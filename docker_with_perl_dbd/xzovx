union selinux_callback {
	/* log the printf-style format and arguments,
	   with the type code indicating the type of message */
	int 
#ifdef __GNUC__
__attribute__ ((format(printf, 2, 3)))
#endif
	(*func_log) (int type, const char *fmt, ...);
	/* store a string representation of auditdata (corresponding
	   to the given security class) into msgbuf. */
	int (*func_audit) (void *auditdata, security_class_t cls,
			   char *msgbuf, size_t msgbufsize);
	/* validate the supplied context, modifying if necessary */
	int (*func_validate) (char **ctx);
	/* netlink callback for setenforce message */
	int (*func_setenforce) (int enforcing);
	/* netlink callback for policyload message */
	int (*func_policyload) (int seqno);
};

#define SELINUX_CB_LOG		0
#define SELINUX_CB_AUDIT	1
#define SELINUX_CB_VALIDATE	2
#define SELINUX_CB_SETENFORCE	3
#define SELINUX_CB_POLICYLOAD	4

extern union selinux_callback selinux_get_callback(int type);
extern void selinux_set_callback(int type, union selinux_callback cb);

	/* Logging type codes, passed to the logging callback */
#define SELINUX_ERROR	        0
#define SELINUX_WARNING		1
#define SELINUX_INFO		2
#define SELINUX_AVC		3
#define SELINUX_POLICYLOAD	4
#define SELINUX_SETENFORCE	5
#define SELINUX_TRANS_DIR	"/var/run/setrans"

/* Compute an access decision. */
extern int security_compute_av(const char * scon,
			       const char * tcon,
			       security_class_t tclass,
			       access_vector_t requested,
			       struct av_decision *avd);
extern int security_compute_av_raw(const char * scon,
				   const char * tcon,
				   security_class_t tclass,
				   access_vector_t requested,
				   struct av_decision *avd);

extern int security_compute_av_flags(const char * scon,
				     const char * tcon,
				     security_class_t tclass,
				     access_vector_t requested,
				     struct av_decision *avd);
extern int security_compute_av_flags_raw(const char * scon,
					 const char * tcon,
					 security_class_t tclass,
					 access_vector_t requested,
					 struct av_decision *avd);

/* Compute a labeling decision and set *newcon to refer to it.
   Caller must free via freecon. */
extern int security_compute_create(const char * scon,
				   const char * tcon,
				   security_class_t tclass,
				   char ** newcon);
extern int security_compute_create_raw(const char * scon,
				       const char * tcon,
				       security_class_t tclass,
				       char ** newcon);
extern int security_compute_create_name(const char * scon,
					const char * tcon,
					security_class_t tclass,
					const char *objname,
					char ** newcon);
extern int security_compute_create_name_raw(const char * scon,
					    const char * tcon,
					    security_class_t tclass,
					    const char *objname,
					    char ** newcon);

/* Compute a relabeling decision and set *newcon to refer to it.
   Caller must free via freecon. */
extern int security_compute_relabel(const char * scon,
				    const char * tcon,
				    security_class_t tclass,
				    char ** newcon);
extern int security_compute_relabel_raw(const char * scon,
					const char * tcon,
					security_class_t tclass,
					char ** newcon);

/* Compute a polyinstantiation member decision and set *newcon to refer to it.
   Caller must free via freecon. */
extern int security_compute_member(const char * scon,
				   const char * tcon,
				   security_class_t tclass,
				   char ** newcon);
extern int security_compute_member_raw(const char * scon,
				       const char * tcon,
				       security_class_t tclass,
				       char ** newcon);

/*
 * Compute the set of reachable user contexts and set *con to refer to
 * the NULL-terminated array of contexts.  Caller must free via freeconary.
 * These interfaces are deprecated.  Use get_ordered_context_list() or
 * one of its variant interfaces instead.
 */
extern int security_compute_user(const char * scon,
				 const char *username,
				 char *** con);
extern int security_compute_user_raw(const char * scon,
				     const char *username,
				     char *** con);

/* Validate a transition. This determines whether a transition from scon to newcon
   using tcon as the target for object class tclass is valid in the loaded policy.
   This checks against the mlsvalidatetrans and validatetrans constraints in the loaded policy.
   Returns 0 if allowed and -1 if an error occurred with errno set */
extern int security_validatetrans(const char *scon,
				  const char *tcon,
				  security_class_t tclass,
				  const char *newcon);
extern int security_validatetrans_raw(const char *scon,
				      const char *tcon,
				      security_class_t tclass,
				      const char *newcon);

/* Load a policy configuration. */
extern int security_load_policy(void *data, size_t len);

/* Get the context of an initial kernel security identifier by name.  
   Caller must free via freecon */
extern int security_get_initial_context(const char *name,
					char ** con);
extern int security_get_initial_context_raw(const char *name,
					    char ** con);

/*
 * Make a policy image and load it.
 * This function provides a higher level interface for loading policy
 * than security_load_policy, internally determining the right policy
 * version, locating and opening the policy file, mapping it into memory,
 * manipulating it as needed for current boolean settings and/or local 
 * definitions, and then calling security_load_policy to load it.
 *
 * 'preservebools' is no longer supported, set to 0.
 */
extern int selinux_mkload_policy(int preservebools);

/* 
 * Perform the initial policy load.
 * This function determines the desired enforcing mode, sets the
 * the *enforce argument accordingly for the caller to use, sets the 
 * SELinux kernel enforcing status to match it, and loads the policy.
 * It also internally handles the initial selinuxfs mount required to
 * perform these actions.
 *
 * The function returns 0 if everything including the policy load succeeds.
 * In this case, init is expected to re-exec itself in order to transition
 * to the proper security context.
 * Otherwise, the function returns -1, and init must check *enforce to
 * determine how to proceed.  If enforcing (*enforce > 0), then init should
 * halt the system.  Otherwise, init may proceed normally without a re-exec.
 */
extern int selinux_init_load_policy(int *enforce);

/* Translate boolean strict to name value pair. */
typedef struct {
	char *name;
	int value;
} SELboolean;
/* save a list of booleans in a single transaction. 'permanent' is no
 * longer supported, set to 0.
 */
extern int security_set_boolean_list(size_t boolcnt,
				     SELboolean * boollist, int permanent);

/* Load policy boolean settings. Deprecated as local policy booleans no
 * longer supported. Will always return -1.
 */
extern int security_load_booleans(char *path)
#ifdef __GNUC__
__attribute__ ((deprecated))
#endif
;

/* Check the validity of a security context. */
extern int security_check_context(const char * con);
extern int security_check_context_raw(const char * con);

/* Canonicalize a security context. */
extern int security_canonicalize_context(const char * con,
					 char ** canoncon);
extern int security_canonicalize_context_raw(const char * con,
					     char ** canoncon);

/* Get the enforce flag value. */
extern int security_getenforce(void);

/* Set the enforce flag value. */
extern int security_setenforce(int value);

/* Get the load-time behavior for undefined classes/permissions */
extern int security_reject_unknown(void);

/* Get the runtime behavior for undefined classes/permissions */
extern int security_deny_unknown(void);

/* Get the checkreqprot value */
extern int security_get_checkreqprot(void);

/* Disable SELinux at runtime (must be done prior to initial policy load). */
extern int security_disable(void);

/* Get the policy version number. */
extern int security_policyvers(void);

/* Get the boolean names */
extern int security_get_boolean_names(char ***names, int *len);

/* Get the pending value for the boolean */
extern int security_get_boolean_pending(const char *name);

/* Get the active value for the boolean */
extern int security_get_boolean_active(const char *name);

/* Set the pending value for the boolean */
extern int security_set_boolean(const char *name, int value);

/* Commit the pending values for the booleans */
extern int security_commit_booleans(void);

/* Userspace class mapping support */
struct security_class_mapping {
	const char *name;
	const char *perms[sizeof(access_vector_t) * 8 + 1];
};

/**
 * selinux_set_mapping - Enable dynamic mapping between integer offsets and security class names
 * @map: array of security_class_mapping structures
 *
 * The core avc_has_perm() API uses integers to represent security
 * classes; previous to the introduction of this function, it was
 * common for userspace object managers to be compiled using generated
 * offsets for a particular policy.  However, that strongly ties the build of the userspace components to a particular policy.
 *
 * By using this function to map between integer offsets and security
 * class names, it's possible to replace a system policies that have
 * at least the same set of security class names as used by the
 * userspace object managers.
 *
 * To correctly use this function, you should override the generated
 * security class defines from the system policy in a local header,
 * starting at 1, and have one security_class_mapping structure entry
 * per define.
 */
extern int selinux_set_mapping(struct security_class_mapping *map);

/* Common helpers */

/* Convert between mode and security class values */
extern security_class_t mode_to_security_class(mode_t mode);
/* Convert between security class values and string names */
extern security_class_t string_to_security_class(const char *name);
extern const char *security_class_to_string(security_class_t cls);

/* Convert between individual access vector permissions and string names */
extern const char *security_av_perm_to_string(security_class_t tclass,
					      access_vector_t perm);
extern access_vector_t string_to_av_perm(security_class_t tclass,
					 const char *name);

/* Returns an access vector in a string representation.  User must free the
 * returned string via free(). */
extern int security_av_string(security_class_t tclass,
			      access_vector_t av, char **result);

/* Display an access vector in a string representation. */
extern void print_access_vector(security_class_t tclass, access_vector_t av);

/* Flush the SELinux class cache, e.g. upon a policy reload. */
extern void selinux_flush_class_cache(void);

/* Set the function used by matchpathcon_init when displaying
   errors about the file_contexts configuration.  If not set,
   then this defaults to fprintf(stderr, fmt, ...). */
extern void set_matchpathcon_printf(void (*f) (const char *fmt, ...));

/* Set the function used by matchpathcon_init when checking the
   validity of a context in the file contexts configuration.  If not set,
   then this defaults to a test based on security_check_context().  
   The function is also responsible for reporting any such error, and
   may include the 'path' and 'lineno' in such error messages. */
extern void set_matchpathcon_invalidcon(int (*f) (const char *path,
						  unsigned lineno,
						  char *context));

/* Same as above, but also allows canonicalization of the context,
   by changing *context to refer to the canonical form.  If not set,
   and invalidcon is also not set, then this defaults to calling
   security_canonicalize_context(). */
extern void set_matchpathcon_canoncon(int (*f) (const char *path,
						unsigned lineno,
						char **context));

/* Set flags controlling operation of matchpathcon_init or matchpathcon. */
#define MATCHPATHCON_BASEONLY 1	/* Only process the base file_contexts file. */
#define MATCHPATHCON_NOTRANS  2	/* Do not perform any context translation. */
#define MATCHPATHCON_VALIDATE 4	/* Validate/canonicalize contexts at init time. */
extern void set_matchpathcon_flags(unsigned int flags);

/* Load the file contexts configuration specified by 'path'
   into memory for use by subsequent matchpathcon calls.  
   If 'path' is NULL, then load the active file contexts configuration,
   i.e. the path returned by selinux_file_context_path().
   Unless the MATCHPATHCON_BASEONLY flag has been set, this
   function also checks for a 'path'.homedirs file and 
   a 'path'.local file and loads additional specifications 
   from them if present. */
extern int matchpathcon_init(const char *path)
#ifdef __GNUC__
   __attribute__ ((deprecated("Use selabel_open with backend SELABEL_CTX_FILE")))
#endif
;

/* Same as matchpathcon_init, but only load entries with
   regexes that have stems that are prefixes of 'prefix'. */
extern int matchpathcon_init_prefix(const char *path, const char *prefix);

/* Free the memory allocated by matchpathcon_init. */
extern void matchpathcon_fini(void)
#ifdef __GNUC__
   __attribute__ ((deprecated("Use selabel_close")))
#endif
;

/* Resolve all of the symlinks and relative portions of a pathname, but NOT
 * the final component (same a realpath() unless the final component is a
 * symlink.  Resolved path must be a path of size PATH_MAX + 1 */
extern int realpath_not_final(const char *name, char *resolved_path);

/* Match the specified pathname and mode against the file contexts
   configuration and set *con to refer to the resulting context.
   'mode' can be 0 to disable mode matching.
   Caller must free via freecon.
   If matchpathcon_init has not already been called, then this function
   will call it upon its first invocation with a NULL path. */
extern int matchpathcon(const char *path,
			mode_t mode, char ** con)
#ifdef __GNUC__
	__attribute__ ((deprecated("Use selabel_lookup instead")))
#endif
;

/* Same as above, but return a specification index for 
   later use in a matchpathcon_filespec_add() call - see below. */
extern int matchpathcon_index(const char *path,
			      mode_t mode, char ** con);

/* Maintain an association between an inode and a specification index,
   and check whether a conflicting specification is already associated
   with the same inode (e.g. due to multiple hard links).  If so, then
   use the latter of the two specifications based on their order in the 
   file contexts configuration.  Return the used specification index. */
extern int matchpathcon_filespec_add(ino_t ino, int specind, const char *file);

/* Destroy any inode associations that have been added, e.g. to restart
   for a new filesystem. */
extern void matchpathcon_filespec_destroy(void);

/* Display statistics on the hash table usage for the associations. */
extern void matchpathcon_filespec_eval(void);

/* Check to see whether any specifications had no matches and report them.
   The 'str' is used as a prefix for any warning messages. */
extern void matchpathcon_checkmatches(char *str);

/* Match the specified media and against the media contexts 
   configuration and set *con to refer to the resulting context.
   Caller must free con via freecon. */
extern int matchmediacon(const char *media, char ** con);

/*
  selinux_getenforcemode reads the /etc/selinux/config file and determines 
  whether the machine should be started in enforcing (1), permissive (0) or 
  disabled (-1) mode.
 */
extern int selinux_getenforcemode(int *enforce);

/*
  selinux_boolean_sub reads the /etc/selinux/TYPE/booleans.subs_dist file
  looking for a record with boolean_name.  If a record exists selinux_boolean_sub
  returns the translated name otherwise it returns the original name.
  The returned value needs to be freed. On failure NULL will be returned.
 */
extern char *selinux_boolean_sub(const char *boolean_name);

/*
  selinux_getpolicytype reads the /etc/selinux/config file and determines 
  what the default policy for the machine is.  Calling application must 
  free policytype.
 */
extern int selinux_getpolicytype(char **policytype);

/*
  selinux_policy_root reads the /etc/selinux/config file and returns 
  the directory path under which the compiled policy file and context 
  configuration files exist.
 */
extern const char *selinux_policy_root(void);

/*
  selinux_set_policy_root sets an alternate policy root directory path under
  which the compiled policy file and context configuration files exist.
 */
extern int selinux_set_policy_root(const char *rootpath);

/* These functions return the paths to specific files under the 
   policy root directory. */
extern const char *selinux_current_policy_path(void);
extern const char *selinux_binary_policy_path(void);
extern const char *selinux_failsafe_context_path(void);
extern const char *selinux_removable_context_path(void);
extern const char *selinux_default_context_path(void);
extern const char *selinux_user_contexts_path(void);
extern const char *selinux_file_context_path(void);
extern const char *selinux_file_context_homedir_path(void);
extern const char *selinux_file_context_local_path(void);
extern const char *selinux_file_context_subs_path(void);
extern const char *selinux_file_context_subs_dist_path(void);
extern const char *selinux_homedir_context_path(void);
extern const char *selinux_media_context_path(void);
extern const char *selinux_virtual_domain_context_path(void);
extern const char *selinux_virtual_image_context_path(void);
extern const char *selinux_lxc_contexts_path(void);
extern const char *selinux_x_context_path(void);
extern const char *selinux_sepgsql_context_path(void);
extern const char *selinux_openrc_contexts_path(void);
extern const char *selinux_openssh_contexts_path(void);
extern const char *selinux_snapperd_contexts_path(void);
extern const char *selinux_systemd_contexts_path(void);
extern const char *selinux_contexts_path(void);
extern const char *selinux_securetty_types_path(void);
extern const char *selinux_booleans_subs_path(void);
/* Deprecated as local policy booleans no longer supported. */
extern const char *selinux_booleans_path(void)
#ifdef __GNUC__
__attribute__ ((deprecated))
#endif
;
extern const char *selinux_customizable_types_path(void);
/* Deprecated as policy ./users no longer supported. */
extern const char *selinux_users_path(void)
#ifdef __GNUC__
__attribute__ ((deprecated))
#endif
;
extern const char *selinux_usersconf_path(void);
extern const char *selinux_translations_path(void);
extern const char *selinux_colors_path(void);
extern const char *selinux_netfilter_context_path(void);
extern const char *selinux_path(void);

/**
 * selinux_check_access - Check permissions and perform appropriate auditing.
 * @scon: source security context
 * @tcon: target security context
 * @tclass: target security class string
 * @perm: requested permissions string, interpreted based on @tclass
 * @auditdata: auxiliary audit data
 *
 * Check the AVC to determine whether the @perm permissions are granted
 * for the SID pair (@scon, @tcon), interpreting the permissions
 * based on @tclass.
 * Return %0 if all @perm permissions are granted, -%1 with 
 * @errno set to %EACCES if any permissions are denied or to another 
 * value upon other errors.
 * If auditing or logging is configured the appropriate callbacks will be called
 * and passed the auditdata field
 */
extern int selinux_check_access(const char * scon, const char * tcon, const char *tclass, const char *perm, void *auditdata);

/* Check a permission in the passwd class.
   Return 0 if granted or -1 otherwise. */
extern int selinux_check_passwd_access(access_vector_t requested)
#ifdef __GNUC__
  __attribute__ ((deprecated("Use selinux_check_access")))
#endif
;

extern int checkPasswdAccess(access_vector_t requested)
#ifdef __GNUC__
   __attribute__ ((deprecated("Use selinux_check_access")))
#endif
;

/* Check if the tty_context is defined as a securetty
   Return 0 if secure, < 0 otherwise. */
extern int selinux_check_securetty_context(const char * tty_context);

/* Set the path to the selinuxfs mount point explicitly.
   Normally, this is determined automatically during libselinux 
   initialization, but this is not always possible, e.g. for /sbin/init
   which performs the initial mount of selinuxfs. */
extern void set_selinuxmnt(const char *mnt);

/* Check if selinuxfs exists as a kernel filesystem */
extern int selinuxfs_exists(void);

/* clear selinuxmnt variable and free allocated memory */
extern void fini_selinuxmnt(void);

/* Set an appropriate security context based on the filename of a helper
 * program, falling back to a new context with the specified type. */
extern int setexecfilecon(const char *filename, const char *fallback_type);

#ifndef DISABLE_RPM
/* Execute a helper for rpm in an appropriate security context. */
extern int rpm_execcon(unsigned int verified,
		       const char *filename,
		       char *const argv[], char *const envp[])
#ifdef __GNUC__
	__attribute__((deprecated("Use setexecfilecon and execve")))
#endif
;
#endif

/* Returns whether a file context is customizable, and should not 
   be relabeled . */
extern int is_context_customizable(const char * scontext);

/* Perform context translation between the human-readable format
   ("translated") and the internal system format ("raw"). 
   Caller must free the resulting context via freecon.  
   Returns -1 upon an error or 0 otherwise.
   If passed NULL, sets the returned context to NULL and returns 0. */
extern int selinux_trans_to_raw_context(const char * trans,
					char ** rawp);
extern int selinux_raw_to_trans_context(const char * raw,
					char ** transp);

/* Perform context translation between security contexts
   and display colors.  Returns a space-separated list of ten
   ten hex RGB triples prefixed by hash marks, e.g. "#ff0000".
   Caller must free the resulting string via free.
   Returns -1 upon an error or 0 otherwise. */
extern int selinux_raw_context_to_color(const char * raw,
					char **color_str);

/* Get the SELinux username and level to use for a given Linux username. 
   These values may then be passed into the get_ordered_context_list*
   and get_default_context* functions to obtain a context for the user.
   Returns 0 on success or -1 otherwise.
   Caller must free the returned strings via free. */
extern int getseuserbyname(const char *linuxuser, char **seuser, char **level);

/* Get the SELinux username and level to use for a given Linux username and service. 
   These values may then be passed into the get_ordered_context_list*
   and get_default_context* functions to obtain a context for the user.
   Returns 0 on success or -1 otherwise.
   Caller must free the returned strings via free. */
extern int getseuser(const char *username, const char *service, 
		     char **r_seuser, char **r_level);

/* Compare two file contexts, return 0 if equivalent. */
extern int selinux_file_context_cmp(const char * a,
			     const char * b);

/* 
 * Verify the context of the file 'path' against policy.
 * Return 1 if match, 0 if not and -1 on error.
 */
extern int selinux_file_context_verify(const char *path, mode_t mode);

/* This function sets the file context on to the system defaults returns 0 on success */
extern int selinux_lsetfilecon_default(const char *path);

/* 
 * Force a reset of the loaded configuration
 * WARNING: This is not thread safe. Be very sure that no other threads
 * are calling into libselinux when this is called.
 */
extern void selinux_reset_config(void);

#ifdef __cplusplus
}
#endif
#endif
                                                                                                                                                                                                                                                                                         usr/include/semaphore.h                                                                             0000644 0000000 0000000 00000006610 14711146254 013644  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* Copyright (C) 2002-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */

#ifndef _SEMAPHORE_H
#define _SEMAPHORE_H	1

#include <features.h>
#include <sys/types.h>
#ifdef __USE_XOPEN2K
# include <bits/types/struct_timespec.h>
#endif

/* Get the definition for sem_t.  */
#include <bits/semaphore.h>


__BEGIN_DECLS

/* Initialize semaphore object SEM to VALUE.  If PSHARED then share it
   with other processes.  */
extern int sem_init (sem_t *__sem, int __pshared, unsigned int __value)
  __THROW __nonnull ((1));

/* Free resources associated with semaphore object SEM.  */
extern int sem_destroy (sem_t *__sem) __THROW __nonnull ((1));

/* Open a named semaphore NAME with open flags OFLAG.  */
extern sem_t *sem_open (const char *__name, int __oflag, ...)
  __THROW __nonnull ((1));

/* Close descriptor for named semaphore SEM.  */
extern int sem_close (sem_t *__sem) __THROW __nonnull ((1));

/* Remove named semaphore NAME.  */
extern int sem_unlink (const char *__name) __THROW __nonnull ((1));

/* Wait for SEM being posted.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int sem_wait (sem_t *__sem) __nonnull ((1));

#ifdef __USE_XOPEN2K
/* Similar to `sem_wait' but wait only until ABSTIME.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
# ifndef __USE_TIME_BITS64
extern int sem_timedwait (sem_t *__restrict __sem,
			  const struct timespec *__restrict __abstime)
  __nonnull ((1, 2));
# else
#  ifdef __REDIRECT
extern int __REDIRECT (sem_timedwait,
                       (sem_t *__restrict __sem,
                        const struct timespec *__restrict __abstime),
                        __sem_timedwait64)
  __nonnull ((1, 2));
#  else
#   define sem_timedwait __sem_timedwait64
#  endif
# endif
#endif

#ifdef __USE_GNU
# ifndef __USE_TIME_BITS64
extern int sem_clockwait (sem_t *__restrict __sem,
			  clockid_t clock,
			  const struct timespec *__restrict __abstime)
  __nonnull ((1, 3));
# else
#  ifdef __REDIRECT
extern int __REDIRECT (sem_clockwait,
                       (sem_t *__restrict __sem,
                        clockid_t clock,
                        const struct timespec *__restrict __abstime),
                        __sem_clockwait64)
  __nonnull ((1, 3));
#  else
#   define sem_clockwait __sem_clockwait64
#  endif
# endif
#endif

/* Test whether SEM is posted.  */
extern int sem_trywait (sem_t *__sem) __THROWNL __nonnull ((1));

/* Post SEM.  */
extern int sem_post (sem_t *__sem) __THROWNL __nonnull ((1));

/* Get current value of SEM and store it in *SVAL.  */
extern int sem_getvalue (sem_t *__restrict __sem, int *__restrict __sval)
  __THROW __nonnull ((1, 2));


__END_DECLS

#endif	/* semaphore.h */
                                                                                                                        usr/include/sepol/                                                                                  0000755 0000000 0000000 00000000000 14714557563 012643  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/include/sepol/boolean_record.h                                                                  0000644 0000000 0000000 00000003017 14433421167 015756  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef _SEPOL_BOOLEAN_RECORD_H_
#define _SEPOL_BOOLEAN_RECORD_H_

#include <stddef.h>
#include <sepol/handle.h>

#ifdef __cplusplus
extern "C" {
#endif

struct sepol_bool;
struct sepol_bool_key;
typedef struct sepol_bool sepol_bool_t;
typedef struct sepol_bool_key sepol_bool_key_t;

/* Key */
extern int sepol_bool_key_create(sepol_handle_t * handle,
				 const char *name, sepol_bool_key_t ** key);

extern void sepol_bool_key_unpack(const sepol_bool_key_t * key,
				  const char **name);

extern int sepol_bool_key_extract(sepol_handle_t * handle,
				  const sepol_bool_t * boolean,
				  sepol_bool_key_t ** key_ptr);

extern void sepol_bool_key_free(sepol_bool_key_t * key);

extern int sepol_bool_compare(const sepol_bool_t * boolean,
			      const sepol_bool_key_t * key);

extern int sepol_bool_compare2(const sepol_bool_t * boolean,
			       const sepol_bool_t * boolean2);

/* Name */
extern const char *sepol_bool_get_name(const sepol_bool_t * boolean);

extern int sepol_bool_set_name(sepol_handle_t * handle,
			       sepol_bool_t * boolean, const char *name);

/* Value */
extern int sepol_bool_get_value(const sepol_bool_t * boolean);

extern void sepol_bool_set_value(sepol_bool_t * boolean, int value);

/* Create/Clone/Destroy */
extern int sepol_bool_create(sepol_handle_t * handle, sepol_bool_t ** bool_ptr);

extern int sepol_bool_clone(sepol_handle_t * handle,
			    const sepol_bool_t * boolean,
			    sepol_bool_t ** bool_ptr);

extern void sepol_bool_free(sepol_bool_t * boolean);

#ifdef __cplusplus
}
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 usr/include/sepol/booleans.h                                                                        0000644 0000000 0000000 00000002457 14433421167 014612  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef _SEPOL_BOOLEANS_H_
#define _SEPOL_BOOLEANS_H_

#include <stddef.h>
#include <sepol/policydb.h>
#include <sepol/boolean_record.h>
#include <sepol/handle.h>

#ifdef __cplusplus
extern "C" {
#endif

/* Set the specified boolean */
extern int sepol_bool_set(sepol_handle_t * handle,
			  sepol_policydb_t * policydb,
			  const sepol_bool_key_t * key,
			  const sepol_bool_t * data);

/* Return the number of booleans */
extern int sepol_bool_count(sepol_handle_t * handle,
			    const sepol_policydb_t * p, unsigned int *response);

/* Check if the specified boolean exists */
extern int sepol_bool_exists(sepol_handle_t * handle,
			     const sepol_policydb_t * policydb,
			     const sepol_bool_key_t * key, int *response);

/* Query a boolean - returns the boolean, or NULL if not found */
extern int sepol_bool_query(sepol_handle_t * handle,
			    const sepol_policydb_t * p,
			    const sepol_bool_key_t * key,
			    sepol_bool_t ** response);

/* Iterate the booleans
 * The handler may return:
 * -1 to signal an error condition,
 * 1 to signal successful exit
 * 0 to signal continue */

extern int sepol_bool_iterate(sepol_handle_t * handle,
			      const sepol_policydb_t * policydb,
			      int (*fn) (const sepol_bool_t * boolean,
					 void *fn_arg), void *arg);

#ifdef __cplusplus
}
#endif

#endif
                                                                                                                                                                                                                 usr/include/sepol/cil/                                                                              0000755 0000000 0000000 00000000000 14714557563 013412  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/include/sepol/cil/cil.h                                                                         0000644 0000000 0000000 00000007261 14433421167 014324  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright 2011 Tresys Technology, LLC. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *    1. Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 * 
 *    2. Redistributions in binary form must reproduce the above copyright notice,
 *       this list of conditions and the following disclaimer in the documentation
 *       and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY TRESYS TECHNOLOGY, LLC ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 * EVENT SHALL TRESYS TECHNOLOGY, LLC OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * The views and conclusions contained in the software and documentation are those
 * of the authors and should not be interpreted as representing official policies,
 * either expressed or implied, of Tresys Technology, LLC.
 */

#ifndef CIL_H_
#define CIL_H_

#include <sepol/policydb/policydb.h>

#ifdef __cplusplus
extern "C" {
#endif

struct cil_db;
typedef struct cil_db cil_db_t;

extern void cil_db_init(cil_db_t **db);
extern void cil_db_destroy(cil_db_t **db);

extern int cil_add_file(cil_db_t *db, const char *name, const char *data, size_t size);

extern int cil_compile(cil_db_t *db);
extern int cil_build_policydb(cil_db_t *db, sepol_policydb_t **sepol_db);
extern int cil_userprefixes_to_string(cil_db_t *db, char **out, size_t *size);
extern int cil_selinuxusers_to_string(cil_db_t *db, char **out, size_t *size);
extern int cil_filecons_to_string(cil_db_t *db, char **out, size_t *size);
extern void cil_set_disable_dontaudit(cil_db_t *db, int disable_dontaudit);
extern void cil_set_multiple_decls(cil_db_t *db, int multiple_decls);
extern void cil_set_qualified_names(struct cil_db *db, int qualified_names);
extern void cil_set_disable_neverallow(cil_db_t *db, int disable_neverallow);
extern void cil_set_preserve_tunables(cil_db_t *db, int preserve_tunables);
extern int cil_set_handle_unknown(cil_db_t *db, int handle_unknown);
extern void cil_set_mls(cil_db_t *db, int mls);
extern void cil_set_attrs_expand_generated(struct cil_db *db, int attrs_expand_generated);
extern void cil_set_attrs_expand_size(struct cil_db *db, unsigned attrs_expand_size);
extern void cil_set_target_platform(cil_db_t *db, int target_platform);
extern void cil_set_policy_version(cil_db_t *db, int policy_version);
extern void cil_write_policy_conf(FILE *out, struct cil_db *db);
extern int cil_write_parse_ast(FILE *out, cil_db_t *db);
extern int cil_write_build_ast(FILE *out, cil_db_t *db);
extern int cil_write_resolve_ast(FILE *out, cil_db_t *db);

enum cil_log_level {
	CIL_ERR = 1,
	CIL_WARN,
	CIL_INFO
};
extern void cil_set_log_level(enum cil_log_level lvl);
extern void cil_set_log_handler(void (*handler)(int lvl, const char *msg));

#ifdef __GNUC__
__attribute__ ((format(printf, 2, 3)))
#endif
extern void cil_log(enum cil_log_level lvl, const char *msg, ...);

extern void cil_set_malloc_error_handler(void (*handler)(void));

#ifdef __cplusplus
}
#endif
#endif
                                                                                                                                                                                                                                                                                                                                               usr/include/sepol/context.h                                                                         0000644 0000000 0000000 00000001360 14433421167 014464  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef _SEPOL_CONTEXT_H_
#define _SEPOL_CONTEXT_H_

#include <sepol/context_record.h>
#include <sepol/policydb.h>
#include <sepol/handle.h>

#ifdef __cplusplus
extern "C" {
#endif

/* -- Deprecated -- */

extern int sepol_check_context(const char *context);

/* -- End deprecated -- */

extern int sepol_context_check(sepol_handle_t * handle,
			       const sepol_policydb_t * policydb,
			       const sepol_context_t * context);

extern int sepol_mls_contains(sepol_handle_t * handle,
			      const sepol_policydb_t * policydb,
			      const char *mls1,
			      const char *mls2, int *response);

extern int sepol_mls_check(sepol_handle_t * handle,
			   const sepol_policydb_t * policydb, const char *mls);

#ifdef __cplusplus
}
#endif

#endif
                                                                                                                                                                                                                                                                                usr/include/sepol/context_record.h                                                                  0000644 0000000 0000000 00000003206 14433421167 016023  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef _SEPOL_CONTEXT_RECORD_H_
#define _SEPOL_CONTEXT_RECORD_H_

#include <sepol/handle.h>

#ifdef __cplusplus
extern "C" {
#endif

struct sepol_context;
typedef struct sepol_context sepol_context_t;

/* We don't need a key, because the context is never stored
 * in a data collection by itself */

/* User */
extern const char *sepol_context_get_user(const sepol_context_t * con);

extern int sepol_context_set_user(sepol_handle_t * handle,
				  sepol_context_t * con, const char *user);

/* Role */
extern const char *sepol_context_get_role(const sepol_context_t * con);

extern int sepol_context_set_role(sepol_handle_t * handle,
				  sepol_context_t * con, const char *role);

/* Type */
extern const char *sepol_context_get_type(const sepol_context_t * con);

extern int sepol_context_set_type(sepol_handle_t * handle,
				  sepol_context_t * con, const char *type);

/* MLS */
extern const char *sepol_context_get_mls(const sepol_context_t * con);

extern int sepol_context_set_mls(sepol_handle_t * handle,
				 sepol_context_t * con, const char *mls_range);

/* Create/Clone/Destroy */
extern int sepol_context_create(sepol_handle_t * handle,
				sepol_context_t ** con_ptr);

extern int sepol_context_clone(sepol_handle_t * handle,
			       const sepol_context_t * con,
			       sepol_context_t ** con_ptr);

extern void sepol_context_free(sepol_context_t * con);

/* Parse to/from string */
extern int sepol_context_from_string(sepol_handle_t * handle,
				     const char *str, sepol_context_t ** con);

extern int sepol_context_to_string(sepol_handle_t * handle,
				   const sepol_context_t * con, char **str_ptr);

#ifdef __cplusplus
}
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                          usr/include/sepol/debug.h                                                                           0000644 0000000 0000000 00000001717 14433421167 014074  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef _SEPOL_DEBUG_H_
#define _SEPOL_DEBUG_H_

#include <sepol/handle.h>

#ifdef __cplusplus
extern "C" {
