uregex_useAnchoringBounds(URegularExpression   *regexp,
                          UBool                 b,
                          UErrorCode           *status);

/**
  * Return true if the most recent matching operation touched the
  *  end of the text being processed.  In this case, additional input text could
  *  change the results of that match.
  *
  *  @param regexp The compiled regular expression.
  *  @param status A pointer to a UErrorCode to receive any errors.
  *  @return  true if the most recent match hit the end of input
  *  @stable ICU 4.0
  */
U_CAPI UBool U_EXPORT2
uregex_hitEnd(const  URegularExpression   *regexp,
                     UErrorCode           *status);

/**
  * Return true the most recent match succeeded and additional input could cause
  * it to fail. If this function returns false and a match was found, then more input
  * might change the match but the match won't be lost. If a match was not found,
  * then requireEnd has no meaning.
  *
  * @param regexp The compiled regular expression.
  * @param status A pointer to a UErrorCode to receive any errors.
  * @return true  if more input could cause the most recent match to no longer match.
  * @stable ICU 4.0
  */
U_CAPI UBool U_EXPORT2   
uregex_requireEnd(const  URegularExpression   *regexp,
                         UErrorCode           *status);





/**
  *    Replaces every substring of the input that matches the pattern
  *    with the given replacement string.  This is a convenience function that
  *    provides a complete find-and-replace-all operation.
  *
  *    This method scans the input string looking for matches of the pattern. 
  *    Input that is not part of any match is copied unchanged to the
  *    destination buffer.  Matched regions are replaced in the output
  *    buffer by the replacement string.   The replacement string may contain
  *    references to capture groups; these take the form of $1, $2, etc.
  *
  *    @param   regexp             The compiled regular expression.
  *    @param   replacementText    A string containing the replacement text.
  *    @param   replacementLength  The length of the replacement string, or
  *                                -1 if it is NUL terminated.
  *    @param   destBuf            A (UChar *) buffer that will receive the result.
  *    @param   destCapacity       The capacity of the destination buffer.
  *    @param   status             A reference to a UErrorCode to receive any errors.
  *    @return                     The length of the string resulting from the find
  *                                and replace operation.  In the event that the
  *                                destination capacity is inadequate, the return value
  *                                is still the full length of the untruncated string.
  *    @stable ICU 3.0
  */
U_CAPI int32_t U_EXPORT2 
uregex_replaceAll(URegularExpression    *regexp,
                  const UChar           *replacementText,
                  int32_t                replacementLength,
                  UChar                 *destBuf,
                  int32_t                destCapacity,
                  UErrorCode            *status);

/**
  *    Replaces every substring of the input that matches the pattern
  *    with the given replacement string.  This is a convenience function that
  *    provides a complete find-and-replace-all operation.
  *
  *    This method scans the input string looking for matches of the pattern. 
  *    Input that is not part of any match is copied unchanged to the
  *    destination buffer.  Matched regions are replaced in the output
  *    buffer by the replacement string.   The replacement string may contain
  *    references to capture groups; these take the form of $1, $2, etc.
  *
  *    @param   regexp         The compiled regular expression.
  *    @param   replacement    A string containing the replacement text.
  *    @param   dest           A mutable UText that will receive the result.
  *                             If NULL, a new UText will be created (which may not be mutable).
  *    @param   status         A reference to a UErrorCode to receive any errors.
  *    @return                 A UText containing the results of the find and replace.
  *                             If a pre-allocated UText was provided, it will always be used and returned.
  *
  *    @stable ICU 4.6
  */
U_CAPI UText * U_EXPORT2 
uregex_replaceAllUText(URegularExpression *regexp,
                       UText              *replacement,
                       UText              *dest,
                       UErrorCode         *status);

/**
  *    Replaces the first substring of the input that matches the pattern
  *    with the given replacement string.  This is a convenience function that
  *    provides a complete find-and-replace operation.
  *
  *    This method scans the input string looking for a match of the pattern. 
  *    All input that is not part of the match is copied unchanged to the
  *    destination buffer.  The matched region is replaced in the output
  *    buffer by the replacement string.   The replacement string may contain
  *    references to capture groups; these take the form of $1, $2, etc.
  *
  *    @param   regexp             The compiled regular expression.
  *    @param   replacementText    A string containing the replacement text.
  *    @param   replacementLength  The length of the replacement string, or
  *                                -1 if it is NUL terminated.
  *    @param   destBuf            A (UChar *) buffer that will receive the result.
  *    @param   destCapacity       The capacity of the destination buffer.
  *    @param   status             a reference to a UErrorCode to receive any errors.
  *    @return                     The length of the string resulting from the find
  *                                and replace operation.  In the event that the
  *                                destination capacity is inadequate, the return value
  *                                is still the full length of the untruncated string.
  *    @stable ICU 3.0
  */
U_CAPI int32_t U_EXPORT2 
uregex_replaceFirst(URegularExpression  *regexp,
                    const UChar         *replacementText,
                    int32_t              replacementLength,
                    UChar               *destBuf,
                    int32_t              destCapacity,
                    UErrorCode          *status);

/**
  *    Replaces the first substring of the input that matches the pattern
  *    with the given replacement string.  This is a convenience function that
  *    provides a complete find-and-replace operation.
  *
  *    This method scans the input string looking for a match of the pattern. 
  *    All input that is not part of the match is copied unchanged to the
  *    destination buffer.  The matched region is replaced in the output
  *    buffer by the replacement string.   The replacement string may contain
  *    references to capture groups; these take the form of $1, $2, etc.
  *
  *    @param   regexp         The compiled regular expression.
  *    @param   replacement    A string containing the replacement text.
  *    @param   dest           A mutable UText that will receive the result.
  *                             If NULL, a new UText will be created (which may not be mutable).
  *    @param   status         A reference to a UErrorCode to receive any errors.
  *    @return                 A UText containing the results of the find and replace.
  *                             If a pre-allocated UText was provided, it will always be used and returned.
  *
  *    @stable ICU 4.6
  */
U_CAPI UText * U_EXPORT2 
uregex_replaceFirstUText(URegularExpression *regexp,
                         UText              *replacement,
                         UText              *dest,
                         UErrorCode         *status);

/**
  *   Implements a replace operation intended to be used as part of an
  *   incremental find-and-replace.
  *
  *   <p>The input string, starting from the end of the previous match and ending at
  *   the start of the current match, is appended to the destination string.  Then the
  *   replacement string is appended to the output string,
  *   including handling any substitutions of captured text.</p>
  *
  *   <p>A note on preflight computation of buffersize and error handling:
  *   Calls to uregex_appendReplacement() and uregex_appendTail() are
  *   designed to be chained, one after another, with the destination
  *   buffer pointer and buffer capacity updated after each in preparation
  *   to for the next.  If the destination buffer is exhausted partway through such a
  *   sequence, a U_BUFFER_OVERFLOW_ERROR status will be returned.  Normal
  *   ICU conventions are for a function to perform no action if it is
  *   called with an error status, but for this one case, uregex_appendRepacement()
  *   will operate normally so that buffer size computations will complete
  *   correctly.
  *
  *   <p>For simple, prepackaged, non-incremental find-and-replace
  *      operations, see replaceFirst() or replaceAll().</p>
  *
  *   @param   regexp      The regular expression object.  
  *   @param   replacementText The string that will replace the matched portion of the
  *                        input string as it is copied to the destination buffer.
  *                        The replacement text may contain references ($1, for
  *                        example) to capture groups from the match.
  *   @param   replacementLength  The length of the replacement text string,
  *                        or -1 if the string is NUL terminated.
  *   @param   destBuf     The buffer into which the results of the
  *                        find-and-replace are placed.  On return, this pointer
  *                        will be updated to refer to the beginning of the
  *                        unused portion of buffer, leaving it in position for
  *                        a subsequent call to this function.
  *   @param   destCapacity The size of the output buffer,  On return, this
  *                        parameter will be updated to reflect the space remaining
  *                        unused in the output buffer.
  *   @param   status      A reference to a UErrorCode to receive any errors. 
  *   @return              The length of the result string.  In the event that
  *                        destCapacity is inadequate, the full length of the
  *                        untruncated output string is returned.
  *
  *   @stable ICU 3.0
  *
  */
U_CAPI int32_t U_EXPORT2 
uregex_appendReplacement(URegularExpression    *regexp,
                         const UChar           *replacementText,
                         int32_t                replacementLength,
                         UChar                **destBuf,
                         int32_t               *destCapacity,
                         UErrorCode            *status);

/**
  *   Implements a replace operation intended to be used as part of an
  *   incremental find-and-replace.
  *
  *   <p>The input string, starting from the end of the previous match and ending at
  *   the start of the current match, is appended to the destination string.  Then the
  *   replacement string is appended to the output string,
  *   including handling any substitutions of captured text.</p>
  *
  *   <p>For simple, prepackaged, non-incremental find-and-replace
  *      operations, see replaceFirst() or replaceAll().</p>
  *
  *   @param   regexp      The regular expression object.  
  *   @param   replacementText The string that will replace the matched portion of the
  *                        input string as it is copied to the destination buffer.
  *                        The replacement text may contain references ($1, for
  *                        example) to capture groups from the match.
  *   @param   dest        A mutable UText that will receive the result. Must not be NULL.
  *   @param   status      A reference to a UErrorCode to receive any errors. 
  *
  *   @stable ICU 4.6
  */
U_CAPI void U_EXPORT2 
uregex_appendReplacementUText(URegularExpression    *regexp,
                              UText                 *replacementText,
                              UText                 *dest,
                              UErrorCode            *status);

/**
  * As the final step in a find-and-replace operation, append the remainder
  * of the input string, starting at the position following the last match,
  * to the destination string. <code>uregex_appendTail()</code> is intended 
  *  to be invoked after one or more invocations of the
  *  <code>uregex_appendReplacement()</code> function.
  *
  *   @param   regexp      The regular expression object.  This is needed to 
  *                        obtain the input string and with the position
  *                        of the last match within it.
  *   @param   destBuf     The buffer in which the results of the
  *                        find-and-replace are placed.  On return, the pointer
  *                        will be updated to refer to the beginning of the
  *                        unused portion of buffer.
  *   @param   destCapacity The size of the output buffer,  On return, this
  *                        value will be updated to reflect the space remaining
  *                        unused in the output buffer.
  *   @param   status      A reference to a UErrorCode to receive any errors. 
  *   @return              The length of the result string.  In the event that
  *                        destCapacity is inadequate, the full length of the
  *                        untruncated output string is returned.
  *
  *   @stable ICU 3.0
  */
U_CAPI int32_t U_EXPORT2 
uregex_appendTail(URegularExpression    *regexp,
                  UChar                **destBuf,
                  int32_t               *destCapacity,
                  UErrorCode            *status);

/**
  * As the final step in a find-and-replace operation, append the remainder
  * of the input string, starting at the position following the last match,
  * to the destination string. <code>uregex_appendTailUText()</code> is intended 
  *  to be invoked after one or more invocations of the
  *  <code>uregex_appendReplacementUText()</code> function.
  *
  *   @param   regexp      The regular expression object.  This is needed to 
  *                        obtain the input string and with the position
  *                        of the last match within it.
  *   @param   dest        A mutable UText that will receive the result. Must not be NULL.
  *
  *   @param status        Error code
  *
  *   @return              The destination UText.
  *
  *   @stable ICU 4.6
  */
U_CAPI UText * U_EXPORT2 
uregex_appendTailUText(URegularExpression    *regexp,
                       UText                 *dest,
                       UErrorCode            *status);

 /**
   * Split a string into fields.  Somewhat like split() from Perl.
   *  The pattern matches identify delimiters that separate the input
   *  into fields.  The input data between the matches becomes the
   *  fields themselves.
   *
   *  Each of the fields is copied from the input string to the destination
   *  buffer, and NUL terminated.  The position of each field within
   *  the destination buffer is returned in the destFields array.
   *
   *  If the delimiter pattern includes capture groups, the captured text will
   *  also appear in the destination array of output strings, interspersed
   *  with the fields.  This is similar to Perl, but differs from Java, 
   *  which ignores the presence of capture groups in the pattern.
   * 
   *  Trailing empty fields will always be returned, assuming sufficient
   *  destination capacity.  This differs from the default behavior for Java
   *  and Perl where trailing empty fields are not returned.
   *
   *  The number of strings produced by the split operation is returned.
   *  This count includes the strings from capture groups in the delimiter pattern.
   *  This behavior differs from Java, which ignores capture groups.
   * 
   *    @param   regexp      The compiled regular expression.
   *    @param   destBuf     A (UChar *) buffer to receive the fields that
   *                         are extracted from the input string. These
   *                         field pointers will refer to positions within the
   *                         destination buffer supplied by the caller.  Any
   *                         extra positions within the destFields array will be
   *                         set to NULL.
   *    @param   destCapacity The capacity of the destBuf.
   *    @param   requiredCapacity  The actual capacity required of the destBuf.
   *                         If destCapacity is too small, requiredCapacity will return 
   *                         the total capacity required to hold all of the output, and
   *                         a U_BUFFER_OVERFLOW_ERROR will be returned.
   *    @param   destFields  An array to be filled with the position of each
   *                         of the extracted fields within destBuf.
   *    @param   destFieldsCapacity  The number of elements in the destFields array.
   *                If the number of fields found is less than destFieldsCapacity,
   *                the extra destFields elements are set to zero.
   *                If destFieldsCapacity is too small, the trailing part of the
   *                input, including any field delimiters, is treated as if it
   *                were the last field - it is copied to the destBuf, and
   *                its position is in the destBuf is stored in the last element
   *                of destFields.  This behavior mimics that of Perl.  It is not
   *                an error condition, and no error status is returned when all destField
   *                positions are used.
   * @param status  A reference to a UErrorCode to receive any errors.
   * @return        The number of fields into which the input string was split.
   * @stable ICU 3.0
   */
U_CAPI int32_t U_EXPORT2 
uregex_split(   URegularExpression      *regexp,
                  UChar                 *destBuf,
                  int32_t                destCapacity,
                  int32_t               *requiredCapacity,
                  UChar                 *destFields[],
                  int32_t                destFieldsCapacity,
                  UErrorCode            *status);

  /**
   * Split a string into fields.  Somewhat like split() from Perl.
   * The pattern matches identify delimiters that separate the input
   *  into fields.  The input data between the matches becomes the
   *  fields themselves.
   * <p>
   * The behavior of this function is not very closely aligned with uregex_split();
   * instead, it is based on (and implemented directly on top of) the C++ split method.
   *
   * @param regexp  The compiled regular expression.
   * @param destFields    An array of mutable UText structs to receive the results of the split.
   *                If a field is NULL, a new UText is allocated to contain the results for
   *                that field. This new UText is not guaranteed to be mutable.
   * @param destFieldsCapacity  The number of elements in the destination array.
   *                If the number of fields found is less than destCapacity, the
   *                extra strings in the destination array are not altered.
   *                If the number of destination strings is less than the number
   *                of fields, the trailing part of the input string, including any
   *                field delimiters, is placed in the last destination string.
   *                This behavior mimics that of Perl.  It is not  an error condition, and no
   *                error status is returned when all destField positions are used.
   * @param status  A reference to a UErrorCode to receive any errors.
   * @return        The number of fields into which the input string was split.
   *
   * @stable ICU 4.6
   */
U_CAPI int32_t U_EXPORT2 
uregex_splitUText(URegularExpression    *regexp,
                  UText                 *destFields[],
                  int32_t                destFieldsCapacity,
                  UErrorCode            *status);

/**
 * Set a processing time limit for match operations with this URegularExpression.
 *
 * Some patterns, when matching certain strings, can run in exponential time.
 * For practical purposes, the match operation may appear to be in an
 * infinite loop.
 * When a limit is set a match operation will fail with an error if the
 * limit is exceeded.
 * <p>
 * The units of the limit are steps of the match engine.
 * Correspondence with actual processor time will depend on the speed
 * of the processor and the details of the specific pattern, but will
 * typically be on the order of milliseconds.
 * <p>
 * By default, the matching time is not limited.
 * <p>
 *
 * @param   regexp      The compiled regular expression.
 * @param   limit       The limit value, or 0 for no limit.
 * @param   status      A reference to a UErrorCode to receive any errors.
 * @stable ICU 4.0
 */
U_CAPI void U_EXPORT2
uregex_setTimeLimit(URegularExpression      *regexp,
                    int32_t                  limit,
                    UErrorCode              *status);

/**
 * Get the time limit for for matches with this URegularExpression.
 * A return value of zero indicates that there is no limit.
 *
 * @param   regexp      The compiled regular expression.
 * @param   status      A reference to a UErrorCode to receive any errors.
 * @return the maximum allowed time for a match, in units of processing steps.
 * @stable ICU 4.0
 */
U_CAPI int32_t U_EXPORT2
uregex_getTimeLimit(const URegularExpression      *regexp,
                          UErrorCode              *status);

/**
 * Set the amount of heap storage available for use by the match backtracking stack.
 * <p>
 * ICU uses a backtracking regular expression engine, with the backtrack stack
 * maintained on the heap.  This function sets the limit to the amount of memory
 * that can be used  for this purpose.  A backtracking stack overflow will
 * result in an error from the match operation that caused it.
 * <p>
 * A limit is desirable because a malicious or poorly designed pattern can use
 * excessive memory, potentially crashing the process.  A limit is enabled
 * by default.
 * <p>
 * @param   regexp      The compiled regular expression.
 * @param   limit       The maximum size, in bytes, of the matching backtrack stack.
 *                      A value of zero means no limit.
 *                      The limit must be greater than or equal to zero.
 * @param   status      A reference to a UErrorCode to receive any errors.
 *
 * @stable ICU 4.0
 */
U_CAPI void U_EXPORT2
uregex_setStackLimit(URegularExpression      *regexp,
                     int32_t                  limit,
                     UErrorCode              *status);

/**
 * Get the size of the heap storage available for use by the back tracking stack.
 *
 * @return  the maximum backtracking stack size, in bytes, or zero if the
 *          stack size is unlimited.
 * @stable ICU 4.0
 */
U_CAPI int32_t U_EXPORT2
uregex_getStackLimit(const URegularExpression      *regexp,
                           UErrorCode              *status);


/**
 * Function pointer for a regular expression matching callback function.
 * When set, a callback function will be called periodically during matching
 * operations.  If the call back function returns false, the matching
 * operation will be terminated early.
 *
 * Note:  the callback function must not call other functions on this
 *        URegularExpression.
 *
 * @param context  context pointer.  The callback function will be invoked
 *                 with the context specified at the time that
 *                 uregex_setMatchCallback() is called.
 * @param steps    the accumulated processing time, in match steps, 
 *                 for this matching operation.
 * @return         true to continue the matching operation.
 *                 false to terminate the matching operation.
 * @stable ICU 4.0
 */
U_CDECL_BEGIN
typedef UBool U_CALLCONV URegexMatchCallback (
                   const void *context,
                   int32_t     steps);
U_CDECL_END

/**
 * Set a callback function for this URegularExpression.
 * During matching operations the function will be called periodically,
 * giving the application the opportunity to terminate a long-running
 * match.
 *
 * @param   regexp      The compiled regular expression.
 * @param   callback    A pointer to the user-supplied callback function.
 * @param   context     User context pointer.  The value supplied at the
 *                      time the callback function is set will be saved
 *                      and passed to the callback each time that it is called.
 * @param   status      A reference to a UErrorCode to receive any errors.
 * @stable ICU 4.0
 */
U_CAPI void U_EXPORT2
uregex_setMatchCallback(URegularExpression      *regexp,
                        URegexMatchCallback     *callback,
                        const void              *context,
                        UErrorCode              *status);


/**
 *  Get the callback function for this URegularExpression.
 *
 * @param   regexp      The compiled regular expression.
 * @param   callback    Out parameter, receives a pointer to the user-supplied 
 *                      callback function.
 * @param   context     Out parameter, receives the user context pointer that
 *                      was set when uregex_setMatchCallback() was called.
 * @param   status      A reference to a UErrorCode to receive any errors.
 * @stable ICU 4.0
 */
U_CAPI void U_EXPORT2
uregex_getMatchCallback(const URegularExpression    *regexp,
                        URegexMatchCallback        **callback,
                        const void                 **context,
                        UErrorCode                  *status);

/**
 * Function pointer for a regular expression find callback function.
 * 
 * When set, a callback function will be called during a find operation
 * and for operations that depend on find, such as findNext, split and some replace
 * operations like replaceFirst.
 * The callback will usually be called after each attempt at a match, but this is not a
 * guarantee that the callback will be invoked at each character.  For finds where the
 * match engine is invoked at each character, this may be close to true, but less likely
 * for more optimized loops where the pattern is known to only start, and the match
 * engine invoked, at certain characters.
 * When invoked, this callback will specify the index at which a match operation is about
 * to be attempted, giving the application the opportunity to terminate a long-running
 * find operation.
 * 
 * If the call back function returns false, the find operation will be terminated early.
 *
 * Note:  the callback function must not call other functions on this
 *        URegularExpression
 *
 * @param context  context pointer.  The callback function will be invoked
 *                 with the context specified at the time that
 *                 uregex_setFindProgressCallback() is called.
 * @param matchIndex  the next index at which a match attempt will be attempted for this
 *                 find operation.  If this callback interrupts the search, this is the
 *                 index at which a find/findNext operation may be re-initiated.
 * @return         true to continue the matching operation.
 *                 false to terminate the matching operation.
 * @stable ICU 4.6
 */
U_CDECL_BEGIN
typedef UBool U_CALLCONV URegexFindProgressCallback (
                   const void *context,
                   int64_t     matchIndex);
U_CDECL_END


/**
 *  Set the find progress callback function for this URegularExpression.
 *
 * @param   regexp      The compiled regular expression.
 * @param   callback    A pointer to the user-supplied callback function.
 * @param   context     User context pointer.  The value supplied at the
 *                      time the callback function is set will be saved
 *                      and passed to the callback each time that it is called.
 * @param   status      A reference to a UErrorCode to receive any errors.
 * @stable ICU 4.6
 */
U_CAPI void U_EXPORT2
uregex_setFindProgressCallback(URegularExpression              *regexp,
                                URegexFindProgressCallback      *callback,
                                const void                      *context,
                                UErrorCode                      *status);

/**
 *  Get the find progress callback function for this URegularExpression.
 *
 * @param   regexp      The compiled regular expression.
 * @param   callback    Out parameter, receives a pointer to the user-supplied 
 *                      callback function.
 * @param   context     Out parameter, receives the user context pointer that
 *                      was set when uregex_setFindProgressCallback() was called.
 * @param   status      A reference to a UErrorCode to receive any errors.
 * @stable ICU 4.6
 */
U_CAPI void U_EXPORT2
uregex_getFindProgressCallback(const URegularExpression          *regexp,
                                URegexFindProgressCallback        **callback,
                                const void                        **context,
                                UErrorCode                        *status);

#endif   /*  !UCONFIG_NO_REGULAR_EXPRESSIONS  */
#endif   /*  UREGEX_H  */
         usr/include/unicode/uregion.h                                                                       0000644 0000000 0000000 00000023477 14340212524 014761  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
*****************************************************************************************
* Copyright (C) 2014, International Business Machines
* Corporation and others. All Rights Reserved.
*****************************************************************************************
*/

#ifndef UREGION_H
#define UREGION_H

#include "unicode/utypes.h"
#include "unicode/uenum.h"

/**
 * \file
 * \brief C API: URegion (territory containment and mapping)
 *
 * URegion objects represent data associated with a particular Unicode Region Code, also known as a 
 * Unicode Region Subtag, which is defined based upon the BCP 47 standard. These include:
 * * Two-letter codes defined by ISO 3166-1, with special LDML treatment of certain private-use or
 *   reserved codes;
 * * A subset of 3-digit numeric codes defined by UN M.49.
 * URegion objects can also provide mappings to and from additional codes. There are different types
 * of regions that are important to distinguish:
 * <p>
 * Macroregion - A code for a "macro geographical (continental) region, geographical sub-region, or 
 * selected economic and other grouping" as defined in UN M.49. These are typically 3-digit codes,
 * but contain some 2-letter codes for LDML extensions, such as "QO" for Outlying Oceania.
 * Macroregions are represented in ICU by one of three region types: WORLD (code 001),
 * CONTINENTS (regions contained directly by WORLD), and SUBCONTINENTS (regions contained directly
 * by a continent ).
 * <p>
 * TERRITORY - A Region that is not a Macroregion. These are typically codes for countries, but also
 * include areas that are not separate countries, such as the code "AQ" for Antarctica or the code 
 * "HK" for Hong Kong (SAR China). Overseas dependencies of countries may or may not have separate 
 * codes. The codes are typically 2-letter codes aligned with ISO 3166, but BCP47 allows for the use
 * of 3-digit codes in the future.
 * <p>
 * UNKNOWN - The code ZZ is defined by Unicode LDML for use in indicating that region is unknown,
 * or that the value supplied as a region was invalid.
 * <p>
 * DEPRECATED - Region codes that have been defined in the past but are no longer in modern usage,
 * usually due to a country splitting into multiple territories or changing its name.
 * <p>
 * GROUPING - A widely understood grouping of territories that has a well defined membership such
 * that a region code has been assigned for it.  Some of these are UN M.49 codes that don't fall into 
 * the world/continent/sub-continent hierarchy, while others are just well-known groupings that have
 * their own region code. Region "EU" (European Union) is one such region code that is a grouping.
 * Groupings will never be returned by the uregion_getContainingRegion, since a different type of region
 * (WORLD, CONTINENT, or SUBCONTINENT) will always be the containing region instead.
 *
 * URegion objects are const/immutable, owned and maintained by ICU itself, so there are not functions
 * to open or close them.
 */

/**
 * URegionType is an enumeration defining the different types of regions.  Current possible
 * values are URGN_WORLD, URGN_CONTINENT, URGN_SUBCONTINENT, URGN_TERRITORY, URGN_GROUPING,
 * URGN_DEPRECATED, and URGN_UNKNOWN.
 * 
 * @stable ICU 51 
 */
typedef enum URegionType {
    /**
     * Type representing the unknown region.
     * @stable ICU 51 
     */
    URGN_UNKNOWN,

    /**
     * Type representing a territory.
     * @stable ICU 51 
     */
    URGN_TERRITORY,

    /**
     * Type representing the whole world.
     * @stable ICU 51 
     */
    URGN_WORLD,

    /**
     * Type representing a continent.
     * @stable ICU 51 
     */
    URGN_CONTINENT,

    /**
     * Type representing a sub-continent.
     * @stable ICU 51 
     */
    URGN_SUBCONTINENT,

    /**
     * Type representing a grouping of territories that is not to be used in
     * the normal WORLD/CONTINENT/SUBCONTINENT/TERRITORY containment tree.
     * @stable ICU 51 
     */
    URGN_GROUPING,

    /**
     * Type representing a region whose code has been deprecated, usually
     * due to a country splitting into multiple territories or changing its name.
     * @stable ICU 51 
     */
    URGN_DEPRECATED,

#ifndef U_HIDE_DEPRECATED_API
    /**
     * One more than the highest normal URegionType value.
     * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
     */
    URGN_LIMIT
#endif  /* U_HIDE_DEPRECATED_API */
} URegionType;

#if !UCONFIG_NO_FORMATTING

/**
 * Opaque URegion object for use in C programs.
 * @stable ICU 52
 */
struct URegion;
typedef struct URegion URegion; /**< @stable ICU 52 */

/**
 * Returns a pointer to a URegion for the specified region code: A 2-letter or 3-letter ISO 3166
 * code, UN M.49 numeric code (superset of ISO 3166 numeric codes), or other valid Unicode Region
 * Code as defined by the LDML specification. The code will be canonicalized internally. If the
 * region code is NULL or not recognized, the appropriate error code will be set
 * (U_ILLEGAL_ARGUMENT_ERROR).
 * @stable ICU 52
 */
U_CAPI const URegion* U_EXPORT2
uregion_getRegionFromCode(const char *regionCode, UErrorCode *status);

/**
 * Returns a pointer to a URegion for the specified numeric region code. If the numeric region
 * code is not recognized, the appropriate error code will be set (U_ILLEGAL_ARGUMENT_ERROR).
 * @stable ICU 52
 */
U_CAPI const URegion* U_EXPORT2
uregion_getRegionFromNumericCode (int32_t code, UErrorCode *status);

/**
 * Returns an enumeration over the canonical codes of all known regions that match the given type.
 * The enumeration must be closed with with uenum_close().
 * @stable ICU 52
 */
U_CAPI UEnumeration* U_EXPORT2
uregion_getAvailable(URegionType type, UErrorCode *status);

/**
 * Returns true if the specified uregion is equal to the specified otherRegion.
 * @stable ICU 52
 */
U_CAPI UBool U_EXPORT2
uregion_areEqual(const URegion* uregion, const URegion* otherRegion);

/**
 * Returns a pointer to the URegion that contains the specified uregion. Returns NULL if the
 * specified uregion is code "001" (World) or "ZZ" (Unknown region). For example, calling
 * this method with region "IT" (Italy) returns the URegion for "039" (Southern Europe).
 * @stable ICU 52
 */
U_CAPI const URegion* U_EXPORT2
uregion_getContainingRegion(const URegion* uregion);

/**
 * Return a pointer to the URegion that geographically contains this uregion and matches the
 * specified type, moving multiple steps up the containment chain if necessary. Returns NULL if no
 * containing region can be found that matches the specified type. Will return NULL if URegionType
 * is URGN_GROUPING, URGN_DEPRECATED, or URGN_UNKNOWN which are not appropriate for this API.
 * For example, calling this method with uregion "IT" (Italy) for type URGN_CONTINENT returns the
 * URegion "150" (Europe).
 * @stable ICU 52
 */
U_CAPI const URegion* U_EXPORT2
uregion_getContainingRegionOfType(const URegion* uregion, URegionType type);

/**
 * Return an enumeration over the canonical codes of all the regions that are immediate children
 * of the specified uregion in the region hierarchy. These returned regions could be either macro
 * regions, territories, or a mixture of the two, depending on the containment data as defined in
 * CLDR. This API returns NULL if this uregion doesn't have any sub-regions. For example, calling
 * this function for uregion "150" (Europe) returns an enumeration containing the various
 * sub-regions of Europe: "039" (Southern Europe), "151" (Eastern Europe), "154" (Northern Europe),
 * and "155" (Western Europe). The enumeration must be closed with with uenum_close().
 * @stable ICU 52
 */
U_CAPI UEnumeration* U_EXPORT2
uregion_getContainedRegions(const URegion* uregion, UErrorCode *status);

/**
 * Returns an enumeration over the canonical codes of all the regions that are children of the
 * specified uregion anywhere in the region hierarchy and match the given type. This API may return
 * an empty enumeration if this uregion doesn't have any sub-regions that match the given type.
 * For example, calling this method with region "150" (Europe) and type URGN_TERRITORY" returns an
 * enumeration containing all the territories in Europe: "FR" (France), "IT" (Italy), "DE" (Germany),
 * etc. The enumeration must be closed with with uenum_close().
 * @stable ICU 52
 */
U_CAPI UEnumeration* U_EXPORT2
uregion_getContainedRegionsOfType(const URegion* uregion, URegionType type, UErrorCode *status);

/**
 * Returns true if the specified uregion contains the specified otherRegion anywhere in the region
 * hierarchy.
 * @stable ICU 52
 */
U_CAPI UBool U_EXPORT2
uregion_contains(const URegion* uregion, const URegion* otherRegion);

/**
 * If the specified uregion is deprecated, returns an enumeration over the canonical codes of the
 * regions that are the preferred replacement regions for the specified uregion. If the specified
 * uregion is not deprecated, returns NULL. For example, calling this method with uregion
 * "SU" (Soviet Union) returns a list of the regions containing "RU" (Russia), "AM" (Armenia),
 * "AZ" (Azerbaijan), etc... The enumeration must be closed with with uenum_close().
 * @stable ICU 52
 */
U_CAPI UEnumeration* U_EXPORT2
uregion_getPreferredValues(const URegion* uregion, UErrorCode *status);

/**
 * Returns the specified uregion's canonical code.
 * @stable ICU 52
 */
U_CAPI const char* U_EXPORT2
uregion_getRegionCode(const URegion* uregion);

/**
 * Returns the specified uregion's numeric code, or a negative value if there is no numeric code
 * for the specified uregion.
 * @stable ICU 52
 */
U_CAPI int32_t U_EXPORT2
uregion_getNumericCode(const URegion* uregion);

/**
 * Returns the URegionType of the specified uregion.
 * @stable ICU 52
 */
U_CAPI URegionType U_EXPORT2
uregion_getType(const URegion* uregion);


#endif /* #if !UCONFIG_NO_FORMATTING */

#endif
                                                                                                                                                                                                 usr/include/unicode/ureldatefmt.h                                                                   0000644 0000000 0000000 00000042050 14340212524 015611  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
*****************************************************************************************
* Copyright (C) 2016, International Business Machines
* Corporation and others. All Rights Reserved.
*****************************************************************************************
*/

#ifndef URELDATEFMT_H
#define URELDATEFMT_H

#include "unicode/utypes.h"

#if !UCONFIG_NO_FORMATTING && !UCONFIG_NO_BREAK_ITERATION

#include "unicode/unum.h"
#include "unicode/udisplaycontext.h"
#include "unicode/uformattedvalue.h"

#if U_SHOW_CPLUSPLUS_API
#include "unicode/localpointer.h"
#endif   // U_SHOW_CPLUSPLUS_API

/**
 * \file
 * \brief C API: URelativeDateTimeFormatter, relative date formatting of unit + numeric offset.
 *
 * Provides simple formatting of relative dates, in two ways
 * <ul>
 *   <li>relative dates with a quantity e.g "in 5 days"</li>
 *   <li>relative dates without a quantity e.g "next Tuesday"</li>
 * </ul>
 * <p>
 * This does not provide compound formatting for multiple units,
 * other than the ability to combine a time string with a relative date,
 * as in "next Tuesday at 3:45 PM". It also does not provide support
 * for determining which unit to use, such as deciding between "in 7 days"
 * and "in 1 week".
 *
 * @stable ICU 57
 */

/**
 * The formatting style
 * @stable ICU 54
 */
typedef enum UDateRelativeDateTimeFormatterStyle {
  /**
   * Everything spelled out.
   * @stable ICU 54
   */
  UDAT_STYLE_LONG,

  /**
   * Abbreviations used when possible.
   * @stable ICU 54
   */
  UDAT_STYLE_SHORT,

  /**
   * Use the shortest possible form.
   * @stable ICU 54
   */
  UDAT_STYLE_NARROW,

#ifndef U_HIDE_DEPRECATED_API
    /**
     * One more than the highest normal UDateRelativeDateTimeFormatterStyle value.
     * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
     */
    UDAT_STYLE_COUNT
#endif  /* U_HIDE_DEPRECATED_API */
} UDateRelativeDateTimeFormatterStyle;

/**
 * Represents the unit for formatting a relative date. e.g "in 5 days"
 * or "next year"
 * @stable ICU 57
 */
typedef enum URelativeDateTimeUnit {
    /**
     * Specifies that relative unit is year, e.g. "last year",
     * "in 5 years". 
     * @stable ICU 57
     */
    UDAT_REL_UNIT_YEAR,
    /**
     * Specifies that relative unit is quarter, e.g. "last quarter",
     * "in 5 quarters".
     * @stable ICU 57
     */
    UDAT_REL_UNIT_QUARTER,
    /**
     * Specifies that relative unit is month, e.g. "last month",
     * "in 5 months".
     * @stable ICU 57
     */
    UDAT_REL_UNIT_MONTH,
    /**
     * Specifies that relative unit is week, e.g. "last week",
     * "in 5 weeks".
     * @stable ICU 57
     */
    UDAT_REL_UNIT_WEEK,
    /**
     * Specifies that relative unit is day, e.g. "yesterday",
     * "in 5 days".
     * @stable ICU 57
     */
    UDAT_REL_UNIT_DAY,
    /**
     * Specifies that relative unit is hour, e.g. "1 hour ago",
     * "in 5 hours".
     * @stable ICU 57
     */
    UDAT_REL_UNIT_HOUR,
    /**
     * Specifies that relative unit is minute, e.g. "1 minute ago",
     * "in 5 minutes".
     * @stable ICU 57
     */
    UDAT_REL_UNIT_MINUTE,
    /**
     * Specifies that relative unit is second, e.g. "1 second ago",
     * "in 5 seconds".
     * @stable ICU 57
     */
    UDAT_REL_UNIT_SECOND,
    /**
     * Specifies that relative unit is Sunday, e.g. "last Sunday",
     * "this Sunday", "next Sunday", "in 5 Sundays".
     * @stable ICU 57
     */
    UDAT_REL_UNIT_SUNDAY,
    /**
     * Specifies that relative unit is Monday, e.g. "last Monday",
     * "this Monday", "next Monday", "in 5 Mondays".
     * @stable ICU 57
     */
    UDAT_REL_UNIT_MONDAY,
    /**
     * Specifies that relative unit is Tuesday, e.g. "last Tuesday",
     * "this Tuesday", "next Tuesday", "in 5 Tuesdays".
     * @stable ICU 57
     */
    UDAT_REL_UNIT_TUESDAY,
    /**
     * Specifies that relative unit is Wednesday, e.g. "last Wednesday",
     * "this Wednesday", "next Wednesday", "in 5 Wednesdays".
     * @stable ICU 57
     */
    UDAT_REL_UNIT_WEDNESDAY,
    /**
