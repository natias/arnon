  length may be unknown, but can be calculated by C<strlen()>, since it is
  terminated by a NUL, which isn't included in its length.

  The optional 'n' following 'str' means that there is a third parameter,
  giving the maximum number of bytes to look at in each string.  Even if both
  strings are longer than the length parameter, those extra bytes will be
  unexamined.

  The 's' suffix means that the 2nd byte string parameter is a literal C
  double-quoted string.  Its length will automatically be calculated by the
  macro, so no length parameter will ever be needed for it.

  If the prefix is 'mem', the string parameters don't have to be C strings;
  they may contain embedded NUL bytes, do not necessarily have a terminating
  NUL, and their lengths can be known only through other means, which in
  practice are additional parameter(s) passed to the function.  All 'mem'
  functions have at least one length parameter.  Barring any 'l' or 's' suffix,
  there is a single length parameter, in position 3, which applies to both
  string parameters.  The 's' suffix means, as described above, that the 2nd
  string is a literal double-quoted C string (hence its length is calculated by
  the macro, and the length parameter to the function applies just to the first
  string parameter, and hence is positioned just after it).  An 'l' suffix
  means that the 2nd string parameter has its own length parameter, and the
  signature will look like memFOOl(s1, l1, s2, l2).

  BEGIN (and END) are for testing if the 2nd string is an initial (or final)
  substring  of the 1st string.  'P' if present indicates that the substring
  must be a "proper" one in tha mathematical sense that the first one must be
  strictly larger than the 2nd.

*/


#define strNE(s1,s2) (strcmp(s1,s2) != 0)
#define strEQ(s1,s2) (strcmp(s1,s2) == 0)
#define strLT(s1,s2) (strcmp(s1,s2) < 0)
#define strLE(s1,s2) (strcmp(s1,s2) <= 0)
#define strGT(s1,s2) (strcmp(s1,s2) > 0)
#define strGE(s1,s2) (strcmp(s1,s2) >= 0)

#define strnNE(s1,s2,l) (strncmp(s1,s2,l) != 0)
#define strnEQ(s1,s2,l) (strncmp(s1,s2,l) == 0)

#define memEQ(s1,s2,l) (memcmp(((const void *) (s1)), ((const void *) (s2)), l) == 0)
#define memNE(s1,s2,l) (! memEQ(s1,s2,l))

/* memEQ and memNE where second comparand is a string constant */
#define memEQs(s1, l, s2) \
        (((sizeof(s2)-1) == (l)) && memEQ((s1), ASSERT_IS_LITERAL(s2), (sizeof(s2)-1)))
#define memNEs(s1, l, s2) (! memEQs(s1, l, s2))

/* Keep these private until we decide it was a good idea */
#if defined(PERL_CORE) || defined(PERL_EXT) || defined(PERL_EXT_POSIX)

#define strBEGINs(s1,s2) (strncmp(s1,ASSERT_IS_LITERAL(s2), sizeof(s2)-1) == 0)

#define memBEGINs(s1, l, s2)                                                \
            (   (Ptrdiff_t) (l) >= (Ptrdiff_t) sizeof(s2) - 1               \
             && memEQ(s1, ASSERT_IS_LITERAL(s2), sizeof(s2)-1))
#define memBEGINPs(s1, l, s2)                                               \
            (   (Ptrdiff_t) (l) > (Ptrdiff_t) sizeof(s2) - 1                \
             && memEQ(s1, ASSERT_IS_LITERAL(s2), sizeof(s2)-1))
#define memENDs(s1, l, s2)                                                  \
            (   (Ptrdiff_t) (l) >= (Ptrdiff_t) sizeof(s2) - 1               \
             && memEQ(s1 + (l) - (sizeof(s2) - 1), ASSERT_IS_LITERAL(s2), sizeof(s2)-1))
#define memENDPs(s1, l, s2)                                                 \
            (   (Ptrdiff_t) (l) > (Ptrdiff_t) sizeof(s2)                    \
             && memEQ(s1 + (l) - (sizeof(s2) - 1), ASSERT_IS_LITERAL(s2), sizeof(s2)-1))
#endif  /* End of making macros private */

#define memLT(s1,s2,l) (memcmp(s1,s2,l) < 0)
#define memLE(s1,s2,l) (memcmp(s1,s2,l) <= 0)
#define memGT(s1,s2,l) (memcmp(s1,s2,l) > 0)
#define memGE(s1,s2,l) (memcmp(s1,s2,l) >= 0)

#define memCHRs(s1,c) ((const char *) memchr(ASSERT_IS_LITERAL(s1) , c, sizeof(s1)-1))

/*
 * Character classes.
 *
 * Unfortunately, the introduction of locales means that we
 * can't trust isupper(), etc. to tell the truth.  And when
 * it comes to /\w+/ with tainting enabled, we *must* be able
 * to trust our character classes.
 *
 * Therefore, the default tests in the text of Perl will be
 * independent of locale.  Any code that wants to depend on
 * the current locale will use the tests that begin with "lc".
 */

#ifdef USE_LOCALE
#  ifndef CTYPE256
#    define CTYPE256
#  endif
#endif

/*

=head1 Character classification
This section is about functions (really macros) that classify characters
into types, such as punctuation versus alphabetic, etc.  Most of these are
analogous to regular expression character classes.  (See
L<perlrecharclass/POSIX Character Classes>.)  There are several variants for
each class.  (Not all macros have all variants; each item below lists the
ones valid for it.)  None are affected by C<use bytes>, and only the ones
with C<LC> in the name are affected by the current locale.

The base function, e.g., C<isALPHA()>, takes any signed or unsigned value,
treating it as a code point, and returns a boolean as to whether or not the
character represented by it is (or on non-ASCII platforms, corresponds to) an
ASCII character in the named class based on platform, Unicode, and Perl rules.
If the input is a number that doesn't fit in an octet, FALSE is returned.

Variant C<isI<FOO>_A> (e.g., C<isALPHA_A()>) is identical to the base function
with no suffix C<"_A">.  This variant is used to emphasize by its name that
only ASCII-range characters can return TRUE.

Variant C<isI<FOO>_L1> imposes the Latin-1 (or EBCDIC equivalent) character set
onto the platform.  That is, the code points that are ASCII are unaffected,
since ASCII is a subset of Latin-1.  But the non-ASCII code points are treated
as if they are Latin-1 characters.  For example, C<isWORDCHAR_L1()> will return
true when called with the code point 0xDF, which is a word character in both
ASCII and EBCDIC (though it represents different characters in each).
If the input is a number that doesn't fit in an octet, FALSE is returned.
(Perl's documentation uses a colloquial definition of Latin-1, to include all
code points below 256.)

Variant C<isI<FOO>_uvchr> is exactly like the C<isI<FOO>_L1> variant, for
inputs below 256, but if the code point is larger than 255, Unicode rules are
used to determine if it is in the character class.  For example,
C<isWORDCHAR_uvchr(0x100)> returns TRUE, since 0x100 is LATIN CAPITAL LETTER A
WITH MACRON in Unicode, and is a word character.

Variants C<isI<FOO>_utf8> and C<isI<FOO>_utf8_safe> are like C<isI<FOO>_uvchr>,
but are used for UTF-8 encoded strings.  The two forms are different names for
the same thing.  Each call to one of these classifies the first character of
the string starting at C<p>.  The second parameter, C<e>, points to anywhere in
the string beyond the first character, up to one byte past the end of the
entire string.  Although both variants are identical, the suffix C<_safe> in
one name emphasizes that it will not attempt to read beyond S<C<e - 1>>,
provided that the constraint S<C<s E<lt> e>> is true (this is asserted for in
C<-DDEBUGGING> builds).  If the UTF-8 for the input character is malformed in
some way, the program may croak, or the function may return FALSE, at the
discretion of the implementation, and subject to change in future releases.

Variant C<isI<FOO>_LC> is like the C<isI<FOO>_A> and C<isI<FOO>_L1> variants,
but the result is based on the current locale, which is what C<LC> in the name
stands for.  If Perl can determine that the current locale is a UTF-8 locale,
it uses the published Unicode rules; otherwise, it uses the C library function
that gives the named classification.  For example, C<isDIGIT_LC()> when not in
a UTF-8 locale returns the result of calling C<isdigit()>.  FALSE is always
returned if the input won't fit into an octet.  On some platforms where the C
library function is known to be defective, Perl changes its result to follow
the POSIX standard's rules.

Variant C<isI<FOO>_LC_uvchr> acts exactly like C<isI<FOO>_LC> for inputs less
than 256, but for larger ones it returns the Unicode classification of the code
point.

Variants C<isI<FOO>_LC_utf8> and C<isI<FOO>_LC_utf8_safe> are like
C<isI<FOO>_LC_uvchr>, but are used for UTF-8 encoded strings.  The two forms
are different names for the same thing.  Each call to one of these classifies
the first character of the string starting at C<p>.  The second parameter,
C<e>, points to anywhere in the string beyond the first character, up to one
byte past the end of the entire string.  Although both variants are identical,
the suffix C<_safe> in one name emphasizes that it will not attempt to read
beyond S<C<e - 1>>, provided that the constraint S<C<s E<lt> e>> is true (this
is asserted for in C<-DDEBUGGING> builds).  If the UTF-8 for the input
character is malformed in some way, the program may croak, or the function may
return FALSE, at the discretion of the implementation, and subject to change in
future releases.

=for apidoc Am|bool|isALPHA|UV ch
=for apidoc_item ||isALPHA_A|UV ch
=for apidoc_item ||isALPHA_L1|UV ch
=for apidoc_item ||isALPHA_uvchr|UV ch
=for apidoc_item ||isALPHA_utf8_safe|U8 * s|U8 * end
=for apidoc_item ||isALPHA_utf8|U8 * s|U8 * end
=for apidoc_item ||isALPHA_LC|UV ch
=for apidoc_item ||isALPHA_LC_uvchr|UV ch
=for apidoc_item ||isALPHA_LC_utf8_safe|U8 * s| U8 *end
Returns a boolean indicating whether the specified input is one of C<[A-Za-z]>,
analogous to C<m/[[:alpha:]]/>.
See the L<top of this section|/Character classification> for an explanation of
the variants.

=cut

Here and below, we add the prototypes of these macros for downstream programs
that would be interested in them, such as Devel::PPPort

=for apidoc Am|bool|isALPHANUMERIC|UV ch
=for apidoc_item ||isALPHANUMERIC_A|UV ch
=for apidoc_item ||isALPHANUMERIC_L1|UV ch
=for apidoc_item ||isALPHANUMERIC_uvchr|UV ch
=for apidoc_item ||isALPHANUMERIC_utf8_safe|U8 * s|U8 * end
=for apidoc_item ||isALPHANUMERIC_utf8|U8 * s|U8 * end
=for apidoc_item ||isALPHANUMERIC_LC|UV ch
=for apidoc_item ||isALPHANUMERIC_LC_uvchr|UV ch
=for apidoc_item ||isALPHANUMERIC_LC_utf8_safe|U8 * s| U8 *end
=for apidoc_item ||isALNUMC|UV ch
=for apidoc_item ||isALNUMC_A|UV ch
=for apidoc_item ||isALNUMC_L1|UV ch
=for apidoc_item ||isALNUMC_LC|UV ch
=for apidoc_item ||isALNUMC_LC_uvchr|UV ch
Returns a boolean indicating whether the specified character is one of
C<[A-Za-z0-9]>, analogous to C<m/[[:alnum:]]/>.
See the L<top of this section|/Character classification> for an explanation of
the variants.

A (discouraged from use) synonym is C<isALNUMC> (where the C<C> suffix means
this corresponds to the C language alphanumeric definition).  Also
there are the variants
C<isALNUMC_A>, C<isALNUMC_L1>
C<isALNUMC_LC>, and C<isALNUMC_LC_uvchr>.

=for apidoc Am|bool|isASCII|UV ch
=for apidoc_item ||isASCII_A|UV ch
=for apidoc_item ||isASCII_L1|UV ch
=for apidoc_item ||isASCII_uvchr|UV ch
=for apidoc_item ||isASCII_utf8_safe|U8 * s|U8 * end
=for apidoc_item ||isASCII_utf8|U8 * s|U8 * end
=for apidoc_item ||isASCII_LC|UV ch
=for apidoc_item ||isASCII_LC_uvchr|UV ch
=for apidoc_item ||isASCII_LC_utf8_safe|U8 * s| U8 *end
Returns a boolean indicating whether the specified character is one of the 128
characters in the ASCII character set, analogous to C<m/[[:ascii:]]/>.
On non-ASCII platforms, it returns TRUE iff this
character corresponds to an ASCII character.  Variants C<isASCII_A()> and
C<isASCII_L1()> are identical to C<isASCII()>.
See the L<top of this section|/Character classification> for an explanation of
the variants.
Note, however, that some platforms do not have the C library routine
C<isascii()>.  In these cases, the variants whose names contain C<LC> are the
same as the corresponding ones without.

Also note, that because all ASCII characters are UTF-8 invariant (meaning they
have the exact same representation (always a single byte) whether encoded in
UTF-8 or not), C<isASCII> will give the correct results when called with any
byte in any string encoded or not in UTF-8.  And similarly C<isASCII_utf8> and
C<isASCII_utf8_safe> will work properly on any string encoded or not in UTF-8.

=for apidoc Am|bool|isBLANK|UV ch
=for apidoc_item ||isBLANK_A|UV ch
=for apidoc_item ||isBLANK_L1|UV ch
=for apidoc_item ||isBLANK_uvchr|UV ch
=for apidoc_item ||isBLANK_utf8_safe|U8 * s|U8 * end
=for apidoc_item ||isBLANK_utf8|U8 * s|U8 * end
=for apidoc_item ||isBLANK_LC|UV ch
=for apidoc_item ||isBLANK_LC_uvchr|UV ch
=for apidoc_item ||isBLANK_LC_utf8_safe|U8 * s| U8 *end
Returns a boolean indicating whether the specified character is a
character considered to be a blank, analogous to C<m/[[:blank:]]/>.
See the L<top of this section|/Character classification> for an explanation of
the variants.
Note,
however, that some platforms do not have the C library routine
C<isblank()>.  In these cases, the variants whose names contain C<LC> are
the same as the corresponding ones without.

=for apidoc Am|bool|isCNTRL|UV ch
=for apidoc_item ||isCNTRL_A|UV ch
=for apidoc_item ||isCNTRL_L1|UV ch
=for apidoc_item ||isCNTRL_uvchr|UV ch
=for apidoc_item ||isCNTRL_utf8_safe|U8 * s|U8 * end
=for apidoc_item ||isCNTRL_utf8|U8 * s|U8 * end
=for apidoc_item ||isCNTRL_LC|UV ch
=for apidoc_item ||isCNTRL_LC_uvchr|UV ch
=for apidoc_item ||isCNTRL_LC_utf8_safe|U8 * s| U8 *end

Returns a boolean indicating whether the specified character is a
control character, analogous to C<m/[[:cntrl:]]/>.
See the L<top of this section|/Character classification> for an explanation of
the variants.
On EBCDIC platforms, you almost always want to use the C<isCNTRL_L1> variant.

=for apidoc Am|bool|isDIGIT|UV ch
=for apidoc_item ||isDIGIT_A|UV ch
=for apidoc_item ||isDIGIT_L1|UV ch
=for apidoc_item ||isDIGIT_uvchr|UV ch
=for apidoc_item ||isDIGIT_utf8_safe|U8 * s|U8 * end
=for apidoc_item ||isDIGIT_utf8|U8 * s|U8 * end
=for apidoc_item ||isDIGIT_LC|UV ch
=for apidoc_item ||isDIGIT_LC_uvchr|UV ch
=for apidoc_item ||isDIGIT_LC_utf8_safe|U8 * s| U8 *end

Returns a boolean indicating whether the specified character is a
digit, analogous to C<m/[[:digit:]]/>.
Variants C<isDIGIT_A> and C<isDIGIT_L1> are identical to C<isDIGIT>.
See the L<top of this section|/Character classification> for an explanation of
the variants.

=for apidoc Am|bool|isGRAPH|UV ch
=for apidoc_item ||isGRAPH_A|UV ch
=for apidoc_item ||isGRAPH_L1|UV ch
=for apidoc_item ||isGRAPH_uvchr|UV ch
=for apidoc_item ||isGRAPH_utf8_safe|U8 * s|U8 * end
=for apidoc_item ||isGRAPH_utf8|U8 * s|U8 * end
=for apidoc_item ||isGRAPH_LC|UV ch
=for apidoc_item ||isGRAPH_LC_uvchr|UV ch
=for apidoc_item ||isGRAPH_LC_utf8_safe|U8 * s| U8 *end
Returns a boolean indicating whether the specified character is a
graphic character, analogous to C<m/[[:graph:]]/>.
See the L<top of this section|/Character classification> for an explanation of
the variants.

=for apidoc Am|bool|isLOWER|UV ch
=for apidoc_item ||isLOWER_A|UV ch
=for apidoc_item ||isLOWER_L1|UV ch
=for apidoc_item ||isLOWER_uvchr|UV ch
=for apidoc_item ||isLOWER_utf8_safe|U8 * s|U8 * end
=for apidoc_item ||isLOWER_utf8|U8 * s|U8 * end
=for apidoc_item ||isLOWER_LC|UV ch
=for apidoc_item ||isLOWER_LC_uvchr|UV ch
=for apidoc_item ||isLOWER_LC_utf8_safe|U8 * s| U8 *end
Returns a boolean indicating whether the specified character is a
lowercase character, analogous to C<m/[[:lower:]]/>.
See the L<top of this section|/Character classification> for an explanation of
the variants

=for apidoc Am|bool|isOCTAL|UV ch
=for apidoc_item ||isOCTAL_A|UV ch
=for apidoc_item ||isOCTAL_L1|UV ch
Returns a boolean indicating whether the specified character is an
octal digit, [0-7].
The only two variants are C<isOCTAL_A> and C<isOCTAL_L1>; each is identical to
C<isOCTAL>.

=for apidoc Am|bool|isPUNCT|UV ch
=for apidoc_item ||isPUNCT_A|UV ch
=for apidoc_item ||isPUNCT_L1|UV ch
=for apidoc_item ||isPUNCT_uvchr|UV ch
=for apidoc_item ||isPUNCT_utf8_safe|U8 * s|U8 * end
=for apidoc_item ||isPUNCT_utf8|U8 * s|U8 * end
=for apidoc_item ||isPUNCT_LC|UV ch
=for apidoc_item ||isPUNCT_LC_uvchr|UV ch
=for apidoc_item ||isPUNCT_LC_utf8_safe|U8 * s| U8 *end
Returns a boolean indicating whether the specified character is a
punctuation character, analogous to C<m/[[:punct:]]/>.
Note that the definition of what is punctuation isn't as
straightforward as one might desire.  See L<perlrecharclass/POSIX Character
Classes> for details.
See the L<top of this section|/Character classification> for an explanation of
the variants.

=for apidoc Am|bool|isSPACE|UV ch
=for apidoc_item ||isSPACE_A|UV ch
=for apidoc_item ||isSPACE_L1|UV ch
=for apidoc_item ||isSPACE_uvchr|UV ch
=for apidoc_item ||isSPACE_utf8_safe|U8 * s|U8 * end
=for apidoc_item ||isSPACE_utf8|U8 * s|U8 * end
=for apidoc_item ||isSPACE_LC|UV ch
=for apidoc_item ||isSPACE_LC_uvchr|UV ch
=for apidoc_item ||isSPACE_LC_utf8_safe|U8 * s| U8 *end
Returns a boolean indicating whether the specified character is a
whitespace character.  This is analogous
to what C<m/\s/> matches in a regular expression.  Starting in Perl 5.18
this also matches what C<m/[[:space:]]/> does.  Prior to 5.18, only the
locale forms of this macro (the ones with C<LC> in their names) matched
precisely what C<m/[[:space:]]/> does.  In those releases, the only difference,
in the non-locale variants, was that C<isSPACE()> did not match a vertical tab.
(See L</isPSXSPC> for a macro that matches a vertical tab in all releases.)
See the L<top of this section|/Character classification> for an explanation of
the variants.

=for apidoc Am|bool|isPSXSPC|UV ch
=for apidoc_item ||isPSXSPC_A|UV ch
=for apidoc_item ||isPSXSPC_L1|UV ch
=for apidoc_item ||isPSXSPC_uvchr|UV ch
=for apidoc_item ||isPSXSPC_utf8_safe|U8 * s|U8 * end
=for apidoc_item ||isPSXSPC_utf8|U8 * s|U8 * end
=for apidoc_item ||isPSXSPC_LC|UV ch
=for apidoc_item ||isPSXSPC_LC_uvchr|UV ch
=for apidoc_item ||isPSXSPC_LC_utf8_safe|U8 * s| U8 *end
(short for Posix Space)
Starting in 5.18, this is identical in all its forms to the
corresponding C<isSPACE()> macros.
The locale forms of this macro are identical to their corresponding
C<isSPACE()> forms in all Perl releases.  In releases prior to 5.18, the
non-locale forms differ from their C<isSPACE()> forms only in that the
C<isSPACE()> forms don't match a Vertical Tab, and the C<isPSXSPC()> forms do.
Otherwise they are identical.  Thus this macro is analogous to what
C<m/[[:space:]]/> matches in a regular expression.
See the L<top of this section|/Character classification> for an explanation of
the variants.

=for apidoc Am|bool|isUPPER|UV ch
=for apidoc_item ||isUPPER_A|UV ch
=for apidoc_item ||isUPPER_L1|UV ch
=for apidoc_item ||isUPPER_uvchr|UV ch
=for apidoc_item ||isUPPER_utf8_safe|U8 * s|U8 * end
=for apidoc_item ||isUPPER_utf8|U8 * s|U8 * end
=for apidoc_item ||isUPPER_LC|UV ch
=for apidoc_item ||isUPPER_LC_uvchr|UV ch
=for apidoc_item ||isUPPER_LC_utf8_safe|U8 * s| U8 *end
Returns a boolean indicating whether the specified character is an
uppercase character, analogous to C<m/[[:upper:]]/>.
See the L<top of this section|/Character classification> for an explanation of
the variants.

=for apidoc Am|bool|isPRINT|UV ch
=for apidoc_item ||isPRINT_A|UV ch
=for apidoc_item ||isPRINT_L1|UV ch
=for apidoc_item ||isPRINT_uvchr|UV ch
=for apidoc_item ||isPRINT_utf8_safe|U8 * s|U8 * end
=for apidoc_item ||isPRINT_utf8|U8 * s|U8 * end
=for apidoc_item ||isPRINT_LC|UV ch
=for apidoc_item ||isPRINT_LC_uvchr|UV ch
=for apidoc_item ||isPRINT_LC_utf8_safe|U8 * s| U8 *end
Returns a boolean indicating whether the specified character is a
printable character, analogous to C<m/[[:print:]]/>.
See the L<top of this section|/Character classification> for an explanation of
the variants.

=for apidoc Am|bool|isWORDCHAR|UV ch
=for apidoc_item ||isWORDCHAR_A|UV ch
=for apidoc_item ||isWORDCHAR_L1|UV ch
=for apidoc_item ||isWORDCHAR_uvchr|UV ch
=for apidoc_item ||isWORDCHAR_utf8_safe|U8 * s|U8 * end
=for apidoc_item ||isWORDCHAR_utf8|U8 * s|U8 * end
=for apidoc_item ||isWORDCHAR_LC|UV ch
=for apidoc_item ||isWORDCHAR_LC_uvchr|UV ch
=for apidoc_item ||isWORDCHAR_LC_utf8_safe|U8 * s| U8 *end
=for apidoc_item ||isALNUM|UV ch
=for apidoc_item ||isALNUM_A|UV ch
=for apidoc_item ||isALNUM_LC|UV ch
=for apidoc_item ||isALNUM_LC_uvchr|UV ch
Returns a boolean indicating whether the specified character is a character
that is a word character, analogous to what C<m/\w/> and C<m/[[:word:]]/> match
in a regular expression.  A word character is an alphabetic character, a
decimal digit, a connecting punctuation character (such as an underscore), or
a "mark" character that attaches to one of those (like some sort of accent).
C<isALNUM()> is a synonym provided for backward compatibility, even though a
word character includes more than the standard C language meaning of
alphanumeric.
See the L<top of this section|/Character classification> for an explanation of
the variants.
C<isWORDCHAR_A>, C<isWORDCHAR_L1>, C<isWORDCHAR_uvchr>,
C<isWORDCHAR_LC>, C<isWORDCHAR_LC_uvchr>, C<isWORDCHAR_LC_utf8>, and
C<isWORDCHAR_LC_utf8_safe> are also as described there, but additionally
include the platform's native underscore.

=for apidoc Am|bool|isXDIGIT|UV ch
=for apidoc_item ||isXDIGIT_A|UV ch
=for apidoc_item ||isXDIGIT_L1|UV ch
=for apidoc_item ||isXDIGIT_uvchr|UV ch
=for apidoc_item ||isXDIGIT_utf8_safe|U8 * s|U8 * end
=for apidoc_item ||isXDIGIT_utf8|U8 * s|U8 * end
=for apidoc_item ||isXDIGIT_LC|UV ch
=for apidoc_item ||isXDIGIT_LC_uvchr|UV ch
=for apidoc_item ||isXDIGIT_LC_utf8_safe|U8 * s| U8 *end
Returns a boolean indicating whether the specified character is a hexadecimal
digit.  In the ASCII range these are C<[0-9A-Fa-f]>.  Variants C<isXDIGIT_A()>
and C<isXDIGIT_L1()> are identical to C<isXDIGIT()>.
See the L<top of this section|/Character classification> for an explanation of
the variants.

=for apidoc Am|bool|isIDFIRST|UV ch
=for apidoc_item ||isIDFIRST_A|UV ch
=for apidoc_item ||isIDFIRST_L1|UV ch
=for apidoc_item ||isIDFIRST_uvchr|UV ch
=for apidoc_item ||isIDFIRST_utf8_safe|U8 * s|U8 * end
=for apidoc_item ||isIDFIRST_utf8|U8 * s|U8 * end
=for apidoc_item ||isIDFIRST_LC|UV ch
=for apidoc_item ||isIDFIRST_LC_uvchr|UV ch
=for apidoc_item ||isIDFIRST_LC_utf8_safe|U8 * s| U8 *end
Returns a boolean indicating whether the specified character can be the first
character of an identifier.  This is very close to, but not quite the same as
the official Unicode property C<XID_Start>.  The difference is that this
returns true only if the input character also matches L</isWORDCHAR>.
See the L<top of this section|/Character classification> for an explanation of
the variants.

=for apidoc Am|bool|isIDCONT|UV ch
=for apidoc_item ||isIDCONT_A|UV ch
=for apidoc_item ||isIDCONT_L1|UV ch
=for apidoc_item ||isIDCONT_uvchr|UV ch
=for apidoc_item ||isIDCONT_utf8_safe|U8 * s|U8 * end
=for apidoc_item ||isIDCONT_utf8|U8 * s|U8 * end
=for apidoc_item ||isIDCONT_LC|UV ch
=for apidoc_item ||isIDCONT_LC_uvchr|UV ch
=for apidoc_item ||isIDCONT_LC_utf8_safe|U8 * s| U8 *end
Returns a boolean indicating whether the specified character can be the
second or succeeding character of an identifier.  This is very close to, but
not quite the same as the official Unicode property C<XID_Continue>.  The
difference is that this returns true only if the input character also matches
L</isWORDCHAR>.  See the L<top of this section|/Character classification> for
an explanation of the variants.

=for apidoc_section $numeric

=for apidoc Am|U8|READ_XDIGIT|char str*
Returns the value of an ASCII-range hex digit and advances the string pointer.
Behaviour is only well defined when isXDIGIT(*str) is true.

=head1 Character case changing
Perl uses "full" Unicode case mappings.  This means that converting a single
character to another case may result in a sequence of more than one character.
For example, the uppercase of C<E<223>> (LATIN SMALL LETTER SHARP S) is the two
character sequence C<SS>.  This presents some complications   The lowercase of
all characters in the range 0..255 is a single character, and thus
C<L</toLOWER_L1>> is furnished.  But, C<toUPPER_L1> can't exist, as it couldn't
return a valid result for all legal inputs.  Instead C<L</toUPPER_uvchr>> has
an API that does allow every possible legal result to be returned.)  Likewise
no other function that is crippled by not being able to give the correct
results for the full range of possible inputs has been implemented here.

=for apidoc Am|UV|toUPPER|UV cp
=for apidoc_item |UV|toUPPER_A|UV cp
=for apidoc_item |UV|toUPPER_uvchr|UV cp|U8* s|STRLEN* lenp
=for apidoc_item |UV|toUPPER_utf8|U8* p|U8* e|U8* s|STRLEN* lenp
=for apidoc_item |UV|toUPPER_utf8_safe|U8* p|U8* e|U8* s|STRLEN* lenp

These all return the uppercase of a character.  The differences are what domain
they operate on, and whether the input is specified as a code point (those
forms with a C<cp> parameter) or as a UTF-8 string (the others).  In the latter
case, the code point to use is the first one in the buffer of UTF-8 encoded
code points, delineated by the arguments S<C<p .. e - 1>>.

C<toUPPER> and C<toUPPER_A> are synonyms of each other.  They return the
uppercase of any lowercase ASCII-range code point.  All other inputs are
returned unchanged.  Since these are macros, the input type may be any integral
one, and the output will occupy the same number of bits as the input.

There is no C<toUPPER_L1> nor C<toUPPER_LATIN1> as the uppercase of some code
points in the 0..255 range is above that range or consists of multiple
characters.  Instead use C<toUPPER_uvchr>.

C<toUPPER_uvchr> returns the uppercase of any Unicode code point.  The return
value is identical to that of C<toUPPER_A> for input code points in the ASCII
range.  The uppercase of the vast majority of Unicode code points is the same
as the code point itself.  For these, and for code points above the legal
Unicode maximum, this returns the input code point unchanged.  It additionally
stores the UTF-8 of the result into the buffer beginning at C<s>, and its
length in bytes into C<*lenp>.  The caller must have made C<s> large enough to
contain at least C<UTF8_MAXBYTES_CASE+1> bytes to avoid possible overflow.

NOTE: the uppercase of a code point may be more than one code point.  The
return value of this function is only the first of these.  The entire uppercase
is returned in C<s>.  To determine if the result is more than a single code
point, you can do something like this:

 uc = toUPPER_uvchr(cp, s, &len);
 if (len > UTF8SKIP(s)) { is multiple code points }
 else { is a single code point }

C<toUPPER_utf8> and C<toUPPER_utf8_safe> are synonyms of each other.  The only
difference between these and C<toUPPER_uvchr> is that the source for these is
encoded in UTF-8, instead of being a code point.  It is passed as a buffer
starting at C<p>, with C<e> pointing to one byte beyond its end.  The C<p>
buffer may certainly contain more than one code point; but only the first one
(up through S<C<e - 1>>) is examined.  If the UTF-8 for the input character is
malformed in some way, the program may croak, or the function may return the
REPLACEMENT CHARACTER, at the discretion of the implementation, and subject to
change in future releases.

=for apidoc Am|UV|toFOLD|UV cp
=for apidoc_item |UV|toFOLD_A|UV cp
=for apidoc_item |UV|toFOLD_uvchr|UV cp|U8* s|STRLEN* lenp
=for apidoc_item |UV|toFOLD_utf8|U8* p|U8* e|U8* s|STRLEN* lenp
=for apidoc_item |UV|toFOLD_utf8_safe|U8* p|U8* e|U8* s|STRLEN* lenp

These all return the foldcase of a character.  "foldcase" is an internal case
for C</i> pattern matching. If the foldcase of character A and the foldcase of
character B are the same, they match caselessly; otherwise they don't.

The differences in the forms are what domain they operate on, and whether the
input is specified as a code point (those forms with a C<cp> parameter) or as a
UTF-8 string (the others).  In the latter case, the code point to use is the
first one in the buffer of UTF-8 encoded code points, delineated by the
arguments S<C<p .. e - 1>>.

C<toFOLD> and C<toFOLD_A> are synonyms of each other.  They return the
foldcase of any ASCII-range code point.  In this range, the foldcase is
identical to the lowercase.  All other inputs are returned unchanged.  Since
these are macros, the input type may be any integral one, and the output will
occupy the same number of bits as the input.

There is no C<toFOLD_L1> nor C<toFOLD_LATIN1> as the foldcase of some code
points in the 0..255 range is above that range or consists of multiple
characters.  Instead use C<toFOLD_uvchr>.

C<toFOLD_uvchr> returns the foldcase of any Unicode code point.  The return
value is identical to that of C<toFOLD_A> for input code points in the ASCII
range.  The foldcase of the vast majority of Unicode code points is the same
as the code point itself.  For these, and for code points above the legal
Unicode maximum, this returns the input code point unchanged.  It additionally
stores the UTF-8 of the result into the buffer beginning at C<s>, and its
length in bytes into C<*lenp>.  The caller must have made C<s> large enough to
contain at least C<UTF8_MAXBYTES_CASE+1> bytes to avoid possible overflow.

NOTE: the foldcase of a code point may be more than one code point.  The
return value of this function is only the first of these.  The entire foldcase
is returned in C<s>.  To determine if the result is more than a single code
point, you can do something like this:

 uc = toFOLD_uvchr(cp, s, &len);
 if (len > UTF8SKIP(s)) { is multiple code points }
 else { is a single code point }

C<toFOLD_utf8> and C<toFOLD_utf8_safe> are synonyms of each other.  The only
difference between these and C<toFOLD_uvchr> is that the source for these is
encoded in UTF-8, instead of being a code point.  It is passed as a buffer
starting at C<p>, with C<e> pointing to one byte beyond its end.  The C<p>
buffer may certainly contain more than one code point; but only the first one
(up through S<C<e - 1>>) is examined.  If the UTF-8 for the input character is
malformed in some way, the program may croak, or the function may return the
REPLACEMENT CHARACTER, at the discretion of the implementation, and subject to
change in future releases.

=for apidoc Am|UV|toLOWER|UV cp
=for apidoc_item |UV|toLOWER_A|UV cp
=for apidoc_item |UV|toLOWER_L1|UV cp
=for apidoc_item |UV|toLOWER_LATIN1|UV cp
=for apidoc_item |UV|toLOWER_LC|UV cp
=for apidoc_item |UV|toLOWER_uvchr|UV cp|U8* s|STRLEN* lenp
=for apidoc_item |UV|toLOWER_utf8|U8* p|U8* e|U8* s|STRLEN* lenp
=for apidoc_item |UV|toLOWER_utf8_safe|U8* p|U8* e|U8* s|STRLEN* lenp

These all return the lowercase of a character.  The differences are what domain
they operate on, and whether the input is specified as a code point (those
forms with a C<cp> parameter) or as a UTF-8 string (the others).  In the latter
case, the code point to use is the first one in the buffer of UTF-8 encoded
code points, delineated by the arguments S<C<p .. e - 1>>.

C<toLOWER> and C<toLOWER_A> are synonyms of each other.  They return the
lowercase of any uppercase ASCII-range code point.  All other inputs are
returned unchanged.  Since these are macros, the input type may be any integral
one, and the output will occupy the same number of bits as the input.

C<toLOWER_L1> and C<toLOWER_LATIN1> are synonyms of each other.  They behave
identically as C<toLOWER> for ASCII-range input.  But additionally will return
the lowercase of any uppercase code point in the entire 0..255 range, assuming
a Latin-1 encoding (or the EBCDIC equivalent on such platforms).

C<toLOWER_LC> returns the lowercase of the input code point according to the
rules of the current POSIX locale.  Input code points outside the range 0..255
are returned unchanged.

C<toLOWER_uvchr> returns the lowercase of any Unicode code point.  The return
value is identical to that of C<toLOWER_L1> for input code points in the 0..255
range.  The lowercase of the vast majority of Unicode code points is the same
as the code point itself.  For these, and for code points above the legal
Unicode maximum, this returns the input code point unchanged.  It additionally
stores the UTF-8 of the result into the buffer beginning at C<s>, and its
length in bytes into C<*lenp>.  The caller must have made C<s> large enough to
contain at least C<UTF8_MAXBYTES_CASE+1> bytes to avoid possible overflow.

NOTE: the lowercase of a code point may be more than one code point.  The
return value of this function is only the first of these.  The entire lowercase
is returned in C<s>.  To determine if the result is more than a single code
point, you can do something like this:

 uc = toLOWER_uvchr(cp, s, &len);
 if (len > UTF8SKIP(s)) { is multiple code points }
 else { is a single code point }

C<toLOWER_utf8> and C<toLOWER_utf8_safe> are synonyms of each other.  The only
difference between these and C<toLOWER_uvchr> is that the source for these is
encoded in UTF-8, instead of being a code point.  It is passed as a buffer
starting at C<p>, with C<e> pointing to one byte beyond its end.  The C<p>
buffer may certainly contain more than one code point; but only the first one
(up through S<C<e - 1>>) is examined.  If the UTF-8 for the input character is
malformed in some way, the program may croak, or the function may return the
REPLACEMENT CHARACTER, at the discretion of the implementation, and subject to
change in future releases.

=for apidoc Am|UV|toTITLE|UV cp
=for apidoc_item |UV|toTITLE_A|UV cp
=for apidoc_item |UV|toTITLE_uvchr|UV cp|U8* s|STRLEN* lenp
=for apidoc_item |UV|toTITLE_utf8|U8* p|U8* e|U8* s|STRLEN* lenp
=for apidoc_item |UV|toTITLE_utf8_safe|U8* p|U8* e|U8* s|STRLEN* lenp

These all return the titlecase of a character.  The differences are what domain
they operate on, and whether the input is specified as a code point (those
forms with a C<cp> parameter) or as a UTF-8 string (the others).  In the latter
case, the code point to use is the first one in the buffer of UTF-8 encoded
code points, delineated by the arguments S<C<p .. e - 1>>.

C<toTITLE> and C<toTITLE_A> are synonyms of each other.  They return the
titlecase of any lowercase ASCII-range code point.  In this range, the
titlecase is identical to the uppercase.  All other inputs are returned
unchanged.  Since these are macros, the input type may be any integral one, and
the output will occupy the same number of bits as the input.

There is no C<toTITLE_L1> nor C<toTITLE_LATIN1> as the titlecase of some code
points in the 0..255 range is above that range or consists of multiple
characters.  Instead use C<toTITLE_uvchr>.

C<toTITLE_uvchr> returns the titlecase of any Unicode code point.  The return
value is identical to that of C<toTITLE_A> for input code points in the ASCII
range.  The titlecase of the vast majority of Unicode code points is the same
as the code point itself.  For these, and for code points above the legal
Unicode maximum, this returns the input code point unchanged.  It additionally
stores the UTF-8 of the result into the buffer beginning at C<s>, and its
length in bytes into C<*lenp>.  The caller must have made C<s> large enough to
contain at least C<UTF8_MAXBYTES_CASE+1> bytes to avoid possible overflow.

NOTE: the titlecase of a code point may be more than one code point.  The
return value of this function is only the first of these.  The entire titlecase
is returned in C<s>.  To determine if the result is more than a single code
point, you can do something like this:

 uc = toTITLE_uvchr(cp, s, &len);
 if (len > UTF8SKIP(s)) { is multiple code points }
 else { is a single code point }

C<toTITLE_utf8> and C<toTITLE_utf8_safe> are synonyms of each other.  The only
difference between these and C<toTITLE_uvchr> is that the source for these is
encoded in UTF-8, instead of being a code point.  It is passed as a buffer
starting at C<p>, with C<e> pointing to one byte beyond its end.  The C<p>
buffer may certainly contain more than one code point; but only the first one
(up through S<C<e - 1>>) is examined.  If the UTF-8 for the input character is
malformed in some way, the program may croak, or the function may return the
REPLACEMENT CHARACTER, at the discretion of the implementation, and subject to
change in future releases.

=cut

XXX Still undocumented isVERTWS_uvchr and _utf8; it's unclear what their names
really should be.  Also toUPPER_LC and toFOLD_LC, which are subject to change,
and aren't general purpose as they don't work on U+DF, and assert against that.

Note that these macros are repeated in Devel::PPPort, so should also be
patched there.  The file as of this writing is cpan/Devel-PPPort/parts/inc/misc

*/

/*
   void below because that's the best fit, and works for Devel::PPPort
=for apidoc_section $integer
=for apidoc AyT||WIDEST_UTYPE

Yields the widest unsigned integer type on the platform, currently either
C<U32> or C<U64>.  This can be used in declarations such as

 WIDEST_UTYPE my_uv;

or casts

 my_uv = (WIDEST_UTYPE) val;

=cut

*/
#ifdef QUADKIND
#   define WIDEST_UTYPE U64
#else
#   define WIDEST_UTYPE U32
#endif

/* Where there could be some confusion, use this as a static assert in macros
 * to make sure that a parameter isn't a pointer.  But some compilers can't
 * handle this.  The only one known so far that doesn't is gcc 3.3.6; the check
 * below isn't thorough for such an old compiler, so may have to be revised if
 * experience so dictates. */
#if  ! PERL_IS_GCC || PERL_GCC_VERSION_GT(3,3,6)
#  define ASSERT_NOT_PTR(x) ((x) | 0)
#else
#  define ASSERT_NOT_PTR(x) (x)
#endif

/* Likewise, this is effectively a static assert to be used to guarantee the
 * parameter is a pointer */
#define ASSERT_IS_PTR(x) (__ASSERT_(sizeof(*(x))) (x))

/* FITS_IN_8_BITS(c) returns true if c doesn't have  a bit set other than in
 * the lower 8.  It is designed to be hopefully bomb-proof, making sure that no
 * bits of information are lost even on a 64-bit machine, but to get the
 * compiler to optimize it out if possible.  This is because Configure makes
 * sure that the machine has an 8-bit byte, so if c is stored in a byte, the
 * sizeof() guarantees that this evaluates to a constant true at compile time.
 *
 * For Coverity, be always true, because otherwise Coverity thinks
 * it finds several expressions that are always true, independent
 * of operands.  Well, they are, but that is kind of the point.
 */
#ifndef __COVERITY__
  /* The '| 0' part in ASSERT_NOT_PTR ensures a compiler error if c is not
   * integer (like e.g., a pointer) */
#  define FITS_IN_8_BITS(c) (   (sizeof(c) == 1)                            \
                             || (((WIDEST_UTYPE) ASSERT_NOT_PTR(c)) >> 8) == 0)
#else
#  define FITS_IN_8_BITS(c) (1)
#endif

/* Returns true if l <= c <= (l + n), where 'l' and 'n' are non-negative
 * Written this way so that after optimization, only one conditional test is
 * needed.  (The NV casts stop any warnings about comparison always being true
 * if called with an unsigned.  The cast preserves the sign, which is all we
 * care about.) */
#define withinCOUNT(c, l, n)  (__ASSERT_((NV) (l) >= 0)                 \
                               __ASSERT_((NV) (n) >= 0)                 \
                               withinCOUNT_KNOWN_VALID_((c), (l), (n)))

/* For internal use only, this can be used in places where it is known that the
 * parameters to withinCOUNT() are valid, to avoid the asserts.  For example,
 * inRANGE() below, calls this several times, but does all the necessary
 * asserts itself, once.  The reason that this is necessary is that the
 * duplicate asserts were exceeding the internal limits of some compilers */
#define withinCOUNT_KNOWN_VALID_(c, l, n)                                   \
    ((((WIDEST_UTYPE) (c)) - ASSERT_NOT_PTR(l))                             \
                                   <= ((WIDEST_UTYPE) ASSERT_NOT_PTR(n)))

/* Returns true if c is in the range l..u, where 'l' is non-negative
 * Written this way so that after optimization, only one conditional test is
 * needed. */
#define inRANGE(c, l, u) (__ASSERT_((NV) (l) >= 0) __ASSERT_((u) >= (l))    \
   (  (sizeof(c) == sizeof(U8))  ? inRANGE_helper_(U8, (c), (l), ((u)))     \
    : (sizeof(c) == sizeof(U16)) ? inRANGE_helper_(U16,(c), (l), ((u)))     \
    : (sizeof(c) == sizeof(U32)) ? inRANGE_helper_(U32,(c), (l), ((u)))     \
             : (__ASSERT_(sizeof(c) == sizeof(WIDEST_UTYPE))                \
                          inRANGE_helper_(WIDEST_UTYPE,(c), (l), ((u))))))

/* For internal use, this is used by machine-generated code which generates
 * known valid calls, with a known sizeof().  This avoids the extra code and
 * asserts that were exceeding internal limits of some compilers. */
#define inRANGE_helper_(cast, c, l, u)                                      \
                    withinCOUNT_KNOWN_VALID_(((cast) (c)), (l), ((u) - (l)))

#ifdef EBCDIC
#   ifndef _ALL_SOURCE
        /* The native libc isascii() et.al. functions return the wrong results
         * on at least z/OS unless this is defined. */
#       error   _ALL_SOURCE should probably be defined
#   endif
#else
    /* There is a simple definition of ASCII for ASCII platforms.  But the
     * EBCDIC one isn't so simple, so is defined using table look-up like the
     * other macros below.
     *
     * The cast here is used instead of '(c) >= 0', because some compilers emit
     * a warning that that test is always true when the parameter is an
     * unsigned type.  khw supposes that it could be written as
     *      && ((c) == '\0' || (c) > 0)
     * to avoid the message, but the cast will likely avoid extra branches even
     * with stupid compilers. */
#   define isASCII(c)    (((WIDEST_UTYPE) ASSERT_NOT_PTR(c)) < 128)
#endif

/* Take the eight possible bit patterns of the lower 3 bits and you get the
 * lower 3 bits of the 8 octal digits, in both ASCII and EBCDIC, so those bits
 * can be ignored.  If the rest match '0', we have an octal */
#define isOCTAL_A(c)  ((((WIDEST_UTYPE) ASSERT_NOT_PTR(c)) & ~7) == '0')

#ifdef H_PERL       /* If have access to perl.h, lookup in its table */

/* Character class numbers.  For internal core Perl use only.  The ones less
 * than 32 are used in PL_charclass[] and the ones up through the one that
 * corresponds to <_HIGHEST_REGCOMP_DOT_H_SYNC> are used by regcomp.h and
 * related files.  PL_charclass ones use names used in l1_char_class_tab.h but
 * their actual definitions are here.  If that file has a name not used here,
 * it won't compile.
 *
 * The first group of these is ordered in what I (khw) estimate to be the
 * frequency of their use.  This gives a slight edge to exiting a loop earlier
 * (in reginclass() in regexec.c).  Except \v should be last, as it isn't a
 * real Posix character class, and some (small) inefficiencies in regular
 * expression handling would be introduced by putting it in the middle of those
 * that are.  Also, cntrl and ascii come after the others as it may be useful
 * to group these which have no members that match above Latin1, (or above
 * ASCII in the latter case) */

#  define _CC_WORDCHAR           0      /* \w and [:word:] */
#  define _CC_DIGIT              1      /* \d and [:digit:] */
#  define _CC_ALPHA              2      /* [:alpha:] */
#  define _CC_LOWER              3      /* [:lower:] */
#  define _CC_UPPER              4      /* [:upper:] */
#  define _CC_PUNCT              5      /* [:punct:] */
#  define _CC_PRINT              6      /* [:print:] */
#  define _CC_ALPHANUMERIC       7      /* [:alnum:] */
#  define _CC_GRAPH              8      /* [:graph:] */
#  define _CC_CASED              9      /* [:lower:] or [:upper:] under /i */
#  define _CC_SPACE             10      /* \s, [:space:] */
#  define _CC_BLANK             11      /* [:blank:] */
#  define _CC_XDIGIT            12      /* [:xdigit:] */
#  define _CC_CNTRL             13      /* [:cntrl:] */
#  define _CC_ASCII             14      /* [:ascii:] */
#  define _CC_VERTSPACE         15      /* \v */

#  define _HIGHEST_REGCOMP_DOT_H_SYNC _CC_VERTSPACE

/* The members of the third group below do not need to be coordinated with data
 * structures in regcomp.[ch] and regexec.c. */
#  define _CC_IDFIRST                  16
#  define _CC_CHARNAME_CONT            17
#  define _CC_NONLATIN1_FOLD           18
#  define _CC_NONLATIN1_SIMPLE_FOLD    19
#  define _CC_QUOTEMETA                20
#  define _CC_NON_FINAL_FOLD           21
#  define _CC_IS_IN_SOME_FOLD          22
#  define _CC_BINDIGIT                 23
#  define _CC_OCTDIGIT                 24
#  define _CC_MNEMONIC_CNTRL           25

/* Unused: 26-31
 * If more bits are needed, one could add a second word for non-64bit
 * QUAD_IS_INT systems, using some #ifdefs to distinguish between having a 2nd
 * word or not.  The IS_IN_SOME_FOLD bit is the most easily expendable, as it
 * is used only for optimization (as of this writing), and differs in the
 * Latin1 range from the ALPHA bit only in two relatively unimportant
 * characters: the masculine and feminine ordinal indicators, so removing it
 * would just cause /i regexes which match them to run less efficiently.
 * Similarly the EBCDIC-only bits are used just for speed, and could be
 * replaced by other means */

#if defined(PERL_CORE) || defined(PERL_EXT)
/* An enum version of the character class numbers, to help compilers
 * optimize */
typedef enum {
    _CC_ENUM_ALPHA          = _CC_ALPHA,
    _CC_ENUM_ALPHANUMERIC   = _CC_ALPHANUMERIC,
    _CC_ENUM_ASCII          = _CC_ASCII,
    _CC_ENUM_BLANK          = _CC_BLANK,
    _CC_ENUM_CASED          = _CC_CASED,
    _CC_ENUM_CNTRL          = _CC_CNTRL,
    _CC_ENUM_DIGIT          = _CC_DIGIT,
    _CC_ENUM_GRAPH          = _CC_GRAPH,
    _CC_ENUM_LOWER          = _CC_LOWER,
    _CC_ENUM_PRINT          = _CC_PRINT,
    _CC_ENUM_PUNCT          = _CC_PUNCT,
    _CC_ENUM_SPACE          = _CC_SPACE,
    _CC_ENUM_UPPER          = _CC_UPPER,
    _CC_ENUM_VERTSPACE      = _CC_VERTSPACE,
    _CC_ENUM_WORDCHAR       = _CC_WORDCHAR,
    _CC_ENUM_XDIGIT         = _CC_XDIGIT
} _char_class_number;
#endif

#define POSIX_CC_COUNT    (_HIGHEST_REGCOMP_DOT_H_SYNC + 1)

START_EXTERN_C
#  ifdef DOINIT
EXTCONST  U32 PL_charclass[] = {
#    include "l1_char_class_tab.h"
};

#  else /* ! DOINIT */
EXTCONST U32 PL_charclass[];
#  endif
END_EXTERN_C

    /* The 1U keeps Solaris from griping when shifting sets the uppermost bit */
#   define _CC_mask(classnum) (1U << (classnum))

    /* For internal core Perl use only: the base macro for defining macros like
     * isALPHA */
#   define _generic_isCC(c, classnum) cBOOL(FITS_IN_8_BITS(c)    \
                && (PL_charclass[(U8) (c)] & _CC_mask(classnum)))

    /* The mask for the _A versions of the macros; it just adds in the bit for
     * ASCII. */
#   define _CC_mask_A(classnum) (_CC_mask(classnum) | _CC_mask(_CC_ASCII))

    /* For internal core Perl use only: the base macro for defining macros like
     * isALPHA_A.  The foo_A version makes sure that both the desired bit and
     * the ASCII bit are present */
#   define _generic_isCC_A(c, classnum) (FITS_IN_8_BITS(c)      \
        && ((PL_charclass[(U8) (c)] & _CC_mask_A(classnum))     \
                                   == _CC_mask_A(classnum)))

/* On ASCII platforms certain classes form a single range.  It's faster to
 * special case these.  isDIGIT is a single range on all platforms */
#   ifdef EBCDIC
#     define isALPHA_A(c)  _generic_isCC_A(c, _CC_ALPHA)
#     define isGRAPH_A(c)  _generic_isCC_A(c, _CC_GRAPH)
#     define isLOWER_A(c)  _generic_isCC_A(c, _CC_LOWER)
#     define isPRINT_A(c)  _generic_isCC_A(c, _CC_PRINT)
#     define isUPPER_A(c)  _generic_isCC_A(c, _CC_UPPER)
#   else
      /* By folding the upper and lowercase, we can use a single range */
#     define isALPHA_A(c)  inRANGE((~('A' ^ 'a') & (c)), 'A', 'Z')
#     define isGRAPH_A(c)  inRANGE(c, ' ' + 1, 0x7e)
#     define isLOWER_A(c)  inRANGE(c, 'a', 'z')
#     define isPRINT_A(c)  inRANGE(c, ' ', 0x7e)
#     define isUPPER_A(c)  inRANGE(c, 'A', 'Z')
#   endif
#   define isALPHANUMERIC_A(c) _generic_isCC_A(c, _CC_ALPHANUMERIC)
#   define isBLANK_A(c)  _generic_isCC_A(c, _CC_BLANK)
#   define isCNTRL_A(c)  _generic_isCC_A(c, _CC_CNTRL)
#   define isDIGIT_A(c)  inRANGE(c, '0', '9')
#   define isPUNCT_A(c)  _generic_isCC_A(c, _CC_PUNCT)
#   define isSPACE_A(c)  _generic_isCC_A(c, _CC_SPACE)
#   define isWORDCHAR_A(c) _generic_isCC_A(c, _CC_WORDCHAR)
#   define isXDIGIT_A(c)  _generic_isCC(c, _CC_XDIGIT) /* No non-ASCII xdigits
                                                        */
#   define isIDFIRST_A(c) _generic_isCC_A(c, _CC_IDFIRST)
#   define isALPHA_L1(c)  _generic_isCC(c, _CC_ALPHA)
#   define isALPHANUMERIC_L1(c) _generic_isCC(c, _CC_ALPHANUMERIC)
#   define isBLANK_L1(c)  _generic_isCC(c, _CC_BLANK)

    /* continuation character for legal NAME in \N{NAME} */
#   define isCHARNAME_CONT(c) _generic_isCC(c, _CC_CHARNAME_CONT)

#   define isCNTRL_L1(c)  _generic_isCC(c, _CC_CNTRL)
#   define isGRAPH_L1(c)  _generic_isCC(c, _CC_GRAPH)
#   define isLOWER_L1(c)  _generic_isCC(c, _CC_LOWER)
#   define isPRINT_L1(c)  _generic_isCC(c, _CC_PRINT)
#   define isPSXSPC_L1(c)  isSPACE_L1(c)
#   define isPUNCT_L1(c)  _generic_isCC(c, _CC_PUNCT)
