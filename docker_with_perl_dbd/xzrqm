prologue, in which case they exact position reported is somewhere in the
relevant markup, but not necessarily as meaningful as for other
events.</p>

<p>The position reporting functions are accurate only outside of the
DTD.  In other words, they usually return bogus information when
called from within a DTD declaration handler.</p>

<h4 id="XML_GetErrorCode">XML_GetErrorCode</h4>
<pre class="fcndec">
enum XML_Error XMLCALL
XML_GetErrorCode(XML_Parser p);
</pre>
<div class="fcndef">
Return what type of error has occurred.
</div>

<h4 id="XML_ErrorString">XML_ErrorString</h4>
<pre class="fcndec">
const XML_LChar * XMLCALL
XML_ErrorString(enum XML_Error code);
</pre>
<div class="fcndef">
Return a string describing the error corresponding to code.
The code should be one of the enums that can be returned from
<code><a href= "#XML_GetErrorCode" >XML_GetErrorCode</a></code>.
</div>

<h4 id="XML_GetCurrentByteIndex">XML_GetCurrentByteIndex</h4>
<pre class="fcndec">
XML_Index XMLCALL
XML_GetCurrentByteIndex(XML_Parser p);
</pre>
<div class="fcndef">
Return the byte offset of the position.  This always corresponds to
the values returned by <code><a href= "#XML_GetCurrentLineNumber"
>XML_GetCurrentLineNumber</a></code> and <code><a href=
"#XML_GetCurrentColumnNumber" >XML_GetCurrentColumnNumber</a></code>.
</div>

<h4 id="XML_GetCurrentLineNumber">XML_GetCurrentLineNumber</h4>
<pre class="fcndec">
XML_Size XMLCALL
XML_GetCurrentLineNumber(XML_Parser p);
</pre>
<div class="fcndef">
Return the line number of the position.  The first line is reported as
<code>1</code>.
</div>

<h4 id="XML_GetCurrentColumnNumber">XML_GetCurrentColumnNumber</h4>
<pre class="fcndec">
XML_Size XMLCALL
XML_GetCurrentColumnNumber(XML_Parser p);
</pre>
<div class="fcndef">
Return the offset, from the beginning of the current line, of
the position.
</div>

<h4 id="XML_GetCurrentByteCount">XML_GetCurrentByteCount</h4>
<pre class="fcndec">
int XMLCALL
XML_GetCurrentByteCount(XML_Parser p);
</pre>
<div class="fcndef">
Return the number of bytes in the current event. Returns
<code>0</code> if the event is inside a reference to an internal
entity and for the end-tag event for empty element tags (the later can
be used to distinguish empty-element tags from empty elements using
separate start and end tags).
</div>

<h4 id="XML_GetInputContext">XML_GetInputContext</h4>
<pre class="fcndec">
const char * XMLCALL
XML_GetInputContext(XML_Parser p,
                    int *offset,
                    int *size);
</pre>
<div class="fcndef">

<p>Returns the parser's input buffer, sets the integer pointed at by
<code>offset</code> to the offset within this buffer of the current
parse position, and set the integer pointed at by <code>size</code> to
the size of the returned buffer.</p>

<p>This should only be called from within a handler during an active
parse and the returned buffer should only be referred to from within
the handler that made the call. This input buffer contains the
untranslated bytes of the input.</p>

<p>Only a limited amount of context is kept, so if the event
triggering a call spans over a very large amount of input, the actual
parse position may be before the beginning of the buffer.</p>

<p>If <code>XML_CONTEXT_BYTES</code> is not defined, this will always
return NULL.</p>
</div>

<h3><a name="billion-laughs">Billion Laughs Attack Protection</a></h3>

<p>The functions in this section configure the built-in
  protection against various forms of
  <a href="https://en.wikipedia.org/wiki/Billion_laughs_attack">billion laughs attacks</a>.</p>

<h4 id="XML_SetBillionLaughsAttackProtectionMaximumAmplification">XML_SetBillionLaughsAttackProtectionMaximumAmplification</h4>
<pre class="fcndec">
/* Added in Expat 2.4.0. */
XML_Bool XMLCALL
XML_SetBillionLaughsAttackProtectionMaximumAmplification(XML_Parser p,
                                                         float maximumAmplificationFactor);
</pre>
<div class="fcndef">
  <p>
    Sets the maximum tolerated amplification factor
    for protection against
    <a href="https://en.wikipedia.org/wiki/Billion_laughs_attack">billion laughs attacks</a>
    (default: <code>100.0</code>)
    of parser <code>p</code> to <code>maximumAmplificationFactor</code>, and
    returns <code>XML_TRUE</code> upon success and <code>XML_FALSE</code> upon error.
  </p>

  The amplification factor is calculated as ..
  <pre>
    amplification := (direct + indirect) / direct
  </pre>
  .. while parsing, whereas
  <code>direct</code> is the number of bytes read from the primary document in parsing and
  <code>indirect</code> is the number of bytes added by expanding entities and reading of external DTD files, combined.

  <p>For a call to <code>XML_SetBillionLaughsAttackProtectionMaximumAmplification</code> to succeed:</p>
  <ul>
    <li>parser <code>p</code> must be a non-<code>NULL</code> root parser (without any parent parsers) and</li>
    <li><code>maximumAmplificationFactor</code> must be non-<code>NaN</code> and greater than or equal to <code>1.0</code>.</li>
  </ul>

  <p>
    <strong>Note:</strong>
    If you ever need to increase this value for non-attack payload,
    please <a href="https://github.com/libexpat/libexpat/issues">file a bug report</a>.
  </p>

  <p>
    <strong>Note:</strong>
    Peak amplifications
    of factor 15,000 for the entire payload and
    of factor 30,000 in the middle of parsing
    have been observed with small benign files in practice.

    So if you do reduce the maximum allowed amplification,
    please make sure that the activation threshold is still big enough
    to not end up with undesired false positives (i.e. benign files being rejected).
  </p>
</div>

<h4 id="XML_SetBillionLaughsAttackProtectionActivationThreshold">XML_SetBillionLaughsAttackProtectionActivationThreshold</h4>
<pre class="fcndec">
/* Added in Expat 2.4.0. */
XML_Bool XMLCALL
XML_SetBillionLaughsAttackProtectionActivationThreshold(XML_Parser p,
                                                        unsigned long long activationThresholdBytes);
</pre>
<div class="fcndef">
  <p>
    Sets number of output bytes (including amplification from entity expansion and reading DTD files)
    needed to activate protection against
    <a href="https://en.wikipedia.org/wiki/Billion_laughs_attack">billion laughs attacks</a>
    (default: <code>8 MiB</code>)
    of parser <code>p</code> to <code>activationThresholdBytes</code>, and
    returns <code>XML_TRUE</code> upon success and <code>XML_FALSE</code> upon error.
  </p>

  <p>For a call to <code>XML_SetBillionLaughsAttackProtectionActivationThreshold</code> to succeed:</p>
  <ul>
    <li>parser <code>p</code> must be a non-<code>NULL</code> root parser (without any parent parsers).</li>
  </ul>

  <p>
    <strong>Note:</strong>
    If you ever need to increase this value for non-attack payload,
    please <a href="https://github.com/libexpat/libexpat/issues">file a bug report</a>.
  </p>

  <p>
    <strong>Note:</strong>
    Activation thresholds below 4 MiB are known to break support for
    <a href="https://en.wikipedia.org/wiki/Darwin_Information_Typing_Architecture">DITA</a> 1.3 payload
    and are hence not recommended.
  </p>
</div>

<h3><a name="miscellaneous">Miscellaneous functions</a></h3>

<p>The functions in this section either obtain state information from
the parser or can be used to dynamically set parser options.</p>

<h4 id="XML_SetUserData">XML_SetUserData</h4>
<pre class="fcndec">
void XMLCALL
XML_SetUserData(XML_Parser p,
                void *userData);
</pre>
<div class="fcndef">
This sets the user data pointer that gets passed to handlers.  It
overwrites any previous value for this pointer. Note that the
application is responsible for freeing the memory associated with
<code>userData</code> when it is finished with the parser. So if you
call this when there's already a pointer there, and you haven't freed
the memory associated with it, then you've probably just leaked
memory.
</div>

<h4 id="XML_GetUserData">XML_GetUserData</h4>
<pre class="fcndec">
void * XMLCALL
XML_GetUserData(XML_Parser p);
</pre>
<div class="fcndef">
This returns the user data pointer that gets passed to handlers.
It is actually implemented as a macro.
</div>

<h4 id="XML_UseParserAsHandlerArg">XML_UseParserAsHandlerArg</h4>
<pre class="fcndec">
void XMLCALL
XML_UseParserAsHandlerArg(XML_Parser p);
</pre>
<div class="fcndef">
After this is called, handlers receive the parser in their
<code>userData</code> arguments.  The user data can still be obtained
using the <code><a href= "#XML_GetUserData"
>XML_GetUserData</a></code> function.
</div>

<h4 id="XML_SetBase">XML_SetBase</h4>
<pre class="fcndec">
enum XML_Status XMLCALL
XML_SetBase(XML_Parser p,
            const XML_Char *base);
</pre>
<div class="fcndef">
Set the base to be used for resolving relative URIs in system
identifiers.  The return value is <code>XML_STATUS_ERROR</code> if
there's no memory to store base, otherwise it's
<code>XML_STATUS_OK</code>.
</div>

<h4 id="XML_GetBase">XML_GetBase</h4>
<pre class="fcndec">
const XML_Char * XMLCALL
XML_GetBase(XML_Parser p);
</pre>
<div class="fcndef">
Return the base for resolving relative URIs.
</div>

<h4 id="XML_GetSpecifiedAttributeCount">XML_GetSpecifiedAttributeCount</h4>
<pre class="fcndec">
int XMLCALL
XML_GetSpecifiedAttributeCount(XML_Parser p);
</pre>
<div class="fcndef">
When attributes are reported to the start handler in the atts vector,
attributes that were explicitly set in the element occur before any
attributes that receive their value from default information in an
ATTLIST declaration. This function returns the number of attributes
that were explicitly set times two, thus giving the offset in the
<code>atts</code> array passed to the start tag handler of the first
attribute set due to defaults. It supplies information for the last
call to a start handler. If called inside a start handler, then that
means the current call.
</div>

<h4 id="XML_GetIdAttributeIndex">XML_GetIdAttributeIndex</h4>
<pre class="fcndec">
int XMLCALL
XML_GetIdAttributeIndex(XML_Parser p);
</pre>
<div class="fcndef">
Returns the index of the ID attribute passed in the atts array in the
last call to <code><a href= "#XML_StartElementHandler"
>XML_StartElementHandler</a></code>, or -1 if there is no ID
attribute. If called inside a start handler, then that means the
current call.
</div>

<h4 id="XML_GetAttributeInfo">XML_GetAttributeInfo</h4>
<pre class="fcndec">
const XML_AttrInfo * XMLCALL
XML_GetAttributeInfo(XML_Parser parser);
</pre>
<pre class="signature">
typedef struct {
  XML_Index  nameStart;  /* Offset to beginning of the attribute name. */
  XML_Index  nameEnd;    /* Offset after the attribute name's last byte. */
  XML_Index  valueStart; /* Offset to beginning of the attribute value. */
  XML_Index  valueEnd;   /* Offset after the attribute value's last byte. */
} XML_AttrInfo;
</pre>
<div class="fcndef">
Returns an array of <code>XML_AttrInfo</code> structures for the
attribute/value pairs passed in the last call to the
<code>XML_StartElementHandler</code> that were specified
in the start-tag rather than defaulted. Each attribute/value pair counts
as 1; thus the number of entries in the array is
<code>XML_GetSpecifiedAttributeCount(parser) / 2</code>.
</div>

<h4 id="XML_SetEncoding">XML_SetEncoding</h4>
<pre class="fcndec">
enum XML_Status XMLCALL
XML_SetEncoding(XML_Parser p,
                const XML_Char *encoding);
</pre>
<div class="fcndef">
Set the encoding to be used by the parser. It is equivalent to
passing a non-null encoding argument to the parser creation functions.
It must not be called after <code><a href= "#XML_Parse"
>XML_Parse</a></code> or <code><a href= "#XML_ParseBuffer"
>XML_ParseBuffer</a></code> have been called on the given parser.
Returns <code>XML_STATUS_OK</code> on success or
<code>XML_STATUS_ERROR</code> on error.
</div>

<h4 id="XML_SetParamEntityParsing">XML_SetParamEntityParsing</h4>
<pre class="fcndec">
int XMLCALL
XML_SetParamEntityParsing(XML_Parser p,
                          enum XML_ParamEntityParsing code);
</pre>
<div class="fcndef">
This enables parsing of parameter entities, including the external
parameter entity that is the external DTD subset, according to
<code>code</code>.
The choices for <code>code</code> are:
<ul>
<li><code>XML_PARAM_ENTITY_PARSING_NEVER</code></li>
<li><code>XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE</code></li>
<li><code>XML_PARAM_ENTITY_PARSING_ALWAYS</code></li>
</ul>
<b>Note:</b> If <code>XML_SetParamEntityParsing</code> is called after 
<code>XML_Parse</code> or <code>XML_ParseBuffer</code>, then it has
no effect and will always return 0.
</div>

<h4 id="XML_SetHashSalt">XML_SetHashSalt</h4>
<pre class="fcndec">
int XMLCALL
XML_SetHashSalt(XML_Parser p,
                unsigned long hash_salt);
</pre>
<div class="fcndef">
Sets the hash salt to use for internal hash calculations.
Helps in preventing DoS attacks based on predicting hash
function behavior. In order to have an effect this must be called
before parsing has started. Returns 1 if successful, 0 when called
after <code>XML_Parse</code> or <code>XML_ParseBuffer</code>.
<p><b>Note:</b> This call is optional, as the parser will auto-generate
a new random salt value if no value has been set at the start of parsing.</p>
<p><b>Note:</b> One should not call <code>XML_SetHashSalt</code> with a
hash salt value of 0, as this value is used as sentinel value to indicate
that <code>XML_SetHashSalt</code> has <b>not</b> been called. Consequently
such a call will have no effect, even if it returns 1.</p>
</div>

<h4 id="XML_UseForeignDTD">XML_UseForeignDTD</h4>
<pre class="fcndec">
enum XML_Error XMLCALL
XML_UseForeignDTD(XML_Parser parser, XML_Bool useDTD);
</pre>
<div class="fcndef">
<p>This function allows an application to provide an external subset
for the document type declaration for documents which do not specify
an external subset of their own.  For documents which specify an
external subset in their DOCTYPE declaration, the application-provided
subset will be ignored.  If the document does not contain a DOCTYPE
declaration at all and <code>useDTD</code> is true, the
application-provided subset will be parsed, but the
<code>startDoctypeDeclHandler</code> and
<code>endDoctypeDeclHandler</code> functions, if set, will not be
called.  The setting of parameter entity parsing, controlled using
<code><a href= "#XML_SetParamEntityParsing"
>XML_SetParamEntityParsing</a></code>, will be honored.</p>

<p>The application-provided external subset is read by calling the
external entity reference handler set via <code><a href=
"#XML_SetExternalEntityRefHandler"
>XML_SetExternalEntityRefHandler</a></code> with both
<code>publicId</code> and <code>systemId</code> set to NULL.</p>

<p>If this function is called after parsing has begun, it returns
<code>XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING</code> and ignores
<code>useDTD</code>.  If called when Expat has been compiled without
DTD support, it returns
<code>XML_ERROR_FEATURE_REQUIRES_XML_DTD</code>.  Otherwise, it
returns <code>XML_ERROR_NONE</code>.</p>

<p><b>Note:</b> For the purpose of checking WFC: Entity Declared, passing
<code>useDTD == XML_TRUE</code> will make the parser behave as if
the document had a DTD with an external subset. This holds true even if
the external entity reference handler returns without action.</p>
</div>

<h4 id="XML_SetReturnNSTriplet">XML_SetReturnNSTriplet</h4>
<pre class="fcndec">
void XMLCALL
XML_SetReturnNSTriplet(XML_Parser parser,
                       int        do_nst);
</pre>
<div class="fcndef">
<p>
This function only has an effect when using a parser created with
<code><a href= "#XML_ParserCreateNS" >XML_ParserCreateNS</a></code>,
i.e. when namespace processing is in effect. The <code>do_nst</code>
sets whether or not prefixes are returned with names qualified with a
namespace prefix. If this function is called with <code>do_nst</code>
non-zero, then afterwards namespace qualified names (that is qualified
with a prefix as opposed to belonging to a default namespace) are
returned as a triplet with the three parts separated by the namespace
separator specified when the parser was created.  The order of
returned parts is URI, local name, and prefix.</p> <p>If
<code>do_nst</code> is zero, then namespaces are reported in the
default manner, URI then local_name separated by the namespace
separator.</p>
</div>

<h4 id="XML_DefaultCurrent">XML_DefaultCurrent</h4>
<pre class="fcndec">
void XMLCALL
XML_DefaultCurrent(XML_Parser parser);
</pre>
<div class="fcndef">
This can be called within a handler for a start element, end element,
processing instruction or character data.  It causes the corresponding
markup to be passed to the default handler set by <code><a
href="#XML_SetDefaultHandler" >XML_SetDefaultHandler</a></code> or
<code><a href="#XML_SetDefaultHandlerExpand"
>XML_SetDefaultHandlerExpand</a></code>.  It does nothing if there is
not a default handler.
</div>

<h4 id="XML_ExpatVersion">XML_ExpatVersion</h4>
<pre class="fcndec">
XML_LChar * XMLCALL
XML_ExpatVersion();
</pre>
<div class="fcndef">
Return the library version as a string (e.g. <code>"expat_1.95.1"</code>).
</div>

<h4 id="XML_ExpatVersionInfo">XML_ExpatVersionInfo</h4>
<pre class="fcndec">
struct XML_Expat_Version XMLCALL
XML_ExpatVersionInfo();
</pre>
<pre class="signature">
typedef struct {
  int major;
  int minor;
  int micro;
} XML_Expat_Version;
</pre>
<div class="fcndef">
Return the library version information as a structure.
Some macros are also defined that support compile-time tests of the
library version:
<ul>
<li><code>XML_MAJOR_VERSION</code></li>
<li><code>XML_MINOR_VERSION</code></li>
<li><code>XML_MICRO_VERSION</code></li>
</ul>
Testing these constants is currently the best way to determine if
particular parts of the Expat API are available.
</div>

<h4 id="XML_GetFeatureList">XML_GetFeatureList</h4>
<pre class="fcndec">
const XML_Feature * XMLCALL
XML_GetFeatureList();
</pre>
<pre class="signature">
enum XML_FeatureEnum {
  XML_FEATURE_END = 0,
  XML_FEATURE_UNICODE,
  XML_FEATURE_UNICODE_WCHAR_T,
  XML_FEATURE_DTD,
  XML_FEATURE_CONTEXT_BYTES,
  XML_FEATURE_MIN_SIZE,
  XML_FEATURE_SIZEOF_XML_CHAR,
  XML_FEATURE_SIZEOF_XML_LCHAR,
  XML_FEATURE_NS,
  XML_FEATURE_LARGE_SIZE
};

typedef struct {
  enum XML_FeatureEnum  feature;
  XML_LChar            *name;
  long int              value;
} XML_Feature;
</pre>
<div class="fcndef">
<p>Returns a list of "feature" records, providing details on how
Expat was configured at compile time.  Most applications should not
need to worry about this, but this information is otherwise not
available from Expat.  This function allows code that does need to
check these features to do so at runtime.</p>

<p>The return value is an array of <code>XML_Feature</code>,
terminated by a record with a <code>feature</code> of
<code>XML_FEATURE_END</code> and <code>name</code> of NULL,
identifying the feature-test macros Expat was compiled with.  Since an
application that requires this kind of information needs to determine
the type of character the <code>name</code> points to, records for the
<code>XML_FEATURE_SIZEOF_XML_CHAR</code> and
<code>XML_FEATURE_SIZEOF_XML_LCHAR</code> will be located at the
beginning of the list, followed by <code>XML_FEATURE_UNICODE</code>
and <code>XML_FEATURE_UNICODE_WCHAR_T</code>, if they are present at
all.</p>

<p>Some features have an associated value.  If there isn't an
associated value, the <code>value</code> field is set to 0.  At this
time, the following features have been defined to have values:</p>

<dl>
  <dt><code>XML_FEATURE_SIZEOF_XML_CHAR</code></dt>
  <dd>The number of bytes occupied by one <code>XML_Char</code>
  character.</dd>
  <dt><code>XML_FEATURE_SIZEOF_XML_LCHAR</code></dt>
  <dd>The number of bytes occupied by one <code>XML_LChar</code>
  character.</dd>
  <dt><code>XML_FEATURE_CONTEXT_BYTES</code></dt>
  <dd>The maximum number of characters of context which can be
  reported by <code><a href= "#XML_GetInputContext"
  >XML_GetInputContext</a></code>.</dd>
</dl>
</div>

<h4 id="XML_FreeContentModel">XML_FreeContentModel</h4>
<pre class="fcndec">
void XMLCALL
XML_FreeContentModel(XML_Parser parser, XML_Content *model);
</pre>
<div class="fcndef">
Function to deallocate the <code>model</code> argument passed to the
<code>XML_ElementDeclHandler</code> callback set using <code><a
href="#XML_SetElementDeclHandler" >XML_ElementDeclHandler</a></code>.
This function should not be used for any other purpose.
</div>

<p>The following functions allow external code to share the memory
allocator an <code>XML_Parser</code> has been configured to use.  This
is especially useful for third-party libraries that interact with a
parser object created by application code, or heavily layered
applications.  This can be essential when using dynamically loaded
libraries which use different C standard libraries (this can happen on
Windows, at least).</p>

<h4 id="XML_MemMalloc">XML_MemMalloc</h4>
<pre class="fcndec">
void * XMLCALL
XML_MemMalloc(XML_Parser parser, size_t size);
</pre>
<div class="fcndef">
Allocate <code>size</code> bytes of memory using the allocator the
<code>parser</code> object has been configured to use.  Returns a
pointer to the memory or NULL on failure.  Memory allocated in this
way must be freed using <code><a href="#XML_MemFree"
>XML_MemFree</a></code>.
</div>

<h4 id="XML_MemRealloc">XML_MemRealloc</h4>
<pre class="fcndec">
void * XMLCALL
XML_MemRealloc(XML_Parser parser, void *ptr, size_t size);
</pre>
<div class="fcndef">
Allocate <code>size</code> bytes of memory using the allocator the
<code>parser</code> object has been configured to use.
<code>ptr</code> must point to a block of memory allocated by <code><a
href="#XML_MemMalloc" >XML_MemMalloc</a></code> or
<code>XML_MemRealloc</code>, or be NULL.  This function tries to
expand the block pointed to by <code>ptr</code> if possible.  Returns
a pointer to the memory or NULL on failure.  On success, the original
block has either been expanded or freed.  On failure, the original
block has not been freed; the caller is responsible for freeing the
original block.  Memory allocated in this way must be freed using
<code><a href="#XML_MemFree"
>XML_MemFree</a></code>.
</div>

<h4 id="XML_MemFree">XML_MemFree</h4>
<pre class="fcndec">
void XMLCALL
XML_MemFree(XML_Parser parser, void *ptr);
</pre>
<div class="fcndef">
Free a block of memory pointed to by <code>ptr</code>.  The block must
have been allocated by <code><a href="#XML_MemMalloc"
>XML_MemMalloc</a></code> or <code>XML_MemRealloc</code>, or be NULL.
</div>

<hr />

  <div class="footer">
    Found a bug in the documentation?
    <a href="https://github.com/libexpat/libexpat/issues">Please file a bug report.</a>
  </div>

</div>
</body>
</html>
                                                                                                                                                                                              usr/share/doc/libexpat1-dev/expat.html/style.css                                                    0000644 0000000 0000000 00000003640 14325775735 020354  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
                            __  __            _
                         ___\ \/ /_ __   __ _| |_
                        / _ \\  /| '_ \ / _` | __|
                       |  __//  \| |_) | (_| | |_
                        \___/_/\_\ .__/ \__,_|\__|
                                 |_| XML parser

   Copyright (c) 2000      Clark Cooper <coopercc@users.sourceforge.net>
   Copyright (c) 2000-2004 Fred L. Drake, Jr. <fdrake@users.sourceforge.net>
   Copyright (c) 2021      Sebastian Pipping <sebastian@pipping.org>
   Licensed under the MIT license:

   Permission is  hereby granted,  free of charge,  to any  person obtaining
   a  copy  of  this  software   and  associated  documentation  files  (the
   "Software"),  to  deal in  the  Software  without restriction,  including
   without  limitation the  rights  to use,  copy,  modify, merge,  publish,
   distribute, sublicense, and/or sell copies of the Software, and to permit
   persons  to whom  the Software  is  furnished to  do so,  subject to  the
   following conditions:

   The above copyright  notice and this permission notice  shall be included
   in all copies or substantial portions of the Software.

   THE  SOFTWARE  IS  PROVIDED  "AS  IS",  WITHOUT  WARRANTY  OF  ANY  KIND,
   EXPRESS  OR IMPLIED,  INCLUDING  BUT  NOT LIMITED  TO  THE WARRANTIES  OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
   NO EVENT SHALL THE AUTHORS OR  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
   DAMAGES OR  OTHER LIABILITY, WHETHER  IN AN  ACTION OF CONTRACT,  TORT OR
   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
   USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

/* Stop not using half the screen */
body {
  max-width: none; /* was: 80ch */
}

.cpp-symbols dt {
  font-family: monospace;
}

/* Resemble style of <footer> which is not part of xhtml1-strict */
.footer {
  font-size: var(--ok-fs-5);
  color: var(--ok-tc-1);
}
                                                                                                usr/share/doc/libexpat1-dev/expat.html/xmlwf.xml.gz                                                 0000644 0000000 0000000 00000012263 14325775735 021001  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ‹     í\[WI’~F¿"›ÎJ* g¼PÓÆ6î¡Ç#ÆÓg½Ã¦ªRR5¥ÊšÊ*„öøÇï‘™u½ö¾lŸ3ƒê’‘‘qı"2Ëƒz½¸ç¿ËKû¿ÆÎ=/_~_\Ú1ø¿Ë¯âëİ#q)¾|Áß¯â9~Ñõ‰¯÷õ®!_‰jñ…oãz‹¦¸o’/`+¸¾€·>~Ñu÷òë—{&iLâÿøğ^d27*ïĞ€7:[äñdZˆ­p[ìíììÚWÏC]âu®S£S1Ù¯ò85YœöC=;\9|¯‡ÿûQ¼ËU$Ş÷ÅÛ\^©®ø5ï‹Á8¢‹W%¦6}£Ë<TcOT?UÅjb±¼üMæ‰ø,ÃDÎÕ•\áòÕÜ]Ş9x÷8ÙÛçj$MËT|Œ3°>ão½Êì­>Ø¸ƒˆåà(´¸O2¨$×:ş]$î¾ŠÔ”î¦ğï–Â§©òXü*gÊˆAÎW¯æq‚áJ™‚Æ÷Ë«•$öv,‰_µgyAêø]ÓßWòTw*cÏérÏ I¹ƒb„?¯
uS”2‰‹E5ô"Mâ+%fÚBÅñM&‹.=(¦±ã8QC?”[¦‘ÊñX‰_N/HßJ¼Õa9Si!‹L¾C•%vû»ıN¯wØüğöìÍğ·Ç"Wc¼–/ÄÇ‹×ïOŞˆÍ^œŸœÁÛá[¢óZë+6Õ¿ÿ©¿Ç§›ëŞœE¶óù¼¯¥‰MOgŠUD:ahp3Ké®oúQmŠÿ ‘ÁÇ§Ã“áo"šãÜ)4"6ÕïC¶üAPßØ<l3eÎƒÀÈÀı>t2üåA‘,”ã~@¿ÏÂB Á½?wIU{ƒ€o»q½ø˜(	ñÉè÷J!=üóŸ‚ÉÌ§*U×–EA-Eªæ*èv›c²Jhò™L¯u’–³ÃİAP_,ó«f2N¿üûpEöÑò`rq+¢ÍV¹õ^˜ÉğJNHŞ&Š¸HÔ!Tÿùİ hß\îcè{>ÆóÖì™^èY®£2´}kŸÀpƒ÷qZŞ‚æÓö4“´¬o C¬d1;ÄĞAà/0à?1uµï/ât¬ÙÅ/¢(WÆ:S~æ¤|`Ÿ­ÇYS7Ş­ò ¾ç¬­¢Ğ3¨œÕÓ,”Ì)ÄşéïO5ÂP~ø¬VÜÁ p7å%bÏ¬AÓ¼µ’üJié3UÈêÕJÍËYdEÀ¿Oc‰(¾vS»Ä§Â#øf§z'+óLRm¡òYœ"ÊÆc%S‰\`¢6WIÒCŞÁLÇôœ4f'ºf‘ê!¦f(œEşf%Aø\)j3éoú—$RHf‰•ÁÏ>OÎNÏiÚú&´èRÉÊ1ïNŞ·ˆ~¿ß„y—üC,‹pªÉÚÄŒ1<x 3ÒÜao:ÜÏÿ‹Ù¯×š5ÚV¡×+p×²Ñåíñù›O'¬’A`o9ó\‚qnÜÏ´€ïÎ‡œ<E#×"Åº³y£|Ø&ûBœĞ½ÎFªÓŞ5²4 
æ,#øå8:‹….AJ¤º&Sa<^`‚gl#ò‰!Çb/]<hTgc*¯‘^6BbùÄP@ö¿¡]¢ÙÙˆÓ¬,,2 ŒIÄH’ŒÄ8×3a
¼	x$ø­&ï^'Vüw*ãóñû÷½wgŸ>œ½¹ø€h|^«¥’  YSzµTg”4%"l® Ë²c$zN)3/! ı–PãBÍâÿVQ›:fÒ=8¬g ‚Pyå#5A6„ Ši¥W`š3‚.ßé2 q„ªÛÙØ =˜‚LŸ%ÅÁÏÈZ^î?mîöw6àÂäÊlşülR@ö~TŸH¨Y6%Ôsxz6<¦ì.÷éáı6iXÙJXæ9Ä”,0&œªğ
¢Éalp·Öá…aeEì8¡Ü)¥c¬kAËÉ]ä„¬\AJ -à·Xˆ- ´ÀmÀôXX5X3™N#Ò“‚µâµ'°à•3rU72Äjá0S +‘ôézn/­Ù„6NÁ”„akËµ}YÅú”748KA˜DLÏ»@g`cäïÜè"Df§õ1ä%'?#f’ÂÇ…Óa‚dDâóe‹×'¨á¨XGR,ˆ—LåÉâ©ÔdQäñ¨…­”0'		«”ù&ÿ*uÛ[Nİ´êDYGºDÆÚ~`êAĞöÄ¦·ŸŒ[Òw&ƒ¢Á
:F{¬j6Kbå¼³@¡DøUhk‘LD&F“êMÜƒ¥Ô~ÆNÑp´>zÀÓˆ h‡pWvÓx°Z{#{ 1ö`QÕsÂ÷İê%SfJ>‡Ú0ÔšBf´¾-ƒÚ‹WÉñ¦JÂşİn„à5#pN|ÌuJøL²C¬³„¡ğ0)#2ÜÍ',Í.g%2nŸ’ˆ;ÿÔÅQD°PPÕÖfÅzT³ŞÂ=º,IÚÈgs[À¨ ²dRIU©Óµê8öVR^ƒpÿAŒâTbÄ¢ßi$8½–yL”œ;sÇ]ºQÕî6aƒØÈ;0F Óù2Vä±5©enÀ—fè\ªÌäM<+gÈ‰ÊY€’œf‡¶†·“¶ÆR@)\I)'’BšĞu"ËÉÔP”€È`›‘Ë2)öÅîÎN§r}×˜ ³X1!÷d–‰åÉ ã6W,/É§ÕDÂòŠöbÛìÿb`BüŒ×şÜ°¿Z³ÜIt…Hû}
ü€ääpvÊ#Ò´Ş¢¤g'¢´GË$- ş¦N BşhA¡“pÔR3Q½›åñŒ`e¹R?%EÀ[³ù%Ş3ßÒT(C!óÑ‘&“>	»PC1–¸£›^Å"êÚ0äì.ƒ»Œ€:£Ôw[÷ œæks7$UàX!)çÖ	÷®8K±ÕR4¶v	‰--£6·™m¸0°“bT$*rñûx_‘6ƒ¶›?ÊùGw8?ëéÙ÷k+°!Ğß–èlOMÏÙnQ!Y[iÃaãkêJ­Z„ê ñR|ˆ_ß
	Rª.Š©.©·	†%§›g„4Üü1×: Ô·°OşßæÖ²¹°QIßiR•¼kÔí
–ƒÄƒ>ÁšôyAÈQ—)¡_*[UëÜtWL`b#º,f‰w¿äL×Æ8¸X¦á”zôqØ|bSTÉÔ}'X3/Ê\Ç5lJ+Il»Xš«• mÄ*|µ×%÷-Nhşo¬»ûÑRÌ¬4>çUq¼oH¶Ğ¾0E.ScµÍBÊ "ß÷'™.éÏ,^#gYWï®”¦e™@	¯AÔI–(w8Z˜å%(…JÃÅopFŠ…NH·^%Ä¨å’“ä
»'—¬nÏj–ØııÓê¾…ÿAU“TrÖIËfkãæ!€ù”„c¨;.Í’ ì„ÍóáÛ“ÓMjÕoÄ9áB´ŠU]Wîb¹Ê!p*f1qˆm\&\18M6ë2dBqÌ6K,ƒµò›¬b8£Ê—€ü<6˜ïrˆ[DT(ÇAÃ½GÌ3;•25Mçæw¶x„7©ò2M!ƒNû‘¢íØwëĞ¯ºqB0‰7·Ì‘Êl¯Ö!5‡s-l‰^öCLB@@'ƒjöíŒpı3J›úzôƒ\"ó­™¶™÷T³4À{<IuNj»‚ƒ”İq«êQƒ—8ƒÎ!ëD®™LØSQqJšâ	©±ÍŠË¨cD^„kRhcGíwêû\Ñöï¢ñHüèO‹Y"ZrûFAMİÔ(U.yJHkÄ4î²Lq?¤¬ã‰r¶n¶ºB#ÁçqdMÓSº«QínßÃmíªj„ìsäû8)z0MOÏ0Ò¨»„ç½£ó7''µ!w;§Ãw½—w?Ú}ÑxÆ&S??9?ë½|ùç¿ôv›ÍEÚé¦.È­†Â|¹¡Àvğ­ájdr/¢ãfE£û6Cú‰¹\±²Ş>„ıoTå/8~B‰ªêÙÜÎMÕ·İ`3+ğlAè¡€	¶H©3©6;ŒxçJ©¬±À»Ñsi(tÙÌ‘ˆ€‰—¨HæÊ¸Mdpo—$¹
ó/Ú`}Vo-`nŠ$n3AÌ)*áÂPx•ĞKx€øMñ,œ:jÔçnK‹¾#Ø=ì9Tb¨Kk÷Lğ—Ô”C`;‰‘P©ŸEğÖá”åßuyU¡L›˜±IâÓ£1'gãïáé#¥7´;­wÓVp®Ì·›`¬ÆhÀ"†â½i¼ú]Ö|úÄ tEŒŸuX,2ÅŒeÕFÖ`Ojgg«Õª~v§ÎœçzÅ—Ævj8 ÊµÈ£AÓ¨?dOßÍ'³GZä²fuÆÖêSÙ&ÑšÑ®,Óóı-2¨Ö²lÖ˜ÒÊá6¿iOQÍĞ0î¬¡^PÌ!T&s¹0–
ivÆªX5ÊW¶+úşßÅ5òÇ*n]9ÎÔEGo&3kö>ĞW,¸çm¸P’ƒ‰Sr©‰l
§nT¦œ¸:Ün‘9ŠiË4oh¢jÔLd®¹j·øSëhŸ“3jU“öRÌ*m2;#”9FKdh_¨,4œšüÀ:&„cFÈÙwXWo¥7ôÚ”í¬EßâšJğm3Xµş_XT:¢iŠ˜9šÆÚ¸³”°f:b5¶ğã¡“ŒJH!˜^Aü4ÍˆŠ$¬·àf£=SV3*ôˆE³€Üfivb(RV).Aª¶»¹DƒêU)%¯èÅûùj¡¢oìæ‘>ñ1©–ôpÑWüÍI>ÛQèS‘zÔz¡~HÃc»+šê:ì‘~Uárwl¸CZWªVüæ’*
&Š˜Z ¦ß‚ÓöĞ]›¼šÜB}êğm’(axä\Ğµ‘3“›Ä×Üø4Íá2KêHPY/}k+—sJ›ì¶næ¸0*!ë&ôOÀ7Dh¦2ÂÔ……KoÆwö¶Ñù°/‘½o­HŞİUM«îÊÛ~ªVíİGéöúi^@KoœCº}˜j¤(@ìii
mÜQ²>]|Ê şL†.Òq<)s÷†¥ï(w]K…O¨hó»øÀü‘r:N-vm®æ>£ÔÒsjE”'õùT»^g®˜æzŞ
B1%†¼„mÒ)Wc#”ïzØUœ`"ŞóFÈD©cÏî ıwhšş¼i©ëpf;Ï”Ádk© J‹íÓ–²‡7Vt¾‹oÉ<B¹u¦ƒ£…cºvºê4‰=CZp{‘MíF'×ª"Ü©h—úËÀ©©Ûßmlî"C$	MmÎQûá›[O~Şöµ½‚Eµ2ß‚Vl¸Kâ0.ìù£Æ‘”ÊÂoo¡õ¹İŸê ÙÍˆ©Š	œPËÓB&DOjš¶ c}âÍ_tvãÈ½/¹øäf[‹ıÎòÉêBû£ãÊÄóİşNï9õ¤;+¬˜üJa¤Ã+'Øæx0­=w/ŒıÎ½LPòAj?ÿí|xüAlÚËŞ3< şú7³d“;æbËÊd»5>Ñ]¦‹~–N6ÅÇÓ_ì ¿[¦~ô­U~ì=ºˆÜ¢Nÿt‘!â›ş¶«+é”nµÿ@yÜ¦á~mšü¹=p:Ò[íŞ0>õèO…º)ÜYP§Éı–Hn©¯‡¢×½Ù‚+r(ê¶l[Kâˆ‰ ıPduÙÑ—0bàÙ?lÌEŸÀ¸»9ğ½æa¨&ÃgôOùæá³ÇÕQgwhÜ_-­wêÍŸy»~¼VGŞqøÛï^‚¹©ßM°RÛ %WØ„f½q®í•“1#Ñön7­±±¥Î1;nAC>®‹¢¶yÅqu•Ò°¸Î\ñQÒ¤â¾w‰[öÄ³Í­"/İºEÕ6‹¥¼;*°¢¡_´kÅ×ˆØrL‡Ö©÷^f:­ØîuC^)5}  ·ÎÂ±İxÁ‡æW1NÖå‚÷Áã´T¦³ÑØ\àÊ€¾èIíAßjû»Û©§q»on³`áğèlY¦kXíñ?N†â|x4¼8_aºuœ°WÀs’ÒŠ/:”@…bè`EéPè‹vöè4w"»®IéÏßÓÈæ›çseÛ!û«Q>"ì¬‘¬x†í“
ÌÅòa–†ÛmÁ	h)0m‹9
íyà1)$K—@İı§VYk­nwíÕ5C{2Š¾-‡{ksx†€¶f|  ¡‡¹r°¶©>í[&ÜI§0ç0Ü7]Êk/¥¬ÁÊ#.ü·[×Y^¯m“±Õƒÿ¦ûÓc|„¼Â}QKÔ8ÒmËÆTLQF>TÖIª%®õÕ“5·)îNòwn}ñK,«ï†~«ö”Ø·™÷øa·Ñ‘käÂŠ‹&9Bğ–·A4‰ŞDwîÆ(şŒ™ÅÂí´+rÉqEPJ8 ô6G_oz v7ÁïŞâîÄ`IµmmÍ§üå5çÌ°ßÒ-m;ïmA5»Mö¬ÁŠU5’†³PiCÓY—¦ÊÊ9f»³1S]qò<²'~hQd;ËÍ.ŸUâ-²”{şÈáüøX½??»e
·0ù°êEM¹‘éöïû§è@Ù`Ï#* ‹şI²õc0­Ï?riŠâĞmÀùê[t2ùTE¼%¼½_Ó¢Ó9óù;÷á§`ogçEğéøMXşÑ…;/w_×«ÎÜî?Ì(J”y|g˜Wòt8j—–Ú¥¥¶ªÂ{¤à.†=û´
i7.@­%Éš£†Îã	Ê3Ú£ğIw´ÍÏ–—¾©¦ x«BÅ'ù·Wç(ÈcÙoÄü&Äõ2èÃ{b‚7WÄú"ä#•‡ÆXÜê¨Lr¸‰mºĞ7Ò]Ú§öHÁÎm‘ıKªÚöüÏ'48¡\\ı™ùŠdÁpÿÔBWüİ5Oùß\¸C'õÛ‡ÿuj‘1E                                                                                                                                                                                                                                                                                                                                               usr/share/doc/libffi-dev                                                                            0000777 0000000 0000000 00000000000 14325446101 015121  2libffi8                                                                                             ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/doc/libffi8/                                                                              0000755 0000000 0000000 00000000000 14714557563 013270  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/doc/libffi8/README.md.gz                                                                  0000644 0000000 0000000 00000015413 14325446101 015151  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ‹     ¬<íRÛH¶ÿõ]ìÖÙÅ!$wfï8æ#Ş@pa’aëÖ­Ğ–ÚvI­UKOísíì‹İsNwK-Ùdâ0TÍÄXİ§Ï÷g‹ –“éTvº‡İC¶àšå"\‹ˆ©”]……šˆœõvXo¯×ë26˜‹ğsÁÌN¶“ ã3Á¦*geñBè·ì§O×oçE‘½İİÕªÌC±à¹èª|¶köíş­Á¯s^0©-¬ÿ	~nşÁ@%™ŒE®	ü\Îæ,"f1Og%«ÙL¤"‡SY¨"˜Ä©Šcµ`¡È.Ó TéƒH©Rİe7s¡qmõÄX*B¡5Ï—;L¦,ãy±C'jŸ8À@D8î`…b•ßwÙU*˜.Ã¹©Aîl…<e:óß¢Ã«'Ş¦-ÜçãoğpÉ8\05¸Öe’<ôM–>´|a|¢Ê‚-æˆ˜–iH8ğ|V& L³…Œã`‚Â)S)|›/‘^-ï²şz¤x¬Ó™åT
˜Cğô\e²—Fî50¤„ñU"X–«YÎDÉRU°ûDBB@…„jÊ|î.P‚JĞ2`èe÷38^¦ºài(vÒBä ÜÁ3'"(Tá‘y™vèHÃ5Ä -ÔpÜ)–¨`S³¯´"wÎfxã}aL „S?ZÚCQ‘»áóƒÙñ`’ËM%W	îãjwĞqFº©40ò¦67ø'5u0A{Y¦@Í'1PïÙ‡…– 
Ò)S#x.U©ÙªÀÉ8@|‡ [€\¡Ü |ZÖ¢vª¡Vr‚Èê³ ¹0—™QHâ}€¼rÎÎ†«	
9KÙ™ƒ;t0Àßôq	=vÇzäX[ËTVÆ<g)OŒ:V¬5D“B¢¡Á"—E!PSÀ"DåJœ #ñqP[Ğıj!ÙqĞH.ÈrU{Â!?©Bƒ;Ix8—)ò%i,b¾¨¨p@n
†ülÓ\SƒÆjö%¥.ñ(uêüPi‘;îÆˆ è´q®É‰ {Ènµµ'ğÅB ¡dU{VtĞã2Cõ”F`°9Ñm'mµ5…9D	B³»€¥	êL$§SğiÁ2À÷›^À†úÒøpÔĞ	×2D"¦rVæÜ8Ã9Šñ¤ âœô6şÅú9°¸!2‘ÁÏ¿ØU†±¡Œ—°,¯\Ha­Ÿ€Nó‡­|³î«ê	b€(²íşõåÑáKX-¯Æ­sØ YÌV| õê™–M çƒcßàW™F¨ûŞW—ãÏƒ'ÄÙœ7Ûƒ 7yéaôû ®-mŠÁõå`7°©>_ôCÂ»˜‡÷Sğ^Õêr7A|À`üáÏbâûÑ¨ß\ı~ôév&~ø|û<1û†ŞmàB©tæÔÆ .?4WŸåB\Ê7?àÙ\ßœ^7 pÜ N5}7>ÙMq||ÿ» DÁŸG‚súü›øQ ÃQ‹àáõpM\ğl6• ğuysÔ£Õï0µN@8ñwø(•fÃác€js=~À2©|4`½ÎD¸ºß’â`øî’İ^°Á· >@½º9<ïoNÂ³™è…!²«ñí@—ş`S 5ŸÀğàôâìaÿ¹ zß Õ¸ó¹Ò£Í¥`860>x³÷,„ nŸ`ÔÌÓş  ceœÔ(€«œ‡±¨Œ‹2’
Œ³ğœd{À†ª¼
`Cn†§óÇ]üw”«ÍIøÜoBŞøã÷ ¸=>b«)Î<Xpşñ{ÿéúä‡PA>ş8÷m6°¡VX)<Àx·ÇƒÁ†Öø] ¾¥Ê« lÍ´;XÎTÉlŠp)ÓÙ¯ßEB§™dm®ÊgeiO Ø}¬‹ÁMl®H- ›‹±`s1>à‡Å¸aŠs[ˆTóc0¢>Ó""‰-+È²]ë‹aËŠåB—qbÛJìDR‡¥Ö¿4&İ bÛ´kÍÒ`MîLæ u©JêVı2Ó±ĞE.'%5±ëršsÈ{§¦öX—+ìÙ™-¹•/	æBê9õáKG®ÕH½Ñ[»¸#ØªÎÜªºÙfğ M{1Wªğàª©?H2T>¦]Æ>ªÂvpéäšÀ¿– 
Õƒ7o¨gÎ9‰İ¬FäÈ¹)bÿ¸ĞŞnĞÀ¦+6ãg…Í6-z§æ`°Pé‹‚™^ëRÿMwwyY¨™H»À™)2Ğ¥:]zwÀ!Fˆw!èú”ğ{AL´
¥bÀù(B¾d$A=i'N;†QÌ,V§ 0˜‰0‹vö‹!³ƒƒ
Útw×éd¹˜ÊÇ»;ï ½E8bLO7 rÜa M º[ê|7V!(õdÉ"1å Ê»+ÌEŠs	`\‘ózø‰I9›Ñì‡‰ºÂuq2Û:´n-fÄeI§eŒI­B[­‹p^• JÓ°¤¼˜`C­Ø¶}§}áá“•¹œ.;šOE±¼»ë²O­ dÀÔA{G°#Ì% ¢ÇºÌ€ÛZ»¹$°)O‚® a—ÁqD‡ÁÆbîğeW8[0ÌÌ,´—öfè0§°gâ|gê´Õ£TDŠíÄel;R!M¿¨ÑŞT°M#ê»»`E0 ·x¡ÍÜ0SZ£5®8p@®ZÍˆÎ€ú<ZMÆg©KĞ®Á_ÿZÍ:A#‡©¡=¤1C-ÑaV,re O3xbğÃL¸êÉ`§ÕÛ @g.c¾[¨İš”Áàg÷¥ƒË··«_^œüùF£Ÿ·Â˜uR«™bÓÑ~yvÑ?ÿ¼Õ99;~y÷ixq2üxşåäâb|5x`[û9^´!êî°ØZ9±“nA uÃ@êÉ5À+çFH©0Ã3²[’™Ñ‰ÔRe¹äàhH7h$ÿƒB$\\|¾ èWğ° Ëç0®$¹c¤0 ßÄò¬-öıõ‚–€,(¼x VS…BœºñÆ½qf2‘>È\¥h;&²âÛ°2ÈE‚S7cW)1¼¾Ş_€{ı¢óığD÷…™`¿—3úÃU"‘mW_¢pX§f œPÚ¡XaÚ‘Œß U],cA<Õİ—Apã¤§ÑªÃ*L`"@ƒ*ŸæÁ˜Ÿ6‰Vqi¼òù‹5U1ò
q(AÎ©M¾{6•_Ì1>º:Nña…©”(}°»ì¿_dÆe$vqôHÕ½K1yxQ•æí.…À‚§™É$¶Ã|”<f #%}wwı±1øxq=ÑÒHıš6×ºÅÀ|©ÌèÛ÷ ]c¾8r6kü£uÓè÷Qùá”[ŠÖÈª¸Œñ¬.ŞmqÚ‚SS“šp¤2;ÿD¾ ÖªNg.âà¢%âB‚“m v•†ÂÓ?„8•)$m"Ú1Sà-L5¶º^FUåŠuä#.³î/6L‹Œ¹¯M®ßtgi‰¹éÛİ¬œìÂ/»ô¸Kª¹se.QÔtc5ãÑD@©›¨™l`«<C™©ï‰øÊ#›’ˆÈÛJ‡\ÔP9{Şİhw€·u{É$¥A•Oƒ)5ÇNÆ	Ü1é‰½ÜOçå¤6ì.6UÙº5s¯ê*,:½ƒ^¡
\™0LèŞ¨ŸÕ}Àğ14&€¬ÒføN'›ÑQ¸ .6Èn/ĞËİ`juš“ÈßL¤ÛîLãB½ìVËÏä#{„Yİs êÃ{Ğ9#;X]è\<Z½g_.Õ–±,–Í]	Mí*ß¿g:1çä¥™Éó|¦=Î°±È:ûošœéW[h=İÏ²w Ù¤Ë; 3ãº±£åo‚òŒşıwC]cujrPëù /¾£¿6W!LIZ¯îc
ç±€²$İ˜rï¢A‹mP¨¯Õ\cÛÆ«¢U—™q2ş†áÅÀ:=±øy|ì±¿Crİ;F>î7ii£Ò¤”
TPù‚dÜ(<Í>¨7ŸpàÍ‡×3¢½és¾„=8Ñı¾-ØÁƒôO¥E®bPdHcOSx
rÙ7"œS¾µdÛƒÓ›—ß@øú’Q@Í(Á S`ˆ5QÿåZÉŒFT0LÖWdA“<LR)Z~%+
W$”˜R„<ÇË_Urôç‹á;L	o.G'ÃëµhXÃâ¼`5•TV}Ğ‚ã¨·_
<S”®1HäÆ¥½è†‘|ÖÈ6²/~D¶=Ö06@G›k.€äÄ¼Ji®Ía(Ò"~µ}@¨y0~oÿMC>vúQ)²{öQ,X44—èŒÁ¸Ï¯ ƒTStSÌÃÓÓÓ×¯ÙD¦àì÷{Çà§ÁmFª$‹÷”ÀæÚ4÷©@œ˜²ƒ©_y!À¢
<Šaz]•Ô˜`(ª®cBN¢ÙñBĞlQZÈóåK†R‡Õ¿Â	 ±I‹sµ –&#Ûşõªÿr•EşZ«­¨á+ë®ù‚}…lƒmÏÂ¯/‰«˜•P}˜>8ø–jàÏÉY³ü£Dƒú!R½ÿ³–ÄF--,Ë4éTî&UÚĞëî“>ì÷P+ïL2	–…‚JUÚÁÌÊİb*@E!‹®¡ûMHö€ğjW,Ùy'ÿí°Ìñæ™»œ§«+m*õ4\¼Ùû†õÇƒşÑv}z>ßœ^¯»Bi©×õ.É×6áWq„j"QÇ÷ï5‹ÚÌÜÆ/Màl±¡}™¹V‰Ü8íÃ¯u V'§š­]åóÇ²ªÏÍ'Ü?åº  |AÙZnxüñ‚¡¶¹@Á¼Å²Ïöæj?r%!w$Wüñ ·ƒ»wª^=û)†g*ˆáPzÇY>Öú{o{O ¿º„¸)LÊ	xº·LÄO¥x»\ğäXaĞğaBNˆŞÉ2tºäëF¸†bu}Éáqãâ–4¦¦‚ ¤+¥	ÿÆæPÅŠÈFÑcóE×G!õ° XéÉ^wÿ hÌ;û¯QUâ£{9ëÅ/µ)&)›C_ÖŒ­Ä‘¬\‹²û„y'GÇ{{{µU¯_åEWòØ«ë	sÉ×äüi±Yµ·©çu&ür¿>c#ÌävÇU›­¬ÀÎ-üŒ æo‰‰õH-ş÷Ö2ØYéÚ‡ÕÍ½µOÛßµ‹¼SkŸÛÇïZõˆßÚ&nÄ œNEl»<—£ë«›ÓÁÍÓ[ÁhP›Á1F*¯¤n:]WİSâ9¼­¡ı
Õ"¤'4<ÀnÒ.
‰’8…7zm"jZŠ:õÅ²ÏúYnÅR—ª zaâô­RøF=»[ØÑÛYR+bÔÃºµ¬­}cå‘rJåÂH„qöTıµ–â$rÆi]°ŒK>åàÁÖîëÛ†+K0ÁÙ(‰"ÅFÍËì´l
Y¡ÌĞçrpt||¼¿
×™¶‹«Fµ/œ=ÈÄg63Ü:sÏ ˜CBˆ};½ÿ|6ZM¨Ìı:)…BıèøC_ô#Xp"3Bâ6±àÔ=¶ù}KqñXE!fÕ/}Ä$’˜ ™éÉÌåãQ÷ÕJvo{[Æ°¼L´cµ6`°ô7™q,ìpö´º“Ü¶ÇŒ:w‰Dı¾IZµÚk]…~SEO²):Á\úş”ÊfÖ³2m—³{İ7š‡´İ½fá`nE#ãÁ!tÜ¨»ö¦ÁÀ¸i¶ª“”¦Ö¨«©|ı{?ê|‚ßÿ¹C½clÃ½»*†g>š¹²—Û6ã×ÉÅ_8Ë­(:&Š(_Û;nP„§î°wâjl²‡Q¿cªòU¶¼®s_È™šYº¨Æk»€„á^BÂ¬I@Ruƒêœ¿¬Á±¿—±IÖ€u•*²ûÍÍk€z¾«)”™œ@Sš'EXÍRv{¢¨v}à¿±ê«L¸‡Ì+rÛ«¸Ø®‰¼¦^ÿ)Slm Pï ÑàXŒåzµ«eIB9zÜ=¤8Ş;\=÷¸K®Ãºôv˜½æNÏTİæšö›¹J€UïELÓèÔffÕÌ¥³õ®w_ÿóï<eşóïTÎLÌlµ&u Ş+eefÊ2ß»AZq}Ú?¹<õ0)L¯¥XÃ_c¤ö2+–u³;ßÛ›éÕ*cW½î4.õœŞù1%ºìugğ	öÆSáboíIdû!%Î`ì‰ÒX	ÖL¥ñ$¶Iïñp9KKr©¥	ş4uY°k`É{î“±ÿ…p¶„`¡ÙL±É²ÛíşŸy´ßííQë÷Xş›c¯4ŸN¹Àë3Zá¹Q‚¡öz¿ßİ³n70ÎÊÄïPĞÈ§ÿÙ÷3W„E)Aå¾L7ß©Ğ8œ/ø¤^;â8]Fs:ùôTï·zÙÎ¼òCğ®%ğ:÷õù=¾î–ë*mÊMvöºIZUçš(áº9»µR¬á¼vFû8D´‰{kè­|µ¢nì(År±d½BÖ­*Pd!•œ!klÛ]ÀğÈ•M0LªYã©±²©¯(|•¯[Š fBHÄú3j¡Ù«$æ‚É_Z‘ÀšîÁAÇƒf÷8%w/¾V/WkÀ—ke«¹k ãI1"Ñ{©FQlši{/“%».µf—!Ø§WMÿ”„Pøæ¿ˆvgÇ*«ñ> 6ôG~pë/i ÷Bdî6) jpåt³4o»›Øn6ïÑš7p«¬€äíêT—CÕõåO?±#;è¨ÊŠèh³¼‹ÇL1'rT™–Vo-Y®Ç²û¬_¨ñ#hó–¨.Ílá™5}0jÏv­hª.k¶½µ¯¦Â2çôTŒÕ‹¶S¬ÉØ'gu°·ŒThŒÄâjÄXí4N²÷fİÎ¦ı{]ÂFÛµFcïÍ7€5o­¹WDa³Sfß95áb Â«1ÎO Ñé’H0³ïÎÍm‰_jo$iÃ~ĞìAY‘ ”J74â$3¹}MÔ1µÿªI”ÙÖïföPGEàµpØp®ò_·Îc–‰o<ƒ˜»P&ÍÀº+G uôû ¤Ë(?$ŠhïÕZÕkßÎÏ×R¨Ø^0CUãWZöI®œÌ\€çÚNÀ³ÆÊq’h3Œ—5¸®¥½#»Ö›FºZ™÷È¾RCn*1*Tã{/½»öÅûÓÇàZõ¸İ#¼Öjóø|HÂwîİêĞE7+(ÛV¶Zj•M@fúoÕs>^§qvîUó‘f`
Ì¾eŞ…©šùš+q{aƒÜª)›´QØØÎµ,Ûyp¸ñºKN—héª-Şj`dB£qªÀ!3Òpæ§ 9û/6 dd¡×İuËò•Ë™L©ñêş Äª~
PÀ¶Îs|¹ı§şó»c5“¡Tø‡"ŒØ¥Òşí”ê­óÿ`r^w/„n5à_÷dš–	ö· ¥C•²Ã¿´š¼`±ë.&ÔÍ`,‰Hëìı÷·7ìù2ôZ>øø¨ş³-9µO3º–K`œÄº>È˜
@ü§6•ch!=Dœól.C]‡Ã W_%íXê„ø‰ÿ¯äjzÛÆè]¿‚·^”Ğ^Š½mº§ÙM‹l{£mÚb%‘i9v}çÍP²E9êCâCŠÔ|ğÍpf¢İº!,t’gßÔğ“ï@;§)|è;šë^ÿôœÒ‰Ö,h2r^İÏ¿ìb|?2Ù¤y@qâFJ4nÑÏ?´éNµJ?­‚ßìJµĞ-©3s»ÒÍ¶’¡YaûE$'”d…òÏ²_
Ò‡£ó]´1Ñ¶3Ú‰‹ TûğæuFuôº!|úĞ"{ÿYfEß’Na —plï-BİşEìP÷Í{yäj’áŸ¬©m‰ÍŸ}t?u]Ò\¼úÌ½Jş#!öºŠõ1y¯‘‘PªQõhpM hkö³İN”‹©¬Î8Äï Ö7• ôz˜MôD˜Ví3º/ä2„ü¡Œãï*ZŒúØ7}©ş·CıQ{úÚÓ#|Y¨g>ã^àb•t68b6ÃÆÚ7¯g-%îô¯¾²ÁÓÑ¦}-/šİ‘Ù8÷I„ìíœìŞú5ù M£ vwû¼”İ¶–ŒMÍ˜/Äh‹8ãòTSÍ×ïn±ú‚¤ÏDÔÅ™Uªwd}P ršf•³ïÌaš¬ù²8ÜQZ;JÈ²F6NÄµºœ,¤àx¢t†àÃŒ‚äµIY¦ê‚®‘f“\ô`ì¿°Æÿ¸-Òe`‘9à0vSıÎ]Å|àóR%/æıÚ4ÑWôÀıT|põŞÆİù'¯t¡ë~©)=5Saûû™Àq"'æÎã/S§U=©Gòè¹YäÀîÌF}zõÅhÙ\ÌÊJesMÜWÒ«R}k2Úİa«XÍ÷uŠî%’¹Bç$İÜjfÂv2yÌ¾«íá¿é «#İÀD}4Âò±ŠñE:d…c½ çŞ‡$AWœEé¦™#{!&ñ=deDb|`hhW›¦(¸+¦µöûS<ï‰”fÜš¤ƒo¤Y5él³÷ÍAr´£“³ë¤!ø~[øJšZÍ9AR pÈ§4G¿8ÅÑHòŠ¿’klä|£e–~O2¤£æ£©¶Åı¥[KõT­¯R]Dª³Ğ<ı©xåÔ×‰+3ÎÕ‡ÓY×èÕ¤iC k„atK@S„€»‡ÙÆ›|LƒlOİkä0.É):­¸sİœ`pó¾‘¬ƒÔtkì®ÄN¢‡C€ ¢u£—Á¨ÆéÕ
¯ù³·¯Ú¢Ò]w”HÈoõ!˜( œIw!Qõwœë
?p¬Í`T¨‡Å•Âÿ’Š*6•ª“J3€è}–.DÃÈ, Èõ’”ÕøBÎê5`œfà<47#n¬*Ã]Ô._IÁı¥Ksİ»ñ;öå´„L¥ú†øS"ÃÜîş.†5eMALêÄÖm|ZáÕ îÿt\*­+~0lx³ğP                                                                                                                                                                                                                                                       usr/share/doc/libffi8/html/                                                                         0000755 0000000 0000000 00000000000 14714557563 014234  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/doc/libffi8/html/Arrays-Unions-Enums.html                                                 0000644 0000000 0000000 00000016116 14325446101 020705  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- 
This manual is for libffi, a portable foreign function interface
library.

Copyright (C) 2008-2019, 2021, 2022 Anthony Green and Red Hat, Inc.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
<title>Arrays Unions Enums (libffi: the portable foreign function interface library)</title>

<meta name="description" content="Arrays Unions Enums (libffi: the portable foreign function interface library)">
<meta name="keywords" content="Arrays Unions Enums (libffi: the portable foreign function interface library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="Types.html" rel="up" title="Types">
<link href="Type-Example.html" rel="next" title="Type Example">
<link href="Size-and-Alignment.html" rel="prev" title="Size and Alignment">
<style type="text/css">
<!--
a.copiable-anchor {visibility: hidden; text-decoration: none; line-height: 0em}
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
span:hover a.copiable-anchor {visibility: visible}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<div class="subsection" id="Arrays-Unions-Enums">
<div class="header">
<p>
Next: <a href="Type-Example.html" accesskey="n" rel="next">Type Example</a>, Previous: <a href="Size-and-Alignment.html" accesskey="p" rel="prev">Size and Alignment</a>, Up: <a href="Types.html" accesskey="u" rel="up">Types</a> &nbsp; [<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Arrays_002c-Unions_002c-and-Enumerations"></span><h4 class="subsection">2.3.4 Arrays, Unions, and Enumerations</h4>

<ul class="section-toc">
<li><a href="#Arrays" accesskey="1">Arrays</a></li>
<li><a href="#Unions" accesskey="2">Unions</a></li>
<li><a href="#Enumerations" accesskey="3">Enumerations</a></li>
</ul>
<div class="subsubsection" id="Arrays">
<h4 class="subsubsection">2.3.4.1 Arrays</h4>

<p><code>libffi</code> does not have direct support for arrays or unions.
However, they can be emulated using structures.
</p>
<p>To emulate an array, simply create an <code>ffi_type</code> using
<code>FFI_TYPE_STRUCT</code> with as many members as there are elements in
the array.
</p>
<div class="example">
<pre class="example">ffi_type array_type;
ffi_type **elements
int i;

elements = malloc ((n + 1) * sizeof (ffi_type *));
for (i = 0; i &lt; n; ++i)
  elements[i] = array_element_type;
elements[n] = NULL;

array_type.size = array_type.alignment = 0;
array_type.type = FFI_TYPE_STRUCT;
array_type.elements = elements;
</pre></div>

<p>Note that arrays cannot be passed or returned by value in C &ndash;
structure types created like this should only be used to refer to
members of real <code>FFI_TYPE_STRUCT</code> objects.
</p>
<p>However, a phony array type like this will not cause any errors from
<code>libffi</code> if you use it as an argument or return type.  This may
be confusing.
</p>
</div>
<div class="subsubsection" id="Unions">
<h4 class="subsubsection">2.3.4.2 Unions</h4>

<p>A union can also be emulated using <code>FFI_TYPE_STRUCT</code>.  In this
case, however, you must make sure that the size and alignment match
the real requirements of the union.
</p>
<p>One simple way to do this is to ensue that each element type is laid
out.  Then, give the new structure type a single element; the size of
the largest element; and the largest alignment seen as well.
</p>
<p>This example uses the <code>ffi_prep_cif</code> trick to ensure that each
element type is laid out.
</p>
<div class="example">
<pre class="example">ffi_abi desired_abi;
ffi_type union_type;
ffi_type **union_elements;

int i;
ffi_type element_types[2];

element_types[1] = NULL;

union_type.size = union_type.alignment = 0;
union_type.type = FFI_TYPE_STRUCT;
union_type.elements = element_types;

for (i = 0; union_elements[i]; ++i)
  {
    ffi_cif cif;
    if (ffi_prep_cif (&amp;cif, desired_abi, 0, union_elements[i], NULL) == FFI_OK)
      {
        if (union_elements[i]-&gt;size &gt; union_type.size)
          {
            union_type.size = union_elements[i];
            size = union_elements[i]-&gt;size;
          }
        if (union_elements[i]-&gt;alignment &gt; union_type.alignment)
          union_type.alignment = union_elements[i]-&gt;alignment;
      }
  }
</pre></div>

</div>
<div class="subsubsection" id="Enumerations">
<h4 class="subsubsection">2.3.4.3 Enumerations</h4>

<p><code>libffi</code> does not have any special support for C <code>enum</code>s.
Although any given <code>enum</code> is implemented using a specific
underlying integral type, exactly which type will be used cannot be
determined by <code>libffi</code> &ndash; it may depend on the values in the
enumeration or on compiler flags such as <samp>-fshort-enums</samp>.
See <a data-manual="gcc" href="https://gcc.gnu.org/onlinedocs/gcc/Structures-unions-enumerations-and-bit_002dfields-implementation.html#Structures-unions-enumerations-and-bit_002dfields-implementation">(gcc)Structures unions enumerations and bit-fields implementation</a>,
for more information about how GCC handles enumerations.
</p>
</div>
</div>
<hr>
<div class="header">
<p>
Next: <a href="Type-Example.html">Type Example</a>, Previous: <a href="Size-and-Alignment.html">Size and Alignment</a>, Up: <a href="Types.html">Types</a> &nbsp; [<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
                                                                                                                                                                                                                                                                                                                                                                                                                                                  usr/share/doc/libffi8/html/Closure-Example.html                                                     0000644 0000000 0000000 00000011423 14325446101 020107  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- 
This manual is for libffi, a portable foreign function interface
library.

Copyright (C) 2008-2019, 2021, 2022 Anthony Green and Red Hat, Inc.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 -->
<title>Closure Example (libffi: the portable foreign function interface library)</title>

<meta name="description" content="Closure Example (libffi: the portable foreign function interface library)">
<meta name="keywords" content="Closure Example (libffi: the portable foreign function interface library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="Using-libffi.html" rel="up" title="Using libffi">
<link href="Thread-Safety.html" rel="next" title="Thread Safety">
<link href="The-Closure-API.html" rel="prev" title="The Closure API">
<style type="text/css">
<!--
a.copiable-anchor {visibility: hidden; text-decoration: none; line-height: 0em}
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
span:hover a.copiable-anchor {visibility: visible}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<div class="section" id="Closure-Example">
<div class="header">
<p>
Next: <a href="Thread-Safety.html" accesskey="n" rel="next">Thread Safety</a>, Previous: <a href="The-Closure-API.html" accesskey="p" rel="prev">The Closure API</a>, Up: <a href="Using-libffi.html" accesskey="u" rel="up">Using libffi</a> &nbsp; [<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Closure-Example-1"></span><h3 class="section">2.6 Closure Example</h3>

<p>A trivial example that creates a new <code>puts</code> by binding
<code>fputs</code> with <code>stdout</code>.
</p>
<div class="example">
<pre class="example">#include &lt;stdio.h&gt;
#include &lt;ffi.h&gt;

/* Acts like puts with the file given at time of enclosure. */
void puts_binding(ffi_cif *cif, void *ret, void* args[],
                  void *stream)
{
  *(ffi_arg *)ret = fputs(*(char **)args[0], (FILE *)stream);
}

typedef int (*puts_t)(char *);

int main()
{
  ffi_cif cif;
  ffi_type *args[1];
  ffi_closure *closure;

  void *bound_puts;
  int rc;

  /* Allocate closure and bound_puts */
  closure = ffi_closure_alloc(sizeof(ffi_closure), &amp;bound_puts);

  if (closure)
    {
      /* Initialize the argument info vectors */
      args[0] = &amp;ffi_type_pointer;

      /* Initialize the cif */
      if (ffi_prep_cif(&amp;cif, FFI_DEFAULT_ABI, 1,
                       &amp;ffi_type_sint, args) == FFI_OK)
