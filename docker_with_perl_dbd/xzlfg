C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if C<d_getnetbyaddr_r>
is defined.

=back

=for hackers
Found in file config.h

=over 4

=item C<GETNETBYNAME_R_PROTO>
X<GETNETBYNAME_R_PROTO>

This symbol encodes the prototype of C<getnetbyname_r>.
It is zero if C<d_getnetbyname_r> is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if C<d_getnetbyname_r>
is defined.

=back

=for hackers
Found in file config.h

=over 4

=item C<GETNETENT_R_PROTO>
X<GETNETENT_R_PROTO>

This symbol encodes the prototype of C<getnetent_r>.
It is zero if C<d_getnetent_r> is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if C<d_getnetent_r>
is defined.

=back

=for hackers
Found in file config.h

=over 4

=item C<GETPROTOBYNAME_R_PROTO>
X<GETPROTOBYNAME_R_PROTO>

This symbol encodes the prototype of C<getprotobyname_r>.
It is zero if C<d_getprotobyname_r> is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if C<d_getprotobyname_r>
is defined.

=back

=for hackers
Found in file config.h

=over 4

=item C<GETPROTOBYNUMBER_R_PROTO>
X<GETPROTOBYNUMBER_R_PROTO>

This symbol encodes the prototype of C<getprotobynumber_r>.
It is zero if C<d_getprotobynumber_r> is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if C<d_getprotobynumber_r>
is defined.

=back

=for hackers
Found in file config.h

=over 4

=item C<GETPROTOENT_R_PROTO>
X<GETPROTOENT_R_PROTO>

This symbol encodes the prototype of C<getprotoent_r>.
It is zero if C<d_getprotoent_r> is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if C<d_getprotoent_r>
is defined.

=back

=for hackers
Found in file config.h

=over 4

=item C<GETPWENT_R_PROTO>
X<GETPWENT_R_PROTO>

This symbol encodes the prototype of C<getpwent_r>.
It is zero if C<d_getpwent_r> is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if C<d_getpwent_r>
is defined.

=back

=for hackers
Found in file config.h

=over 4

=item C<GETPWNAM_R_PROTO>
X<GETPWNAM_R_PROTO>

This symbol encodes the prototype of C<getpwnam_r>.
It is zero if C<d_getpwnam_r> is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if C<d_getpwnam_r>
is defined.

=back

=for hackers
Found in file config.h

=over 4

=item C<GETPWUID_R_PROTO>
X<GETPWUID_R_PROTO>

This symbol encodes the prototype of C<getpwuid_r>.
It is zero if C<d_getpwuid_r> is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if C<d_getpwuid_r>
is defined.

=back

=for hackers
Found in file config.h

=over 4

=item C<GETSERVBYNAME_R_PROTO>
X<GETSERVBYNAME_R_PROTO>

This symbol encodes the prototype of C<getservbyname_r>.
It is zero if C<d_getservbyname_r> is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if C<d_getservbyname_r>
is defined.

=back

=for hackers
Found in file config.h

=over 4

=item C<GETSERVBYPORT_R_PROTO>
X<GETSERVBYPORT_R_PROTO>

This symbol encodes the prototype of C<getservbyport_r>.
It is zero if C<d_getservbyport_r> is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if C<d_getservbyport_r>
is defined.

=back

=for hackers
Found in file config.h

=over 4

=item C<GETSERVENT_R_PROTO>
X<GETSERVENT_R_PROTO>

This symbol encodes the prototype of C<getservent_r>.
It is zero if C<d_getservent_r> is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if C<d_getservent_r>
is defined.

=back

=for hackers
Found in file config.h

=over 4

=item C<GETSPNAM_R_PROTO>
X<GETSPNAM_R_PROTO>

This symbol encodes the prototype of C<getspnam_r>.
It is zero if C<d_getspnam_r> is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if C<d_getspnam_r>
is defined.

=back

=for hackers
Found in file config.h

=over 4

=item C<HAS_DBMINIT_PROTO>
X<HAS_DBMINIT_PROTO>

This symbol, if defined, indicates that the system provides
a prototype for the C<dbminit()> function.  Otherwise, it is up
to the program to supply one.  A good guess is

 extern int dbminit(char *);

=back

=for hackers
Found in file config.h

=over 4

=item C<HAS_DRAND48_PROTO>
X<HAS_DRAND48_PROTO>

This symbol, if defined, indicates that the system provides
a prototype for the C<drand48()> function.  Otherwise, it is up
to the program to supply one.  A good guess is

 extern double drand48(void);

=back

=for hackers
Found in file config.h

=over 4

=item C<HAS_FLOCK_PROTO>
X<HAS_FLOCK_PROTO>

This symbol, if defined, indicates that the system provides
a prototype for the C<flock()> function.  Otherwise, it is up
to the program to supply one.  A good guess is

 extern int flock(int, int);

=back

=for hackers
Found in file config.h

=over 4

=item C<HAS_GETHOST_PROTOS>
X<HAS_GETHOST_PROTOS>

This symbol, if defined, indicates that F<netdb.h> includes
prototypes for C<gethostent()>, C<gethostbyname()>, and
C<gethostbyaddr()>.  Otherwise, it is up to the program to guess
them.  See netdbtype.U (part of metaconfig) for probing for various C<Netdb_xxx_t> types.

=back

=for hackers
Found in file config.h

=over 4

=item C<HAS_GETNET_PROTOS>
X<HAS_GETNET_PROTOS>

This symbol, if defined, indicates that F<netdb.h> includes
prototypes for C<getnetent()>, C<getnetbyname()>, and
C<getnetbyaddr()>.  Otherwise, it is up to the program to guess
them.  See netdbtype.U (part of metaconfig) for probing for various C<Netdb_xxx_t> types.

=back

=for hackers
Found in file config.h

=over 4

=item C<HAS_GETPROTO_PROTOS>
X<HAS_GETPROTO_PROTOS>

This symbol, if defined, indicates that F<netdb.h> includes
prototypes for C<getprotoent()>, C<getprotobyname()>, and
C<getprotobyaddr()>.  Otherwise, it is up to the program to guess
them.  See netdbtype.U (part of metaconfig) for probing for various C<Netdb_xxx_t> types.

=back

=for hackers
Found in file config.h

=over 4

=item C<HAS_GETSERV_PROTOS>
X<HAS_GETSERV_PROTOS>

This symbol, if defined, indicates that F<netdb.h> includes
prototypes for C<getservent()>, C<getservbyname()>, and
C<getservbyaddr()>.  Otherwise, it is up to the program to guess
them.  See netdbtype.U (part of metaconfig) for probing for various C<Netdb_xxx_t> types.

=back

=for hackers
Found in file config.h

=over 4

=item C<HAS_MODFL_PROTO>
X<HAS_MODFL_PROTO>

This symbol, if defined, indicates that the system provides
a prototype for the C<modfl()> function.  Otherwise, it is up
to the program to supply one.

=back

=for hackers
Found in file config.h

=over 4

=item C<HAS_SBRK_PROTO>
X<HAS_SBRK_PROTO>

This symbol, if defined, indicates that the system provides
a prototype for the C<sbrk()> function.  Otherwise, it is up
to the program to supply one.  Good guesses are

 extern void* sbrk(int);
 extern void* sbrk(size_t);

=back

=for hackers
Found in file config.h

=over 4

=item C<HAS_SETRESGID_PROTO>
X<HAS_SETRESGID_PROTO>

This symbol, if defined, indicates that the system provides
a prototype for the C<setresgid()> function.  Otherwise, it is up
to the program to supply one.  Good guesses are

 extern int setresgid(uid_t ruid, uid_t euid, uid_t suid);

=back

=for hackers
Found in file config.h

=over 4

=item C<HAS_SETRESUID_PROTO>
X<HAS_SETRESUID_PROTO>

This symbol, if defined, indicates that the system provides
a prototype for the C<setresuid()> function.  Otherwise, it is up
to the program to supply one.  Good guesses are

 extern int setresuid(uid_t ruid, uid_t euid, uid_t suid);

=back

=for hackers
Found in file config.h

=over 4

=item C<HAS_SHMAT_PROTOTYPE>
X<HAS_SHMAT_PROTOTYPE>

This symbol, if defined, indicates that the F<sys/shm.h> includes
a prototype for C<shmat()>.  Otherwise, it is up to the program to
guess one.  C<Shmat_t> C<shmat(int, Shmat_t, int)> is a good guess,
but not always right so it should be emitted by the program only
when C<HAS_SHMAT_PROTOTYPE> is not defined to avoid conflicting defs.

=back

=for hackers
Found in file config.h

=over 4

=item C<HAS_SOCKATMARK_PROTO>
X<HAS_SOCKATMARK_PROTO>

This symbol, if defined, indicates that the system provides
a prototype for the C<sockatmark()> function.  Otherwise, it is up
to the program to supply one.  A good guess is

 extern int sockatmark(int);

=back

=for hackers
Found in file config.h

=over 4

=item C<HAS_SYSCALL_PROTO>
X<HAS_SYSCALL_PROTO>

This symbol, if defined, indicates that the system provides
a prototype for the C<syscall()> function.  Otherwise, it is up
to the program to supply one.  Good guesses are

 extern int syscall(int,  ...);
 extern int syscall(long, ...);

=back

=for hackers
Found in file config.h

=over 4

=item C<HAS_TELLDIR_PROTO>
X<HAS_TELLDIR_PROTO>

This symbol, if defined, indicates that the system provides
a prototype for the C<telldir()> function.  Otherwise, it is up
to the program to supply one.  A good guess is

 extern long telldir(DIR*);

=back

=for hackers
Found in file config.h

=over 4

=item C<NDBM_H_USES_PROTOTYPES>
X<NDBM_H_USES_PROTOTYPES>

This symbol, if defined, indicates that F<ndbm.h> uses real C<ANSI> C
prototypes instead of K&R style function declarations without any
parameter information. While C<ANSI> C prototypes are supported in C++,
K&R style function declarations will yield errors.

=back

=for hackers
Found in file config.h

=over 4

=item C<RANDOM_R_PROTO>
X<RANDOM_R_PROTO>

This symbol encodes the prototype of C<random_r>.
It is zero if C<d_random_r> is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if C<d_random_r>
is defined.

=back

=for hackers
Found in file config.h

=over 4

=item C<READDIR_R_PROTO>
X<READDIR_R_PROTO>

This symbol encodes the prototype of C<readdir_r>.
It is zero if C<d_readdir_r> is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if C<d_readdir_r>
is defined.

=back

=for hackers
Found in file config.h

=over 4

=item C<SETGRENT_R_PROTO>
X<SETGRENT_R_PROTO>

This symbol encodes the prototype of C<setgrent_r>.
It is zero if C<d_setgrent_r> is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if C<d_setgrent_r>
is defined.

=back

=for hackers
Found in file config.h

=over 4

=item C<SETHOSTENT_R_PROTO>
X<SETHOSTENT_R_PROTO>

This symbol encodes the prototype of C<sethostent_r>.
It is zero if C<d_sethostent_r> is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if C<d_sethostent_r>
is defined.

=back

=for hackers
Found in file config.h

=over 4

=item C<SETLOCALE_R_PROTO>
X<SETLOCALE_R_PROTO>

This symbol encodes the prototype of C<setlocale_r>.
It is zero if C<d_setlocale_r> is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if C<d_setlocale_r>
is defined.

=back

=for hackers
Found in file config.h

=over 4

=item C<SETNETENT_R_PROTO>
X<SETNETENT_R_PROTO>

This symbol encodes the prototype of C<setnetent_r>.
It is zero if C<d_setnetent_r> is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if C<d_setnetent_r>
is defined.

=back

=for hackers
Found in file config.h

=over 4

=item C<SETPROTOENT_R_PROTO>
X<SETPROTOENT_R_PROTO>

This symbol encodes the prototype of C<setprotoent_r>.
It is zero if C<d_setprotoent_r> is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if C<d_setprotoent_r>
is defined.

=back

=for hackers
Found in file config.h

=over 4

=item C<SETPWENT_R_PROTO>
X<SETPWENT_R_PROTO>

This symbol encodes the prototype of C<setpwent_r>.
It is zero if C<d_setpwent_r> is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if C<d_setpwent_r>
is defined.

=back

=for hackers
Found in file config.h

=over 4

=item C<SETSERVENT_R_PROTO>
X<SETSERVENT_R_PROTO>

This symbol encodes the prototype of C<setservent_r>.
It is zero if C<d_setservent_r> is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if C<d_setservent_r>
is defined.

=back

=for hackers
Found in file config.h

=over 4

=item C<SRANDOM_R_PROTO>
X<SRANDOM_R_PROTO>

This symbol encodes the prototype of C<srandom_r>.
It is zero if C<d_srandom_r> is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if C<d_srandom_r>
is defined.

=back

=for hackers
Found in file config.h

=over 4

=item C<SRAND48_R_PROTO>
X<SRAND48_R_PROTO>

This symbol encodes the prototype of C<srand48_r>.
It is zero if C<d_srand48_r> is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if C<d_srand48_r>
is defined.

=back

=for hackers
Found in file config.h

=over 4

=item C<STRERROR_R_PROTO>
X<STRERROR_R_PROTO>

This symbol encodes the prototype of C<strerror_r>.
It is zero if C<d_strerror_r> is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if C<d_strerror_r>
is defined.

=back

=for hackers
Found in file config.h

=over 4

=item C<TMPNAM_R_PROTO>
X<TMPNAM_R_PROTO>

This symbol encodes the prototype of C<tmpnam_r>.
It is zero if C<d_tmpnam_r> is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if C<d_tmpnam_r>
is defined.

=back

=for hackers
Found in file config.h

=over 4

=item C<TTYNAME_R_PROTO>
X<TTYNAME_R_PROTO>

This symbol encodes the prototype of C<ttyname_r>.
It is zero if C<d_ttyname_r> is undef, and one of the
C<REENTRANT_PROTO_T_ABC> macros of F<reentr.h> if C<d_ttyname_r>
is defined.

=back

=for hackers
Found in file config.h

=head1 Reference-counted stack manipulation

Functions for pushing and pulling items on the stack when the
stack is reference counted. They are intended as replacements
for the old PUSHs, POPi, EXTEND etc pp macros within pp
functions.


=over 4

=item C<rpp_context>
X<rpp_context>

NOTE: C<rpp_context> is B<experimental> and may change or be
removed without notice.

Impose void, scalar or list context on the stack.
First, pop C<extra> items off the stack, then when C<gimme> is:
C<G_LIST>:   return as-is.
C<G_VOID>:   pop everything back to C<mark>
C<G_SCALAR>: move the top stack item (or C<&PL_sv_undef> if none) to
C<mark+1> and free everything above it.

=over 3

 void  rpp_context(SV **mark, U8 gimme, SSize_t extra)

=back

=back

=for hackers
Found in file inline.h

=over 4

=item C<rpp_extend>
X<rpp_extend>

NOTE: C<rpp_extend> is B<experimental> and may change or be
removed without notice.

Ensures that there is space on the stack to push C<n> items, extending it
if necessary.

=over 3

 void  rpp_extend(SSize_t n)

=back

=back

=for hackers
Found in file inline.h

=over 4

=item C<rpp_invoke_xs>
X<rpp_invoke_xs>

NOTE: C<rpp_invoke_xs> is B<experimental> and may change or be
removed without notice.

Call the XS function associated with C<cv>. Wraps the call if necessary to
handle XS functions which are not aware of reference-counted stacks.

=over 3

 void  rpp_invoke_xs(CV *cv)

=back

=back

=for hackers
Found in file inline.h

=over 4

=item C<rpp_is_lone>
X<rpp_is_lone>

NOTE: C<rpp_is_lone> is B<experimental> and may change or be
removed without notice.

Indicates whether the stacked SV C<sv> (assumed to be not yet popped off
the stack) is only kept alive due to a single reference from the argument
stack and/or and the temps stack.

This can used for example to decide whether the copying of return values
in rvalue context can be skipped, or whether it shouldn't be assigned to
in lvalue context.

=over 3

 bool  rpp_is_lone(SV *sv)

=back

=back

=for hackers
Found in file inline.h

=over 4

=item C<rpp_popfree_1_NN>
X<rpp_popfree_1_NN>

NOTE: C<rpp_popfree_1_NN> is B<experimental> and may change or be
removed without notice.

A variant of rpp_popfree_1() which assumes that the pointer being popped
off the stack is non-NULL.

=over 3

 void  rpp_popfree_1_NN()

=back

=back

=for hackers
Found in file inline.h

=over 4

=item C<rpp_popfree_2_NN>
X<rpp_popfree_2_NN>

NOTE: C<rpp_popfree_2_NN> is B<experimental> and may change or be
removed without notice.

A variant of rpp_popfree_2() which assumes that the two pointers being
popped off the stack are non-NULL.

=over 3

 void  rpp_popfree_2_NN()

=back

=back

=for hackers
Found in file inline.h

=over 4

=item C<rpp_popfree_to>
X<rpp_popfree_to>

NOTE: C<rpp_popfree_to> is B<experimental> and may change or be
removed without notice.

Pop and free all items on the argument stack above C<sp>. On return,
C<PL_stack_sp> will be equal to C<sp>.

=over 3

 void  rpp_popfree_to(SV **sp)

=back

=back

=for hackers
Found in file inline.h

=over 4

=item C<rpp_popfree_to_NN>
X<rpp_popfree_to_NN>

NOTE: C<rpp_popfree_to_NN> is B<experimental> and may change or be
removed without notice.

A variant of rpp_popfree_to() which assumes that all the pointers being
popped off the stack are non-NULL.

=over 3

 void  rpp_popfree_to_NN(SV **sp)

=back

=back

=for hackers
Found in file inline.h

=over 4

=item C<rpp_popfree_1>
X<rpp_popfree_1>

NOTE: C<rpp_popfree_1> is B<experimental> and may change or be
removed without notice.

Pop and free the top item on the argument stack and update C<PL_stack_sp>.

=over 3

 void  rpp_popfree_1()

=back

=back

=for hackers
Found in file inline.h

=over 4

=item C<rpp_popfree_2>
X<rpp_popfree_2>

NOTE: C<rpp_popfree_2> is B<experimental> and may change or be
removed without notice.

Pop and free the top two items on the argument stack and update
C<PL_stack_sp>.

=over 3

 void  rpp_popfree_2()

=back

=back

=for hackers
Found in file inline.h

=over 4

=item C<rpp_pop_1_norc>
X<rpp_pop_1_norc>

NOTE: C<rpp_pop_1_norc> is B<experimental> and may change or be
removed without notice.

Pop and return the top item off the argument stack and update
C<PL_stack_sp>. It's similar to rpp_popfree_1(), except that it actually
returns a value, and it I<doesn't> decrement the SV's reference count.
On non-C<PERL_RC_STACK> builds it actually increments the SV's reference
count.

This is useful in cases where the popped value is immediately embedded
somewhere e.g. via av_store(), allowing you skip decrementing and then
immediately incrementing the reference count again (and risk prematurely
freeing the SV if it had a RC of 1). On non-RC builds, the reference count
bookkeeping still works too, which is why it should be used rather than
a simple C<*PL_stack_sp-->.

=over 3

 SV *  rpp_pop_1_norc()

=back

=back

=for hackers
Found in file inline.h

=over 4

=item C<rpp_push_1_norc>
X<rpp_push_1_norc>

NOTE: C<rpp_push_1_norc> is B<experimental> and may change or be
removed without notice.

Push C<sv> onto the stack without incrementing its reference count, and
update C<PL_stack_sp>. On non-PERL_RC_STACK builds, mortalise too.

This is most useful where an SV has just been created and already has a
reference count of 1, but has not yet been anchored anywhere.

=over 3

 void  rpp_push_1_norc(SV *sv)

=back

=back

=for hackers
Found in file inline.h

=over 4

=item C<rpp_push_1>

=item C<rpp_push_IMM>

=item C<rpp_push_2>

=item C<rpp_xpush_1>

=item C<rpp_xpush_IMM>

=item C<rpp_xpush_2>
X<rpp_push_1>X<rpp_push_IMM>X<rpp_push_2>X<rpp_xpush_1>X<rpp_xpush_IMM>X<rpp_xpush_2>

NOTE: all these forms are B<experimental> and may change or be
removed without notice.

Push one or two SVs onto the stack, incrementing their reference counts
and updating C<PL_stack_sp>. With the C<x> variants, it extends the stack
first. The C<IMM> variants assume that the single argument is an immortal
such as <&PL_sv_undef> and, for efficiency, will skip incrementing its
reference count.

=over 3

 void  rpp_push_1   (SV *sv)
 void  rpp_push_IMM (SV *sv)
 void  rpp_push_2   (SV *sv1, SV *sv2)
 void  rpp_xpush_1  (SV *sv)
 void  rpp_xpush_IMM(SV *sv)
 void  rpp_xpush_2  (SV *sv1, SV *sv2)

=back

=back

=for hackers
Found in file inline.h

=over 4

=item C<rpp_replace_at>
X<rpp_replace_at>

NOTE: C<rpp_replace_at> is B<experimental> and may change or be
removed without notice.

Replace the SV at address sp within the stack with C<sv>, while suitably
adjusting reference counts. Equivalent to C<*sp = sv>, except with proper
reference count handling.

=over 3

 void  rpp_replace_at(SV **sp, SV *sv)

=back

