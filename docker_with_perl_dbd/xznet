# Temporarily disabled         }
      else
        {
  
#------------------------------------------------------------------------------
# When we get to this part of the code it means that the current command line 
# argument is not a known option.
#
# We check if it is the name of an experiment directory and if so, add it to 
# the list with directories to use.
#
# If not, print an error message and increment the error variable because this
# is clearly something that is not right.
#-------------------------------------------------------------------------------

          if ($arg =~ /^\-.*/)
            {
#-------------------------------------------------------------------------------
# It is an option, but not a supported one.  Print a message and increment
# the error count.
#-------------------------------------------------------------------------------
              $message = "option $arg is not a known option";
              push (@g_user_input_errors, $message);

              $option_errors++;
            }
          else
            {
#-------------------------------------------------------------------------------
# Other than options, the input has to consist of at least one directory name.  
# First remove any trailing slashes (/) and then check if the name is valid.
#-------------------------------------------------------------------------------
              $arg =~ s/\/*\/$//;
              if ($arg =~ /.+\.er$/)
                {
#-------------------------------------------------------------------------------
# It is the name of an experiment directory and is added to the list.
#-------------------------------------------------------------------------------
                  $found_exp_dir = $TRUE;
                  push (@exp_dir_list, $arg);
                }
              else
                {
#-------------------------------------------------------------------------------
# It is not a valid experiment directory name. Print a message and exit.
#-------------------------------------------------------------------------------
                  $message = "not a valid experiment directory name: $arg";
                  push (@g_user_input_errors, $message);

                  $option_errors++;
                }
            }

        } #-- End of last else

    } #-- End of while-loop

#-------------------------------------------------------------------------------
# Check if the name of the experiment directories is valid.  Note that later
# we check for these directories to exist.
#-------------------------------------------------------------------------------
  if (not $found_exp_dir) 
    {
      $message = "experiment directory name(s) are either not valid, or missing";
      push (@g_user_input_errors, $message);

      $option_errors++;
    }

#------------------------------------------------------------------------------
# Check for fatal errors to have occurred. If so, stop execution.  Otherwise,
# confirm the verbose setting.
#------------------------------------------------------------------------------
  if ($option_errors > 0)
    {
      gp_message ("debug", $subr_name, "a total of $option_errors input errors have been found");
    }
  else
    {
      gp_message ("debug", $subr_name, "no errors in the options found");
    }

  return ($option_errors, $found_exp_dir, \@exp_dir_list);

} #-- End of subroutine parse_and_check_user_options

#------------------------------------------------------------------------------
# Parse the generated .dis files
#------------------------------------------------------------------------------
sub parse_dis_files
{
  my $subr_name = get_my_name ();

  my ($number_of_metrics_ref, $function_info_ref, 
      $function_address_and_index_ref, $input_string_ref, 
      $addressobj_index_ref) = @_;

#------------------------------------------------------------------------------
# Note that $function_address_and_index_ref is not used, but we need to pass 
# in the address into generate_dis_html.
#------------------------------------------------------------------------------
  my $number_of_metrics = ${ $number_of_metrics_ref };
  my @function_info     = @{ $function_info_ref };
  my $input_string      = ${ $input_string_ref };
  my %addressobj_index  = %{ $addressobj_index_ref };

#------------------------------------------------------------------------------
# The regex section.
#------------------------------------------------------------------------------
  my $dis_filename_id_regex = 'file\.([0-9]+)\.dis';

  my $filename;
  my $outputdir = append_forward_slash ($input_string);

  my @source_line = ();
  my $source_line_ref; 

  my @metric = ();
  my $metric_ref;

  my $target_function;
 
  gp_message ("debug", $subr_name, "building disassembly files");
  gp_message ("debug", $subr_name, "outputdir = $outputdir");

  while (glob ($outputdir.'*.dis'))
    {
      gp_message ("debug", $subr_name, "processing disassembly file: $_");

      my $base_name = get_basename ($_);

      if ($base_name =~ /$dis_filename_id_regex/)
        {
          if (defined ($1))
            {
              gp_message ("debug", $subr_name, "processing disassembly file: $base_name $1");
              if (exists ($function_info[$1]{"routine"}))
                {
                  $target_function = $function_info[$1]{"routine"};
                  gp_message ("debug", $subr_name, "processing disassembly file: $base_name target_function = $target_function");
                }
              if (exists ($g_function_tag_id{$target_function}))
                {
                  gp_message ("debug", $subr_name, "target_function = $target_function ftag = $g_function_tag_id{$target_function}");
                }
              else
                {
                  my $msg = "no function tag found for $target_function";
                  gp_message ("assertion", $subr_name, $msg);
                }
            }
          else
            {
              gp_message ("debug", $subr_name, "processing disassembly file: $base_name unknown id");
            }
        }
        
      $filename = $_;
      gp_message ("verbose", $subr_name, "  Processing disassembly file $filename");
      ($source_line_ref, $metric_ref) = generate_dis_html (
                                          \$target_function,
                                          \$number_of_metrics, 
                                          $function_info_ref, 
                                          $function_address_and_index_ref, 
                                          \$outputdir, 
                                          \$filename, 
                                          \@source_line, 
                                          \@metric, 
                                          \%addressobj_index);

      @source_line = @{ $source_line_ref };
      @metric      = @{ $metric_ref };
    }
 
  return (0)

} #-- End of subroutine parse_dis_files

#------------------------------------------------------------------------------
# Parse the .src.txt files
#------------------------------------------------------------------------------
sub parse_source_files
{
  my $subr_name = get_my_name ();

  my ($number_of_metrics_ref, $function_info_ref, $outputdir_ref) = @_;

  my $number_of_metrics = ${ $number_of_metrics_ref };
  my $outputdir         = ${ $outputdir_ref };
  my $ignore_value;

  my $outputdir_with_slash = append_forward_slash ($outputdir);

  gp_message ("verbose", $subr_name, "building source files");

  while (glob ($outputdir_with_slash.'*.src.txt'))
    {
      gp_message ("verbose", $subr_name, "  Processing source file: $_");
      gp_message ("debug", $subr_name, "processing source file: $_");

      my $found_target = process_source (
                           $number_of_metrics, 
                           $function_info_ref, 
                           $outputdir_with_slash, 
                           $_);

      if (not $found_target)
        {
          gp_message ("debug", $subr_name, "target function not found");
        }
    }

} #-- End of subroutine parse_source_files

#------------------------------------------------------------------------------
# Routine to prepend \\ to selected symbols.
#------------------------------------------------------------------------------
sub prepend_backslashes
{
  my $subr_name = get_my_name ();

  my ($target_string) = @_;

  gp_message ("debug", $subr_name, "target_string on entry  = $target_string");

  $target_string =~ s/\(/\\\(/g; 
  $target_string =~ s/\)/\\\)/g; 
  $target_string =~ s/\+/\\\+/g; 
  $target_string =~ s/\[/\\\[/g; 
  $target_string =~ s/\]/\\\]/g; 
  $target_string =~ s/\*/\\\*/g; 
  $target_string =~ s/\./\\\./g; 
  $target_string =~ s/\$/\\\$/g; 
  $target_string =~ s/\^/\\\^/g; 
  $target_string =~ s/\#/\\\#/g; 

  gp_message ("debug", $subr_name, "target_string on return = $target_string");

  return ($target_string);

} #-- End of subroutine prepend_backslashes

#------------------------------------------------------------------------------
# TBD
#------------------------------------------------------------------------------
sub preprocess_function_files
{
  my $subr_name = get_my_name ();

  my ($metric_description_ref, $script_pc_metrics, $input_string, $sort_fields_ref) = @_;

  my $outputdir   = append_forward_slash ($input_string);
  my @sort_fields = @{ $sort_fields_ref };
  
  my $error_code; 
  my $cmd_output;
  my $re;

# TBD  $outputdir .= "/";

  gp_message ("debug", $subr_name, "enter subroutine");

  my %metric_description = %{ $metric_description_ref };

  for my $m (keys %metric_description)
    {
      gp_message ("debug", $subr_name, "metric_description{$m} = $metric_description{$m}");
    }

  $re = name_regex ($metric_description_ref, $script_pc_metrics, "functions", $outputdir."functions.sort.func-PC");
  ($error_code, $cmd_output) = execute_system_cmd ("echo '$re' > $outputdir"."functions.sort.func-PC.name-regex");
  if ($error_code != 0 )
    {
      gp_message ("abort", $subr_name, "execution terminated");
    }

  for my $field (@sort_fields)
    {
      $re = name_regex ($metric_description_ref, $script_pc_metrics, $field, $outputdir."$field.sort.func-PC");
      ($error_code, $cmd_output) = execute_system_cmd ("echo '$re' > $outputdir"."$field.sort.func-PC.name-regex");
      if ($error_code != 0 )
        {
          gp_message ("abort", $subr_name, "execution terminated");
        }
    }

  $re = name_regex ($metric_description_ref, $script_pc_metrics, "calls", $outputdir."calls.sort.func-PC");
  ($error_code, $cmd_output) = execute_system_cmd ("echo '$re' > $outputdir"."calls.sort.func-PC.name-regex");
  if ($error_code != 0 )
    {
      gp_message ("abort", $subr_name, "execution terminated");
    }

  if ($g_user_settings{"calltree"}{"current_value"} eq "on")
    {
      $re = name_regex ($metric_description_ref, $script_pc_metrics, "calltree", $outputdir."calltree.sort.func-PC");
      ($error_code, $cmd_output) = execute_system_cmd ("echo '$re' > $outputdir"."calltree.sort.func-PC.name-regex");
      if ($error_code != 0 )
        {
          gp_message ("abort", $subr_name, "execution terminated");
        }
    }

  return (0);

} #-- End of subroutine preprocess_function_files

#-------------------------------------------------------------------------------
# Print the help overview
#-------------------------------------------------------------------------------
sub print_help_info 
{
  print
    #-------Marker line - do not go beyond this line ------------------------------
    "Usage: $driver_cmd [OPTION(S)] EXPERIMENT(S)\n".
    "\n".
    "Process one or more experiments to generate a directory containing the\n" .
    "index.html file that may be used to browse the experiment data.\n".
    "\n".
    "Options:\n".
    "\n".
    " --help              print usage information and exit.\n".
    " --version           print the version number and exit.\n".
    " --verbose {on|off}  enable/disable verbose mode that shows diagnostic\n" .
    "                       messages about the processing of the data; default\n" .
    "                       is off.\n".
    #-------Marker line - do not go beyond this line ------------------------------
    " -d, --debug {on|s|m|l|xl|off}  control the printing of run time information\n" .
    "                        to assist with troubleshooting, or further\n" .
    "                        development of this tool; on gives a modest amount\n" .
    "                        of information; s, m, l, or xl gives an increasing\n" .
    "                        amount of information and off disables the printing\n" .
    "                        of debug information; note that currently on, s, m,\n" .
    "                        and l are equivalent; this is expected to change in\n" .
    "                        future updates; default is off.\n" .
    #-------Marker line - do not go beyond this line ------------------------------
    " -hp, ----highlight-percentage <value>  a percentage value in the interval\n" .
    "                                 [0,100] to select and color code source\n" .
    "                                 lines as well as instructions that are\n" .
    "                                 within this percentage of the maximum\n" .
    "                                 metric value(s); a value of zero (-hp 0)\n" .
    "                                 disables this feature; the default is 90.\n".
    #-------Marker line - do not go beyond this line ------------------------------
    " -o, --output <dir-name>  use <dir-name> to store the results in; the\n" .
    "                            default name is ./display.<n>.html with <n> the\n" .
    "                            first positive integer number not in use; an\n" .
    "                            existing directory is not overwritten.\n".
    #-------Marker line - do not go beyond this line ------------------------------
    " -O, --overwrite <dir-name>  use <dir-name> to store the results in and\n" .
    "                               overwrite any existing directory with the\n" .
    "                               same name; make sure that umask is set to the\n" .
    "                               correct access permissions.\n" .
    #-------Marker line - do not go beyond this line ------------------------------
    " -q, --quiet {on|off}  disable/allow the display of all warning, debug and\n" .
    "                         verbose messages; if set to on, the settings for\n" .
    "                         verbose, warnings and debug are ignored; default\n" .
    "                         is off.\n".
    #-------Marker line - do not go beyond this line ------------------------------
    " -w, --warnings {on|off}  enable/disable run time warning messages;\n" .
    "                            default is on.\n".
    "\n".
# Temmporarily disabled    " -fl, --func-limit <limit>  impose a limit on the number of functions processed;\n".
# Temmporarily disabled    "                             this is an integer number; set to 0 to process all\n".
# Temmporarily disabled    "                             functions; the default value is 100.\n".
# Temmporarily disabled    "\n".
# Temmporarily disabled    "  -ct, --calltree {on|off}  enable or disable an html page with a call tree linked\n".
# Temmporarily disabled    "                             from the bottom of the first page; default is off.\n".
# Temmporarily disabled    "\n".
# Temmporarily disabled    "  -tp, --threshold-percentage <percentage>  provide a percentage of metric accountability; the\n".
# Temmporarily disabled    "                                             inclusion of functions for each metric will take\n".
# Temmporarily disabled    "                                             place in sort order until the percentage has been\n".
# Temmporarily disabled    "                                             reached.\n".
# Temmporarily disabled    "\n".
# Temmporarily disabled    "  -dm, --default-metrics {on|off}  enable or disable automatic selection of metrics\n".
# Temmporarily disabled    "                                   and use a default set of metrics; the default is off.\n".
# Temmporarily disabled    "\n".
# Temmporarily disabled    "  -im, --ignore-metrics <metric-list>  ignore the metrics from <metric-list>.\n".
# Temmporarily disabled    "\n".
# Temmporarily disabled     "Environment:\n".
# Temmporarily disabled     "\n".
# Temmporarily disabled     "The options can be set in a configuration file called .gp-display-html.rc.  This\n".
# Temmporarily disabled     "file needs to be either in the current directory, or in the home directory of the user.\n".
# Temmporarily disabled     "The long name of the option without the leading dashes is supported.  For example calltree\n".
# Temmporarily disabled     "to enable or disable the call tree.  Note that some options take a value.  In case the same option\n".
# Temmporarily disabled     "occurs multiple times in this file, only the last setting encountered is preserved.\n".
# Temmporarily disabled     "\n".
    "Documentation:\n".
    "\n".
    "A getting started guide for gprofng is maintained as a Texinfo manual.\n" .
    "If the info and gprofng programs are properly installed at your site,\n" .
    "the command \"info gprofng\" should give you access to this document.\n".
    "\n".
    "See also:\n".
    "\n".
    "gprofng(1), gp-archive(1), gp-collect-app(1), gp-display-src(1), " .
    "gp-display-text(1)\n";

    return (0);

} #-- End of subroutine print_help_info

#-------------------------------------------------------------------------------
# Print the meta data for each experiment directory.
#-------------------------------------------------------------------------------
sub print_meta_data_experiments
{
  my $subr_name = get_my_name ();

  my ($mode) = @_;

  for my $exp (sort keys %g_exp_dir_meta_data)
    {
      for my $meta (sort keys %{$g_exp_dir_meta_data{$exp}})
        {
          gp_message ($mode, $subr_name, "$exp => $meta = $g_exp_dir_meta_data{$exp}{$meta}");
        }
    }

  return (0);

} #-- End of subroutine print_meta_data_experiments

#------------------------------------------------------------------------------
# Brute force subroutine that prints the contents of a structure with function
# level information.  This version is for a top level array structure, 
# followed by a hash.
#------------------------------------------------------------------------------
sub print_metric_function_array
{
  my $subr_name = get_my_name ();

  my ($metric, $struct_type_name, $target_structure_ref) = @_;

  my @target_structure = @{$target_structure_ref}; 

  gp_message ("debugXL", $subr_name, "contents of structure ".$struct_type_name."{".$metric."}:");

  for my $fields (sort keys @target_structure)
    {
          for my $elems (sort keys % {$target_structure[$fields]})
            {
              my $msg = $struct_type_name."{$metric}[$fields]{$elems} = ";
              $msg   .= $target_structure[$fields]{$elems};
              gp_message ("debugXL", $subr_name, $msg);
            }
    }

  return (0);

} #-- End of subroutine print_metric_function_array

#------------------------------------------------------------------------------
# Brute force subroutine that prints the contents of a structure with function
# level information.  This version is for a top level hash structure.  The
# next level may be another hash, or an array.
#------------------------------------------------------------------------------
sub print_metric_function_hash
{
  my $subr_name = get_my_name ();

  my ($sub_struct_type, $metric, $struct_type_name, $target_structure_ref) = @_;

  my %target_structure = %{$target_structure_ref}; 

  gp_message ("debugXL", $subr_name, "contents of structure ".$struct_type_name."{".$metric."}:");

  for my $fields (sort keys %target_structure)
    {
      gp_message ("debugXL", $subr_name, "metric = $metric fields = $fields");
      if ($sub_struct_type eq "hash_hash")
        {
          for my $elems (sort keys %{$target_structure{$fields}})
            {
              my $txt = $struct_type_name."{$metric}{$fields}{$elems} = ";
              $txt   .= $target_structure{$fields}{$elems};
              gp_message ("debugXL", $subr_name, $txt);
            }
        }
      elsif ($sub_struct_type eq "hash_array")
        {
          my $values = "";
          for my $elems (sort keys @{$target_structure{$fields}})
            {
              $values .= "$target_structure{$fields}[$elems] ";
            }
          gp_message ("debugXL", $subr_name, $struct_type_name."{$metric}{$fields} = $values");
        }
      else
        {
          my $msg = "sub-structure type '$sub_struct_type' is not supported";
          gp_message ("assertion", $subr_name, $msg);
        }
    }
        
  return (0);

} #-- End of subroutine print_metric_function_hash

#------------------------------------------------------------------------------
# Print the opening message.
#------------------------------------------------------------------------------
sub print_opening_message
{
  my $subr_name = get_my_name ();
#------------------------------------------------------------------------------
# Since the second argument is an array, we pass it in by reference.  The
# alternative is to make it the last argument.
#------------------------------------------------------------------------------
  my ($outputdir, $exp_dir_list_ref, $time_percentage_multiplier) = @_;

  my @exp_dir_list = @{$exp_dir_list_ref};

  my $msg;
  my $no_of_dirs = scalar (@exp_dir_list);
#------------------------------------------------------------------------------
# Build a comma separated list with all directory names.  If there is only one
# entry, the leading comma will not be inserted.
#------------------------------------------------------------------------------
  my $dir_list   = join (", ", @exp_dir_list);

#------------------------------------------------------------------------------
# If there are at least two entries, find the last comma and replace it by
# " and".  Note that we know there is at least one comma, so the value 
# returned by rindex () cannot be -1.
#------------------------------------------------------------------------------
  if ($no_of_dirs > 1)
    {
      my $last_comma   = rindex ($dir_list, ",");
      my $ignore_value = substr ($dir_list, $last_comma, 1, " and");
    }
  $msg = "start $tool_name, generating directory $outputdir from $dir_list";

  gp_message ("verbose", $subr_name, $msg);

  if ($time_percentage_multiplier < 1.0)
    {
      $msg = "Handle at least ";
    }
  else
    {
      $msg = "Handle ";
    }

  $msg .= ($time_percentage_multiplier*100.0)."% of the time";
      
  gp_message ("verbose", $subr_name, $msg);

} #-- End of subroutine print_opening_message

#------------------------------------------------------------------------------
# TBD.
#------------------------------------------------------------------------------
sub print_program_header
{
  my $subr_name = get_my_name ();

  my ($mode, $tool_name, $binutils_version) = @_;

  my $header_limit = 60;
  my $dashes = "-";

#------------------------------------------------------------------------------
# Generate the dashed line
#------------------------------------------------------------------------------
  for (2 .. $header_limit)
    {
      $dashes .= "-";
    }

    gp_message ($mode, $subr_name, $dashes);
    gp_message ($mode, $subr_name, "Tool name: $tool_name");
    gp_message ($mode, $subr_name, "Version  : $binutils_version");
    gp_message ($mode, $subr_name, "Date     : " . localtime ());
    gp_message ($mode, $subr_name, $dashes);

} #-- End of subroutine print_program_header

#------------------------------------------------------------------------------
# Print a comment string, followed by the values of the options. The list
# with the keywords is sorted alphabetically.
#
# The value stored in $mode is passed on to gp_message ().  The intended use
# for this is to call this function in verbose and/or debug mode.
#
# The comment string is converted to uppercase.
#
# In case the length of the comment exceeds the length of the dashed line,
# the comment line is allowed to stick out to the right.
#
# If the length of the comment is less than the dashed line, it is centered 
# relative to the # length of the dashed line. 

# If the length of the comment and this line do not divide, an extra space is 
# added to the left of the comment.
#
# For example, if the comment is 55 long, there are 5 spaces to be distributed.
# There will be 3 spaces, followed by the comment. 
#------------------------------------------------------------------------------
sub print_table_user_settings
{
  my $subr_name = get_my_name ();

  my ($mode, $comment) = @_;

  my $leftover;
  my $padding;

  my $keyword;
  my $user_option;
  my $defined;
  my $value;
  my $data_type; 

  my $HEADER_LIMIT = 60;
  my $header = sprintf ("%-20s   %-9s   %8s   %s", "keyword", "option", "user set", "value");

#------------------------------------------------------------------------------
# Generate the dashed line
#------------------------------------------------------------------------------
  my $dashes = "-";
  for (2 .. $HEADER_LIMIT)
    {
      $dashes .= "-";
    }

#------------------------------------------------------------------------------
# Determine the padding needed to the left of the comment.
#------------------------------------------------------------------------------
  my $length_comment = length ($comment);

  $leftover = $length_comment%2;

  if ($length_comment <= ($HEADER_LIMIT-2))
    {
      $padding = ($HEADER_LIMIT - $length_comment + $leftover)/2;
    }
  else
    {
      $padding = 0;
    }
    
#------------------------------------------------------------------------------
# Generate the first blank part of the line.
#------------------------------------------------------------------------------
  my $blank_line = "";
  for (1 .. $padding)
    {
      $blank_line .= " ";
    }

#------------------------------------------------------------------------------
# Add the comment line with the first letter in uppercase.
#------------------------------------------------------------------------------
  my $final_comment = $blank_line.ucfirst ($comment);

  gp_message ($mode, $subr_name, $dashes);
  gp_message ($mode, $subr_name, $final_comment);
  gp_message ($mode, $subr_name, $dashes);
  gp_message ($mode, $subr_name, $header);
  gp_message ($mode, $subr_name, $dashes);

#------------------------------------------------------------------------------
# Print a line for each option. The list is sorted alphabetically.
#------------------------------------------------------------------------------
  for my $rc_keyword  (sort keys %g_user_settings)
    {
      $keyword     = $rc_keyword;
      $user_option = $g_user_settings{$rc_keyword}{"option"};
      $defined     = ($g_user_settings{$rc_keyword}{"defined"} ? "set" : "not set");
      $data_type   = $g_user_settings{$rc_keyword}{"data_type"};

      if (defined ($g_user_settings{$rc_keyword}{"current_value"}))
        {
          $value = $g_user_settings{$rc_keyword}{"current_value"};
          if ($data_type eq "boolean")
            {
              $value = $value ? "on" : "off";
            }
        }
      else
        {
          $value       = "undefined";
        }

      my $print_line = sprintf ("%-20s   %-9s   %8s   %s", $keyword, $user_option, $defined, $value);

      gp_message ($mode, $subr_name, $print_line);
    }
} #-- End of subroutine print_table_user_settings

#------------------------------------------------------------------------------
# Dump the contents of nested hash "g_user_settings".  Some simple formatting 
# is applied to make it easier to distinguish the various values.
#------------------------------------------------------------------------------
sub print_user_settings
{
  my $subr_name = get_my_name ();

  my ($mode, $comment) = @_;

  my $keyword_value_pair; 

  gp_message ($mode, $subr_name, $comment);

  for my $rc_keyword (keys %g_user_settings)
    {
      my $print_line = sprintf ("%-20s =>", $rc_keyword);
      for my $fields (sort keys %{ $g_user_settings{$rc_keyword} })
        {
          if (defined ($g_user_settings{$rc_keyword}{$fields}))
            {
              $keyword_value_pair = $fields." = ".$g_user_settings{$rc_keyword}{$fields};
            }
          else
            {
              $keyword_value_pair = $fields." = ". "undefined";
            }
           $print_line = join ("  ", $print_line, $keyword_value_pair);
        }
        gp_message ($mode, $subr_name, $print_line);
    }
} #-- End of subroutine print_user_settings

#------------------------------------------------------------------------------
# Print the version number and license information.
#------------------------------------------------------------------------------
sub print_version_info 
{
  print "$version_info\n";
  print "Copyright (C) 2023 Free Software Foundation, Inc.\n";
  print "License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\n";
  print "This is free software: you are free to change and redistribute it.\n";
  print "There is NO WARRANTY, to the extent permitted by law.\n";

  return (0);

} #-- End of subroutine print_version_info

#------------------------------------------------------------------------------
# Process the call tree input data and generate HTML output.
#------------------------------------------------------------------------------
sub process_calltree
{
  my $subr_name = get_my_name ();

  my ($function_info_ref, $function_address_info_ref, $addressobjtextm_ref, 
       $input_string) = @_;

  my @function_info         = @{ $function_info_ref };
  my %function_address_info = %{ $function_address_info_ref };
  my %addressobjtextm       = %{ $addressobjtextm_ref };

  my $outputdir = append_forward_slash ($input_string);

  my @call_tree_data = ();

  my $LANG              = $g_locale_settings{"LANG"};
  my $decimal_separator = $g_locale_settings{"decimal_separator"};

  my $infile  = $outputdir . "calltree";
  my $outfile = $outputdir . "calltree.html";

  open (CALL_TREE_IN, "<", $infile) 
    or die ("Not able to open calltree file $infile for reading - '$!'");
  gp_message ("debug", $subr_name, "opened file $infile for reading");

  open (CALL_TREE_OUT, ">", $outfile) 
    or die ("Not able to open $outfile for writing - '$!'");
  gp_message ("debug", $subr_name, "opened file $outfile for writing");

  gp_message ("debug", $subr_name, "building calltree file $outfile");
  
#------------------------------------------------------------------------------
# The directory name is potentially used below, but since it is a constant,
# we get it here and only once.
#------------------------------------------------------------------------------
#  my ($ignore_file_name, $directory_name, $ignore_suffix) = fileparse ($infile,"");
#  gp_message ("debug", $subr_name, "directory_name = $directory_name");

#------------------------------------------------------------------------------
# Generate some of the structures used in the HTML output.
#------------------------------------------------------------------------------
  my $file_title      = "Call Tree overview";
  my $html_header     = ${ create_html_header (\$file_title) };
  my $html_home_right = ${ generate_home_link ("right") };

  my $page_title    = "Call Tree View";
  my $size_text     = "h2";
  my $position_text = "center";
  my $html_title_header = ${ generate_a_header (
                            \$page_title, 
                            \$size_text, 
                            \$position_text) };

#-------------------------------------------------------------------------------
# Get the acknowledgement, return to main link, and final html statements.
#-------------------------------------------------------------------------------
  my $html_home_left       = ${ generate_home_link ("left") };
  my $html_acknowledgement = ${ create_html_credits () };
  my $html_end             = ${ terminate_html_document () };

#------------------------------------------------------------------------------
# Read all of the file into array with the name call_tree_data.
#------------------------------------------------------------------------------
  chomp (@call_tree_data = <CALL_TREE_IN>);
  close (CALL_TREE_IN);

#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
# Process the data here and generate the HTML lines.
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Print the top part of the HTML file.
#------------------------------------------------------------------------------
  print CALL_TREE_OUT $html_header;
  print CALL_TREE_OUT $html_home_right;
  print CALL_TREE_OUT $html_title_header;

#-------------------------------------------------------------------------------
# Print the generated HTML structures here.
#-------------------------------------------------------------------------------
##  print CALL_TREE_OUT "$_" for @whatever;
##  print CALL_TREE_OUT "<pre>\n";
##  print CALL_TREE_OUT "$_\n" for @whatever2;
##  print CALL_TREE_OUT "</pre>\n";

#-------------------------------------------------------------------------------
# Print the last part of the HTML file.
#-------------------------------------------------------------------------------
  print CALL_TREE_OUT $html_home_left;
  print CALL_TREE_OUT "<br>\n";
  print CALL_TREE_OUT $html_acknowledgement;
  print CALL_TREE_OUT $html_end;

  close (CALL_TREE_OUT);

  return (0);

} #-- End of subroutine process_calltree

#-------------------------------------------------------------------------------
# Process the generated experiment info file(s).
#-------------------------------------------------------------------------------
sub process_experiment_info
{
  my $subr_name = get_my_name ();

  my ($experiment_data_ref) = @_;

  my @exp_info;
  my @experiment_data = @{ $experiment_data_ref };

  my $exp_id;
  my $exp_name;
  my $exp_data_file;
  my $input_line;
  my $target_cmd;
  my $hostname ;
  my $OS;
  my $page_size;
  my $architecture;
  my $start_date;
  my $end_experiment;
  my $data_collection_duration;
  my $total_thread_time;
  my $user_cpu_time;
  my $user_cpu_percentage;
  my $system_cpu_time;
  my $system_cpu_percentage;
  my $sleep_time;
  my $sleep_percentage;

#-------------------------------------------------------------------------------
# Define the regular expressions used to capture the info.
#-------------------------------------------------------------------------------
# Target command (64-bit): './../bindir/mxv-pthreads.exe -m 3000 -n 2000 -t 2'

  my $target_cmd_regex = '\s*Target command\s+(\(.+\)):\s+\'(.+)\'';

# Host `ruudvan-vm-haswell-2-20210609', OS `Linux 5.4.17-2102.202.5.el8uek.x86_64', page size 4096, architecture `x86_64'

  my $host_system_regex = '\s*Host\s+\`(.+)\',\s+OS\s+\`(.+)\',\s+page size\s+(\d+),\s+architecture\s+\`(.+)\'';

# Experiment started Mon Aug 30 13:03:20 2021

  my $start_date_regex = '\s*Experiment started\s+(.+)';

# Experiment Ended: 1.812441219

  my $end_experiment_regex = '\s*Experiment Ended:\s+(.+)';

# Data Collection Duration: 1.812441219

  my $data_collection_duration_regex = '\s*Data Collection Duration:\s+(.+)';

#                           Total Thread Time (sec.): 1.812

  my $total_thread_time_regex = '\s*Total Thread Time (sec.):\s+(.+)';

#                                          User CPU: 1.685 ( 95.0%)

  my $user_cpu_regex = '\s*User CPU:\s+(.+)\s+\(\s*(.+)\)';

#                                        System CPU: 0.088 (  5.0%)

  my $system_cpu_regex = '\s*System CPU:\s+(.+)\s+\(\s*(.+)\)';

#                                             Sleep: 0.    (  0. %)

  my $sleep_regex = '\s*Sleep:\s+(.+)\s+\(\s*(.+)\)';

#-------------------------------------------------------------------------------
# Scan the experiment data and select the info of interest.
#-------------------------------------------------------------------------------
  for my $i (sort keys @experiment_data)
    {
      $exp_id        = $experiment_data[$i]{"exp_id"};
      $exp_name      = $experiment_data[$i]{"exp_name_full"};
      $exp_data_file = $experiment_data[$i]{"exp_data_file"};

      my $msg = "exp_id = $exp_id name = $exp_name file = $exp_data_file";
      gp_message ("debug", $subr_name, $msg);

      open (EXPERIMENT_INFO, "<", $exp_data_file) 
        or die ("$subr_name - unable to open file $exp_data_file for reading '$!'");
      gp_message ("debug", $subr_name, "opened file $exp_data_file for reading");

      chomp (@exp_info = <EXPERIMENT_INFO>);

#-------------------------------------------------------------------------------
# Process the info for the current experiment.
#-------------------------------------------------------------------------------
      for my $line (0 .. $#exp_info)
        {
          $input_line = $exp_info[$line];

          my $msg = "exp_id = $exp_id: input_line = $input_line";
          gp_message ("debugM", $subr_name, $msg);

          if ($input_line =~ /$target_cmd_regex/)
            {
              $target_cmd = $2;
              gp_message ("debugM", $subr_name, "$exp_id => $target_cmd");
              $experiment_data[$i]{"target_cmd"} = $target_cmd;
            }
          elsif ($input_line =~ /$host_system_regex/)
            {
              $hostname  = $1;
              $OS        = $2;
              $page_size = $3;
              $architecture = $4;
              gp_message ("debugM", $subr_name, "$exp_id => $hostname $OS $page_size $architecture");
              $experiment_data[$i]{"hostname"} = $hostname;
              $experiment_data[$i]{"OS"} = $OS;
              $experiment_data[$i]{"page_size"} = $page_size;
              $experiment_data[$i]{"architecture"} = $architecture;
            }
          elsif ($input_line =~ /$start_date_regex/)
            {
              $start_date = $1;
              gp_message ("debugM", $subr_name, "$exp_id => $start_date");
              $experiment_data[$i]{"start_date"} = $start_date;
            }
          elsif ($input_line =~ /$end_experiment_regex/) 
            {
              $end_experiment = $1;
              gp_message ("debugM", $subr_name, "$exp_id => $end_experiment");
              $experiment_data[$i]{"end_experiment"} = $end_experiment;
            }
          elsif ($input_line =~ /$data_collection_duration_regex/) 
            {
              $data_collection_duration = $1;
              gp_message ("debugM", $subr_name, "$exp_id => $data_collection_duration");
              $experiment_data[$i]{"data_collection_duration"} = $data_collection_duration;
            }
#------------------------------------------------------------------------------
#                                       Start Label: Total
#                                          End Label: Total
#                                  Start Time (sec.): 0.000
#                                    End Time (sec.): 1.812
#                                    Duration (sec.): 1.812
#                           Total Thread Time (sec.): 1.812
#                          Average number of Threads: 1.000
# 
#                               Process Times (sec.):
#                                           User CPU: 1.666 ( 91.9%)
#                                         System CPU: 0.090 (  5.0%)
#                                           Trap CPU: 0.    (  0. %)
#                                          User Lock: 0.    (  0. %)
#                                    Data Page Fault: 0.    (  0. %)
#                                    Text Page Fault: 0.    (  0. %)
#                                  Kernel Page Fault: 0.    (  0. %)
#                                            Stopped: 0.    (  0. %)
#                                           Wait CPU: 0.    (  0. %)
#                                              Sleep: 0.056 (  3.1%)
#------------------------------------------------------------------------------
          elsif ($input_line =~ /$total_thread_time_regex/) 
            {
