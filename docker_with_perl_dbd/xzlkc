Otherwise, C<L<use locale|perllocale>> sets the default modifier to C</l>;
and C<L<use feature 'unicode_strings|feature>>, or
C<L<use v5.12|perlfunc/use VERSION>> (or higher) set the default to
C</u> when not in the same scope as either C<L<use locale|perllocale>>
or C<L<use bytes|bytes>>.
(C<L<use locale ':not_characters'|perllocale/Unicode and UTF-8>> also
sets the default to C</u>, overriding any plain C<use locale>.)
Unlike the mechanisms mentioned above, these
affect operations besides regular expressions pattern matching, and so
give more consistent results with other operators, including using
C<\U>, C<\l>, I<etc>. in substitution replacements.

If none of the above apply, for backwards compatibility reasons, the
C</d> modifier is the one in effect by default.  As this can lead to
unexpected results, it is best to specify which other rule set should be
used.

=head4 Character set modifier behavior prior to Perl 5.14

Prior to 5.14, there were no explicit modifiers, but C</l> was implied
for regexes compiled within the scope of C<use locale>, and C</d> was
implied otherwise.  However, interpolating a regex into a larger regex
would ignore the original compilation in favor of whatever was in effect
at the time of the second compilation.  There were a number of
inconsistencies (bugs) with the C</d> modifier, where Unicode rules
would be used when inappropriate, and vice versa.  C<\p{}> did not imply
Unicode rules, and neither did all occurrences of C<\N{}>, until 5.12.

=head2 Regular Expressions

=head3 Quantifiers

Quantifiers are used when a particular portion of a pattern needs to
match a certain number (or numbers) of times.  If there isn't a
quantifier the number of times to match is exactly one.  The following
standard quantifiers are recognized:
X<metacharacter> X<quantifier> X<*> X<+> X<?> X<{n}> X<{n,}> X<{n,m}>

    *           Match 0 or more times
    +           Match 1 or more times
    ?           Match 1 or 0 times
    {n}         Match exactly n times
    {n,}        Match at least n times
    {,n}        Match at most n times
    {n,m}       Match at least n but not more than m times

(If a non-escaped curly bracket occurs in a context other than one of
the quantifiers listed above, where it does not form part of a
backslashed sequence like C<\x{...}>, it is either a fatal syntax error,
or treated as a regular character, generally with a deprecation warning
raised.  To escape it, you can precede it with a backslash (C<"\{">) or
enclose it within square brackets  (C<"[{]">).
This change will allow for future syntax extensions (like making the
lower bound of a quantifier optional), and better error checking of
quantifiers).

The C<"*"> quantifier is equivalent to C<{0,}>, the C<"+">
quantifier to C<{1,}>, and the C<"?"> quantifier to C<{0,1}>.  I<n> and I<m> are limited
to non-negative integral values less than a preset limit defined when perl is built.
This is usually 65534 on the most common platforms.  The actual limit can
be seen in the error message generated by code such as this:

    $_ **= $_ , / {$_} / for 2 .. 42;

By default, a quantified subpattern is "greedy", that is, it will match as
many times as possible (given a particular starting location) while still
allowing the rest of the pattern to match.  If you want it to match the
minimum number of times possible, follow the quantifier with a C<"?">.  Note
that the meanings don't change, just the "greediness":
X<metacharacter> X<greedy> X<greediness>
X<?> X<*?> X<+?> X<??> X<{n}?> X<{n,}?> X<{,n}?> X<{n,m}?>

    *?        Match 0 or more times, not greedily
    +?        Match 1 or more times, not greedily
    ??        Match 0 or 1 time, not greedily
    {n}?      Match exactly n times, not greedily (redundant)
    {n,}?     Match at least n times, not greedily
    {,n}?     Match at most n times, not greedily
    {n,m}?    Match at least n but not more than m times, not greedily

Normally when a quantified subpattern does not allow the rest of the
overall pattern to match, Perl will backtrack. However, this behaviour is
sometimes undesirable. Thus Perl provides the "possessive" quantifier form
as well.

 *+     Match 0 or more times and give nothing back
 ++     Match 1 or more times and give nothing back
 ?+     Match 0 or 1 time and give nothing back
 {n}+   Match exactly n times and give nothing back (redundant)
 {n,}+  Match at least n times and give nothing back
 {,n}+  Match at most n times and give nothing back
 {n,m}+ Match at least n but not more than m times and give nothing back

For instance,

   'aaaa' =~ /a++a/

will never match, as the C<a++> will gobble up all the C<"a">'s in the
string and won't leave any for the remaining part of the pattern. This
feature can be extremely useful to give perl hints about where it
shouldn't backtrack. For instance, the typical "match a double-quoted
string" problem can be most efficiently performed when written as:

   /"(?:[^"\\]++|\\.)*+"/

as we know that if the final quote does not match, backtracking will not
help. See the independent subexpression
C<L</(?E<gt>I<pattern>)>> for more details;
possessive quantifiers are just syntactic sugar for that construct. For
instance the above example could also be written as follows:

   /"(?>(?:(?>[^"\\]+)|\\.)*)"/

Note that the possessive quantifier modifier can not be combined
with the non-greedy modifier. This is because it would make no sense.
Consider the follow equivalency table:

    Illegal         Legal
    ------------    ------
    X??+            X{0}
    X+?+            X{1}
    X{min,max}?+    X{min}

=head3 Escape sequences

Because patterns are processed as double-quoted strings, the following
also work:

 \t          tab                   (HT, TAB)
 \n          newline               (LF, NL)
 \r          return                (CR)
 \f          form feed             (FF)
 \a          alarm (bell)          (BEL)
 \e          escape (think troff)  (ESC)
 \cK         control char          (example: VT)
 \x{}, \x00  character whose ordinal is the given hexadecimal number
 \N{name}    named Unicode character or character sequence
 \N{U+263D}  Unicode character     (example: FIRST QUARTER MOON)
 \o{}, \000  character whose ordinal is the given octal number
 \l          lowercase next char (think vi)
 \u          uppercase next char (think vi)
 \L          lowercase until \E (think vi)
 \U          uppercase until \E (think vi)
 \Q          quote (disable) pattern metacharacters until \E
 \E          end either case modification or quoted section, think vi

Details are in L<perlop/Quote and Quote-like Operators>.

=head3 Character Classes and other Special Escapes

In addition, Perl defines the following:
X<\g> X<\k> X<\K> X<backreference>

 Sequence   Note    Description
  [...]     [1]  Match a character according to the rules of the
                   bracketed character class defined by the "...".
                   Example: [a-z] matches "a" or "b" or "c" ... or "z"
  [[:...:]] [2]  Match a character according to the rules of the POSIX
                   character class "..." within the outer bracketed
                   character class.  Example: [[:upper:]] matches any
                   uppercase character.
  (?[...])  [8]  Extended bracketed character class
  \w        [3]  Match a "word" character (alphanumeric plus "_", plus
                   other connector punctuation chars plus Unicode
                   marks)
  \W        [3]  Match a non-"word" character
  \s        [3]  Match a whitespace character
  \S        [3]  Match a non-whitespace character
  \d        [3]  Match a decimal digit character
  \D        [3]  Match a non-digit character
  \pP       [3]  Match P, named property.  Use \p{Prop} for longer names
  \PP       [3]  Match non-P
  \X        [4]  Match Unicode "eXtended grapheme cluster"
  \1        [5]  Backreference to a specific capture group or buffer.
                   '1' may actually be any positive integer.
  \g1       [5]  Backreference to a specific or previous group,
  \g{-1}    [5]  The number may be negative indicating a relative
                   previous group and may optionally be wrapped in
                   curly brackets for safer parsing.
  \g{name}  [5]  Named backreference
  \k<name>  [5]  Named backreference
  \k'name'  [5]  Named backreference
  \k{name}  [5]  Named backreference
  \K        [6]  Keep the stuff left of the \K, don't include it in $&
  \N        [7]  Any character but \n.  Not affected by /s modifier
  \v        [3]  Vertical whitespace
  \V        [3]  Not vertical whitespace
  \h        [3]  Horizontal whitespace
  \H        [3]  Not horizontal whitespace
  \R        [4]  Linebreak

=over 4

=item [1]

See L<perlrecharclass/Bracketed Character Classes> for details.

=item [2]

See L<perlrecharclass/POSIX Character Classes> for details.

=item [3]

See L<perlunicode/Unicode Character Properties> for details

=item [4]

See L<perlrebackslash/Misc> for details.

=item [5]

See L</Capture groups> below for details.

=item [6]

See L</Extended Patterns> below for details.

=item [7]

Note that C<\N> has two meanings.  When of the form C<\N{I<NAME>}>, it
matches the character or character sequence whose name is I<NAME>; and
similarly
when of the form C<\N{U+I<hex>}>, it matches the character whose Unicode
code point is I<hex>.  Otherwise it matches any character but C<\n>.

=item [8]

See L<perlrecharclass/Extended Bracketed Character Classes> for details.

=back

=head3 Assertions

Besides L<C<"^"> and C<"$">|/Metacharacters>, Perl defines the following
zero-width assertions:
X<zero-width assertion> X<assertion> X<regex, zero-width assertion>
X<regexp, zero-width assertion>
X<regular expression, zero-width assertion>
X<\b> X<\B> X<\A> X<\Z> X<\z> X<\G>

 \b{}   Match at Unicode boundary of specified type
 \B{}   Match where corresponding \b{} doesn't match
 \b     Match a \w\W or \W\w boundary
 \B     Match except at a \w\W or \W\w boundary
 \A     Match only at beginning of string
 \Z     Match only at end of string, or before newline at the end
 \z     Match only at end of string
 \G     Match only at pos() (e.g. at the end-of-match position
        of prior m//g)

A Unicode boundary (C<\b{}>), available starting in v5.22, is a spot
between two characters, or before the first character in the string, or
after the final character in the string where certain criteria defined
by Unicode are met.  See L<perlrebackslash/\b{}, \b, \B{}, \B> for
details.

A word boundary (C<\b>) is a spot between two characters
that has a C<\w> on one side of it and a C<\W> on the other side
of it (in either order), counting the imaginary characters off the
beginning and end of the string as matching a C<\W>.  (Within
character classes C<\b> represents backspace rather than a word
boundary, just as it normally does in any double-quoted string.)
The C<\A> and C<\Z> are just like C<"^"> and C<"$">, except that they
won't match multiple times when the C</m> modifier is used, while
C<"^"> and C<"$"> will match at every internal line boundary.  To match
the actual end of the string and not ignore an optional trailing
newline, use C<\z>.
X<\b> X<\A> X<\Z> X<\z> X</m>

The C<\G> assertion can be used to chain global matches (using
C<m//g>), as described in L<perlop/"Regexp Quote-Like Operators">.
It is also useful when writing C<lex>-like scanners, when you have
several patterns that you want to match against consequent substrings
of your string; see the previous reference.  The actual location
where C<\G> will match can also be influenced by using C<pos()> as
an lvalue: see L<perlfunc/pos>. Note that the rule for zero-length
matches (see L</"Repeated Patterns Matching a Zero-length Substring">)
is modified somewhat, in that contents to the left of C<\G> are
not counted when determining the length of the match. Thus the following
will not match forever:
X<\G>

     my $string = 'ABC';
     pos($string) = 1;
     while ($string =~ /(.\G)/g) {
         print $1;
     }

It will print 'A' and then terminate, as it considers the match to
be zero-width, and thus will not match at the same position twice in a
row.

It is worth noting that C<\G> improperly used can result in an infinite
loop. Take care when using patterns that include C<\G> in an alternation.

Note also that C<s///> will refuse to overwrite part of a substitution
that has already been replaced; so for example this will stop after the
first iteration, rather than iterating its way backwards through the
string:

    $_ = "123456789";
    pos = 6;
    s/.(?=.\G)/X/g;
    print; 	# prints 1234X6789, not XXXXX6789


=head3 Capture groups

The grouping construct C<( ... )> creates capture groups (also referred to as
capture buffers). To refer to the current contents of a group later on, within
the same pattern, use C<\g1> (or C<\g{1}>) for the first, C<\g2> (or C<\g{2}>)
for the second, and so on.
This is called a I<backreference>.
X<regex, capture buffer> X<regexp, capture buffer>
X<regex, capture group> X<regexp, capture group>
X<regular expression, capture buffer> X<backreference>
X<regular expression, capture group> X<backreference>
X<\g{1}> X<\g{-1}> X<\g{name}> X<relative backreference> X<named backreference>
X<named capture buffer> X<regular expression, named capture buffer>
X<named capture group> X<regular expression, named capture group>
X<%+> X<$+{name}> X<< \k<name> >>
There is no limit to the number of captured substrings that you may use.
Groups are numbered with the leftmost open parenthesis being number 1, I<etc>.  If
a group did not match, the associated backreference won't match either. (This
can happen if the group is optional, or in a different branch of an
alternation.)
You can omit the C<"g">, and write C<"\1">, I<etc>, but there are some issues with
this form, described below.

You can also refer to capture groups relatively, by using a negative number, so
that C<\g-1> and C<\g{-1}> both refer to the immediately preceding capture
group, and C<\g-2> and C<\g{-2}> both refer to the group before it.  For
example:

        /
         (Y)            # group 1
         (              # group 2
            (X)         # group 3
            \g{-1}      # backref to group 3
            \g{-3}      # backref to group 1
         )
        /x

would match the same as C</(Y) ( (X) \g3 \g1 )/x>.  This allows you to
interpolate regexes into larger regexes and not have to worry about the
capture groups being renumbered.

You can dispense with numbers altogether and create named capture groups.
The notation is C<(?E<lt>I<name>E<gt>...)> to declare and C<\g{I<name>}> to
reference.  (To be compatible with .Net regular expressions, C<\g{I<name>}> may
also be written as C<\k{I<name>}>, C<\kE<lt>I<name>E<gt>> or C<\k'I<name>'>.)
I<name> must not begin with a number, nor contain hyphens.
When different groups within the same pattern have the same name, any reference
to that name assumes the leftmost defined group.  Named groups count in
absolute and relative numbering, and so can also be referred to by those
numbers.
(It's possible to do things with named capture groups that would otherwise
require C<(??{})>.)

Capture group contents are dynamically scoped and available to you outside the
pattern until the end of the enclosing block or until the next successful
match in the same scope, whichever comes first.
See L<perlsyn/"Compound Statements"> and
L<perlvar/"Scoping Rules of Regex Variables"> for more details.

You can access the contents of a capture group by absolute number (using
C<"$1"> instead of C<"\g1">, I<etc>); or by name via the C<%+> hash,
using C<"$+{I<name>}">.

Braces are required in referring to named capture groups, but are optional for
absolute or relative numbered ones.  Braces are safer when creating a regex by
concatenating smaller strings.  For example if you have C<qr/$x$y/>, and C<$x>
contained C<"\g1">, and C<$y> contained C<"37">, you would get C</\g137/> which
is probably not what you intended.

If you use braces, you may also optionally add any number of blank
(space or tab) characters within but adjacent to the braces, like
S<C<\g{ -1 }>>, or S<C<\k{ I<name> }>>.

The C<\g> and C<\k> notations were introduced in Perl 5.10.0.  Prior to that
there were no named nor relative numbered capture groups.  Absolute numbered
groups were referred to using C<\1>,
C<\2>, I<etc>., and this notation is still
accepted (and likely always will be).  But it leads to some ambiguities if
there are more than 9 capture groups, as C<\10> could mean either the tenth
capture group, or the character whose ordinal in octal is 010 (a backspace in
ASCII).  Perl resolves this ambiguity by interpreting C<\10> as a backreference
only if at least 10 left parentheses have opened before it.  Likewise C<\11> is
a backreference only if at least 11 left parentheses have opened before it.
And so on.  C<\1> through C<\9> are always interpreted as backreferences.
There are several examples below that illustrate these perils.  You can avoid
the ambiguity by always using C<\g{}> or C<\g> if you mean capturing groups;
and for octal constants always using C<\o{}>, or for C<\077> and below, using 3
digits padded with leading zeros, since a leading zero implies an octal
constant.

The C<\I<digit>> notation also works in certain circumstances outside
the pattern.  See L</Warning on \1 Instead of $1> below for details.

Examples:

    s/^([^ ]*) *([^ ]*)/$2 $1/;     # swap first two words

    /(.)\g1/                        # find first doubled char
         and print "'$1' is the first doubled character\n";

    /(?<char>.)\k<char>/            # ... a different way
         and print "'$+{char}' is the first doubled character\n";

    /(?'char'.)\g1/                 # ... mix and match
         and print "'$1' is the first doubled character\n";

    if (/Time: (..):(..):(..)/) {   # parse out values
        $hours = $1;
        $minutes = $2;
        $seconds = $3;
    }

    /(.)(.)(.)(.)(.)(.)(.)(.)(.)\g10/   # \g10 is a backreference
    /(.)(.)(.)(.)(.)(.)(.)(.)(.)\10/    # \10 is octal
    /((.)(.)(.)(.)(.)(.)(.)(.)(.))\10/  # \10 is a backreference
    /((.)(.)(.)(.)(.)(.)(.)(.)(.))\010/ # \010 is octal

    $x = '(.)\1';        # Creates problems when concatenated.
    $y = '(.)\g{1}';     # Avoids the problems.
    "aa" =~ /${x}/;      # True
    "aa" =~ /${y}/;      # True
    "aa0" =~ /${x}0/;    # False!
    "aa0" =~ /${y}0/;    # True
    "aa\x08" =~ /${x}0/;  # True!
    "aa\x08" =~ /${y}0/;  # False

Several special variables also refer back to portions of the previous
match.  C<$+> returns whatever the last bracket match matched.
C<$&> returns the entire matched string.  (At one point C<$0> did
also, but now it returns the name of the program.)  C<$`> returns
everything before the matched string.  C<$'> returns everything
after the matched string. And C<$^N> contains whatever was matched by
the most-recently closed group (submatch). C<$^N> can be used in
extended patterns (see below), for example to assign a submatch to a
variable.
X<$+> X<$^N> X<$&> X<$`> X<$'>

These special variables, like the C<%+> hash and the numbered match variables
(C<$1>, C<$2>, C<$3>, I<etc>.) are dynamically scoped
until the end of the enclosing block or until the next successful
match, whichever comes first.  (See L<perlsyn/"Compound Statements">.)
X<$+> X<$^N> X<$&> X<$`> X<$'>
X<$1> X<$2> X<$3> X<$4> X<$5> X<$6> X<$7> X<$8> X<$9>
X<@{^CAPTURE}>

The C<@{^CAPTURE}> array may be used to access ALL of the capture buffers
as an array without needing to know how many there are. For instance

    $string=~/$pattern/ and @captured = @{^CAPTURE};

will place a copy of each capture variable, C<$1>, C<$2> etc, into the
C<@captured> array.

Be aware that when interpolating a subscript of the C<@{^CAPTURE}>
array you must use demarcated curly brace notation:

    print "${^CAPTURE[0]}";

See L<perldata/"Demarcated variable names using braces"> for more on
this notation.

B<NOTE>: Failed matches in Perl do not reset the match variables,
which makes it easier to write code that tests for a series of more
specific cases and remembers the best match.

B<WARNING>: If your code is to run on Perl 5.16 or earlier,
beware that once Perl sees that you need one of C<$&>, C<$`>, or
C<$'> anywhere in the program, it has to provide them for every
pattern match.  This may substantially slow your program.

Perl uses the same mechanism to produce C<$1>, C<$2>, I<etc>, so you also
pay a price for each pattern that contains capturing parentheses.
(To avoid this cost while retaining the grouping behaviour, use the
extended regular expression C<(?: ... )> instead.)  But if you never
use C<$&>, C<$`> or C<$'>, then patterns I<without> capturing
parentheses will not be penalized.  So avoid C<$&>, C<$'>, and C<$`>
if you can, but if you can't (and some algorithms really appreciate
them), once you've used them once, use them at will, because you've
already paid the price.
X<$&> X<$`> X<$'>

Perl 5.16 introduced a slightly more efficient mechanism that notes
separately whether each of C<$`>, C<$&>, and C<$'> have been seen, and
thus may only need to copy part of the string.  Perl 5.20 introduced a
much more efficient copy-on-write mechanism which eliminates any slowdown.

As another workaround for this problem, Perl 5.10.0 introduced C<${^PREMATCH}>,
C<${^MATCH}> and C<${^POSTMATCH}>, which are equivalent to C<$`>, C<$&>
and C<$'>, B<except> that they are only guaranteed to be defined after a
successful match that was executed with the C</p> (preserve) modifier.
The use of these variables incurs no global performance penalty, unlike
their punctuation character equivalents, however at the trade-off that you
have to tell perl when you want to use them.
X</p> X<p modifier>

=head2 Quoting metacharacters

Backslashed metacharacters in Perl are alphanumeric, such as C<\b>,
C<\w>, C<\n>.  Unlike some other regular expression languages, there
are no backslashed symbols that aren't alphanumeric.  So anything
that looks like C<\\>, C<\(>, C<\)>, C<\[>, C<\]>, C<\{>, or C<\}> is
always
interpreted as a literal character, not a metacharacter.  This was
once used in a common idiom to disable or quote the special meanings
of regular expression metacharacters in a string that you want to
use for a pattern. Simply quote all non-"word" characters:

    $pattern =~ s/(\W)/\\$1/g;

(If C<use locale> is set, then this depends on the current locale.)
Today it is more common to use the C<L<quotemeta()|perlfunc/quotemeta>>
function or the C<\Q> metaquoting escape sequence to disable all
metacharacters' special meanings like this:

    /$unquoted\Q$quoted\E$unquoted/

Beware that if you put literal backslashes (those not inside
interpolated variables) between C<\Q> and C<\E>, double-quotish
backslash interpolation may lead to confusing results.  If you
I<need> to use literal backslashes within C<\Q...\E>,
consult L<perlop/"Gory details of parsing quoted constructs">.

C<quotemeta()> and C<\Q> are fully described in L<perlfunc/quotemeta>.

=head2 Extended Patterns

Perl also defines a consistent extension syntax for features not
found in standard tools like B<awk> and
B<lex>.  The syntax for most of these is a
pair of parentheses with a question mark as the first thing within
the parentheses.  The character after the question mark indicates
the extension.

A question mark was chosen for this and for the minimal-matching
construct because 1) question marks are rare in older regular
expressions, and 2) whenever you see one, you should stop and
"question" exactly what is going on.  That's psychology....

=over 4

=item C<(?#I<text>)>
X<(?#)>

A comment.  The I<text> is ignored.
Note that Perl closes
the comment as soon as it sees a C<")">, so there is no way to put a literal
C<")"> in the comment.  The pattern's closing delimiter must be escaped by
a backslash if it appears in the comment.

See L</E<sol>x> for another way to have comments in patterns.

Note that a comment can go just about anywhere, except in the middle of
an escape sequence.   Examples:

 qr/foo(?#comment)bar/'  # Matches 'foobar'

 # The pattern below matches 'abcd', 'abccd', or 'abcccd'
 qr/abc(?#comment between literal and its quantifier){1,3}d/

 # The pattern below generates a syntax error, because the '\p' must
 # be followed immediately by a '{'.
 qr/\p(?#comment between \p and its property name){Any}/

 # The pattern below generates a syntax error, because the initial
 # '\(' is a literal opening parenthesis, and so there is nothing
 # for the  closing ')' to match
 qr/\(?#the backslash means this isn't a comment)p{Any}/

 # Comments can be used to fold long patterns into multiple lines
 qr/First part of a long regex(?#
   )remaining part/

=item C<(?adlupimnsx-imnsx)>

=item C<(?^alupimnsx)>
X<(?)> X<(?^)>

Zero or more embedded pattern-match modifiers, to be turned on (or
turned off if preceded by C<"-">) for the remainder of the pattern or
the remainder of the enclosing pattern group (if any).

This is particularly useful for dynamically-generated patterns,
such as those read in from a
configuration file, taken from an argument, or specified in a table
somewhere.  Consider the case where some patterns want to be
case-sensitive and some do not:  The case-insensitive ones merely need to
include C<(?i)> at the front of the pattern.  For example:

    $pattern = "foobar";
    if ( /$pattern/i ) { }

    # more flexible:

    $pattern = "(?i)foobar";
    if ( /$pattern/ ) { }

These modifiers are restored at the end of the enclosing group. For example,

    ( (?i) blah ) \s+ \g1

will match C<blah> in any case, some spaces, and an exact (I<including the case>!)
repetition of the previous word, assuming the C</x> modifier, and no C</i>
modifier outside this group.

These modifiers do not carry over into named subpatterns called in the
enclosing group. In other words, a pattern such as C<((?i)(?&I<NAME>))> does not
change the case-sensitivity of the I<NAME> pattern.

A modifier is overridden by later occurrences of this construct in the
same scope containing the same modifier, so that

    /((?im)foo(?-m)bar)/

matches all of C<foobar> case insensitively, but uses C</m> rules for
only the C<foo> portion.  The C<"a"> flag overrides C<aa> as well;
likewise C<aa> overrides C<"a">.  The same goes for C<"x"> and C<xx>.
Hence, in

    /(?-x)foo/xx

both C</x> and C</xx> are turned off during matching C<foo>.  And in

    /(?x)foo/x

C</x> but NOT C</xx> is turned on for matching C<foo>.  (One might
mistakenly think that since the inner C<(?x)> is already in the scope of
C</x>, that the result would effectively be the sum of them, yielding
C</xx>.  It doesn't work that way.)  Similarly, doing something like
C<(?xx-x)foo> turns off all C<"x"> behavior for matching C<foo>, it is not
that you subtract 1 C<"x"> from 2 to get 1 C<"x"> remaining.

Any of these modifiers can be set to apply globally to all regular
expressions compiled within the scope of a C<use re>.  See
L<re/"'/flags' mode">.

Starting in Perl 5.14, a C<"^"> (caret or circumflex accent) immediately
after the C<"?"> is a shorthand equivalent to C<d-imnsx>.  Flags (except
C<"d">) may follow the caret to override it.
But a minus sign is not legal with it.

Note that the C<"a">, C<"d">, C<"l">, C<"p">, and C<"u"> modifiers are special in
that they can only be enabled, not disabled, and the C<"a">, C<"d">, C<"l">, and
C<"u"> modifiers are mutually exclusive: specifying one de-specifies the
others, and a maximum of one (or two C<"a">'s) may appear in the
construct.  Thus, for
example, C<(?-p)> will warn when compiled under C<use warnings>;
C<(?-d:...)> and C<(?dl:...)> are fatal errors.

Note also that the C<"p"> modifier is special in that its presence
anywhere in a pattern has a global effect.

Having zero modifiers makes this a no-op (so why did you specify it,
unless it's generated code), and starting in v5.30, warns under L<C<use
re 'strict'>|re/'strict' mode>.

=item C<(?:I<pattern>)>
X<(?:)>

=item C<(?adluimnsx-imnsx:I<pattern>)>

=item C<(?^aluimnsx:I<pattern>)>
X<(?^:)>

This is for clustering, not capturing; it groups subexpressions like
C<"()">, but doesn't make backreferences as C<"()"> does.  So

    @fields = split(/\b(?:a|b|c)\b/)

matches the same field delimiters as

    @fields = split(/\b(a|b|c)\b/)

but doesn't spit out the delimiters themselves as extra fields (even though
that's the behaviour of L<perlfunc/split> when its pattern contains capturing
groups).  It's also cheaper not to capture
characters if you don't need to.

Any letters between C<"?"> and C<":"> act as flags modifiers as with
C<(?adluimnsx-imnsx)>.  For example,

    /(?s-i:more.*than).*million/i

is equivalent to the more verbose

    /(?:(?s-i)more.*than).*million/i

Note that any C<()> constructs enclosed within this one will still
capture unless the C</n> modifier is in effect.

Like the L</(?adlupimnsx-imnsx)> construct, C<aa> and C<"a"> override each
other, as do C<xx> and C<"x">.  They are not additive.  So, doing
something like C<(?xx-x:foo)> turns off all C<"x"> behavior for matching
C<foo>.

Starting in Perl 5.14, a C<"^"> (caret or circumflex accent) immediately
after the C<"?"> is a shorthand equivalent to C<d-imnsx>.  Any positive
flags (except C<"d">) may follow the caret, so

    (?^x:foo)

is equivalent to

    (?x-imns:foo)

The caret tells Perl that this cluster doesn't inherit the flags of any
surrounding pattern, but uses the system defaults (C<d-imnsx>),
modified by any flags specified.

The caret allows for simpler stringification of compiled regular
expressions.  These look like

    (?^:pattern)

with any non-default flags appearing between the caret and the colon.
A test that looks at such stringification thus doesn't need to have the
system default flags hard-coded in it, just the caret.  If new flags are
added to Perl, the meaning of the caret's expansion will change to include
the default for those flags, so the test will still work, unchanged.

Specifying a negative flag after the caret is an error, as the flag is
redundant.

Mnemonic for C<(?^...)>:  A fresh beginning since the usual use of a caret is
to match at the beginning.

=item C<(?|I<pattern>)>
X<(?|)> X<Branch reset>

This is the "branch reset" pattern, which has the special property
that the capture groups are numbered from the same starting point
in each alternation branch. It is available starting from perl 5.10.0.

Capture groups are numbered from left to right, but inside this
construct the numbering is restarted for each branch.

The numbering within each branch will be as normal, and any groups
following this construct will be numbered as though the construct
contained only one branch, that being the one with the most capture
groups in it.

This construct is useful when you want to capture one of a
number of alternative matches.

Consider the following pattern.  The numbers underneath show in
which group the captured content will be stored.


    # before  ---------------branch-reset----------- after
    / ( a )  (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x
    # 1            2         2  3        2     3     4

Be careful when using the branch reset pattern in combination with
named captures. Named captures are implemented as being aliases to
numbered groups holding the captures, and that interferes with the
implementation of the branch reset pattern. If you are using named
captures in a branch reset pattern, it's best to use the same names,
in the same order, in each of the alternations:

   /(?|  (?<a> x ) (?<b> y )
      |  (?<a> z ) (?<b> w )) /x

Not doing so may lead to surprises:

  "12" =~ /(?| (?<a> \d+ ) | (?<b> \D+))/x;
  say $+{a};    # Prints '12'
  say $+{b};    # *Also* prints '12'.

The problem here is that both the group named C<< a >> and the group
named C<< b >> are aliases for the group belonging to C<< $1 >>.

=item Lookaround Assertions
X<look-around assertion> X<lookaround assertion> X<look-around> X<lookaround>

Lookaround assertions are zero-width patterns which match a specific
pattern without including it in C<$&>. Positive assertions match when
their subpattern matches, negative assertions match when their subpattern
fails. Lookbehind matches text up to the current match position,
lookahead matches text following the current match position.

=over 4

=item C<(?=I<pattern>)>

=item C<(*pla:I<pattern>)>

=item C<(*positive_lookahead:I<pattern>)>
X<(?=)>
X<(*pla>
X<(*positive_lookahead>
X<look-ahead, positive> X<lookahead, positive>

A zero-width positive lookahead assertion.  For example, C</\w+(?=\t)/>
matches a word followed by a tab, without including the tab in C<$&>.

=item C<(?!I<pattern>)>

=item C<(*nla:I<pattern>)>

=item C<(*negative_lookahead:I<pattern>)>
X<(?!)>
X<(*nla>
X<(*negative_lookahead>
X<look-ahead, negative> X<lookahead, negative>

A zero-width negative lookahead assertion.  For example C</foo(?!bar)/>
matches any occurrence of "foo" that isn't followed by "bar".  Note
however that lookahead and lookbehind are NOT the same thing.  You cannot
use this for lookbehind.

If you are looking for a "bar" that isn't preceded by a "foo", C</(?!foo)bar/>
will not do what you want.  That's because the C<(?!foo)> is just saying that
the next thing cannot be "foo"--and it's not, it's a "bar", so "foobar" will
match.  Use lookbehind instead (see below).

=item C<(?<=I<pattern>)>

=item C<\K>

=item C<(*plb:I<pattern>)>

=item C<(*positive_lookbehind:I<pattern>)>
X<(?<=)>
X<(*plb>
X<(*positive_lookbehind>
X<look-behind, positive> X<lookbehind, positive> X<\K>

A zero-width positive lookbehind assertion.  For example, C</(?<=\t)\w+/>
matches a word that follows a tab, without including the tab in C<$&>.

Prior to Perl 5.30, it worked only for fixed-width lookbehind, but
starting in that release, it can handle variable lengths from 1 to 255
characters as an experimental feature.  The feature is enabled
automatically if you use a variable length positive lookbehind assertion.

In Perl 5.35.10 the scope of the experimental nature of this construct
has been reduced, and experimental warnings will only be produced when
the construct contains capturing parenthesis. The warnings will be
raised at pattern compilation time, unless turned off, in the
C<experimental::vlb> category.  This is to warn you that the exact
contents of capturing buffers in a variable length positive lookbehind
is not well defined and is subject to change in a future release of perl.

Currently if you use capture buffers inside of a positive variable length
lookbehind the result will be the longest and thus leftmost match possible.
This means that

    "aax" =~ /(?=x)(?<=(a|aa))/
    "aax" =~ /(?=x)(?<=(aa|a))/
    "aax" =~ /(?=x)(?<=(a{1,2}?)/
    "aax" =~ /(?=x)(?<=(a{1,2})/

will all result in C<$1> containing C<"aa">. It is possible in a future
release of perl we will change this behavior.

There is a special form of this construct, called C<\K>
(available since Perl 5.10.0), which causes the
regex engine to "keep" everything it had matched prior to the C<\K> and
not include it in C<$&>. This effectively provides non-experimental
variable-length lookbehind of any length.

And, there is a technique that can be used to handle variable length
lookbehinds on earlier releases, and longer than 255 characters.  It is
described in
L<http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html>.

Note that under C</i>, a few single characters match two or three other
characters.  This makes them variable length, and the 255 length applies
to the maximum number of characters in the match.  For
example C<qr/\N{LATIN SMALL LETTER SHARP S}/i> matches the sequence
C<"ss">.  Your lookbehind assertion could contain 127 Sharp S
characters under C</i>, but adding a 128th would generate a compilation
error, as that could match 256 C<"s"> characters in a row.

The use of C<\K> inside of another lookaround assertion
is allowed, but the behaviour is currently not well defined.

For various reasons C<\K> may be significantly more efficient than the
equivalent C<< (?<=...) >> construct, and it is especially useful in
situations where you want to efficiently remove something following
something else in a string. For instance

  s/(foo)bar/$1/g;

can be rewritten as the much more efficient

  s/foo\Kbar//g;

Use of the non-greedy modifier C<"?"> may not give you the expected
results if it is within a capturing group within the construct.

=item C<(?<!I<pattern>)>

=item C<(*nlb:I<pattern>)>

=item C<(*negative_lookbehind:I<pattern>)>
X<(?<!)>
X<(*nlb>
X<(*negative_lookbehind>
X<look-behind, negative> X<lookbehind, negative>

A zero-width negative lookbehind assertion.  For example C</(?<!bar)foo/>
matches any occurrence of "foo" that does not follow "bar".

Prior to Perl 5.30, it worked only for fixed-width lookbehind, but
starting in that release, it can handle variable lengths from 1 to 255
characters as an experimental feature.  The feature is enabled
automatically if you use a variable length negative lookbehind assertion.

In Perl 5.35.10 the scope of the experimental nature of this construct
has been reduced, and experimental warnings will only be produced when
the construct contains capturing parentheses. The warnings will be
raised at pattern compilation time, unless turned off, in the
C<experimental::vlb> category.  This is to warn you that the exact
contents of capturing buffers in a variable length negative lookbehind
is not well defined and is subject to change in a future release of perl.

Currently if you use capture buffers inside of a negative variable length
lookbehind the result may not be what you expect, for instance:

    say "axfoo"=~/(?=foo)(?<!(a|ax)(?{ say $1 }))/ ? "y" : "n";

will output the following:

    a
    no

which does not make sense as this should print out "ax" as the "a" does
not line up at the correct place. Another example would be:

    say "yes: '$1-$2'" if "aayfoo"=~/(?=foo)(?<!(a|aa)(a|aa)x)/;

will output the following:

    yes: 'aa-a'

It is possible in a future release of perl we will change this behavior
so both of these examples produced more reasonable output.

Note that we are confident that the construct will match and reject
patterns appropriately, the undefined behavior strictly relates to the
value of the capture buffer during or after matching.

There is a technique that can be used to handle variable length
lookbehind on earlier releases, and longer than 255 characters.  It is
described in
L<http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html>.

Note that under C</i>, a few single characters match two or three other
characters.  This makes them variable length, and the 255 length applies
to the maximum number of characters in the match.  For
example C<qr/\N{LATIN SMALL LETTER SHARP S}/i> matches the sequence
C<"ss">.  Your lookbehind assertion could contain 127 Sharp S
characters under C</i>, but adding a 128th would generate a compilation
error, as that could match 256 C<"s"> characters in a row.

Use of the non-greedy modifier C<"?"> may not give you the expected
results if it is within a capturing group within the construct.

=back

=item C<< (?<I<NAME>>I<pattern>) >>

=item C<(?'I<NAME>'I<pattern>)>
X<< (?<NAME>) >> X<(?'NAME')> X<named capture> X<capture>

A named capture group. Identical in every respect to normal capturing
parentheses C<()> but for the additional fact that the group
can be referred to by name in various regular expression
constructs (like C<\g{I<NAME>}>) and can be accessed by name
after a successful match via C<%+> or C<%->. See L<perlvar>
for more details on the C<%+> and C<%-> hashes.

If multiple distinct capture groups have the same name, then
C<$+{I<NAME>}> will refer to the leftmost defined group in the match.

The forms C<(?'I<NAME>'I<pattern>)> and C<< (?<I<NAME>>I<pattern>) >>
are equivalent.

B<NOTE:> While the notation of this construct is the same as the similar
function in .NET regexes, the behavior is not. In Perl the groups are
numbered sequentially regardless of being named or not. Thus in the
pattern

  /(x)(?<foo>y)(z)/

C<$+{foo}> will be the same as C<$2>, and C<$3> will contain 'z' instead of
the opposite which is what a .NET regex hacker might expect.

Currently I<NAME> is restricted to simple identifiers only.
In other words, it must match C</^[_A-Za-z][_A-Za-z0-9]*\z/> or
its Unicode extension (see L<utf8>),
though it isn't extended by the locale (see L<perllocale>).

B<NOTE:> In order to make things easier for programmers with experience
