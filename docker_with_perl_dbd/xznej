# Convenience.  These map the on/off value to $TRUE/$FALSE to make the code
# easier to read.  For example: "if ($g_verbose)" as opposed to the following:
# "if ($verbose_setting eq "on").
#------------------------------------------------------------------------------
my $g_verbose;
my $g_warnings;
my $g_quiet;

my $g_first_metric; 

my $binutils_version;
my $driver_cmd;
my $tool_name;
my $version_info;

my %g_mapped_cmds = ();

#------------------------------------------------------------------------------
# TBD All warning messages are collected and are accessible through the main
# page.
#------------------------------------------------------------------------------
my @g_warning_messages = ();

#------------------------------------------------------------------------------
# Contains the names that have already been tagged.  This is a global
# structure because otherwise the code would get much more complicated.
#------------------------------------------------------------------------------
my %g_tagged_names = ();

#------------------------------------------------------------------------------
# TBD Remove the use of these structures. No longer used.
#------------------------------------------------------------------------------
my %g_function_tag_id = ();
my $g_context = 5; # Defines the range of scan

my $g_default_setting_lang = "en-US.UTF-8";
my %g_exp_dir_meta_data;

my @g_user_input_errors = ();

my $g_html_credits_line;

my $g_warn_keyword  = "Input warning: ";
my $g_error_keyword = "Input error:   ";

my %g_function_occurrences = ();
my %g_map_function_to_index = ();
my %g_multi_count_function = ();
my %g_function_view_all = ();
my @g_full_function_view_table = ();

my @g_html_experiment_stats = ();

#-------------------------------------------------------------------------------
# These structures contain the information printed in the function views.
#-------------------------------------------------------------------------------
my $g_header_lines;

my @g_html_function_name = ();

#-------------------------------------------------------------------------------
# TBD: This variable may not be needed and replaced by tp_value
my $thresh = 0;
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
# Define the driver command, tool name and version number.
#-------------------------------------------------------------------------------
$driver_cmd       = "gprofng display html";
$tool_name        = "gp-display-html";
#$binutils_version = "2.38.50";
$binutils_version = "2.40.00";
$version_info     = $tool_name . " GNU binutils version " . $binutils_version;

#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
# Define several key data structures.
#-------------------------------------------------------------------------------
my %g_user_settings = 
  (
    output           => { option => "-o" , no_of_arguments => 1, data_type => "path"    , current_value => undef, defined => $FALSE},
    overwrite        => { option => "-O" , no_of_arguments => 1, data_type => "path"    , current_value => undef, defined => $FALSE},
    calltree         => { option => "-ct", no_of_arguments => 1, data_type => "onoff"   , current_value => "off"      , defined => $FALSE},
    func_limit       => { option => "-fl", no_of_arguments => 1, data_type => "pinteger", current_value => 500        , defined => $FALSE},
    highlight_percentage => { option => "-hp", no_of_arguments => 1, data_type => "pfloat"  , current_value => 90.0       , defined => $FALSE},
    threshold_percentage => { option => "-tp", no_of_arguments => 1, data_type => "pfloat"  , current_value => 100.0      , defined => $FALSE},
    default_metrics  => { option => "-dm", no_of_arguments => 1, data_type => "onoff"   , current_value => "off"      , defined => $FALSE},
    ignore_metrics   => { option => "-im", no_of_arguments => 1, data_type => "metric_names", current_value => undef, defined => $FALSE},
    verbose          => { option => "--verbose" , no_of_arguments => 1, data_type => "onoff"  , current_value => "off" , defined => $FALSE},
    warnings         => { option => "--warnings" , no_of_arguments => 1, data_type => "onoff"  , current_value => "on" , defined => $FALSE},
    debug            => { option => "--debug" , no_of_arguments => 1, data_type => "size"  , current_value => "off" , defined => $FALSE},
    quiet            => { option => "--quiet" , no_of_arguments => 1, data_type => "onoff"   , current_value => "off"      , defined => $FALSE},
  );

my %g_debug_size = 
  (
    "on"  => $FALSE,
    "s"   => $FALSE,
    "m"   => $FALSE,
    "l"   => $FALSE,
    "xl"  => $FALSE,
  );

my %local_system_config =
  (
    kernel_name       => "undefined",
    nodename          => "undefined",
    kernel_release    => "undefined",
    kernel_version    => "undefined",
    machine           => "undefined",
    processor         => "undefined",
    hardware_platform => "undefined",
    operating_system  => "undefined",
    hostname_current  => "undefined",
  );

# Note that we use single quotes here, because regular expressions wreak havoc otherwise.

my %g_arch_specific_settings =
  (
    arch_supported  => $FALSE,
    arch            => 'undefined',
    regex           => 'undefined',
    subexp          => 'undefined',
    linksubexp      => 'undefined',
  );

my %g_locale_settings = (
  LANG              => "en_US.UTF-8",
  decimal_separator => "\\.",
  covert_to_dot     => $FALSE
);

#------------------------------------------------------------------------------
# See this page for a nice overview with the colors:
# https://www.w3schools.com/colors/colors_groups.asp
#------------------------------------------------------------------------------

my %g_html_color_scheme = (
  "control_flow"  => "Brown",
  "target_function_name" => "Red",
  "non_target_function_name" => "BlueViolet",
  "background_color_hot" => "PeachPuff",
  "background_color_lukewarm" => "LemonChiffon",
  "link_outside_range" => "Crimson",
  "error_message" => "LightPink",
  "background_color_page" => "White",
#  "background_color_page" => "LightGray",
  "background_selected_sort" => "LightSlateGray",
  "index" => "Lavender",
);

#------------------------------------------------------------------------------
# These are the base names for the HTML files that are generated.
#------------------------------------------------------------------------------
my %g_html_base_file_name = (
  "caller_callee"  => "caller-callee",
  "disassembly" => "dis",
  "experiment_info"  => "experiment-info",
  "function_view"  => "function-view-sorted",
  "index" => "index",
  "source" => "src",
  "warnings" => "warnings",
);

#------------------------------------------------------------------------------
# This is cosmetic, but helps with the scoping of variables.
#------------------------------------------------------------------------------
  main ();

  exit (0);

#------------------------------------------------------------------------------
# This is the driver part of the program.
#------------------------------------------------------------------------------
sub main
{
  my $subr_name = get_my_name ();

#------------------------------------------------------------------------------
# The name of the configuration file.
#------------------------------------------------------------------------------
  my $rc_file_name = ".gp-display-html.rc";

#------------------------------------------------------------------------------
# OS commands executed and search paths.
#------------------------------------------------------------------------------
  my @selected_os_cmds = qw (rm mv cat hostname locale which printenv ls
                             uname readelf mkdir);
  my @search_paths_os_cmds = qw (
    /usr/bin
    /bin
    /usr/local/bin
    /usr/local/sbin
    /usr/sbin
    /sbin
  );

#------------------------------------------------------------------------------
# TBD: Eliminate these.
#------------------------------------------------------------------------------
  my $ARCHIVES_MAP_NAME;
  my $ARCHIVES_MAP_VADDR;

#------------------------------------------------------------------------------
# Local structures (hashes and arrays).
#------------------------------------------------------------------------------
  my @exp_dir_list; # List with experiment directories
  my @metrics_data;

  my %function_address_info = ();
  my $function_address_info_ref; 

  my @function_info = ();
  my $function_info_ref;

  my %function_address_and_index = ();
  my $function_address_and_index_ref;

  my %addressobjtextm = ();
  my $addressobjtextm_ref;

  my %addressobj_index = ();
  my $addressobj_index_ref;

  my %LINUX_vDSO = ();
  my $LINUX_vDSO_ref;

  my %function_view_structure = ();
  my $function_view_structure_ref;

  my %elf_rats = ();
  my $elf_rats_ref;

#------------------------------------------------------------------------------
# Local variables.
#------------------------------------------------------------------------------
  my $abs_path_outputdir; 
  my $archive_dir_not_empty;
  my $base_va_executable; 
  my $executable_name;
  my $exp_dir_list_ref;
  my $found_exp_dir;
  my $ignore_value;
  my $message;
  my $number_of_metrics;
  my $va_executable_in_hex;

  my $failed_command_mappings; 
  my $option_errors;
  my $total_user_errors;

  my $script_pc_metrics; 
  my $dir_check_errors;
  my $consistency_errors;
  my $outputdir;
  my $return_code;

  my $decimal_separator;
  my $convert_to_dot;
  my $architecture_supported;
  my $elf_arch;
  my $elf_support;
  my $home_dir;
  my $elf_loadobjects_found; 

  my $rc_file_paths_ref;
  my @rc_file_paths = ();
  my $rc_file_errors = 0;

  my @sort_fields = ();
  my $summary_metrics;
  my $call_metrics;
  my $user_metrics;
  my $system_metrics;
  my $wall_metrics;
  my $detail_metrics;
  my $detail_metrics_system; 

  my $pretty_dir_list; 

  my %metric_value       = ();
  my %metric_description = ();
  my %metric_description_reversed = ();
  my %metric_found = ();
  my %ignored_metrics = ();

  my $metric_value_ref;
  my $metric_description_ref;
  my $metric_found_ref;
  my $ignored_metrics_ref;

  my @table_execution_stats = ();
  my $table_execution_stats_ref;

  my $html_first_metric_file_ref;
  my $html_first_metric_file;

  my $arch;
  my $subexp;
  my $linksubexp;

  my $setting_for_LANG;
  my $time_percentage_multiplier;
  my $process_all_functions;

  my $selected_archive;

#------------------------------------------------------------------------------
# If no options are given, print the help info and exit.
#------------------------------------------------------------------------------
  if ($#ARGV == -1)
    {
      $ignore_value = print_help_info (); 
      return (0);
    }

#------------------------------------------------------------------------------
# This part is like a preamble.  Before we continue we need to figure out some 
# things that are needed later on.
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Store the absolute path of the command executed.
#------------------------------------------------------------------------------
  my $location_gp_command = $0;

#------------------------------------------------------------------------------
# The very first thing to do is to quickly determine if the user has enabled 
# one of the following options and take action accordingly:
# --version, --verbose, --debug, --quiet
#
# This avoids that there is a gap between the start of the execution and the
# moment the options are parsed, checked, and interpreted.
#
# When parsing the full command line, these options will be more extensively
# checked and also updated in %g_user_settings

# Note that a confirmation message, if any, is printed here and not when the 
# options are parsed and processed.
#------------------------------------------------------------------------------

  $g_verbose  = $g_user_settings{"verbose"}{"current_value"} eq "on" ? $TRUE : $FALSE;
  $g_warnings = $g_user_settings{"warnings"}{"current_value"} eq "on" ? $TRUE : $FALSE;
  $g_quiet    = $g_user_settings{"quiet"}{"current_value"} eq "on" ? $TRUE : $FALSE;

  $ignore_value = early_scan_specific_options ();

#------------------------------------------------------------------------------
# The next subroutine is executed early to ensure the OS commands we need are 
# available.
#
# This subroutine stores the commands and the full path names as an associative
# array called "g_mapped_cmds".  The command is the key and the value is the full 
# path.  For example: ("uname", /usr/bin/uname).
#------------------------------------------------------------------------------
  $failed_command_mappings = check_and_define_cmds (\@selected_os_cmds, \@search_paths_os_cmds);

  if ($failed_command_mappings == 0)
    {
      gp_message ("debug", $subr_name, "verified the OS commands");
    }
  else
    {
      my $msg = "failure in the verification of the OS commands";
      gp_message ("assertion", $subr_name, $msg);
    }

#------------------------------------------------------------------------------
# Get the home directory and the locations for the configuration file on the 
# current system.
#------------------------------------------------------------------------------
  ($home_dir, $rc_file_paths_ref) = get_home_dir_and_rc_path ($rc_file_name);

  @rc_file_paths = @{ $rc_file_paths_ref };
  gp_message ("debug", $subr_name, "the home directory is $home_dir");
  gp_message ("debugXL", $subr_name, "the search path for the rc file is @rc_file_paths");

  $pretty_dir_list = build_pretty_dir_list (\@rc_file_paths);

#------------------------------------------------------------------------------
# Get the ball rolling.  Parse and interpret the configuration file (if any)
# and the command line options.
#
# If either $rc_file_errors or $total_user_errors, or both, are non-zero it
# means a fatal error has occured. In this case, all error messages are 
# printed and execution is terminated.
#
# Note that the verbose, debug, and quiet options can be set in this file.
# It is a deliberate choice to ignore these for now.  The assumption is that
# the user will not be happy if we ignore the command line settings for a
# while.
#------------------------------------------------------------------------------

  gp_message ("debugXL", $subr_name, "processing of the rc file disabled for now");

# Temporarily disabled  print_table_user_settings ("debugXL", "before function process_rc_file");
# Temporarily disabled
# Temporarily disabled  $rc_file_errors = process_rc_file ($rc_file_name, $rc_file_paths_ref);
# Temporarily disabled  
# Temporarily disabled  if ($rc_file_errors != 0)
# Temporarily disabled    {
# Temporarily disabled      $message = "fatal errors in file $rc_file_name encountered";
# Temporarily disabled      gp_message ("debugXL", $subr_name, $message);
# Temporarily disabled    }
# Temporarily disabled
# Temporarily disabled  print_table_user_settings ("debugXL", "after function process_rc_file");

#------------------------------------------------------------------------------
# Get the ball rolling. Parse and interpret the options.  Some first checks
# are performed.
#
# Instead of bailing out on the first user error, we capture all errors, print
# messages and then bail out. This is more user friendly.
#------------------------------------------------------------------------------
  gp_message ("verbose", $subr_name, "Parse the user options");

  $total_user_errors = 0;

  ($option_errors, $found_exp_dir, $exp_dir_list_ref) = parse_and_check_user_options (
                                                          \$#ARGV, 
                                                          \@ARGV);
  $total_user_errors += $option_errors;

#------------------------------------------------------------------------------
# Dynamically load the modules needed.  If a module is not available, print 
# an error message and bail out.
#
# This call replaces the following:
#
# use feature qw (state);
# use List::Util qw (min max);
# use Cwd;
# use File::Basename;
# use File::stat;
# use POSIX;
# use bignum;
#
# Note that this check cannot be done earlier, because in case of a missing 
# module, the man page would not be generated if the code ends prematurely
# in case the --help and --version options are used..
#------------------------------------------------------------------------------
  my ($module_errors_ref, $missing_modules_ref) = handle_module_availability ();
 
  my $module_errors = ${ $module_errors_ref };

  if ($module_errors > 0)
    {
      my $msg;

      my $plural_or_single = ($module_errors > 1) ? "modules are" : "module is";
      my @missing_modules = @{ $missing_modules_ref };

      for my $i (0 .. $#missing_modules)
        {
          $msg = "module $missing_modules[$i] is missing";
          gp_message ("error", $subr_name, $msg);
        }
      
      $msg = $module_errors . " " . $plural_or_single  .
             "missing - execution is terminated";
      gp_message ("abort", $subr_name, $msg);
    }

#------------------------------------------------------------------------------
# The user options have been taken in.  Check for validity and consistency.
#------------------------------------------------------------------------------
  gp_message ("verbose", $subr_name, "Process user options");

  ($option_errors, $ignored_metrics_ref, $outputdir, 
   $time_percentage_multiplier, $process_all_functions,
   $exp_dir_list_ref) = process_user_options ($exp_dir_list_ref);

  @exp_dir_list = @{ $exp_dir_list_ref };
  %ignored_metrics = %{$ignored_metrics_ref};

  $total_user_errors += $option_errors;

#------------------------------------------------------------------------------
# If no option is given for the output directory, pick a default.  Otherwise,
# if the output directory exists, wipe it clean in case the -O option is used.
# If not, flag an error because the -o option does not overwrite an existing
# directory.
#------------------------------------------------------------------------------
  if ($total_user_errors == 0)
    {
      ($option_errors, $outputdir) = set_up_output_directory ();
      $abs_path_outputdir = cwd () . "/" . $outputdir;
      $total_user_errors += $option_errors;
    }

  if ($total_user_errors == 0)
    {
      gp_message ("debug", $subr_name, "the output directory is $outputdir");
    }
  else
    {
#------------------------------------------------------------------------------
# All command line errors and warnings are printed here.
#------------------------------------------------------------------------------
      my $plural_or_single = ($total_user_errors > 1) ? "errors have" : "error has";
      $message  =  $g_error_keyword;
      $message .=  $total_user_errors;
      if ($rc_file_errors > 0)
        {
          $message .=  " additional";
        }
      $message .=  " fatal input $plural_or_single been detected:";
      gp_message ("error", $subr_name, $message);
      for my $key (keys @g_user_input_errors)
        {
          gp_message ("error", $subr_name, "$g_error_keyword  $g_user_input_errors[$key]");
        }
    }

#------------------------------------------------------------------------------
# Bail out in case fatal errors have occurred.
#------------------------------------------------------------------------------
  if ( ($rc_file_errors + $total_user_errors) > 0)
    {
      my $msg = "the current values for the user controllable settings";
      print_user_settings ("debug", $msg);

      gp_message ("abort", $subr_name, "execution terminated");
    }
  else
    {
      my $msg = "after parsing the user options, the final values are";
      print_user_settings ("debug", $msg);

#------------------------------------------------------------------------------
# TBD: Enable once all planned features have been implemented and tested.
#------------------------------------------------------------------------------
# Temporarily disabled      $msg = "the final values for the user controllable settings";
# Temporarily disabled      print_table_user_settings ("verbose", $msg);
    }

#------------------------------------------------------------------------------
# Print a list with the experiment directory names
#------------------------------------------------------------------------------
  $pretty_dir_list = build_pretty_dir_list (\@exp_dir_list);

  my $plural = ($#exp_dir_list > 0) ? "directories are" : "directory is";

  gp_message ("verbose", $subr_name, "The experiment " . $plural . ":");
  gp_message ("verbose", $subr_name, $pretty_dir_list);

#------------------------------------------------------------------------------
# Set up the first entry with the meta data for the experiments.  This field
# contains the absolute paths to the experiment directories.
#------------------------------------------------------------------------------
  for my $exp_dir (@exp_dir_list)
    {
     my ($filename, $directory_path, $ignore_suffix) = fileparse ($exp_dir);
     gp_message ("debug", $subr_name, "exp_dir = $exp_dir"); 
     gp_message ("debug", $subr_name, "filename = $filename"); 
     gp_message ("debug", $subr_name, "directory_path = $directory_path"); 
     $g_exp_dir_meta_data{$filename}{"directory_path"} = $directory_path; 
    }

#------------------------------------------------------------------------------
# Check whether the experiment directories are valid.  If not, it is a fatal
# error.
# Upon successful return, one directory has been selected to be used in the
# remainder.  This is not always the correct thing to do, but is the same as
# the original code.  In due time this should be addressed though.
#------------------------------------------------------------------------------
  ($dir_check_errors, $archive_dir_not_empty, $selected_archive, 
   $elf_rats_ref) = check_validity_exp_dirs ($exp_dir_list_ref);

  if ($dir_check_errors)
    {
      gp_message ("abort", $subr_name, "execution terminated");
    }
  else
    {
      gp_message ("verbose", $subr_name, "The experiment directories have been verified and are valid");
    }

  %elf_rats = %{$elf_rats_ref};

#-------------------------------------------------------------------------------
# Now that we know the map.xml file(s) are present, we can scan these and get
# the required information.  This includes setting the base virtual address.
#-------------------------------------------------------------------------------
  $ignore_value = determine_base_virtual_address ($exp_dir_list_ref);

#------------------------------------------------------------------------------
# Check whether the experiment directories are consistent.
#------------------------------------------------------------------------------
  ($consistency_errors, $executable_name) = verify_consistency_experiments ($exp_dir_list_ref);

  if ($consistency_errors == 0)
    {
      gp_message ("verbose", $subr_name, "The experiment directories are consistent");
    }
  else
    {
      gp_message ("abort", $subr_name, "number of consistency errors detected: $consistency_errors"); 
    }

#------------------------------------------------------------------------------
# The directories are consistent.  We can now set the base virtual address of
# the executable.
#------------------------------------------------------------------------------
  $base_va_executable = $g_exp_dir_meta_data{$selected_archive}{"va_base_in_hex"}; 

  gp_message ("debug", $subr_name, "executable_name    = $executable_name");
  gp_message ("debug", $subr_name, "selected_archive = $selected_archive");
  gp_message ("debug", $subr_name, "base_va_executable = $base_va_executable");

#------------------------------------------------------------------------------
# The $GP_DISPLAY_TEXT tool is critical and has to be available in order 
# to proceed.
# This subroutine only returns a value if the tool can be found."
#------------------------------------------------------------------------------
  $g_path_to_tools = ${ check_availability_tool (\$location_gp_command)};

  $GP_DISPLAY_TEXT = $g_path_to_tools . $GP_DISPLAY_TEXT;

  gp_message ("debug", $subr_name, "updated GP_DISPLAY_TEXT = $GP_DISPLAY_TEXT");

#------------------------------------------------------------------------------
# Check if $GP_DISPLAY_TEXT is executable for user, group, and other.
# If not, print a warning only, since this may not be fatal but could
# potentially lead to issues later on.
#------------------------------------------------------------------------------
  if (not is_file_executable ($GP_DISPLAY_TEXT))
    {
      my $msg = "file $GP_DISPLAY_TEXT is not executable for user, group, and other";
      gp_message ("warning", $subr_name, $msg);
    }

#------------------------------------------------------------------------------
# Find out what the decimal separator is, as set by the user.
#------------------------------------------------------------------------------
  ($return_code, $decimal_separator, $convert_to_dot) = 
                                                determine_decimal_separator ();

  if ($return_code == 0)
    {
      my $txt  = "decimal separator is $decimal_separator " . 
                 "(conversion to dot is " .
                 ($convert_to_dot == $TRUE ? "enabled" : "disabled").")";
      gp_message ("debugXL", $subr_name, $txt);
    }
  else
    {
      my $msg = "the decimal separator cannot be determined - set to $decimal_separator";
      gp_message ("warning", $subr_name, $msg);
    }

#------------------------------------------------------------------------------
# Collect and store the system information.
#------------------------------------------------------------------------------
  gp_message ("verbose", $subr_name, "Collect system information and adapt settings");

  $return_code = get_system_config_info (); 

#------------------------------------------------------------------------------
# The 3 variables below are used in the remainder.
#
# The output from "uname -p" is recommended to be used for the ISA.
#------------------------------------------------------------------------------
  my $hostname_current = $local_system_config{hostname_current};
  my $arch_uname_s     = $local_system_config{kernel_name};
  my $arch_uname       = $local_system_config{processor};

  gp_message ("debug", $subr_name, "set hostname_current = $hostname_current");
  gp_message ("debug", $subr_name, "set arch_uname_s     = $arch_uname_s");
  gp_message ("debug", $subr_name, "set arch_uname       = $arch_uname");

#-------------------------------------------------------------------------------
# This function also sets the values in "g_arch_specific_settings".  This 
# includes several definitions of regular expressions.
#-------------------------------------------------------------------------------
  ($architecture_supported, $elf_arch, $elf_support) = 
                     set_system_specific_variables ($arch_uname, $arch_uname_s);

  gp_message ("debug", $subr_name, "architecture_supported = $architecture_supported");
  gp_message ("debug", $subr_name, "elf_arch               = $elf_arch");
  gp_message ("debug", $subr_name, "elf_support            = ".($elf_arch ? "TRUE" : "FALSE"));

  for my $feature (sort keys %g_arch_specific_settings)
    {
      gp_message ("debug", $subr_name, "g_arch_specific_settings{$feature} = $g_arch_specific_settings{$feature}");
    }

  $arch       = $g_arch_specific_settings{"arch"};
  $subexp     = $g_arch_specific_settings{"subexp"};
  $linksubexp = $g_arch_specific_settings{"linksubexp"};

  $g_locale_settings{"LANG"} =  get_LANG_setting ();

  gp_message ("debugXL", $subr_name, "after get_LANG_setting: LANG = $g_locale_settings{'LANG'}");

#------------------------------------------------------------------------------
# Temporarily reset selected settings since these are not yet implemented.
#------------------------------------------------------------------------------
  $ignore_value = reset_selected_settings ();

#------------------------------------------------------------------------------
# TBD: Revisit. Is this really necessary?
#------------------------------------------------------------------------------

  ($executable_name, $va_executable_in_hex) = check_loadobjects_are_elf ($selected_archive);
  $elf_loadobjects_found = $TRUE;

# TBD: Hack and those ARCHIVES_ names can be eliminated
  $ARCHIVES_MAP_NAME  = $executable_name;
  $ARCHIVES_MAP_VADDR = $va_executable_in_hex;
  gp_message ("debugXL", $subr_name, "hack ARCHIVES_MAP_NAME  = $ARCHIVES_MAP_NAME");
  gp_message ("debugXL", $subr_name, "hack ARCHIVES_MAP_VADDR = $ARCHIVES_MAP_VADDR");

  gp_message ("debugXL", $subr_name, "after call to check_loadobjects_are_elf forced elf_loadobjects_found = $elf_loadobjects_found");
  
  $g_html_credits_line = ${ create_html_credits () };
  gp_message ("debugXL", $subr_name, "g_html_credits_line = $g_html_credits_line");
#------------------------------------------------------------------------------
# Add a "/" to simplify the construction of path names in the remainder.
#
# TBD: Push this into a subroutine(s).
#------------------------------------------------------------------------------
  $outputdir = append_forward_slash ($outputdir);

  gp_message ("debug", $subr_name, "prepared outputdir = $outputdir");

#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
# ******* TBD: e.system not available on Linux!!
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------

##  my $summary_metrics       = 'e.totalcpu';
  $detail_metrics        = 'e.totalcpu';
  $detail_metrics_system = 'e.totalcpu:e.system';
  $call_metrics          = 'a.totalcpu';

  my $cmd_options; 
  my $metrics_cmd;

  my $outfile1      = $outputdir   ."metrics";
  my $outfile2      = $outputdir . "metrictotals";
  my $gp_error_file = $outputdir . $g_gp_error_logfile;

#------------------------------------------------------------------------------
# Execute the $GP_DISPLAY_TEXT tool with the appropriate options.  The goal is
# to get all the output in files $outfile1 and $outfile2.  These are then
# parsed.
#------------------------------------------------------------------------------
  gp_message ("verbose", $subr_name, "Gather the metrics data from the experiments");

  $return_code = get_metrics_data (\@exp_dir_list, $outputdir, $outfile1, $outfile2, $gp_error_file);

  if ($return_code != 0)
    {
      gp_message ("abort", $subr_name, "execution terminated");
    }

#------------------------------------------------------------------------------
# TBD: Test this code
#------------------------------------------------------------------------------
  open (METRICS, "<", $outfile1) 
    or die ("$subr_name - unable to open metric value data file $outfile1 for reading: '$!'");
  gp_message ("debug", $subr_name, "opened file $outfile1 for reading");

  chomp (@metrics_data = <METRICS>);
  close (METRICS);

  for my $i (keys @metrics_data)
    {
      gp_message ("debugXL", $subr_name, "metrics_data[$i] = $metrics_data[$i]");
    }

#------------------------------------------------------------------------------
# Process the generated metrics data.
#------------------------------------------------------------------------------
  if ($g_user_settings{"default_metrics"}{"current_value"} eq "off")

#------------------------------------------------------------------------------
# The metrics will be derived from the experiments.
#------------------------------------------------------------------------------
    {
      gp_message ("verbose", $subr_name, "Process the metrics data");

      ($metric_value_ref, $metric_description_ref, $metric_found_ref, 
       $user_metrics, $system_metrics, $wall_metrics,
       $summary_metrics, $detail_metrics, $detail_metrics_system, $call_metrics
       ) = process_metrics_data ($outfile1, $outfile2, \%ignored_metrics);

      %metric_value                = %{ $metric_value_ref };
      %metric_description          = %{ $metric_description_ref };
      %metric_found                = %{ $metric_found_ref };
      %metric_description_reversed = reverse %metric_description;

      gp_message ("debugXL", $subr_name, "after the call to process_metrics_data");
      for my $metric (sort keys %metric_value)
        {
          gp_message ("debugXL", $subr_name, "metric_value{$metric} = $metric_value{$metric}");
        }
      for my $metric (sort keys %metric_description)
        {
          gp_message ("debugXL", $subr_name, "metric_description{$metric} = $metric_description{$metric}");
        }
      gp_message ("debugXL", $subr_name, "user_metrics   = $user_metrics");
      gp_message ("debugXL", $subr_name, "system_metrics = $system_metrics");
      gp_message ("debugXL", $subr_name, "wall_metrics   = $wall_metrics");
    }
  else
    {
#------------------------------------------------------------------------------
# A default set of metrics will be used.
#
# TBD: These should be OS dependent.
#------------------------------------------------------------------------------
      gp_message ("verbose", $subr_name, "Select the set of default metrics"); 

      ($metric_description_ref, $metric_found_ref, $summary_metrics, 
       $detail_metrics, $detail_metrics_system, $call_metrics
       ) = set_default_metrics ($outfile1, \%ignored_metrics);


      %metric_description          = %{ $metric_description_ref };
      %metric_found                = %{ $metric_found_ref };
      %metric_description_reversed = reverse %metric_description;

      gp_message ("debug", $subr_name, "after the call to set_default_metrics");

    }

  $number_of_metrics = split (":", $summary_metrics);

  gp_message ("debugXL", $subr_name, "summary_metrics       = $summary_metrics");
  gp_message ("debugXL", $subr_name, "detail_metrics        = $detail_metrics");
  gp_message ("debugXL", $subr_name, "detail_metrics_system = $detail_metrics_system");
  gp_message ("debugXL", $subr_name, "call_metrics          = $call_metrics");
  gp_message ("debugXL", $subr_name, "number_of_metrics = $number_of_metrics");

#------------------------------------------------------------------------------
# TBD Find a way to better handle this situation:
#------------------------------------------------------------------------------
  for my $im (keys %metric_found)
    {
      gp_message ("debugXL", $subr_name, "metric_found{$im} = $metric_found{$im}");
    }
  for my $im (keys %ignored_metrics)
    {
      if (not exists ($metric_found{$im}))
        {
          gp_message ("debugXL", $subr_name, "user requested ignored metric (-im) $im does not exist in collected metrics");
        }
    }

#------------------------------------------------------------------------------
# Get the information on the experiments.
#------------------------------------------------------------------------------
  gp_message ("verbose", $subr_name, "Generate the experiment information");
  
  my $exp_info_file_ref;
  my $exp_info_file;
  my $exp_info_ref;
  my @exp_info;

  my $experiment_data_ref;

  $experiment_data_ref = get_experiment_info (\$outputdir, \@exp_dir_list);
  my @experiment_data = @{ $experiment_data_ref };

  for my $i (sort keys @experiment_data)
    {
      my $msg = "i = $i " . $experiment_data[$i]{"exp_id"} . " => " . 
                $experiment_data[$i]{"exp_name_full"};
      gp_message ("debugM", $subr_name, $msg);
    }

  $experiment_data_ref = process_experiment_info ($experiment_data_ref);
  @experiment_data = @{ $experiment_data_ref };

  for my $i (sort keys @experiment_data)
    {
      for my $fields (sort keys %{ $experiment_data[$i] })
        {
          my $msg = "i = $i experiment_data[$i]{$fields} = " .
                    $experiment_data[$i]{$fields};
          gp_message ("debugXL", $subr_name, $msg);
        }
    }

  @g_html_experiment_stats = @{ create_exp_info (
                                  \@exp_dir_list,
                                  \@experiment_data) };

  $table_execution_stats_ref = html_generate_exp_summary (
                                 \$outputdir, 
                                 \@experiment_data);
  @table_execution_stats = @{ $table_execution_stats_ref };

#------------------------------------------------------------------------------
# Get the function overview.
#------------------------------------------------------------------------------
  gp_message ("verbose", $subr_name, "Generate the list with functions executed");

  my ($outfile, $sort_fields_ref) = get_hot_functions (\@exp_dir_list, $summary_metrics, $outputdir);

  @sort_fields = @{$sort_fields_ref};

#------------------------------------------------------------------------------
# Parse the output from the fsummary command and store the relevant data for
# all the functions listed there.
#------------------------------------------------------------------------------

  gp_message ("verbose", $subr_name, "Analyze and store the relevant function information");

  ($function_info_ref, $function_address_and_index_ref, $addressobjtextm_ref, 
   $LINUX_vDSO_ref, $function_view_structure_ref) = get_function_info ($outfile);

  @function_info              = @{ $function_info_ref };
  %function_address_and_index = %{ $function_address_and_index_ref };
  %addressobjtextm            = %{ $addressobjtextm_ref };
  %LINUX_vDSO                 = %{ $LINUX_vDSO_ref };
  %function_view_structure    = %{ $function_view_structure_ref };

  for my $keys (0 .. $#function_info)
    {
      for my $fields (keys %{$function_info[$keys]})
        {
          gp_message ("debugXL", $subr_name,"$keys $fields $function_info[$keys]{$fields}");
        }
    }

  for my $i (keys %addressobjtextm)
    {
      gp_message ("debugXL", $subr_name,"addressobjtextm{$i} = $addressobjtextm{$i}");
    }

  gp_message ("verbose", $subr_name, "Generate the files with function overviews and the callers-callees information"); 

  $script_pc_metrics = generate_function_level_info (\@exp_dir_list, 
                                                     $call_metrics, 
                                                     $summary_metrics, 
                                                     $outputdir, 
                                                     $sort_fields_ref);

  gp_message ("verbose", $subr_name, "Preprocess the files with the function level information");

  $ignore_value = preprocess_function_files (
                    $metric_description_ref, 
                    $script_pc_metrics, 
                    $outputdir, 
                    \@sort_fields);

  gp_message ("verbose", $subr_name, "For each function, generate a set of files");

  ($function_info_ref, $function_address_info_ref, $addressobj_index_ref) = process_function_files (
                                                                            \@exp_dir_list,
                                                                            $executable_name,
                                                                            $time_percentage_multiplier,
                                                                            $summary_metrics,
                                                                            $process_all_functions,
                                                                            $elf_loadobjects_found, 
                                                                            $outputdir, 
                                                                            \@sort_fields, 
                                                                            \@function_info, 
                                                                            \%function_address_and_index,
                                                                            \%LINUX_vDSO,
                                                                            \%metric_description,
                                                                            $elf_arch,
                                                                            $base_va_executable,
                                                                            $ARCHIVES_MAP_NAME, $ARCHIVES_MAP_VADDR, \%elf_rats);

  @function_info         = @{ $function_info_ref };
  %function_address_info = %{ $function_address_info_ref };
  %addressobj_index      = %{ $addressobj_index_ref };

#-------------------------------------------------------------------------------------
# Parse the disassembly information and generate the html files.
#-------------------------------------------------------------------------------------
  gp_message ("verbose", $subr_name, "Parse the disassembly files and generate the html files");

  $ignore_value = parse_dis_files (\$number_of_metrics, \@function_info, 
                   \%function_address_and_index,
                   \$outputdir, \%addressobj_index);

#-------------------------------------------------------------------------------------
# Parse the source information and generate the html files.
#-------------------------------------------------------------------------------------
  gp_message ("verbose", $subr_name, "Parse the source files and generate the html files");

  parse_source_files (\$number_of_metrics, \@function_info, \$outputdir);

#-------------------------------------------------------------------------------------
# Parse the caller-callee information and generate the html files.
#-------------------------------------------------------------------------------------
  gp_message ("verbose", $subr_name, "Process the caller-callee information and generate the html file");

#-------------------------------------------------------------------------------------
# Generate the caller-callee information.
#-------------------------------------------------------------------------------------
  $ignore_value = generate_caller_callee (
