#define case_70_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 69
#define case_69_SBOX32(hash,state,key) _SBOX32_CASE(69,hash,state,key)
#else
#define case_69_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 68
#define case_68_SBOX32(hash,state,key) _SBOX32_CASE(68,hash,state,key)
#else
#define case_68_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 67
#define case_67_SBOX32(hash,state,key) _SBOX32_CASE(67,hash,state,key)
#else
#define case_67_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 66
#define case_66_SBOX32(hash,state,key) _SBOX32_CASE(66,hash,state,key)
#else
#define case_66_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 65
#define case_65_SBOX32(hash,state,key) _SBOX32_CASE(65,hash,state,key)
#else
#define case_65_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 64
#define case_64_SBOX32(hash,state,key) _SBOX32_CASE(64,hash,state,key)
#else
#define case_64_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 63
#define case_63_SBOX32(hash,state,key) _SBOX32_CASE(63,hash,state,key)
#else
#define case_63_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 62
#define case_62_SBOX32(hash,state,key) _SBOX32_CASE(62,hash,state,key)
#else
#define case_62_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 61
#define case_61_SBOX32(hash,state,key) _SBOX32_CASE(61,hash,state,key)
#else
#define case_61_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 60
#define case_60_SBOX32(hash,state,key) _SBOX32_CASE(60,hash,state,key)
#else
#define case_60_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 59
#define case_59_SBOX32(hash,state,key) _SBOX32_CASE(59,hash,state,key)
#else
#define case_59_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 58
#define case_58_SBOX32(hash,state,key) _SBOX32_CASE(58,hash,state,key)
#else
#define case_58_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 57
#define case_57_SBOX32(hash,state,key) _SBOX32_CASE(57,hash,state,key)
#else
#define case_57_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 56
#define case_56_SBOX32(hash,state,key) _SBOX32_CASE(56,hash,state,key)
#else
#define case_56_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 55
#define case_55_SBOX32(hash,state,key) _SBOX32_CASE(55,hash,state,key)
#else
#define case_55_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 54
#define case_54_SBOX32(hash,state,key) _SBOX32_CASE(54,hash,state,key)
#else
#define case_54_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 53
#define case_53_SBOX32(hash,state,key) _SBOX32_CASE(53,hash,state,key)
#else
#define case_53_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 52
#define case_52_SBOX32(hash,state,key) _SBOX32_CASE(52,hash,state,key)
#else
#define case_52_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 51
#define case_51_SBOX32(hash,state,key) _SBOX32_CASE(51,hash,state,key)
#else
#define case_51_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 50
#define case_50_SBOX32(hash,state,key) _SBOX32_CASE(50,hash,state,key)
#else
#define case_50_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 49
#define case_49_SBOX32(hash,state,key) _SBOX32_CASE(49,hash,state,key)
#else
#define case_49_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 48
#define case_48_SBOX32(hash,state,key) _SBOX32_CASE(48,hash,state,key)
#else
#define case_48_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 47
#define case_47_SBOX32(hash,state,key) _SBOX32_CASE(47,hash,state,key)
#else
#define case_47_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 46
#define case_46_SBOX32(hash,state,key) _SBOX32_CASE(46,hash,state,key)
#else
#define case_46_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 45
#define case_45_SBOX32(hash,state,key) _SBOX32_CASE(45,hash,state,key)
#else
#define case_45_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 44
#define case_44_SBOX32(hash,state,key) _SBOX32_CASE(44,hash,state,key)
#else
#define case_44_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 43
#define case_43_SBOX32(hash,state,key) _SBOX32_CASE(43,hash,state,key)
#else
#define case_43_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 42
#define case_42_SBOX32(hash,state,key) _SBOX32_CASE(42,hash,state,key)
#else
#define case_42_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 41
#define case_41_SBOX32(hash,state,key) _SBOX32_CASE(41,hash,state,key)
#else
#define case_41_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 40
#define case_40_SBOX32(hash,state,key) _SBOX32_CASE(40,hash,state,key)
#else
#define case_40_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 39
#define case_39_SBOX32(hash,state,key) _SBOX32_CASE(39,hash,state,key)
#else
#define case_39_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 38
#define case_38_SBOX32(hash,state,key) _SBOX32_CASE(38,hash,state,key)
#else
#define case_38_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 37
#define case_37_SBOX32(hash,state,key) _SBOX32_CASE(37,hash,state,key)
#else
#define case_37_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 36
#define case_36_SBOX32(hash,state,key) _SBOX32_CASE(36,hash,state,key)
#else
#define case_36_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 35
#define case_35_SBOX32(hash,state,key) _SBOX32_CASE(35,hash,state,key)
#else
#define case_35_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 34
#define case_34_SBOX32(hash,state,key) _SBOX32_CASE(34,hash,state,key)
#else
#define case_34_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 33
#define case_33_SBOX32(hash,state,key) _SBOX32_CASE(33,hash,state,key)
#else
#define case_33_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 32
#define case_32_SBOX32(hash,state,key) _SBOX32_CASE(32,hash,state,key)
#else
#define case_32_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 31
#define case_31_SBOX32(hash,state,key) _SBOX32_CASE(31,hash,state,key)
#else
#define case_31_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 30
#define case_30_SBOX32(hash,state,key) _SBOX32_CASE(30,hash,state,key)
#else
#define case_30_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 29
#define case_29_SBOX32(hash,state,key) _SBOX32_CASE(29,hash,state,key)
#else
#define case_29_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 28
#define case_28_SBOX32(hash,state,key) _SBOX32_CASE(28,hash,state,key)
#else
#define case_28_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 27
#define case_27_SBOX32(hash,state,key) _SBOX32_CASE(27,hash,state,key)
#else
#define case_27_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 26
#define case_26_SBOX32(hash,state,key) _SBOX32_CASE(26,hash,state,key)
#else
#define case_26_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 25
#define case_25_SBOX32(hash,state,key) _SBOX32_CASE(25,hash,state,key)
#else
#define case_25_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 24
#define case_24_SBOX32(hash,state,key) _SBOX32_CASE(24,hash,state,key)
#else
#define case_24_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 23
#define case_23_SBOX32(hash,state,key) _SBOX32_CASE(23,hash,state,key)
#else
#define case_23_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 22
#define case_22_SBOX32(hash,state,key) _SBOX32_CASE(22,hash,state,key)
#else
#define case_22_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 21
#define case_21_SBOX32(hash,state,key) _SBOX32_CASE(21,hash,state,key)
#else
#define case_21_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 20
#define case_20_SBOX32(hash,state,key) _SBOX32_CASE(20,hash,state,key)
#else
#define case_20_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 19
#define case_19_SBOX32(hash,state,key) _SBOX32_CASE(19,hash,state,key)
#else
#define case_19_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 18
#define case_18_SBOX32(hash,state,key) _SBOX32_CASE(18,hash,state,key)
#else
#define case_18_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 17
#define case_17_SBOX32(hash,state,key) _SBOX32_CASE(17,hash,state,key)
#else
#define case_17_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 16
#define case_16_SBOX32(hash,state,key) _SBOX32_CASE(16,hash,state,key)
#else
#define case_16_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 15
#define case_15_SBOX32(hash,state,key) _SBOX32_CASE(15,hash,state,key)
#else
#define case_15_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 14
#define case_14_SBOX32(hash,state,key) _SBOX32_CASE(14,hash,state,key)
#else
#define case_14_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 13
#define case_13_SBOX32(hash,state,key) _SBOX32_CASE(13,hash,state,key)
#else
#define case_13_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 12
#define case_12_SBOX32(hash,state,key) _SBOX32_CASE(12,hash,state,key)
#else
#define case_12_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 11
#define case_11_SBOX32(hash,state,key) _SBOX32_CASE(11,hash,state,key)
#else
#define case_11_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 10
#define case_10_SBOX32(hash,state,key) _SBOX32_CASE(10,hash,state,key)
#else
#define case_10_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 9
#define case_9_SBOX32(hash,state,key) _SBOX32_CASE(9,hash,state,key)
#else
#define case_9_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 8
#define case_8_SBOX32(hash,state,key) _SBOX32_CASE(8,hash,state,key)
#else
#define case_8_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 7
#define case_7_SBOX32(hash,state,key) _SBOX32_CASE(7,hash,state,key)
#else
#define case_7_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 6
#define case_6_SBOX32(hash,state,key) _SBOX32_CASE(6,hash,state,key)
#else
#define case_6_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 5
#define case_5_SBOX32(hash,state,key) _SBOX32_CASE(5,hash,state,key)
#else
#define case_5_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 4
#define case_4_SBOX32(hash,state,key) _SBOX32_CASE(4,hash,state,key)
#else
#define case_4_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 3
#define case_3_SBOX32(hash,state,key) _SBOX32_CASE(3,hash,state,key)
#else
#define case_3_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 2
#define case_2_SBOX32(hash,state,key) _SBOX32_CASE(2,hash,state,key)
#else
#define case_2_SBOX32(hash,state,key) /**/
#endif
#if SBOX32_MAX_LEN >= 1
#define case_1_SBOX32(hash,state,key) _SBOX32_CASE(1,hash,state,key)
#else
#define case_1_SBOX32(hash,state,key) /**/
#endif

#define XORSHIFT128_set(r,x,y,z,w,t) STMT_START {       \
    t = ( x ^ ( x << 5 ) );                             \
    x = y; y = z; z = w;                                \
    r = w = ( w ^ ( w >> 29 ) ) ^ ( t ^ ( t >> 12 ) );  \
} STMT_END

#ifndef SBOX32_CHURN_ROUNDS 
#define SBOX32_CHURN_ROUNDS 128
#endif

#define _SBOX32_CASE(len,hash,state,key) \
    /* FALLTHROUGH */ \
    case len: hash ^= state[ 1 + ( 256 * ( len - 1 ) ) + key[ len - 1 ] ];


SBOX32_STATIC_INLINE void sbox32_seed_state128 (
    const U8 *seed_ch,
    U8 *state_ch
) {
    U32 *seed= (U32 *)seed_ch;
    U32 *state= (U32 *)state_ch;
    U32 *state_cursor = state + 1;
    U32 *sbox32_end = state + 1 + (256 * SBOX32_MAX_LEN);
    U32 s0 = seed[1] ^ 0x786f6273; /* sbox */
    U32 s1 = seed[0] ^ 0x68736168; /* hash */
    U32 s2 = seed[2] ^ 0x646f6f67; /* good */
    U32 s3 = seed[3] ^ 0x74736166; /* fast */
    U32 t1,t2,i;

    /* make sure we have all non-zero state elements */
    if (!s0) s0 = 1;
    if (!s1) s1 = 2;
    if (!s2) s2 = 4;
    if (!s3) s3 = 8;

    /* Do a bunch of mix rounds to avalanche the seedbits
     * before we use them for the XORSHIFT rng. */
    for ( i = 0; i < SBOX32_CHURN_ROUNDS; i++ )
        SBOX32_MIX4(s0,s1,s2,s3,"SEED STATE");

    s0 ^= ~seed[3];
    s1 ^= ~seed[2];
    s2 ^= ~seed[1];
    s3 ^= ~seed[0];

    /* make sure we have all non-zero state elements, again */
    if (!s0) s0 = 8;
    if (!s1) s1 = 4;
    if (!s2) s2 = 2;
    if (!s3) s3 = 1;
    
    for ( i = 0; i < SBOX32_CHURN_ROUNDS; i++ )
        SBOX32_MIX4(s0,s1,s2,s3,"SEED STATE");

    while ( state_cursor < sbox32_end ) {
        U32 *row_end = state_cursor + 256; 
        for ( ; state_cursor < row_end; state_cursor++ ) {
            XORSHIFT128_set(*state_cursor,s0,s1,s2,s3,t1);
        }
    }
    XORSHIFT128_set(*state,s0,s1,s2,s3,t2);
}

SBOX32_STATIC_INLINE U32 sbox32_hash_with_state(
    const U8 *state_ch,
    const U8 *key,
    const STRLEN key_len
) {
    U32 *state= (U32 *)state_ch;
    U32 hash = *state;
    switch (key_len) {
        default: return zaphod32_hash_with_state(state_ch, key, key_len);
        case_256_SBOX32(hash,state,key)
        case_255_SBOX32(hash,state,key)
        case_254_SBOX32(hash,state,key)
        case_253_SBOX32(hash,state,key)
        case_252_SBOX32(hash,state,key)
        case_251_SBOX32(hash,state,key)
        case_250_SBOX32(hash,state,key)
        case_249_SBOX32(hash,state,key)
        case_248_SBOX32(hash,state,key)
        case_247_SBOX32(hash,state,key)
        case_246_SBOX32(hash,state,key)
        case_245_SBOX32(hash,state,key)
        case_244_SBOX32(hash,state,key)
        case_243_SBOX32(hash,state,key)
        case_242_SBOX32(hash,state,key)
        case_241_SBOX32(hash,state,key)
        case_240_SBOX32(hash,state,key)
        case_239_SBOX32(hash,state,key)
        case_238_SBOX32(hash,state,key)
        case_237_SBOX32(hash,state,key)
        case_236_SBOX32(hash,state,key)
        case_235_SBOX32(hash,state,key)
        case_234_SBOX32(hash,state,key)
        case_233_SBOX32(hash,state,key)
        case_232_SBOX32(hash,state,key)
        case_231_SBOX32(hash,state,key)
        case_230_SBOX32(hash,state,key)
        case_229_SBOX32(hash,state,key)
        case_228_SBOX32(hash,state,key)
        case_227_SBOX32(hash,state,key)
        case_226_SBOX32(hash,state,key)
        case_225_SBOX32(hash,state,key)
        case_224_SBOX32(hash,state,key)
        case_223_SBOX32(hash,state,key)
        case_222_SBOX32(hash,state,key)
        case_221_SBOX32(hash,state,key)
        case_220_SBOX32(hash,state,key)
        case_219_SBOX32(hash,state,key)
        case_218_SBOX32(hash,state,key)
        case_217_SBOX32(hash,state,key)
        case_216_SBOX32(hash,state,key)
        case_215_SBOX32(hash,state,key)
        case_214_SBOX32(hash,state,key)
        case_213_SBOX32(hash,state,key)
        case_212_SBOX32(hash,state,key)
        case_211_SBOX32(hash,state,key)
        case_210_SBOX32(hash,state,key)
        case_209_SBOX32(hash,state,key)
        case_208_SBOX32(hash,state,key)
        case_207_SBOX32(hash,state,key)
        case_206_SBOX32(hash,state,key)
        case_205_SBOX32(hash,state,key)
        case_204_SBOX32(hash,state,key)
        case_203_SBOX32(hash,state,key)
        case_202_SBOX32(hash,state,key)
        case_201_SBOX32(hash,state,key)
        case_200_SBOX32(hash,state,key)
        case_199_SBOX32(hash,state,key)
        case_198_SBOX32(hash,state,key)
        case_197_SBOX32(hash,state,key)
        case_196_SBOX32(hash,state,key)
        case_195_SBOX32(hash,state,key)
        case_194_SBOX32(hash,state,key)
        case_193_SBOX32(hash,state,key)
        case_192_SBOX32(hash,state,key)
        case_191_SBOX32(hash,state,key)
        case_190_SBOX32(hash,state,key)
        case_189_SBOX32(hash,state,key)
        case_188_SBOX32(hash,state,key)
        case_187_SBOX32(hash,state,key)
        case_186_SBOX32(hash,state,key)
        case_185_SBOX32(hash,state,key)
        case_184_SBOX32(hash,state,key)
        case_183_SBOX32(hash,state,key)
        case_182_SBOX32(hash,state,key)
        case_181_SBOX32(hash,state,key)
        case_180_SBOX32(hash,state,key)
        case_179_SBOX32(hash,state,key)
        case_178_SBOX32(hash,state,key)
        case_177_SBOX32(hash,state,key)
        case_176_SBOX32(hash,state,key)
        case_175_SBOX32(hash,state,key)
        case_174_SBOX32(hash,state,key)
        case_173_SBOX32(hash,state,key)
        case_172_SBOX32(hash,state,key)
        case_171_SBOX32(hash,state,key)
        case_170_SBOX32(hash,state,key)
        case_169_SBOX32(hash,state,key)
        case_168_SBOX32(hash,state,key)
        case_167_SBOX32(hash,state,key)
        case_166_SBOX32(hash,state,key)
        case_165_SBOX32(hash,state,key)
        case_164_SBOX32(hash,state,key)
        case_163_SBOX32(hash,state,key)
        case_162_SBOX32(hash,state,key)
        case_161_SBOX32(hash,state,key)
        case_160_SBOX32(hash,state,key)
        case_159_SBOX32(hash,state,key)
        case_158_SBOX32(hash,state,key)
        case_157_SBOX32(hash,state,key)
        case_156_SBOX32(hash,state,key)
        case_155_SBOX32(hash,state,key)
        case_154_SBOX32(hash,state,key)
        case_153_SBOX32(hash,state,key)
        case_152_SBOX32(hash,state,key)
        case_151_SBOX32(hash,state,key)
        case_150_SBOX32(hash,state,key)
        case_149_SBOX32(hash,state,key)
        case_148_SBOX32(hash,state,key)
        case_147_SBOX32(hash,state,key)
        case_146_SBOX32(hash,state,key)
        case_145_SBOX32(hash,state,key)
        case_144_SBOX32(hash,state,key)
        case_143_SBOX32(hash,state,key)
        case_142_SBOX32(hash,state,key)
        case_141_SBOX32(hash,state,key)
        case_140_SBOX32(hash,state,key)
        case_139_SBOX32(hash,state,key)
        case_138_SBOX32(hash,state,key)
        case_137_SBOX32(hash,state,key)
        case_136_SBOX32(hash,state,key)
        case_135_SBOX32(hash,state,key)
        case_134_SBOX32(hash,state,key)
        case_133_SBOX32(hash,state,key)
        case_132_SBOX32(hash,state,key)
        case_131_SBOX32(hash,state,key)
        case_130_SBOX32(hash,state,key)
        case_129_SBOX32(hash,state,key)
        case_128_SBOX32(hash,state,key)
        case_127_SBOX32(hash,state,key)
        case_126_SBOX32(hash,state,key)
        case_125_SBOX32(hash,state,key)
        case_124_SBOX32(hash,state,key)
        case_123_SBOX32(hash,state,key)
        case_122_SBOX32(hash,state,key)
        case_121_SBOX32(hash,state,key)
        case_120_SBOX32(hash,state,key)
        case_119_SBOX32(hash,state,key)
        case_118_SBOX32(hash,state,key)
        case_117_SBOX32(hash,state,key)
        case_116_SBOX32(hash,state,key)
        case_115_SBOX32(hash,state,key)
        case_114_SBOX32(hash,state,key)
        case_113_SBOX32(hash,state,key)
        case_112_SBOX32(hash,state,key)
        case_111_SBOX32(hash,state,key)
        case_110_SBOX32(hash,state,key)
        case_109_SBOX32(hash,state,key)
        case_108_SBOX32(hash,state,key)
        case_107_SBOX32(hash,state,key)
        case_106_SBOX32(hash,state,key)
        case_105_SBOX32(hash,state,key)
        case_104_SBOX32(hash,state,key)
        case_103_SBOX32(hash,state,key)
        case_102_SBOX32(hash,state,key)
        case_101_SBOX32(hash,state,key)
        case_100_SBOX32(hash,state,key)
        case_99_SBOX32(hash,state,key)
        case_98_SBOX32(hash,state,key)
        case_97_SBOX32(hash,state,key)
        case_96_SBOX32(hash,state,key)
        case_95_SBOX32(hash,state,key)
        case_94_SBOX32(hash,state,key)
        case_93_SBOX32(hash,state,key)
        case_92_SBOX32(hash,state,key)
        case_91_SBOX32(hash,state,key)
        case_90_SBOX32(hash,state,key)
        case_89_SBOX32(hash,state,key)
        case_88_SBOX32(hash,state,key)
        case_87_SBOX32(hash,state,key)
        case_86_SBOX32(hash,state,key)
        case_85_SBOX32(hash,state,key)
        case_84_SBOX32(hash,state,key)
        case_83_SBOX32(hash,state,key)
        case_82_SBOX32(hash,state,key)
        case_81_SBOX32(hash,state,key)
        case_80_SBOX32(hash,state,key)
        case_79_SBOX32(hash,state,key)
        case_78_SBOX32(hash,state,key)
        case_77_SBOX32(hash,state,key)
        case_76_SBOX32(hash,state,key)
        case_75_SBOX32(hash,state,key)
        case_74_SBOX32(hash,state,key)
        case_73_SBOX32(hash,state,key)
        case_72_SBOX32(hash,state,key)
        case_71_SBOX32(hash,state,key)
        case_70_SBOX32(hash,state,key)
        case_69_SBOX32(hash,state,key)
        case_68_SBOX32(hash,state,key)
        case_67_SBOX32(hash,state,key)
        case_66_SBOX32(hash,state,key)
        case_65_SBOX32(hash,state,key)
        case_64_SBOX32(hash,state,key)
        case_63_SBOX32(hash,state,key)
        case_62_SBOX32(hash,state,key)
        case_61_SBOX32(hash,state,key)
        case_60_SBOX32(hash,state,key)
        case_59_SBOX32(hash,state,key)
        case_58_SBOX32(hash,state,key)
        case_57_SBOX32(hash,state,key)
        case_56_SBOX32(hash,state,key)
        case_55_SBOX32(hash,state,key)
        case_54_SBOX32(hash,state,key)
        case_53_SBOX32(hash,state,key)
        case_52_SBOX32(hash,state,key)
        case_51_SBOX32(hash,state,key)
        case_50_SBOX32(hash,state,key)
        case_49_SBOX32(hash,state,key)
        case_48_SBOX32(hash,state,key)
        case_47_SBOX32(hash,state,key)
        case_46_SBOX32(hash,state,key)
        case_45_SBOX32(hash,state,key)
        case_44_SBOX32(hash,state,key)
        case_43_SBOX32(hash,state,key)
        case_42_SBOX32(hash,state,key)
        case_41_SBOX32(hash,state,key)
        case_40_SBOX32(hash,state,key)
        case_39_SBOX32(hash,state,key)
        case_38_SBOX32(hash,state,key)
        case_37_SBOX32(hash,state,key)
        case_36_SBOX32(hash,state,key)
        case_35_SBOX32(hash,state,key)
        case_34_SBOX32(hash,state,key)
        case_33_SBOX32(hash,state,key)
        case_32_SBOX32(hash,state,key)
        case_31_SBOX32(hash,state,key)
        case_30_SBOX32(hash,state,key)
        case_29_SBOX32(hash,state,key)
        case_28_SBOX32(hash,state,key)
        case_27_SBOX32(hash,state,key)
        case_26_SBOX32(hash,state,key)
        case_25_SBOX32(hash,state,key)
        case_24_SBOX32(hash,state,key)
        case_23_SBOX32(hash,state,key)
        case_22_SBOX32(hash,state,key)
        case_21_SBOX32(hash,state,key)
        case_20_SBOX32(hash,state,key)
        case_19_SBOX32(hash,state,key)
        case_18_SBOX32(hash,state,key)
        case_17_SBOX32(hash,state,key)
        case_16_SBOX32(hash,state,key)
        case_15_SBOX32(hash,state,key)
        case_14_SBOX32(hash,state,key)
        case_13_SBOX32(hash,state,key)
        case_12_SBOX32(hash,state,key)
        case_11_SBOX32(hash,state,key)
        case_10_SBOX32(hash,state,key)
        case_9_SBOX32(hash,state,key)
        case_8_SBOX32(hash,state,key)
        case_7_SBOX32(hash,state,key)
        case_6_SBOX32(hash,state,key)
        case_5_SBOX32(hash,state,key)
        case_4_SBOX32(hash,state,key)
        case_3_SBOX32(hash,state,key)
        case_2_SBOX32(hash,state,key)
        case_1_SBOX32(hash,state,key)
        case 0: break;
    }
    return hash;
}

SBOX32_STATIC_INLINE U32 sbox32_hash128(
    const U8 *seed_ch,
    const U8 *key,
    const STRLEN key_len
) {
    U32 state[SBOX32_STATE_WORDS];
    sbox32_seed_state128(seed_ch,(U8*)state);
    return sbox32_hash_with_state((U8*)state,key,key_len);
}

#endif
                                                                                                   usr/lib/x86_64-linux-gnu/perl/5.36.0/CORE/scope.h                                                   0000644 0000000 0000000 00000032120 14530460112 017204  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    scope.h
 *
 *    Copyright (C) 1993, 1994, 1996, 1997, 1998, 1999, 2000, 2001,
 *    2002, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/* *** Update arg_counts[] in scope.c if you modify these */

/* zero args */

#define SAVEt_ALLOC		0
#define SAVEt_CLEARPADRANGE	1
#define SAVEt_CLEARSV		2
#define SAVEt_REGCONTEXT	3

/* one arg */

#define SAVEt_TMPSFLOOR		4
#define SAVEt_BOOL		5
#define SAVEt_COMPILE_WARNINGS	6
#define SAVEt_COMPPAD		7
#define SAVEt_FREECOPHH		8
#define SAVEt_FREEOP		9
#define SAVEt_FREEPV		10
#define SAVEt_FREESV		11
#define SAVEt_I16		12
#define SAVEt_I32_SMALL		13
#define SAVEt_I8		14
#define SAVEt_INT_SMALL		15
#define SAVEt_MORTALIZESV	16
#define SAVEt_NSTAB		17
#define SAVEt_OP		18
#define SAVEt_PARSER		19
#define SAVEt_STACK_POS		20
#define SAVEt_READONLY_OFF	21
#define SAVEt_FREEPADNAME	22
#define SAVEt_STRLEN_SMALL      23

/* two args */

#define SAVEt_AV		24
#define SAVEt_DESTRUCTOR	25
#define SAVEt_DESTRUCTOR_X	26
#define SAVEt_GENERIC_PVREF	27
#define SAVEt_GENERIC_SVREF	28
#define SAVEt_GP		29
#define SAVEt_GVSV		30
#define SAVEt_HINTS		31
#define SAVEt_HPTR		32
#define SAVEt_HV		33
#define SAVEt_I32		34
#define SAVEt_INT		35
#define SAVEt_ITEM		36
#define SAVEt_IV		37
#define SAVEt_LONG		38
#define SAVEt_PPTR		39
#define SAVEt_SAVESWITCHSTACK	40
#define SAVEt_SHARED_PVREF	41
#define SAVEt_SPTR		42
#define SAVEt_STRLEN		43
#define SAVEt_SV		44
#define SAVEt_SVREF		45
#define SAVEt_VPTR		46
#define SAVEt_ADELETE		47
#define SAVEt_APTR		48

/* three args */

#define SAVEt_HELEM		49
#define SAVEt_PADSV_AND_MORTALIZE 50
#define SAVEt_SET_SVFLAGS	51
#define SAVEt_GVSLOT		52
#define SAVEt_AELEM		53
#define SAVEt_DELETE		54
#define SAVEt_HINTS_HH		55


#define SAVEf_SETMAGIC		1
#define SAVEf_KEEPOLDELEM	2

#define SAVE_TIGHT_SHIFT	6
#define SAVE_MASK		0x3F

#define save_aelem(av,idx,sptr)	save_aelem_flags(av,idx,sptr,SAVEf_SETMAGIC)
#define save_helem(hv,key,sptr)	save_helem_flags(hv,key,sptr,SAVEf_SETMAGIC)

#ifndef SCOPE_SAVES_SIGNAL_MASK
#define SCOPE_SAVES_SIGNAL_MASK 0
#endif

/* the maximum number of entries that might be pushed using the SS_ADD*
 * macros */
#define SS_MAXPUSH 4

#define SSCHECK(need) if (UNLIKELY(PL_savestack_ix + (I32)(need) > PL_savestack_max)) savestack_grow()
#define SSGROW(need) if (UNLIKELY(PL_savestack_ix + (I32)(need) > PL_savestack_max)) savestack_grow_cnt(need)
#define SSPUSHINT(i) (PL_savestack[PL_savestack_ix++].any_i32 = (I32)(i))
#define SSPUSHLONG(i) (PL_savestack[PL_savestack_ix++].any_long = (long)(i))
#define SSPUSHBOOL(p) (PL_savestack[PL_savestack_ix++].any_bool = (p))
#define SSPUSHIV(i) (PL_savestack[PL_savestack_ix++].any_iv = (IV)(i))
#define SSPUSHUV(u) (PL_savestack[PL_savestack_ix++].any_uv = (UV)(u))
#define SSPUSHPTR(p) (PL_savestack[PL_savestack_ix++].any_ptr = (void*)(p))
#define SSPUSHDPTR(p) (PL_savestack[PL_savestack_ix++].any_dptr = (p))
#define SSPUSHDXPTR(p) (PL_savestack[PL_savestack_ix++].any_dxptr = (p))

/* SS_ADD*: newer, faster versions of the above. Don't mix the two sets of
 * macros. These are fast because they save reduce accesses to the PL_
 * vars and move the size check to the end. Doing the check last means
 * that values in registers will have been pushed and no longer needed, so
 * don't need saving around the call to grow. Also, tail-call elimination
 * of the grow() can be done. These changes reduce the code of something
 * like save_pushptrptr() to half its former size.
 * Of course, doing the size check *after* pushing means we must always
 * ensure there are SS_MAXPUSH free slots on the savestack. This is ensured by
 * savestack_grow() and savestack_grow_cnt always allocating SS_MAXPUSH slots
 * more than asked for, or that it sets PL_savestack_max to
 *
 * These are for internal core use only and are subject to change */

#define dSS_ADD \
    I32 ix = PL_savestack_ix;     \
    ANY *ssp = &PL_savestack[ix]

#define SS_ADD_END(need) \
    assert((need) <= SS_MAXPUSH);                               \
    ix += (need);                                               \
    PL_savestack_ix = ix;                                       \
    assert(ix <= PL_savestack_max + SS_MAXPUSH);                \
    if (UNLIKELY(ix > PL_savestack_max)) savestack_grow();      \
    assert(PL_savestack_ix <= PL_savestack_max);

#define SS_ADD_INT(i)   ((ssp++)->any_i32 = (I32)(i))
#define SS_ADD_LONG(i)  ((ssp++)->any_long = (long)(i))
#define SS_ADD_BOOL(p)  ((ssp++)->any_bool = (p))
#define SS_ADD_IV(i)    ((ssp++)->any_iv = (IV)(i))
#define SS_ADD_UV(u)    ((ssp++)->any_uv = (UV)(u))
#define SS_ADD_PTR(p)   ((ssp++)->any_ptr = (void*)(p))
#define SS_ADD_DPTR(p)  ((ssp++)->any_dptr = (p))
#define SS_ADD_DXPTR(p) ((ssp++)->any_dxptr = (p))

#define SSPOPINT (PL_savestack[--PL_savestack_ix].any_i32)
#define SSPOPLONG (PL_savestack[--PL_savestack_ix].any_long)
#define SSPOPBOOL (PL_savestack[--PL_savestack_ix].any_bool)
#define SSPOPIV (PL_savestack[--PL_savestack_ix].any_iv)
#define SSPOPUV (PL_savestack[--PL_savestack_ix].any_uv)
#define SSPOPPTR (PL_savestack[--PL_savestack_ix].any_ptr)
#define SSPOPDPTR (PL_savestack[--PL_savestack_ix].any_dptr)
#define SSPOPDXPTR (PL_savestack[--PL_savestack_ix].any_dxptr)


/*
=for apidoc_section $callback

=for apidoc Amns||SAVETMPS
Opening bracket for temporaries on a callback.  See C<L</FREETMPS>> and
L<perlcall>.

=for apidoc Amns||FREETMPS
Closing bracket for temporaries on a callback.  See C<L</SAVETMPS>> and
L<perlcall>.

=for apidoc Amns||ENTER
Opening bracket on a callback.  See C<L</LEAVE>> and L<perlcall>.

=for apidoc Amns||LEAVE
Closing bracket on a callback.  See C<L</ENTER>> and L<perlcall>.

=for apidoc Ams||ENTER_with_name|"name"

Same as C<L</ENTER>>, but when debugging is enabled it also associates the
given literal string with the new scope.

=for apidoc Ams||LEAVE_with_name|"name"

Same as C<L</LEAVE>>, but when debugging is enabled it first checks that the
scope has the given name. C<name> must be a literal string.

=cut
*/

#define SAVETMPS Perl_savetmps(aTHX)

#define FREETMPS if (PL_tmps_ix > PL_tmps_floor) free_tmps()

#ifdef DEBUGGING
#define ENTER							\
    STMT_START {						\
        push_scope();						\
        DEBUG_SCOPE("ENTER")					\
    } STMT_END
#define LEAVE							\
    STMT_START {						\
        DEBUG_SCOPE("LEAVE")					\
        pop_scope();						\
    } STMT_END
#define ENTER_with_name(name)						\
    STMT_START {							\
        push_scope();							\
        if (PL_scopestack_name)						\
            PL_scopestack_name[PL_scopestack_ix-1] = ASSERT_IS_LITERAL(name);\
        DEBUG_SCOPE("ENTER \"" name "\"")				\
    } STMT_END
#define LEAVE_with_name(name)						\
    STMT_START {							\
        DEBUG_SCOPE("LEAVE \"" name "\"")				\
        if (PL_scopestack_name)	{					\
            CLANG_DIAG_IGNORE_STMT(-Wstring-compare);			\
            assert(((char*)PL_scopestack_name[PL_scopestack_ix-1]	\
                        == (char*)ASSERT_IS_LITERAL(name))              \
                    || strEQ(PL_scopestack_name[PL_scopestack_ix-1], name));        \
            CLANG_DIAG_RESTORE_STMT;					\
        }								\
        pop_scope();							\
    } STMT_END
#else
#define ENTER push_scope()
#define LEAVE pop_scope()
#define ENTER_with_name(name) ENTER
#define LEAVE_with_name(name) LEAVE
#endif
#define LEAVE_SCOPE(old) STMT_START { \
        if (PL_savestack_ix > old) leave_scope(old); \
    } STMT_END

#define SAVEI8(i)                   save_I8((I8*)&(i))
#define SAVEI16(i)                  save_I16((I16*)&(i))
#define SAVEI32(i)                  save_I32((I32*)&(i))
#define SAVEINT(i)                  save_int((int*)&(i))
#define SAVEIV(i)                   save_iv((IV*)&(i))
#define SAVELONG(l)                 save_long((long*)&(l))
#define SAVESTRLEN(l)               Perl_save_strlen(aTHX_ (STRLEN*)&(l))
#define SAVEBOOL(b)                 save_bool(&(b))
#define SAVESPTR(s)                 save_sptr((SV**)&(s))
#define SAVEPPTR(s)                 save_pptr((char**)&(s))
#define SAVEVPTR(s)                 save_vptr((void*)&(s))
#define SAVEPADSVANDMORTALIZE(s)    save_padsv_and_mortalize(s)
#define SAVEFREESV(s)               save_freesv(MUTABLE_SV(s))
#define SAVEFREEPADNAME(s)          save_pushptr((void *)(s), SAVEt_FREEPADNAME)
#define SAVEMORTALIZESV(s)          save_mortalizesv(MUTABLE_SV(s))
#define SAVEFREEOP(o)               save_freeop((OP*)(o))
#define SAVEFREEPV(p)               save_freepv((char*)(p))
#define SAVECLEARSV(sv)             save_clearsv((SV**)&(sv))
#define SAVEGENERICSV(s)            save_generic_svref((SV**)&(s))
#define SAVEGENERICPV(s)            save_generic_pvref((char**)&(s))
#define SAVESHAREDPV(s)             save_shared_pvref((char**)&(s))
#define SAVESETSVFLAGS(sv,mask,val) save_set_svflags(sv,mask,val)
#define SAVEFREECOPHH(h)            save_pushptr((void *)(h), SAVEt_FREECOPHH)

#define SAVEDELETE(h,k,l) \
          save_delete(MUTABLE_HV(h), (char*)(k), (I32)(l))
#define SAVEHDELETE(h,s) \
          save_hdelete(MUTABLE_HV(h), (s))
#define SAVEADELETE(a,k) \
          save_adelete(MUTABLE_AV(a), (SSize_t)(k))
#define SAVEDESTRUCTOR(f,p) \
          save_destructor((DESTRUCTORFUNC_NOCONTEXT_t)(f), (void*)(p))

#define SAVEDESTRUCTOR_X(f,p) \
          save_destructor_x((DESTRUCTORFUNC_t)(f), (void*)(p))

#define SAVESTACK_POS() \
    STMT_START {				   \
        dSS_ADD;                                   \
        SS_ADD_INT(PL_stack_sp - PL_stack_base);   \
        SS_ADD_UV(SAVEt_STACK_POS);                \
        SS_ADD_END(2);                             \
    } STMT_END

#define SAVEOP()	save_op()

#define SAVEHINTS()	save_hints()

#define SAVECOMPPAD() save_pushptr(MUTABLE_SV(PL_comppad), SAVEt_COMPPAD)

#define SAVESWITCHSTACK(f,t) \
    STMT_START {					\
        save_pushptrptr(MUTABLE_SV(f), MUTABLE_SV(t), SAVEt_SAVESWITCHSTACK); \
        SWITCHSTACK((f),(t));				\
        PL_curstackinfo->si_stack = (t);		\
    } STMT_END

/* Need to do the cop warnings like this, rather than a "SAVEFREESHAREDPV",
   because realloc() means that the value can actually change. Possibly
   could have done savefreesharedpvREF, but this way actually seems cleaner,
   as it simplifies the code that does the saves, and reduces the load on the
   save stack.  */
#define SAVECOMPILEWARNINGS() save_pushptr(PL_compiling.cop_warnings, SAVEt_COMPILE_WARNINGS)

#define SAVEPARSER(p) save_pushptr((p), SAVEt_PARSER)

#ifdef USE_ITHREADS
#  define SAVECOPSTASH_FREE(c)	SAVEIV((c)->cop_stashoff)
#  define SAVECOPFILE(c)	SAVEPPTR(CopFILE(c))
#  define SAVECOPFILE_FREE(c)	SAVESHAREDPV(CopFILE(c))
#else
#  /* XXX not refcounted */
#  define SAVECOPSTASH_FREE(c)	SAVESPTR(CopSTASH(c))
#  define SAVECOPFILE(c)	SAVESPTR(CopFILEGV(c))
#  define SAVECOPFILE_FREE(c)	SAVEGENERICSV(CopFILEGV(c))
#endif

#define SAVECOPLINE(c)		SAVEI32(CopLINE(c))

/*
