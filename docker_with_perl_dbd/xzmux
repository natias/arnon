
#define sv_taint(sv)	  sv_magic((sv), NULL, PERL_MAGIC_taint, NULL, 0)

#ifdef NO_TAINT_SUPPORT
#   define SvTAINTED(sv) 0
#else
#   define SvTAINTED(sv)	  (SvMAGICAL(sv) && sv_tainted(sv))
#endif
#define SvTAINTED_on(sv)  STMT_START{ if(UNLIKELY(TAINTING_get)){sv_taint(sv);}   }STMT_END
#define SvTAINTED_off(sv) STMT_START{ if(UNLIKELY(TAINTING_get)){sv_untaint(sv);} }STMT_END

#define SvTAINT(sv)			\
    STMT_START {			\
        assert(TAINTING_get || !TAINT_get); \
        if (UNLIKELY(TAINT_get))	\
            SvTAINTED_on(sv);	        \
    } STMT_END

/*
=for apidoc_section $SV
=for apidoc Am|char*|SvPV_force              |SV* sv|STRLEN len
=for apidoc_item   ||SvPV_force_flags        |SV * sv|STRLEN len|U32 flags
=for apidoc_item   ||SvPV_force_flags_mutable|SV * sv|STRLEN len|U32 flags
=for apidoc_item   ||SvPV_force_flags_nolen  |SV * sv           |U32 flags
=for apidoc_item   ||SvPV_force_mutable      |SV * sv|STRLEN len
=for apidoc_item   ||SvPV_force_nolen        |SV* sv
=for apidoc_item   ||SvPV_force_nomg         |SV* sv|STRLEN len
=for apidoc_item   ||SvPV_force_nomg_nolen   |SV * sv
=for apidoc_item   ||SvPVbyte_force          |SV * sv|STRLEN len
=for apidoc_item   ||SvPVbytex_force         |SV * sv|STRLEN len
=for apidoc_item   ||SvPVutf8_force          |SV * sv|STRLEN len
=for apidoc_item   ||SvPVutf8x_force         |SV * sv|STRLEN len
=for apidoc_item   ||SvPVx_force             |SV* sv|STRLEN len

These are like C<L</SvPV>>, returning the string in the SV, but will force the
SV into containing a string (C<L</SvPOK>>), and only a string
(C<L</SvPOK_only>>), by hook or by crook.  You need to use one of these
C<force> routines if you are going to update the C<L</SvPVX>> directly.

Note that coercing an arbitrary scalar into a plain PV will potentially
strip useful data from it.  For example if the SV was C<SvROK>, then the
referent will have its reference count decremented, and the SV itself may
be converted to an C<SvPOK> scalar with a string buffer containing a value
such as C<"ARRAY(0x1234)">.

The differences between the forms are:

The forms with C<flags> in their names allow you to use the C<flags> parameter
to specify to perform 'get' magic (by setting the C<SV_GMAGIC> flag) or to skip
'get' magic (by clearing it).  The other forms do perform 'get' magic, except
for the ones with C<nomg> in their names, which skip 'get' magic.

The forms that take a C<len> parameter will set that variable to the byte
length of the resultant string (these are macros, so don't use C<&len>).

The forms with C<nolen> in their names indicate they don't have a C<len>
parameter.  They should be used only when it is known that the PV is a C
string, terminated by a NUL byte, and without intermediate NUL characters; or
when you don't care about its length.

The forms with C<mutable> in their names are effectively the same as those without,
but the name emphasizes that the string is modifiable by the caller, which it is
in all the forms.

C<SvPVutf8_force> is like C<SvPV_force>, but converts C<sv> to UTF-8 first if
not already UTF-8.

C<SvPVutf8x_force> is like C<SvPVutf8_force>, but guarantees to evaluate C<sv>
only once; use the more efficient C<SvPVutf8_force> otherwise.

C<SvPVbyte_force> is like C<SvPV_force>, but converts C<sv> to byte
representation first if currently encoded as UTF-8.  If the SV cannot be
downgraded from UTF-8, this croaks.

C<SvPVbytex_force> is like C<SvPVbyte_force>, but guarantees to evaluate C<sv>
only once; use the more efficient C<SvPVbyte_force> otherwise.

=for apidoc Am   |      char*|SvPV                 |SV* sv|STRLEN len
=for apidoc_item |const char*|SvPV_const           |SV* sv|STRLEN len
=for apidoc_item |      char*|SvPV_flags           |SV* sv|STRLEN len|U32 flags
=for apidoc_item |const char*|SvPV_flags_const     |SV* sv|STRLEN len|U32 flags
=for apidoc_item |      char*|SvPV_flags_mutable   |SV* sv|STRLEN len|U32 flags
=for apidoc_item |      char*|SvPV_mutable         |SV* sv|STRLEN len
=for apidoc_item |      char*|SvPV_nolen           |SV* sv
=for apidoc_item |const char*|SvPV_nolen_const     |SV* sv
=for apidoc_item |      char*|SvPV_nomg            |SV* sv|STRLEN len
=for apidoc_item |const char*|SvPV_nomg_const      |SV* sv|STRLEN len
=for apidoc_item |const char*|SvPV_nomg_const_nolen|SV* sv
=for apidoc_item |      char*|SvPV_nomg_nolen      |SV* sv
=for apidoc_item |      char*|SvPVbyte             |SV* sv|STRLEN len
=for apidoc_item |      char*|SvPVbyte_nolen       |SV* sv
=for apidoc_item |      char*|SvPVbyte_nomg        |SV* sv|STRLEN len
=for apidoc_item |      char*|SvPVbyte_or_null     |SV* sv|STRLEN len
=for apidoc_item |      char*|SvPVbyte_or_null_nomg|SV* sv|STRLEN len
=for apidoc_item |      char*|SvPVbytex            |SV* sv|STRLEN len
=for apidoc_item |      char*|SvPVbytex_nolen      |SV* sv
=for apidoc_item |      char*|SvPVutf8             |SV* sv|STRLEN len
=for apidoc_item |      char*|SvPVutf8_nolen       |SV* sv
=for apidoc_item |      char*|SvPVutf8_nomg        |SV* sv|STRLEN len
=for apidoc_item |      char*|SvPVutf8_or_null     |SV* sv|STRLEN len
=for apidoc_item |      char*|SvPVutf8_or_null_nomg|SV* sv|STRLEN len
=for apidoc_item |      char*|SvPVutf8x            |SV* sv|STRLEN len
=for apidoc_item |      char*|SvPVx                |SV* sv|STRLEN len
=for apidoc_item |const char*|SvPVx_const          |SV* sv|STRLEN len
=for apidoc_item |      char*|SvPVx_nolen          |SV* sv
=for apidoc_item |const char*|SvPVx_nolen_const    |SV* sv

These each return a pointer to the string in C<sv>, or a stringified form of
C<sv> if it does not contain a string.  The SV may cache the stringified
version becoming C<SvPOK>.

This is a very basic and common operation, so there are lots of slightly
different versions of it.

Note that there is no guarantee that the return value of C<SvPV(sv)>, for
example, is equal to C<SvPVX(sv)>, or that C<SvPVX(sv)> contains valid data, or
that successive calls to C<SvPV(sv)> (or another of these forms) will return
the same pointer value each time.  This is due to the way that things like
overloading and Copy-On-Write are handled.  In these cases, the return value
may point to a temporary buffer or similar.  If you absolutely need the
C<SvPVX> field to be valid (for example, if you intend to write to it), then
see C<L</SvPV_force>>.

The differences between the forms are:

The forms with neither C<byte> nor C<utf8> in their names (e.g., C<SvPV> or
C<SvPV_nolen>) can expose the SV's internal string buffer. If
that buffer consists entirely of bytes 0-255 and includes any bytes above
127, then you B<MUST> consult C<SvUTF8> to determine the actual code points
the string is meant to contain. Generally speaking, it is probably safer to
prefer C<SvPVbyte>, C<SvPVutf8>, and the like. See
L<perlguts/How do I pass a Perl string to a C library?> for more details.

The forms with C<flags> in their names allow you to use the C<flags> parameter
to specify to process 'get' magic (by setting the C<SV_GMAGIC> flag) or to skip
'get' magic (by clearing it).  The other forms process 'get' magic, except for
the ones with C<nomg> in their names, which skip 'get' magic.

The forms that take a C<len> parameter will set that variable to the byte
length of the resultant string (these are macros, so don't use C<&len>).

The forms with C<nolen> in their names indicate they don't have a C<len>
parameter.  They should be used only when it is known that the PV is a C
string, terminated by a NUL byte, and without intermediate NUL characters; or
when you don't care about its length.

The forms with C<const> in their names return S<C<const char *>> so that the
compiler will hopefully complain if you were to try to modify the contents of
the string (unless you cast away const yourself).

The other forms return a mutable pointer so that the string is modifiable by
the caller; this is emphasized for the ones with C<mutable> in their names.

As of 5.38, all forms are guaranteed to evaluate C<sv> exactly once.  For
earlier Perls, use a form whose name ends with C<x> for single evaluation.

C<SvPVutf8> is like C<SvPV>, but converts C<sv> to UTF-8 first if not already
UTF-8.  Similarly, the other forms with C<utf8> in their names correspond to
their respective forms without.

C<SvPVutf8_or_null> and C<SvPVutf8_or_null_nomg> don't have corresponding
non-C<utf8> forms.  Instead they are like C<SvPVutf8_nomg>, but when C<sv> is
undef, they return C<NULL>.

C<SvPVbyte> is like C<SvPV>, but converts C<sv> to byte representation first if
currently encoded as UTF-8.  If C<sv> cannot be downgraded from UTF-8, it
croaks.  Similarly, the other forms with C<byte> in their names correspond to
their respective forms without.

C<SvPVbyte_or_null> doesn't have a corresponding non-C<byte> form.  Instead it
is like C<SvPVbyte>, but when C<sv> is undef, it returns C<NULL>.

=for apidoc      SvTRUE
=for apidoc_item SvTRUE_NN
=for apidoc_item SvTRUE_nomg
=for apidoc_item SvTRUE_nomg_NN
=for apidoc_item SvTRUEx

These return a boolean indicating whether Perl would evaluate the SV as true or
false.  See C<L</SvOK>> for a defined/undefined test.

As of Perl 5.32, all are guaranteed to evaluate C<sv> only once.  Prior to that
release, only C<SvTRUEx> guaranteed single evaluation; now C<SvTRUEx> is
identical to C<SvTRUE>.

C<SvTRUE_nomg> and C<TRUE_nomg_NN> do not perform 'get' magic; the others do
unless the scalar is already C<SvPOK>, C<SvIOK>, or C<SvNOK> (the public, not
the private flags).

C<SvTRUE_NN> is like C<L</SvTRUE>>, but C<sv> is assumed to be
non-null (NN).  If there is a possibility that it is NULL, use plain
C<SvTRUE>.

C<SvTRUE_nomg_NN> is like C<L</SvTRUE_nomg>>, but C<sv> is assumed to be
non-null (NN).  If there is a possibility that it is NULL, use plain
C<SvTRUE_nomg>.

=for apidoc Am|U32|SvIsCOW|SV* sv
Returns a U32 value indicating whether the SV is Copy-On-Write (either shared
hash key scalars, or full Copy On Write scalars if 5.9.0 is configured for
COW).

=for apidoc Am|bool|SvIsCOW_shared_hash|SV* sv
Returns a boolean indicating whether the SV is Copy-On-Write shared hash key
scalar.

=cut
*/

/* To pass the action to the functions called by the following macros */
typedef enum {
    SvPVutf8_type_,
    SvPVbyte_type_,
    SvPVnormal_type_,
    SvPVforce_type_,
    SvPVutf8_pure_type_,
    SvPVbyte_pure_type_
} PL_SvPVtype;

START_EXTERN_C

/* When this code was written, embed.fnc could not handle function pointer
 * parameters; perhaps it still can't */
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE char*
Perl_SvPV_helper(pTHX_ SV *const sv, STRLEN *const lp, const U32 flags, const PL_SvPVtype type, char * (*non_trivial)(pTHX_ SV *, STRLEN * const, const U32), const bool or_null, const U32 return_flags);
#endif

END_EXTERN_C

/* This test is "is there a cached PV that we can use directly?"
 * We can if
 * a) SVf_POK is true and there's definitely no get magic on the scalar
 * b) SVp_POK is true, there's no get magic, and we know that the cached PV
 *    came from an IV conversion.
 * For the latter case, we don't set SVf_POK so that we can distinguish whether
 * the value originated as a string or as an integer, before we cached the
 * second representation. */
#define SvPOK_or_cached_IV(sv) \
    (((SvFLAGS(sv) & (SVf_POK|SVs_GMG)) == SVf_POK) || ((SvFLAGS(sv) & (SVf_IOK|SVp_POK|SVs_GMG)) == (SVf_IOK|SVp_POK)))

#define SvPV_flags(sv, len, flags)                                          \
   Perl_SvPV_helper(aTHX_ sv, &len, flags, SvPVnormal_type_,                \
                    Perl_sv_2pv_flags, FALSE, 0)
#define SvPV_flags_const(sv, len, flags)                                    \
   ((const char*) Perl_SvPV_helper(aTHX_ sv, &len, flags, SvPVnormal_type_, \
                                   Perl_sv_2pv_flags, FALSE,                \
                                   SV_CONST_RETURN))
#define SvPV_flags_const_nolen(sv, flags)                                   \
   ((const char*) Perl_SvPV_helper(aTHX_ sv, NULL, flags, SvPVnormal_type_, \
                                   Perl_sv_2pv_flags, FALSE,                \
                                   SV_CONST_RETURN))
#define SvPV_flags_mutable(sv, len, flags)                                  \
    Perl_SvPV_helper(aTHX_ sv, &len, flags, SvPVnormal_type_,               \
                     Perl_sv_2pv_flags, FALSE, SV_MUTABLE_RETURN)

#define SvPV_nolen(sv)                                                      \
    Perl_SvPV_helper(aTHX_ sv, NULL, SV_GMAGIC, SvPVnormal_type_,           \
                     Perl_sv_2pv_flags, FALSE, 0)

#define SvPV_nolen_const(sv)  SvPV_flags_const_nolen(sv, SV_GMAGIC)

#define SvPV(sv, len)               SvPV_flags(sv, len, SV_GMAGIC)
#define SvPV_const(sv, len)         SvPV_flags_const(sv, len, SV_GMAGIC)
#define SvPV_mutable(sv, len)       SvPV_flags_mutable(sv, len, SV_GMAGIC)

#define SvPV_nomg_nolen(sv)                                                 \
    Perl_SvPV_helper(aTHX_ sv, NULL, 0, SvPVnormal_type_,Perl_sv_2pv_flags, \
                     FALSE, 0)
#define SvPV_nomg(sv, len)          SvPV_flags(sv, len, 0)
#define SvPV_nomg_const(sv, len)    SvPV_flags_const(sv, len, 0)
#define SvPV_nomg_const_nolen(sv)   SvPV_flags_const_nolen(sv, 0)

#define SvPV_force_flags(sv, len, flags)                                    \
    Perl_SvPV_helper(aTHX_ sv, &len, flags, SvPVforce_type_,                \
                     Perl_sv_pvn_force_flags, FALSE, 0)
#define SvPV_force_flags_nolen(sv, flags)                                   \
    Perl_SvPV_helper(aTHX_ sv, NULL, flags, SvPVforce_type_,                \
                     Perl_sv_pvn_force_flags, FALSE, 0)
#define SvPV_force_flags_mutable(sv, len, flags)                            \
    Perl_SvPV_helper(aTHX_ sv, &len, flags, SvPVforce_type_,                \
                     Perl_sv_pvn_force_flags, FALSE, SV_MUTABLE_RETURN)

#define SvPV_force(sv, len)         SvPV_force_flags(sv, len, SV_GMAGIC)
#define SvPV_force_nolen(sv)        SvPV_force_flags_nolen(sv, SV_GMAGIC)
#define SvPV_force_mutable(sv, len) SvPV_force_flags_mutable(sv, len, SV_GMAGIC)

/* "_nomg" in these defines means no mg_get() */
#define SvPV_force_nomg(sv, len)    SvPV_force_flags(sv, len, 0)
#define SvPV_force_nomg_nolen(sv)   SvPV_force_flags_nolen(sv, 0)

#define SvPVutf8(sv, len)                                                   \
    Perl_SvPV_helper(aTHX_ sv, &len, SV_GMAGIC, SvPVutf8_type_,             \
                     Perl_sv_2pvutf8_flags, FALSE, 0)
#define SvPVutf8_nomg(sv, len)                                              \
    Perl_SvPV_helper(aTHX_ sv, &len, 0, SvPVutf8_type_,                     \
                     Perl_sv_2pvutf8_flags, FALSE, 0)
#define SvPVutf8_nolen(sv)                                                  \
    Perl_SvPV_helper(aTHX_ sv, NULL, SV_GMAGIC, SvPVutf8_type_,             \
                     Perl_sv_2pvutf8_flags, FALSE, 0)
#define SvPVutf8_or_null(sv, len)                                           \
    Perl_SvPV_helper(aTHX_ sv, &len, SV_GMAGIC, SvPVutf8_type_,             \
                     Perl_sv_2pvutf8_flags, TRUE, 0)
#define SvPVutf8_or_null_nomg(sv, len)                                      \
    Perl_SvPV_helper(aTHX_ sv, &len, 0, SvPVutf8_type_,                     \
                     Perl_sv_2pvutf8_flags, TRUE, 0)

#define SvPVbyte(sv, len)                                                   \
    Perl_SvPV_helper(aTHX_ sv, &len, SV_GMAGIC, SvPVbyte_type_,             \
                     Perl_sv_2pvbyte_flags, FALSE, 0)
#define SvPVbyte_nomg(sv, len)                                              \
    Perl_SvPV_helper(aTHX_ sv, &len, 0, SvPVbyte_type_,                     \
                     Perl_sv_2pvbyte_flags, FALSE, 0)
#define SvPVbyte_nolen(sv)                                                  \
    Perl_SvPV_helper(aTHX_ sv, NULL, SV_GMAGIC, SvPVbyte_type_,             \
                     Perl_sv_2pvbyte_flags, FALSE, 0)
#define SvPVbyte_or_null(sv, len)                                           \
    Perl_SvPV_helper(aTHX_ sv, &len, SV_GMAGIC, SvPVbyte_type_,             \
                     Perl_sv_2pvbyte_flags, TRUE, 0)
#define SvPVbyte_or_null_nomg(sv, len)                                      \
    Perl_SvPV_helper(aTHX_ sv, &len, 0, SvPVbyte_type_,                     \
                     Perl_sv_2pvbyte_flags, TRUE, 0)

#define SvPVutf8_force(sv, len)                                             \
    Perl_SvPV_helper(aTHX_ sv, &len, 0, SvPVutf8_pure_type_,                \
                     Perl_sv_pvutf8n_force_wrapper, FALSE, 0)

#define SvPVbyte_force(sv, len)                                             \
    Perl_SvPV_helper(aTHX_ sv, &len, 0, SvPVbyte_pure_type_,                \
                     Perl_sv_pvbyten_force_wrapper, FALSE, 0)

/* define FOOx(): Before FOO(x) was inlined, these were idempotent versions of
 * FOO(). */

#define SvPVx_force(sv, len) sv_pvn_force(sv, &len)
#define SvPVutf8x_force(sv, len) sv_pvutf8n_force(sv, &len)
#define SvPVbytex_force(sv, len) sv_pvbyten_force(sv, &len)

#define SvTRUEx(sv)        SvTRUE(sv)
#define SvTRUEx_nomg(sv)   SvTRUE_nomg(sv)
#define SvTRUE_nomg_NN(sv) SvTRUE_common(sv, TRUE)

#  define SvIVx(sv) SvIV(sv)
#  define SvUVx(sv) SvUV(sv)
#  define SvNVx(sv) SvNV(sv)

#if defined(PERL_USE_GCC_BRACE_GROUPS)

#  define SvPVx(sv, len) ({SV *_sv = (sv); SvPV(_sv, len); })
#  define SvPVx_const(sv, len) ({SV *_sv = (sv); SvPV_const(_sv, len); })
#  define SvPVx_nolen(sv) ({SV *_sv = (sv); SvPV_nolen(_sv); })
#  define SvPVx_nolen_const(sv) ({SV *_sv = (sv); SvPV_nolen_const(_sv); })
#  define SvPVutf8x(sv, len) ({SV *_sv = (sv); SvPVutf8(_sv, len); })
#  define SvPVbytex(sv, len) ({SV *_sv = (sv); SvPVbyte(_sv, len); })
#  define SvPVbytex_nolen(sv) ({SV *_sv = (sv); SvPVbyte_nolen(_sv); })

#else /* __GNUC__ */

/* These inlined macros use globals, which will require a thread
 * declaration in user code, so we avoid them under threads */

#  define SvPVx(sv, len) ((PL_Sv = (sv)), SvPV(PL_Sv, len))
#  define SvPVx_const(sv, len) ((PL_Sv = (sv)), SvPV_const(PL_Sv, len))
#  define SvPVx_nolen(sv) ((PL_Sv = (sv)), SvPV_nolen(PL_Sv))
#  define SvPVx_nolen_const(sv) ((PL_Sv = (sv)), SvPV_nolen_const(PL_Sv))
#  define SvPVutf8x(sv, len) ((PL_Sv = (sv)), SvPVutf8(PL_Sv, len))
#  define SvPVbytex(sv, len) ((PL_Sv = (sv)), SvPVbyte(PL_Sv, len))
#  define SvPVbytex_nolen(sv) ((PL_Sv = (sv)), SvPVbyte_nolen(PL_Sv))
#endif /* __GNU__ */

#define SvIsCOW(sv)              (SvFLAGS(sv) & SVf_IsCOW)
#define SvIsCOW_on(sv)           (SvFLAGS(sv) |= SVf_IsCOW)
#define SvIsCOW_off(sv)          (SvFLAGS(sv) &= ~(SVf_IsCOW|SVppv_STATIC))
#define SvIsCOW_shared_hash(sv)  ((SvFLAGS(sv) & (SVf_IsCOW|SVppv_STATIC)) == (SVf_IsCOW) && SvLEN(sv) == 0)
#define SvIsCOW_static(sv)       ((SvFLAGS(sv) & (SVf_IsCOW|SVppv_STATIC)) == (SVf_IsCOW|SVppv_STATIC))

#define SvSHARED_HEK_FROM_PV(pvx) \
        ((struct hek*)(pvx - STRUCT_OFFSET(struct hek, hek_key)))
/*
=for apidoc Am|struct hek*|SvSHARED_HASH|SV * sv
Returns the hash for C<sv> created by C<L</newSVpvn_share>>.

=cut
*/
#define SvSHARED_HASH(sv) (0 + SvSHARED_HEK_FROM_PV(SvPVX_const(sv))->hek_hash)

/* flag values for sv_*_flags functions */
#define SV_UTF8_NO_ENCODING	0       /* No longer used */

/*
=for apidoc AmnhD||SV_UTF8_NO_ENCODING

=cut
*/

/* Flags used as `U32 flags` arguments to various functions */
#define SV_IMMEDIATE_UNREF      (1 <<  0) /* 0x0001 -     1 */
#define SV_GMAGIC               (1 <<  1) /* 0x0002 -     2 */
#define SV_COW_DROP_PV          (1 <<  2) /* 0x0004 -     4 */
/* SV_NOT_USED                  (1 <<  3)    0x0008 -     8 */
#define SV_NOSTEAL              (1 <<  4) /* 0x0010 -    16 */
#define SV_CONST_RETURN         (1 <<  5) /* 0x0020 -    32 */
#define SV_MUTABLE_RETURN       (1 <<  6) /* 0x0040 -    64 */
#define SV_SMAGIC               (1 <<  7) /* 0x0080 -   128 */
#define SV_HAS_TRAILING_NUL     (1 <<  8) /* 0x0100 -   256 */
#define SV_COW_SHARED_HASH_KEYS (1 <<  9) /* 0x0200 -   512 */
/* This one is only enabled for PERL_OLD_COPY_ON_WRITE */
/* XXX This flag actually enabled for any COW.  But it appears not to do
       anything.  Can we just remove it?  Or will it serve some future
       purpose.  */
#define SV_COW_OTHER_PVS        (1 << 10) /* 0x0400 -  1024 */
/* Make sv_2pv_flags return NULL if something is undefined.  */
#define SV_UNDEF_RETURNS_NULL   (1 << 11) /* 0x0800 -  2048 */
/* Tell sv_utf8_upgrade() to not check to see if an upgrade is really needed.
 * This is used when the caller has already determined it is, and avoids
 * redundant work */
#define SV_FORCE_UTF8_UPGRADE   (1 << 12) /* 0x1000 -  4096 */
/* if (after resolving magic etc), the SV is found to be overloaded,
 * don't call the overload magic, just return as-is */
#define SV_SKIP_OVERLOAD        (1 << 13) /* 0x2000 -  8192 */
#define SV_CATBYTES             (1 << 14) /* 0x4000 - 16384 */
#define SV_CATUTF8              (1 << 15) /* 0x8000 - 32768 */

/* The core is safe for this COW optimisation. XS code on CPAN may not be.
   So only default to doing the COW setup if we're in the core.
 */
#ifdef PERL_CORE
#  ifndef SV_DO_COW_SVSETSV
#    define SV_DO_COW_SVSETSV	SV_COW_SHARED_HASH_KEYS|SV_COW_OTHER_PVS
#  endif
#endif

#ifndef SV_DO_COW_SVSETSV
#  define SV_DO_COW_SVSETSV	0
#endif


#define sv_unref(sv)    	sv_unref_flags(sv, 0)
#define sv_force_normal(sv)	sv_force_normal_flags(sv, 0)
#define sv_usepvn(sv, p, l)	sv_usepvn_flags(sv, p, l, 0)
#define sv_usepvn_mg(sv, p, l)	sv_usepvn_flags(sv, p, l, SV_SMAGIC)

/*
=for apidoc Am|void|SV_CHECK_THINKFIRST_COW_DROP|SV * sv

Call this when you are about to replace the PV value in C<sv>, which is
potentially copy-on-write.  It stops any sharing with other SVs, so that no
Copy on Write (COW) actually happens.  This COW would be useless, as it would
immediately get changed to something else.  This function also removes any
other encumbrances that would be problematic when changing C<sv>.

=cut
*/

#define SV_CHECK_THINKFIRST_COW_DROP(sv) if (SvTHINKFIRST(sv)) \
                                    sv_force_normal_flags(sv, SV_COW_DROP_PV)

#ifdef PERL_COPY_ON_WRITE
#   define SvCANCOW(sv)					    \
        (SvIsCOW(sv)					     \
         ? SvLEN(sv) ? CowREFCNT(sv) != SV_COW_REFCNT_MAX : 1 \
         : (SvFLAGS(sv) & CAN_COW_MASK) == CAN_COW_FLAGS       \
                            && SvCUR(sv)+1 < SvLEN(sv))
   /* Note: To allow 256 COW "copies", a refcnt of 0 means 1. */
#   define CowREFCNT(sv)	(*(U8 *)(SvPVX(sv)+SvLEN(sv)-1))
#   define SV_COW_REFCNT_MAX	nBIT_UMAX(sizeof(U8) * CHARBITS)
#   define CAN_COW_MASK	(SVf_POK|SVf_ROK|SVp_POK|SVf_FAKE| \
                         SVf_OOK|SVf_BREAK|SVf_READONLY|SVf_PROTECT)
#endif

#define CAN_COW_FLAGS	(SVp_POK|SVf_POK)

/*
=for apidoc Am|void|SV_CHECK_THINKFIRST|SV * sv

Remove any encumbrances from C<sv>, that need to be taken care of before it
is modifiable.  For example if it is Copy on Write (COW), now is the time to
make that copy.

If you know that you are about to change the PV value of C<sv>, instead use
L</C<SV_CHECK_THINKFIRST_COW_DROP>> to avoid the write that would be
immediately written again.

=cut
*/
#define SV_CHECK_THINKFIRST(sv) if (SvTHINKFIRST(sv)) \
                                    sv_force_normal_flags(sv, 0)


/* all these 'functions' are now just macros */

#define sv_pv(sv) SvPV_nolen(sv)
#define sv_pvutf8(sv) SvPVutf8_nolen(sv)
#define sv_pvbyte(sv) SvPVbyte_nolen(sv)

#define sv_pvn_force_nomg(sv, lp) sv_pvn_force_flags(sv, lp, 0)
#define sv_utf8_upgrade_flags(sv, flags) sv_utf8_upgrade_flags_grow(sv, flags, 0)
#define sv_utf8_upgrade_nomg(sv) sv_utf8_upgrade_flags(sv, 0)
#define sv_utf8_downgrade(sv, fail_ok) sv_utf8_downgrade_flags(sv, fail_ok, SV_GMAGIC)
#define sv_utf8_downgrade_nomg(sv, fail_ok) sv_utf8_downgrade_flags(sv, fail_ok, 0)
#define sv_catpvn_nomg(dsv, sstr, slen) sv_catpvn_flags(dsv, sstr, slen, 0)
#define sv_catpv_nomg(dsv, sstr) sv_catpv_flags(dsv, sstr, 0)
#define sv_setsv(dsv, ssv) \
        sv_setsv_flags(dsv, ssv, SV_GMAGIC|SV_DO_COW_SVSETSV)
#define sv_setsv_nomg(dsv, ssv) sv_setsv_flags(dsv, ssv, SV_DO_COW_SVSETSV)
#define sv_catsv(dsv, ssv) sv_catsv_flags(dsv, ssv, SV_GMAGIC)
#define sv_catsv_nomg(dsv, ssv) sv_catsv_flags(dsv, ssv, 0)
#define sv_catsv_mg(dsv, ssv) sv_catsv_flags(dsv, ssv, SV_GMAGIC|SV_SMAGIC)
#define sv_catpvn(dsv, sstr, slen) sv_catpvn_flags(dsv, sstr, slen, SV_GMAGIC)
#define sv_catpvn_mg(dsv, sstr, slen) sv_catpvn_flags(dsv, sstr, slen, SV_GMAGIC|SV_SMAGIC);
#define sv_copypv(dsv, ssv) sv_copypv_flags(dsv, ssv, SV_GMAGIC)
#define sv_copypv_nomg(dsv, ssv) sv_copypv_flags(dsv, ssv, 0)
#define sv_2pv(sv, lp) sv_2pv_flags(sv, lp, SV_GMAGIC)
#define sv_2pv_nolen(sv) sv_2pv(sv, 0)
#define sv_2pvbyte(sv, lp) sv_2pvbyte_flags(sv, lp, SV_GMAGIC)
#define sv_2pvbyte_nolen(sv) sv_2pvbyte(sv, 0)
#define sv_2pvutf8(sv, lp) sv_2pvutf8_flags(sv, lp, SV_GMAGIC)
#define sv_2pvutf8_nolen(sv) sv_2pvutf8(sv, 0)
#define sv_2pv_nomg(sv, lp) sv_2pv_flags(sv, lp, 0)
#define sv_pvn_force(sv, lp) sv_pvn_force_flags(sv, lp, SV_GMAGIC)
#define sv_utf8_upgrade(sv) sv_utf8_upgrade_flags(sv, SV_GMAGIC)
#define sv_2iv(sv) sv_2iv_flags(sv, SV_GMAGIC)
#define sv_2uv(sv) sv_2uv_flags(sv, SV_GMAGIC)
#define sv_2nv(sv) sv_2nv_flags(sv, SV_GMAGIC)
#define sv_eq(sv1, sv2) sv_eq_flags(sv1, sv2, SV_GMAGIC)
#define sv_cmp(sv1, sv2) sv_cmp_flags(sv1, sv2, SV_GMAGIC)
#define sv_cmp_locale(sv1, sv2) sv_cmp_locale_flags(sv1, sv2, SV_GMAGIC)
#define sv_numeq(sv1, sv2) sv_numeq_flags(sv1, sv2, SV_GMAGIC)
#define sv_streq(sv1, sv2) sv_streq_flags(sv1, sv2, SV_GMAGIC)
#define sv_collxfrm(sv, nxp) sv_collxfrm_flags(sv, nxp, SV_GMAGIC)
#define sv_2bool(sv) sv_2bool_flags(sv, SV_GMAGIC)
#define sv_2bool_nomg(sv) sv_2bool_flags(sv, 0)
#define sv_insert(bigstr, offset, len, little, littlelen)		\
        Perl_sv_insert_flags(aTHX_ (bigstr),(offset), (len), (little),	\
                             (littlelen), SV_GMAGIC)
#define sv_mortalcopy(sv) \
        Perl_sv_mortalcopy_flags(aTHX_ sv, SV_GMAGIC|SV_DO_COW_SVSETSV)
#define sv_cathek(sv,hek)					    \
        STMT_START {						     \
            HEK * const bmxk = hek;				      \
            sv_catpvn_flags(sv, HEK_KEY(bmxk), HEK_LEN(bmxk),	       \
                            HEK_UTF8(bmxk) ? SV_CATUTF8 : SV_CATBYTES); \
        } STMT_END

/* Should be named SvCatPVN_utf8_upgrade? */
#define sv_catpvn_nomg_utf8_upgrade(dsv, sstr, slen, nsv)	\
        STMT_START {					\
            if (!(nsv))					\
                nsv = newSVpvn_flags(sstr, slen, SVs_TEMP);	\
            else					\
                sv_setpvn(nsv, sstr, slen);		\
            SvUTF8_off(nsv);				\
            sv_utf8_upgrade(nsv);			\
            sv_catsv_nomg(dsv, nsv);			\
        } STMT_END
#define sv_catpvn_nomg_maybeutf8(dsv, sstr, len, is_utf8) \
        sv_catpvn_flags(dsv, sstr, len, (is_utf8)?SV_CATUTF8:SV_CATBYTES)

#if defined(PERL_CORE) || defined(PERL_EXT)
# define sv_or_pv_len_utf8(sv, pv, bytelen)	      \
    (SvGAMAGIC(sv)				       \
        ? utf8_length((U8 *)(pv), (U8 *)(pv)+(bytelen))	\
        : sv_len_utf8(sv))
#endif

/*
=for apidoc newRV
=for apidoc_item ||newRV_inc|

These are identical.  They create an RV wrapper for an SV.  The reference count
for the original SV is incremented.

=cut
*/

#define newRV_inc(sv)	newRV(sv)

/* the following macros update any magic values this C<sv> is associated with */

/*
=for apidoc_section $SV

=for apidoc Am|void|SvSETMAGIC|SV* sv
Invokes C<L</mg_set>> on an SV if it has 'set' magic.  This is necessary
after modifying a scalar, in case it is a magical variable like C<$|>
or a tied variable (it calls C<STORE>).  This macro evaluates its
argument more than once.

=for apidoc Am|void|SvSetMagicSV|SV* dsv|SV* ssv
=for apidoc_item    SvSetMagicSV_nosteal
=for apidoc_item    SvSetSV
=for apidoc_item    SvSetSV_nosteal

if C<dsv> is the same as C<ssv>, these do nothing.  Otherwise they all call
some form of C<L</sv_setsv>>.  They may evaluate their arguments more than
once.

The only differences are:

C<SvSetMagicSV> and C<SvSetMagicSV_nosteal> perform any required 'set' magic
afterwards on the destination SV; C<SvSetSV> and C<SvSetSV_nosteal> do not.

C<SvSetSV_nosteal> C<SvSetMagicSV_nosteal> call a non-destructive version of
C<sv_setsv>.

=for apidoc Am|void|SvSHARE|SV* sv
Arranges for C<sv> to be shared between threads if a suitable module
has been loaded.

=for apidoc Am|void|SvLOCK|SV* sv
Arranges for a mutual exclusion lock to be obtained on C<sv> if a suitable module
has been loaded.

=for apidoc Am|void|SvUNLOCK|SV* sv
Releases a mutual exclusion lock on C<sv> if a suitable module
has been loaded.

=for apidoc_section $SV

=for apidoc Am|char *|SvGROW|SV* sv|STRLEN len
Expands the character buffer in the SV so that it has room for the
indicated number of bytes (remember to reserve space for an extra trailing
C<NUL> character).  Calls C<sv_grow> to perform the expansion if necessary.
Returns a pointer to the character
buffer.  SV must be of type >= C<SVt_PV>.  One
alternative is to call C<sv_grow> if you are not sure of the type of SV.

You might mistakenly think that C<len> is the number of bytes to add to the
existing size, but instead it is the total size C<sv> should be.

=for apidoc Am|char *|SvPVCLEAR|SV* sv
Ensures that sv is a SVt_PV and that its SvCUR is 0, and that it is
properly null terminated. Equivalent to sv_setpvs(""), but more efficient.

=for apidoc Am|char *|SvPVCLEAR_FRESH|SV* sv

Like SvPVCLEAR, but optimized for newly-minted SVt_PV/PVIV/PVNV/PVMG
that already have a PV buffer allocated, but no SvTHINKFIRST.

=cut
*/

#define SvPVCLEAR(sv) sv_setpv_bufsize(sv,0,0)
#define SvPVCLEAR_FRESH(sv) sv_setpv_freshbuf(sv)
#define SvSHARE(sv) PL_sharehook(aTHX_ sv)
#define SvLOCK(sv) PL_lockhook(aTHX_ sv)
#define SvUNLOCK(sv) PL_unlockhook(aTHX_ sv)
#define SvDESTROYABLE(sv) PL_destroyhook(aTHX_ sv)

#define SvSETMAGIC(x) STMT_START { if (UNLIKELY(SvSMAGICAL(x))) mg_set(x); } STMT_END

#define SvSetSV_and(dst,src,finally) \
        STMT_START {					\
            SV * src_ = src;                            \
            SV * dst_ = dst;                            \
            if (LIKELY((dst_) != (src_))) {             \
                sv_setsv(dst_, src_);                   \
                finally;				\
            }						\
        } STMT_END

#define SvSetSV_nosteal_and(dst,src,finally) \
        STMT_START {					\
            SV * src_ = src;                            \
            SV * dst_ = dst;                            \
            if (LIKELY((dst_) != (src_))) {             \
                sv_setsv_flags(dst_, src_,              \
                        SV_GMAGIC                       \
                      | SV_NOSTEAL                      \
                      | SV_DO_COW_SVSETSV);             \
                finally;				\
            }						\
        } STMT_END

#define SvSetSV(dst,src) \
                SvSetSV_and(dst,src,/*nothing*/;)
#define SvSetSV_nosteal(dst,src) \
                SvSetSV_nosteal_and(dst,src,/*nothing*/;)

#define SvSetMagicSV(dst,src) \
                SvSetSV_and(dst,src,SvSETMAGIC(dst))
#define SvSetMagicSV_nosteal(dst,src) \
                SvSetSV_nosteal_and(dst,src,SvSETMAGIC(dst))


#if !defined(SKIP_DEBUGGING)
#define SvPEEK(sv) sv_peek(sv)
#else
#define SvPEEK(sv) ""
#endif

/* Is this a per-interpreter immortal SV (rather than global)?
 * These should either occupy adjacent entries in the interpreter struct
 * (MULTIPLICITY) or adjacent elements of PL_sv_immortals[] otherwise.
 * The unsigned (Size_t) cast avoids the need for a second < 0 condition.
 */
#define SvIMMORTAL_INTERP(sv) ((Size_t)((sv) - &PL_sv_yes) < 4)

/* Does this immortal have a true value? Currently only PL_sv_yes does. */
#define SvIMMORTAL_TRUE(sv)   ((sv) == &PL_sv_yes)

/* the SvREADONLY() test is to quickly reject most SVs */
#define SvIMMORTAL(sv) \
                (  SvREADONLY(sv) \
                && (SvIMMORTAL_INTERP(sv) || (sv) == &PL_sv_placeholder))

#ifdef DEBUGGING
   /* exercise the immortal resurrection code in sv_free2() */
#  ifdef PERL_RC_STACK
     /* When the stack is ref-counted, the code tends to take a lot of
      * short cuts with immortals, such as skipping the bump of the ref
      * count of PL_sv_undef when pushing it on the stack. Exercise that
      * this doesn't cause problems, especially on code which
      * special-cases RC==1 etc.
      */
#    define SvREFCNT_IMMORTAL 10
#  else
#    define SvREFCNT_IMMORTAL 1000
#  endif
#else
#  define SvREFCNT_IMMORTAL ((~(U32)0)/2)
#endif

/*
=for apidoc Am|SV *|boolSV|bool b

Returns a true SV if C<b> is a true value, or a false SV if C<b> is 0.

See also C<L</PL_sv_yes>> and C<L</PL_sv_no>>.

=cut
*/

#define boolSV(b) ((b) ? &PL_sv_yes : &PL_sv_no)

/*
=for apidoc Am|void|sv_setbool|SV *sv|bool b
=for apidoc_item |void|sv_setbool_mg|SV *sv|bool b

These set an SV to a true or false boolean value, upgrading first if necessary.

They differ only in that C<sv_setbool_mg> handles 'set' magic; C<sv_setbool>
does not.

=cut
*/

#define sv_setbool(sv, b)     sv_setsv(sv, boolSV(b))
#define sv_setbool_mg(sv, b)  sv_setsv_mg(sv, boolSV(b))

#define isGV(sv) (SvTYPE(sv) == SVt_PVGV)
/* If I give every macro argument a different name, then there won't be bugs
   where nested macros get confused. Been there, done that.  */
/*
=for apidoc Am|bool|isGV_with_GP|SV * sv
Returns a boolean as to whether or not C<sv> is a GV with a pointer to a GP
(glob pointer).

=cut
*/
#define isGV_with_GP(pwadak) \
        (((SvFLAGS(pwadak) & (SVp_POK|SVpgv_GP)) == SVpgv_GP)	\
        && (SvTYPE(pwadak) == SVt_PVGV || SvTYPE(pwadak) == SVt_PVLV))

#define isGV_with_GP_on(sv)                                            \
    STMT_START {			                               \
        SV * sv_ = MUTABLE_SV(sv);                                     \
        assert (SvTYPE(sv_) == SVt_PVGV || SvTYPE(sv_) == SVt_PVLV);   \
        assert (!SvPOKp(sv_));					       \
        assert (!SvIOKp(sv_));					       \
        (SvFLAGS(sv_) |= SVpgv_GP);				       \
    } STMT_END

#define isGV_with_GP_off(sv)                                           \
    STMT_START {                                                       \
        SV * sv_ = MUTABLE_SV(sv);                                     \
        assert (SvTYPE(sv_) == SVt_PVGV || SvTYPE(sv_) == SVt_PVLV);   \
        assert (!SvPOKp(sv_));                                         \
        assert (!SvIOKp(sv_));					       \
        (SvFLAGS(sv_) &= ~SVpgv_GP);				       \
    } STMT_END

#ifdef PERL_CORE
# define isGV_or_RVCV(kadawp) \
    (isGV(kadawp) || (SvROK(kadawp) && SvTYPE(SvRV(kadawp)) == SVt_PVCV))
#endif
#define isREGEXP(sv) \
    (SvTYPE(sv) == SVt_REGEXP				      \
     || (SvFLAGS(sv) & (SVTYPEMASK|SVpgv_GP|SVf_FAKE))        \
         == (SVt_PVLV|SVf_FAKE))


#ifdef PERL_ANY_COW
# define SvGROW(sv,len) \
        (SvIsCOW(sv) || SvLEN(sv) < (len) ? sv_grow(sv,len) : SvPVX(sv))
#else
# define SvGROW(sv,len) (SvLEN(sv) < (len) ? sv_grow(sv,len) : SvPVX(sv))
#endif
#define SvGROW_mutable(sv,len) \
    (SvLEN(sv) < (len) ? sv_grow(sv,len) : SvPVX_mutable(sv))
#define Sv_Grow sv_grow

#define CLONEf_COPY_STACKS 1
#define CLONEf_KEEP_PTR_TABLE 2
#define CLONEf_CLONE_HOST 4
#define CLONEf_JOIN_IN 8

struct clone_params {
  AV* stashes;
  UV  flags;
  PerlInterpreter *proto_perl;
  PerlInterpreter *new_perl;
  AV *unreferenced;
};

/* SV_NOSTEAL prevents TEMP buffers being, well, stolen, and saves games
   with SvTEMP_off and SvTEMP_on round a call to sv_setsv.  */
#define newSVsv(sv) newSVsv_flags((sv), SV_GMAGIC|SV_NOSTEAL)
#define newSVsv_nomg(sv) newSVsv_flags((sv), SV_NOSTEAL)

/*
=for apidoc Am|SV*|newSVpvn_utf8|const char* s|STRLEN len|U32 utf8

Creates a new SV and copies a string (which may contain C<NUL> (C<\0>)
characters) into it.  If C<utf8> is true, calls
C<SvUTF8_on> on the new SV.  Implemented as a wrapper around C<newSVpvn_flags>.

=cut
*/

#define newSVpvn_utf8(s, len, u) newSVpvn_flags((s), (len), (u) ? SVf_UTF8 : 0)

/*
=for apidoc Amx|SV*|newSVpadname|PADNAME *pn

Creates a new SV containing the pad name.

=cut
*/

#define newSVpadname(pn) newSVpvn_utf8(PadnamePV(pn), PadnameLEN(pn), TRUE)

/*
=for apidoc Am|void|SvOOK_offset|SV*sv|STRLEN len

Reads into C<len> the offset from C<SvPVX> back to the true start of the
allocated buffer, which will be non-zero if C<sv_chop> has been used to
efficiently remove characters from start of the buffer.  Implemented as a
macro, which takes the address of C<len>, which must be of type C<STRLEN>.
Evaluates C<sv> more than once.  Sets C<len> to 0 if C<SvOOK(sv)> is false.

=cut
*/

#ifdef DEBUGGING
/* Does the bot know something I don't?
10:28 <@Nicholas> metabatman
10:28 <+meta> Nicholas: crash
*/
#  define SvOOK_offset(sv, offset) STMT_START {				\
        STATIC_ASSERT_STMT(sizeof(offset) == sizeof(STRLEN));		\
        if (SvOOK(sv)) {						\
            const U8 *_crash = (U8*)SvPVX_const(sv);			\
            (offset) = *--_crash;					\
            if (!(offset)) {						\
                _crash -= sizeof(STRLEN);				\
                Copy(_crash, (U8 *)&(offset), sizeof(STRLEN), U8);	\
            }								\
            {								\
                /* Validate the preceding buffer's sentinels to		\
                   verify that no-one is using it.  */			\
                const U8 *const _bonk = (U8*)SvPVX_const(sv) - (offset);\
                while (_crash > _bonk) {				\
                    --_crash;						\
                    assert (*_crash == (U8)PTR2UV(_crash));		\
                }							\
            }								\
        } else {							\
            (offset) = 0;						\
        }								\
    } STMT_END
#else
    /* This is the same code, but avoids using any temporary variables:  */
#  define SvOOK_offset(sv, offset) STMT_START {				\
        STATIC_ASSERT_STMT(sizeof(offset) == sizeof(STRLEN));		\
        if (SvOOK(sv)) {						\
            (offset) = ((U8*)SvPVX_const(sv))[-1];			\
            if (!(offset)) {						\
                Copy(SvPVX_const(sv) - 1 - sizeof(STRLEN),		\
                     (U8*)&(offset), sizeof(STRLEN), U8);		\
            }								\
        } else {							\
            (offset) = 0;						\
        }								\
    } STMT_END
#endif

/*
=for apidoc_section $io
=for apidoc newIO

Create a new IO, setting the reference count to 1.

=cut
*/
#define newIO()	MUTABLE_IO(newSV_type(SVt_PVIO))

#if defined(PERL_CORE) || defined(PERL_EXT)

#  define SV_CONST(name) \
        PL_sv_consts[SV_CONST_##name] \
                ? PL_sv_consts[SV_CONST_##name] \
                : (PL_sv_consts[SV_CONST_##name] = newSVpv_share(#name, 0))

#  define SV_CONST_TIESCALAR 0
#  define SV_CONST_TIEARRAY 1
#  define SV_CONST_TIEHASH 2
#  define SV_CONST_TIEHANDLE 3

#  define SV_CONST_FETCH 4
#  define SV_CONST_FETCHSIZE 5
#  define SV_CONST_STORE 6
#  define SV_CONST_STORESIZE 7
#  define SV_CONST_EXISTS 8

#  define SV_CONST_PUSH 9
#  define SV_CONST_POP 10
#  define SV_CONST_SHIFT 11
#  define SV_CONST_UNSHIFT 12
#  define SV_CONST_SPLICE 13
#  define SV_CONST_EXTEND 14

#  define SV_CONST_FIRSTKEY 15
#  define SV_CONST_NEXTKEY 16
#  define SV_CONST_SCALAR 17

#  define SV_CONST_OPEN 18
#  define SV_CONST_WRITE 19
#  define SV_CONST_PRINT 20
#  define SV_CONST_PRINTF 21
#  define SV_CONST_READ 22
#  define SV_CONST_READLINE 23
#  define SV_CONST_GETC 24
#  define SV_CONST_SEEK 25
#  define SV_CONST_TELL 26
#  define SV_CONST_EOF 27
#  define SV_CONST_BINMODE 28
#  define SV_CONST_FILENO 29
#  define SV_CONST_CLOSE 30

#  define SV_CONST_DELETE 31
#  define SV_CONST_CLEAR 32
#  define SV_CONST_UNTIE 33
#  define SV_CONST_DESTROY 34
#endif

#define SV_CONSTS_COUNT 35

/*
 * Bodyless IVs and NVs!
 *
 * Since 5.9.2, we can avoid allocating a body for SVt_IV-type SVs.
 * Since the larger IV-holding variants of SVs store their integer
 * values in their respective bodies, the family of SvIV() accessor
 * macros would  naively have to branch on the SV type to find the
 * integer value either in the HEAD or BODY. In order to avoid this
 * expensive branch, a clever soul has deployed a great hack:
 * We set up the SvANY pointer such that instead of pointing to a
 * real body, it points into the memory before the location of the
 * head. We compute this pointer such that the location of
 * the integer member of the hypothetical body struct happens to
 * be the same as the location of the integer member of the bodyless
 * SV head. This now means that the SvIV() family of accessors can
 * always read from the (hypothetical or real) body via SvANY.
 *
 * Since the 5.21 dev series, we employ the same trick for NVs
 * if the architecture can support it (NVSIZE <= IVSIZE).
 */

/* The following two macros compute the necessary offsets for the above
 * trick and store them in SvANY for SvIV() (and friends) to use. */

#  define SET_SVANY_FOR_BODYLESS_IV(sv) \
    STMT_START {                                            \
        SV * sv_ = MUTABLE_SV(sv);                          \
        SvANY(sv_) =   (XPVIV*)((char*)&(sv_->sv_u.svu_iv)  \
                    - STRUCT_OFFSET(XPVIV, xiv_iv));        \
    } STMT_END

#  define SET_SVANY_FOR_BODYLESS_NV(sv) \
    STMT_START {                                            \
        SV * sv_ = MUTABLE_SV(sv);                          \
        SvANY(sv_) =   (XPVNV*)((char*)&(sv_->sv_u.svu_nv)  \
                    - STRUCT_OFFSET(XPVNV, xnv_u.xnv_nv));  \
    } STMT_END

#if defined(PERL_CORE) && defined(USE_ITHREADS)
/* Certain cases in Perl_ss_dup have been merged, by relying on the fact
   that currently av_dup, gv_dup and hv_dup are the same as sv_dup.
   If this changes, please unmerge ss_dup.
