    **   fsize   - place to store the fetched size
    **   rcode   - place to store the fetched column returned code
    **   dtype   - place to store the data type
    **   buf     - array to store the column name
    **   bufl    - place to store the column name length
    **   dsize   - maximum display size
    **   tbuf    - place to store the table name
    **   tbufl   - place to store the table name length
    */

sword ocidsp (  struct csrdef *cursor, sword pos, sb4 *dbsize, sb2 *dbtype,
                   sb1 *cbuf, sb4 *cbufl, sb4 *dsize, sb2 *pre, sb2 *scl,
                   sb2 *nul );

sword ocidpr( ldadef *lda, oratext *object_name, size_t object_length,
                void * reserved1, size_t reserved1_length, void * reserved2,
                size_t reserved2_length, ub2 *overload, ub2 *position,
                ub2 *level, oratext **argument_name, ub2 *argument_length, 
                ub2 *datatype, ub1 *default_supplied, ub1 *in_out, 
                ub4 *length, sb2 *precision, sb2 *scale, ub1 *radix, 
                ub4 *spare, ub4 *total_elements );
   /*
   ** OCIDPR - User Program Interface: Describe Stored Procedure
   **
   ** This routine is used to obtain information about the calling
   ** arguments of a stored procedure.  The client provides the 
   ** name of the procedure using "object_name" and "database_name"
   ** (database name is optional).  The client also supplies the 
   ** arrays for OCIDPR to return the values and indicates the 
   ** length of array via the "total_elements" parameter.  Upon return
   ** the number of elements used in the arrays is returned in the 
   ** "total_elements" parameter.  If the array is too small then 
   ** an error will be returned and the contents of the return arrays 
   ** are invalid.
   **
   **
   **   EXAMPLE :
   **
   **   Client provides -
   **
   **   object_name    - SCOTT.ACCOUNT_UPDATE@BOSTON
   **   total_elements - 100
   **   
   **
   **   ACCOUNT_UPDATE is an overloaded function with specification :
   **
   **     type number_table is table of number index by binary_integer;
   **     table account (account_no number, person_id number,
   **                    balance number(7,2))
   **     table person  (person_id number(4), person_nm varchar2(10))
   **
   **      function ACCOUNT_UPDATE (account number, 
   **         person person%rowtype, amounts number_table,
   **         trans_date date) return accounts.balance%type;
   **
   **      function ACCOUNT_UPDATE (account number, 
   **         person person%rowtype, amounts number_table,
   **         trans_no number) return accounts.balance%type;
   **
   **
   **   Values returned -
   **
   **   overload position   argument  level  datatype length prec scale rad
   **   -------------------------------------------------------------------
   **          0        0                0   NUMBER     22    7     2   10
   **          0        1   ACCOUNT      0   NUMBER     22    0     0    0
   **          0        2   PERSON       0   RECORD      0    0     0    0
   **          0        2     PERSON_ID  1   NUMBER     22    4     0   10
   **          0        2     PERSON_NM  1   VARCHAR2   10    0     0    0
   **          0        3   AMOUNTS      0   TABLE       0    0     0    0
   **          0        3                1   NUMBER     22    0     0    0
   **          0        4   TRANS_NO     0   NUMBER     22    0     0    0
   **
   **          1        0                0   NUMBER     22    7     2   10
   **          1        1   ACCOUNT      0   NUMBER     22    0     0    0
   **          1        2   PERSON       0   RECORD      0    0     0    0
   **          1        2    PERSON_ID   1   NUMBER     22    4     0   10
   **          1        2    PERSON_NM   1   VARCHAR2   10    0     0    0
   **          1        3   AMOUNTS      0   TABLE       0    0     0    0
   **          1        3                1   NUMBER     22    0     0    0
   **          1        4   TRANS_DATE   0   NUMBER     22    0     0    0
   **
   **
   **  OCIDPR Argument Descriptions -
   **
   **  ldadef           - pointer to ldadef
   **  object_name      - object name, synonyms are also accepted and will 
   **                     be translate, currently only procedure and function
   **                     names are accepted, also NLS names are accepted.
   **                     Currently, the accepted format of a name is 
   **                     [[part1.]part2.]part3[@dblink] (required)
   **  object_length    - object name length (required)
   **  reserved1        - reserved for future use
   **  reserved1_length - reserved for future use
   **  reserved2        - reserved for future use
   **  reserved2_length - reserved for future use
   **  overload         - array indicating overloaded procedure # (returned)
   **  position         - array of argument positions, position 0 is a 
   **                     function return argument (returned)
   **  level            - array of argument type levels, used to describe
   **                     sub-datatypes of data structures like records
   **                     and arrays (returned)
   **  argument_name    - array of argument names, only returns first 
   **                     30 characters of argument names, note storage
   **                     for 30 characters is allocated by client (returned)
   **  argument_length  - array of argument name lengths (returned)
   **  datatype         - array of oracle datatypes (returned)
   **  default_supplied - array indicating parameter has default (returned)
   **                     0 = no default, 1 = default supplied
   **  in_out           - array indicating if argument is IN or OUT (returned
   **                     0 = IN param, 1 = OUT param, 2 = IN/OUT param
   **  length           - array of argument lengths (returned)
   **  precision        - array of precisions (if number type)(returned)
   **  scale            - array of scales (if number type)(returned)
   **  radix            - array of radix (if number type)(returned)
   **  spare            - array of spares.
   **  total_elements   - size of arrays supplied by client (required),
   **                     total number of elements filled (returned)
   */

/*************************************/
/* DEFINING                          */
/*************************************/
sword ocidfi(  struct csrdef *cursor, sword pos, ub1 *buf, sword bufl,
                  sword ftype, sb2 *rc, sword scale  );
sword ocidfn(  struct csrdef *cursor, sword pos, ub1 *buf, sword bufl,
                 sword ftype, sword scale, sb2 *indp, oratext *fmt, sword fmtl,
                 sword fmtt, ub2 *rl, ub2 *rc  );
sword ocidfnps(  struct csrdef *cursor, ub1 opcode, sword pos, ub1 *buf, 
                    sb4 bufl, sword ftype, sword scale,  
                    sb2 *indp, oratext *fmt, sb4 fmtl,
                    sword fmtt, ub2 *rl, ub2 *rc,
                    sb4 pv_skip, sb4 ind_skip, sb4 len_skip, 
                    sb4 rc_skip  );


   /*  Define a user data buffer using upidfn
   **   cursor  - pointer to csrdef
   **   pos     - position of a field or exp in the select list of a query
   **   bfa/bfl - address and length of client-supplied storage
                  to receive data
   **   ftype   - user datatype
   **   scale   - number of fractional digits for cobol packed decimals
   **   indp    - place to store the length of the returned value. If returned
   **             value is:
   **             negative, the field fetched was NULL
   **             zero    , the field fetched was same length or shorter than
   **               the buffer provided
   **             positive, the field fetched was truncated
   **   fmt    - format string
   **   fmtl   - length of format string, if -1 strlent(fmt) used
   **   rl     - place to store column length after each fetch
   **   rc     - place to store column error code after each fetch
   **   fmtt   - fomat type
   */
 
/********************************/
/*    PIECE INFORMATION GET/SET */
/********************************/
sword           ocigetpi(  struct csrdef *cursor, ub1 *piecep,
                              void  **ctxpp, ub4 *iterp, ub4 *indexp  );
sword           ocisetpi(  struct csrdef *cursor, ub1 piece,
                              void  *bufp, ub4 *lenp  );


/********************************/
/*   EXECUTE                    */
/********************************/
sword ociexe(  struct csrdef *cursor  );
sword ociexn(  struct csrdef *cursor, sword iters, sword roff  );
sword ociefn(  struct csrdef *cursor, ub4 nrows, sword can, sword exact );
    /* 
    ** ociexe  - execute a cursor
    ** ociexn  - execute a cursosr N times
    **  cursor   - pointer to a csrdef
    **  iters    - number of times to execute cursor
    **  roff     - offset within the bind variable array at which to begin 
    **             operations.
    */


/*********************************/
/*     FETCHING                  */
/*********************************/
sword ocifet(  struct csrdef *cursor  );
sword ocifen(  struct csrdef *cursor, sword nrows  );
    /* ocifet - fetch the next row
    ** ocifen - fetch n rows 
    ** cursor   - pointer to csrdef
    ** nrows    - number of rows to be fetched
    */

sword ocilng( struct csrdef *cursor, sword posit, ub1 *bfa, sb4 bfl,
                 sword dty, ub4 *rln, sb4 off );

/*********************************/
/*         CONVERSION            */
/*********************************/
sword ocic32(  struct csrdef *cursor  );
    /*
    **   Convert selected version 3 return codes to the equivalent
    **   version 2 code.
    **   csrdef->csrrc is set to the converted code
    **   csrdef->csrft is set to v2 oracle statment type
    **   csrdef->csrrpc is set to the rows processed count
    **   csrdef->csrpeo is set to error postion
    ** 
    **     cursor - pointer to csrdef
    */


sword ocir32(  struct csrdef *cursor, sword retcode  );
   /*   
   ** Convert selected version 3 return codes to the equivalent version 2 
   ** code.
   **
   **    cursor - pointer to csrdef
   **    retcode - place to store the return code
   */


void ociscn(  sword **arglst, char *mask_addr, sword **newlst  );
   /*
   ** Convert call-by-ref to call-by-value:
   ** takes an arg list and a mask address, determines which args need 
   ** conversion to a value, and creates a new list begging at the address
   ** of newlst.
   **
   **    arglst    - list of arguments
   **    mast_addr _ mask address determines args needing conversion
   **    newlst    - new list of args
   */

sword    ocistf (  sword typ, sword bufl, sword rdig, oratext *fmt, 
                      struct csrdef *cursor, sword *err  );
/*  Convert a packed  decimal buffer  length  (bytes) and scale to a format
**  string of the form mm.+/-nn, where  mm is the number of packed 
**  decimal digits, and nn is the scaling factor.   A positive scale name 
**  nn digits to the rights of the decimal; a negative scale means nn zeros 
**  should be supplied to the left of the decimal.
**     bufl   - length of the packed decimal buffer
**     rdig   - number of fractional digits
**     fmt    - pointer to a string holding the conversion format
**     cursor - pointer to csrdef 
**     err    - pointer to word storing error code
*/ 


/******************************************/
/*         Non-blocking operations        */
/******************************************/
sword ocinbs(  ldadef *lda  );  /* set a connection to non-blocking   */
sword ocinbt(  ldadef *lda  );  /* test if connection is non-blocking */
sword ocinbc(  ldadef *lda  );  /* clear a connection to blocking     */
sword ocinlo(  ldadef *lda, struct hstdef *hst, oratext *conn,
                  sword connl, oratext *uid, sword uidl,
                  oratext *psw, sword pswl, sword audit  );  
              /* logon in non-blocking fashion */
/* ocinlo allows an application to logon in non-blocking fashion.
**   lda     - pointer to ldadef
**   hst     - pointer to a 256 byte area, must be cleared to zero before call
**   conn    - the database link (if specified @LINK in uid will be ignored)
**   connl   - length of conn; if -1 strlen(conn) is used   
**   uid     - user id [USER[/PASSWORD][@LINK]]
**   uidl    - length of uid, if -1 strlen(uid) is used
**   psw     - password string; ignored if specified in uid
**   pswl    - length of psw, if -1 strlen(psw) is used
**   audit   - is not supported; the only permissible value is 0
*/

/***************************************************/
/*         Procedure Declaration for Pro*C         */
/***************************************************/
/* Note: The following routines are used in Pro*C and have the
   same interface as their couterpart in OCI. 
   Althought the interface follows for more details please refer 
   to the above routines */

/******************************************/
/*         initialization/logon/logof     */
/******************************************/
sword ocipin(  ub4 mode  );

sword ologin(  ldadef *lda, sb2 areacount  );
sword ologon(  ldadef *lda, sb2 areacount  );

/*****************************************/
/*        Open/Close/Parse Cursor        */
/*****************************************/

/* 
** ocisqd - oci delayed parse (Should be used only with deferred upi/oci)
** FUNCTION: Call upidpr to delay the parse of the sql statement till the
**           time that a call needs to be made to the kernel (execution or
**           describe time )
** RETURNS: Oracle return code.
*/ 
sword ocisq7( struct csrdef *cursor, oratext * /* sqlstm */, sb4 sqllen,
                 sword defflg, ub4 sqlt );

/*****************************************/
/*            Bind                       */
/*****************************************/
sword obind(  struct csrdef *cursor, oratext *sqlvar, sword sqlvl, 
                 ub1 *progv, sword progvl, sword ftype, sword scale, 
                 oratext *fmt, sword fmtl, sword fmtt  );
sword obindn(  struct csrdef *cursor, ub2 sqlvn, ub1 *progv, sword progvl,
                  sword ftype, sword scale, oratext *fmt, sword fmtl, 
                  sword fmtt  );

/**********************************************/
/*                 Define                     */
/**********************************************/
sword odfinn(  struct csrdef *cursor, sword pos, ub1 *buf, sword bufl,
                  sword ftype, sb2 *rc, sword scale  );

/**********************************************/
/*                 Describe                   */
/**********************************************/
sword odsrbn(  struct csrdef *cursor, sword pos, sb2 *dbsize, sb2 *dtype, 
            sb2 *fsize  );


/******************************************/
/*         Non-blocking operations        */
/******************************************/
sword onblon(  ldadef *lda, struct hstdef *hst, oratext *conn,
                  sword connl, oratext *uid, sword uidl,
                  oratext *psw, sword pswl, sword audit  );  
              /* logon in non-blocking fashion */
sword ocignfd(  ldadef *lda, void  *nfdp );           /* get native fd */

ub2   ocigft_getFcnType(  ub2 oertyp  );      /* get sql function code */

#endif
       usr/include/oracle/19.6/client64/ocidem.h                                                           0000644 0000000 0000000 00000007720 13576202531 016415  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * 
 */

/* Copyright (c) 1991, 2005, Oracle. All rights reserved.  */
/* Copyright (c) 1991, 2005, Oracle. All rights reserved.  */
/*
   NAME
     ocidem.h - OCI demo header
   MODIFIED   (MM/DD/YY)
    dmukhin    06/29/05  - ANSI prototypes; miscellaneous cleanup 
    whe        04/07/99 -  bug#810071
    whe        03/19/99 -  lrg 32079 etc.: putting static back for oci_func_tab
    nmacnaug   02/02/99 -  static declarations should not be in header files
    mygopala   09/22/97 -  Fix for bug 550351
    surman     03/14/97 -  Merge 413362 to 8.0.3
    surman     11/08/96 -  413362: Add SS_64BIT_SERVER macro
    emendez    04/07/94 -  merge changes from branch 1.6.710.1
    emendez    02/02/94 -  Fix for bug 157576
    jnlee      01/05/93 -  include oratypes.h once, make oci_func_tab static
    rkooi2     10/26/92 -  More portability mods 
    rkooi2     10/22/92 -  Change text back to char to avoid casts 
    rkooi2     10/20/92 -  Changes to make it portable 
    sjain      03/16/92 -  Creation 
*/

/*
 *  ocidem.h
 *
 *  Declares additional functions and data structures
 *  used in the OCI C sample programs.
 */


#ifndef ORATYPES
#include <oratypes.h>
#endif /* ORATYPES */

#ifndef OCIDFN
#include <ocidfn.h>
#endif /* OCIDFN */

#ifndef OCIDEM
#define OCIDEM


/*  internal/external datatype codes */
#define VARCHAR2_TYPE            1
#define NUMBER_TYPE              2
#define INT_TYPE                 3
#define FLOAT_TYPE               4
#define STRING_TYPE              5
#define ROWID_TYPE              11
#define DATE_TYPE               12

/*  ORACLE error codes used in demonstration programs */
#define VAR_NOT_IN_LIST       1007
#ifndef NO_DATA_FOUND
#  define NO_DATA_FOUND         1403
#endif
#define NULL_VALUE_RETURNED   1405

/*  some SQL and OCI function codes */
#define FT_INSERT                3
#define FT_SELECT                4
#define FT_UPDATE                5
#define FT_DELETE                9

#define FC_OOPEN                14

/*
 *  OCI function code labels,
 *  corresponding to the fc numbers
 *  in the cursor data area.
 */
static const text  *oci_func_tab[] =  {(text *) "not used",
/* 1-2 */       (text *) "not used", (text *) "OSQL",
/* 3-4 */       (text *) "not used", (text *) "OEXEC, OEXN",
/* 5-6 */       (text *) "not used", (text *) "OBIND",
/* 7-8 */       (text *) "not used", (text *) "ODEFIN",
/* 9-10 */      (text *) "not used", (text *) "ODSRBN",
/* 11-12 */     (text *) "not used", (text *) "OFETCH, OFEN",
/* 13-14 */     (text *) "not used", (text *) "OOPEN",
/* 15-16 */     (text *) "not used", (text *) "OCLOSE",
/* 17-18 */     (text *) "not used", (text *) "not used",
/* 19-20 */     (text *) "not used", (text *) "not used",
/* 21-22 */     (text *) "not used", (text *) "ODSC",
/* 23-24 */     (text *) "not used", (text *) "ONAME",
/* 25-26 */     (text *) "not used", (text *) "OSQL3",
/* 27-28 */     (text *) "not used", (text *) "OBNDRV",
/* 29-30 */     (text *) "not used", (text *) "OBNDRN",
/* 31-32 */     (text *) "not used", (text *) "not used",
/* 33-34 */     (text *) "not used", (text *) "OOPT",
/* 35-36 */     (text *) "not used", (text *) "not used",
/* 37-38 */     (text *) "not used", (text *) "not used",
/* 39-40 */     (text *) "not used", (text *) "not used",
/* 41-42 */     (text *) "not used", (text *) "not used",
/* 43-44 */     (text *) "not used", (text *) "not used",
/* 45-46 */     (text *) "not used", (text *) "not used",
/* 47-48 */     (text *) "not used", (text *) "not used",
/* 49-50 */     (text *) "not used", (text *) "not used",
/* 51-52 */     (text *) "not used", (text *) "OCAN",
/* 53-54 */     (text *) "not used", (text *) "OPARSE",
/* 55-56 */     (text *) "not used", (text *) "OEXFET",
/* 57-58 */     (text *) "not used", (text *) "OFLNG",
/* 59-60 */     (text *) "not used", (text *) "ODESCR",
/* 61-62 */     (text *) "not used", (text *) "OBNDRA",
/* 63-64 */     (text *) "OBINDPS",  (text *) "ODEFINPS",
/* 65-66 */     (text *) "OGETPI",   (text *) "OSETPI"
};

#endif      /* OCIDEM */

                                                usr/include/oracle/19.6/client64/ocidfn.h                                                           0000644 0000000 0000000 00000027006 13576202531 016416  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* Copyright (c) 1991, 2012, Oracle and/or its affiliates. 
All rights reserved. */
/*
   NAME
     ocidfn.h - OCI Definations
   NOTES
     Shipped to users.
   MODIFIED   (MM/DD/YY)
    kkverma    12/19/12 - define host area type
    sagrawal   12/03/10 - Boolean Binds
    mbastawa   09/16/05 - dbhygiene
    dmukhin    06/29/05 - ANSI prototypes; miscellaneous cleanup 
    srseshad   11/25/02 - change binary float/double codes
    srseshad   11/14/02 - Add SQLT_IBFLOAT, SQLT_IBDOUBLE
    mxyang     09/17/02 - grabtrans 'mmorsi_obj_float'
    srseshad   09/06/02 - Add binary float/double
    aahluwal   06/04/02 - bug 2360115
    kmuthukk   05/02/00 - add SQLT_PNTY
    amangal    07/30/99 - Merge into 8.1.6 : Bug 879031
    tnbui      07/28/99 - Remove SQLT_TIMESTAMP_ITZ                            
    tnbui      07/21/99 - SQLT_TIMESTAMP_LTZ                                   
    tnbui      06/16/99 - TIMESTAMP WITH IMPLICIT TIME ZONE                    
    whe        04/07/99 - bug#810075
    whe        03/19/99 - lrg 32079 etc.: move HDA def from ocidem.h to ocidfn.
    skmishra   05/10/98 -
    vyanaman   04/16/98 - update sql92 datatypes
    khnguyen   01/16/98 -
    khnguyen   12/23/97 - SQLT* for datetimes and intervals
    tanguyen   08/19/97 -
    dchatter   03/18/97 -  porting exception 390897
    dchatter   05/02/97 -   merge porting exception
    dalpern    12/04/96 -   SQLCS_LIT_NULL added
    cxcheng    11/14/96 -   add SQLT_BFILE/SQLT_CFILE to fix compile prob
    cxcheng    11/12/96 -   add SQLT_NCO for named collection
    lchidamb   10/17/96 -   add SQLT_VST and SQLT_ODT
    sgollapu   10/14/96 -   Mutual exclusion of ocidfn and sqldef
    sgollapu   10/07/96 -   OCI Simplification
    aroy       09/09/96 -   add SQLCS* definitions
    slari      08/07/96 -  add SQLT_RDD, rowid descriptor
    slari      06/12/96 -  remove SQLT_TTBL
    dchatter   04/21/96 -  prepare for merge into main
    slari      08/24/95 -  b299432, define CDA_SIZE
    zwalcott   02/28/96 -  add SQLT_BFILEE and SQLT_CFILEE.
    lchidamb   02/22/96 -  make dtys consistent with dtydef.h
    lchidamb   02/16/96 -  add SQLT_BFILEE and SQLT_CFILEE
    lchidamb   01/30/96 -  rename new datatypes for v8
    lchidamb   09/06/95 -  add new datatypes
    slari      05/11/95 -  add OCI_EV_DEF and OCI_EV_TSF
    dchatter   04/06/95 -  add ifdef flags around OCI_flags
    dchatter   03/08/95 -  piece values
    dchatter   03/06/95 -  merge changes from branch 1.2.720.3
    jfbrown    02/17/95 -  merge changes from branch 1.2.720.2
    dchatter   02/08/95 -  olog call modes
    jfbrown    02/03/95 -  remove non-printable characters
    lchidamb   12/06/94 -  merge changes from branch 1.2.720.1
    lchidamb   10/04/94 -  added field chk to cda_head, cda_def
    dchatter   07/05/94 -  SQLT_CUR added
    rkooi2     11/27/92 -  Changing e* datatypes to s* 
    rkooi2     10/26/92 -  More portability mods 
    rkooi2     10/22/92 -  Added #ifndef ORATYPES ... 
    rkooi2     10/18/92 -  Changes to make it portable. 
    sjain      03/16/92 -  Creation 
*/

/*
 *  ocidfn.h
 *
 *  Common header file for OCI C sample programs.
 *  This header declares the cursor and logon data area structure.
 *  The types used are defined in <oratypes.h>.
 *
 */
 
#ifndef OCIDFN
#define OCIDFN

#include <oratypes.h>

/* The cda_head struct is strictly PRIVATE.  It is used
   internally only. Do not use this struct in OCI programs. */

struct cda_head {
    sb2          v2_rc;
    ub2          ft;
    ub4          rpc;
    ub2          peo;
    ub1          fc;
    ub1          rcs1;
    ub2          rc;
    ub1          wrn;
    ub1          rcs2;
    sword        rcs3;
    struct {
        struct {
           ub4    rcs4;
           ub2    rcs5;
           ub1    rcs6;
        } rd;
        ub4    rcs7;
        ub2    rcs8;
    } rid;
    sword        ose;
    ub1           chk;
    void         *rcsp;
};

/*
** Size of HDA area:
** 512 for 64 bit arquitectures
** 256 for 32 bit arquitectures
*/

#if defined(SS_64BIT_SERVER) || defined(__64BIT__)
# define HDA_SIZE 512
#else
# define HDA_SIZE 256
#endif

#if defined(SS_64BIT_SERVER) || defined(__64BIT__)
#define CDA_SIZE 88
#else
# define CDA_SIZE 64
#endif

/* the real CDA, padded to CDA_SIZE bytes in size */
struct cda_def {
    sb2          v2_rc;                                    /* V2 return code */
    ub2          ft;                                    /* SQL function type */
    ub4          rpc;                                /* rows processed count */
    ub2          peo;                                  /* parse error offset */
    ub1          fc;                                    /* OCI function code */
    ub1          rcs1;                                        /* filler area */
    ub2          rc;                                       /* V7 return code */
    ub1          wrn;                                       /* warning flags */
    ub1          rcs2;                                           /* reserved */
    sword        rcs3;                                           /* reserved */
    struct {                                              /* rowid structure */
        struct {
           ub4    rcs4;
           ub2    rcs5;
           ub1    rcs6;
        } rd;
        ub4    rcs7;
        ub2    rcs8;
    } rid;
    sword        ose;                                 /* OSD dependent error */
    ub1           chk;
    void         *rcsp;                          /* pointer to reserved area */
    ub1          rcs9[CDA_SIZE - sizeof (struct cda_head)];        /* filler */
};

typedef struct cda_def Cda_Def;

/* the logon data area (LDA)
   is the same shape as the CDA */
typedef struct cda_def Lda_Def;

/* define host area type */
typedef ub8 Hda_AlignType;
typedef Hda_AlignType Hda_Def[HDA_SIZE/sizeof(Hda_AlignType)];

/* OCI Environment Modes for opinit call */
#define OCI_EV_DEF 0                  /* default single-threaded environment */
#define OCI_EV_TSF 1                              /* thread-safe environment */

/* OCI Logon Modes for olog call */
#define OCI_LM_DEF 0                                        /* default login */
#define OCI_LM_NBL 1                                   /* non-blocking logon */

/* 
 * since sqllib uses both ocidef and ocidfn the following defines
 * need to be guarded
 */
#ifndef OCI_FLAGS 
#define OCI_FLAGS

/* OCI_*_PIECE defines the piece types that are returned or set
*/
#define OCI_ONE_PIECE   0                 /* there or this is the only piece */
#define OCI_FIRST_PIECE 1                        /* the first of many pieces */
#define OCI_NEXT_PIECE  2                         /* the next of many pieces */
#define OCI_LAST_PIECE  3                   /* the last piece of this column */
#endif

#ifndef SQLDEF 

/* input data types */
#define SQLT_CHR  1                        /* (ORANET TYPE) character string */
#define SQLT_NUM  2                          /* (ORANET TYPE) oracle numeric */
#define SQLT_INT  3                                 /* (ORANET TYPE) integer */
#define SQLT_FLT  4                   /* (ORANET TYPE) Floating point number */
#define SQLT_STR  5                                /* zero terminated string */
#define SQLT_VNU  6                        /* NUM with preceding length byte */
#define SQLT_PDN  7                  /* (ORANET TYPE) Packed Decimal Numeric */
#define SQLT_LNG  8                                                  /* long */
#define SQLT_VCS  9                             /* Variable character string */
#define SQLT_NON  10                      /* Null/empty PCC Descriptor entry */
#define SQLT_RID  11                                                /* rowid */
#define SQLT_DAT  12                                /* date in oracle format */
#define SQLT_VBI  15                                 /* binary in VCS format */
#define SQLT_BFLOAT 21                                /* Native Binary float*/
#define SQLT_BDOUBLE 22                             /* NAtive binary double */
#define SQLT_BIN  23                                  /* binary data(DTYBIN) */
#define SQLT_LBI  24                                          /* long binary */
#define SQLT_UIN  68                                     /* unsigned integer */
#define SQLT_SLS  91                        /* Display sign leading separate */
#define SQLT_LVC  94                                  /* Longer longs (char) */
#define SQLT_LVB  95                                   /* Longer long binary */
#define SQLT_AFC  96                                      /* Ansi fixed char */
#define SQLT_AVC  97                                        /* Ansi Var char */
#define SQLT_IBFLOAT  100                          /* binary float canonical */
#define SQLT_IBDOUBLE 101                         /* binary double canonical */
#define SQLT_CUR  102                                        /* cursor  type */
#define SQLT_RDD  104                                    /* rowid descriptor */
#define SQLT_LAB  105                                          /* label type */
#define SQLT_OSL  106                                        /* oslabel type */

#define SQLT_NTY  108                                   /* named object type */
#define SQLT_REF  110                                            /* ref type */
#define SQLT_CLOB 112                                       /* character lob */
#define SQLT_BLOB 113                                          /* binary lob */
#define SQLT_BFILEE 114                                   /* binary file lob */
#define SQLT_CFILEE 115                                /* character file lob */
#define SQLT_RSET 116                                     /* result set type */
#define SQLT_NCO  122      /* named collection type (varray or nested table) */
#define SQLT_VST  155                                      /* OCIString type */
#define SQLT_ODT  156                                        /* OCIDate type */

/* datetimes and intervals */
#define SQLT_DATE                      184                      /* ANSI Date */
#define SQLT_TIME                      185                           /* TIME */
#define SQLT_TIME_TZ                   186            /* TIME WITH TIME ZONE */
#define SQLT_TIMESTAMP                 187                      /* TIMESTAMP */
#define SQLT_TIMESTAMP_TZ              188       /* TIMESTAMP WITH TIME ZONE */
#define SQLT_INTERVAL_YM               189         /* INTERVAL YEAR TO MONTH */
#define SQLT_INTERVAL_DS               190         /* INTERVAL DAY TO SECOND */
#define SQLT_TIMESTAMP_LTZ             232        /* TIMESTAMP WITH LOCAL TZ */



#define SQLT_PNTY   241              /* pl/sql representation of named types */

/* some pl/sql specific types */
#define SQLT_REC    250                     /* pl/sql 'record' (or %rowtype) */
#define SQLT_TAB    251                            /* pl/sql 'indexed table' */
#define SQLT_BOL    252                                  /* pl/sql 'boolean' */

/* cxcheng: this has been added for backward compatibility -
   it needs to be here because ocidfn.h can get included ahead of sqldef.h */
#define SQLT_FILE SQLT_BFILEE                             /* binary file lob */
#define SQLT_CFILE SQLT_CFILEE
#define SQLT_BFILE SQLT_BFILEE
 
/* CHAR/NCHAR/VARCHAR2/NVARCHAR2/CLOB/NCLOB char set "form" information */
#define SQLCS_IMPLICIT 1     /* for CHAR, VARCHAR2, CLOB w/o a specified set */
#define SQLCS_NCHAR    2                  /* for NCHAR, NCHAR VARYING, NCLOB */
#define SQLCS_EXPLICIT 3   /* for CHAR, etc, with "CHARACTER SET ..." syntax */
#define SQLCS_FLEXIBLE 4                 /* for PL/SQL "flexible" parameters */
#define SQLCS_LIT_NULL 5      /* for typecheck of NULL and empty_clob() lits */

#endif  /* SQLDEF */
#endif  /* OCIDFN */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/include/oracle/19.6/client64/ociextp.h                                                          0000644 0000000 0000000 00000021371 13576202531 016626  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * 
 */

/* Copyright (c) 1996, 2005, Oracle. All rights reserved.  */
 
/* 
   NAME 
     ociextp.h - Interface Definitions for PL/SQL External Procedures

   DESCRIPTION 
     This header file contains C language callable interface from 
     PL/SQL External Procedures.

   PUBLIC FUNCTION(S) 
     OCIExtProcAllocCallMemory  - Allocate Call memory
     OCIExtProcRaiseExcp        - Raise Exception
     OCIExtProcRaiseExcpWithMsg - Raise Exception with message
     OCIExtProcGetEnv           - Get OCI Environment

   PRIVATE FUNCTION(S)
     <list of static functions defined in .c file - with one-line descriptions>

   EXAMPLES

   NOTES
     <other useful comments, qualifications, etc.>

   MODIFIED   (MM/DD/YY)
   dmukhin     06/29/05 - ANSI prototypes; miscellaneous cleanup 
   srseshad    03/12/03 - convert oci public api to ansi
   rdecker     01/10/02 - change 32k to MAX_OEN for error numbers
   sagrawal    07/20/01 - Statement Handle to safe cal outs
   abrumm      04/19/01 - move include of oci.h after defines/typedef
   rdecker     02/22/01 - lint fix
   bpalaval    02/08/01 - Change text to oratext.
   sagrawal    06/16/00 - ref cursor in callouts
   whe         09/01/99 - 976457:check __cplusplus for C++ code
   asethi      04/15/99 - Created (by moving ociextp.h from /vobs/plsql/public)
   rhari       03/25/97 - Use ifndef
   rhari       12/18/96 - Include oratypes.h
   rhari       12/11/96 - #416977, Flip values of return codes
   rhari       12/02/96 - Define Return Code Macros
   rhari       11/18/96 - Error number is int
   rhari       10/30/96 - Fix OCIExtProcRaiseExcpWithMsg
   rhari       10/30/96 - Get rid of warnings
   rhari       10/04/96 - Fix OCIExtProcRaiseExcpWithMsg
   rhari       09/23/96 - Creation

*/

 
#ifndef OCIEXTP_ORACLE
# define OCIEXTP_ORACLE

# ifndef ORATYPES 
#  include <oratypes.h> 
# endif


/*---------------------------------------------------------------------------
                     PUBLIC TYPES AND CONSTANTS
  ---------------------------------------------------------------------------*/


/* ----------------------------- Return Codes ----------------------------- */
/* Success and Error return codes for certain external procedure interface 
 * functions. If a particular interface function returns OCIEXTPROC_SUCCESS
 * or OCIEXTPROC_ERROR, then applications must use these macros to check
 * for return values.
 *
 *     OCIEXTPROC_SUCCESS  -- External Procedure Success Return Code 
 *     OCIEXTPROC_ERROR    -- External Procedure Failure Return Code 
 */
#define OCIEXTPROC_SUCCESS 0
#define OCIEXTPROC_ERROR   1


/* --------------------------- With-Context Type --------------------------- */
/*
 * The C callable interface to PL/SQL External Procedures require the 
 * With-Context parameter to be passed. The type of this structure is 
 * OCIExtProcContext is is opaque to the user.
 *
 * The user can declare the With-Context parameter in the application as
 *
 *    OCIExtProcContext *with_context;
 */
typedef struct OCIExtProcContext OCIExtProcContext;

/* NOTE: OCIExtProcContext must be visible prior to including <oci.h> */

# ifndef OCI_ORACLE
#  include <oci.h>
# endif


/* ----------------------- OCIExtProcAllocCallMemory ----------------------- */
/* OCIExtProcAllocCallMemory
 *    Allocate N bytes of memory for the duration of the External Procedure.
 *
 *    Memory thus allocated will be freed by PL/SQL upon return from the
 *    External Procedure. You must not use any kind of 'free' function on 
 *    memory allocated by OCIExtProcAllocCallMemory.
 *    Use this function to allocate memory for function returns.
 * 
 * PARAMETERS
 * Input : 
 *    with_context - The with_context pointer that is passed to the C 
 *                   External Procedure.
 *                  Type of with_context : OCIExtProcContext *
 *    amount       - The number of bytes to allocate.
 *                   Type of amount : size_t
 *
 * Output :
 *    Nothing
 *
 * Return :
 *    An untyped (opaque) Pointer to the allocated memory. 
 *
 * Errors :
 *    A 0 return value should be treated as an error
 *
 * EXAMPLE 
 *  text *ptr = (text *)OCIExtProcAllocCallMemory(wctx, 1024)
 *
 */
#define OCIExtProcAllocCallMemory(with_context, amount) \
ociepacm(with_context, (size_t)amount)




/* -------------------------- OCIExtProcRaiseExcp -------------------------- */
/* OCIExtProcRaiseExcp
 *    Raise an Exception to PL/SQL.
 *
 *  Calling this function signalls an exception back to PL/SQL. After a
 *  successful return from this function, the External Procedure must start 
 *  its exit handling and return back to PL/SQL. Once an exception is 
 *  signalled to PL/SQL, INOUT and OUT arguments, if any, are not processed 
 *  at all.
 * 
 * PARAMETERS
 * Input :
 *   with_context - The with_context pointer that is passed to the C
 *                  External Procedure. 
 *                  Type of with_context : OCIExtProcContext *
 *   errnum       - Oracle Error number to signal to PL/SQL. errnum
 *                  must be a positive number and in the range 1 to MAX_OEN
 *                  Type of errnum : int
 * Output :
 *   Nothing
 *
 * Return :
 *   OCIEXTPROC_SUCCESS - If the call was successful.
 *   OCIEXTPROC_ERROR   - If the call failed.
 *
 */
#define OCIExtProcRaiseExcp(with_context, errnum) \
ocieperr(with_context, (int)errnum)





/* ---------------------- OCIExtProcRaiseExcpWithMsg ---------------------- */
/* OCIExtProcRaiseExcpWithMsg
 *    Raise an exception to PL/SQL. In addition, substitute the
 *    following error message string within the standard Oracle error 
 *    message string. See note for OCIExtProcRaiseExcp
 * 
 * PARAMETERS
 * Input :
 *   with_context  - The with_context pointer that is passed to the C
 *                   External Procedure.
 *                   Type of with_context : OCIExtProcContext *
 *   errnum        - Oracle Error number to signal to PL/SQL. errnum
 *                   must be a positive number and in the range 1 to MAX_OEN
 *                   Type of errnum : int
 *   errmsg        - The error message associated with the errnum.
 *                   Type of errmsg : char *
 *   len           - The length of the error message. 0 if errmsg is
 *                   null terminated string.
 *                   Type of len : size_t
 * Output :
 *   Nothing
 *
 * Return :
 *  OCIEXTPROC_SUCCESS - If the call was successful.
 *  OCIEXTPROC_ERROR   - If the call failed.
 *
 */
#define OCIExtProcRaiseExcpWithMsg(with_context, errnum, errmsg, msglen) \
ociepmsg(with_context, (int)errnum, errmsg, (size_t)msglen)



/* --------------------------- OCIExtProcGetEnv --------------------------- */
/* OCIExtProcGetEnv
 *    Get OCI Environment
 * 
 * PARAMETERS
 * Input :
 *    with_context - The with_context pointer that is passed to the C
 *                   External Procedure.
 *
 * Output :
 *    envh - The OCI Environment handle.
 *    svch - The OCI Service handle.
 *    errh - The OCI Error handle.
 *
 * Return :
 *  OCI_SUCCESS - Successful completion of the function.
 *  OCI_ERROR   - Error.
 *
 */
#define OCIExtProcGetEnv(with_context, envh, svch, errh) \
ociepgoe(with_context, envh, svch, errh)



/* ------------------------ OCIInitializeStatementHandle ------------------- */
/* OCIreateStatementHandle
 *    Initialize Statement Handle
 * 
 * PARAMETERS
 * Input :
 *    wctx     - The 
 *    cursorno - The cursor number for which we need to initialize
 *               the statement handle
 *    svch     - The OCI Service handle.
 *
 * Output :
 *    stmthp - The OCI Statement handle.
 *    errh   - The OCI Error handle.
 *
 * Return :
 *  OCI_SUCCESS - Successful completion of the function.
 *  OCI_ERROR   - Error.
 *
 */
#define OCIInitializeStatementHandle(wctx, cursorno,  svch, stmthp, errh) \
ociepish(wctx, cursor, svch, stmthp, errh)




/*---------------------------------------------------------------------------
                     PRIVATE TYPES AND CONSTANTS
  ---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
                           PUBLIC FUNCTIONS
  ---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
                          PRIVATE FUNCTIONS
  ---------------------------------------------------------------------------*/



void  *ociepacm(OCIExtProcContext *with_context, size_t amount);



size_t ocieperr(OCIExtProcContext *with_context, int error_number);



size_t ociepmsg(OCIExtProcContext *with_context, int error_number,
                oratext *error_message, size_t len );



sword ociepgoe(OCIExtProcContext *with_context, OCIEnv **envh, 
               OCISvcCtx **svch, OCIError **errh);


#endif                                                     /* OCIEXTP_ORACLE */
                                                                                                                                                                                                                                                                       usr/include/oracle/19.6/client64/ocikpr.h                                                           0000644 0000000 0000000 00000014536 13576202531 016447  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* Copyright (c) 1991, 2005, Oracle. All rights reserved.  */
/*
   NAME
     ocikpr.h - header of K & R compilers
   MODIFIED   (MM/DD/YY)
    mbastawa   09/16/05 - dbhygiene 
    porangas   12/04/00 - Forward merge bug#974710 to 9i
    sgollapu   05/19/98 - Change text to OraText
