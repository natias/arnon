    \ , "SPARC.CodeGen.Amode"
    \ , "SPARC.CodeGen.Base"
    \ , "SPARC.CodeGen.CondCode"
    \ , "SPARC.CodeGen.Expand"
    \ , "SPARC.CodeGen.Gen32"
    \ , "SPARC.CodeGen.Gen64"
    \ , "SPARC.CodeGen.Sanity"
    \ , "SPARC.Cond"
    \ , "SPARC.Imm"
    \ , "SPARC.Instr"
    \ , "SPARC.Ppr"
    \ , "SPARC.Regs"
    \ , "SPARC.ShortcutJump"
    \ , "SPARC.Stack"
    \ , "SetLevels"
    \ , "SimplCore"
    \ , "SimplEnv"
    \ , "SimplMonad"
    \ , "SimplStg"
    \ , "SimplUtils"
    \ , "Simplify"
    \ , "SpecConstr"
    \ , "Specialise"
    \ , "SrcLoc"
    \ , "State"
    \ , "StaticPtrTable"
    \ , "StgCmm"
    \ , "StgCmmArgRep"
    \ , "StgCmmBind"
    \ , "StgCmmClosure"
    \ , "StgCmmCon"
    \ , "StgCmmEnv"
    \ , "StgCmmExpr"
    \ , "StgCmmExtCode"
    \ , "StgCmmForeign"
    \ , "StgCmmHeap"
    \ , "StgCmmHpc"
    \ , "StgCmmLayout"
    \ , "StgCmmMonad"
    \ , "StgCmmPrim"
    \ , "StgCmmProf"
    \ , "StgCmmTicky"
    \ , "StgCmmUtils"
    \ , "StgCse"
    \ , "StgLint"
    \ , "StgStats"
    \ , "StgSyn"
    \ , "Stream"
    \ , "StringBuffer"
    \ , "SysTools"
    \ , "SysTools.BaseDir"
    \ , "SysTools.ExtraObj"
    \ , "SysTools.Info"
    \ , "SysTools.Process"
    \ , "SysTools.Tasks"
    \ , "SysTools.Terminal"
    \ , "THNames"
    \ , "TargetReg"
    \ , "TcAnnotations"
    \ , "TcArrows"
    \ , "TcBackpack"
    \ , "TcBinds"
    \ , "TcCanonical"
    \ , "TcClassDcl"
    \ , "TcDefaults"
    \ , "TcDeriv"
    \ , "TcDerivInfer"
    \ , "TcDerivUtils"
    \ , "TcEnv"
    \ , "TcErrors"
    \ , "TcEvidence"
    \ , "TcExpr"
    \ , "TcFlatten"
    \ , "TcForeign"
    \ , "TcGenDeriv"
    \ , "TcGenFunctor"
    \ , "TcGenGenerics"
    \ , "TcHsSyn"
    \ , "TcHsType"
    \ , "TcIface"
    \ , "TcInstDcls"
    \ , "TcInteract"
    \ , "TcMType"
    \ , "TcMatches"
    \ , "TcPat"
    \ , "TcPatSyn"
    \ , "TcPluginM"
    \ , "TcRnDriver"
    \ , "TcRnExports"
    \ , "TcRnMonad"
    \ , "TcRnTypes"
    \ , "TcRules"
    \ , "TcSMonad"
    \ , "TcSigs"
    \ , "TcSimplify"
    \ , "TcSplice"
    \ , "TcTyClsDecls"
    \ , "TcTyDecls"
    \ , "TcType"
    \ , "TcTypeNats"
    \ , "TcTypeable"
    \ , "TcUnify"
    \ , "TcValidity"
    \ , "TidyPgm"
    \ , "TmOracle"
    \ , "ToIface"
    \ , "TrieMap"
    \ , "TyCoRep"
    \ , "TyCon"
    \ , "Type"
    \ , "TysPrim"
    \ , "TysWiredIn"
    \ , "UnVarGraph"
    \ , "UnariseStg"
    \ , "Unify"
    \ , "UniqDFM"
    \ , "UniqDSet"
    \ , "UniqFM"
    \ , "UniqMap"
    \ , "UniqSet"
    \ , "UniqSupply"
    \ , "Unique"
    \ , "Util"
    \ , "Var"
    \ , "VarEnv"
    \ , "VarSet"
    \ , "Vectorise"
    \ , "Vectorise.Builtins"
    \ , "Vectorise.Builtins.Base"
    \ , "Vectorise.Builtins.Initialise"
    \ , "Vectorise.Convert"
    \ , "Vectorise.Env"
    \ , "Vectorise.Exp"
    \ , "Vectorise.Generic.Description"
    \ , "Vectorise.Generic.PADict"
    \ , "Vectorise.Generic.PAMethods"
    \ , "Vectorise.Generic.PData"
    \ , "Vectorise.Monad"
    \ , "Vectorise.Monad.Base"
    \ , "Vectorise.Monad.Global"
    \ , "Vectorise.Monad.InstEnv"
    \ , "Vectorise.Monad.Local"
    \ , "Vectorise.Monad.Naming"
    \ , "Vectorise.Type.Classify"
    \ , "Vectorise.Type.Env"
    \ , "Vectorise.Type.TyConDecl"
    \ , "Vectorise.Type.Type"
    \ , "Vectorise.Utils"
    \ , "Vectorise.Utils.Base"
    \ , "Vectorise.Utils.Closure"
    \ , "Vectorise.Utils.Hoisting"
    \ , "Vectorise.Utils.PADict"
    \ , "Vectorise.Utils.Poly"
    \ , "Vectorise.Var"
    \ , "Vectorise.Vect"
    \ , "WorkWrap"
    \ , "WwLib"
    \ , "X86.CodeGen"
    \ , "X86.Cond"
    \ , "X86.Instr"
    \ , "X86.Ppr"
    \ , "X86.RegInfo"
    \ , "X86.Regs"
    \ , "Numeric.Half"
    \ , "Data.Hashable"
    \ , "Data.Hashable.Lifted"
    \ , "Language.Haskell.Lexer"
    \ , "Language.Haskell.ParseMonad"
    \ , "Language.Haskell.ParseUtils"
    \ , "Language.Haskell.Parser"
    \ , "Language.Haskell.Pretty"
    \ , "Language.Haskell.Syntax"
    \ , "Control.Monad"
    \ , "Data.Array"
    \ , "Data.Bits"
    \ , "Data.Char"
    \ , "Data.Complex"
    \ , "Data.Int"
    \ , "Data.Ix"
    \ , "Data.List"
    \ , "Data.Maybe"
    \ , "Data.Ratio"
    \ , "Data.Word"
    \ , "Foreign"
    \ , "Foreign.C"
    \ , "Foreign.C.Error"
    \ , "Foreign.C.String"
    \ , "Foreign.C.Types"
    \ , "Foreign.ForeignPtr"
    \ , "Foreign.Marshal"
    \ , "Foreign.Marshal.Alloc"
    \ , "Foreign.Marshal.Array"
    \ , "Foreign.Marshal.Error"
    \ , "Foreign.Marshal.Utils"
    \ , "Foreign.Ptr"
    \ , "Foreign.StablePtr"
    \ , "Foreign.Storable"
    \ , "Numeric"
    \ , "Prelude"
    \ , "System.Environment"
    \ , "System.Exit"
    \ , "System.IO"
    \ , "System.IO.Error"
    \ , "Array"
    \ , "Bits"
    \ , "CError"
    \ , "CForeign"
    \ , "CPUTime"
    \ , "CString"
    \ , "CTypes"
    \ , "Char"
    \ , "Complex"
    \ , "Directory"
    \ , "ForeignPtr"
    \ , "IO"
    \ , "Int"
    \ , "Ix"
    \ , "List"
    \ , "Locale"
    \ , "MarshalAlloc"
    \ , "MarshalArray"
    \ , "MarshalError"
    \ , "MarshalUtils"
    \ , "Maybe"
    \ , "Monad"
    \ , "Numeric"
    \ , "Prelude"
    \ , "Ptr"
    \ , "Random"
    \ , "Ratio"
    \ , "StablePtr"
    \ , "Storable"
    \ , "System"
    \ , "Time"
    \ , "Word"
    \ , "Trace.Hpc.Mix"
    \ , "Trace.Hpc.Reflect"
    \ , "Trace.Hpc.Tix"
    \ , "Trace.Hpc.Util"
    \ , "Text.Html"
    \ , "Text.Html.BlockTable"
    \ , "GHC.Integer.Logarithms.Compat"
    \ , "Math.NumberTheory.Logarithms"
    \ , "Math.NumberTheory.Powers.Integer"
    \ , "Math.NumberTheory.Powers.Natural"
    \ , "Control.Monad.Cont"
    \ , "Control.Monad.Cont.Class"
    \ , "Control.Monad.Error"
    \ , "Control.Monad.Error.Class"
    \ , "Control.Monad.Except"
    \ , "Control.Monad.Identity"
    \ , "Control.Monad.List"
    \ , "Control.Monad.RWS"
    \ , "Control.Monad.RWS.Class"
    \ , "Control.Monad.RWS.Lazy"
    \ , "Control.Monad.RWS.Strict"
    \ , "Control.Monad.Reader"
    \ , "Control.Monad.Reader.Class"
    \ , "Control.Monad.State"
    \ , "Control.Monad.State.Class"
    \ , "Control.Monad.State.Lazy"
    \ , "Control.Monad.State.Strict"
    \ , "Control.Monad.Trans"
    \ , "Control.Monad.Writer"
    \ , "Control.Monad.Writer.Class"
    \ , "Control.Monad.Writer.Lazy"
    \ , "Control.Monad.Writer.Strict"
    \ , "Network.Multipart"
    \ , "Network.Multipart.Header"
    \ , "Network"
    \ , "Network.BSD"
    \ , "Network.Socket"
    \ , "Network.Socket.ByteString"
    \ , "Network.Socket.ByteString.Lazy"
    \ , "Network.Socket.Internal"
    \ , "Network.URI"
    \ , "System.Locale"
    \ , "System.Time"
    \ , "Control.Parallel"
    \ , "Control.Parallel.Strategies"
    \ , "Control.Seq"
    \ , "Text.Parsec"
    \ , "Text.Parsec.ByteString"
    \ , "Text.Parsec.ByteString.Lazy"
    \ , "Text.Parsec.Char"
    \ , "Text.Parsec.Combinator"
    \ , "Text.Parsec.Error"
    \ , "Text.Parsec.Expr"
    \ , "Text.Parsec.Language"
    \ , "Text.Parsec.Perm"
    \ , "Text.Parsec.Pos"
    \ , "Text.Parsec.Prim"
    \ , "Text.Parsec.String"
    \ , "Text.Parsec.Text"
    \ , "Text.Parsec.Text.Lazy"
    \ , "Text.Parsec.Token"
    \ , "Text.ParserCombinators.Parsec"
    \ , "Text.ParserCombinators.Parsec.Char"
    \ , "Text.ParserCombinators.Parsec.Combinator"
    \ , "Text.ParserCombinators.Parsec.Error"
    \ , "Text.ParserCombinators.Parsec.Expr"
    \ , "Text.ParserCombinators.Parsec.Language"
    \ , "Text.ParserCombinators.Parsec.Perm"
    \ , "Text.ParserCombinators.Parsec.Pos"
    \ , "Text.ParserCombinators.Parsec.Prim"
    \ , "Text.ParserCombinators.Parsec.Token"
    \ , "Text.PrettyPrint"
    \ , "Text.PrettyPrint.Annotated"
    \ , "Text.PrettyPrint.Annotated.HughesPJ"
    \ , "Text.PrettyPrint.Annotated.HughesPJClass"
    \ , "Text.PrettyPrint.HughesPJ"
    \ , "Text.PrettyPrint.HughesPJClass"
    \ , "Control.Monad.Primitive"
    \ , "Data.Primitive"
    \ , "Data.Primitive.Addr"
    \ , "Data.Primitive.Array"
    \ , "Data.Primitive.ByteArray"
    \ , "Data.Primitive.MVar"
    \ , "Data.Primitive.MachDeps"
    \ , "Data.Primitive.MutVar"
    \ , "Data.Primitive.PrimArray"
    \ , "Data.Primitive.Ptr"
    \ , "Data.Primitive.SmallArray"
    \ , "Data.Primitive.Types"
    \ , "Data.Primitive.UnliftedArray"
    \ , "System.Cmd"
    \ , "System.Process"
    \ , "System.Process.Internals"
    \ , "System.Random"
    \ , "Text.Regex.Base"
    \ , "Text.Regex.Base.Context"
    \ , "Text.Regex.Base.Impl"
    \ , "Text.Regex.Base.RegexLike"
    \ , "Text.Regex"
    \ , "Text.Regex.Posix"
    \ , "Text.Regex.Posix.ByteString"
    \ , "Text.Regex.Posix.ByteString.Lazy"
    \ , "Text.Regex.Posix.Sequence"
    \ , "Text.Regex.Posix.String"
    \ , "Text.Regex.Posix.Wrap"
    \ , "Data.ByteString.Builder.Scientific"
    \ , "Data.Scientific"
    \ , "Data.Text.Lazy.Builder.Scientific"
    \ , "Data.List.Split"
    \ , "Data.List.Split.Internals"
    \ , "Control.Concurrent.STM"
    \ , "Control.Concurrent.STM.TArray"
    \ , "Control.Concurrent.STM.TBQueue"
    \ , "Control.Concurrent.STM.TChan"
    \ , "Control.Concurrent.STM.TMVar"
    \ , "Control.Concurrent.STM.TQueue"
    \ , "Control.Concurrent.STM.TSem"
    \ , "Control.Concurrent.STM.TVar"
    \ , "Control.Monad.STM"
    \ , "Data.Generics"
    \ , "Data.Generics.Aliases"
    \ , "Data.Generics.Basics"
    \ , "Data.Generics.Builders"
    \ , "Data.Generics.Instances"
    \ , "Data.Generics.Schemes"
    \ , "Data.Generics.Text"
    \ , "Data.Generics.Twins"
    \ , "Generics.SYB"
    \ , "Generics.SYB.Aliases"
    \ , "Generics.SYB.Basics"
    \ , "Generics.SYB.Builders"
    \ , "Generics.SYB.Instances"
    \ , "Generics.SYB.Schemes"
    \ , "Generics.SYB.Text"
    \ , "Generics.SYB.Twins"
    \ , "Language.Haskell.TH"
    \ , "Language.Haskell.TH.LanguageExtensions"
    \ , "Language.Haskell.TH.Lib"
    \ , "Language.Haskell.TH.Lib.Internal"
    \ , "Language.Haskell.TH.Ppr"
    \ , "Language.Haskell.TH.PprLib"
    \ , "Language.Haskell.TH.Quote"
    \ , "Language.Haskell.TH.Syntax"
    \ , "Data.Text"
    \ , "Data.Text.Array"
    \ , "Data.Text.Encoding"
    \ , "Data.Text.Encoding.Error"
    \ , "Data.Text.Foreign"
    \ , "Data.Text.IO"
    \ , "Data.Text.Internal"
    \ , "Data.Text.Internal.Builder"
    \ , "Data.Text.Internal.Builder.Functions"
    \ , "Data.Text.Internal.Builder.Int.Digits"
    \ , "Data.Text.Internal.Builder.RealFloat.Functions"
    \ , "Data.Text.Internal.Encoding.Fusion"
    \ , "Data.Text.Internal.Encoding.Fusion.Common"
    \ , "Data.Text.Internal.Encoding.Utf16"
    \ , "Data.Text.Internal.Encoding.Utf32"
    \ , "Data.Text.Internal.Encoding.Utf8"
    \ , "Data.Text.Internal.Functions"
    \ , "Data.Text.Internal.Fusion"
    \ , "Data.Text.Internal.Fusion.CaseMapping"
    \ , "Data.Text.Internal.Fusion.Common"
    \ , "Data.Text.Internal.Fusion.Size"
    \ , "Data.Text.Internal.Fusion.Types"
    \ , "Data.Text.Internal.IO"
    \ , "Data.Text.Internal.Lazy"
    \ , "Data.Text.Internal.Lazy.Encoding.Fusion"
    \ , "Data.Text.Internal.Lazy.Fusion"
    \ , "Data.Text.Internal.Lazy.Search"
    \ , "Data.Text.Internal.Private"
    \ , "Data.Text.Internal.Read"
    \ , "Data.Text.Internal.Search"
    \ , "Data.Text.Internal.Unsafe"
    \ , "Data.Text.Internal.Unsafe.Char"
    \ , "Data.Text.Internal.Unsafe.Shift"
    \ , "Data.Text.Lazy"
    \ , "Data.Text.Lazy.Builder"
    \ , "Data.Text.Lazy.Builder.Int"
    \ , "Data.Text.Lazy.Builder.RealFloat"
    \ , "Data.Text.Lazy.Encoding"
    \ , "Data.Text.Lazy.IO"
    \ , "Data.Text.Lazy.Internal"
    \ , "Data.Text.Lazy.Read"
    \ , "Data.Text.Read"
    \ , "Data.Text.Unsafe"
    \ , "System.Random.TF"
    \ , "System.Random.TF.Gen"
    \ , "System.Random.TF.Init"
    \ , "System.Random.TF.Instances"
    \ , "Data.Time"
    \ , "Data.Time.Calendar"
    \ , "Data.Time.Calendar.Easter"
    \ , "Data.Time.Calendar.Julian"
    \ , "Data.Time.Calendar.MonthDay"
    \ , "Data.Time.Calendar.OrdinalDate"
    \ , "Data.Time.Calendar.WeekDate"
    \ , "Data.Time.Clock"
    \ , "Data.Time.Clock.POSIX"
    \ , "Data.Time.Clock.System"
    \ , "Data.Time.Clock.TAI"
    \ , "Data.Time.Format"
    \ , "Data.Time.LocalTime"
    \ , "Control.Applicative.Backwards"
    \ , "Control.Applicative.Lift"
    \ , "Control.Monad.Signatures"
    \ , "Control.Monad.Trans.Accum"
    \ , "Control.Monad.Trans.Class"
    \ , "Control.Monad.Trans.Cont"
    \ , "Control.Monad.Trans.Error"
    \ , "Control.Monad.Trans.Except"
    \ , "Control.Monad.Trans.Identity"
    \ , "Control.Monad.Trans.List"
    \ , "Control.Monad.Trans.Maybe"
    \ , "Control.Monad.Trans.RWS"
    \ , "Control.Monad.Trans.RWS.Lazy"
    \ , "Control.Monad.Trans.RWS.Strict"
    \ , "Control.Monad.Trans.Reader"
    \ , "Control.Monad.Trans.Select"
    \ , "Control.Monad.Trans.State"
    \ , "Control.Monad.Trans.State.Lazy"
    \ , "Control.Monad.Trans.State.Strict"
    \ , "Control.Monad.Trans.Writer"
    \ , "Control.Monad.Trans.Writer.Lazy"
    \ , "Control.Monad.Trans.Writer.Strict"
    \ , "Data.Functor.Constant"
    \ , "Data.Functor.Reverse"
    \ , "Control.Monad.Trans.Instances"
    \ , "Data.Functor.Classes.Generic"
    \ , "Data.Functor.Classes.Generic.Internal"
    \ , "System.Posix"
    \ , "System.Posix.ByteString"
    \ , "System.Posix.ByteString.FilePath"
    \ , "System.Posix.Directory"
    \ , "System.Posix.Directory.ByteString"
    \ , "System.Posix.DynamicLinker"
    \ , "System.Posix.DynamicLinker.ByteString"
    \ , "System.Posix.DynamicLinker.Module"
    \ , "System.Posix.DynamicLinker.Module.ByteString"
    \ , "System.Posix.DynamicLinker.Prim"
    \ , "System.Posix.Env"
    \ , "System.Posix.Env.ByteString"
    \ , "System.Posix.Error"
    \ , "System.Posix.Fcntl"
    \ , "System.Posix.Files"
    \ , "System.Posix.Files.ByteString"
    \ , "System.Posix.IO"
    \ , "System.Posix.IO.ByteString"
    \ , "System.Posix.Process"
    \ , "System.Posix.Process.ByteString"
    \ , "System.Posix.Process.Internals"
    \ , "System.Posix.Resource"
    \ , "System.Posix.Semaphore"
    \ , "System.Posix.SharedMem"
    \ , "System.Posix.Signals"
    \ , "System.Posix.Signals.Exts"
    \ , "System.Posix.Temp"
    \ , "System.Posix.Temp.ByteString"
    \ , "System.Posix.Terminal"
    \ , "System.Posix.Terminal.ByteString"
    \ , "System.Posix.Time"
    \ , "System.Posix.Unistd"
    \ , "System.Posix.User"
    \ , "Data.HashMap.Lazy"
    \ , "Data.HashMap.Strict"
    \ , "Data.HashSet"
    \ , "Data.Vector"
    \ , "Data.Vector.Fusion.Bundle"
    \ , "Data.Vector.Fusion.Bundle.Monadic"
    \ , "Data.Vector.Fusion.Bundle.Size"
    \ , "Data.Vector.Fusion.Stream.Monadic"
    \ , "Data.Vector.Fusion.Util"
    \ , "Data.Vector.Generic"
    \ , "Data.Vector.Generic.Base"
    \ , "Data.Vector.Generic.Mutable"
    \ , "Data.Vector.Generic.Mutable.Base"
    \ , "Data.Vector.Generic.New"
    \ , "Data.Vector.Internal.Check"
    \ , "Data.Vector.Mutable"
    \ , "Data.Vector.Primitive"
    \ , "Data.Vector.Primitive.Mutable"
    \ , "Data.Vector.Storable"
    \ , "Data.Vector.Storable.Internal"
    \ , "Data.Vector.Storable.Mutable"
    \ , "Data.Vector.Unboxed"
    \ , "Data.Vector.Unboxed.Base"
    \ , "Data.Vector.Unboxed.Mutable"
    \ , "Text.XHtml"
    \ , "Text.XHtml.Debug"
    \ , "Text.XHtml.Frameset"
    \ , "Text.XHtml.Strict"
    \ , "Text.XHtml.Table"
    \ , "Text.XHtml.Transitional"
    \ , "Codec.Compression.GZip"
    \ , "Codec.Compression.Zlib"
    \ , "Codec.Compression.Zlib.Internal"
    \ , "Codec.Compression.Zlib.Raw"
    \ , "Web.Spock"
    \ , "Web.Spock.Config"
    \ , "Web.Spock.Internal.SessionManager"
    \ , "Web.Spock.Internal.SessionVault"
    \ , "Web.Spock.SessionActions"
    \ , "Web.Spock.Api"
    \ , "Web.Spock.Auth"
    \ , "Web.Spock.Action"
    \ , "Web.Spock.Core"
    \ , "Web.Spock.Internal.Cookies"
    \ , "Web.Spock.Internal.Util"
    \ , "Web.Spock.Routing"
    \ , "Web.Spock.Digestive"
    \ , "Database.Esqueleto"
    \ , "Database.Esqueleto.Internal.Language"
    \ , "Database.Esqueleto.Internal.Sql"
    \ , "Database.Esqueleto.PostgreSQL"
    \ , "Database.Persist"
    \ , "Database.Persist.Class"
    \ , "Database.Persist.Quasi"
    \ , "Database.Persist.Sql"
    \ , "Database.Persist.Sql.Types.Internal"
    \ , "Database.Persist.Sql.Util"
    \ , "Database.Persist.Types"
    \ , "Database.Persist.MySQL"
    \ , "Database.Persist.Postgresql"
    \ , "Database.Persist.Postgresql.JSON"
    \ , "Database.Persist.Redis"
    \ , "Database.Persist.Sqlite"
    \ , "Database.Sqlite"
    \ , "Servant.API"
    \ , "Servant.API.Alternative"
    \ , "Servant.API.BasicAuth"
    \ , "Servant.API.Capture"
    \ , "Servant.API.ContentTypes"
    \ , "Servant.API.Description"
    \ , "Servant.API.Empty"
    \ , "Servant.API.Experimental.Auth"
    \ , "Servant.API.Generic"
    \ , "Servant.API.Header"
    \ , "Servant.API.HttpVersion"
    \ , "Servant.API.Internal.Test.ComprehensiveAPI"
    \ , "Servant.API.IsSecure"
    \ , "Servant.API.Modifiers"
    \ , "Servant.API.QueryParam"
    \ , "Servant.API.Raw"
    \ , "Servant.API.RemoteHost"
    \ , "Servant.API.ReqBody"
    \ , "Servant.API.ResponseHeaders"
    \ , "Servant.API.Stream"
    \ , "Servant.API.Sub"
    \ , "Servant.API.TypeLevel"
    \ , "Servant.API.Vault"
    \ , "Servant.API.Verbs"
    \ , "Servant.API.WithNamedContext"
    \ , "Servant.Links"
    \ , "Servant.Utils.Enter"
    \ , "Servant.Utils.Links"
    \ , "Servant.Auth"
    \ , "Servant.Client"
    \ , "Servant.Client.Internal.HttpClient"
    \ , "Servant"
    \ , "Servant.Server"
    \ , "Servant.Server.Experimental.Auth"
    \ , "Servant.Server.Generic"
    \ , "Servant.Server.Internal"
    \ , "Servant.Server.Internal.BasicAuth"
    \ , "Servant.Server.Internal.Context"
    \ , "Servant.Server.Internal.Handler"
    \ , "Servant.Server.Internal.Router"
    \ , "Servant.Server.Internal.RoutingApplication"
    \ , "Servant.Server.Internal.ServantErr"
    \ , "Servant.Server.StaticFiles"
    \ , "Servant.Utils.StaticFiles"
    \ ]
                                                                                                                                                                                                usr/share/vim/vim90/autoload/htmlcomplete.vim                                                       0000644 0000000 0000000 00000061612 14424703754 017760  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim completion script
" Language:	HTML and XHTML
" Maintainer:	Mikolaj Machowski ( mikmach AT wp DOT pl )
" Last Change:	2019 Sep 27

" Distinguish between HTML versions.
" To use with other HTML versions add another "elseif" condition to match
" proper DOCTYPE.
function! htmlcomplete#DetectOmniFlavor()
  if &filetype == 'xhtml'
    let b:html_omni_flavor = 'xhtml10s'
  else
    let b:html_omni_flavor = 'html401t'
  endif
  let i = 1
  let line = ""
  while i < 10 && i < line("$")
    let line = getline(i)
    if line =~ '<!DOCTYPE.*\<DTD '
      break
    endif
    let i += 1
  endwhile
  if line =~ '<!DOCTYPE.*\<DTD '  " doctype line found above
    if line =~ ' HTML 3\.2'
      let b:html_omni_flavor = 'html32'
    elseif line =~ ' XHTML 1\.1'
      let b:html_omni_flavor = 'xhtml11'
    else    " two-step detection with strict/frameset/transitional
      if line =~ ' XHTML 1\.0'
	let b:html_omni_flavor = 'xhtml10'
      elseif line =~ ' HTML 4\.01'
	let b:html_omni_flavor = 'html401'
      elseif line =~ ' HTML 4.0\>'
	let b:html_omni_flavor = 'html40'
      endif
      if line =~ '\<Transitional\>'
	let b:html_omni_flavor .= 't'
      elseif line =~ '\<Frameset\>'
	let b:html_omni_flavor .= 'f'
      else
	let b:html_omni_flavor .= 's'
      endif
    endif
  endif
endfunction

function! htmlcomplete#CompleteTags(findstart, base)
  if a:findstart
    " locate the start of the word
    let line = getline('.')
    let start = col('.') - 1
	let curline = line('.')
	let compl_begin = col('.') - 2
    while start >= 0 && line[start - 1] =~ '\(\k\|[!:.-]\)'
		let start -= 1
    endwhile
	" Handling of entities {{{
	if start >= 0 && line[start - 1] =~ '&'
		let b:entitiescompl = 1
		let b:compl_context = ''
		return start
	endif
	" }}}
	" Handling of <style> tag {{{
	let stylestart = searchpair('<style\>', '', '<\/style\>', "bnW")
	let styleend   = searchpair('<style\>', '', '<\/style\>', "nW")
	if stylestart != 0 && styleend != 0
		if stylestart <= curline && styleend >= curline
			let start = col('.') - 1
			let b:csscompl = 1
			while start >= 0 && line[start - 1] =~ '\(\k\|-\)'
				let start -= 1
			endwhile
		endif
	endif
	" }}}
	" Handling of <script> tag {{{
	let scriptstart = searchpair('<script\>', '', '<\/script\>', "bnW")
	let scriptend   = searchpair('<script\>', '', '<\/script\>', "nW")
	if scriptstart != 0 && scriptend != 0
		if scriptstart <= curline && scriptend >= curline
			let start = col('.') - 1
			let b:jscompl = 1
			let b:jsrange = [scriptstart, scriptend]
			while start >= 0 && line[start - 1] =~ '\k'
				let start -= 1
			endwhile
			" We are inside of <script> tag. But we should also get contents
			" of all linked external files and (secondary, less probably) other <script> tags
			" This logic could possible be done in separate function - may be
			" reused in events scripting (also with option could be reused for
			" CSS
			let b:js_extfiles = []
			let l = line('.')
			let c = col('.')
			call cursor(1,1)
			while search('<\@<=script\>', 'W') && line('.') <= l
				if synIDattr(synID(line('.'),col('.')-1,0),"name") !~? 'comment'
					let sname = matchstr(getline('.'), '<script[^>]*src\s*=\s*\([''"]\)\zs.\{-}\ze\1')
					if filereadable(sname)
						let b:js_extfiles += readfile(sname)
					endif
				endif
			endwhile
			call cursor(1,1)
			let js_scripttags = []
			while search('<script\>', 'W') && line('.') < l
				if matchstr(getline('.'), '<script[^>]*src') == ''
					let js_scripttag = getline(line('.'), search('</script>', 'W'))
					let js_scripttags += js_scripttag
				endif
			endwhile
			let b:js_extfiles += js_scripttags
			call cursor(l,c)
			unlet! l c
		endif
	endif
	" }}}
	if !exists("b:csscompl") && !exists("b:jscompl")
		let b:compl_context = getline('.')[0:(compl_begin)]
		if b:compl_context !~ '<[^>]*$'
			" Look like we may have broken tag. Check previous lines.
			let i = 1
			while 1
				let context_line = getline(curline-i)
				if context_line =~ '<[^>]*$'
					" Yep, this is this line
					let context_lines = getline(curline-i, curline-1) + [b:compl_context]
					let b:compl_context = join(context_lines, ' ')
					break
				elseif context_line =~ '>[^<]*$' || i == curline
					" We are in normal tag line, no need for completion at all
					" OR reached first line without tag at all
					let b:compl_context = ''
					break
				endif
				let i += 1
			endwhile
			" Make sure we don't have counter
			unlet! i
		endif
		let b:compl_context = matchstr(b:compl_context, '.*\zs<.*')

		" Return proper start for on-events. Without that beginning of
		" completion will be badly reported
		if b:compl_context =~? 'on[a-z]*\s*=\s*\(''[^'']*\|"[^"]*\)$'
			let start = col('.') - 1
			while start >= 0 && line[start - 1] =~ '\k'
				let start -= 1
			endwhile
		endif
		" If b:compl_context begins with <? we are inside of PHP code. It
		" wasn't closed so PHP completion passed it to HTML
		if &filetype =~? 'php' && b:compl_context =~ '^<?'
			let b:phpcompl = 1
			let start = col('.') - 1
			while start >= 0 && line[start - 1] =~ '[a-zA-Z_0-9\x7f-\xff$]'
				let start -= 1
			endwhile
		endif
	else
		let b:compl_context = getline('.')[0:compl_begin]
	endif
    return start
  else
	" Initialize base return lists
    let res = []
    let res2 = []
	" a:base is very short - we need context
	let context = b:compl_context
	" Check if we should do CSS completion inside of <style> tag
	" or JS completion inside of <script> tag or PHP completion in case of <?
	" tag AND &ft==php
	if exists("b:csscompl")
		unlet! b:csscompl
		let context = b:compl_context
		unlet! b:compl_context
		return csscomplete#CompleteCSS(0, context)
	elseif exists("b:jscompl")
		unlet! b:jscompl
		return javascriptcomplete#CompleteJS(0, a:base)
	elseif exists("b:phpcompl")
		unlet! b:phpcompl
		let context = b:compl_context
		return phpcomplete#CompletePHP(0, a:base)
	else
		if len(b:compl_context) == 0 && !exists("b:entitiescompl")
			return []
		endif
		let context = matchstr(b:compl_context, '.\zs.*')
	endif
	unlet! b:compl_context
	" Entities completion {{{
	if exists("b:entitiescompl")
		unlet! b:entitiescompl

		if !exists("b:html_doctype")
			call htmlcomplete#CheckDoctype()
		endif
		if !exists("b:html_omni")
			"runtime! autoload/xml/xhtml10s.vim
			call htmlcomplete#LoadData()
		endif

	    let entities =  b:html_omni['vimxmlentities']

		if len(a:base) == 1
			for m in entities
				if m =~ '^'.a:base
					call add(res, m.';')
				endif
			endfor
			return res
		else
			for m in entities
				if m =~? '^'.a:base
					call add(res, m.';')
				elseif m =~? a:base
					call add(res2, m.';')
				endif
			endfor

			return res + res2
		endif


	endif
	" }}}
	if context =~ '>'
		" Generally if context contains > it means we are outside of tag and
		" should abandon action - with one exception: <style> span { bo
		if context =~ 'style[^>]\{-}>[^<]\{-}$'
			return csscomplete#CompleteCSS(0, context)
		elseif context =~ 'script[^>]\{-}>[^<]\{-}$'
			let b:jsrange = [line('.'), search('<\/script\>', 'nW')]
			return javascriptcomplete#CompleteJS(0, context)
		else
			return []
		endif
	endif

	" If context contains > it means we are already outside of tag and we
	" should abandon action
	" If context contains white space it is attribute.
	" It can be also value of attribute.
	" We have to get first word to offer proper completions
	if context =~ '^\s*$'
		" empty or whitespace line
		let tag = ''
	else
		let tag = split(context)[0]
		" Detect if tag is uppercase to return in proper case,
		" we need to make it lowercase for processing
		if tag =~ '^[A-Z]*$'
			let uppercase_tag = 1
			let tag = tolower(tag)
		else
			let uppercase_tag = 0
		endif
	endif
	" Get last word, it should be attr name
	let attr = matchstr(context, '.*\s\zs.*')
	" Possible situations where any prediction would be difficult:
	" 1. Events attributes
	if context =~ '\s'
		" Sort out style, class, and on* cases
		if context =~? "\\(on[a-z]*\\|id\\|style\\|class\\)\\s*=\\s*[\"']"
			" Id, class completion {{{
			if context =~? "\\(id\\|class\\)\\s*=\\s*[\"'][a-zA-Z0-9_ -]*$"
				if context =~? "class\\s*=\\s*[\"'][a-zA-Z0-9_ -]*$"
					let search_for = "class"
				elseif context =~? "id\\s*=\\s*[\"'][a-zA-Z0-9_ -]*$"
					let search_for = "id"
				endif
				" Handle class name completion
				" 1. Find lines of <link stylesheet>
				" 1a. Check file for @import
				" 2. Extract filename(s?) of stylesheet,
				call cursor(1,1)
				let head = getline(search('<head\>'), search('<\/head>'))
				let headjoined = join(copy(head), ' ')
				if headjoined =~ '<style'
					" Remove possibly confusing CSS operators
					let stylehead = substitute(headjoined, '+>\*[,', ' ', 'g')
					if search_for == 'class'
						let styleheadlines = split(stylehead)
						let headclasslines = filter(copy(styleheadlines), "v:val =~ '\\([a-zA-Z0-9:]\\+\\)\\?\\.[a-zA-Z0-9_-]\\+'")
					else
						let stylesheet = split(headjoined, '[{}]')
						" Get all lines which fit id syntax
						let classlines = filter(copy(stylesheet), "v:val =~ '#[a-zA-Z0-9_-]\\+'")
						" Filter out possible color definitions
						call filter(classlines, "v:val !~ ':\\s*#[a-zA-Z0-9_-]\\+'")
						" Filter out complex border definitions
						call filter(classlines, "v:val !~ '\\(none\\|hidden\\|dotted\\|dashed\\|solid\\|double\\|groove\\|ridge\\|inset\\|outset\\)\\s*#[a-zA-Z0-9_-]\\+'")
						let templines = join(classlines, ' ')
						let headclasslines = split(templines)
						call filter(headclasslines, "v:val =~ '#[a-zA-Z0-9_-]\\+'")
					endif
					let internal = 1
				else
					let internal = 0
				endif
				let styletable = []
				let secimportfiles = []
				let filestable = filter(copy(head), "v:val =~ '\\(@import\\|link.*stylesheet\\)'")
				for line in filestable
					if line =~ "@import"
						let styletable += [matchstr(line, "import\\s\\+\\(url(\\)\\?[\"']\\?\\zs\\f\\+\\ze")]
					elseif line =~ "<link"
						let styletable += [matchstr(line, "href\\s*=\\s*[\"']\\zs\\f\\+\\ze")]
					endif
				endfor
				for file in styletable
					if filereadable(file)
						let stylesheet = readfile(file)
						let secimport = filter(copy(stylesheet), "v:val =~ '@import'")
						if len(secimport) > 0
							for line in secimport
								let secfile = matchstr(line, "import\\s\\+\\(url(\\)\\?[\"']\\?\\zs\\f\\+\\ze")
								let secfile = fnamemodify(file, ":p:h").'/'.secfile
								let secimportfiles += [secfile]
							endfor
						endif
					endif
				endfor
				let cssfiles = styletable + secimportfiles
				let classes = []
				for file in cssfiles
				  	let classlines = []
					if filereadable(file)
						let stylesheet = readfile(file)
						let stylefile = join(stylesheet, ' ')
						let stylefile = substitute(stylefile, '+>\*[,', ' ', 'g')
						if search_for == 'class'
							let stylesheet = split(stylefile)
							let classlines = filter(copy(stylesheet), "v:val =~ '\\([a-zA-Z0-9:]\\+\\)\\?\\.[a-zA-Z0-9_-]\\+'")
						else
							let stylesheet = split(stylefile, '[{}]')
							" Get all lines which fit id syntax
							let classlines = filter(copy(stylesheet), "v:val =~ '#[a-zA-Z0-9_-]\\+'")
							" Filter out possible color definitions
							call filter(classlines, "v:val !~ ':\\s*#[a-zA-Z0-9_-]\\+'")
							" Filter out complex border definitions
							call filter(classlines, "v:val !~ '\\(none\\|hidden\\|dotted\\|dashed\\|solid\\|double\\|groove\\|ridge\\|inset\\|outset\\)\\s*#[a-zA-Z0-9_-]\\+'")
							let templines = join(classlines, ' ')
							let stylelines = split(templines)
							let classlines = filter(stylelines, "v:val =~ '#[a-zA-Z0-9_-]\\+'")

						endif
					endif
					" We gathered classes definitions from all external files
					let classes += classlines
				endfor
				if internal == 1
					let classes += headclasslines
				endif

				if search_for == 'class'
					let elements = {}
					for element in classes
						if element =~ '^\.'
							let class = matchstr(element, '^\.\zs[a-zA-Z][a-zA-Z0-9_-]*\ze')
							let class = substitute(class, ':.*', '', '')
							if has_key(elements, 'common')
								let elements['common'] .= ' '.class
							else
								let elements['common'] = class
							endif
						else
							let class = matchstr(element, '[a-zA-Z1-6]*\.\zs[a-zA-Z][a-zA-Z0-9_-]*\ze')
							let tagname = tolower(matchstr(element, '[a-zA-Z1-6]*\ze.'))
							if tagname != ''
								if has_key(elements, tagname)
									let elements[tagname] .= ' '.class
								else
									let elements[tagname] = class
								endif
							endif
						endif
					endfor

					if has_key(elements, tag) && has_key(elements, 'common')
						let values = split(elements[tag]." ".elements['common'])
					elseif has_key(elements, tag) && !has_key(elements, 'common')
						let values = split(elements[tag])
					elseif !has_key(elements, tag) && has_key(elements, 'common')
						let values = split(elements['common'])
					else
						return []
					endif

