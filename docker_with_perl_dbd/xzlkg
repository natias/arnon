
 /(A)        # Group 1
  (          # Group 2
    (B)      # Group 3
    \g{-1}   # Refers to group 3 (B)
    \g{-3}   # Refers to group 1 (A)
    \g{ -3 } # Same, showing optional blanks adjacent to the braces
  )
 /x;         # Matches "ABBA".

 my $qr = qr /(.)(.)\g{-2}\g{-1}/;  # Matches 'abab', 'cdcd', etc.
 /$qr$qr/                           # Matches 'ababcdcd'.

=head3 Named referencing

C<\g{I<name>}> (starting in Perl 5.10.0) can be used to back refer to a
named capture group, dispensing completely with having to think about capture
buffer positions.

To be compatible with .Net regular expressions, C<\g{name}> may also be
written as C<\k{name}>, C<< \k<name> >> or C<\k'name'>.

To prevent any ambiguity, I<name> must not start with a digit nor contain a
hyphen.

=head4 Examples

 /(?<word>\w+) \g{word}/   # Finds duplicated word, (e.g. "cat cat")
 /(?<word>\w+) \k{word}/   # Same.
 /(?<word>\w+) \g{ word }/ # Same, showing optional blanks adjacent to
                           # the braces
 /(?<word>\w+) \k{ word }/ # Same.
 /(?<word>\w+) \k<word>/   # Same.  There are no braces, so no blanks
                           # are permitted
 /(?<letter1>.)(?<letter2>.)\g{letter2}\g{letter1}/
                           # Match a four letter palindrome (e.g.
                           # "ABBA")

=head2 Assertions

Assertions are conditions that have to be true; they don't actually
match parts of the substring. There are six assertions that are written as
backslash sequences.

=over 4

=item \A

C<\A> only matches at the beginning of the string. If the C</m> modifier
isn't used, then C</\A/> is equivalent to C</^/>. However, if the C</m>
modifier is used, then C</^/> matches internal newlines, but the meaning
of C</\A/> isn't changed by the C</m> modifier. C<\A> matches at the beginning
of the string regardless whether the C</m> modifier is used.

=item \z, \Z

C<\z> and C<\Z> match at the end of the string. If the C</m> modifier isn't
used, then C</\Z/> is equivalent to C</$/>; that is, it matches at the
end of the string, or one before the newline at the end of the string. If the
C</m> modifier is used, then C</$/> matches at internal newlines, but the
meaning of C</\Z/> isn't changed by the C</m> modifier. C<\Z> matches at
the end of the string (or just before a trailing newline) regardless whether
the C</m> modifier is used.

C<\z> is just like C<\Z>, except that it does not match before a trailing
newline. C<\z> matches at the end of the string only, regardless of the
modifiers used, and not just before a newline.  It is how to anchor the
match to the true end of the string under all conditions.

=item \G

C<\G> is usually used only in combination with the C</g> modifier. If the
C</g> modifier is used and the match is done in scalar context, Perl
remembers where in the source string the last match ended, and the next time,
it will start the match from where it ended the previous time.

C<\G> matches the point where the previous match on that string ended,
or the beginning of that string if there was no previous match.

=for later add link to perlremodifiers

Mnemonic: I<G>lobal.

=item \b{}, \b, \B{}, \B

C<\b{...}>, available starting in v5.22, matches a boundary (between two
characters, or before the first character of the string, or after the
final character of the string) based on the Unicode rules for the
boundary type specified inside the braces.  The boundary
types are given a few paragraphs below.  C<\B{...}> matches at any place
between characters where C<\b{...}> of the same type doesn't match.

C<\b> when not immediately followed by a C<"{"> is available in all
Perls.  It matches at any place
between a word (something matched by C<\w>) and a non-word character
(C<\W>); C<\B> when not immediately followed by a C<"{"> matches at any
place between characters where C<\b> doesn't match.  To get better
word matching of natural language text, see L</\b{wb}> below.

C<\b>
and C<\B> assume there's a non-word character before the beginning and after
the end of the source string; so C<\b> will match at the beginning (or end)
of the source string if the source string begins (or ends) with a word
character. Otherwise, C<\B> will match.

Do not use something like C<\b=head\d\b> and expect it to match the
beginning of a line.  It can't, because for there to be a boundary before
the non-word "=", there must be a word character immediately previous.
All plain C<\b> and C<\B> boundary determinations look for word
characters alone, not for
non-word characters nor for string ends.  It may help to understand how
C<\b> and C<\B> work by equating them as follows:

    \b	really means	(?:(?<=\w)(?!\w)|(?<!\w)(?=\w))
    \B	really means	(?:(?<=\w)(?=\w)|(?<!\w)(?!\w))

In contrast, C<\b{...}> and C<\B{...}> may or may not match at the
beginning and end of the line, depending on the boundary type.  These
implement the Unicode default boundaries, specified in
L<https://www.unicode.org/reports/tr14/> and
L<https://www.unicode.org/reports/tr29/>.
The boundary types are:

=over

=item C<\b{gcb}> or C<\b{g}>

This matches a Unicode "Grapheme Cluster Boundary".  (Actually Perl
always uses the improved "extended" grapheme cluster").  These are
explained below under C<L</\X>>.  In fact, C<\X> is another way to get
the same functionality.  It is equivalent to C</.+?\b{gcb}/>.  Use
whichever is most convenient for your situation.

=item C<\b{lb}>

This matches according to the default Unicode Line Breaking Algorithm
(L<https://www.unicode.org/reports/tr14/>), as customized in that
document
(L<Example 7 of revision 35|https://www.unicode.org/reports/tr14/tr14-35.html#Example7>)
for better handling of numeric expressions.

This is suitable for many purposes, but the L<Unicode::LineBreak> module
is available on CPAN that provides many more features, including
customization.

=item C<\b{sb}>

This matches a Unicode "Sentence Boundary".  This is an aid to parsing
natural language sentences.  It gives good, but imperfect results.  For
example, it thinks that "Mr. Smith" is two sentences.  More details are
at L<https://www.unicode.org/reports/tr29/>.  Note also that it thinks
that anything matching L</\R> (except form feed and vertical tab) is a
sentence boundary.  C<\b{sb}> works with text designed for
word-processors which wrap lines
automatically for display, but hard-coded line boundaries are considered
to be essentially the ends of text blocks (paragraphs really), and hence
the ends of sentences.  C<\b{sb}> doesn't do well with text containing
embedded newlines, like the source text of the document you are reading.
Such text needs to be preprocessed to get rid of the line separators
before looking for sentence boundaries.  Some people view this as a bug
in the Unicode standard, and this behavior is quite subject to change in
future Perl versions.

=item C<\b{wb}>

This matches a Unicode "Word Boundary", but tailored to Perl
expectations.  This gives better (though not
perfect) results for natural language processing than plain C<\b>
(without braces) does.  For example, it understands that apostrophes can
be in the middle of words and that parentheses aren't (see the examples
below).  More details are at L<https://www.unicode.org/reports/tr29/>.

The current Unicode definition of a Word Boundary matches between every
white space character.  Perl tailors this, starting in version 5.24, to
generally not break up spans of white space, just as plain C<\b> has
always functioned.  This allows C<\b{wb}> to be a drop-in replacement for
C<\b>, but with generally better results for natural language
processing.  (The exception to this tailoring is when a span of white
space is immediately followed by something like U+0303, COMBINING TILDE.
If the final space character in the span is a horizontal white space, it
is broken out so that it attaches instead to the combining character.
To be precise, if a span of white space that ends in a horizontal space
has the character immediately following it have any of the Word
Boundary property values "Extend", "Format" or "ZWJ", the boundary between the
final horizontal space character and the rest of the span matches
C<\b{wb}>.  In all other cases the boundary between two white space
characters matches C<\B{wb}>.)

=back

It is important to realize when you use these Unicode boundaries,
that you are taking a risk that a future version of Perl which contains
a later version of the Unicode Standard will not work precisely the same
way as it did when your code was written.  These rules are not
considered stable and have been somewhat more subject to change than the
rest of the Standard.  Unicode reserves the right to change them at
will, and Perl reserves the right to update its implementation to
Unicode's new rules.  In the past, some changes have been because new
characters have been added to the Standard which have different
characteristics than all previous characters, so new rules are
formulated for handling them.  These should not cause any backward
compatibility issues.  But some changes have changed the treatment of
existing characters because the Unicode Technical Committee has decided
that the change is warranted for whatever reason.  This could be to fix
a bug, or because they think better results are obtained with the new
rule.

It is also important to realize that these are default boundary
definitions, and that implementations may wish to tailor the results for
particular purposes and locales.  For example, some languages, such as
Japanese and Thai, require dictionary lookup to accurately determine
word boundaries.

Mnemonic: I<b>oundary.

=back

=head4 Examples

  "cat"   =~ /\Acat/;     # Match.
  "cat"   =~ /cat\Z/;     # Match.
  "cat\n" =~ /cat\Z/;     # Match.
  "cat\n" =~ /cat\z/;     # No match.

  "cat"   =~ /\bcat\b/;   # Matches.
  "cats"  =~ /\bcat\b/;   # No match.
  "cat"   =~ /\bcat\B/;   # No match.
  "cats"  =~ /\bcat\B/;   # Match.

  while ("cat dog" =~ /(\w+)/g) {
      print $1;           # Prints 'catdog'
  }
  while ("cat dog" =~ /\G(\w+)/g) {
      print $1;           # Prints 'cat'
  }

  my $s = "He said, \"Is pi 3.14? (I'm not sure).\"";
  print join("|", $s =~ m/ ( .+? \b     ) /xg), "\n";
  print join("|", $s =~ m/ ( .+? \b{wb} ) /xg), "\n";
 prints
  He| |said|, "|Is| |pi| |3|.|14|? (|I|'|m| |not| |sure
  He| |said|,| |"|Is| |pi| |3.14|?| |(|I'm| |not| |sure|)|.|"

=head2 Misc

Here we document the backslash sequences that don't fall in one of the
categories above. These are:

=over 4

=item \K

This appeared in perl 5.10.0. Anything matched left of C<\K> is
not included in C<$&>, and will not be replaced if the pattern is
used in a substitution. This lets you write C<s/PAT1 \K PAT2/REPL/x>
instead of C<s/(PAT1) PAT2/${1}REPL/x> or C<s/(?<=PAT1) PAT2/REPL/x>.

Mnemonic: I<K>eep.

=item \N

This feature, available starting in v5.12,  matches any character
that is B<not> a newline.  It is a short-hand for writing C<[^\n]>, and is
identical to the C<.> metasymbol, except under the C</s> flag, which changes
the meaning of C<.>, but not C<\N>.

Note that C<\N{...}> can mean a
L<named or numbered character
|/Named or numbered characters and character sequences>.

Mnemonic: Complement of I<\n>.

=item \R
X<\R>

C<\R> matches a I<generic newline>; that is, anything considered a
linebreak sequence by Unicode. This includes all characters matched by
C<\v> (vertical whitespace), and the multi character sequence C<"\x0D\x0A">
(carriage return followed by a line feed, sometimes called the network
newline; it's the end of line sequence used in Microsoft text files opened
in binary mode). C<\R> is equivalent to C<< (?>\x0D\x0A|\v) >>.  (The
reason it doesn't backtrack is that the sequence is considered
inseparable.  That means that

 "\x0D\x0A" =~ /^\R\x0A$/   # No match

fails, because the C<\R> matches the entire string, and won't backtrack
to match just the C<"\x0D">.)  Since
C<\R> can match a sequence of more than one character, it cannot be put
inside a bracketed character class; C</[\R]/> is an error; use C<\v>
instead.  C<\R> was introduced in perl 5.10.0.

Note that this does not respect any locale that might be in effect; it
matches according to the platform's native character set.

Mnemonic: none really. C<\R> was picked because PCRE already uses C<\R>,
and more importantly because Unicode recommends such a regular expression
metacharacter, and suggests C<\R> as its notation.

=item \X
X<\X>

This matches a Unicode I<extended grapheme cluster>.

C<\X> matches quite well what normal (non-Unicode-programmer) usage
would consider a single character.  As an example, consider a G with some sort
of diacritic mark, such as an arrow.  There is no such single character in
Unicode, but one can be composed by using a G followed by a Unicode "COMBINING
UPWARDS ARROW BELOW", and would be displayed by Unicode-aware software as if it
were a single character.

The match is greedy and non-backtracking, so that the cluster is never
broken up into smaller components.

See also L<C<\b{gcb}>|/\b{}, \b, \B{}, \B>.

Mnemonic: eI<X>tended Unicode character.

=back

=head4 Examples

 $str =~ s/foo\Kbar/baz/g; # Change any 'bar' following a 'foo' to 'baz'
 $str =~ s/(.)\K\g1//g;    # Delete duplicated characters.

 "\n"   =~ /^\R$/;         # Match, \n   is a generic newline.
 "\r"   =~ /^\R$/;         # Match, \r   is a generic newline.
 "\r\n" =~ /^\R$/;         # Match, \r\n is a generic newline.

 "P\x{307}" =~ /^\X$/     # \X matches a P with a dot above.

=cut
                                                                                                                 usr/local/lib/perl5/5.40.0/pod/perlrecharclass.pod                                                  0000644 0000000 0000000 00000137307 14714567415 020164  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =head1 NAME
X<character class>

perlrecharclass - Perl Regular Expression Character Classes

=head1 DESCRIPTION

The top level documentation about Perl regular expressions
is found in L<perlre>.

This manual page discusses the syntax and use of character
classes in Perl regular expressions.

A character class is a way of denoting a set of characters
in such a way that one character of the set is matched.
It's important to remember that: matching a character class
consumes exactly one character in the source string. (The source
string is the string the regular expression is matched against.)

There are three types of character classes in Perl regular
expressions: the dot, backslash sequences, and the form enclosed in square
brackets.  Keep in mind, though, that often the term "character class" is used
to mean just the bracketed form.  Certainly, most Perl documentation does that.

=head2 The dot

The dot (or period), C<.> is probably the most used, and certainly
the most well-known character class. By default, a dot matches any
character, except for the newline. That default can be changed to
add matching the newline by using the I<single line> modifier:
for the entire regular expression with the C</s> modifier, or
locally with C<(?s)>  (and even globally within the scope of
L<C<use re '/s'>|re/'E<sol>flags' mode>).  (The C<L</\N>> backslash
sequence, described
below, matches any character except newline without regard to the
I<single line> modifier.)

Here are some examples:

 "a"  =~  /./       # Match
 "."  =~  /./       # Match
 ""   =~  /./       # No match (dot has to match a character)
 "\n" =~  /./       # No match (dot does not match a newline)
 "\n" =~  /./s      # Match (global 'single line' modifier)
 "\n" =~  /(?s:.)/  # Match (local 'single line' modifier)
 "ab" =~  /^.$/     # No match (dot matches one character)

=head2 Backslash sequences
X<\w> X<\W> X<\s> X<\S> X<\d> X<\D> X<\p> X<\P>
X<\N> X<\v> X<\V> X<\h> X<\H>
X<word> X<whitespace>

A backslash sequence is a sequence of characters, the first one of which is a
backslash.  Perl ascribes special meaning to many such sequences, and some of
these are character classes.  That is, they match a single character each,
provided that the character belongs to the specific set of characters defined
by the sequence.

Here's a list of the backslash sequences that are character classes.  They
are discussed in more detail below.  (For the backslash sequences that aren't
character classes, see L<perlrebackslash>.)

 \d             Match a decimal digit character.
 \D             Match a non-decimal-digit character.
 \w             Match a "word" character.
 \W             Match a non-"word" character.
 \s             Match a whitespace character.
 \S             Match a non-whitespace character.
 \h             Match a horizontal whitespace character.
 \H             Match a character that isn't horizontal whitespace.
 \v             Match a vertical whitespace character.
 \V             Match a character that isn't vertical whitespace.
 \N             Match a character that isn't a newline.
 \pP, \p{Prop}  Match a character that has the given Unicode property.
 \PP, \P{Prop}  Match a character that doesn't have the Unicode property

=head3 \N

C<\N>, available starting in v5.12, like the dot, matches any
character that is not a newline. The difference is that C<\N> is not influenced
by the I<single line> regular expression modifier (see L</The dot> above).  Note
that the form C<\N{...}> may mean something completely different.  When the
C<{...}> is a L<quantifier|perlre/Quantifiers>, it means to match a non-newline
character that many times.  For example, C<\N{3}> means to match 3
non-newlines; C<\N{5,}> means to match 5 or more non-newlines.  But if C<{...}>
is not a legal quantifier, it is presumed to be a named character.  See
L<charnames> for those.  For example, none of C<\N{COLON}>, C<\N{4F}>, and
C<\N{F4}> contain legal quantifiers, so Perl will try to find characters whose
names are respectively C<COLON>, C<4F>, and C<F4>.

=head3 Digits

C<\d> matches a single character considered to be a decimal I<digit>.
If the C</a> regular expression modifier is in effect, it matches [0-9].
Otherwise, it
matches anything that is matched by C<\p{Digit}>, which includes [0-9].
(An unlikely possible exception is that under locale matching rules, the
current locale might not have C<[0-9]> matched by C<\d>, and/or might match
other characters whose code point is less than 256.  The only such locale
definitions that are legal would be to match C<[0-9]> plus another set of
10 consecutive digit characters;  anything else would be in violation of
the C language standard, but Perl doesn't currently assume anything in
regard to this.)

What this means is that unless the C</a> modifier is in effect C<\d> not
only matches the digits '0' - '9', but also Arabic, Devanagari, and
digits from other languages.  This may cause some confusion, and some
security issues.

Some digits that C<\d> matches look like some of the [0-9] ones, but
have different values.  For example, BENGALI DIGIT FOUR (U+09EA) looks
very much like an ASCII DIGIT EIGHT (U+0038), and LEPCHA DIGIT SIX
(U+1C46) looks very much like an ASCII DIGIT FIVE (U+0035).  An
application that
is expecting only the ASCII digits might be misled, or if the match is
C<\d+>, the matched string might contain a mixture of digits from
different writing systems that look like they signify a number different
than they actually do.  L<Unicode::UCD/num()> can
be used to safely
calculate the value, returning C<undef> if the input string contains
such a mixture.  Otherwise, for example, a displayed price might be
deliberately different than it appears.

What C<\p{Digit}> means (and hence C<\d> except under the C</a>
modifier) is C<\p{General_Category=Decimal_Number}>, or synonymously,
C<\p{General_Category=Digit}>.  Starting with Unicode version 4.1, this
is the same set of characters matched by C<\p{Numeric_Type=Decimal}>.
But Unicode also has a different property with a similar name,
C<\p{Numeric_Type=Digit}>, which matches a completely different set of
characters.  These characters are things such as C<CIRCLED DIGIT ONE>
or subscripts, or are from writing systems that lack all ten digits.

The design intent is for C<\d> to exactly match the set of characters
that can safely be used with "normal" big-endian positional decimal
syntax, where, for example 123 means one 'hundred', plus two 'tens',
plus three 'ones'.  This positional notation does not necessarily apply
to characters that match the other type of "digit",
C<\p{Numeric_Type=Digit}>, and so C<\d> doesn't match them.

The Tamil digits (U+0BE6 - U+0BEF) can also legally be
used in old-style Tamil numbers in which they would appear no more than
one in a row, separated by characters that mean "times 10", "times 100",
etc.  (See L<https://www.unicode.org/notes/tn21>.)

Any character not matched by C<\d> is matched by C<\D>.

=head3 Word characters

A C<\w> matches a single alphanumeric character (an alphabetic character, or a
decimal digit); or a connecting punctuation character, such as an
underscore ("_"); or a "mark" character (like some sort of accent) that
attaches to one of those.  It does not match a whole word.  To match a
whole word, use C<\w+>.  This isn't the same thing as matching an
English word, but in the ASCII range it is the same as a string of
Perl-identifier characters.

=over

=item If the C</a> modifier is in effect ...

C<\w> matches the 63 characters [a-zA-Z0-9_].

=item otherwise ...

=over

=item For code points above 255 ...

C<\w> matches the same as C<\p{Word}> matches in this range.  That is,
it matches Thai letters, Greek letters, etc.  This includes connector
punctuation (like the underscore) which connect two words together, or
diacritics, such as a C<COMBINING TILDE> and the modifier letters, which
are generally used to add auxiliary markings to letters.

=item For code points below 256 ...

=over

=item if locale rules are in effect ...

C<\w> matches the platform's native underscore character plus whatever
the locale considers to be alphanumeric.

=item if, instead, Unicode rules are in effect ...

C<\w> matches exactly what C<\p{Word}> matches.

=item otherwise ...

C<\w> matches [a-zA-Z0-9_].

=back

=back

=back

Which rules apply are determined as described in L<perlre/Which character set modifier is in effect?>.

There are a number of security issues with the full Unicode list of word
characters.  See L<https://unicode.org/reports/tr36>.

Also, for a somewhat finer-grained set of characters that are in programming
language identifiers beyond the ASCII range, you may wish to instead use the
more customized L</Unicode Properties>, C<\p{ID_Start}>,
C<\p{ID_Continue}>, C<\p{XID_Start}>, and C<\p{XID_Continue}>.  See
L<https://unicode.org/reports/tr31>.

Any character not matched by C<\w> is matched by C<\W>.

=head3 Whitespace

C<\s> matches any single character considered whitespace.

=over

=item If the C</a> modifier is in effect ...

In all Perl versions, C<\s> matches the 5 characters [\t\n\f\r ]; that
is, the horizontal tab,
the newline, the form feed, the carriage return, and the space.
Starting in Perl v5.18, it also matches the vertical tab, C<\cK>.
See note C<[1]> below for a discussion of this.

=item otherwise ...

=over

=item For code points above 255 ...

C<\s> matches exactly the code points above 255 shown with an "s" column
in the table below.

=item For code points below 256 ...

=over

=item if locale rules are in effect ...

C<\s> matches whatever the locale considers to be whitespace.

=item if, instead, Unicode rules are in effect ...

C<\s> matches exactly the characters shown with an "s" column in the
table below.

=item otherwise ...

C<\s> matches [\t\n\f\r ] and, starting in Perl
v5.18, the vertical tab, C<\cK>.
(See note C<[1]> below for a discussion of this.)
Note that this list doesn't include the non-breaking space.

=back

=back

=back

Which rules apply are determined as described in L<perlre/Which character set modifier is in effect?>.

Any character not matched by C<\s> is matched by C<\S>.

C<\h> matches any character considered horizontal whitespace;
this includes the platform's space and tab characters and several others
listed in the table below.  C<\H> matches any character
not considered horizontal whitespace.  They use the platform's native
character set, and do not consider any locale that may otherwise be in
use.

C<\v> matches any character considered vertical whitespace;
this includes the platform's carriage return and line feed characters (newline)
plus several other characters, all listed in the table below.
C<\V> matches any character not considered vertical whitespace.
They use the platform's native character set, and do not consider any
locale that may otherwise be in use.

C<\R> matches anything that can be considered a newline under Unicode
rules. It can match a multi-character sequence. It cannot be used inside
a bracketed character class; use C<\v> instead (vertical whitespace).
It uses the platform's
native character set, and does not consider any locale that may
otherwise be in use.
Details are discussed in L<perlrebackslash>.

Note that unlike C<\s> (and C<\d> and C<\w>), C<\h> and C<\v> always match
the same characters, without regard to other factors, such as the active
locale or whether the source string is in UTF-8 format.

One might think that C<\s> is equivalent to C<[\h\v]>. This is indeed true
starting in Perl v5.18, but prior to that, the sole difference was that the
vertical tab (C<"\cK">) was not matched by C<\s>.

The following table is a complete listing of characters matched by
C<\s>, C<\h> and C<\v> as of Unicode 14.0.

The first column gives the Unicode code point of the character (in hex format),
the second column gives the (Unicode) name. The third column indicates
by which class(es) the character is matched (assuming no locale is in
effect that changes the C<\s> matching).

 0x0009        CHARACTER TABULATION   h s
 0x000a              LINE FEED (LF)    vs
 0x000b             LINE TABULATION    vs  [1]
 0x000c              FORM FEED (FF)    vs
 0x000d        CARRIAGE RETURN (CR)    vs
 0x0020                       SPACE   h s
 0x0085             NEXT LINE (NEL)    vs  [2]
 0x00a0              NO-BREAK SPACE   h s  [2]
 0x1680            OGHAM SPACE MARK   h s
 0x2000                     EN QUAD   h s
 0x2001                     EM QUAD   h s
 0x2002                    EN SPACE   h s
 0x2003                    EM SPACE   h s
 0x2004          THREE-PER-EM SPACE   h s
 0x2005           FOUR-PER-EM SPACE   h s
 0x2006            SIX-PER-EM SPACE   h s
 0x2007                FIGURE SPACE   h s
 0x2008           PUNCTUATION SPACE   h s
 0x2009                  THIN SPACE   h s
 0x200a                  HAIR SPACE   h s
 0x2028              LINE SEPARATOR    vs
 0x2029         PARAGRAPH SEPARATOR    vs
 0x202f       NARROW NO-BREAK SPACE   h s
 0x205f   MEDIUM MATHEMATICAL SPACE   h s
 0x3000           IDEOGRAPHIC SPACE   h s

=over 4

=item [1]

Prior to Perl v5.18, C<\s> did not match the vertical tab.
C<[^\S\cK]> (obscurely) matches what C<\s> traditionally did.

=item [2]

NEXT LINE and NO-BREAK SPACE may or may not match C<\s> depending
on the rules in effect.  See
L<the beginning of this section|/Whitespace>.

=back

=head3 Unicode Properties

C<\pP> and C<\p{Prop}> are character classes to match characters that fit given
Unicode properties.  One letter property names can be used in the C<\pP> form,
with the property name following the C<\p>, otherwise, braces are required.
When using braces, there is a single form, which is just the property name
enclosed in the braces, and a compound form which looks like C<\p{name=value}>,
which means to match if the property "name" for the character has that particular
"value".
For instance, a match for a number can be written as C</\pN/> or as
C</\p{Number}/>, or as C</\p{Number=True}/>.
Lowercase letters are matched by the property I<Lowercase_Letter> which
has the short form I<Ll>. They need the braces, so are written as C</\p{Ll}/> or
C</\p{Lowercase_Letter}/>, or C</\p{General_Category=Lowercase_Letter}/>
(the underscores are optional).
C</\pLl/> is valid, but means something different.
It matches a two character string: a letter (Unicode property C<\pL>),
followed by a lowercase C<l>.

What a Unicode property matches is never subject to locale rules, and
if locale rules are not otherwise in effect, the use of a Unicode
property will force the regular expression into using Unicode rules, if
it isn't already.

Note that almost all properties are immune to case-insensitive matching.
That is, adding a C</i> regular expression modifier does not change what
they match.  But there are two sets that are affected.  The first set is
C<Uppercase_Letter>,
C<Lowercase_Letter>,
and C<Titlecase_Letter>,
all of which match C<Cased_Letter> under C</i> matching.
The second set is
C<Uppercase>,
C<Lowercase>,
and C<Titlecase>,
all of which match C<Cased> under C</i> matching.
(The difference between these sets is that some things, such as Roman
numerals, come in both upper and lower case, so they are C<Cased>, but
aren't considered to be letters, so they aren't C<Cased_Letter>s. They're
actually C<Letter_Number>s.)
This set also includes its subsets C<PosixUpper> and C<PosixLower>, both
of which under C</i> match C<PosixAlpha>.

For more details on Unicode properties, see L<perlunicode/Unicode
Character Properties>; for a
complete list of possible properties, see
L<perluniprops/Properties accessible through \p{} and \P{}>,
which notes all forms that have C</i> differences.
It is also possible to define your own properties. This is discussed in
L<perlunicode/User-Defined Character Properties>.

Unicode properties are defined (surprise!) only on Unicode code points.
Starting in v5.20, when matching against C<\p> and C<\P>, Perl treats
non-Unicode code points (those above the legal Unicode maximum of
0x10FFFF) as if they were typical unassigned Unicode code points.

Prior to v5.20, Perl raised a warning and made all matches fail on
non-Unicode code points.  This could be somewhat surprising:

 chr(0x110000) =~ \p{ASCII_Hex_Digit=True}     # Fails on Perls < v5.20.
 chr(0x110000) =~ \p{ASCII_Hex_Digit=False}    # Also fails on Perls
                                               # < v5.20

Even though these two matches might be thought of as complements, until
v5.20 they were so only on Unicode code points.

Starting in perl v5.30, wildcards are allowed in Unicode property
values.  See L<perlunicode/Wildcards in Property Values>.

=head4 Examples

 "a"  =~  /\w/      # Match, "a" is a 'word' character.
 "7"  =~  /\w/      # Match, "7" is a 'word' character as well.
 "a"  =~  /\d/      # No match, "a" isn't a digit.
 "7"  =~  /\d/      # Match, "7" is a digit.
 " "  =~  /\s/      # Match, a space is whitespace.
 "a"  =~  /\D/      # Match, "a" is a non-digit.
 "7"  =~  /\D/      # No match, "7" is not a non-digit.
 " "  =~  /\S/      # No match, a space is not non-whitespace.

 " "  =~  /\h/      # Match, space is horizontal whitespace.
 " "  =~  /\v/      # No match, space is not vertical whitespace.
 "\r" =~  /\v/      # Match, a return is vertical whitespace.

 "a"  =~  /\pL/     # Match, "a" is a letter.
 "a"  =~  /\p{Lu}/  # No match, /\p{Lu}/ matches upper case letters.

 "\x{0e0b}" =~ /\p{Thai}/  # Match, \x{0e0b} is the character
                           # 'THAI CHARACTER SO SO', and that's in
                           # Thai Unicode class.
 "a"  =~  /\P{Lao}/ # Match, as "a" is not a Laotian character.

It is worth emphasizing that C<\d>, C<\w>, etc, match single characters, not
complete numbers or words. To match a number (that consists of digits),
use C<\d+>; to match a word, use C<\w+>.  But be aware of the security
considerations in doing so, as mentioned above.

=head2 Bracketed Character Classes

The third form of character class you can use in Perl regular expressions
is the bracketed character class.  In its simplest form, it lists the characters
that may be matched, surrounded by square brackets, like this: C<[aeiou]>.
This matches one of C<a>, C<e>, C<i>, C<o> or C<u>.  Like the other
character classes, exactly one character is matched.* To match
a longer string consisting of characters mentioned in the character
class, follow the character class with a L<quantifier|perlre/Quantifiers>.  For
instance, C<[aeiou]+> matches one or more lowercase English vowels.

Repeating a character in a character class has no
effect; it's considered to be in the set only once.

Examples:

 "e"  =~  /[aeiou]/        # Match, as "e" is listed in the class.
 "p"  =~  /[aeiou]/        # No match, "p" is not listed in the class.
 "ae" =~  /^[aeiou]$/      # No match, a character class only matches
                           # a single character.
 "ae" =~  /^[aeiou]+$/     # Match, due to the quantifier.

 -------

* There are two exceptions to a bracketed character class matching a
single character only.  Each requires special handling by Perl to make
things work:

=over

=item *

When the class is to match caselessly under C</i> matching rules, and a
character that is explicitly mentioned inside the class matches a
multiple-character sequence caselessly under Unicode rules, the class
will also match that sequence.  For example, Unicode says that the
letter C<LATIN SMALL LETTER SHARP S> should match the sequence C<ss>
under C</i> rules.  Thus,

 'ss' =~ /\A\N{LATIN SMALL LETTER SHARP S}\z/i             # Matches
 'ss' =~ /\A[aeioust\N{LATIN SMALL LETTER SHARP S}]\z/i    # Matches

For this to happen, the class must not be inverted (see L</Negation>)
and the character must be explicitly specified, and not be part of a
multi-character range (not even as one of its endpoints).  (L</Character
Ranges> will be explained shortly.) Therefore,

 'ss' =~ /\A[\0-\x{ff}]\z/ui       # Doesn't match
 'ss' =~ /\A[\0-\N{LATIN SMALL LETTER SHARP S}]\z/ui   # No match
 'ss' =~ /\A[\xDF-\xDF]\z/ui   # Matches on ASCII platforms, since
                               # \xDF is LATIN SMALL LETTER SHARP S,
                               # and the range is just a single
                               # element

Note that it isn't a good idea to specify these types of ranges anyway.

=item *

Some names known to C<\N{...}> refer to a sequence of multiple characters,
instead of the usual single character.  When one of these is included in
the class, the entire sequence is matched.  For example,

  "\N{TAMIL LETTER KA}\N{TAMIL VOWEL SIGN AU}"
                              =~ / ^ [\N{TAMIL SYLLABLE KAU}]  $ /x;

matches, because C<\N{TAMIL SYLLABLE KAU}> is a named sequence
consisting of the two characters matched against.  Like the other
instance where a bracketed class can match multiple characters, and for
similar reasons, the class must not be inverted, and the named sequence
may not appear in a range, even one where it is both endpoints.  If
these happen, it is a fatal error if the character class is within the
scope of L<C<use re 'strict>|re/'strict' mode>, or within an extended
L<C<(?[...])>|/Extended Bracketed Character Classes> class; otherwise
only the first code point is used (with a C<regexp>-type warning
raised).

=back

=head3 Special Characters Inside a Bracketed Character Class

Most characters that are meta characters in regular expressions (that
is, characters that carry a special meaning like C<.>, C<*>, or C<(>) lose
their special meaning and can be used inside a character class without
the need to escape them. For instance, C<[()]> matches either an opening
parenthesis, or a closing parenthesis, and the parens inside the character
class don't group or capture.  Be aware that, unless the pattern is
evaluated in single-quotish context, variable interpolation will take
place before the bracketed class is parsed:

 $, = "\t| ";
 $x =~ m'[$,]';        # single-quotish: matches '$' or ','
 $x =~ q{[$,]}'        # same
 $x =~ m/[$,]/;        # double-quotish: Because we made an
                       #   assignment to $, above, this now
                       #   matches "\t", "|", or " "

Characters that may carry a special meaning inside a character class are:
C<\>, C<^>, C<->, C<[> and C<]>, and are discussed below. They can be
escaped with a backslash, although this is sometimes not needed, in which
case the backslash may be omitted.

The sequence C<\b> is special inside a bracketed character class. While
outside the character class, C<\b> is an assertion indicating a point
that does not have either two word characters or two non-word characters
on either side, inside a bracketed character class, C<\b> matches a
backspace character.

The sequences
C<\a>,
C<\c>,
C<\e>,
C<\f>,
C<\n>,
C<\N{I<NAME>}>,
C<\N{U+I<hex char>}>,
C<\r>,
C<\t>,
and
C<\x>
are also special and have the same meanings as they do outside a
bracketed character class.

Also, a backslash followed by two or three octal digits is considered an octal
number.

A C<[> is not special inside a character class, unless it's the start of a
POSIX character class (see L</POSIX Character Classes> below). It normally does
not need escaping.

A C<]> is normally either the end of a POSIX character class (see
L</POSIX Character Classes> below), or it signals the end of the bracketed
character class.  If you want to include a C<]> in the set of characters, you
must generally escape it.

However, if the C<]> is the I<first> (or the second if the first
character is a caret) character of a bracketed character class, it
does not denote the end of the class (as you cannot have an empty class)
and is considered part of the set of characters that can be matched without
escaping.

Examples:

 "+"   =~ /[+?*]/     #  Match, "+" in a character class is not special.
 "\cH" =~ /[\b]/      #  Match, \b inside in a character class
                      #  is equivalent to a backspace.
 "]"   =~ /[][]/      #  Match, as the character class contains
                      #  both [ and ].
 "[]"  =~ /[[]]/      #  Match, the pattern contains a character class
                      #  containing just [, and the character class is
                      #  followed by a ].

=head3 Bracketed Character Classes and the C</xx> pattern modifier

Normally SPACE and TAB characters have no special meaning inside a
bracketed character class; they are just added to the list of characters
matched by the class.  But if the L<C</xx>|perlre/E<sol>x and E<sol>xx>
pattern modifier is in effect, they are generally ignored and can be
added to improve readability.  They can't be added in the middle of a
single construct:

 / [ \x{10 FFFF} ] /xx  # WRONG!

The SPACE in the middle of the hex constant is illegal.

To specify a literal SPACE character, you can escape it with a
backslash, like:

 /[ a e i o u \  ]/xx

This matches the English vowels plus the SPACE character.

For clarity, you should already have been using C<\t> to specify a
literal tab, and C<\t> is unaffected by C</xx>.

=head3 Character Ranges

It is not uncommon to want to match a range of characters. Luckily, instead
of listing all characters in the range, one may use the hyphen (C<->).
If inside a bracketed character class you have two characters separated
by a hyphen, it's treated as if all characters between the two were in
the class. For instance, C<[0-9]> matches any ASCII digit, and C<[a-m]>
matches any lowercase letter from the first half of the ASCII alphabet.

Note that the two characters on either side of the hyphen are not
necessarily both letters or both digits. Any character is possible,
although not advisable.  C<['-?]> contains a range of characters, but
most people will not know which characters that means.  Furthermore,
such ranges may lead to portability problems if the code has to run on
a platform that uses a different character set, such as EBCDIC.

If a hyphen in a character class cannot syntactically be part of a range, for
instance because it is the first or the last character of the character class,
or if it immediately follows a range, the hyphen isn't special, and so is
considered a character to be matched literally.  If you want a hyphen in
your set of characters to be matched and its position in the class is such
that it could be considered part of a range, you must escape that hyphen
with a backslash.

Examples:

 [a-z]       #  Matches a character that is a lower case ASCII letter.
 [a-fz]      #  Matches any letter between 'a' and 'f' (inclusive) or
             #  the letter 'z'.
 [-z]        #  Matches either a hyphen ('-') or the letter 'z'.
 [a-f-m]     #  Matches any letter between 'a' and 'f' (inclusive), the
             #  hyphen ('-'), or the letter 'm'.
 ['-?]       #  Matches any of the characters  '()*+,-./0123456789:;<=>?
             #  (But not on an EBCDIC platform).
 [\N{APOSTROPHE}-\N{QUESTION MARK}]
             #  Matches any of the characters  '()*+,-./0123456789:;<=>?
             #  even on an EBCDIC platform.
 [\N{U+27}-\N{U+3F}] # Same. (U+27 is "'", and U+3F is "?")

As the final two examples above show, you can achieve portability to
non-ASCII platforms by using the C<\N{...}> form for the range
endpoints.  These indicate that the specified range is to be interpreted
using Unicode values, so C<[\N{U+27}-\N{U+3F}]> means to match
C<\N{U+27}>, C<\N{U+28}>, C<\N{U+29}>, ..., C<\N{U+3D}>, C<\N{U+3E}>,
and C<\N{U+3F}>, whatever the native code point versions for those are.
These are called "Unicode" ranges.  If either end is of the C<\N{...}>
form, the range is considered Unicode.  A C<regexp> warning is raised
under C<S<"use re 'strict'">> if the other endpoint is specified
non-portably:

 [\N{U+00}-\x09]    # Warning under re 'strict'; \x09 is non-portable
 [\N{U+00}-\t]      # No warning;

Both of the above match the characters C<\N{U+00}> C<\N{U+01}>, ...
C<\N{U+08}>, C<\N{U+09}>, but the C<\x09> looks like it could be a
