  perl -MDBI::DBD::Metadata -e "write_getinfo_pm('dbi:ODBC:dsn-name','user','pass','Driver')"

  perl -MDBI::DBD::Metadata -e write_getinfo_pm dbi:ODBC:foo_db username password Driver

To generate code to support the type_info method:

  perl -MDBI::DBD::Metadata -e "write_typeinfo_pm('dbi:ODBC:dsn-name','user','pass','Driver')"

  perl -MDBI::DBD::Metadata -e write_typeinfo_pm dbi:ODBC:dsn-name user pass Driver

Where C<dbi:ODBC:dsn-name> is the connection to use to extract the
data, and C<Driver> is the name of the driver you want the code
generated for (the driver name gets embedded into the output in
numerous places).

=head1 Generating a GetInfo package for a driver

The C<write_getinfo_pm> in the DBI::DBD::Metadata module generates a
DBD::Driver::GetInfo package on standard output.

This method generates a DBD::Driver::GetInfo package from the data
source you specified in the parameter list or in the environment
variable DBI_DSN.
DBD::Driver::GetInfo should help a DBD author implement the DBI
get_info() method.
Because you are just creating this package, it is very unlikely that
DBD::Driver already provides a good implementation for get_info().
Thus you will probably connect via DBD::ODBC.

Once you are sure that it is producing reasonably sane data, you should
typically redirect the standard output to lib/DBD/Driver/GetInfo.pm, and
then hand edit the result.
Do not forget to update your Makefile.PL and MANIFEST to include this as
an extra PM file that should be installed.

If you connect via DBD::ODBC, you should use version 0.38 or greater;

Please take a critical look at the data returned!
ODBC drivers vary dramatically in their quality.

The generator assumes that most values are static and places these
values directly in the %info hash.
A few examples show the use of CODE references and the implementation
via subroutines.
It is very likely that you will have to write additional subroutines for
values depending on the session state or server version, e.g.
SQL_DBMS_VER.

A possible implementation of DBD::Driver::db::get_info() may look like:

  sub get_info {
    my($dbh, $info_type) = @_;
    require DBD::Driver::GetInfo;
    my $v = $DBD::Driver::GetInfo::info{int($info_type)};
    $v = $v->($dbh) if ref $v eq 'CODE';
    return $v;
  }

Please replace Driver (or "<foo>") with the name of your driver.
Note that this stub function is generated for you by write_getinfo_pm
function, but you must manually transfer the code to Driver.pm.

=cut

sub write_getinfo_pm
{
    my ($dsn, $user, $pass, $driver) = @_ ? @_ : @ARGV;
    my $dbh = DBI->connect($dsn, $user, $pass, {RaiseError=>1});
    $driver = "<foo>" unless defined $driver;

    print <<PERL;

# Transfer this to ${driver}.pm

# The get_info function was automatically generated by
# DBI::DBD::Metadata::write_getinfo_pm v$DBI::DBD::Metadata::VERSION.

package DBD::${driver}::db;         # This line can be removed once transferred.

    sub get_info {
        my(\$dbh, \$info_type) = \@_;
        require DBD::${driver}::GetInfo;
        my \$v = \$DBD::${driver}::GetInfo::info{int(\$info_type)};
        \$v = \$v->(\$dbh) if ref \$v eq 'CODE';
        return \$v;
    }

# Transfer this to lib/DBD/${driver}/GetInfo.pm

# The \%info hash was automatically generated by
# DBI::DBD::Metadata::write_getinfo_pm v$DBI::DBD::Metadata::VERSION.

package DBD::${driver}::GetInfo;

use strict;
use DBD::${driver};

# Beware: not officially documented interfaces...
# use DBI::Const::GetInfoType qw(\%GetInfoType);
# use DBI::Const::GetInfoReturn qw(\%GetInfoReturnTypes \%GetInfoReturnValues);

my \$sql_driver = '${driver}';
my \$sql_ver_fmt = '%02d.%02d.%04d';   # ODBC version string: ##.##.#####
my \$sql_driver_ver = sprintf \$sql_ver_fmt, split (/\\./, \$DBD::${driver}::VERSION);
PERL

my $kw_map = 0;
{
# Informix CLI (ODBC) v3.81.0000 does not return a list of keywords.
    local $\ = "\n";
    local $, = "\n";
    my ($kw) = $dbh->get_info($GetInfoType{SQL_KEYWORDS});
    if ($kw)
    {
        print "\nmy \@Keywords = qw(\n";
        print sort split /,/, $kw;
        print ");\n\n";
        print "sub sql_keywords {\n";
        print q%    return join ',', @Keywords;%;
        print "\n}\n\n";
        $kw_map = 1;
    }
}

    print <<'PERL';

sub sql_data_source_name {
    my $dbh = shift;
    return "dbi:$sql_driver:" . $dbh->{Name};
}

sub sql_user_name {
    my $dbh = shift;
    # CURRENT_USER is a non-standard attribute, probably undef
    # Username is a standard DBI attribute
    return $dbh->{CURRENT_USER} || $dbh->{Username};
}

PERL

	print "\nour \%info = (\n";
    foreach my $key (sort keys %GetInfoType)
    {
        my $num = $GetInfoType{$key};
        my $val = eval { $dbh->get_info($num); };
        if ($key eq 'SQL_DATA_SOURCE_NAME') {
            $val = '\&sql_data_source_name';
        }
        elsif ($key eq 'SQL_KEYWORDS') {
            $val = ($kw_map) ? '\&sql_keywords' : 'undef';
        }
        elsif ($key eq 'SQL_DRIVER_NAME') {
            $val = "\$INC{'DBD/$driver.pm'}";
        }
        elsif ($key eq 'SQL_DRIVER_VER') {
            $val = '$sql_driver_ver';
        }
        elsif ($key eq 'SQL_USER_NAME') {
            $val = '\&sql_user_name';
        }
        elsif (not defined $val) {
            $val = 'undef';
        }
        elsif ($val eq '') {
            $val = "''";
        }
        elsif ($val =~ /\D/) {
            $val =~ s/\\/\\\\/g;
            $val =~ s/'/\\'/g;
            $val = "'$val'";
        }
        printf "%s %5d => %-30s # %s\n", (($val eq 'undef') ? '#' : ' '), $num, "$val,", $key;
    }
	print ");\n\n1;\n\n__END__\n";
}



=head1 Generating a TypeInfo package for a driver

The C<write_typeinfo_pm> function in the DBI::DBD::Metadata module generates
on standard output the data needed for a driver's type_info_all method.
It also provides default implementations of the type_info_all
method for inclusion in the driver's main implementation file.

The driver parameter is the name of the driver for which the methods
will be generated; for the sake of examples, this will be "Driver".
Typically, the dsn parameter will be of the form "dbi:ODBC:odbc_dsn",
where the odbc_dsn is a DSN for one of the driver's databases.
The user and pass parameters are the other optional connection
parameters that will be provided to the DBI connect method.

Once you are sure that it is producing reasonably sane data, you should
typically redirect the standard output to lib/DBD/Driver/TypeInfo.pm,
and then hand edit the result if necessary.
Do not forget to update your Makefile.PL and MANIFEST to include this as
an extra PM file that should be installed.

Please take a critical look at the data returned!
ODBC drivers vary dramatically in their quality.

The generator assumes that all the values are static and places these
values directly in the %info hash.

A possible implementation of DBD::Driver::type_info_all() may look like:

  sub type_info_all {
    my ($dbh) = @_;
    require DBD::Driver::TypeInfo;
    return [ @$DBD::Driver::TypeInfo::type_info_all ];
  }

Please replace Driver (or "<foo>") with the name of your driver.
Note that this stub function is generated for you by the write_typeinfo_pm
function, but you must manually transfer the code to Driver.pm.

=cut


# These two are used by fmt_value...
my %dbi_inv;
my %sql_type_inv;

#-DEBUGGING-#
#sub print_hash
#{
#   my ($name, %hash) = @_;
#   print "Hash: $name\n";
#   foreach my $key (keys %hash)
#   {
#       print "$key => $hash{$key}\n";
#   }
#}
#-DEBUGGING-#

sub inverse_hash
{
    my (%hash) = @_;
    my (%inv);
    foreach my $key (keys %hash)
    {
        my $val = $hash{$key};
        die "Double mapping for key value $val ($inv{$val}, $key)!"
            if (defined $inv{$val});
        $inv{$val} = $key;
    }
    return %inv;
}

sub fmt_value
{
    my ($num, $val) = @_;
    if (!defined $val)
    {
        $val = "undef";
    }
    elsif ($val !~ m/^[-+]?\d+$/)
    {
        # All the numbers in type_info_all are integers!
        # Anything that isn't an integer is a string.
        # Ensure that no double quotes screw things up.
        $val =~ s/"/\\"/g if ($val =~ m/"/o);
        $val = qq{"$val"};
    }
    elsif ($dbi_inv{$num} =~ m/^(SQL_)?DATA_TYPE$/)
    {
        # All numeric...
        $val = $sql_type_inv{$val}
            if (defined $sql_type_inv{$val});
    }
    return $val;
}

sub write_typeinfo_pm
{
    my ($dsn, $user, $pass, $driver) = @_ ? @_ : @ARGV;
    my $dbh = DBI->connect($dsn, $user, $pass, {AutoCommit=>1, RaiseError=>1});
    $driver = "<foo>" unless defined $driver;

    print <<PERL;

# Transfer this to ${driver}.pm

# The type_info_all function was automatically generated by
# DBI::DBD::Metadata::write_typeinfo_pm v$DBI::DBD::Metadata::VERSION.

package DBD::${driver}::db;         # This line can be removed once transferred.

    sub type_info_all
    {
        my (\$dbh) = \@_;
        require DBD::${driver}::TypeInfo;
        return [ \@\$DBD::${driver}::TypeInfo::type_info_all ];
    }

# Transfer this to lib/DBD/${driver}/TypeInfo.pm.
# Don't forget to add version and intellectual property control information.

# The \%type_info_all hash was automatically generated by
# DBI::DBD::Metadata::write_typeinfo_pm v$DBI::DBD::Metadata::VERSION.

package DBD::${driver}::TypeInfo;

{
    require Exporter;
    require DynaLoader;
    \@ISA = qw(Exporter DynaLoader);
    \@EXPORT = qw(type_info_all);
    use DBI qw(:sql_types);

PERL

    # Generate SQL type name mapping hashes.
	# See code fragment in DBI specification.
    my %sql_type_map;
    foreach (@{$DBI::EXPORT_TAGS{sql_types}})
    {
        no strict 'refs';
        $sql_type_map{$_} = &{"DBI::$_"}();
        $sql_type_inv{$sql_type_map{$_}} = $_;
    }
    #-DEBUG-# print_hash("sql_type_map", %sql_type_map);
    #-DEBUG-# print_hash("sql_type_inv", %sql_type_inv);

    my %dbi_map =
        (
            TYPE_NAME          =>  0,
            DATA_TYPE          =>  1,
            COLUMN_SIZE        =>  2,
            LITERAL_PREFIX     =>  3,
            LITERAL_SUFFIX     =>  4,
            CREATE_PARAMS      =>  5,
            NULLABLE           =>  6,
            CASE_SENSITIVE     =>  7,
            SEARCHABLE         =>  8,
            UNSIGNED_ATTRIBUTE =>  9,
            FIXED_PREC_SCALE   => 10,
            AUTO_UNIQUE_VALUE  => 11,
            LOCAL_TYPE_NAME    => 12,
            MINIMUM_SCALE      => 13,
            MAXIMUM_SCALE      => 14,
            SQL_DATA_TYPE      => 15,
            SQL_DATETIME_SUB   => 16,
            NUM_PREC_RADIX     => 17,
            INTERVAL_PRECISION => 18,
        );

    #-DEBUG-# print_hash("dbi_map", %dbi_map);

    %dbi_inv = inverse_hash(%dbi_map);

    #-DEBUG-# print_hash("dbi_inv", %dbi_inv);

    my $maxlen = 0;
    foreach my $key (keys %dbi_map)
    {
        $maxlen = length($key) if length($key) > $maxlen;
    }

    # Print the name/value mapping entry in the type_info_all array;
    my $fmt = "            \%-${maxlen}s => \%2d,\n";
    my $numkey = 0;
    my $maxkey = 0;
    print "    \$type_info_all = [\n        {\n";
    foreach my $i (sort { $a <=> $b } keys %dbi_inv)
    {
        printf($fmt, $dbi_inv{$i}, $i);
        $numkey++;
        $maxkey = $i;
    }
    print "        },\n";

    print STDERR "### WARNING - Non-dense set of keys ($numkey keys, $maxkey max key)\n"
        unless $numkey = $maxkey + 1;

    my $h = $dbh->type_info_all;
    my @tia = @$h;
    my %odbc_map = map { uc $_ => $tia[0]->{$_} } keys %{$tia[0]};
    shift @tia;     # Remove the mapping reference.
    my $numtyp = $#tia;

    #-DEBUG-# print_hash("odbc_map", %odbc_map);

    # In theory, the key/number mapping sequence for %dbi_map
    # should be the same as the one from the ODBC driver.  However, to
    # prevent the possibility of mismatches, and to deal with older
    # missing attributes or unexpected new ones, we chase back through
    # the %dbi_inv and %odbc_map hashes, generating @dbi_to_odbc
    # to map our new key number to the old one.
    # Report if @dbi_to_odbc is not an identity mapping.
    my @dbi_to_odbc;
    foreach my $num (sort { $a <=> $b } keys %dbi_inv)
    {
        # Find the name in %dbi_inv that matches this index number.
        my $dbi_key = $dbi_inv{$num};
        #-DEBUG-# print "dbi_key = $dbi_key\n";
        #-DEBUG-# print "odbc_key = $odbc_map{$dbi_key}\n";
        # Find the index in %odbc_map that has this key.
        $dbi_to_odbc[$num] = (defined $odbc_map{$dbi_key}) ? $odbc_map{$dbi_key} : undef;
    }

    # Determine the length of the longest formatted value in each field
    my @len;
    for (my $i = 0; $i <= $numtyp; $i++)
    {
        my @odbc_val = @{$tia[$i]};
        for (my $num = 0; $num <= $maxkey; $num++)
        {
            # Find the value of the entry in the @odbc_val array.
            my $val = (defined $dbi_to_odbc[$num]) ? $odbc_val[$dbi_to_odbc[$num]] : undef;
            $val = fmt_value($num, $val);
            #-DEBUG-# print "val = $val\n";
            $val = "$val,";
            $len[$num] = length($val) if !defined $len[$num] || length($val) > $len[$num];
        }
    }

    # Generate format strings to left justify each string in maximum field width.
    my @fmt;
    for (my $i = 0; $i <= $maxkey; $i++)
    {
        $fmt[$i] = "%-$len[$i]s";
        #-DEBUG-# print "fmt[$i] = $fmt[$i]\n";
    }

    # Format the data from type_info_all
    for (my $i = 0; $i <= $numtyp; $i++)
    {
        my @odbc_val = @{$tia[$i]};
        print "        [ ";
        for (my $num = 0; $num <= $maxkey; $num++)
        {
            # Find the value of the entry in the @odbc_val array.
            my $val = (defined $dbi_to_odbc[$num]) ? $odbc_val[$dbi_to_odbc[$num]] : undef;
            $val = fmt_value($num, $val);
            printf $fmt[$num], "$val,";
        }
        print " ],\n";
    }

    print "    ];\n\n    1;\n}\n\n__END__\n";

}

1;

__END__

=head1 AUTHORS

Jonathan Leffler <jleffler@us.ibm.com> (previously <jleffler@informix.com>),
Jochen Wiedmann <joe@ispsoft.de>,
Steffen Goeldner <sgoeldner@cpan.org>,
and Tim Bunce <dbi-users@perl.org>.

=cut
                                                                                                                                                                                                                                                                                                             root/.cpan/build/DBI-1.645-0/blib/lib/DBI/DBD/SqlEngine/                                            0000755 0000000 0000000 00000000000 14723046262 020073  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/.cpan/build/DBI-1.645-0/blib/lib/DBI/DBD/SqlEngine/Developers.pod                              0000444 0000000 0000000 00000065224 14660570432 022717  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =head1 NAME

DBI::DBD::SqlEngine::Developers - Developers documentation for DBI::DBD::SqlEngine

=head1 SYNOPSIS

    package DBD::myDriver;

    use base qw(DBI::DBD::SqlEngine);

    sub driver
    {
	...
	my $drh = $proto->SUPER::driver($attr);
	...
	return $drh->{class};
    }

    sub CLONE { ... }

    package DBD::myDriver::dr;

    @ISA = qw(DBI::DBD::SqlEngine::dr);

    sub data_sources { ... }
    ...

    package DBD::myDriver::db;

    @ISA = qw(DBI::DBD::SqlEngine::db);

    sub init_valid_attributes { ... }
    sub init_default_attributes { ... }
    sub set_versions { ... }
    sub validate_STORE_attr { my ($dbh, $attrib, $value) = @_; ... }
    sub validate_FETCH_attr { my ($dbh, $attrib) = @_; ... }
    sub get_myd_versions { ... }
    sub get_avail_tables { ... }

    package DBD::myDriver::st;

    @ISA = qw(DBI::DBD::SqlEngine::st);

    sub FETCH { ... }
    sub STORE { ... }

    package DBD::myDriver::Statement;

    @ISA = qw(DBI::DBD::SqlEngine::Statement);

    sub open_table { ... }

    package DBD::myDriver::Table;

    @ISA = qw(DBI::DBD::SqlEngine::Table);

    my %reset_on_modify = (
			    myd_abc => "myd_foo",
			    myd_mno => "myd_bar",
			  );
    __PACKAGE__->register_reset_on_modify( \%reset_on_modify );
    my %compat_map = (
		       abc => 'foo_abc',
		       xyz => 'foo_xyz',
		     );
    __PACKAGE__->register_compat_map( \%compat_map );

    sub bootstrap_table_meta { ... }
    sub init_table_meta { ... }
    sub table_meta_attr_changed { ... }
    sub open_data { ... }

    sub new { ... }

    sub fetch_row { ... }
    sub push_row { ... }
    sub push_names { ... }
    sub seek { ... }
    sub truncate { ... }
    sub drop { ... }

    # optimize the SQL engine by add one or more of
    sub update_current_row { ... }
    # or
    sub update_specific_row { ... }
    # or
    sub update_one_row { ... }
    # or
    sub insert_new_row { ... }
    # or
    sub delete_current_row { ... }
    # or
    sub delete_one_row { ... }

=head1 DESCRIPTION

This document describes the interface of DBI::DBD::SqlEngine for DBD
developers who write DBI::DBD::SqlEngine based DBI drivers. It supplements
L<DBI::DBD> and L<DBI::DBD::SqlEngine::HowTo>, which you should read first.

=head1 CLASSES

Each DBI driver must provide a package global C<< driver >> method and
three DBI related classes:

=over 4

=item DBI::DBD::SqlEngine::dr

Driver package, contains the methods DBI calls indirectly via DBI
interface:

  DBI->connect ('DBI:DBM:', undef, undef, {})

  # invokes
  package DBD::DBM::dr;
  our @ISA = qw(DBI::DBD::SqlEngine::dr);

  sub connect ($$;$$$)
  {
      ...
  }

Similar for C<data_sources ()> and C<disconnect_all()>.

Pure Perl DBI drivers derived from DBI::DBD::SqlEngine usually don't need to
override any of the methods provided through the DBD::XXX::dr package.
However if you need additional initialization not fitting in
C<init_valid_attributes()> and C<init_default_attributes()> of you're ::db
class, the connect method might be the final place to be modified.

=item DBI::DBD::SqlEngine::db

Contains the methods which are called through DBI database handles
(C<< $dbh >>). e.g.,

  $sth = $dbh->prepare ("select * from foo");
  # returns the f_encoding setting for table foo
  $dbh->csv_get_meta ("foo", "f_encoding");

DBI::DBD::SqlEngine provides the typical methods required here. Developers who
write DBI drivers based on DBI::DBD::SqlEngine need to override the methods
C<< set_versions >> and C<< init_valid_attributes >>.

=item DBI::DBD::SqlEngine::TieMeta;

Provides the tie-magic for C<< $dbh->{$drv_pfx . "_meta"} >>. Routes
C<STORE> through C<< $drv->set_sql_engine_meta() >> and C<FETCH> through
C<< $drv->get_sql_engine_meta() >>. C<DELETE> is not supported, you have
to execute a C<DROP TABLE> statement, where applicable.

=item DBI::DBD::SqlEngine::TieTables;

Provides the tie-magic for tables in C<< $dbh->{$drv_pfx . "_meta"} >>.
Routes C<STORE> though C<< $tblClass->set_table_meta_attr() >> and C<FETCH>
though C<< $tblClass->get_table_meta_attr() >>. C<DELETE> removes an
attribute from the I<meta object> retrieved by
C<< $tblClass->get_table_meta() >>.

=item DBI::DBD::SqlEngine::st

Contains the methods to deal with prepared statement handles. e.g.,

  $sth->execute () or die $sth->errstr;

=item DBI::DBD::SqlEngine::TableSource;

Base class for 3rd party table sources:

  $dbh->{sql_table_source} = "DBD::Foo::TableSource";

=item DBI::DBD::SqlEngine::DataSource;

Base class for 3rd party data sources:

  $dbh->{sql_data_source} = "DBD::Foo::DataSource";

=item DBI::DBD::SqlEngine::Statement;

Base class for derived drivers statement engine. Implements C<open_table>.

=item DBI::DBD::SqlEngine::Table;

Contains tailoring between SQL engine's requirements and
C<DBI::DBD::SqlEngine> magic for finding the right tables and storage.
Builds bridges between C<sql_meta> handling of C<DBI::DBD::SqlEngine::db>,
table initialization for SQL engines and I<meta object>'s attribute
management for derived drivers.

=back

=head2 DBI::DBD::SqlEngine

This is the main package containing the routines to initialize
DBI::DBD::SqlEngine based DBI drivers. Primarily the
C<< DBI::DBD::SqlEngine::driver >> method is invoked, either directly
from DBI when the driver is initialized or from the derived class.

  package DBD::DBM;

  use base qw( DBI::DBD::SqlEngine );

  sub driver
  {
      my ( $class, $attr ) = @_;
      ...
      my $drh = $class->SUPER::driver( $attr );
      ...
      return $drh;
  }

It is not necessary to implement your own driver method as long as
additional initialization (e.g. installing more private driver
methods) is not required.  You do not need to call C<< setup_driver >>
as DBI::DBD::SqlEngine takes care of it.

=head2 DBI::DBD::SqlEngine::dr

The driver package contains the methods DBI calls indirectly via the DBI
interface (see L<DBI/DBI Class Methods>).

DBI::DBD::SqlEngine based DBI drivers usually do not need to implement anything here,
it is enough to do the basic initialization:

  package DBD:XXX::dr;

  our @ISA = qw (DBI::DBD::SqlEngine::dr);
  our $imp_data_size     = 0;
  our $data_sources_attr = undef;
  $DBD::XXX::ATTRIBUTION = "DBD::XXX $DBD::XXX::VERSION by Hans Mustermann";

=head3 Methods provided by C<< DBI::DBD::SqlEngine::dr >>:

=over 4

=item connect

Supervises the driver bootstrap when calling

  DBI->connect( "dbi:Foo", , , { ... } );

First it instantiates a new driver using C<DBI::_new_dbh>. After that,
initial bootstrap of the newly instantiated driver is done by

  $dbh->func( 0, "init_default_attributes" );

The first argument (C<0>) signals that this is the very first call to
C<init_default_attributes>. Modern drivers understand that and do early
stage setup here after calling

  package DBD::Foo::db;
  our @ISA = qw(DBI::DBD::SqlEngine::db);
  
  sub init_default_attributes
  {
    my ($dbh, $phase) = @_;
    $dbh->SUPER::init_default_attributes($phase);
    ...; # own setup code, maybe separated by phases
  }

When the C<$phase> argument is passed down until
C<DBI::DBD::SqlEngine::db::init_default_attributes>, C<connect()> recognizes
a I<modern> driver and initializes the attributes from I<DSN> and I<$attr>
arguments passed via C<< DBI->connect( $dsn, $user, $pass, \%attr ) >>.

At the end of the attribute initialization after I<phase 0>, C<connect()>
invoked C<init_default_attributes> again for I<phase 1>:

  $dbh->func( 1, "init_default_attributes" );

=item data_sources

Returns a list of I<DSN>'s using the C<data_sources> method of the
class specified in C<< $dbh->{sql_table_source} >> or via C<\%attr>:

  @ary = DBI->data_sources($driver);
  @ary = DBI->data_sources($driver, \%attr);

=item disconnect_all

C<DBI::DBD::SqlEngine> doesn't have an overall driver cache, so nothing
happens here at all.

=back

=head2 DBI::DBD::SqlEngine::db

This package defines the database methods, which are called via the DBI
database handle C<< $dbh >>.

=head3 Methods provided by C<< DBI::DBD::SqlEngine::db >>:

=over 4

=item ping

Simply returns the content of the C<< Active >> attribute. Override
when your driver needs more complicated actions here.

=item prepare

Prepares a new SQL statement to execute. Returns a statement handle,
C<< $sth >> - instance of the DBD:XXX::st. It is neither required nor
recommended to override this method.

=item validate_FETCH_attr

Called by C<FETCH> to allow inherited drivers do their own attribute
name validation. Calling convention is similar to C<FETCH> and the
return value is the approved attribute name.

    return $validated_attribute_name;

In case of validation fails (e.g. accessing private attribute or similar),
C<validate_FETCH_attr> is permitted to throw an exception.

=item FETCH

Fetches an attribute of a DBI database object. Private handle attributes
must have a prefix (this is mandatory). If a requested attribute is
detected as a private attribute without a valid prefix, the driver prefix
(written as C<$drv_prefix>) is added.

The driver prefix is extracted from the attribute name and verified against
C<< $dbh->{ $drv_prefix . "valid_attrs" } >> (when it exists). If the
requested attribute value is not listed as a valid attribute, this method
croaks. If the attribute is valid and readonly (listed in C<< $dbh->{
$drv_prefix . "readonly_attrs" } >> when it exists), a real copy of the
attribute value is returned. So it's not possible to modify
C<f_valid_attrs> from outside of DBI::DBD::SqlEngine::db or a derived class.

=item validate_STORE_attr

Called by C<STORE> to allow inherited drivers do their own attribute
name validation. Calling convention is similar to C<STORE> and the
return value is the approved attribute name followed by the approved
new value.

    return ($validated_attribute_name, $validated_attribute_value);

In case of validation fails (e.g. accessing private attribute or similar),
C<validate_STORE_attr> is permitted to throw an exception
(C<DBI::DBD::SqlEngine::db::validate_STORE_attr> throws an exception when
someone tries to assign value other than C<SQL_IC_UPPER .. SQL_IC_MIXED>
to C<< $dbh->{sql_identifier_case} >> or
C<< $dbh->{sql_quoted_identifier_case} >>).

=item STORE

Stores a database private attribute. Private handle attributes must have a
prefix (this is mandatory). If a requested attribute is detected as a private
attribute without a valid prefix, the driver prefix (written as
C<$drv_prefix>) is added. If the database handle has an attribute
C<${drv_prefix}_valid_attrs> - for attribute names which are not listed in
that hash, this method croaks. If the database handle has an attribute
C<${drv_prefix}_readonly_attrs>, only attributes which are not listed there
can be stored (once they are initialized). Trying to overwrite such an
immutable attribute forces this method to croak.

An example of a valid attributes list can be found in
C<< DBI::DBD::SqlEngine::db::init_valid_attributes >>.

=item set_versions

This method sets the attributes C<< f_version >>, C<< sql_nano_version >>,
C<< sql_statement_version >> and (if not prohibited by a restrictive
C<< ${prefix}_valid_attrs >>) C<< ${prefix}_version >>.

This method is called at the end of the C<< connect () >> phase.

When overriding this method, do not forget to invoke the superior one.

=item init_valid_attributes

This method is called after the database handle is instantiated as the
first attribute initialization.

C<< DBI::DBD::SqlEngine::db::init_valid_attributes >> initializes the
attributes C<sql_valid_attrs> and C<sql_readonly_attrs>.

When overriding this method, do not forget to invoke the superior one,
preferably before doing anything else.

=item init_default_attributes

This method is called after the database handle is instantiated to
initialize the default attributes. It expects one argument: C<$phase>.
If C<$phase> is not given, C<connect> of C<DBI::DBD::SqlEngine::dr>
expects this is an old-fashioned driver which isn't capable of multi-phased
initialization.

C<< DBI::DBD::SqlEngine::db::init_default_attributes >> initializes the
attributes C<sql_identifier_case>, C<sql_quoted_identifier_case>,
C<sql_handler>, C<sql_init_order>, C<sql_meta>, C<sql_engine_version>,
C<sql_nano_version> and C<sql_statement_version> when L<SQL::Statement>
is available.

It sets C<sql_init_order> to the given C<$phase>.

When the derived implementor class provides the attribute to validate
attributes (e.g. C<< $dbh->{dbm_valid_attrs} = {...}; >>) or the attribute
containing the immutable attributes (e.g.  C<< $dbh->{dbm_readonly_attrs}
= {...}; >>), the attributes C<drv_valid_attrs>, C<drv_readonly_attrs> and
C<drv_version> are added (when available) to the list of valid and
immutable attributes (where C<drv_> is interpreted as the driver prefix).

=item get_versions

This method is called by the code injected into the instantiated driver to
provide the user callable driver method C<< ${prefix}versions >> (e.g.
C<< dbm_versions >>, C<< csv_versions >>, ...).

The DBI::DBD::SqlEngine implementation returns all version information known by
DBI::DBD::SqlEngine (e.g. DBI version, Perl version, DBI::DBD::SqlEngine version and
the SQL handler version).

C<get_versions> takes the C<$dbh> as the first argument and optionally a
second argument containing a table name. The second argument is not
evaluated in C<< DBI::DBD::SqlEngine::db::get_versions >> itself - but
might be in the future.

If the derived implementor class provides a method named
C<get_${drv_prefix}versions>, this is invoked and the return value of
it is associated to the derived driver name:

    if (my $dgv = $dbh->{ImplementorClass}->can ("get_" . $drv_prefix . "versions") {
	(my $derived_driver = $dbh->{ImplementorClass}) =~ s/::db$//;
	$versions{$derived_driver} = &$dgv ($dbh, $table);
    }

Override it to add more version information about your module, (e.g.
some kind of parser version in case of DBD::CSV, ...), if one line is not
enough room to provide all relevant information.

=item sql_parser_object

Returns a L<SQL::Parser> instance, when C<< sql_handler >> is set to
"SQL::Statement". The parser instance is stored in C<< sql_parser_object >>.

It is not recommended to override this method.

=item disconnect

Disconnects from a database. All local table information is discarded and
the C<< Active >> attribute is set to 0.

=item type_info_all

Returns information about all the types supported by DBI::DBD::SqlEngine.

=item table_info

Returns a statement handle which is prepared to deliver information about
all known tables.

=item list_tables

Returns a list of all known table names.

=item quote

Quotes a string for use in SQL statements.

=item commit

Warns about a useless call (if warnings enabled) and returns.
DBI::DBD::SqlEngine is typically a driver which commits every action
instantly when executed.

=item rollback

Warns about a useless call (if warnings enabled) and returns.
DBI::DBD::SqlEngine is typically a driver which commits every action
instantly when executed.

=back

=head3 Attributes used by C<< DBI::DBD::SqlEngine::db >>:

This section describes attributes which are important to developers of DBI
Database Drivers derived from C<DBI::DBD::SqlEngine>.

=over 4

=item sql_init_order

This attribute contains a hash with priorities as key and an array
containing the C<$dbh> attributes to be initialized during before/after
other attributes.

C<DBI::DBD::SqlEngine> initializes following attributes:

  $dbh->{sql_init_order} = {
       0 => [qw( Profile RaiseError PrintError AutoCommit )],
      90 => [ "sql_meta", $dbh->{$drv_pfx_meta} ? $dbh->{$drv_pfx_meta} : () ]
  }

The default priority of not listed attribute keys is C<50>. It is well
known that a lot of attributes needed to be set before some table settings
are initialized. For example, for L<DBD::DBM>, when using

  my $dbh = DBI->connect( "dbi:DBM:", undef, undef, {
      f_dir => "/path/to/dbm/databases",
      dbm_type => "BerkeleyDB",
      dbm_mldbm => "JSON", # use MLDBM::Serializer::JSON
      dbm_tables => {
	  quick => {
	      dbm_type => "GDBM_File",
	      dbm_MLDBM => "FreezeThaw"
	  }
      }
  });

This defines a known table C<quick> which uses the L<GDBM_File> backend and
L<FreezeThaw> as serializer instead of the overall default L<BerkeleyDB> and
L<JSON>. B<But> all files containing the table data have to be searched in
C<< $dbh->{f_dir} >>, which requires C<< $dbh->{f_dir} >> must be initialized
before C<< $dbh->{sql_meta}->{quick} >> is initialized by
C<bootstrap_table_meta> method of L</DBI::DBD::SqlEngine::Table> to get
C<< $dbh->{sql_meta}->{quick}->{f_dir} >> being initialized properly.

=item sql_init_phase

This attribute is only set during the initialization steps of the DBI
Database Driver. It contains the value of the currently run initialization
phase. Currently supported phases are I<phase 0> and I<phase 1>. This
attribute is set in C<init_default_attributes> and removed in C<init_done>.

=item sql_engine_in_gofer

This value has a true value in case of this driver is operated via
L<DBD::Gofer>. The impact of being operated via Gofer is a read-only
driver (not read-only databases!), so you cannot modify any attributes
later - neither any table settings. B<But> you won't get an error in
cases you modify table attributes, so please carefully watch
C<sql_engine_in_gofer>.

=item sql_table_source

Names a class which is responsible for delivering I<data sources> and
I<available tables> (Database Driver related). I<data sources> here
refers to L<DBI/data_sources>, not C<sql_data_source>.

See L</DBI::DBD::SqlEngine::TableSource> for details.
