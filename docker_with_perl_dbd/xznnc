        op_precompute<Op>::apply(len);
        result_type retval = create_uninitalized_return_value<result_type>::apply(len);

        result_access_type returnAccess (retval);

        if (any_masked(array))
        {
            masked_access_type access (array);
            VectorizedOperation1<Op,result_access_type,masked_access_type> vop(returnAccess,access);
            dispatchTask(vop,len);
        }
        else
        {
            direct_access_type access (array);
            VectorizedOperation1<Op,result_access_type,direct_access_type> vop(returnAccess,access);
            dispatchTask(vop,len);
        }

        PY_IMATH_RETURN_PYTHON;
        return retval;
    }
};

template <class Op, class Vectorize, class Func>
struct VectorizedMemberFunction1 {
    BOOST_STATIC_ASSERT((size<Vectorize>::value+1 == function_traits<Func>::arity));

    typedef function_traits<Func> traits;

    typedef typename vectorized_result_type<typename traits::result_type,true_>::type result_type;

    typedef typename access_type<typename traits::arg1_type>::reference_type reference_type;
    typedef typename access_type<typename traits::arg1_type>::direct direct_access_type;
    typedef typename access_type<typename traits::arg1_type>::masked masked_access_type;

    typedef typename argument_access_type<typename traits::arg2_type,
                              typename at<Vectorize,long_<0> >::type>::type arg1_type;
    typedef typename argument_access_type<typename traits::arg2_type,
                              typename at<Vectorize,long_<0> >::type>::direct arg1_direct_access_type;
    typedef typename argument_access_type<typename traits::arg2_type,
                              typename at<Vectorize,long_<0> >::type>::masked arg1_masked_access_type;

    // The return value can't be const or masked.  Verify that condition.
    BOOST_STATIC_ASSERT( !is_const<result_type>::value );
    typedef typename result_type::WritableDirectAccess result_access_type;

    static result_type
    apply(reference_type array, arg1_type arg1)
    {
        PY_IMATH_LEAVE_PYTHON;
        size_t len = measure_arguments(array,arg1);
        op_precompute<Op>::apply(len);
        result_type retval = create_uninitalized_return_value<result_type>::apply(len);

        result_access_type returnAccess (retval);

        if (any_masked(array))
        {
            masked_access_type access (array);

            if (any_masked(arg1))
            {
                arg1_masked_access_type argAccess =
                     getArrayAccess<arg1_masked_access_type> (arg1);

                VectorizedOperation2<Op,result_access_type,
                                        masked_access_type,
                                   arg1_masked_access_type> vop (returnAccess, access, argAccess);
                dispatchTask(vop,len);
            }
            else
            {
                arg1_direct_access_type argAccess =
                     getArrayAccess<arg1_direct_access_type> (arg1);

                VectorizedOperation2<Op,result_access_type,
                                        masked_access_type,
                                   arg1_direct_access_type> vop (returnAccess, access, argAccess);
                dispatchTask(vop,len);
            }
        }
        else
        {
            direct_access_type access (array);

            if (any_masked(arg1))
            {
                arg1_masked_access_type argAccess =
                     getArrayAccess<arg1_masked_access_type> (arg1);

                VectorizedOperation2<Op,result_access_type,
                                        direct_access_type,
                                   arg1_masked_access_type> vop (returnAccess, access, argAccess);
                dispatchTask(vop,len);
            }
            else
            {
                arg1_direct_access_type argAccess =
                     getArrayAccess<arg1_direct_access_type> (arg1);

                VectorizedOperation2<Op,result_access_type,
                                        direct_access_type,
                                   arg1_direct_access_type> vop (returnAccess, access, argAccess);
                dispatchTask(vop,len);
            }
        }

        PY_IMATH_RETURN_PYTHON;
        return retval;
    }

    static std::string
    format_arguments(const boost::python::detail::keywords<1> &args)
    {
        // TODO: add types here
        return std::string("(")+args.elements[0].name+") - ";
    }
};

template <class Op, class Vectorize, class Func>
struct VectorizedMemberFunction2 {
    BOOST_STATIC_ASSERT((size<Vectorize>::value+1 == function_traits<Func>::arity));

    typedef function_traits<Func> traits;

    typedef typename vectorized_result_type<typename traits::result_type,true_>::type result_type;

    typedef typename access_type<typename traits::arg1_type>::reference_type reference_type;
    typedef typename access_type<typename traits::arg1_type>::direct direct_access_type;
    typedef typename access_type<typename traits::arg1_type>::masked masked_access_type;

    typedef typename argument_access_type<typename traits::arg2_type,
                              typename at<Vectorize,long_<0> >::type>::type arg1_type;
    typedef typename argument_access_type<typename traits::arg2_type,
                              typename at<Vectorize,long_<0> >::type>::direct arg1_direct_access_type;
    typedef typename argument_access_type<typename traits::arg2_type,
                              typename at<Vectorize,long_<0> >::type>::masked arg1_masked_access_type;

    typedef typename argument_access_type<typename traits::arg3_type,
                              typename at<Vectorize,long_<1> >::type>::type arg2_type;
    typedef typename argument_access_type<typename traits::arg3_type,
                              typename at<Vectorize,long_<1> >::type>::direct arg2_direct_access_type;
    typedef typename argument_access_type<typename traits::arg3_type,
                              typename at<Vectorize,long_<1> >::type>::masked arg2_masked_access_type;

    // The return value can't be const or masked.  Verify that condition.
    BOOST_STATIC_ASSERT( !is_const<result_type>::value );
    typedef typename result_type::WritableDirectAccess result_access_type;

    static result_type
    apply(reference_type array, arg1_type arg1, arg2_type arg2)
    {
        PY_IMATH_LEAVE_PYTHON;
        size_t len = measure_arguments(array,arg1,arg2);
        op_precompute<Op>::apply(len);
        result_type retval = create_uninitalized_return_value<result_type>::apply(len);

        result_access_type returnAccess (retval);

        if (any_masked(array))
        {
            masked_access_type access (array);

            if (any_masked(arg1))
            {
                arg1_masked_access_type arg1Access =
                     getArrayAccess<arg1_masked_access_type> (arg1);

                if (any_masked(arg2))
                {
                    arg2_masked_access_type arg2Access =
                         getArrayAccess<arg2_masked_access_type> (arg2);

                    VectorizedOperation3<Op,result_access_type,
                                            masked_access_type,
                                       arg1_masked_access_type,
                                       arg2_masked_access_type>
                        vop (returnAccess, access, arg1Access, arg2Access);
                    dispatchTask(vop,len);
                }
                else
                {
                    arg2_direct_access_type arg2Access =
                         getArrayAccess<arg2_direct_access_type> (arg2);

                    VectorizedOperation3<Op,result_access_type,
                                            masked_access_type,
                                       arg1_masked_access_type,
                                       arg2_direct_access_type>
                        vop (returnAccess, access, arg1Access, arg2Access);
                    dispatchTask(vop,len);
                }
            }
            else
            {
                arg1_direct_access_type arg1Access =
                     getArrayAccess<arg1_direct_access_type> (arg1);

                if (any_masked(arg2))
                {
                    arg2_masked_access_type arg2Access =
                         getArrayAccess<arg2_masked_access_type> (arg2);

                    VectorizedOperation3<Op,result_access_type,
                                            masked_access_type,
                                       arg1_direct_access_type,
                                       arg2_masked_access_type>
                        vop (returnAccess, access, arg1Access, arg2Access);
                    dispatchTask(vop,len);
                }
                else
                {
                    arg2_direct_access_type arg2Access =
                         getArrayAccess<arg2_direct_access_type> (arg2);

                    VectorizedOperation3<Op,result_access_type,
                                            masked_access_type,
                                       arg1_direct_access_type,
                                       arg2_direct_access_type>
                        vop (returnAccess, access, arg1Access, arg2Access);
                    dispatchTask(vop,len);
                }
            }
        }
        else
        {
            direct_access_type access (array);

            if (any_masked(arg1))
            {
                arg1_masked_access_type arg1Access =
                     getArrayAccess<arg1_masked_access_type> (arg1);

                if (any_masked(arg2))
                {
                    arg2_masked_access_type arg2Access =
                         getArrayAccess<arg2_masked_access_type> (arg2);

                    VectorizedOperation3<Op,result_access_type,
                                            direct_access_type,
                                       arg1_masked_access_type,
                                       arg2_masked_access_type>
                        vop (returnAccess, access, arg1Access, arg2Access);
                    dispatchTask(vop,len);
                }
                else
                {
                    arg2_direct_access_type arg2Access =
                         getArrayAccess<arg2_direct_access_type> (arg2);

                    VectorizedOperation3<Op,result_access_type,
                                            direct_access_type,
                                       arg1_masked_access_type,
                                       arg2_direct_access_type>
                        vop (returnAccess, access, arg1Access, arg2Access);
                    dispatchTask(vop,len);
                }
            }
            else
            {
                arg1_direct_access_type arg1Access =
                     getArrayAccess<arg1_direct_access_type> (arg1);

                if (any_masked(arg2))
                {
                    arg2_masked_access_type arg2Access =
                         getArrayAccess<arg2_masked_access_type> (arg2);

                    VectorizedOperation3<Op,result_access_type,
                                            direct_access_type,
                                       arg1_direct_access_type,
                                       arg2_masked_access_type>
                        vop (returnAccess, access, arg1Access, arg2Access);
                    dispatchTask(vop,len);
                }
                else
                {
                    arg2_direct_access_type arg2Access =
                         getArrayAccess<arg2_direct_access_type> (arg2);

                    VectorizedOperation3<Op,result_access_type,
                                            direct_access_type,
                                       arg1_direct_access_type,
                                       arg2_direct_access_type>
                        vop (returnAccess, access, arg1Access, arg2Access);
                    dispatchTask(vop,len);
                }
            }
        }

        PY_IMATH_RETURN_PYTHON;
        return retval;
    }

    static std::string
    format_arguments(const boost::python::detail::keywords<2> &args)
    {
        // TODO: add types here
        return std::string("(")+args.elements[0].name+","+args.elements[1].name+") - ";
    }
};

template <class Op, class Cls, class Func, class Keywords>
struct member_function_binding
{
    Cls &_cls;
    std::string _name, _doc;
    const Keywords &_args;

    member_function_binding(Cls &cls,const std::string &name, const std::string &doc,const Keywords &args)
        : _cls(cls), _name(name), _doc(doc), _args(args)
    {}

    template <class Vectorize>
    void operator()(Vectorize) const
    {
        typedef typename if_<is_same<void,typename function_traits<Func>::result_type>,
                             typename if_<boost::mpl::equal<Vectorize,boost::mpl::vector<boost::mpl::true_> >,
                                 VectorizedVoidMaskableMemberFunction1<Op,Func>,
                                 VectorizedVoidMemberFunction1<Op,Vectorize,Func> >::type,
                             VectorizedMemberFunction1<Op,Vectorize,Func>
                         >::type member_func1_type;

        typedef typename if_<is_same<void,typename function_traits<Func>::result_type>,
                         VectorizedVoidMemberFunction2<Op,Vectorize,Func>,
                         VectorizedMemberFunction2<Op,Vectorize,Func> >::type member_func2_type;

        typedef typename if_<is_same<void,typename function_traits<Func>::result_type>,
                         boost::python::return_internal_reference<>,  // the void vectorizations return a reference to self
                         boost::python::default_call_policies>::type call_policies;

        typedef typename at<vector<
            int,  // unused, arity 0
            int,  // unused, arity 1 - first argument corresponds to the class type
            member_func1_type,
            member_func2_type
            >,
            long_<function_traits<Func>::arity> >::type vectorized_function_type;
        std::string doc = _name + vectorized_function_type::format_arguments(_args) + _doc;
        _cls.def(_name.c_str(),&vectorized_function_type::apply,doc.c_str(),_args,call_policies());
    }
};

template <class Op,class Cls,class Func,class Keywords>
member_function_binding<Op,Cls,Func,Keywords>
build_member_function_binding(Cls &cls,Func *func,const std::string &name,const std::string &doc,const Keywords &args)
{
    return member_function_binding<Op,Cls,Func,Keywords>(cls,name,doc,args);
}

template <class Op,class Cls,class Vectorizable,class Keywords>
struct generate_member_bindings_struct
{
    //BOOST_STATIC_ASSERT(size<Vectorizable>::value+1 == function_traits<Op::apply>::arity);
    static void apply(Cls &cls,const std::string &name,const std::string &doc,const Keywords &args) {
        for_each<typename allowable_vectorizations<Vectorizable>::type>(build_member_function_binding<Op>(cls,Op::apply,name,doc,args));
    }
};

template <class Op,class Cls,class Func>
void
generate_single_member_binding(Cls &cls,Func *func,const std::string &name,const std::string &doc)
{
    typedef typename if_<is_same<void,typename function_traits<Func>::result_type>,
                         VectorizedVoidMemberFunction0<Op,boost::mpl::vector<>,Func>,
                         VectorizedMemberFunction0<Op,boost::mpl::vector<>,Func> >::type vectorized_function_type;

    typedef typename if_<is_same<void,typename function_traits<Func>::result_type>,
                         boost::python::return_internal_reference<>,  // the void vectorizations return a reference to self
                         boost::python::default_call_policies>::type call_policies;

    cls.def(name.c_str(),&vectorized_function_type::apply,doc.c_str(),call_policies());
}

} // namespace detail

// TODO: update for arg("name")=default_value syntax
template <class Op,class Vectorizable0>
void generate_bindings(const std::string &name,const std::string &doc,const boost::python::detail::keywords<1> &args) {
    using namespace detail;
    generate_bindings_struct<Op,vector<Vectorizable0>,boost::python::detail::keywords<1> >::apply(name,doc,args);
}

template <class Op,class Vectorizable0, class Vectorizable1>
void generate_bindings(const std::string &name,const std::string &doc,const boost::python::detail::keywords<2> &args) {
    using namespace detail;
    generate_bindings_struct<Op,vector<Vectorizable0,Vectorizable1>,boost::python::detail::keywords<2> >::apply(name,doc,args);
}

template <class Op,class Vectorizable0, class Vectorizable1, class Vectorizable2>
void generate_bindings(const std::string &name,const std::string &doc,const boost::python::detail::keywords<3> &args) {
    using namespace detail;
    generate_bindings_struct<Op,vector<Vectorizable0,Vectorizable1,Vectorizable2>,boost::python::detail::keywords<3> >::apply(name,doc,args);
}

template <class Op,class Vectorizable0, class Vectorizable1, class Vectorizable2, class Vectorizable3>
void generate_bindings(const std::string &name,const std::string &doc,const boost::python::detail::keywords<4> &args) {
    using namespace detail;
    generate_bindings_struct<Op,vector<Vectorizable0,Vectorizable1,Vectorizable2,Vectorizable3>,boost::python::detail::keywords<4> >::apply(name,doc,args);
}

template <class Op,class Vectorizable0, class Vectorizable1, class Vectorizable2, class Vectorizable3, class Vectorizable4>
void generate_bindings(const std::string &name,const std::string &doc,const boost::python::detail::keywords<5> &args) {
    using namespace detail;
    generate_bindings_struct<Op,vector<Vectorizable0,Vectorizable1,Vectorizable2,Vectorizable3,Vectorizable4>,boost::python::detail::keywords<5> >::apply(name,doc,args);
}

template <class Op,class Cls>
void
generate_member_bindings(Cls &cls,const std::string &name,const std::string &doc)
{
    using namespace detail;
    generate_single_member_binding<Op>(cls,&Op::apply,name,doc);
}

template <class Op,class Vectorizable0,class Cls>
void
generate_member_bindings(Cls &cls,const std::string &name,const std::string &doc,
                         const boost::python::detail::keywords<1> &args)
{
    using boost::mpl::vector;
    detail::generate_member_bindings_struct<Op,Cls,vector<Vectorizable0>,
                                            boost::python::detail::keywords<1> >::apply(cls,name,doc,args);
}

template <class Op,class Vectorizable0,class Vectorizable1,class Cls>
void
generate_member_bindings(Cls &cls,const std::string &name,const std::string &doc,
                         const boost::python::detail::keywords<2> &args)
{
    using boost::mpl::vector;
    detail::generate_member_bindings_struct<Op,Cls,vector<Vectorizable0,Vectorizable1>,
                                            boost::python::detail::keywords<2> >::apply(cls,name,doc,args);
}

} // namespace PyImath

#endif // _PyImathAutovectorize_h_
                                                                                                                                                                                                                                                                                                                                                                                            usr/include/Imath/PyImathBasicTypes.h                                                               0000644 0000000 0000000 00000000434 14330770346 016265  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //
// SPDX-License-Identifier: BSD-3-Clause
// Copyright Contributors to the OpenEXR Project.
//

// clang-format off


#ifndef _PyImathBasicTypes_h_
#define _PyImathBasicTypes_h_

#include "PyImathExport.h"

namespace PyImath {

PYIMATH_EXPORT void register_basicTypes();

}

#endif
                                                                                                                                                                                                                                    usr/include/Imath/PyImathBox.h                                                                      0000644 0000000 0000000 00000014044 14330770346 014751  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //
// SPDX-License-Identifier: BSD-3-Clause
// Copyright Contributors to the OpenEXR Project.
//

// clang-format off

#ifndef _PyImathBox_h_
#define _PyImathBox_h_

#include <Python.h>
#include <boost/python.hpp>
#include <ImathBox.h>
#include "PyImathVec.h"
#include "PyImathFixedArray.h"

namespace PyImath {

template <class T> boost::python::class_<IMATH_NAMESPACE::Box<T> > register_Box2();
template <class T> boost::python::class_<IMATH_NAMESPACE::Box<T> > register_Box3();

template <class T> boost::python::class_<FixedArray<IMATH_NAMESPACE::Box<T> > > register_BoxArray();

typedef FixedArray<IMATH_NAMESPACE::Box2s>   Box2sArray;
typedef FixedArray<IMATH_NAMESPACE::Box2i>   Box2iArray;
typedef FixedArray<IMATH_NAMESPACE::Box2i64> Box2i64Array;
typedef FixedArray<IMATH_NAMESPACE::Box2f>   Box2fArray;
typedef FixedArray<IMATH_NAMESPACE::Box2d>   Box2dArray;

typedef FixedArray<IMATH_NAMESPACE::Box3s>   Box3sArray;
typedef FixedArray<IMATH_NAMESPACE::Box3i>   Box3iArray;
typedef FixedArray<IMATH_NAMESPACE::Box3i64> Box3i64Array;
typedef FixedArray<IMATH_NAMESPACE::Box3f>   Box3fArray;
typedef FixedArray<IMATH_NAMESPACE::Box3d>   Box3dArray;

//

// Other code in the Zeno code base assumes the existance of a class with the
// same name as the Imath class, and with static functions wrap() and
// convert() to produce a PyImath object from an Imath object and vice-versa,
// respectively.  The class Boost generates from the Imath class does not
// have these properties, so we define a companion class here.
// The template argument, T, is the element type for the box (e.g., int,
// float).

template <class T>
class Box2 {
  public:
    static PyObject *	wrap (const IMATH_NAMESPACE::Box< IMATH_NAMESPACE::Vec2<T> > &b);
    static int		convert (PyObject *p, IMATH_NAMESPACE::Box< IMATH_NAMESPACE::Vec2<T> > *b);
};

template <class T>
class Box3 {
  public:
    static PyObject *	wrap (const IMATH_NAMESPACE::Box< IMATH_NAMESPACE::Vec3<T> > &b);
    static int		convert (PyObject *p, IMATH_NAMESPACE::Box< IMATH_NAMESPACE::Vec3<T> > *v);
};

template <class T>
PyObject *
Box2<T>::wrap (const IMATH_NAMESPACE::Box< IMATH_NAMESPACE::Vec2<T> > &b)
{
    typename boost::python::return_by_value::apply < IMATH_NAMESPACE::Box< IMATH_NAMESPACE::Vec2<T> > >::type converter;
    PyObject *p = converter (b);
    return p;
}

template <class T>
PyObject *
Box3<T>::wrap (const IMATH_NAMESPACE::Box< IMATH_NAMESPACE::Vec3<T> > &b)
{
    typename boost::python::return_by_value::apply < IMATH_NAMESPACE::Box< IMATH_NAMESPACE::Vec3<T> > >::type converter;
    PyObject *p = converter (b);
    return p;
}

template <class T>
int
Box2<T>::convert (PyObject *p, IMATH_NAMESPACE::Box< IMATH_NAMESPACE::Vec2<T> > *v)
{
    boost::python::extract < IMATH_NAMESPACE::Box<IMATH_NAMESPACE::V2i> > extractorV2i (p);
    if (extractorV2i.check())
    {
        IMATH_NAMESPACE::Box<IMATH_NAMESPACE::V2i> b = extractorV2i();
        v->min = b.min;
        v->max = b.max;
        return 1;
    }

    boost::python::extract < IMATH_NAMESPACE::Box<IMATH_NAMESPACE::V2f> > extractorV2f (p);
    if (extractorV2f.check())
    {
        IMATH_NAMESPACE::Box<IMATH_NAMESPACE::V2f> b = extractorV2f();
        v->min = b.min;
        v->max = b.max;
        return 1;
    }

    boost::python::extract < IMATH_NAMESPACE::Box<IMATH_NAMESPACE::V2d> > extractorV2d (p);
    if (extractorV2d.check())
    {
        IMATH_NAMESPACE::Box<IMATH_NAMESPACE::V2d> b = extractorV2d();
        v->min = b.min;
        v->max = b.max;
        return 1;
    }

    boost::python::extract <boost::python::tuple> extractorTuple (p);
    if (extractorTuple.check())
    {
        boost::python::tuple t = extractorTuple();
        if (t.attr ("__len__") () == 2)
        {
            PyObject *minObj = 
                boost::python::extract <boost::python::object> (t[0])().ptr();
            PyObject *maxObj = 
                boost::python::extract <boost::python::object> (t[1])().ptr();

            IMATH_NAMESPACE::Vec2<T> min, max;
            if (! V2<T>::convert (minObj, &min))
                return 0;
            if (! V2<T>::convert (maxObj, &max))
                return 0;

            v->min = min;
            v->max = max;

            return 1;
        }
    }

    return 0;
}

template <class T>
int
Box3<T>::convert (PyObject *p, IMATH_NAMESPACE::Box< IMATH_NAMESPACE::Vec3<T> > *v)
{
    boost::python::extract < IMATH_NAMESPACE::Box<IMATH_NAMESPACE::V3i> > extractorV3i (p);
    if (extractorV3i.check())
    {
        IMATH_NAMESPACE::Box<IMATH_NAMESPACE::V3i> b = extractorV3i();
        v->min = b.min;
        v->max = b.max;
        return 1;
    }

    boost::python::extract < IMATH_NAMESPACE::Box<IMATH_NAMESPACE::V3f> > extractorV3f (p);
    if (extractorV3f.check())
    {
        IMATH_NAMESPACE::Box<IMATH_NAMESPACE::V3f> b = extractorV3f();
        v->min = b.min;
        v->max = b.max;
        return 1;
    }

    boost::python::extract < IMATH_NAMESPACE::Box<IMATH_NAMESPACE::V3d> > extractorV3d (p);
    if (extractorV3d.check())
    {
        IMATH_NAMESPACE::Box<IMATH_NAMESPACE::V3d> b = extractorV3d();
        v->min = b.min;
        v->max = b.max;
        return 1;
    }

    boost::python::extract <boost::python::tuple> extractorTuple (p);
    if (extractorTuple.check())
    {
        boost::python::tuple t = extractorTuple();
        if (t.attr ("__len__") () == 2)
        {
            PyObject *minObj = 
                boost::python::extract <boost::python::object> (t[0])().ptr();
            PyObject *maxObj = 
                boost::python::extract <boost::python::object> (t[1])().ptr();

            IMATH_NAMESPACE::Vec3<T> min, max;
            if (! V3<T>::convert (minObj, &min))
                return 0;
            if (! V3<T>::convert (maxObj, &max))
                return 0;

            v->min = min;
            v->max = max;

            return 1;
        }
    }

    return 0;
}

typedef Box2<int>	Box2i;
typedef Box2<int64_t>	Box2i64;
typedef Box2<float>	Box2f;
typedef Box2<double>	Box2d;

typedef Box3<int>	Box3i;
typedef Box3<int64_t>	Box3i64;
typedef Box3<float>	Box3f;
typedef Box3<double>	Box3d;

}

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            usr/include/Imath/PyImathBoxArrayImpl.h                                                             0000644 0000000 0000000 00000004303 14330770346 016567  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //
// SPDX-License-Identifier: BSD-3-Clause
// Copyright Contributors to the OpenEXR Project.
//

// clang-format off

#ifndef _PyImathBoxArrayImpl_h_
#define _PyImathBoxArrayImpl_h_

//
// This .C file was turned into a header file so that instantiations
// of the various Box* types can be spread across multiple files in
// order to work around MSVC limitations.
//

#include <Python.h>
#include <boost/python.hpp>
#include <boost/python/make_constructor.hpp>
#include <boost/format.hpp>
#include <ImathVec.h>
#include <ImathVecAlgo.h>
#include <ImathBox.h>
#include "PyImath.h"
#include "PyImathBox.h"
#include "PyImathDecorators.h"
#include "PyImathMathExc.h"
#include "PyImathOperators.h"
#include "PyImathVecOperators.h"

namespace PyImath {
using namespace boost::python;
using namespace IMATH_NAMESPACE;

template <class T,int index>
static FixedArray<T>
BoxArray_get(FixedArray<IMATH_NAMESPACE::Box<T> > &va)
{
    return index == 0 ? 
           FixedArray<T>(&(va.unchecked_index(0).min),
                         va.len(),2*va.stride(),va.handle(),va.writable()) :
           FixedArray<T>(&(va.unchecked_index(0).max),
                         va.len(),2*va.stride(),va.handle(),va.writable());
}

template <class T>
static void
setItemTuple(FixedArray<IMATH_NAMESPACE::Box<T> > &va, Py_ssize_t index, const tuple &t)
{
    if(t.attr("__len__")() == 2)
    {
        Box<T> v;
        v.min = extract<T>(t[0]);
        v.max = extract<T>(t[1]);
        va[(size_t)va.canonical_index(index)] = v;
    }
    else
      throw std::invalid_argument ("tuple of length 2 expected");
}

template <class T>
class_<FixedArray<IMATH_NAMESPACE::Box<T> > >
register_BoxArray()
{
    using boost::mpl::true_;
    using boost::mpl::false_;

    class_<FixedArray<IMATH_NAMESPACE::Box<T> > > boxArray_class = FixedArray<IMATH_NAMESPACE::Box<T> >::register_("Fixed length array of IMATH_NAMESPACE::Box");
    boxArray_class
        .add_property("min",&BoxArray_get<T,0>)
        .add_property("max",&BoxArray_get<T,1>)
        .def("__setitem__", &setItemTuple<T>)
    ;

    add_comparison_functions(boxArray_class);
    decoratecopy(boxArray_class);

    return boxArray_class;
}

}  // namespace PyImath

#endif   // _PyImathBoxArrayImpl_h_
                                                                                                                                                                                                                                                                                                                             usr/include/Imath/PyImathBufferProtocol.h                                                           0000644 0000000 0000000 00000001074 14330770346 017153  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //
// SPDX-License-Identifier: BSD-3-Clause
// Copyright Contributors to the OpenEXR Project.
//

// clang-format off

#ifndef _PyImathBufferProtocol_h_
#define _PyImathBufferProtocol_h_

#include <boost/python.hpp>

namespace PyImath {

//  For more information on working with the protocol see:
//
//    https://docs.python.org/2.7/c-api/buffer.html
//    https://docs.python.org/3.7.10/c-api/buffer.html

template <class T>
void add_buffer_protocol (boost::python::class_<T> &classObj);

template <class ArrayT>
ArrayT* fixedArrayFromBuffer (PyObject *obj);

}

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    usr/include/Imath/PyImathColor.h                                                                    0000644 0000000 0000000 00000016444 14330770346 015305  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //
// SPDX-License-Identifier: BSD-3-Clause
// Copyright Contributors to the OpenEXR Project.
//

// clang-format off

#ifndef _PyImathColor3_h_
#define _PyImathColor3_h_

#include <Python.h>
#include <boost/python.hpp>
#include <ImathColor.h>
#include "PyImath.h"

namespace PyImath {

template <class T> boost::python::class_<IMATH_NAMESPACE::Color4<T> > register_Color4();
template <class T> boost::python::class_<PyImath::FixedArray2D<IMATH_NAMESPACE::Color4<T> > > register_Color4Array2D();
template <class T> boost::python::class_<PyImath::FixedArray<IMATH_NAMESPACE::Color4<T> > > register_Color4Array();
template <class T> boost::python::class_<IMATH_NAMESPACE::Color3<T>, boost::python::bases<IMATH_NAMESPACE::Vec3<T> > > register_Color3();
template <class T> boost::python::class_<PyImath::FixedArray<IMATH_NAMESPACE::Color3<T> > > register_Color3Array();

typedef FixedArray2D<IMATH_NAMESPACE::Color4f> Color4fArray;
typedef FixedArray2D<IMATH_NAMESPACE::Color4c> Color4cArray;
typedef FixedArray<IMATH_NAMESPACE::Color4f> C4fArray;
typedef FixedArray<IMATH_NAMESPACE::Color4c> C4cArray;
typedef FixedArray<IMATH_NAMESPACE::Color3f> C3fArray;
typedef FixedArray<IMATH_NAMESPACE::Color3c> C3cArray;

//
// Other code in the Zeno code base assumes the existance of a class with the
// same name as the Imath class, and with static functions wrap() and
// convert() to produce a PyImath object from an Imath object and vice-versa,
// respectively.  The class Boost generates from the Imath class does not
// have these properties, so we define a companion class here.
// The template argument, T, is the element type for the color in C++ (e.g., char,
// float).  The other argument, U, is how this type is represented in Python
// (e.g., int, float).

template <class T, class U>
class C3 {
  public:
    static PyObject *	wrap (const IMATH_NAMESPACE::Color3<T> &c);
    static int		convert (PyObject *p, IMATH_NAMESPACE::Color3<T> *v);
};

template <class T, class U>
class C4 {
  public:
    static PyObject *	wrap (const IMATH_NAMESPACE::Color4<T> &c);
    static int		convert (PyObject *p, IMATH_NAMESPACE::Color4<T> *v);
};

template <class T, class U>
PyObject *
C3<T, U>::wrap (const IMATH_NAMESPACE::Color3<T> &c)
{
    typename boost::python::return_by_value::apply < IMATH_NAMESPACE::Color3<T> >::type converter;
    PyObject *p = converter (c);
    return p;
}

template <class T, class U>
PyObject *
C4<T, U>::wrap (const IMATH_NAMESPACE::Color4<T> &c)
{
    typename boost::python::return_by_value::apply < IMATH_NAMESPACE::Color4<T> >::type converter;
    PyObject *p = converter (c);
    return p;
}

template <class T, class U>
int
C3<T, U>::convert (PyObject *p, IMATH_NAMESPACE::Color3<T> *v)
{
    boost::python::extract <IMATH_NAMESPACE::C3c> extractorC3c (p);
    if (extractorC3c.check())
    {
        IMATH_NAMESPACE::C3c c3c = extractorC3c();
        v->setValue (U(c3c[0]), U(c3c[1]), U(c3c[2]));
        return 1;
    }

    boost::python::extract <IMATH_NAMESPACE::C3f> extractorC3f (p);
    if (extractorC3f.check())
    {
        IMATH_NAMESPACE::C3f c3f = extractorC3f();
        v->setValue (U(c3f[0]), U(c3f[1]), U(c3f[2]));
        return 1;
    }

    boost::python::extract <boost::python::tuple> extractorTuple (p);
    if (extractorTuple.check())
    {
        boost::python::tuple t = extractorTuple();
        if (t.attr ("__len__") () == 3)
        {
            double a = boost::python::extract <double> (t[0]);
            double b = boost::python::extract <double> (t[1]);
            double c = boost::python::extract <double> (t[2]);
            v->setValue (U(a), U(b), U(c));
            return 1;
        }
    }

    boost::python::extract <boost::python::list> extractorList (p);
    if (extractorList.check())
    {
        boost::python::list l = extractorList();
        if (l.attr ("__len__") () == 3)
        {
            boost::python::extract <double> extractor0 (l[0]);
            boost::python::extract <double> extractor1 (l[1]);
            boost::python::extract <double> extractor2 (l[2]);
            if (extractor0.check() && extractor1.check() &&
                extractor2.check())
            {
                v->setValue (U(extractor0()), U(extractor1()),
                             U(extractor2()));
                return 1;
            }
        }
    }

    boost::python::extract <IMATH_NAMESPACE::V3i> extractorV3i (p);
    if (extractorV3i.check())
    {
        IMATH_NAMESPACE::V3i v3i = extractorV3i();
        v->setValue (U(v3i[0]), U(v3i[1]), U(v3i[2]));
        return 1;
    }

    boost::python::extract <IMATH_NAMESPACE::V3f> extractorV3f (p);
    if (extractorV3f.check())
    {
        IMATH_NAMESPACE::V3f v3f = extractorV3f();
        v->setValue (U(v3f[0]), U(v3f[1]), U(v3f[2]));
        return 1;
    }

    boost::python::extract <IMATH_NAMESPACE::V3d> extractorV3d (p);
    if (extractorV3d.check())
    {
        IMATH_NAMESPACE::V3d v3d = extractorV3d();
        v->setValue (U(v3d[0]), U(v3d[1]), U(v3d[2]));
        return 1;
    }

    return 0;
}

template <class T, class U>
int
C4<T, U>::convert (PyObject *p, IMATH_NAMESPACE::Color4<T> *v)
{
    boost::python::extract <IMATH_NAMESPACE::C4c> extractorC4c (p);
    if (extractorC4c.check())
    {
        IMATH_NAMESPACE::C4c c4c = extractorC4c();
        v->setValue (U(c4c[0]), U(c4c[1]), U(c4c[2]), U(c4c[3]));
        return 1;
    }

    boost::python::extract <IMATH_NAMESPACE::C4f> extractorC4f (p);
    if (extractorC4f.check())
    {
        IMATH_NAMESPACE::C4f c4f = extractorC4f();
        v->setValue (U(c4f[0]), U(c4f[1]), U(c4f[2]), U(c4f[3]));
        return 1;
    }

    boost::python::extract <boost::python::tuple> extractorTuple (p);
    if (extractorTuple.check())
    {
        boost::python::tuple t = extractorTuple();
        if (t.attr ("__len__") () == 4)
        {
            // As with V3<T>, we extract the tuple elements as doubles and
            // cast them to Ts in setValue(), to avoid any odd cases where
            // extracting them as Ts from the start would fail.

            double a = boost::python::extract <double> (t[0]);
            double b = boost::python::extract <double> (t[1]);
            double c = boost::python::extract <double> (t[2]);
            double d = boost::python::extract <double> (t[3]);
            v->setValue (U(a), U(b), U(c), U(d));
            return 1;
        }
    }

    boost::python::extract <boost::python::list> extractorList (p);
    if (extractorList.check())
    {
        boost::python::list l = extractorList();
        if (l.attr ("__len__") () == 4)
        {
            boost::python::extract <double> extractor0 (l[0]);
            boost::python::extract <double> extractor1 (l[1]);
            boost::python::extract <double> extractor2 (l[2]);
            boost::python::extract <double> extractor3 (l[3]);
            if (extractor0.check() && extractor1.check() &&
                extractor2.check() && extractor3.check())
            {
                v->setValue (U(extractor0()), U(extractor1()),
                             U(extractor2()), U(extractor3()));
                return 1;
            }
        }
    }

    return 0;
}


typedef C3<float, float>	Color3f;
typedef C3<unsigned char, int>	Color3c;
typedef Color3f			C3f;
typedef Color3c			C3c;

typedef C4<float, float>	Color4f;
typedef C4<unsigned char, int>	Color4c;
typedef Color4f			C4f;
typedef Color4c			C4c;

