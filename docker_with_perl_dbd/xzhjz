Here "myfoobar" is a name that the user can choose, the only condition is that
it differs from other packages.

In your documentation you explain what the plugins do, and tell the user how
to load the optional plugin: >
	:packadd! fooextra

You could add this packadd command in one of your plugins, to be executed when
the optional plugin is needed.

Run the `:helptags` command to generate the doc/tags file.  Including this
generated file in the package means that the user can drop the package in the
pack directory and the help command works right away.  Don't forget to re-run
the command after changing the plugin help: >
	:helptags path/start/foobar/doc
	:helptags path/opt/fooextra/doc


Dependencies between plugins ~
							*packload-two-steps*
Suppose you have two plugins that depend on the same functionality. You can
put the common functionality in an autoload directory, so that it will be
found automatically.  Your package would have these files:

	pack/foo/start/one/plugin/one.vim  >
		call foolib#getit()
<	pack/foo/start/two/plugin/two.vim >
		call foolib#getit()
<	pack/foo/start/lib/autoload/foolib.vim >
		func foolib#getit()

This works, because loading packages will first add all found directories to
'runtimepath' before sourcing the plugins.

==============================================================================
7. Debugging scripts					*debug-scripts*

Besides the obvious messages that you can add to your scripts to find out what
they are doing, Vim offers a debug mode.  This allows you to step through a
sourced file or user function and set breakpoints.

NOTE: The debugging mode is far from perfect.  Debugging will have side
effects on how Vim works.  You cannot use it to debug everything.  For
example, the display is messed up by the debugging messages.

An alternative to debug mode is setting the 'verbose' option.  With a bigger
number it will give more verbose messages about what Vim is doing.


STARTING DEBUG MODE						*debug-mode*

To enter debugging mode use one of these methods:
1. Start Vim with the |-D| argument: >
	vim -D file.txt
<  Debugging will start as soon as the first vimrc file is sourced.  This is
   useful to find out what is happening when Vim is starting up.  A side
   effect is that Vim will switch the terminal mode before initialisations
   have finished, with unpredictable results.
   For a GUI-only version (Windows, Macintosh) the debugging will start as
   soon as the GUI window has been opened.  To make this happen early, add a
   ":gui" command in the vimrc file.
								*:debug*
2. Run a command with ":debug" prepended.  Debugging will only be done while
   this command executes.  Useful for debugging a specific script or user
   function.  And for scripts and functions used by autocommands.  Example: >
	:debug edit test.txt.gz

3. Set a breakpoint in a sourced file or user function.  You could do this in
   the command line: >
	vim -c "breakadd file */explorer.vim" .
<  This will run Vim and stop in the first line of the "explorer.vim" script.
   Breakpoints can also be set while in debugging mode.

In debugging mode every executed command is displayed before it is executed.
Comment lines, empty lines and lines that are not executed are skipped.  When
a line contains two commands, separated by "|", each command will be displayed
separately.


DEBUG MODE

Once in debugging mode, the usual Ex commands can be used.  For example, to
inspect the value of a variable: >
	echo idx
When inside a user function, this will print the value of the local variable
"idx".  Prepend "g:" to get the value of a global variable: >
	echo g:idx
All commands are executed in the context of the current function or script.
You can also set options, for example setting or resetting 'verbose' will show
what happens, but you might want to set it just before executing the lines you
are interested in: >
	:set verbose=20

Commands that require updating the screen should be avoided, because their
effect won't be noticed until after leaving debug mode.  For example: >
	:help
won't be very helpful.

There is a separate command-line history for debug mode.

NOTE: In Vim9 script, if a command is written at the script level and
continues on the next line, not using the old way with a backslash for line
continuation, only the first line is printed before the debugging prompt.

The line number for a function line is relative to the start of the function.
If you have trouble figuring out where you are, edit the file that defines
the function in another Vim, search for the start of the function and do
"99j".  Replace "99" with the line number.

Additionally, these commands can be used:
							*>cont*
	cont		Continue execution until the next breakpoint is hit.
							*>quit*
	quit		Abort execution.  This is like using CTRL-C, some
			things might still be executed, doesn't abort
			everything.  Still stops at the next breakpoint.
							*>next*
	next		Execute the command and come back to debug mode when
			it's finished.  This steps over user function calls
			and sourced files.
							*>step*
	step		Execute the command and come back to debug mode for
			the next command.  This steps into called user
			functions and sourced files.
							*>interrupt*
	interrupt	This is like using CTRL-C, but unlike ">quit" comes
			back to debug mode for the next command that is
			executed.  Useful for testing |:finally| and |:catch|
			on interrupt exceptions.
							*>finish*
	finish		Finish the current script or user function and come
			back to debug mode for the command after the one that
			sourced or called it.
							*>bt*
							*>backtrace*
							*>where*
	backtrace	Show the call stacktrace for current debugging session.
	bt
	where
							*>frame*
	frame N		Goes to N backtrace level. + and - signs make movement
			relative.  E.g., ":frame +3" goes three frames up.
							*>up*
	up		Goes one level up from call stacktrace.
							*>down*
	down		Goes one level down from call stacktrace.

About the additional commands in debug mode:
- There is no command-line completion for them, you get the completion for the
  normal Ex commands only.
- You can shorten them, up to a single character, unless more than one command
  starts with the same letter.  "f" stands for "finish", use "fr" for "frame".
- Hitting <CR> will repeat the previous one.  When doing another command, this
  is reset (because it's not clear what you want to repeat).
- When you want to use the Ex command with the same name, prepend a colon:
  ":cont", ":next", ":finish" (or shorter).
							*vim9-debug*
When debugging a compiled :def function, "step" will stop before every
executed line, not every single instruction.  Thus it works mostly like a not
compiled function.  Access to local variables is limited you can use: >
	echo varname
But not much else.
When executing a command that is not a specific bytecode instruction but
executed like a normal Ex command, "step" will stop once in the compiled
context, where local variables can be inspected, and once just before
executing the command.

In a :def function variables that haven't been declared yet cannot be
inspected.  Variables that have been declared can be inspected, also when the
block they were declared in has finished.  In commands this would not be
possible, thus is slightly misleading (but can be useful).

The backtrace shows the hierarchy of function calls, e.g.:
	>bt ~
	  3 function One[3] ~
	  2 Two[3] ~
	->1 Three[3] ~
	  0 Four ~
	line 1: let four = 4 ~

The "->" points to the current frame.  Use "up", "down" and "frame N" to
select another frame.

In the current frame you can evaluate the local function variables.  There is
no way to see the command at the current line yet.


DEFINING BREAKPOINTS
							*:breaka* *:breakadd*
:breaka[dd] func [lnum] {name}
		Set a breakpoint in a function.  Example: >
			:breakadd func Explore
<		Doesn't check for a valid function name, thus the breakpoint
		can be set before the function is defined.

:breaka[dd] file [lnum] {name}
		Set a breakpoint in a sourced file.  Example: >
			:breakadd file 43 .vimrc

:breaka[dd] here
		Set a breakpoint in the current line of the current file.
		Like doing: >
			:breakadd file <cursor-line> <current-file>
<		Note that this only works for commands that are executed when
		sourcing the file, not for a function defined in that file.

:breaka[dd] expr {expression}
		Sets a breakpoint, that will break whenever the {expression}
		evaluates to a different value. Example: >
			:breakadd expr g:lnum
<		Will break, whenever the global variable lnum changes.

		Errors in evaluation are suppressed, you can use the name of a
		variable that does not exist yet.  This also means you will
		not notice anything if the expression has a mistake.

		Note if you watch a |script-variable| this will break
		when switching scripts, since the script variable is only
		valid in the script where it has been defined and if that
		script is called from several other scripts, this will stop
		whenever that particular variable will become visible or
		inaccessible again.

The [lnum] is the line number of the breakpoint.  Vim will stop at or after
this line.  When omitted line 1 is used.

							*:debug-name*
{name} is a pattern that is matched with the file or function name.  The
pattern is like what is used for autocommands.  There must be a full match (as
if the pattern starts with "^" and ends in "$").  A "*" matches any sequence
of characters.  'ignorecase' is not used, but "\c" can be used in the pattern
to ignore case |/\c|.  Don't include the () for the function name!

The match for sourced scripts is done against the full file name.  If no path
is specified the current directory is used.  Examples: >
	breakadd file explorer.vim
matches "explorer.vim" in the current directory. >
	breakadd file *explorer.vim
matches ".../plugin/explorer.vim", ".../plugin/iexplorer.vim", etc. >
	breakadd file */explorer.vim
matches ".../plugin/explorer.vim" and "explorer.vim" in any other directory.

The match for functions is done against the name as it's shown in the output
of ":function".  However, for local functions the script-specific prefix such
as "<SNR>99_" is ignored to make it easier to match script-local functions
without knowing the ID of the script.

Note that functions are first loaded and later executed.  When they are loaded
the "file" breakpoints are checked, when they are executed the "func"
breakpoints.


DELETING BREAKPOINTS
						*:breakd* *:breakdel* *E161*
:breakd[el] {nr}
		Delete breakpoint {nr}.  Use |:breaklist| to see the number of
		each breakpoint.

:breakd[el] *
		Delete all breakpoints.

:breakd[el] func [lnum] {name}
		Delete a breakpoint in a function.

:breakd[el] file [lnum] {name}
		Delete a breakpoint in a sourced file.

:breakd[el] here
		Delete a breakpoint at the current line of the current file.

When [lnum] is omitted, the first breakpoint in the function or file is
deleted.
The {name} must be exactly the same as what was typed for the ":breakadd"
command.  "explorer", "*explorer.vim" and "*explorer*" are different.


LISTING BREAKPOINTS
							*:breakl* *:breaklist*
:breakl[ist]
		List all breakpoints.


OBSCURE

						*:debugg* *:debuggreedy*
:debugg[reedy]
		Read debug mode commands from the normal input stream, instead
		of getting them directly from the user.  Only useful for test
		scripts.  Example: >
		  echo 'q^Mq' | vim -e -s -c debuggreedy -c 'breakadd file script.vim' -S script.vim

:0debugg[reedy]
		Undo ":debuggreedy": get debug mode commands directly from the
		user, don't use typeahead for debug commands.

==============================================================================
8. Profiling						*profile* *profiling*

Profiling means that Vim measures the time that is spent on executing
functions and/or scripts.  The |+profile| feature is required for this.
It is included when Vim was compiled with "huge" features.

You can also use the |reltime()| function to measure time.  This only requires
the |+reltime| feature, which is present in more builds.

For profiling syntax highlighting see |:syntime|.

For example, to profile the one_script.vim script file: >
	:profile start /tmp/one_script_profile
	:profile file one_script.vim
	:source one_script.vim
	:exit


:prof[ile] start {fname}			*:prof* *:profile* *E750*
		Start profiling, write the output in {fname} upon exit or when
		a `:profile stop` or `:profile dump` command is invoked.
		"~/" and environment variables in {fname} will be expanded.
		If {fname} already exists it will be silently overwritten.
		The variable |v:profiling| is set to one.

:prof[ile] stop
		Write the collected profiling information to the logfile and
		stop profiling. You can use the `:profile start` command to
		clear the profiling statistics and start profiling again.

:prof[ile] pause
		Don't profile until the following `:profile continue`.  Can be
		used when doing something that should not be counted (e.g., an
		external command).  Does not nest.

:prof[ile] continue
		Continue profiling after `:profile pause`.

:prof[ile] func {pattern}
		Profile function that matches the pattern {pattern}.
		See |:debug-name| for how {pattern} is used.

:prof[ile][!] file {pattern}
		Profile script file that matches the pattern {pattern}.
		See |:debug-name| for how {pattern} is used.
		This only profiles the script itself, not the functions
		defined in it.
		When the [!] is added then all functions defined in the script
		will also be profiled.
		Note that profiling only starts when the script is loaded
		after this command.  A :profile command in the script itself
		won't work.

:prof[ile] dump
		Write the current state of profiling to the logfile
		immediately.  After running this command, Vim continues to
		collect the profiling statistics.

:profd[el] ...						*:profd* *:profdel*
		Stop profiling for the arguments specified. See |:breakdel|
		for the arguments. Examples: >
			profdel func MyFunc
			profdel file MyScript.vim
			profdel here

You must always start with a ":profile start fname" command.  The resulting
file is written when Vim exits.  For example, to profile one specific
function: >
	profile start /tmp/vimprofile
	profile func MyFunc

Here is an example of the output, with line
numbers prepended for the explanation:

  1 FUNCTION  Test2() ~
  2 Called 1 time ~
  3 Total time:   0.155251 ~
  4  Self time:   0.002006 ~
  5  ~
  6 count  total (s)   self (s) ~
  7	9	       0.000096   for i in range(8) ~
  8	8   0.153655   0.000410     call Test3() ~
  9	8	       0.000070   endfor ~
 10				  " Ask a question ~
 11	1	       0.001341   echo input("give me an answer: ") ~

The header (lines 1-4) gives the time for the whole function.  The "Total"
time is the time passed while the function was executing.  The "Self" time is
the "Total" time reduced by time spent in:
- other user defined functions
- sourced scripts
- executed autocommands
- external (shell) commands

Lines 7-11 show the time spent in each executed line.  Lines that are not
executed do not count.  Thus a comment line is never counted.

The Count column shows how many times a line was executed.  Note that the
"for" command in line 7 is executed one more time as the following lines.
That is because the line is also executed to detect the end of the loop.

The time Vim spends waiting for user input isn't counted at all.  Thus how
long you take to respond to the input() prompt is irrelevant.

Profiling should give a good indication of where time is spent, but keep in
mind there are various things that may clobber the results:

- The accuracy of the time measured depends on the gettimeofday() system
  function.  It may only be as accurate as 1/100 second, even though the times
  are displayed in micro seconds.

- Real elapsed time is measured, if other processes are busy they may cause
  delays at unpredictable moments.  You may want to run the profiling several
  times and use the lowest results.

- If you have several commands in one line you only get one time.  Split the
  line to see the time for the individual commands.

- The time of the lines added up is mostly less than the time of the whole
  function.  There is some overhead in between.

- Functions that are deleted before Vim exits will not produce profiling
  information.  You can check the |v:profiling| variable if needed: >
	:if !v:profiling
	:   delfunc MyFunc
	:endif
<
- Profiling may give weird results on multi-processor systems, when sleep
  mode kicks in or the processor frequency is reduced to save power.

- The "self" time is wrong when a function is used recursively.


 vim:tw=78:ts=8:noet:ft=help:norl:
                                                                                                                                                                                                            usr/share/vim/vim90/doc/rileft.txt                                                                  0000644 0000000 0000000 00000011707 14424703754 015531  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        *rileft.txt*    For Vim version 9.0.  Last change: 2022 Oct 12


		  VIM REFERENCE MANUAL    by Avner Lottem
					  updated by Nadim Shaikli


Right to Left display mode for Vim				*rileft*


These functions were originally created by Avner Lottem:
   E-mail: alottem@iil.intel.com
   Phone:  +972-4-8307322

								*E26*
{only available when compiled with the |+rightleft| feature}


Introduction
------------
Some languages such as Arabic, Farsi, Hebrew (among others) require the
ability to display their text from right-to-left.  Files in those languages
are stored conventionally and the right-to-left requirement is only a
function of the display engine (per the Unicode specification).  In
right-to-left oriented files the characters appear on the screen from
right to left.

Bidirectionality (or bidi for short) is what Unicode offers as a full
solution to these languages.  Bidi offers the user the ability to view
both right-to-left as well as left-to-right text properly at the same time
within the same window.  Vim currently, due to simplicity, does not offer
bidi and is merely opting to present a functional means to display/enter/use
right-to-left languages.  An older hybrid solution in which direction is
encoded for every character (or group of characters) are not supported either
as this kind of support is out of the scope of a simple addition to an
existing editor (and it's not sanctioned by Unicode either).

As many people working on the code do not use the right-to-left mode, this
feature may not work in some situations.  If you can describe what is wrong
and how it would work when fixed, please create an issue on github, see
|bug-reports|.


Highlights
----------
o  Editing left-to-right files as in the original Vim, no change.

o  Viewing and editing files in right-to-left windows.  File orientation
   is per window, so it is possible to view the same file in right-to-left
   and left-to-right modes, simultaneously.  (Useful for editing mixed files
   in which both right-to-left and left-to-right text exist).

o  Compatibility to the original Vim.  Almost all features work in
   right-to-left mode (see Bugs below).

o  Backing from reverse insert mode to the correct place in the file
   (if possible).

o  No special terminal with right-to-left capabilities is required.  The
   right-to-left changes are completely hardware independent.

o  Many languages use and require right-to-left support.  These languages
   can quite easily be supported given the inclusion of their required
   keyboard mappings and some possible minor code change.  Some of the
   current supported languages include - |arabic.txt|, |farsi.txt| and
   |hebrew.txt|.


Of Interest...
--------------

o  Invocations
   -----------
   + 'rightleft' ('rl') sets window orientation to right-to-left.
   + 'delcombine' ('deco'), boolean, if editing UTF-8 encoded languages,
     allows one to remove a composing character which gets superimposed
     on those that preceded them (some languages require this).
   + 'rightleftcmd' ('rlc') sets the command-line within certain modes
     (such as search) to be utilized in right-to-left orientation as well.

o  Typing backwards					*ins-reverse*
   ----------------
   In lieu of using the full-fledged 'rightleft' option, one can opt for
   reverse insertion.  When the 'revins' (reverse insert) option is set,
   inserting happens backwards.  This can be used to type right-to-left
   text.  When inserting characters the cursor is not moved and the text
   moves rightwards.  A <BS> deletes the character under the cursor.
   CTRL-W and CTRL-U also work in the opposite direction.  <BS>, CTRL-W
   and CTRL-U do not stop at the start of insert or end of line, no matter
   how the 'backspace' option is set.

   There is no reverse replace mode (yet).

   If the 'showmode' option is set, "-- REVERSE INSERT --" will be shown
   in the status line when reverse Insert mode is active.

o  Pasting when in a rightleft window
   ----------------------------------
   When cutting text with the mouse and pasting it in a rightleft window
   the text will be reversed, because the characters come from the cut buffer
   from the left to the right, while inserted in the file from the right to
   the left.   In order to avoid it, toggle 'revins' before pasting.


Bugs
----
o  Does not handle CTRL-A and CTRL-X commands (add and subtract) correctly
   when in rightleft window.

o  Does not support reverse insert and rightleft modes on the command-line.
   However, functionality of the editor is not reduced, because it is
   possible to enter mappings, abbreviations and searches typed from the
   left to the right on the command-line.

o  Somewhat slower in right-to-left mode, because right-to-left motion is
   emulated inside Vim, not by the controlling terminal.

o  When both 'rightleft' and 'revins' are on: 'textwidth' does not work.
   Lines do not wrap at all; you just get a single, long line.

o  There is no full bidirectionality (bidi) support.


 vim:tw=78:ts=8:noet:ft=help:norl:
                                                         usr/share/vim/vim90/doc/russian.txt                                                                 0000644 0000000 0000000 00000005720 14424703754 015726  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        *russian.txt*   For Vim version 9.0.  Last change: 2006 Apr 24


		  VIM REFERENCE MANUAL    by Vassily Ragosin


Russian language localization and support in Vim	   *russian* *Russian*

1. Introduction				  |russian-intro|
2. Russian keymaps			  |russian-keymap|
3. Localization				  |russian-l18n|
4. Known issues				  |russian-issues|

===============================================================================
1. Introduction							*russian-intro*

Russian language is supported perfectly well in Vim.  You can type and view
Russian text just as any other, without the need to tweak the settings.

===============================================================================
2. Russian keymaps					       *russian-keymap*

To switch between languages you can use your system native keyboard switcher,
or use one of the Russian keymaps, included in the Vim distribution.  For
example,
>
    :set keymap=russian-jcukenwin
<
In the latter case, you can switch between languages even if you do not have
system Russian keyboard or independently from a system-wide keyboard settings.
See 'keymap'.  You can also map a key to switch between keyboards, if you
choose the latter option.  See |:map|.

For your convenience, to avoid switching between keyboards, when you need to
enter Normal mode command, you can also set 'langmap' option:
>
    :set langmap=ФИСВУАПРШОЛДЬТЩЗЙКЫЕГМЦЧНЯ;ABCDEFGHIJKLMNOPQRSTUVWXYZ,
    фисвуапршолдьтщзйкыегмцчня;abcdefghijklmnopqrstuvwxyz

This is in utf-8, you cannot read this if your 'encoding' is not utf-8.
You have to type this command in one line, it is wrapped for the sake of
readability.

===============================================================================
3. Localization							 *russian-l18n*

If you wish to use messages, help files, menus and other items translated to
Russian, you will need to install the RuVim Language Pack, available in
different codepages from

    http://www.sourceforge.net/projects/ruvim/

Make sure that your Vim is at least 6.2.506 and use ruvim 0.5 or later for
automatic installs.  Vim also needs to be compiled with |+gettext| feature for
user interface items translations to work.

After downloading an archive from RuVim project, unpack it into your
$VIMRUNTIME directory.  We recommend using UTF-8 archive.

In order to use the Russian documentation, make sure you have set the
'helplang' option to "ru".

===============================================================================
4. Known issues						       *russian-issues*

-- If you are using Russian message translations in Win32 console, then
   you may see the output produced by "vim --help", "vim --version" commands
   and Win32 console window title appearing in a wrong codepage.  This problem
   is related to a bug in GNU gettext library and may be fixed in the future
   releases of gettext.

===============================================================================
 vim:tw=78:ts=8:noet:ft=help:norl:
                                                usr/share/vim/vim90/doc/scroll.txt                                                                  0000644 0000000 0000000 00000033730 14424703754 015542  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        *scroll.txt*    For Vim version 9.0.  Last change: 2022 Oct 17


		  VIM REFERENCE MANUAL    by Bram Moolenaar


Scrolling						*scrolling*

These commands move the contents of the window.  If the cursor position is
moved off of the window, the cursor is moved onto the window (with
'scrolloff' screen lines around it).  A page is the number of lines in the
window minus two.  The mnemonics for these commands may be a bit confusing.
Remember that the commands refer to moving the window (the part of the buffer
that you see) upwards or downwards in the buffer.  When the window moves
upwards in the buffer, the text in the window moves downwards on your screen.

See section |03.7| of the user manual for an introduction.

1. Scrolling downwards		|scroll-down|
2. Scrolling upwards		|scroll-up|
3. Scrolling relative to cursor	|scroll-cursor|
4. Scrolling horizontally	|scroll-horizontal|
5. Scrolling synchronously	|scroll-binding|
6. Scrolling with a mouse wheel |scroll-mouse-wheel|

==============================================================================
1. Scrolling downwards					*scroll-down*

The following commands move the edit window (the part of the buffer that you
see) downwards (this means that more lines downwards in the text buffer can be
seen):

							*CTRL-E*
CTRL-E			Scroll window [count] lines downwards in the buffer.
			The text moves upwards on the screen.
			Mnemonic: Extra lines.

							*CTRL-D*
CTRL-D			Scroll window Downwards in the buffer.  The number of
			lines comes from the 'scroll' option (default: half a
			screen).  If [count] given, first set 'scroll' option
			to [count].  The cursor is moved the same number of
			lines down in the file (if possible; when lines wrap
			and when hitting the end of the file there may be a
			difference).  When the cursor is on the last line of
			the buffer nothing happens and a beep is produced.
			See also 'startofline' option.

<S-Down>	or				*<S-Down>* *<kPageDown>*
<PageDown>	or				*<PageDown>* *CTRL-F*
CTRL-F			Scroll window [count] pages Forwards (downwards) in
			the buffer.  See also 'startofline' option.
			When there is only one window the 'window' option
			might be used.

							*z+*
z+			Without [count]: Redraw with the line just below the
			window at the top of the window.  Put the cursor in
			that line, at the first non-blank in the line.
			With [count]: just like "z<CR>".

==============================================================================
2. Scrolling upwards					*scroll-up*

The following commands move the edit window (the part of the buffer that you
see) upwards (this means that more lines upwards in the text buffer can be
seen):

							*CTRL-Y*
CTRL-Y			Scroll window [count] lines upwards in the buffer.
			The text moves downwards on the screen.
			Note: When using the MS-Windows key bindings CTRL-Y is
			remapped to redo.

							*CTRL-U*
CTRL-U			Scroll window Upwards in the buffer.  The number of
			lines comes from the 'scroll' option (default: half a
			screen).  If [count] given, first set the 'scroll'
			option to [count].  The cursor is moved the same
			number of lines up in the file (if possible; when
			lines wrap and when hitting the end of the file there
			may be a difference).  When the cursor is on the first
			line of the buffer nothing happens and a beep is
			produced.  See also 'startofline' option.

<S-Up>		or					*<S-Up>* *<kPageUp>*
<PageUp>	or					*<PageUp>* *CTRL-B*
CTRL-B			Scroll window [count] pages Backwards (upwards) in the
			buffer.  See also 'startofline' option.
			When there is only one window the 'window' option
			might be used.

							*z^*
z^			Without [count]: Redraw with the line just above the
			window at the bottom of the window.  Put the cursor in
			that line, at the first non-blank in the line.
			With [count]: First scroll the text to put the [count]
			line at the bottom of the window, then redraw with the
			line which is now at the top of the window at the
			bottom of the window.  Put the cursor in that line, at
			the first non-blank in the line.

==============================================================================
3. Scrolling relative to cursor				*scroll-cursor*

The following commands reposition the edit window (the part of the buffer that
you see) while keeping the cursor on the same line.  Note that the 'scrolloff'
option may cause context lines to show above and below the cursor.

							*z<CR>*
z<CR>			Redraw, line [count] at top of window (default
			cursor line).  Put cursor at first non-blank in the
			line.

							*zt*
zt			Like "z<CR>", but leave the cursor in the same
			column.

							*zN<CR>*
z{height}<CR>		Redraw, make window {height} lines tall.  This is
			useful to make the number of lines small when screen
			updating is very slow.  Cannot make the height more
			than the physical screen height.

							*z.*
z.			Redraw, line [count] at center of window (default
			cursor line).  Put cursor at first non-blank in the
			line.

							*zz*
zz			Like "z.", but leave the cursor in the same column.
			Careful: If caps-lock is on, this command becomes
			"ZZ": write buffer and exit!

							*z-*
z-			Redraw, line [count] at bottom of window (default
			cursor line).  Put cursor at first non-blank in the
			line.

							*zb*
zb			Like "z-", but leave the cursor in the same column.

==============================================================================
4. Scrolling horizontally				*scroll-horizontal*

For the following four commands the cursor follows the screen.  If the
character that the cursor is on is moved off the screen, the cursor is moved
to the closest character that is on the screen.  The value of 'sidescroll' is
not used.

z<Right>    or						*zl* *z<Right>*
zl			Move the view on the text [count] characters to the
			right, thus scroll the text [count] characters to the
			left.  This only works when 'wrap' is off.

z<Left>      or						*zh* *z<Left>*
zh			Move the view on the text [count] characters to the
			left, thus scroll the text [count] characters to the
			right.  This only works when 'wrap' is off.

							*zL*
zL			Move the view on the text half a screenwidth to the
			right, thus scroll the text half a screenwidth to the
			left.  This only works when 'wrap' is off.

							*zH*
zH			Move the view on the text half a screenwidth to the
			left, thus scroll the text half a screenwidth to the
			right.  This only works when 'wrap' is off.

For the following two commands the cursor is not moved in the text, only the
text scrolls on the screen.

							*zs*
zs			Scroll the text horizontally to position the cursor
			at the start (left side) of the screen.  This only
			works when 'wrap' is off.

							*ze*
ze			Scroll the text horizontally to position the cursor
			at the end (right side) of the screen.  This only
			works when 'wrap' is off.

==============================================================================
5. Scrolling synchronously				*scroll-binding*

Occasionally, it is desirable to bind two or more windows together such that
when one window is scrolled, the other windows are also scrolled.  In Vim,
windows can be given this behavior by setting the (window-specific)
'scrollbind' option.  When a window that has 'scrollbind' set is scrolled, all
other 'scrollbind' windows are scrolled the same amount, if possible.  The
behavior of 'scrollbind' can be modified by the 'scrollopt' option.

When using the scrollbars, the binding only happens when scrolling the window
with focus (where the cursor is).  You can use this to avoid scroll-binding
for a moment without resetting options.

When a window also has the 'diff' option set, the scroll-binding uses the
differences between the two buffers to synchronize the position precisely.
Otherwise the following method is used.

							*scrollbind-relative*
Each 'scrollbind' window keeps track of its "relative offset," which can be
thought of as the difference between the current window's vertical scroll
position and the other window's vertical scroll position.  When one of the
'scrollbind' windows is asked to vertically scroll past the beginning or end
limit of its text, the window no longer scrolls, but remembers how far past
the limit it wishes to be.  The window keeps this information so that it can
maintain the same relative offset, regardless of its being asked to scroll
past its buffer's limits.

However, if a 'scrollbind' window that has a relative offset that is past its
buffer's limits is given the cursor focus, the other 'scrollbind' windows must
jump to a location where the current window's relative offset is valid.  This
behavior can be changed by clearing the "jump" flag from the 'scrollopt'
option.

						*syncbind* *:syncbind* *:sync*
:syncbind		Force all 'scrollbind' windows to have the same
			relative offset.  I.e., when any of the 'scrollbind'
			windows is scrolled to the top of its buffer, all of
			the 'scrollbind' windows will also be at the top of
			their buffers.

							*scrollbind-quickadj*
The 'scrollbind' flag is meaningful when using keyboard commands to vertically
scroll a window, and also meaningful when using the vertical scrollbar of the
window which has the cursor focus.  However, when using the vertical scrollbar
of a window which doesn't have the cursor focus, 'scrollbind' is ignored.
This allows quick adjustment of the relative offset of 'scrollbind' windows.

==============================================================================
6. Scrolling with a mouse wheel				*scroll-mouse-wheel*

When your mouse has a scroll wheel, it should work with Vim in the GUI.  How
it works depends on your system.  It might also work in an xterm
|xterm-mouse-wheel|.  By default only vertical scroll wheels are supported,
but some GUIs also support horizontal scroll wheels.

On MS-Windows, if the scroll action causes input focus -problems, see
|intellimouse-wheel-problems|.

For Win32 and the X11 GUIs (Motif and GTK) scrolling the wheel generates key
presses <ScrollWheelUp>, <ScrollWheelDown>, <ScrollWheelLeft> and
<ScrollWheelRight>.  For example, if you push the scroll wheel upwards a
<ScrollWheelUp> key press is generated causing the window to scroll upwards
(while the text is actually moving downwards).  The default action for these
keys are:
    <ScrollWheelUp>	    scroll N lines up	        *<ScrollWheelUp>*
    <S-ScrollWheelUp>	    scroll one page up		*<S-ScrollWheelUp>*
    <C-ScrollWheelUp>	    scroll one page up		*<C-ScrollWheelUp>*
    <ScrollWheelDown>	    scroll N lines down	        *<ScrollWheelDown>*
    <S-ScrollWheelDown>	    scroll one page down	*<S-ScrollWheelDown>*
    <C-ScrollWheelDown>	    scroll one page down	*<C-ScrollWheelDown>*
    <ScrollWheelLeft>	    scroll N columns left	*<ScrollWheelLeft>*
    <S-ScrollWheelLeft>	    scroll one page left	*<S-ScrollWheelLeft>*
    <C-ScrollWheelLeft>	    scroll one page left	*<C-ScrollWheelLeft>*
    <ScrollWheelRight>	    scroll N columns right	*<ScrollWheelRight>*
    <S-ScrollWheelRight>    scroll one page right	*<S-ScrollWheelRight>*
    <C-ScrollWheelRight>    scroll one page right	*<C-ScrollWheelRight>*
This should work in all modes, except when editing the command line.

The value of N depends on the system.  By default Vim scrolls three lines when
moving vertically, and six columns when moving horizontally.  On MS-Windows
the amount of lines and columns for each scroll action is taken from the
system-wide settings.

Note that horizontal scrolling only works if 'nowrap' is set.  Also, unless
the "h" flag in 'guioptions' is set, the cursor moves to the longest visible
line if the cursor line is about to be scrolled off the screen (similarly to
how the horizontal scrollbar works).

You can modify the default behavior by mapping the keys.  For example, to make
the scroll wheel move one line or half a page in Normal mode: >
   :map <ScrollWheelUp> <C-Y>
   :map <S-ScrollWheelUp> <C-U>
   :map <ScrollWheelDown> <C-E>
   :map <S-ScrollWheelDown> <C-D>
You can also use Alt and Ctrl modifiers.

This only works when Vim gets the scroll wheel events, of course.  You can
check if this works with the "xev" program.
							*mouse-scrolling-off*
If you do not want the mouse to cause scrolling (e.g. because resting your
palm on the touchpad causes scroll events), you can disable that with: >
	:map <ScrollWheelDown> <Nop>
	:map! <ScrollWheelDown> <Nop>
	:map <ScrollWheelUp> <Nop>
	:map! <ScrollWheelUp> <Nop>
	:map <ScrollWheelLeft> <Nop>
	:map! <ScrollWheelLeft> <Nop>
	:map <ScrollWheelRight> <Nop>
	:map! <ScrollWheelRight> <Nop>

When using XFree86, the /etc/XF86Config file should have the correct entry for
your mouse.  For FreeBSD, this entry works for a Logitech scrollmouse: >
    Protocol     "MouseMan"
    Device       "/dev/psm0"
    ZAxisMapping 4 5
See the XFree86 documentation for information.

						*<MouseDown>* *<MouseUp>*
The keys <MouseDown> and <MouseUp> have been deprecated.  Use <ScrollWheelUp>
instead of <MouseDown> and use <ScrollWheelDown> instead of <MouseUp>.

							*xterm-mouse-wheel*
To use the mouse wheel in a new xterm you only have to make the scroll wheel
work in your Xserver, as mentioned above.

To use the mouse wheel in an older xterm you must do this:
1. Make it work in your Xserver, as mentioned above.
2. Add translations for the xterm, so that the xterm will pass a scroll event
   to Vim as an escape sequence.
3. Add mappings in Vim, to interpret the escape sequences as <ScrollWheelDown>
   or <ScrollWheelUp> keys.

You can do the translations by adding this to your ~.Xdefaults file (or other
file where your X resources are kept): >

  XTerm*VT100.Translations:		#override \n\
		s<Btn4Down>: string("0x9b") string("[64~") \n\
		s<Btn5Down>: string("0x9b") string("[65~") \n\
		<Btn4Down>: string("0x9b") string("[62~") \n\
		<Btn5Down>: string("0x9b") string("[63~") \n\
		<Btn4Up>: \n\
		<Btn5Up>:

Add these mappings to your vimrc file: >
	:map <M-Esc>[62~ <ScrollWheelUp>
	:map! <M-Esc>[62~ <ScrollWheelUp>
	:map <M-Esc>[63~ <ScrollWheelDown>
	:map! <M-Esc>[63~ <ScrollWheelDown>
	:map <M-Esc>[64~ <S-ScrollWheelUp>
	:map! <M-Esc>[64~ <S-ScrollWheelUp>
	:map <M-Esc>[65~ <S-ScrollWheelDown>
	:map! <M-Esc>[65~ <S-ScrollWheelDown>
<
 vim:tw=78:ts=8:noet:ft=help:norl:
                                        usr/share/vim/vim90/doc/sign.txt                                                                    0000644 0000000 0000000 00000064354 14424703754 015212  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        *sign.txt*      For Vim version 9.0.  Last change: 2023 Feb 21


		  VIM REFERENCE MANUAL    by Gordon Prieur
					  and Bram Moolenaar


Sign Support Features				*sign-support*

1. Introduction				|sign-intro|
2. Commands				|sign-commands|
3. Functions				|sign-functions-details|

{only available when compiled with the |+signs| feature}

==============================================================================
1. Introduction					*sign-intro* *signs*

When a debugger or other IDE tool is driving an editor it needs to be able
to give specific highlights which quickly tell the user useful information
about the file.  One example of this would be a debugger which had an icon
in the left-hand column denoting a breakpoint.  Another example might be an
arrow representing the Program Counter (PC).  The sign features allow both
placement of a sign, or icon, in the left-hand side of the window and
definition of a highlight which will be applied to that line.  Displaying the
sign as an image is most likely only feasible in gvim (although Sun
Microsystem's dtterm does support this it's the only terminal emulator I know
of which does).  A text sign and the highlight should be feasible in any color
terminal emulator.

Signs and highlights are not useful just for debuggers.  Sun's Visual
WorkShop uses signs and highlights to mark build errors and SourceBrowser
hits.  Additionally, the debugger supports 8 to 10 different signs and
highlight colors, see |NetBeans|.

