 *
 * Author: Alexander Larsson <alexl@redhat.com>
 *         David Zeuthen <davidz@redhat.com>
 */

#ifndef __G_MOUNT_H__
#define __G_MOUNT_H__

#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
#error "Only <gio/gio.h> can be included directly."
#endif

#include <gio/giotypes.h>

G_BEGIN_DECLS

#define G_TYPE_MOUNT            (g_mount_get_type ())
#define G_MOUNT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_MOUNT, GMount))
#define G_IS_MOUNT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_MOUNT))
#define G_MOUNT_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_MOUNT, GMountIface))

typedef struct _GMountIface    GMountIface;

/**
 * GMountIface:
 * @g_iface: The parent interface.
 * @changed: Changed signal that is emitted when the mount's state has changed.
 * @unmounted: The unmounted signal that is emitted when the #GMount have been unmounted. If the recipient is holding references to the object they should release them so the object can be finalized.
 * @pre_unmount: The ::pre-unmount signal that is emitted when the #GMount will soon be emitted. If the recipient is somehow holding the mount open by keeping an open file on it it should close the file.
 * @get_root: Gets a #GFile to the root directory of the #GMount.
 * @get_name: Gets a string containing the name of the #GMount.
 * @get_icon: Gets a #GIcon for the #GMount.
 * @get_uuid: Gets the UUID for the #GMount. The reference is typically based on the file system UUID for the mount in question and should be considered an opaque string. Returns %NULL if there is no UUID available.
 * @get_volume: Gets a #GVolume the mount is located on. Returns %NULL if the #GMount is not associated with a #GVolume.
 * @get_drive: Gets a #GDrive the volume of the mount is located on. Returns %NULL if the #GMount is not associated with a #GDrive or a #GVolume. This is convenience method for getting the #GVolume and using that to get the #GDrive.
 * @can_unmount: Checks if a #GMount can be unmounted.
 * @can_eject: Checks if a #GMount can be ejected.
 * @unmount: Starts unmounting a #GMount.
 * @unmount_finish: Finishes an unmounting operation.
 * @eject: Starts ejecting a #GMount.
 * @eject_finish: Finishes an eject operation.
 * @remount: Starts remounting a #GMount.
 * @remount_finish: Finishes a remounting operation.
 * @guess_content_type: Starts guessing the type of the content of a #GMount.
 *     See g_mount_guess_content_type() for more information on content
 *     type guessing. This operation was added in 2.18.
 * @guess_content_type_finish: Finishes a content type guessing operation. Added in 2.18.
 * @guess_content_type_sync: Synchronous variant of @guess_content_type. Added in 2.18
 * @unmount_with_operation: Starts unmounting a #GMount using a #GMountOperation. Since 2.22.
 * @unmount_with_operation_finish: Finishes an unmounting operation using a #GMountOperation. Since 2.22.
 * @eject_with_operation: Starts ejecting a #GMount using a #GMountOperation. Since 2.22.
 * @eject_with_operation_finish: Finishes an eject operation using a #GMountOperation. Since 2.22.
 * @get_default_location: Gets a #GFile indication a start location that can be use as the entry point for this mount. Since 2.24.
 * @get_sort_key: Gets a key used for sorting #GMount instance or %NULL if no such key exists. Since 2.32.
 * @get_symbolic_icon: Gets a symbolic #GIcon for the #GMount. Since 2.34.
 *
 * Interface for implementing operations for mounts.
 **/
struct _GMountIface
{
  GTypeInterface g_iface;

  /* signals */

  void        (* changed)                   (GMount              *mount);
  void        (* unmounted)                 (GMount              *mount);

  /* Virtual Table */

  GFile     * (* get_root)                  (GMount              *mount);
  char      * (* get_name)                  (GMount              *mount);
  GIcon     * (* get_icon)                  (GMount              *mount);
  char      * (* get_uuid)                  (GMount              *mount);
  GVolume   * (* get_volume)                (GMount              *mount);
  GDrive    * (* get_drive)                 (GMount              *mount);
  gboolean    (* can_unmount)               (GMount              *mount);
  gboolean    (* can_eject)                 (GMount              *mount);

  void        (* unmount)                   (GMount              *mount,
                                             GMountUnmountFlags   flags,
                                             GCancellable        *cancellable,
                                             GAsyncReadyCallback  callback,
                                             gpointer             user_data);
  gboolean    (* unmount_finish)            (GMount              *mount,
                                             GAsyncResult        *result,
                                             GError             **error);

  void        (* eject)                     (GMount              *mount,
                                             GMountUnmountFlags   flags,
                                             GCancellable        *cancellable,
                                             GAsyncReadyCallback  callback,
                                             gpointer             user_data);
  gboolean    (* eject_finish)              (GMount              *mount,
                                             GAsyncResult        *result,
                                             GError             **error);

  void        (* remount)                   (GMount              *mount,
                                             GMountMountFlags     flags,
                                             GMountOperation     *mount_operation,
                                             GCancellable        *cancellable,
                                             GAsyncReadyCallback  callback,
                                             gpointer             user_data);
  gboolean    (* remount_finish)            (GMount              *mount,
                                             GAsyncResult        *result,
                                             GError             **error);

  void        (* guess_content_type)        (GMount              *mount,
                                             gboolean             force_rescan,
                                             GCancellable        *cancellable,
                                             GAsyncReadyCallback  callback,
                                             gpointer             user_data);
  gchar    ** (* guess_content_type_finish) (GMount              *mount,
                                             GAsyncResult        *result,
                                             GError             **error);
  gchar    ** (* guess_content_type_sync)   (GMount              *mount,
                                             gboolean             force_rescan,
                                             GCancellable        *cancellable,
                                             GError             **error);

  /* Signal, not VFunc */
  void        (* pre_unmount)               (GMount              *mount);

  void        (* unmount_with_operation)    (GMount              *mount,
                                             GMountUnmountFlags   flags,
                                             GMountOperation     *mount_operation,
                                             GCancellable        *cancellable,
                                             GAsyncReadyCallback  callback,
                                             gpointer             user_data);
  gboolean    (* unmount_with_operation_finish) (GMount          *mount,
                                             GAsyncResult        *result,
                                             GError             **error);

  void        (* eject_with_operation)      (GMount              *mount,
                                             GMountUnmountFlags   flags,
                                             GMountOperation     *mount_operation,
                                             GCancellable        *cancellable,
                                             GAsyncReadyCallback  callback,
                                             gpointer             user_data);
  gboolean    (* eject_with_operation_finish) (GMount            *mount,
                                             GAsyncResult        *result,
                                             GError             **error);
  GFile     * (* get_default_location)      (GMount              *mount);

  const gchar * (* get_sort_key)            (GMount              *mount);
  GIcon       * (* get_symbolic_icon)       (GMount              *mount);
};

GLIB_AVAILABLE_IN_ALL
GType       g_mount_get_type                  (void) G_GNUC_CONST;

GLIB_AVAILABLE_IN_ALL
GFile     * g_mount_get_root                  (GMount              *mount);
GLIB_AVAILABLE_IN_ALL
GFile     * g_mount_get_default_location      (GMount              *mount);
GLIB_AVAILABLE_IN_ALL
char      * g_mount_get_name                  (GMount              *mount);
GLIB_AVAILABLE_IN_ALL
GIcon     * g_mount_get_icon                  (GMount              *mount);
GLIB_AVAILABLE_IN_ALL
GIcon     * g_mount_get_symbolic_icon         (GMount              *mount);
GLIB_AVAILABLE_IN_ALL
char      * g_mount_get_uuid                  (GMount              *mount);
GLIB_AVAILABLE_IN_ALL
GVolume   * g_mount_get_volume                (GMount              *mount);
GLIB_AVAILABLE_IN_ALL
GDrive    * g_mount_get_drive                 (GMount              *mount);
GLIB_AVAILABLE_IN_ALL
gboolean    g_mount_can_unmount               (GMount              *mount);
GLIB_AVAILABLE_IN_ALL
gboolean    g_mount_can_eject                 (GMount              *mount);

GLIB_DEPRECATED_FOR(g_mount_unmount_with_operation)
void        g_mount_unmount                   (GMount              *mount,
                                               GMountUnmountFlags   flags,
                                               GCancellable        *cancellable,
                                               GAsyncReadyCallback  callback,
                                               gpointer             user_data);

GLIB_DEPRECATED_FOR(g_mount_unmount_with_operation_finish)
gboolean    g_mount_unmount_finish            (GMount              *mount,
                                               GAsyncResult        *result,
                                               GError             **error);

GLIB_DEPRECATED_FOR(g_mount_eject_with_operation)
void        g_mount_eject                     (GMount              *mount,
                                               GMountUnmountFlags   flags,
                                               GCancellable        *cancellable,
                                               GAsyncReadyCallback  callback,
                                               gpointer             user_data);

GLIB_DEPRECATED_FOR(g_mount_eject_with_operation_finish)
gboolean    g_mount_eject_finish              (GMount              *mount,
                                               GAsyncResult        *result,
                                               GError             **error);

GLIB_AVAILABLE_IN_ALL
void        g_mount_remount                   (GMount              *mount,
                                               GMountMountFlags     flags,
                                               GMountOperation     *mount_operation,
                                               GCancellable        *cancellable,
                                               GAsyncReadyCallback  callback,
                                               gpointer             user_data);
GLIB_AVAILABLE_IN_ALL
gboolean    g_mount_remount_finish            (GMount              *mount,
                                               GAsyncResult        *result,
                                               GError             **error);

GLIB_AVAILABLE_IN_ALL
void        g_mount_guess_content_type        (GMount              *mount,
                                               gboolean             force_rescan,
                                               GCancellable        *cancellable,
                                               GAsyncReadyCallback  callback,
                                               gpointer             user_data);
GLIB_AVAILABLE_IN_ALL
gchar    ** g_mount_guess_content_type_finish (GMount              *mount,
                                               GAsyncResult        *result,
                                               GError             **error);
GLIB_AVAILABLE_IN_ALL
gchar    ** g_mount_guess_content_type_sync   (GMount              *mount,
                                               gboolean             force_rescan,
                                               GCancellable        *cancellable,
                                               GError             **error);

GLIB_AVAILABLE_IN_ALL
gboolean    g_mount_is_shadowed               (GMount              *mount);
GLIB_AVAILABLE_IN_ALL
void        g_mount_shadow                    (GMount              *mount);
GLIB_AVAILABLE_IN_ALL
void        g_mount_unshadow                  (GMount              *mount);

GLIB_AVAILABLE_IN_ALL
void        g_mount_unmount_with_operation    (GMount              *mount,
                                               GMountUnmountFlags   flags,
                                               GMountOperation     *mount_operation,
                                               GCancellable        *cancellable,
                                               GAsyncReadyCallback  callback,
                                               gpointer             user_data);
GLIB_AVAILABLE_IN_ALL
gboolean    g_mount_unmount_with_operation_finish (GMount          *mount,
                                               GAsyncResult        *result,
                                               GError             **error);

GLIB_AVAILABLE_IN_ALL
void        g_mount_eject_with_operation      (GMount              *mount,
                                               GMountUnmountFlags   flags,
                                               GMountOperation     *mount_operation,
                                               GCancellable        *cancellable,
                                               GAsyncReadyCallback  callback,
                                               gpointer             user_data);
GLIB_AVAILABLE_IN_ALL
gboolean    g_mount_eject_with_operation_finish (GMount            *mount,
                                               GAsyncResult        *result,
                                               GError             **error);

GLIB_AVAILABLE_IN_ALL
const gchar *g_mount_get_sort_key             (GMount              *mount);

G_END_DECLS

#endif /* __G_MOUNT_H__ */
                                usr/include/glib-2.0/gio/gmountoperation.h                                                          0000644 0000000 0000000 00000015236 14375670023 017111  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* GIO - GLib Input, Output and Streaming Library
 *
 * Copyright (C) 2006-2007 Red Hat, Inc.
 *
 * SPDX-License-Identifier: LGPL-2.1-or-later
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General
 * Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Alexander Larsson <alexl@redhat.com>
 */

#ifndef __G_MOUNT_OPERATION_H__
#define __G_MOUNT_OPERATION_H__

#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
#error "Only <gio/gio.h> can be included directly."
#endif

#include <gio/giotypes.h>

G_BEGIN_DECLS

#define G_TYPE_MOUNT_OPERATION         (g_mount_operation_get_type ())
#define G_MOUNT_OPERATION(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_MOUNT_OPERATION, GMountOperation))
#define G_MOUNT_OPERATION_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_MOUNT_OPERATION, GMountOperationClass))
#define G_IS_MOUNT_OPERATION(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_MOUNT_OPERATION))
#define G_IS_MOUNT_OPERATION_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_MOUNT_OPERATION))
#define G_MOUNT_OPERATION_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_MOUNT_OPERATION, GMountOperationClass))

/**
 * GMountOperation:
 *
 * Class for providing authentication methods for mounting operations,
 * such as mounting a file locally, or authenticating with a server.
 **/
typedef struct _GMountOperationClass   GMountOperationClass;
typedef struct _GMountOperationPrivate GMountOperationPrivate;

struct _GMountOperation
{
  GObject parent_instance;

  GMountOperationPrivate *priv;
};

struct _GMountOperationClass
{
  GObjectClass parent_class;

  /* signals: */

  void (* ask_password) (GMountOperation       *op,
			 const char            *message,
			 const char            *default_user,
			 const char            *default_domain,
			 GAskPasswordFlags      flags);

  /**
   * GMountOperationClass::ask_question:
   * @op: a #GMountOperation
   * @message: string containing a message to display to the user
   * @choices: (array zero-terminated=1) (element-type utf8): an array of
   *    strings for each possible choice
   *
   * Virtual implementation of #GMountOperation::ask-question.
   */
  void (* ask_question) (GMountOperation       *op,
			 const char            *message,
			 const char            *choices[]);

  void (* reply)        (GMountOperation       *op,
			 GMountOperationResult  result);

  void (* aborted)      (GMountOperation       *op);

  /**
   * GMountOperationClass::show_processes:
   * @op: a #GMountOperation
   * @message: string containing a message to display to the user
   * @processes: (element-type GPid): an array of #GPid for processes blocking
   *    the operation
   * @choices: (array zero-terminated=1) (element-type utf8): an array of
   *    strings for each possible choice
   *
   * Virtual implementation of #GMountOperation::show-processes.
   *
   * Since: 2.22
   */
  void (* show_processes) (GMountOperation      *op,
                           const gchar          *message,
                           GArray               *processes,
                           const gchar          *choices[]);

  void (* show_unmount_progress) (GMountOperation *op,
                                  const gchar     *message,
                                  gint64           time_left,
                                  gint64           bytes_left);

  /*< private >*/
  /* Padding for future expansion */
  void (*_g_reserved1) (void);
  void (*_g_reserved2) (void);
  void (*_g_reserved3) (void);
  void (*_g_reserved4) (void);
  void (*_g_reserved5) (void);
  void (*_g_reserved6) (void);
  void (*_g_reserved7) (void);
  void (*_g_reserved8) (void);
  void (*_g_reserved9) (void);
};

GLIB_AVAILABLE_IN_ALL
GType             g_mount_operation_get_type      (void) G_GNUC_CONST;
GLIB_AVAILABLE_IN_ALL
GMountOperation * g_mount_operation_new           (void);

GLIB_AVAILABLE_IN_ALL
const char *  g_mount_operation_get_username      (GMountOperation *op);
GLIB_AVAILABLE_IN_ALL
void          g_mount_operation_set_username      (GMountOperation *op,
						   const char      *username);
GLIB_AVAILABLE_IN_ALL
const char *  g_mount_operation_get_password      (GMountOperation *op);
GLIB_AVAILABLE_IN_ALL
void          g_mount_operation_set_password      (GMountOperation *op,
						   const char      *password);
GLIB_AVAILABLE_IN_ALL
gboolean      g_mount_operation_get_anonymous     (GMountOperation *op);
GLIB_AVAILABLE_IN_ALL
void          g_mount_operation_set_anonymous     (GMountOperation *op,
						   gboolean         anonymous);
GLIB_AVAILABLE_IN_ALL
const char *  g_mount_operation_get_domain        (GMountOperation *op);
GLIB_AVAILABLE_IN_ALL
void          g_mount_operation_set_domain        (GMountOperation *op,
						   const char      *domain);
GLIB_AVAILABLE_IN_ALL
GPasswordSave g_mount_operation_get_password_save (GMountOperation *op);
GLIB_AVAILABLE_IN_ALL
void          g_mount_operation_set_password_save (GMountOperation *op,
						   GPasswordSave    save);
GLIB_AVAILABLE_IN_ALL
int           g_mount_operation_get_choice        (GMountOperation *op);
GLIB_AVAILABLE_IN_ALL
void          g_mount_operation_set_choice        (GMountOperation *op,
						   int              choice);
GLIB_AVAILABLE_IN_ALL
void          g_mount_operation_reply             (GMountOperation *op,
						   GMountOperationResult result);
GLIB_AVAILABLE_IN_2_58
gboolean      g_mount_operation_get_is_tcrypt_hidden_volume (GMountOperation *op);
GLIB_AVAILABLE_IN_2_58
void          g_mount_operation_set_is_tcrypt_hidden_volume (GMountOperation *op,
                                                             gboolean hidden_volume);
GLIB_AVAILABLE_IN_2_58
gboolean      g_mount_operation_get_is_tcrypt_system_volume (GMountOperation *op);
GLIB_AVAILABLE_IN_2_58
void          g_mount_operation_set_is_tcrypt_system_volume (GMountOperation *op,
                                                             gboolean system_volume);
GLIB_AVAILABLE_IN_2_58
guint  g_mount_operation_get_pim           (GMountOperation *op);
GLIB_AVAILABLE_IN_2_58
void          g_mount_operation_set_pim           (GMountOperation *op,
                                                   guint pim);

G_END_DECLS

#endif /* __G_MOUNT_OPERATION_H__ */
                                                                                                                                                                                                                                                                                                                                                                  usr/include/glib-2.0/gio/gnativesocketaddress.h                                                     0000644 0000000 0000000 00000005031 14375670023 020063  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* GIO - GLib Input, Output and Streaming Library
 *
 * Copyright (C) 2008 Christian Kellner, Samuel Cormier-Iijima
 *
 * SPDX-License-Identifier: LGPL-2.1-or-later
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General
 * Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
 *
 * Authors: Christian Kellner <gicmo@gnome.org>
 *          Samuel Cormier-Iijima <sciyoshi@gmail.com>
 */

#ifndef __G_NATIVE_SOCKET_ADDRESS_H__
#define __G_NATIVE_SOCKET_ADDRESS_H__

#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
#error "Only <gio/gio.h> can be included directly."
#endif

#include <gio/gsocketaddress.h>

G_BEGIN_DECLS

#define G_TYPE_NATIVE_SOCKET_ADDRESS         (g_native_socket_address_get_type ())
#define G_NATIVE_SOCKET_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_NATIVE_SOCKET_ADDRESS, GNativeSocketAddress))
#define G_NATIVE_SOCKET_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_NATIVE_SOCKET_ADDRESS, GNativeSocketAddressClass))
#define G_IS_NATIVE_SOCKET_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_NATIVE_SOCKET_ADDRESS))
#define G_IS_NATIVE_SOCKET_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_NATIVE_SOCKET_ADDRESS))
#define G_NATIVE_SOCKET_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_NATIVE_SOCKET_ADDRESS, GNativeSocketAddressClass))

typedef struct _GNativeSocketAddressClass   GNativeSocketAddressClass;
typedef struct _GNativeSocketAddressPrivate GNativeSocketAddressPrivate;

struct _GNativeSocketAddress
{
  GSocketAddress parent_instance;

  /*< private >*/
  GNativeSocketAddressPrivate *priv;
};

struct _GNativeSocketAddressClass
{
  GSocketAddressClass parent_class;
};

GLIB_AVAILABLE_IN_2_46
GType           g_native_socket_address_get_type        (void) G_GNUC_CONST;

GLIB_AVAILABLE_IN_2_46
GSocketAddress *g_native_socket_address_new            (gpointer        native,
                                                        gsize           len);

G_END_DECLS

#endif /* __G_NATIVE_SOCKET_ADDRESS_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/include/glib-2.0/gio/gnativevolumemonitor.h                                                     0000644 0000000 0000000 00000004417 14375670023 020153  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* GIO - GLib Input, Output and Streaming Library
 *
 * Copyright (C) 2006-2007 Red Hat, Inc.
 *
 * SPDX-License-Identifier: LGPL-2.1-or-later
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General
 * Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Alexander Larsson <alexl@redhat.com>
 */

#ifndef __G_NATIVE_VOLUME_MONITOR_H__
#define __G_NATIVE_VOLUME_MONITOR_H__

#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
#error "Only <gio/gio.h> can be included directly."
#endif

#include <gio/gvolumemonitor.h>

G_BEGIN_DECLS

#define G_TYPE_NATIVE_VOLUME_MONITOR        (g_native_volume_monitor_get_type ())
#define G_NATIVE_VOLUME_MONITOR(o)          (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_NATIVE_VOLUME_MONITOR, GNativeVolumeMonitor))
#define G_NATIVE_VOLUME_MONITOR_CLASS(k)    (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_NATIVE_VOLUME_MONITOR, GNativeVolumeMonitorClass))
#define G_IS_NATIVE_VOLUME_MONITOR(o)       (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_NATIVE_VOLUME_MONITOR))
#define G_IS_NATIVE_VOLUME_MONITOR_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_NATIVE_VOLUME_MONITOR))

#define G_NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME "gio-native-volume-monitor"

typedef struct _GNativeVolumeMonitor      GNativeVolumeMonitor;
typedef struct _GNativeVolumeMonitorClass GNativeVolumeMonitorClass;

struct _GNativeVolumeMonitor
{
  GVolumeMonitor parent_instance;
};

struct _GNativeVolumeMonitorClass
{
  GVolumeMonitorClass parent_class;

  GMount * (* get_mount_for_mount_path) (const char   *mount_path,
                                         GCancellable *cancellable);
};

GLIB_AVAILABLE_IN_ALL
GType g_native_volume_monitor_get_type (void) G_GNUC_CONST;

G_END_DECLS

#endif /* __G_NATIVE_VOLUME_MONITOR_H__ */
                                                                                                                                                                                                                                                 usr/include/glib-2.0/gio/gnetworkaddress.h                                                          0000644 0000000 0000000 00000005675 14375670023 017073  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* GIO - GLib Input, Output and Streaming Library
 *
 * Copyright (C) 2008 Red Hat, Inc.
 *
 * SPDX-License-Identifier: LGPL-2.1-or-later
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General
 * Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
 */

#ifndef __G_NETWORK_ADDRESS_H__
#define __G_NETWORK_ADDRESS_H__

#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
#error "Only <gio/gio.h> can be included directly."
#endif

#include <gio/giotypes.h>

G_BEGIN_DECLS

#define G_TYPE_NETWORK_ADDRESS         (g_network_address_get_type ())
#define G_NETWORK_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_NETWORK_ADDRESS, GNetworkAddress))
#define G_NETWORK_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_NETWORK_ADDRESS, GNetworkAddressClass))
#define G_IS_NETWORK_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_NETWORK_ADDRESS))
#define G_IS_NETWORK_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_NETWORK_ADDRESS))
#define G_NETWORK_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_NETWORK_ADDRESS, GNetworkAddressClass))

typedef struct _GNetworkAddressClass   GNetworkAddressClass;
typedef struct _GNetworkAddressPrivate GNetworkAddressPrivate;

struct _GNetworkAddress
{
  GObject parent_instance;

  /*< private >*/
  GNetworkAddressPrivate *priv;
};

struct _GNetworkAddressClass
{
  GObjectClass parent_class;

};

GLIB_AVAILABLE_IN_ALL
GType               g_network_address_get_type     (void) G_GNUC_CONST;

GLIB_AVAILABLE_IN_ALL
GSocketConnectable *g_network_address_new          (const gchar      *hostname,
						    guint16           port);
GLIB_AVAILABLE_IN_2_44
GSocketConnectable *g_network_address_new_loopback (guint16           port);
GLIB_AVAILABLE_IN_ALL
GSocketConnectable *g_network_address_parse        (const gchar      *host_and_port,
						    guint16           default_port,
						    GError          **error);
GLIB_AVAILABLE_IN_ALL
GSocketConnectable *g_network_address_parse_uri    (const gchar      *uri,
    						    guint16           default_port,
						    GError          **error);
GLIB_AVAILABLE_IN_ALL
const gchar        *g_network_address_get_hostname (GNetworkAddress  *addr);
GLIB_AVAILABLE_IN_ALL
guint16             g_network_address_get_port     (GNetworkAddress  *addr);
GLIB_AVAILABLE_IN_ALL
const gchar        *g_network_address_get_scheme   (GNetworkAddress  *addr);


G_END_DECLS

#endif /* __G_NETWORK_ADDRESS_H__ */
                                                                   usr/include/glib-2.0/gio/gnetworking.h                                                              0000644 0000000 0000000 00000003726 14707647037 016226  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* GIO - GLib Input, Output and Streaming Library
 *
 * Copyright (C) 2008-2011 Red Hat, Inc.
 *
 * SPDX-License-Identifier: LGPL-2.1-or-later
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, see <http://www.gnu.org/licenses/>.
 */

#ifndef __G_NETWORKING_H__
#define __G_NETWORKING_H__

#include <glib.h>

#ifdef G_OS_WIN32
#include <winsock2.h>
#include <ws2tcpip.h>
#include <windns.h>
#include <mswsock.h>
#include <wspiapi.h>
#include <iphlpapi.h>
#undef interface

#else /* !G_OS_WIN32 */

#include <sys/types.h>

#include <netdb.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <resolv.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <net/if.h>

#include <arpa/inet.h>
#include <arpa/nameser.h>


#ifndef T_SRV
#define T_SRV 33
#endif

#ifndef _PATH_RESCONF
#define _PATH_RESCONF "/etc/resolv.conf"
#endif

#ifndef CMSG_LEN
/* CMSG_LEN and CMSG_SPACE are defined by RFC 2292, but missing on
 * some older platforms.
 */
#define CMSG_LEN(len) ((size_t)CMSG_DATA((struct cmsghdr *)NULL) + (len))

/* CMSG_SPACE must add at least as much padding as CMSG_NXTHDR()
 * adds. We overestimate here.
 */
#define GLIB_ALIGN_TO_SIZEOF(len, obj) (((len) + sizeof (obj) - 1) & ~(sizeof (obj) - 1))
#define CMSG_SPACE(len) GLIB_ALIGN_TO_SIZEOF (CMSG_LEN (len), struct cmsghdr)
#endif
#endif

G_BEGIN_DECLS

GLIB_AVAILABLE_IN_2_36
void g_networking_init (void);

G_END_DECLS

#endif /* __G_NETWORKING_H__ */
                                          usr/include/glib-2.0/gio/gnetworkmonitor.h                                                          0000644 0000000 0000000 00000010300 14375670023 017112  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* GIO - GLib Input, Output and Streaming Library
 *
 * Copyright 2011 Red Hat, Inc.
 *
 * SPDX-License-Identifier: LGPL-2.1-or-later
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General
 * Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
 */

#ifndef __G_NETWORK_MONITOR_H__
#define __G_NETWORK_MONITOR_H__

#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
#error "Only <gio/gio.h> can be included directly."
#endif

#include <gio/giotypes.h>

G_BEGIN_DECLS

/**
 * G_NETWORK_MONITOR_EXTENSION_POINT_NAME:
 *
 * Extension point for network status monitoring functionality.
 * See [Extending GIO][extending-gio].
 *
 * Since: 2.30
 */
#define G_NETWORK_MONITOR_EXTENSION_POINT_NAME "gio-network-monitor"

#define G_TYPE_NETWORK_MONITOR             (g_network_monitor_get_type ())
#define G_NETWORK_MONITOR(o)               (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_NETWORK_MONITOR, GNetworkMonitor))
#define G_IS_NETWORK_MONITOR(o)            (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_NETWORK_MONITOR))
#define G_NETWORK_MONITOR_GET_INTERFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), G_TYPE_NETWORK_MONITOR, GNetworkMonitorInterface))

typedef struct _GNetworkMonitorInterface GNetworkMonitorInterface;

struct _GNetworkMonitorInterface {
  GTypeInterface g_iface;

  void     (*network_changed)  (GNetworkMonitor      *monitor,
				gboolean              network_available);

  gboolean (*can_reach)        (GNetworkMonitor      *monitor,
				GSocketConnectable   *connectable,
				GCancellable         *cancellable,
				GError              **error);
  void     (*can_reach_async)  (GNetworkMonitor      *monitor,
				GSocketConnectable   *connectable,
				GCancellable         *cancellable,
				GAsyncReadyCallback   callback,
				gpointer              user_data);
  gboolean (*can_reach_finish) (GNetworkMonitor      *monitor,
				GAsyncResult         *result,
				GError              **error);
};

GLIB_AVAILABLE_IN_2_32
GType                 g_network_monitor_get_type              (void) G_GNUC_CONST;
GLIB_AVAILABLE_IN_2_32
GNetworkMonitor      *g_network_monitor_get_default           (void);

GLIB_AVAILABLE_IN_2_32
gboolean              g_network_monitor_get_network_available (GNetworkMonitor     *monitor);

GLIB_AVAILABLE_IN_2_46
gboolean              g_network_monitor_get_network_metered   (GNetworkMonitor     *monitor);

GLIB_AVAILABLE_IN_2_44
GNetworkConnectivity  g_network_monitor_get_connectivity      (GNetworkMonitor     *monitor);

GLIB_AVAILABLE_IN_2_32
gboolean              g_network_monitor_can_reach             (GNetworkMonitor     *monitor,
                                                               GSocketConnectable  *connectable,
                                                               GCancellable        *cancellable,
                                                               GError             **error);
GLIB_AVAILABLE_IN_2_32
void                  g_network_monitor_can_reach_async       (GNetworkMonitor     *monitor,
                                                               GSocketConnectable  *connectable,
                                                               GCancellable        *cancellable,
                                                               GAsyncReadyCallback  callback,
                                                               gpointer             user_data);
GLIB_AVAILABLE_IN_2_32
gboolean              g_network_monitor_can_reach_finish      (GNetworkMonitor     *monitor,
                                                               GAsyncResult        *result,
                                                               GError             **error);

G_END_DECLS

#endif /* __G_NETWORK_MONITOR_H__ */
                                                                                                                                                                                                                                                                                                                                usr/include/glib-2.0/gio/gnetworkservice.h                                                          0000644 0000000 0000000 00000005364 14375670023 017101  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* GIO - GLib Input, Output and Streaming Library
 *
 * Copyright (C) 2008 Red Hat, Inc.
 *
 * SPDX-License-Identifier: LGPL-2.1-or-later
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General
 * Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
 */

#ifndef __G_NETWORK_SERVICE_H__
#define __G_NETWORK_SERVICE_H__

#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
#error "Only <gio/gio.h> can be included directly."
#endif

#include <gio/giotypes.h>

G_BEGIN_DECLS

#define G_TYPE_NETWORK_SERVICE         (g_network_service_get_type ())
#define G_NETWORK_SERVICE(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_NETWORK_SERVICE, GNetworkService))
#define G_NETWORK_SERVICE_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_NETWORK_SERVICE, GNetworkServiceClass))
#define G_IS_NETWORK_SERVICE(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_NETWORK_SERVICE))
#define G_IS_NETWORK_SERVICE_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_NETWORK_SERVICE))
#define G_NETWORK_SERVICE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_NETWORK_SERVICE, GNetworkServiceClass))

typedef struct _GNetworkServiceClass   GNetworkServiceClass;
typedef struct _GNetworkServicePrivate GNetworkServicePrivate;

struct _GNetworkService
{
  GObject parent_instance;

  /*< private >*/
  GNetworkServicePrivate *priv;
};

struct _GNetworkServiceClass
{
  GObjectClass parent_class;

};

GLIB_AVAILABLE_IN_ALL
GType                g_network_service_get_type      (void) G_GNUC_CONST;

GLIB_AVAILABLE_IN_ALL
GSocketConnectable  *g_network_service_new           (const gchar     *service,
						      const gchar     *protocol,
						      const gchar     *domain);

GLIB_AVAILABLE_IN_ALL
const gchar         *g_network_service_get_service   (GNetworkService *srv);
GLIB_AVAILABLE_IN_ALL
const gchar         *g_network_service_get_protocol  (GNetworkService *srv);
GLIB_AVAILABLE_IN_ALL
const gchar         *g_network_service_get_domain    (GNetworkService *srv);
GLIB_AVAILABLE_IN_ALL
const gchar         *g_network_service_get_scheme    (GNetworkService *srv);
GLIB_AVAILABLE_IN_ALL
void                 g_network_service_set_scheme    (GNetworkService *srv, const gchar *scheme);

G_END_DECLS

#endif /* __G_NETWORK_SERVICE_H__ */
                                                                                                                                                                                                                                                                            usr/include/glib-2.0/gio/gnotification.h                                                            0000644 0000000 0000000 00000012064 14375670023 016510  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright © 2013 Lars Uebernickel
 *
 * SPDX-License-Identifier: LGPL-2.1-or-later
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General
 * Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
 *
 * Authors: Lars Uebernickel <lars@uebernic.de>
 */

#ifndef __G_NOTIFICATION_H__
#define __G_NOTIFICATION_H__

#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
#error "Only <gio/gio.h> can be included directly."
#endif

#include <gio/giotypes.h>
#include <gio/gioenums.h>

G_BEGIN_DECLS

#define G_TYPE_NOTIFICATION         (g_notification_get_type ())
#define G_NOTIFICATION(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_NOTIFICATION, GNotification))
#define G_IS_NOTIFICATION(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_NOTIFICATION))

GLIB_AVAILABLE_IN_2_40
GType                   g_notification_get_type                         (void) G_GNUC_CONST;

GLIB_AVAILABLE_IN_2_40
GNotification *         g_notification_new                              (const gchar *title);

GLIB_AVAILABLE_IN_2_40
void                    g_notification_set_title                        (GNotification *notification,
                                                                         const gchar   *title);

GLIB_AVAILABLE_IN_2_40
void                    g_notification_set_body                         (GNotification *notification,
                                                                         const gchar   *body);

GLIB_AVAILABLE_IN_2_40
void                    g_notification_set_icon                         (GNotification *notification,
                                                                         GIcon         *icon);

GLIB_DEPRECATED_IN_2_42_FOR(g_notification_set_priority)
void                    g_notification_set_urgent                       (GNotification *notification,
                                                                         gboolean       urgent);

GLIB_AVAILABLE_IN_2_42
void                    g_notification_set_priority                     (GNotification         *notification,
                                                                         GNotificationPriority  priority);

GLIB_AVAILABLE_IN_2_70
void                    g_notification_set_category                     (GNotification *notification,
                                                                         const gchar   *category);

GLIB_AVAILABLE_IN_2_40
void                    g_notification_add_button                       (GNotification *notification,
                                                                         const gchar   *label,
                                                                         const gchar   *detailed_action);

GLIB_AVAILABLE_IN_2_40
void                    g_notification_add_button_with_target           (GNotification *notification,
                                                                         const gchar   *label,
                                                                         const gchar   *action,
                                                                         const gchar   *target_format,
                                                                         ...);

GLIB_AVAILABLE_IN_2_40
void                    g_notification_add_button_with_target_value     (GNotification *notification,
                                                                         const gchar   *label,
                                                                         const gchar   *action,
                                                                         GVariant      *target);

GLIB_AVAILABLE_IN_2_40
void                    g_notification_set_default_action               (GNotification *notification,
                                                                         const gchar   *detailed_action);

GLIB_AVAILABLE_IN_2_40
void                    g_notification_set_default_action_and_target    (GNotification *notification,
