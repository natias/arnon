As of the time this document was last revised, the following 
Perl functions were implemented in the VMS port of Perl 
(functions marked with * are discussed in more detail below):

    file tests*, abs, alarm, atan, backticks*, binmode*, bless,
    caller, chdir, chmod, chown, chomp, chop, chr,
    close, closedir, cos, crypt*, defined, delete, die, do, dump*, 
    each, endgrent, endpwent, eof, eval, exec*, exists, exit, exp, 
    fileno, flock  getc, getgrent*, getgrgid*, getgrnam, getlogin,
    getppid, getpwent*, getpwnam*, getpwuid*, glob, gmtime*, goto,
    grep, hex, ioctl, import, index, int, join, keys, kill*,
    last, lc, lcfirst, lchown*, length, link*, local, localtime, log,
    lstat, m//, map, mkdir, my, next, no, oct, open, opendir, ord,
    pack, pipe, pop, pos, print, printf, push, q//, qq//, qw//,
    qx//*, quotemeta, rand, read, readdir, readlink*, redo, ref,
    rename, require, reset, return, reverse, rewinddir, rindex,
    rmdir, s///, scalar, seek, seekdir, select(internal),
    select (system call)*, setgrent, setpwent, shift, sin, sleep,
    socketpair, sort, splice, split, sprintf, sqrt, srand, stat,
    study, substr, symlink*, sysread, system*, syswrite, tell,
    telldir, tie, time, times*, tr///, uc, ucfirst, umask,
    undef, unlink*, unpack, untie, unshift, use, utime*,
    values, vec, wait, waitpid*, wantarray, warn, write, y///

The following functions were not implemented in the VMS port, 
and calling them produces a fatal error (usually) or 
undefined behavior (rarely, we hope):

    chroot, dbmclose, dbmopen, fork*, getpgrp, getpriority,  
    msgctl, msgget, msgsend, msgrcv, semctl,
    semget, semop, setpgrp, setpriority, shmctl, shmget,
    shmread, shmwrite, syscall

The following functions are available on Perls compiled with Dec C
5.2 or greater and running VMS 7.0 or greater:

    truncate

The following functions are available on Perls built on VMS 7.2 or
greater:

    fcntl (without locking)

The following functions may or may not be implemented, 
depending on what type of socket support you've built into 
your copy of Perl:

    accept, bind, connect, getpeername,
    gethostbyname, getnetbyname, getprotobyname,
    getservbyname, gethostbyaddr, getnetbyaddr,
    getprotobynumber, getservbyport, gethostent,
    getnetent, getprotoent, getservent, sethostent,
    setnetent, setprotoent, setservent, endhostent,
    endnetent, endprotoent, endservent, getsockname,
    getsockopt, listen, recv, select(system call)*,
    send, setsockopt, shutdown, socket

The following function is available on Perls built on 64 bit OpenVMS v8.2
with hard links enabled on an ODS-5 formatted build disk.  CRTL support
is in principle available as of OpenVMS v7.3-1, and better configuration
support could detect this.

    link

The following functions are available on Perls built on 64 bit OpenVMS
v8.2 and later.  CRTL support is in principle available as of OpenVMS
v7.3-2, and better configuration support could detect this.

   getgrgid, getgrnam, getpwnam, getpwuid,
   setgrent, ttyname

The following functions are available on Perls built on 64 bit OpenVMS v8.2
and later.  

   statvfs, socketpair

=over 4

=item File tests

The tests C<-b>, C<-B>, C<-c>, C<-C>, C<-d>, C<-e>, C<-f>,
C<-o>, C<-M>, C<-s>, C<-S>, C<-t>, C<-T>, and C<-z> work as
advertised.  The return values for C<-r>, C<-w>, and C<-x>
tell you whether you can actually access the file; this may
not reflect the UIC-based file protections.  Since real and
effective UIC don't differ under VMS, C<-O>, C<-R>, C<-W>,
and C<-X> are equivalent to C<-o>, C<-r>, C<-w>, and C<-x>.
Similarly, several other tests, including C<-A>, C<-g>, C<-k>,
C<-l>, C<-p>, and C<-u>, aren't particularly meaningful under
VMS, and the values returned by these tests reflect whatever
your CRTL C<stat()> routine does to the equivalent bits in the
st_mode field.  Finally, C<-d> returns true if passed a device
specification without an explicit directory (e.g. C<DUA1:>), as
well as if passed a directory.

There are DECC feature logical names AND ODS-5 volume attributes that
also control what values are returned for the date fields.

Note: Some sites have reported problems when using the file-access
tests (C<-r>, C<-w>, and C<-x>) on files accessed via DEC's DFS.
Specifically, since DFS does not currently provide access to the
extended file header of files on remote volumes, attempts to
examine the ACL fail, and the file tests will return false,
with C<$!> indicating that the file does not exist.  You can
use C<stat> on these files, since that checks UIC-based protection
only, and then manually check the appropriate bits, as defined by
your C compiler's F<stat.h>, in the mode value it returns, if you
need an approximation of the file's protections.

=item backticks

Backticks create a subprocess, and pass the enclosed string
to it for execution as a DCL command.  Since the subprocess is
created directly via C<lib$spawn()>, any valid DCL command string
may be specified.

=item binmode FILEHANDLE

The C<binmode> operator will attempt to insure that no translation
of carriage control occurs on input from or output to this filehandle.
Since this involves reopening the file and then restoring its
file position indicator, if this function returns FALSE, the
underlying filehandle may no longer point to an open file, or may
point to a different position in the file than before C<binmode>
was called.

Note that C<binmode> is generally not necessary when using normal
filehandles; it is provided so that you can control I/O to existing
record-structured files when necessary.  You can also use the
C<vmsfopen> function in the VMS::Stdio extension to gain finer
control of I/O to files and devices with different record structures.

=item crypt PLAINTEXT, USER

The C<crypt> operator uses the C<sys$hash_password> system
service to generate the hashed representation of PLAINTEXT.
If USER is a valid username, the algorithm and salt values
are taken from that user's UAF record.  If it is not, then
the preferred algorithm and a salt of 0 are used.  The
quadword encrypted value is returned as an 8-character string.

The value returned by C<crypt> may be compared against
the encrypted password from the UAF returned by the C<getpw*>
functions, in order to authenticate users.  If you're
going to do this, remember that the encrypted password in
the UAF was generated using uppercase username and
password strings; you'll have to upcase the arguments to
C<crypt> to insure that you'll get the proper value:

    sub validate_passwd {
        my($user,$passwd) = @_;
        my($pwdhash);
        if ( !($pwdhash = (getpwnam($user))[1]) ||
               $pwdhash ne crypt("\U$passwd","\U$name") ) {
            intruder_alert($name);
        }
        return 1;
    }


=item die

C<die> will force the native VMS exit status to be an SS$_ABORT code
if neither of the $! or $? status values are ones that would cause
the native status to be interpreted as being what VMS classifies as
SEVERE_ERROR severity for DCL error handling.

When C<PERL_VMS_POSIX_EXIT> is active (see L</"$?"> below), the native VMS exit
status value will have either one of the C<$!> or C<$?> or C<$^E> or
the Unix value 255 encoded into it in a way that the effective original
value can be decoded by other programs written in C, including Perl
and the GNV package.  As per the normal non-VMS behavior of C<die> if
either C<$!> or C<$?> are non-zero, one of those values will be
encoded into a native VMS status value.  If both of the Unix status
values are 0, and the C<$^E> value is set one of ERROR or SEVERE_ERROR
severity, then the C<$^E> value will be used as the exit code as is.
If none of the above apply, the Unix value of 255 will be encoded into
a native VMS exit status value.

Please note a significant difference in the behavior of C<die> in
the C<PERL_VMS_POSIX_EXIT> mode is that it does not force a VMS
SEVERE_ERROR status on exit.  The Unix exit values of 2 through
255 will be encoded in VMS status values with severity levels of
SUCCESS.  The Unix exit value of 1 will be encoded in a VMS status
value with a severity level of ERROR.  This is to be compatible with
how the VMS C library encodes these values.

The minimum severity level set by C<die> in C<PERL_VMS_POSIX_EXIT> mode
may be changed to be ERROR or higher in the future depending on the 
results of testing and further review.

See L</"$?"> for a description of the encoding of the Unix value to
produce a native VMS status containing it.

=item dump

Rather than causing Perl to abort and dump core, the C<dump>
operator invokes the VMS debugger.  If you continue to
execute the Perl program under the debugger, control will
be transferred to the label specified as the argument to
C<dump>, or, if no label was specified, back to the
beginning of the program.  All other state of the program
(I<e.g.> values of variables, open file handles) are not
affected by calling C<dump>.

=item exec LIST

A call to C<exec> will cause Perl to exit, and to invoke the command
given as an argument to C<exec> via C<lib$do_command>.  If the
argument begins with '@' or '$' (other than as part of a filespec),
then it is executed as a DCL command.  Otherwise, the first token on
the command line is treated as the filespec of an image to run, and
an attempt is made to invoke it (using F<.Exe> and the process
defaults to expand the filespec) and pass the rest of C<exec>'s
argument to it as parameters.  If the token has no file type, and
matches a file with null type, then an attempt is made to determine
whether the file is an executable image which should be invoked
using C<MCR> or a text file which should be passed to DCL as a
command procedure.

=item fork

While in principle the C<fork> operator could be implemented via
(and with the same rather severe limitations as) the CRTL C<vfork()>
routine, and while some internal support to do just that is in
place, the implementation has never been completed, making C<fork>
currently unavailable.  A true kernel C<fork()> is expected in a
future version of VMS, and the pseudo-fork based on interpreter
threads may be available in a future version of Perl on VMS (see
L<perlfork>).  In the meantime, use C<system>, backticks, or piped
filehandles to create subprocesses.

=item getpwent

=item getpwnam

=item getpwuid

These operators obtain the information described in L<perlfunc>,
if you have the privileges necessary to retrieve the named user's
UAF information via C<sys$getuai>.  If not, then only the C<$name>,
C<$uid>, and C<$gid> items are returned.  The C<$dir> item contains
the login directory in VMS syntax, while the C<$comment> item
contains the login directory in Unix syntax. The C<$gcos> item
contains the owner field from the UAF record.  The C<$quota>
item is not used.

=item gmtime

The C<gmtime> operator will function properly if you have a
working CRTL C<gmtime()> routine, or if the logical name
SYS$TIMEZONE_DIFFERENTIAL is defined as the number of seconds
which must be added to UTC to yield local time.  (This logical
name is defined automatically if you are running a version of
VMS with built-in UTC support.)  If neither of these cases is
true, a warning message is printed, and C<undef> is returned.

=item kill

In most cases, C<kill> is implemented via the undocumented system
service C<$SIGPRC>, which has the same calling sequence as C<$FORCEX>, but
throws an exception in the target process rather than forcing it to call
C<$EXIT>.  Generally speaking, C<kill> follows the behavior of the
CRTL's C<kill()> function, but unlike that function can be called from
within a signal handler.  Also, unlike the C<kill> in some versions of
the CRTL, Perl's C<kill> checks the validity of the signal passed in and
returns an error rather than attempting to send an unrecognized signal.

Also, negative signal values don't do anything special under
VMS; they're just converted to the corresponding positive value.

=item qx//

See the entry on C<backticks> above.

=item select (system call)

If Perl was not built with socket support, the system call
version of C<select> is not available at all.  If socket
support is present, then the system call version of
C<select> functions only for file descriptors attached
to sockets.  It will not provide information about regular
files or pipes, since the CRTL C<select()> routine does not
provide this functionality.

=item stat EXPR

Since VMS keeps track of files according to a different scheme
than Unix, it's not really possible to represent the file's ID
in the C<st_dev> and C<st_ino> fields of a C<struct stat>.  Perl
tries its best, though, and the values it uses are pretty unlikely
to be the same for two different files.  We can't guarantee this,
though, so caveat scriptor.

=item system LIST

The C<system> operator creates a subprocess, and passes its 
arguments to the subprocess for execution as a DCL command.  
Since the subprocess is created directly via C<lib$spawn()>, any 
valid DCL command string may be specified.  If the string begins with
'@', it is treated as a DCL command unconditionally.  Otherwise, if
the first token contains a character used as a delimiter in file
specification (e.g. C<:> or C<]>), an attempt is made to expand it
using  a default type of F<.Exe> and the process defaults, and if
successful, the resulting file is invoked via C<MCR>. This allows you
to invoke an image directly simply by passing the file specification
to C<system>, a common Unixish idiom.  If the token has no file type,
and matches a file with null type, then an attempt is made to
determine whether the file is an executable image which should be
invoked using C<MCR> or a text file which should be passed to DCL
as a command procedure.

If LIST consists of the empty string, C<system> spawns an
interactive DCL subprocess, in the same fashion as typing
B<SPAWN> at the DCL prompt.

Perl waits for the subprocess to complete before continuing
execution in the current process.  As described in L<perlfunc>,
the return value of C<system> is a fake "status" which follows
POSIX semantics unless the pragma C<use vmsish 'status'> is in
effect; see the description of C<$?> in this document for more 
detail.  

=item time

The value returned by C<time> is the offset in seconds from
01-JAN-1970 00:00:00 (just like the CRTL's times() routine), in order
to make life easier for code coming in from the POSIX/Unix world.

=item times

The array returned by the C<times> operator is divided up 
according to the same rules the CRTL C<times()> routine.  
Therefore, the "system time" elements will always be 0, since 
there is no difference between "user time" and "system" time 
under VMS, and the time accumulated by a subprocess may or may 
not appear separately in the "child time" field, depending on 
whether C<times()> keeps track of subprocesses separately.  Note
especially that the VAXCRTL (at least) keeps track only of
subprocesses spawned using C<fork()> and C<exec()>; it will not
accumulate the times of subprocesses spawned via pipes, C<system()>,
or backticks.

=item unlink LIST

C<unlink> will delete the highest version of a file only; in
order to delete all versions, you need to say

    1 while unlink LIST;

You may need to make this change to scripts written for a
Unix system which expect that after a call to C<unlink>,
no files with the names passed to C<unlink> will exist.
(Note: This can be changed at compile time; if you
C<use Config> and C<$Config{'d_unlink_all_versions'}> is
C<define>, then C<unlink> will delete all versions of a
file on the first call.)

C<unlink> will delete a file if at all possible, even if it
requires changing file protection (though it won't try to
change the protection of the parent directory).  You can tell
whether you've got explicit delete access to a file by using the
C<VMS::Filespec::candelete> operator.  For instance, in order
to delete only files to which you have delete access, you could
say something like

    sub safe_unlink {
        my($file,$num);
        foreach $file (@_) {
            next unless VMS::Filespec::candelete($file);
            $num += unlink $file;
        }
        $num;
    }

(or you could just use C<VMS::Stdio::remove>, if you've installed
the VMS::Stdio extension distributed with Perl). If C<unlink> has to
change the file protection to delete the file, and you interrupt it
in midstream, the file may be left intact, but with a changed ACL
allowing you delete access.

This behavior of C<unlink> is to be compatible with POSIX behavior
and not traditional VMS behavior.

=item utime LIST

This operator changes only the modification time of the file (VMS 
revision date) on ODS-2 volumes and ODS-5 volumes without access 
dates enabled. On ODS-5 volumes with access dates enabled, the 
true access time is modified.

=item waitpid PID,FLAGS

If PID is a subprocess started by a piped C<open()> (see L<open>), 
C<waitpid> will wait for that subprocess, and return its final status
value in C<$?>.  If PID is a subprocess created in some other way (e.g.
SPAWNed before Perl was invoked), C<waitpid> will simply check once per
second whether the process has completed, and return when it has.  (If
PID specifies a process that isn't a subprocess of the current process,
and you invoked Perl with the C<-w> switch, a warning will be issued.)

Returns PID on success, -1 on error.  The FLAGS argument is ignored
in all cases.

=back

=head1 Perl variables

The following VMS-specific information applies to the indicated
"special" Perl variables, in addition to the general information
in L<perlvar>.  Where there is a conflict, this information
takes precedence.

=over 4

=item %ENV 

The operation of the C<%ENV> array depends on the translation
of the logical name F<PERL_ENV_TABLES>.  If defined, it should
be a search list, each element of which specifies a location
for C<%ENV> elements.  If you tell Perl to read or set the
element C<$ENV{>I<name>C<}>, then Perl uses the translations of
F<PERL_ENV_TABLES> as follows:

=over 4

=item CRTL_ENV

This string tells Perl to consult the CRTL's internal C<environ> array
of key-value pairs, using I<name> as the key.  In most cases, this
contains only a few keys, but if Perl was invoked via the C
C<exec[lv]e()> function, as is the case for some embedded Perl
applications or when running under a shell such as GNV bash, the
C<environ> array may have been populated by the calling program.

=item CLISYM_[LOCAL]

A string beginning with C<CLISYM_>tells Perl to consult the CLI's
symbol tables, using I<name> as the name of the symbol.  When reading
an element of C<%ENV>, the local symbol table is scanned first, followed
by the global symbol table..  The characters following C<CLISYM_> are
significant when an element of C<%ENV> is set or deleted: if the
complete string is C<CLISYM_LOCAL>, the change is made in the local
symbol table; otherwise the global symbol table is changed.

=item Any other string

If an element of F<PERL_ENV_TABLES> translates to any other string,
that string is used as the name of a logical name table, which is
consulted using I<name> as the logical name.  The normal search
order of access modes is used.

=back

F<PERL_ENV_TABLES> is translated once when Perl starts up; any changes
you make while Perl is running do not affect the behavior of C<%ENV>.
If F<PERL_ENV_TABLES> is not defined, then Perl defaults to consulting
first the logical name tables specified by F<LNM$FILE_DEV>, and then
the CRTL C<environ> array.  This default order is reversed when the
logical name F<GNV$UNIX_SHELL> is defined, such as when running under
GNV bash.

For operations on %ENV entries based on logical names or DCL symbols, the
key string is treated as if it were entirely uppercase, regardless of the
case actually specified in the Perl expression. Entries in %ENV based on the
CRTL's environ array preserve the case of the key string when stored, and
lookups are case sensitive.

When an element of C<%ENV> is read, the locations to which
F<PERL_ENV_TABLES> points are checked in order, and the value
obtained from the first successful lookup is returned.  If the
name of the C<%ENV> element contains a semi-colon, it and
any characters after it are removed.  These are ignored when
the CRTL C<environ> array or a CLI symbol table is consulted.
However, the name is looked up in a logical name table, the
suffix after the semi-colon is treated as the translation index
to be used for the lookup.   This lets you look up successive values
for search list logical names.  For instance, if you say

   $  Define STORY  once,upon,a,time,there,was
   $  perl -e "for ($i = 0; $i <= 6; $i++) " -
   _$ -e "{ print $ENV{'story;'.$i},' '}"

Perl will print C<ONCE UPON A TIME THERE WAS>, assuming, of course,
that F<PERL_ENV_TABLES> is set up so that the logical name C<story>
is found, rather than a CLI symbol or CRTL C<environ> element with
the same name.

When an element of C<%ENV> is set to a defined string, the
corresponding definition is made in the location to which the
first translation of F<PERL_ENV_TABLES> points.  If this causes a
logical name to be created, it is defined in supervisor mode.
(The same is done if an existing logical name was defined in
executive or kernel mode; an existing user or supervisor mode
logical name is reset to the new value.)  If the value is an empty
string, the logical name's translation is defined as a single C<NUL>
(ASCII C<\0>) character, since a logical name cannot translate to a
zero-length string.  (This restriction does not apply to CLI symbols
or CRTL C<environ> values; they are set to the empty string.)

When an element of C<%ENV> is set to C<undef>, the element is looked
up as if it were being read, and if it is found, it is deleted.  (An
item "deleted" from the CRTL C<environ> array is set to the empty
string.)  Using C<delete> to remove an element from C<%ENV> has a
similar effect, but after the element is deleted, another attempt is
made to look up the element, so an inner-mode logical name or a name
in another location will replace the logical name just deleted. In
either case, only the first value found searching PERL_ENV_TABLES is
altered.  It is not possible at present to define a search list
logical name via %ENV.

The element C<$ENV{DEFAULT}> is special: when read, it returns
Perl's current default device and directory, and when set, it
resets them, regardless of the definition of F<PERL_ENV_TABLES>.
It cannot be cleared or deleted; attempts to do so are silently
ignored.

Note that if you want to pass on any elements of the
C-local environ array to a subprocess which isn't
started by fork/exec, or isn't running a C program, you
can "promote" them to logical names in the current
process, which will then be inherited by all subprocesses,
by saying

    foreach my $key (qw[C-local keys you want promoted]) {
        my $temp = $ENV{$key}; # read from C-local array
        $ENV{$key} = $temp;    # and define as logical name
    }

(You can't just say C<$ENV{$key} = $ENV{$key}>, since the
Perl optimizer is smart enough to elide the expression.)

Don't try to clear C<%ENV> by saying C<%ENV = ();>, it will throw
a fatal error.  This is equivalent to doing the following from DCL:

    DELETE/LOGICAL *

You can imagine how bad things would be if, for example, the SYS$MANAGER
or SYS$SYSTEM logical names were deleted.

At present, the first time you iterate over %ENV using
C<keys>, or C<values>,  you will incur a time penalty as all
logical names are read, in order to fully populate %ENV.
Subsequent iterations will not reread logical names, so they
won't be as slow, but they also won't reflect any changes
to logical name tables caused by other programs.

You do need to be careful with the logical names representing
process-permanent files, such as C<SYS$INPUT> and C<SYS$OUTPUT>.
The translations for these logical names are prepended with a
two-byte binary value (0x1B 0x00) that needs to be stripped off
if you want to use it. (In previous versions of Perl it wasn't
possible to get the values of these logical names, as the null
byte acted as an end-of-string marker)

=item $!

The string value of C<$!> is that returned by the CRTL's
strerror() function, so it will include the VMS message for
VMS-specific errors.  The numeric value of C<$!> is the
value of C<errno>, except if errno is EVMSERR, in which
case C<$!> contains the value of vaxc$errno.  Setting C<$!>
always sets errno to the value specified.  If this value is
EVMSERR, it also sets vaxc$errno to 4 (NONAME-F-NOMSG), so
that the string value of C<$!> won't reflect the VMS error
message from before C<$!> was set.

=item $^E

This variable provides direct access to VMS status values
in vaxc$errno, which are often more specific than the
generic Unix-style error messages in C<$!>.  Its numeric value
is the value of vaxc$errno, and its string value is the
corresponding VMS message string, as retrieved by sys$getmsg().
Setting C<$^E> sets vaxc$errno to the value specified.

While Perl attempts to keep the vaxc$errno value to be current, if
errno is not EVMSERR, it may not be from the current operation.

=item $?

The "status value" returned in C<$?> is synthesized from the
actual exit status of the subprocess in a way that approximates
POSIX wait(5) semantics, in order to allow Perl programs to
portably test for successful completion of subprocesses.  The
low order 8 bits of C<$?> are always 0 under VMS, since the
termination status of a process may or may not have been
generated by an exception.

The next 8 bits contain the termination status of the program.

If the child process follows the convention of C programs
compiled with the _POSIX_EXIT macro set, the status value will
contain the actual value of 0 to 255 returned by that program
on a normal exit.

With the _POSIX_EXIT macro set, the Unix exit value of zero is
represented as a VMS native status of 1, and the Unix values
from 2 to 255 are encoded by the equation:

   VMS_status = 0x35a000 + (unix_value * 8) + 1.

And in the special case of Unix value 1 the encoding is:

   VMS_status = 0x35a000 + 8 + 2 + 0x10000000.

For other termination statuses, the severity portion of the
subprocess's exit status is used: if the severity was success or
informational, these bits are all 0; if the severity was
warning, they contain a value of 1; if the severity was
error or fatal error, they contain the actual severity bits,
which turns out to be a value of 2 for error and 4 for severe_error.
Fatal is another term for the severe_error status.

As a result, C<$?> will always be zero if the subprocess's exit
status indicated successful completion, and non-zero if a
warning or error occurred or a program compliant with encoding
_POSIX_EXIT values was run and set a status.

How can you tell the difference between a non-zero status that is
the result of a VMS native error status or an encoded Unix status?
You can not unless you look at the ${^CHILD_ERROR_NATIVE} value.
The ${^CHILD_ERROR_NATIVE} value returns the actual VMS status value
and check the severity bits. If the severity bits are equal to 1,
then if the numeric value for C<$?> is between 2 and 255 or 0, then
C<$?> accurately reflects a value passed back from a Unix application.
If C<$?> is 1, and the severity bits indicate a VMS error (2), then
C<$?> is from a Unix application exit value.

In practice, Perl scripts that call programs that return _POSIX_EXIT
type status values will be expecting those values, and programs that
call traditional VMS programs will either be expecting the previous
behavior or just checking for a non-zero status.

And success is always the value 0 in all behaviors.

When the actual VMS termination status of the child is an error,
internally the C<$!> value will be set to the closest Unix errno
value to that error so that Perl scripts that test for error
messages will see the expected Unix style error message instead
of a VMS message.

Conversely, when setting C<$?> in an END block, an attempt is made
to convert the POSIX value into a native status intelligible to
the operating system upon exiting Perl.  What this boils down to
is that setting C<$?> to zero results in the generic success value
SS$_NORMAL, and setting C<$?> to a non-zero value results in the
generic failure status SS$_ABORT.  See also L<perlport/exit>.

With the C<PERL_VMS_POSIX_EXIT> logical name defined as "ENABLE",
setting C<$?> will cause the new value to be encoded into C<$^E>
so that either the original parent or child exit status values 
 0 to 255 can be automatically recovered by C programs expecting
_POSIX_EXIT behavior.  If both a parent and a child exit value are
non-zero, then it will be assumed that this is actually a VMS native
status value to be passed through.  The special value of 0xFFFF is
almost a NOOP as it will cause the current native VMS status in the
C library to become the current native Perl VMS status, and is handled
this way as it is known to not be a valid native VMS status value.
It is recommend that only values in the range of normal Unix parent or
child status numbers, 0 to 255 are used.

The pragma C<use vmsish 'status'> makes C<$?> reflect the actual 
VMS exit status instead of the default emulation of POSIX status 
described above.  This pragma also disables the conversion of
non-zero values to SS$_ABORT when setting C<$?> in an END
block (but zero will still be converted to SS$_NORMAL).

Do not use the pragma C<use vmsish 'status'> with C<PERL_VMS_POSIX_EXIT>
enabled, as they are at times requesting conflicting actions and the
consequence of ignoring this advice will be undefined to allow future
improvements in the POSIX exit handling.

In general, with C<PERL_VMS_POSIX_EXIT> enabled, more detailed information
will be available in the exit status for DCL scripts or other native VMS tools,
and will give the expected information for Posix programs.  It has not been
made the default in order to preserve backward compatibility.

N.B. Setting C<DECC$FILENAME_UNIX_REPORT> implicitly enables 
C<PERL_VMS_POSIX_EXIT>.

=item $|

Setting C<$|> for an I/O stream causes data to be flushed
all the way to disk on each write (I<i.e.> not just to
the underlying RMS buffers for a file).  In other words,
it's equivalent to calling fflush() and fsync() from C.

=back

=head1 Standard modules with VMS-specific differences

=head2 SDBM_File

SDBM_File works properly on VMS. It has, however, one minor
difference. The database directory file created has a F<.sdbm_dir>
extension rather than a F<.dir> extension. F<.dir> files are VMS filesystem
directory files, and using them for other purposes could cause unacceptable
problems.

=head1 Revision date

Please see the git repository for revision history.

=head1 AUTHOR

Charles Bailey  bailey@cor.newman.upenn.edu
Craig Berry  craigberry@mac.com
Dan Sugalski  dan@sidhe.org
John Malmberg wb8tyw@qsl.net
                                                                                                                                                                                                                                                                                                                                                                                   usr/local/lib/perl5/5.40.0/pod/perlvos.pod                                                          0000644 0000000 0000000 00000007426 14714567415 016477  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # vim: syntax=pod

If you read this file _as_is_, just ignore the funny characters you
see. It is written in the POD format (see pod/perlpod.pod) which is
specially designed to be readable as is.

=head1 NAME

perlvos - Perl for Stratus OpenVOS

=head1 SYNOPSIS

This file contains notes for building perl on the Stratus OpenVOS
operating system.  Perl is a scripting or macro language that is
popular on many systems.  See L<perlbook> for a number of good books
on Perl.

These are instructions for building Perl from source.  This version of
Perl requires the dynamic linking support that is found in OpenVOS
Release 17.1 and thus is not supported on OpenVOS Release 17.0 or
earlier releases.

If you are running VOS Release 14.4.1 or later, you can obtain a
pre-compiled, supported copy of perl by purchasing the GNU Tools
product from Stratus Technologies.

=head1 BUILDING PERL FOR OPENVOS

To build perl from its source code on the Stratus V Series platform
you must have OpenVOS Release 17.1.0 or later, GNU Tools Release
3.5 or later, and the C/POSIX Runtime Libraries.

Follow the normal instructions for building perl; e.g, enter bash, run
the Configure script, then use "gmake" to build perl.

=head1 INSTALLING PERL IN OPENVOS

=over 4

=item 1

After you have built perl using the Configure script, ensure that you
have modify and default write permission to C<< >system>ported >> and
all subdirectories.  Then type

     gmake install

=item 2

While there are currently no architecture-specific extensions or
modules distributed with perl, the following directories can be
used to hold such files (replace the string VERSION by the
appropriate version number):

     >system>ported>lib>perl5>VERSION>i786

=item 3

Site-specific perl extensions and modules can be installed in one of
two places.  Put architecture-independent files into:

     >system>ported>lib>perl5>site_perl>VERSION

Put site-specific architecture-dependent files into one of the
following directories:

     >system>ported>lib>perl5>site_perl>VERSION>i786

=item 4

You can examine the @INC variable from within a perl program
to see the order in which Perl searches these directories.

=back

=head1 USING PERL IN OPENVOS

=head2 Restrictions of Perl on OpenVOS

This port of Perl version 5 prefers Unix-style, slash-separated
pathnames over OpenVOS-style greater-than-separated pathnames.
OpenVOS-style pathnames should work in most contexts, but if you have
trouble, replace all greater-than characters by slash characters.
Because the slash character is used as a pathname delimiter, Perl
cannot process OpenVOS pathnames containing a slash character in a
directory or file name; these must be renamed.

This port of Perl also uses Unix-epoch date values internally.
As long as you are dealing with ASCII character string
representations of dates, this should not be an issue.  The
supported epoch is January 1, 1980 to January 17, 2038.

See the file pod/perlport.pod for more information about the OpenVOS
port of Perl.

=head1 TEST STATUS

A number of the perl self-tests fails for various reasons; generally
these are minor and due to subtle differences between common
POSIX-based environments and the OpenVOS POSIX environment.  Ensure
that you conduct sufficient testing of your code to guarantee that it
works properly in the OpenVOS environment.

=head1 SUPPORT STATUS

I'm offering this port "as is".  You can ask me questions, but I
can't guarantee I'll be able to answer them.  There are some
excellent books available on the Perl language; consult a book
seller.

If you want a supported version of perl for OpenVOS, purchase the
OpenVOS GNU Tools product from Stratus Technologies, along with a
support contract (or from anyone else who will sell you support).

=head1 AUTHOR

Paul Green (Paul.Green@stratus.com)

=head1 LAST UPDATE

February 28, 2013

=cut
                                                                                                                                                                                                                                          usr/local/lib/perl5/5.40.0/pod/perlwin32.pod                                                        0000644 0000000 0000000 00000076141 14714567415 016632  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # vim: syntax=pod

If you read this file _as_is_, just ignore the funny characters you
see. It is written in the POD format (see pod/perlpod.pod) which is
specially designed to be readable as is.

=head1 NAME

perlwin32 - Perl under Windows

=head1 SYNOPSIS

These are instructions for building Perl under Windows 7 and later.

=head1 DESCRIPTION

Before you start, you should glance through the README file
found in the top-level directory to which the Perl distribution
was extracted.  Make sure you read and understand the terms under
which this software is being distributed.

Also make sure you read L</BUGS AND CAVEATS> below for the
known limitations of this port.

The INSTALL file in the perl top-level has much information that is
only relevant to people building Perl on Unix-like systems.  In
particular, you can safely ignore any information that talks about
"Configure".

You may also want to look at one other option for building a perl that
will work on Windows: the README.cygwin file, which give a different
set of rules to build a perl for Windows.  This method will probably
enable you to build a more Unix-compatible perl, but you will also
need to download and use various other build-time and run-time support
software described in that file.

This set of instructions is meant to describe a so-called "native"
port of Perl to the Windows platform.  This includes both 32-bit and
64-bit Windows operating systems.  The resulting Perl requires no
additional software to run (other than what came with your operating
system).  Currently, this port is capable of using one of the
following compilers on the Intel x86 and x86_64 architectures:

      Microsoft Visual C++    Visual C++ 2015 (version 14.0) or later
      Intel C++ Compiler      (experimental)
      Gcc by mingw.org        gcc version 3.4.5-5.3.0
      Gcc by mingw-w64.org    gcc version 4.4.3 or later

Note that the last two of these are actually competing projects both
delivering complete gcc toolchain for MS Windows:

=over 4

=item L<https://osdn.net/projects/mingw/>

Delivers gcc toolchain building 32-bit executables (which can be used both 32 and 64 bit Windows platforms)

=item L<https://mingw-w64.org>

Delivers gcc toolchain targeting both 64-bit Windows and 32-bit Windows
platforms (despite the project name "mingw-w64" they are not only 64-bit
oriented). They deliver the native gcc compilers and cross-compilers
that are also supported by perl's makefile.

=back

The Microsoft Visual C++ compilers are also now being given away free. They
are available as "Visual C++ 2015-2022 Community Edition" and are the same
compilers that ship with "Visual C++ 2015-2022 Professional".

The MinGW64 compiler is available at L<https://mingw-w64.org>.
The latter is actually a cross-compiler targeting Win64. There's also a trimmed
down compiler (no java, or gfortran) suitable for building perl available at:
L<https://strawberryperl.com/package/kmx/64_gcctoolchain/>

NOTE: If you're using a 32-bit compiler to build perl on a 64-bit Windows
operating system, then you should set the WIN64 environment variable to "undef".
Also, the trimmed down compiler only passes tests when USE_ITHREADS *= define
(as opposed to undef) and when the CFG *= Debug line is commented out.

This port fully supports MakeMaker (the set of modules that
is used to build extensions to perl).  Therefore, you should be
able to build and install most extensions found in the CPAN sites.
See L</Usage Hints for Perl on Windows> below for general hints about this.

=head2 Setting Up Perl on Windows

=over 4

=item Make

You need a "make" program to build the sources.  If you are using
Visual C++, you can use nmake supplied with Visual C++.
You may also use gmake instead of nmake.  Builds using gcc need
gmake. nmake is not supported for gcc builds.  Parallel building is only
supported with gmake, not nmake.

=item Command Shell

Use the default "cmd" shell that comes with Windows.  Some versions of the
popular 4DOS/NT shell have incompatibilities that may cause you trouble.
If the build fails under that shell, try building again with the cmd
shell.

Make sure the path to the build directory does not contain spaces.  The
build usually works in this circumstance, but some tests will fail.

=item Microsoft Visual C++

The nmake that comes with Visual C++ will suffice for building. Visual C++
requires that certain things be set up in the console before Visual C++ will
successfully run. To make a console box be able to run the C compiler, you will
need to beforehand, run C<vcvarsall.bat x86> to compile for x86-32 and for
x86-64 C<vcvarsall.bat amd64>. On a typical install of a Microsoft C++
compiler product, these batch files will already be in your C<PATH>
environment variable so you may just type them without an absolute path into
your console. If you need to find the absolute path to the batch file, it is
usually found somewhere like
C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC.
With some newer Microsoft C products (released after ~2004), the installer will
put a shortcut in the start menu to launch a new console window with the
console already set up for your target architecture (x86-32 or x86-64 or IA64).
With the newer compilers, you may also use the older batch files if you choose
so.

=item Microsoft Visual C++ 2015-2022 Community Edition

These free versions of Visual C++ 2015-2022 Professional contain the same
compilers and linkers that ship with the full versions, and also contain
everything necessary to build Perl.

These packages can be downloaded from L<https://visualstudio.microsoft.com/>.

Install Visual C++ 2015-2022 Community, then setup your environment
using, e.g.

F<C:\Program Files\Microsoft Visual Studio 14.0\Common7\Tools\vsvars32.bat>

(assuming the default installation location was chosen).

Perl should now build using the F<win32/Makefile>.  You will need to edit that
file to set C<CCTYPE> to one of C<MSVC140>-C<MSVC143> first.

=item Microsoft C++ Build Tools

There's also a standalone (IDE-less) version of the build tools mentioned
above containing the MSVC compiler available for download from
L<https://visualstudio.microsoft.com/visual-cpp-build-tools/>.

This is also referred to as I<Build Tools for Visual Studio>.

=item GCC

Perl can be compiled with gcc from MinGW (version 3.4.5 or later) or from
MinGW64 (version 4.4.3 or later).  It can be downloaded here:

L<https://osdn.net/projects/mingw/>
L<https://www.mingw-w64.org/>

You also need gmake. Usually it comes with MinGW but its executable may have
a different name, such as mingw32-make.exe.

Note that the MinGW build currently fails with version 6.3.0 or later.

Note also that the C++ mode build currently fails with MinGW 3.4.5 and 4.7.2
or later, and with MinGW64 64-bit 6.3.0 or later.

