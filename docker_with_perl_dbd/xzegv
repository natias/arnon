$GrabDetails->tagConfigure("bold", -font => "bold");
$frame->pack(-fill => "x");

### SQL selection
$frame = $GrabMain->Frame(-borderwidth => 3, -relief => "raised");
$frame->Label(-text => "SQL Selection Criteria")->pack(-anchor => "w");
$frame1 = $frame->Frame(-highlightthickness => 1);

## SQL sort frame
$frame1->Label(-text => "Order SQL by")
   ->grid(-column => 0, -row => 0, -sticky => "w", -columnspan => 2);
$frame2 = $frame1->Frame(-highlightthickness => 0);

# Ordering frame
$frame3 = $frame2->Frame(-highlightthickness => 1);
$frame3->Radiobutton(-text => "No ordering", -highlightthickness => 0,
                     -value => "", -variable => \$ordering,
                     -command => $ord_bn_cb)
   ->pack(-anchor => "w");
$frame3->Radiobutton(-text => "Total", -highlightthickness => 0,
                    -value => "total", -variable => \$ordering,
                    -command => $ord_bn_cb)
   ->pack(-anchor => "w");
$frame3->Radiobutton(-text => "Average per execution",
                     -highlightthickness => 0, -value => "average",
                     -variable => \$ordering, -command => $ord_bn_cb)
   ->pack(-anchor => "w");
$frame3->pack(-side => "left", -padx => 6);

# Order by frame
$frame3 = $frame2->Frame(-highlightthickness => 1);
$ord_bn{disk_reads} =
   $frame3->Radiobutton(-text => "Disk reads", -highlightthickness => 0,
                        -value => "disk_reads", -variable => \$order_by,
                        -command => $ord_bn_cb)
      ->grid(-column => 0, -row => 0, -sticky => "w");
$ord_bn{buffer_gets} =
   $frame3->Radiobutton(-text => "Buffer gets", -highlightthickness => 0,
                        -value => "buffer_gets", -variable => \$order_by,
                        -command => $ord_bn_cb)
      ->grid(-column => 1, -row => 0, -sticky => "w");
$ord_bn{rows_processed} =
   $frame3->Radiobutton(-text => "Rows processed", -highlightthickness => 0,
                        -value => "rows_processed", -variable => \$order_by,
                        -command => $ord_bn_cb)
      ->grid(-column => 0, -row => 1, -sticky => "w");
$ord_bn{sorts} =
   $frame3->Radiobutton(-text => "Sorts", -highlightthickness => 0,
                        -value => "sorts", -variable => \$order_by,
                        -command => $ord_bn_cb)
      ->grid(-column => 1, -row => 1, -sticky => "w");
$ord_bn{loads} =
   $frame3->Radiobutton(-text => "Loads", -highlightthickness => 0,
                        -value => "loads", -variable => \$order_by,
                        -command => $ord_bn_cb)
      ->grid(-column => 0, -row => 2, -sticky => "w");
$ord_bn{parse_calls} =
   $frame3->Radiobutton(-text => "Parse calls", -highlightthickness => 0,
                        -value => "parse_calls", -variable => \$order_by,
                        -command => $ord_bn_cb)
      ->grid(-column => 1, -row => 2, -sticky => "w");
$ord_bn{executions} =
   $frame3->Radiobutton(-text => "Executions", -highlightthickness => 0,
                        -value => "executions", -variable => \$order_by,
                        -command => $ord_bn_cb)
      ->grid(-column => 0, -row => 3, -sticky => "w");
$ord_bn{first_load_time} =
   $frame3->Radiobutton(-text => "First load", -highlightthickness => 0,
                        -value => "first_load_time", -variable => \$order_by,
                        -command => $ord_bn_cb)
      ->grid(-column => 1, -row => 3, -sticky => "w");
$frame3->pack(-side => "left", -padx => 6);

# Sort order frame
$frame3 = $frame2->Frame(-highlightthickness => 1);
$sort_bn{desc} =
   $frame3->Radiobutton(-text => "Descending", -highlightthickness => 0,
                        -value => "desc", -variable => \$sort_by,
                        -command => $ord_bn_cb)
      ->grid(-column => 0, -row => 0, -sticky => "w");
$sort_bn{asc} =
   $frame3->Radiobutton(-text => "Ascending", -highlightthickness => 0,
                        -value => "asc", -variable => \$sort_by,
                        -command => $ord_bn_cb)
      ->grid(-column => 0, -row => 1, -sticky => "w");
$frame3->pack(-side => "right", -padx => 6);
$frame2->grid(-column => 0, -row => 1, -sticky => "w", -columnspan => 2);

## Other options frame
$frame2 = $frame1->Frame(-highlightthickness => 0);
$frame2->Checkbutton(-text => "Exclude queries by SYS or SYSTEM",
                     -variable => \$no_sys, -offvalue => 0, -onvalue => 1,
                     -highlightthickness => 0)
   ->grid(-column => 0, -row => 0, -sticky => "w", -columnspan => 2);
$frame2->Label(-text => "First user to execute statement")
   ->grid(-column => 0, -row => 1, -sticky => "w");
$frame2->Entry(-textvariable => \$user, -width => 30)
   ->grid(-column => 1, -row => 1, -sticky => "w");
$frame2->Label(-text => "SQL matches pattern")
   ->grid(-column => 0, -row => 2, -sticky => "w");
$frame2->Entry(-textvariable => \$pattern, -width => 30)
   ->grid(-column => 1, -row => 2, -sticky => "w");
$frame2->Label(-text => "Maximum number of statements")
   ->grid(-column => 0, -row => 3, -sticky => "w");
$frame2->Entry(-textvariable => \$rows, -width => 4)
   ->grid(-column => 1, -row => 3, -sticky => "w");
$frame2->grid(-column => 0, -row => 2, -sticky => "we",
              -columnspan => 2, -padx => 6, -pady => 6);
$frame1->pack(-fill => "x");
&$ord_bn_cb();   # Set the buttons to the initial state
$frame->pack(-fill => "x", -padx => 6, -pady => 6);

### Buttons
$frame = $GrabMain->Frame(-borderwidth => 3, -relief => "raised");
$frame->Button(-text => "Capture SQL", -command => $grab_cb)
   ->pack(-side => "left", -expand => 1, -pady => 6);
$frame->Button(-text => "Copy to Explain",
               -command => sub { copy_sql($GrabSql, $GrabSelection); })
   ->pack(-side => "left", -expand => 1, -pady => 6);
$frame->Button(-text => "Close", -command => sub { $GrabMain->withdraw(); })
   ->pack(-side => "left", -expand => 1, -pady => 6);
$frame->pack(-fill => "x");
}

################################################################################
# Main

### Main window
$ProgName = basename($0);
$ProgName =~ s/\..*$//;
$PlanMain = MainWindow->new();
$PlanMain->withdraw();
update_title();
$Balloon = $PlanMain->Balloon();

### Splash screen
my $splash;
if (@ARGV == 0 || $ARGV[0] ne '-q')
   {
   about($PlanMain, \$splash);
   $splash->after(10000,
                  sub { if ($splash) { $splash->destroy(); undef($splash); } });
   $PlanMain->update();
   }
else
   { shift(@ARGV); }

### Menubar
my $menubar = $PlanMain->Frame(-relief => "raised", -borderwidth => 3);

# Create a bold font $ figure out charcter spacing
my $t = $PlanMain->Text();
my $f = $t->cget(-font);
$t->fontCreate("bold", $PlanMain->fontActual($f), -weight => "bold");
$CharWidth = $PlanMain->fontMeasure($f, "X");
undef($f);
$t->destroy();
undef($t);

my $menubar_file = $menubar->Menubutton(-text => "File", -underline => 0);
$menubar_file->command(-label => "Login ...", -underline => 0,
   -command => sub { login_dialog($PlanMain); });
$menubar_file->command(-label => "Schema ...", -underline => 2,
   -command => sub { schema_dialog($PlanMain); });
$menubar_file->command(-label => "Explain", -underline => 0,
   -command => \&explain);
$menubar_file->command(-label => "SQL Cache ...", -underline => 4,
   -command => \&grab_main);
$menubar_file->separator();
$menubar_file->command(-label => "Open File ...", -underline => 0,
   -command => sub { open_dialog($PlanMain); });
$menubar_file->command(-label => "Save File ...", -underline => 0,
   -command => sub { save_dialog($PlanMain, $PlanSql); });
$menubar_file->separator();
$menubar_file->command(-label => "Exit", -underline => 1,
   -command => sub { $Db->disconnect() if ($Db); exit(0); });
$menubar_file->pack(-side => "left");

my $menubar_help = $menubar->Menubutton(-text => "Help", -underline => 0);
$menubar_help->command(-label => "About ...", -underline => 0,
   -command => sub { about($PlanMain); });
$menubar_help->command(-label => "Usage ...", -underline => 0,
   -command => sub { help($PlanMain); });
$menubar_help->pack(-side => "right");
$menubar->pack(-fill => "x");

### Query plan tree
my $frame;
$frame = $PlanMain->Frame(-borderwidth => 3, -relief => "raised");
$PlanTitle = $frame->Label(-text => "Query Plan")->pack(-anchor => "nw");
my $b1_cb = sub
   { error($PlanMain, $@) if (! eval { disp_plan_step_obj($_[0])}); };
my $b3_cb = sub
   { error($PlanMain, $@) if (! eval { disp_index_popup($_[0])}); };
$PlanTree = $frame->Scrolled("B3Tree", -height => 15, -width => 80,
                             -borderwidth => 0, -highlightthickness => 1,
                             -scrollbars => "osoe",
                             -browsecmd => \&disp_plan_step,
                             -command => $b1_cb, -b3command => $b3_cb)
   ->pack(-expand => 1, -fill => "both");
$frame->pack(-expand => 1, -fill => "both");

### Query plan statement details
$frame = $PlanMain->Frame(-borderwidth => 3, -relief => "raised");
$frame->Label(-text => "Query Step Details")->pack(-anchor => "nw");
$PlanStep = $frame->Scrolled("ROText", -height => 8, -width => 80,
                             -borderwidth => 0, -wrap => "none",
                             -setgrid => "true", -scrollbars => "osoe")
   ->pack(-fill => "x");
$frame->pack(-fill => "x");

### SQL text editor
$frame = $PlanMain->Frame(-borderwidth => 3, -relief => "raised");
$frame->Label(-text => "SQL Editor")->pack(-anchor => "nw");
$PlanSql = $frame->Scrolled("Text", -setgrid => "true", -scrollbars => "oe",
                            -borderwidth => 0, -height => 15, -width => 80,
                            -wrap => "word")
   ->pack(-expand => 1, -fill => "both");
$frame->pack(-expand => 1, -fill => "both");

### Buttons
$frame = $PlanMain->Frame(-borderwidth => 3, -relief => "raised");
$frame->Button(-text => "Explain", -command => \&explain)
   ->pack(-side => "left", -expand => 1, -pady => 6);
$frame->Button(-text => "Clear", -command => \&clear_editor)
   ->pack(-side => "left", -expand => 1, -pady => 6);
$frame->Button(-text => "SQL Cache", -command => \&grab_main)
   ->pack(-side => "left", -expand => 1, -pady => 6);
$frame->pack(-fill => "x");

### user/pass@db command-line argument processing
$PlanMain->update();
$PlanMain->deiconify();
$splash->raise() if (defined($splash));
if (@ARGV >= 1 && $ARGV[0] =~ /\w*\/\w*(@\w+)?/)
   {
   my ($username, $password, $database) = split(/[\/@]/, shift(@ARGV));
   if (! $username) { $username = "/"; $password = ""; }
   if (! $database) { $database = $ENV{TWO_TASK} || $ENV{ORACLE_SID}; }
   error($PlanMain, $@) if (! eval { login($database, $username, $password); });
   update_title();
   }
else
   {
   login_dialog($PlanMain);
   }

### SQL filename argument processing
if (@ARGV >= 1 && -r $ARGV[0])
   {
   my $file = shift(@ARGV);
   if (open_file($file))
      {
      $FileDir = dirname($file);
      explain() if ($Db);
      }
   }

# Doncha just love GUI programming :-)
MainLoop();

################################################################################
__END__

=head1 NAME

ora_explain.pl - Visualise Oracle query plans

=head1 SYNOPSIS

 $ ora_explain.pl [ [ user/password@database ] sql script ]

=head1 DESCRIPTION

Explain is a GUI-based tool that enables easier visualisation of Oracle Query
plans.  A query plan is the access path that Oracle will use to satisfy a SQL
query.  The Oracle query optimiser is responsible for deciding on the optimal
path to use.  Needless to say, understanding such plans requires a fairly
sophisticated knowledge of Oracle architecture and internals.

Explain allows a user to interactively edit a SQL statement and view the
resulting query plan with the click of a single button.  The effects of
modifying the SQL or of adding hints can be rapidly established.

Explain allows the user to capture all the SQL currently cached by Oracle.  The
SQL capture can be filtered and sorted by different criterea, e.g. all SQL
matching a pattern, order by number of executions etc.

Explain is written using Perl, DBI/DBD::Oracle and Tk.

=head1 PREREQUISITES

=over 2

=item 1.

Oracle 7 or Oracle 8, with SQL*Net if appropriate

=item 2.

L<Perl 5.004_04|perl> or later

=item 3.

L<DBI> version 1.02 or later

=item 4.

L<DBD::Oracle> 0.54 or later

=item 5.

L<Tk|Tk::overview> 800.011 or later

=item 6.

L<Tk::Pod> 3.15 or later

=back

Items 2 through 6 can be obtained from any CPAN mirror.

=head1 HOW TO USE

Type "ora_explain.pl" at the shell prompt.  A window will appear with
a menu bar and three frames, labelled "Query Plan", "Query Step Details" and
"SQL Editor".  At the bottom of the window are three buttons labelled
"Explain", "Clear" and "SQL Cache".  A login dialog will also appear, into
which you should enter the database username, password and database instance
name (SID).  The parameters you enter are passed to the DBI->connect() method,
so if you have any problems refer to the DBI and DBD::Oracle documentation.

Optionally you may supply up to two command-line arguments.  If the first
argument is of the form username/password@database, explain will use this to
log in to Oracle, otherwise if it is a filename it will be loaded into the SQL
editor.  If two arguments are supplied, the second one will be assumed to be a
filename.

Examples:

   explain scott/tiger@DEMO query.sql
   explain / query.sql
   explain query.sql

=head2 Explain functionality

The menu bar has two pulldown menus, "File" and "Help".  "File" allows you to
login to Oracle, Change the current schema, Capture the contents of the Oracle
SQL cache, Load SQL from files, Save SQL to files and to Exit the program.
"Help" allows you to view release information and read this documentation.

The "SQL Editor" frame allows the editing of a SQL statement.  This should be
just a single statement - multiple statements are not allowed.  Refer to the
documentation for the Tk text widget for a description of the editing keys
available.  Text may be loaded and saved by using the "File" pulldown menu.

Once you have entered a SQL statement, the "Explain" button at the bottom of
the window will generate the query plan for the statement.  A tree
representation of the plan will appear in the "Query Plan" frame.  Individual
"legs" of the plan may be expanded and collapsed by clicking on the "+' and "-"
boxes on the plan tree.  The tree is drawn so that the "innermost" or "first"
query steps are indented most deeply.  The connecting lines show the
"parent-child" relationships between the query steps.  For a comprehensive
explanation of the meaning of query plans you should refer to the relevant
Oracle documentation.  The "Clear" button will empty the editor & query plan
tree panes.

Single-clicking on a plan step in the Query Plan pane will display more
detailed information on that query step in the Query Step Details frame.  This
information includes Oracle's estimates of cost, cardinality and bytes
returned.  The exact information displayed depends on the Oracle version.
Again, for detailed information on the meaning of these fields, refer to the
Oracle documentation.

Double-clicking on a plan step that refers to either a table or an index will
pop up a dialog box showing the definition of the table or index in a format
similar to that of the SQL*Plus 'desc' command.

The dialog that appears has a button labelled 'Index'.  Clicking on this will
expand the table dialog to show all the indexes defined on the table.  Each
column represents an index, and the figures define the order that the table
columns appears in the index.  To find out the name of an index, position the
mouse over the index column.  A single click will display the definition of the
index in a separate dialog.

Right-clicking on a plan step that refers to a table will pop up a menu showing
a list of the indexes available for the table.  Selecting an index will display
its definition in a dialog box.

=head2 Capture SQL Cache functionality

The explain window has an option on the "File" menu labelled "SQL Cache ...",
as well as a button with the same function.  Selecting this will popup a new
top-level window containing a menu bar and three frames, labelled "SQL Cache",
"SQL Statement Statistics" and "SQL Selection Criteria".  At the bottom of the
window are three buttons labelled "Capture SQL", "Explain" and "Close".

The menu bar has two pulldown menus "File" and "Help".  "File" allows you to
Save the contents of the SQL Cache pane to a file, copy the selected SQL
statement to the Explain window and Close the Grab window.

The "SQL Cache" frame shows the statements currently in the Oracle SQL cache.
As you move the cursor over this window, each SQL statement will be highlighted
with an outline box.  Single-clicking on a statement in the SQL Cache pane will
highlight the statement in green and display more detailed information on that
statement in the SQL Statement Statistics frame.

If you want to save the entire contents of the SQL Cache pane, you can do this
from the "File" menu.

The "SQL Selection Criteria" frame allows you to specify which SQL statements
you are interested in, and how you want them sorted.  The pattern used to select
statements is a normal perl regexp.  Once you have defined the selection
criteria, clicking the "Capture SQL" button will read all the matching
statements from the SQL cache and display them in the top frame.

Double-clicking on a statement in the "SQL Cache" pane, selecting "Explain"
from the "File" menu or clicking the "Explain" button will copy the currently
highlighted statement in the "SQL Cache" pane to the SQL editor in the Explain
window, so that the query plan for the statement can be examined.  Note also
that the current schema will be changed to that of the user who first executed
the captured statement.

=head1 SEE ALSO

This tool assumes that you already know how to interpret Oracle query plans.
If need an explanation of the information displayed by this tool, you should
refer to the appropriate Oracle documentation.  Information can be found in the
"Concepts" and "Oracle Tuning" manuals - look for "Query plan" and "Explain
plan".  Two other useful sources of information are:

   Oracle Performance Tuning, 2nd ed.
      Mark Gurry and Peter Corrigan
      O'Reilly & Associates, Inc.
      ISBN 1-56592-237-9

   Advanced Oracle Tuning and Administration
      Eyal Aronoff, Kevin Loney and Noorali Sonawalla
      Oracle Press (Osborne)
      ISBN 0-07-882241-6

=head1 SUPPORT

Support questions and suggestions can be directed to Alan.Burlison@uk.sun.com

=head1 COPYRIGHT AND DISCLAIMER 

Copyright (c) 1999 Alan Burlison

You may distribute under the terms of either the GNU General Public License
or the Artistic License, as specified in the Perl README file.

This code is provided with no warranty of any kind, and is used entirely at
your own risk.

This code was written by the author as a private individual, and is in no way
endorsed or warrantied by Sun Microsystems.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             root/.cpan/build/DBD-Oracle-1.90-1/examples/oradump.pl                                              0000755 0001750 0001750 00000002307 14616324562 020536  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/env perl
#
# Dump the contents of an Oracle table into a set of insert statements.
# Quoting is controlled by the datatypes of each column. (new with DBI)
#
# Usage: oradump <database> <user> <pass> <table>
#
# Author:   Kevin Stock (original oraperl script)
# Date:     28th February 1992
#

use DBI;

use strict;

# Set trace level if '-# trace_level' option is given
DBI->trace( shift ) if 1 < @ARGV && $ARGV[0] =~ /^-#/ && shift;

die "syntax: $0 base user pass table\n" if 4 > @ARGV;
my ( $base, $user, $pass, $table ) = @ARGV;

# Connect to database
my $dbh = DBI->connect( "dbi:Oracle:$base", $user, $pass,
    { AutoCommit => 0, RaiseError => 1, PrintError => 0 } )
    or die $DBI::errstr;

my $sth = $dbh->prepare( "SELECT * FROM $table");
$sth->execute;
my @name = @{$sth->{NAME}};
my @type = @{$sth->{TYPE}};
my $lead = "INSERT INTO $table ( " . join( ', ', @name ) . " ) VALUES ( ";
my ( @data, $i );
$sth->bind_columns( {}, \( @data[0 .. $#name] ) );
while ( $sth->fetch ) {
    $i = 0;
    print $lead . join( ", ", map { $dbh->quote( $_, $type[$i++] ) } @data ) .
  # print $lead . join( ", ", map { $dbh->quote( $_ ) } @data ) . # for old DBI
        " );\n";
}

$sth->finish;
$dbh->disconnect;
                                                                                                                                                                                                                                                                                                                         root/.cpan/build/DBD-Oracle-1.90-1/examples/proc.pl                                                 0000755 0001750 0001750 00000010654 14616324562 020036  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/env perl
# Short examples of procedure calls from Oracle.pm
# These PL/SQL examples come from: Eric Bartley <bartley@cc.purdue.edu>.

use DBI;

use strict;

# Set trace level if '-# trace_level' option is given
DBI->trace( shift ) if 1 < @ARGV && $ARGV[0] =~ /^-#/ && shift;

die "syntax: $0 [-# trace] base user pass" if 3 > @ARGV;
my ( $inst, $user, $pass ) = @ARGV;

# So we don't have to check every DBI call we set RaiseError.
#     See the DBI docs if you're not familiar with RaiseError.
# AutoCommit is currently encouraged and may be required later.
my $dbh = DBI->connect( "dbi:Oracle:$inst", $user, $pass,
    { AutoCommit => 0, RaiseError => 1, PrintError => 0 } )
    or die "Unable to connect: $DBI::errstr";

# Create the package for the examples
$dbh->do( <<END_PLSQL_EXAMPLE );
CREATE OR REPLACE PACKAGE plsql_example IS
    PROCEDURE proc_np;
    PROCEDURE proc_in( err_code IN NUMBER );
    PROCEDURE proc_in_inout( test_num IN NUMBER, is_odd IN OUT NUMBER );
    FUNCTION func_np RETURN VARCHAR2;
END plsql_example;
END_PLSQL_EXAMPLE

$dbh->do( <<END_PLSQL_EXAMPLE );
CREATE OR REPLACE PACKAGE BODY plsql_example IS
    PROCEDURE proc_np IS
        whoami VARCHAR2(20) := NULL;
    BEGIN
        SELECT user INTO whoami FROM DUAL;
    END;

    PROCEDURE proc_in( err_code IN NUMBER ) IS
    BEGIN
        RAISE_APPLICATION_ERROR( err_code, 'This is a test.' );
    END;

    PROCEDURE proc_in_inout ( test_num IN NUMBER, is_odd IN OUT NUMBER ) IS
    BEGIN
        is_odd := MOD( test_num, 2 );
    END;

    FUNCTION func_np RETURN VARCHAR2 IS
        ret_val VARCHAR2(20);
    BEGIN
        SELECT user INTO ret_val FROM DUAL;
        RETURN ret_val;
    END;
END plsql_example;
END_PLSQL_EXAMPLE

my $sth;

print "\nExample 1\n";
# Calling a PLSQL procedure that takes no parameters. This shows you the
# basic's of what you need to execute a PLSQL procedure. Just wrap your
# procedure call in a BEGIN END; block just like you'd do in SQL*Plus.
#
# p.s. If you've used SQL*Plus's exec command all it does is wrap the
#      command in a BEGIN END; block for you.

$sth = $dbh->prepare( q{
BEGIN
    plsql_example.proc_np;
END;
} );
$sth->execute;


print "\nExample 2\n";
# Now we call a procedure that has 1 IN parameter. Here we use bind_param
# to bind out parameter to the prepared statement just like you might
# do for an INSERT, UPDATE, DELETE, or SELECT statement.
#
# I could have used positional placeholders (e.g. :1, :2, etc.) or
# ODBC style placeholders (e.g. ?), but I prefer Oracle's named
# placeholders (but few DBI drivers support them so they're not portable).
#
# proc_in() will RAISE_APPLICATION_ERROR which will cause the execute to 'fail'.
# Because we set RaiseError, the DBI will die() so we catch that with eval {}.

my $err_code = -20001;

$sth = $dbh->prepare( q{
BEGIN
    plsql_example.proc_in( :err_code );
END;
} );
$sth->bind_param( ":err_code", $err_code );
eval { $sth->execute; };
print 'After proc_in: $@ = ', "'$@', errstr = '$DBI::errstr'\n";


print "\nExample 3\n";
# Building on the last example, I've added 1 IN OUT parameter. We still
# use a placeholders in the call to prepare, the difference is that
# we now call bind_param_inout to bind the value to the place holder.
#
# Note that the third parameter to bind_param_inout is the maximum size
# of the variable. You normally make this slightly larger than necessary.
# But note that the perl variable will have that much memory assigned to
# it even if the actual value returned is shorter.

my $test_num = 5;
my $is_odd;

$sth = $dbh->prepare( q{
BEGIN
    plsql_example.proc_in_inout( :test_num, :is_odd );
END;
} );

# The value of $test_num is _copied_ here
$sth->bind_param( ":test_num", $test_num );
$sth->bind_param_inout( ":is_odd", \$is_odd, 1 );

# The execute will automatically update the value of $is_odd
$sth->execute;
print "$test_num is ", $is_odd ? "odd - ok" : "even - error!", "\n";


print "\nExample 4\n";
# What about the return value of a PL/SQL function? Well treat it the same
# as you would a call to a function from SQL*Plus. We add a placeholder
# for the return value and bind it with a call to bind_param_inout so
# we can access its value after execute.

my $whoami = "";

$sth = $dbh->prepare( q{
BEGIN
    :whoami := plsql_example.func_np;
END;
} );
$sth->bind_param_inout( ":whoami", \$whoami, 30 );
$sth->execute;
print "Your database user name is $whoami\n";

# Get rid of the example package
$dbh->do( 'DROP PACKAGE plsql_example' );
$dbh->disconnect;
                                                                                    root/.cpan/build/DBD-Oracle-1.90-1/examples/read_long_via_blob_read.pl                              0000644 0001750 0001750 00000001325 14616324562 023645  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/env perl

use strict;
use warnings;

use DBI;

my $dbh = DBI->connect( 'dbi:Oracle:mydb', 'username', 'password' );

$dbh->{RaiseError} = 1;
$dbh->{LongTruncOk} = 1; # truncation on initial fetch is ok

my $sth = $dbh->prepare("SELECT key, long_field FROM table_name");
$sth->execute;

while ( my ($key) = $sth->fetchrow_array) {
    my $offset = 0;
    my $lump = 4096; # use benchmarks to get best value for you
    my @frags;
    while (1) {
        my $frag = $sth->blob_read(1, $offset, $lump);
        last unless defined $frag;
        my $len = length $frag;
        last unless $len;
        push @frags, $frag;
        $offset += $len;
    }
    my $blob = join "", @frags;
    print "$key: $blob\n";
}

                                                                                                                                                                                                                                                                                                           root/.cpan/build/DBD-Oracle-1.90-1/examples/sql                                                     0000755 0001750 0001750 00000016247 14616324562 017264  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/perl -w
'di';
'ig00';
# See usage() for syntax

use Getopt::Long;

use DBI;

use strict;

# Default values for options
my ( $trace, $inst, $cache, $delim, $format, $headers, $page_len, $null_str ) =
   ( 0, $ENV{TWO_TASK} || $ENV{ORACLE_SID} || '', '', "\t", 0, 0, 60, '' );

# Syntax description
sub usage {
    my ( $sOpt, $sVal, @sMsg ) = @_;

    my $sHelpText = <<END_HELP_END;
Execute a SQL statement
syntax: $0 [options] name pass [stmt]
Options:
   -h          Write this help to STDOUT
   -t trace    trace control string
   -b base     database to use (default $inst)
   -c cache    SQL fetch cache size in rows
   -d delim    specifies the field delimiter (default TAB)
   -F          format output, similar to sqlplus
   -H          add headers, not allowed if formatting
   -l page_len lines per page, only used by -f (default $page_len)
   -n string   replace NULL fields by string
Arguments:
   name Oracle username
   pass Password
   stmt Oracle statement to be executed
        it is read from STDIN if not given on command line
END_HELP_END
# Balance quotes in here document # ' # "

    my $nRet = 'help' eq $sOpt ? 0 : 0 + $sVal;
    my $fh   = $nRet ? *STDERR : *STDOUT;
    foreach ( @sMsg, $sHelpText ) { s/\s+$//; print $fh "$_\n"; }
    exit $nRet;
}

# Get options and arguments
Getopt::Long::config( qw( no_ignore_case no_auto_abbrev require_order ) );
GetOptions(
    'help|h'    => \&usage,
    'trace|t=i' => \$trace,
    'base|b=s'  => \$inst,
    'cache|c=i' => \$cache,
    'delim|d=s' => \$delim,
    'Format!'   => \$format,  'F!' => \$format,
    'Headers!'  => \$headers, 'H!' => \$headers,
    'len|len=i' => \$page_len,
    'null|n=s'  => \$null_str,
 ) or usage( 'die', 1 );
usage( 'die', 1,  "Only one of -F and -H may be specified\n" )
    if $format && $headers;

usage( 'die', 1, 'Username and password are required' ) if 2 > @ARGV;
my ( $user, $pass, @stmt ) = @ARGV;
if ( ! @stmt ) {
    print "Enter the statement to execute (^D to end):\n";
    @stmt = <STDIN>;
}
usage( 'die', 1, "A statement is required" ) if ! @stmt;

$\ = "\n";      # each record terminated with newline
$, = $delim;    # set column delimiter
$= = $page_len; # set page length

# Set trace level
DBI->trace( $trace );

# Connect to database
my $dbh = DBI->connect( "dbi:Oracle:$inst", $user, $pass,
    { AutoCommit => 0, RaiseError => 1, PrintError => 0 } )
    or die $DBI::errstr;
$dbh->{RowCacheSize} = $cache if $cache; # set fetch cache

# Start statement
my $sth = $dbh->prepare( join "\n", @stmt );
$sth->execute;
my $nfields = $sth->{NUM_OF_FIELDS};

# print out any information which comes back
if ( $nfields ) {
    # the statement has output columns
    my ( @col, $col );
    my @name = @{$sth->{NAME}};
    if ( $format ) {
        # build format statements for the data
        my @size = @{$sth->{PRECISION}};

        # First, the header - a list of field names, formatted
        #    in columns of the appropriate width
        my $fmt  = join '|', map { "%-${_}.${_}s" } @size;
        $fmt     = sprintf $fmt, @name;
        $format = "format STDOUT_TOP =\n" . $fmt . "\n";

        # Then underlines for the field names
        $fmt    =~ tr/|/-/c;
        $fmt    =~ tr/|/+/;
        $format .= $fmt . "\n.\n";

        # Then for the data format, a @<<... field per column
        $fmt =~ tr/-+/<|/;
        $fmt =~ s/(^|\|)</$1@/g;
        $format .= "format STDOUT =\n" . $fmt . "\n";

        # Finally the variable associated with each column
        # Why doesn't Perl let us specify an array here?
        $format .= join ', ', map { "\$col[$_]" } 0 .. $#name;
        $format .= "\n.\n";

        eval($format);
    }
    elsif ( $headers ) {
        # Simple headers with underlines
        print map { s/\s+$//; $_ } @name;
        print map { tr//-/c;  $_ } @name;
    }

    # Associate @col with output columns and fetch the rows
    $sth->bind_columns( {}, \( @col[0 .. $#name] ) );
    while ( $sth->fetch ) {
        foreach $col ( @col ) { $col = $null_str if ! defined $col; }
        $format ? write : print @col;
    }
}

# finish off neatly
$sth->finish;
$dbh->disconnect;

__END__     # no need for perl even to scan the rest

##############################################################################

    # These next few lines are legal in both Perl and nroff.

.00;            # finish .ig

'di         \" finish diversion--previous line must be blank
.nr nl 0-1      \" fake up transition to first page again
.nr % 0         \" start at page 1
';<<'.ex'; ############## From here on it's a standard manual page ############
.TH SQL L "5th July 1999"
.ad
.nh
.SH NAME
sql \- execute an Oracle SQL statement from the command line
.SH SYNOPSIS
\fBsql\fP
[\fB\-b\fP\fIbase\fP]
[\fB\-c\fP\fIcache\fP]
[\fB\-d\fP\fIdelim\fP]
[\fB\-F\fP|\fB\-H\fP]
[\fB\-l\fP\fIpage_len\fP]
[\fB\-n\fP\fIstring\fP]
\fIname\fP \fIpassword\fP
\fIstatement\fP
.SH DESCRIPTION
.I Sql
connects to an Oracle database
using the \fIname\fP and \fIpassword\fP supplied
and executes the given SQL \fIstatement\fP
displaying the result
on its standard output.

The \fB\-b\fP\fIbase\fP flag may be supplied to specify the database to be used.
If it is not given, the database specified by the environment variable
\fBTWO_TASK\fP or \fBORACLE_SID\fP is used.

The \fB\-c\fP\fIcache\fP flag may be supplied to set the size of fetch cache
to be used. If it is not given, the default is used.

If the \fB\-n\fP\fIstring\fP flag is supplied,
\fBNULL\fP fields (in the \fIOracle\fP sense)
will replaced in the output by \fIstring\fP.
Normally, they are left blank.

The \fB\-F\fP and \fB\-H\fP flags may be used to modify the form of the output.
Without either flag, no field headers are printed
and fields are not padded.
With the \fB\-H\fP flag,
field headers are added to the top of the output,
but the format is otherwise unchanged.
With the \fB\-F\fP flag,
the output is formatted in a tabular form similar to that used by \fIsqlplus\fP,
except that all fields are left\-justified, regardless of their data type.
Column headers are printed at the top of each page;
a page is assumed to be 60 lines long,
but this may be overridden with the \fB\-l\fP\fIpage_len\fP flag.

Without the \fB\-F\fP flag, fields are separated with tabs;
this may be changed to any desired string (\fIdelim\fP)
using the \fB\-d\fP flag.
.SH ENVIRONMENT
The environment variable \fBTWO_TASK\fP or \fBORACLE_SID\fP
determines the Oracle database to be used
if the \fB\-b\fP\fIbase\fP flag is not supplied.
.SH DIAGNOSTICS
.in +5
.ti -5
\fBonly one of \-F and \-H may be specified\fP
.br
the \fB\-F\fP and \fB\-H\fP options are mutually exclusive,
but both were specified

.in -5
The only other diagnostics generated by \fIsql\fP are usage messages,
which should be self\-explanatory.
However, you may also encounter
error messages from DBI (unlikely) or from Oracle (more common).
See the \fIOracle Error Messages and Codes Manual\fP for details.
.SH NOTES
This program is only intended for use from the command line.
If you use it within a shell script
then you should consider rewriting your script in DBI
to use Perl's text manipulation and formatting commands.
.SH "SEE ALSO"
\fISQL Language Reference Manual\fP
.br
perl(1),
oraperl(1)
.SH AUTHOR
Kevin Stock,
.if t .ft C
<kstock@encore.com>
.if t .ft P
.ex
                                                                                                                                                                                                                                                                                                                                                         root/.cpan/build/DBD-Oracle-1.90-1/examples/tabinfo.pl                                              0000755 0001750 0001750 00000003457 14616324562 020520  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/env perl
#
# tabinfo
#
#  Usage:   tabinfo base user password table
#
# Displays the structure of the specified table.
# Note that the field names are restricted to the length of the field.
# This is mainly to show the use of &ora_lengths, &ora_titles and &ora_types.
#
use DBI;

use strict;

# Set trace level if '-# trace_level' option is given
DBI->trace( shift ) if 1 < @ARGV && $ARGV[0] =~ /^-#/ && shift;

# read the compulsory arguments
die "syntax: $0 base user password table ...\n" if 4 > @ARGV;
my ( $base, $user, $pass, @table ) = @ARGV;

my ( $table, @name, @length, @type, %type_name, $i );
format STDOUT_TOP =
Structure of @<<<<<<<<<<<<<<<<<<<<<<<
$table

Field name                                    | Length | Type | Type Name
----------------------------------------------+--------+------+-----------------
.

format STDOUT =
@<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< | @>>>>> | @>>> | @<<<<<<<<<<<<<<<
$name[$i], $length[$i], $type[$i], $type_name{$type[$i]}
.

# Connect to database
my $dbh = DBI->connect( "dbi:Oracle:$base", $user, $pass,
   { AutoCommit => 0, RaiseError => 1, PrintError => 0 } )
   or die $DBI::errstr;

# Associate type names to types
{
    my $type_info_all = $dbh->type_info_all;
    my $iname = $type_info_all->[0]{TYPE_NAME};
    my $itype = $type_info_all->[0]{DATA_TYPE};
    my $rtype;
    shift @$type_info_all;
    foreach $rtype ( @$type_info_all ) {
        $type_name{$$rtype[$itype]} = $$rtype[$iname]
            if ! exists $type_name{$$rtype[$itype]};
    }
}

my $sth;
foreach $table ( @table ) {
    $sth = $dbh->prepare( "SELECT * FROM $table WHERE 1 = 2");
    @name   = @{$sth->{NAME}};
    @length = @{$sth->{PRECISION}};
    @type   = @{$sth->{TYPE}};

    foreach $i ( 0 .. $#name ) {
        write;
    }
    $- = 0;
    $sth->finish;
}

$dbh->disconnect;
                                                                                                                                                                                                                 root/.cpan/build/DBD-Oracle-1.90-1/hints/                                                           0000755 0001750 0001750 00000000000 14723047257 016036  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/.cpan/build/DBD-Oracle-1.90-1/hints/dgux.pl                                                    0000644 0001750 0001750 00000000502 14616324562 017335  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        my $archname = $Config::Config{archname} || die;
$att{LIBS}      ||= [];
$att{LIBS}->[0] ||= '';

push @libs, '-lc', '-lm';

warn "$^O LIBS attribute defaulted to '$att{LIBS}->[0]' for '$archname'";
$att{LIBS}->[0] .= " ".join(" ", @libs);	# append libs
warn "$^O LIBS attribute updated   to '$att{LIBS}->[0]'";


__END__
                                                                                                                                                                                              root/.cpan/build/DBD-Oracle-1.90-1/hints/macos_bundle.syms                                          0000644 0001750 0001750 00000000306 14616324562 021403  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        _main
_kpuach
_kpuasav
_kpucer
_kpudbcx
