instead.

=for apidoc Am|void|SvUTF8_on|SV *sv
Turn on the UTF-8 status of an SV (the data is not changed, just the flag).
Do not use frivolously.

=for apidoc Am|void|SvUTF8_off|SV *sv
Unsets the UTF-8 status of an SV (the data is not changed, just the flag).
Do not use frivolously.

=for apidoc Am|void|SvPOK_only_UTF8|SV* sv
Tells an SV that it is a string and disables all other C<OK> bits,
and leaves the UTF-8 status as it was.

=cut
 */

/* Ensure the return value of this macro does not clash with the GV_ADD* flags
in gv.h: */
#define SvUTF8(sv)		(SvFLAGS(sv) & SVf_UTF8)
#define SvUTF8_on(sv)		(SvFLAGS(sv) |= (SVf_UTF8))
#define SvUTF8_off(sv)		(SvFLAGS(sv) &= ~(SVf_UTF8))

#define SvPOK(sv)		(SvFLAGS(sv) & SVf_POK)
#define SvPOK_on(sv)		(assert_not_ROK(sv) assert_not_glob(sv)	\
                                 SvFLAGS(sv) |= (SVf_POK|SVp_POK))
#define SvPOK_off(sv)		(SvFLAGS(sv) &= ~(SVf_POK|SVp_POK))
#define SvPOK_only(sv)		(assert_not_ROK(sv) assert_not_glob(sv)	\
                                 SvFLAGS(sv) &= ~(SVf_OK|		\
                                                  SVf_IVisUV|SVf_UTF8),	\
                                    SvFLAGS(sv) |= (SVf_POK|SVp_POK))
#define SvPOK_only_UTF8(sv)	(assert_not_ROK(sv) assert_not_glob(sv)	\
                                 SvFLAGS(sv) &= ~(SVf_OK|		\
                                                  SVf_IVisUV),		\
                                    SvFLAGS(sv) |= (SVf_POK|SVp_POK))

#define SvVOK(sv)		(SvMAGICAL(sv)				\
                                 && mg_find(sv,PERL_MAGIC_vstring))
/*
=for apidoc Am|MAGIC*|SvVSTRING_mg|SV * sv

Returns the vstring magic, or NULL if none

=cut
*/
#define SvVSTRING_mg(sv)	(SvMAGICAL(sv) \
                                 ? mg_find(sv,PERL_MAGIC_vstring) : NULL)

#define SvOOK(sv)		(SvFLAGS(sv) & SVf_OOK)
#define SvOOK_on(sv)		(SvFLAGS(sv) |= SVf_OOK)


/*
=for apidoc Am|void|SvOOK_off|SV * sv

Remove any string offset.

=cut
*/

#define SvOOK_off(sv)		((void)(SvOOK(sv) && (sv_backoff(sv),0)))

#define SvFAKE(sv)		(SvFLAGS(sv) & SVf_FAKE)
#define SvFAKE_on(sv)		(SvFLAGS(sv) |= SVf_FAKE)
#define SvFAKE_off(sv)		(SvFLAGS(sv) &= ~SVf_FAKE)

#define SvROK(sv)		(SvFLAGS(sv) & SVf_ROK)
#define SvROK_on(sv)		(SvFLAGS(sv) |= SVf_ROK)
#define SvROK_off(sv)		(SvFLAGS(sv) &= ~(SVf_ROK))

#define SvMAGICAL(sv)		(SvFLAGS(sv) & (SVs_GMG|SVs_SMG|SVs_RMG))
#define SvMAGICAL_on(sv)	(SvFLAGS(sv) |= (SVs_GMG|SVs_SMG|SVs_RMG))
#define SvMAGICAL_off(sv)	(SvFLAGS(sv) &= ~(SVs_GMG|SVs_SMG|SVs_RMG))

#define SvGMAGICAL(sv)		(SvFLAGS(sv) & SVs_GMG)
#define SvGMAGICAL_on(sv)	(SvFLAGS(sv) |= SVs_GMG)
#define SvGMAGICAL_off(sv)	(SvFLAGS(sv) &= ~SVs_GMG)

#define SvSMAGICAL(sv)		(SvFLAGS(sv) & SVs_SMG)
#define SvSMAGICAL_on(sv)	(SvFLAGS(sv) |= SVs_SMG)
#define SvSMAGICAL_off(sv)	(SvFLAGS(sv) &= ~SVs_SMG)

#define SvRMAGICAL(sv)		(SvFLAGS(sv) & SVs_RMG)
#define SvRMAGICAL_on(sv)	(SvFLAGS(sv) |= SVs_RMG)
#define SvRMAGICAL_off(sv)	(SvFLAGS(sv) &= ~SVs_RMG)

/*
=for apidoc Am|bool|SvAMAGIC|SV * sv

Returns a boolean as to whether C<sv> has overloading (active magic) enabled or
not.

=cut
*/

#define SvAMAGIC(sv)		(SvROK(sv) && SvOBJECT(SvRV(sv)) &&	\
                                 HvAMAGIC(SvSTASH(SvRV(sv))))

/* To be used on the stashes themselves: */
#define HvAMAGIC(hv)		(SvFLAGS(hv) & SVf_AMAGIC)
#define HvAMAGIC_on(hv)		(SvFLAGS(hv) |= SVf_AMAGIC)
#define HvAMAGIC_off(hv)	(SvFLAGS(hv) &=~ SVf_AMAGIC)


/* "nog" means "doesn't have get magic" */
#define SvPOK_nog(sv)		((SvFLAGS(sv) & (SVf_POK|SVs_GMG)) == SVf_POK)
#define SvIOK_nog(sv)		((SvFLAGS(sv) & (SVf_IOK|SVs_GMG)) == SVf_IOK)
#define SvUOK_nog(sv)		((SvFLAGS(sv) & (SVf_IOK|SVf_IVisUV|SVs_GMG)) == (SVf_IOK|SVf_IVisUV))
#define SvNOK_nog(sv)		((SvFLAGS(sv) & (SVf_NOK|SVs_GMG)) == SVf_NOK)
#define SvNIOK_nog(sv)		(SvNIOK(sv) && !(SvFLAGS(sv) & SVs_GMG))

#define SvPOK_nogthink(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_THINKFIRST|SVs_GMG)) == SVf_POK)
#define SvIOK_nogthink(sv)	((SvFLAGS(sv) & (SVf_IOK|SVf_THINKFIRST|SVs_GMG)) == SVf_IOK)
#define SvUOK_nogthink(sv)	((SvFLAGS(sv) & (SVf_IOK|SVf_IVisUV|SVf_THINKFIRST|SVs_GMG)) == (SVf_IOK|SVf_IVisUV))
#define SvNOK_nogthink(sv)	((SvFLAGS(sv) & (SVf_NOK|SVf_THINKFIRST|SVs_GMG)) == SVf_NOK)
#define SvNIOK_nogthink(sv)	(SvNIOK(sv) && !(SvFLAGS(sv) & (SVf_THINKFIRST|SVs_GMG)))

#define SvPOK_utf8_nog(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVs_GMG)) == (SVf_POK|SVf_UTF8))
#define SvPOK_utf8_nogthink(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_THINKFIRST|SVs_GMG)) == (SVf_POK|SVf_UTF8))

#define SvPOK_byte_nog(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVs_GMG)) == SVf_POK)
#define SvPOK_byte_nogthink(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_THINKFIRST|SVs_GMG)) == SVf_POK)

#define SvPOK_pure_nogthink(sv) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_IOK|SVf_NOK|SVf_ROK|SVpgv_GP|SVf_THINKFIRST|SVs_GMG)) == SVf_POK)
#define SvPOK_utf8_pure_nogthink(sv) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_IOK|SVf_NOK|SVf_ROK|SVpgv_GP|SVf_THINKFIRST|SVs_GMG)) == (SVf_POK|SVf_UTF8))
#define SvPOK_byte_pure_nogthink(sv) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_IOK|SVf_NOK|SVf_ROK|SVpgv_GP|SVf_THINKFIRST|SVs_GMG)) == SVf_POK)

/*
=for apidoc Am|bool|SvIsBOOL|SV* sv

Returns true if the SV is one of the special boolean constants (PL_sv_yes or
PL_sv_no), or is a regular SV whose last assignment stored a copy of one.

=cut
*/

#define SvIsBOOL(sv)            Perl_sv_isbool(aTHX_ sv)

/*
=for apidoc Am|U32|SvGAMAGIC|SV* sv

Returns true if the SV has get magic or
overloading.  If either is true then
the scalar is active data, and has the potential to return a new value every
time it is accessed.  Hence you must be careful to
only read it once per user logical operation and work
with that returned value.  If neither is true then
the scalar's value cannot change unless written to.

=cut
*/

#define SvGAMAGIC(sv)           (SvGMAGICAL(sv) || SvAMAGIC(sv))

#define Gv_AMG(stash) \
        (HvNAME(stash) && Gv_AMupdate(stash,FALSE) \
            ? 1					    \
            : (HvAMAGIC_off(stash), 0))

#define SvWEAKREF(sv)		((SvFLAGS(sv) & (SVf_ROK|SVprv_WEAKREF)) \
                                  == (SVf_ROK|SVprv_WEAKREF))
#define SvWEAKREF_on(sv)	(SvFLAGS(sv) |=  (SVf_ROK|SVprv_WEAKREF))
#define SvWEAKREF_off(sv)	(SvFLAGS(sv) &= ~(SVf_ROK|SVprv_WEAKREF))

#define SvPCS_IMPORTED(sv)	((SvFLAGS(sv) & (SVf_ROK|SVprv_PCS_IMPORTED)) \
                                 == (SVf_ROK|SVprv_PCS_IMPORTED))
#define SvPCS_IMPORTED_on(sv)	(SvFLAGS(sv) |=  (SVf_ROK|SVprv_PCS_IMPORTED))
#define SvPCS_IMPORTED_off(sv)	(SvFLAGS(sv) &= ~(SVf_ROK|SVprv_PCS_IMPORTED))

/*
=for apidoc m|U32|SvTHINKFIRST|SV *sv

A quick flag check to see whether an C<sv> should be passed to C<sv_force_normal>
to be "downgraded" before C<SvIVX> or C<SvPVX> can be modified directly.

For example, if your scalar is a reference and you want to modify the C<SvIVX>
slot, you can't just do C<SvROK_off>, as that will leak the referent.

This is used internally by various sv-modifying functions, such as
C<sv_setsv>, C<sv_setiv> and C<sv_pvn_force>.

One case that this does not handle is a gv without SvFAKE set.  After

    if (SvTHINKFIRST(gv)) sv_force_normal(gv);

it will still be a gv.

C<SvTHINKFIRST> sometimes produces false positives.  In those cases
C<sv_force_normal> does nothing.

=cut
*/

#define SvTHINKFIRST(sv)	(SvFLAGS(sv) & SVf_THINKFIRST)

#define SVs_PADMY		0
#define SvPADMY(sv)		!(SvFLAGS(sv) & SVs_PADTMP)
#ifndef PERL_CORE
# define SvPADMY_on(sv)		SvPADTMP_off(sv)
#endif

#define SvPADTMP(sv)		(SvFLAGS(sv) & (SVs_PADTMP))
#define SvPADSTALE(sv)		(SvFLAGS(sv) & (SVs_PADSTALE))

#define SvPADTMP_on(sv)		(SvFLAGS(sv) |= SVs_PADTMP)
#define SvPADTMP_off(sv)	(SvFLAGS(sv) &= ~SVs_PADTMP)
#define SvPADSTALE_on(sv)	Perl_SvPADSTALE_on(MUTABLE_SV(sv))
#define SvPADSTALE_off(sv)	Perl_SvPADSTALE_off(MUTABLE_SV(sv))

#define SvTEMP(sv)		(SvFLAGS(sv) & SVs_TEMP)
#define SvTEMP_on(sv)		(SvFLAGS(sv) |= SVs_TEMP)
#define SvTEMP_off(sv)		(SvFLAGS(sv) &= ~SVs_TEMP)

#define SvOBJECT(sv)		(SvFLAGS(sv) & SVs_OBJECT)
#define SvOBJECT_on(sv)		(SvFLAGS(sv) |= SVs_OBJECT)
#define SvOBJECT_off(sv)	(SvFLAGS(sv) &= ~SVs_OBJECT)

/*
=for apidoc Am|U32|SvREADONLY|SV* sv
Returns true if the argument is readonly, otherwise returns false.
Exposed to perl code via Internals::SvREADONLY().

=for apidoc Am|U32|SvREADONLY_on|SV* sv
Mark an object as readonly. Exactly what this means depends on the object
type. Exposed to perl code via Internals::SvREADONLY().

=for apidoc Am|U32|SvREADONLY_off|SV* sv
Mark an object as not-readonly. Exactly what this mean depends on the
object type. Exposed to perl code via Internals::SvREADONLY().

=cut
*/

#define SvREADONLY(sv)		(SvFLAGS(sv) & (SVf_READONLY|SVf_PROTECT))
#ifdef PERL_CORE
# define SvREADONLY_on(sv)	(SvFLAGS(sv) |= (SVf_READONLY|SVf_PROTECT))
# define SvREADONLY_off(sv)	(SvFLAGS(sv) &=~(SVf_READONLY|SVf_PROTECT))
#else
# define SvREADONLY_on(sv)	(SvFLAGS(sv) |= SVf_READONLY)
# define SvREADONLY_off(sv)	(SvFLAGS(sv) &= ~SVf_READONLY)
#endif

#define SvSCREAM(sv) ((SvFLAGS(sv) & (SVp_SCREAM|SVp_POK)) == (SVp_SCREAM|SVp_POK))
#define SvSCREAM_on(sv)		(SvFLAGS(sv) |= SVp_SCREAM)
#define SvSCREAM_off(sv)	(SvFLAGS(sv) &= ~SVp_SCREAM)

#ifndef PERL_CORE
#  define SvCOMPILED(sv)	0
#  define SvCOMPILED_on(sv)
#  define SvCOMPILED_off(sv)
#endif


#if defined (DEBUGGING) && defined(PERL_USE_GCC_BRACE_GROUPS)
#  define SvTAIL(sv)	({ const SV *const _svtail = (const SV *)(sv);	\
                            assert(SvTYPE(_svtail) != SVt_PVAV);	\
                            assert(SvTYPE(_svtail) != SVt_PVHV);	\
                            assert(!(SvFLAGS(_svtail) & (SVf_NOK|SVp_NOK))); \
                            assert(SvVALID(_svtail));                        \
                            ((XPVNV*)SvANY(_svtail))->xnv_u.xnv_bm_tail;     \
                        })
#else
#  define SvTAIL(_svtail)  (((XPVNV*)SvANY(_svtail))->xnv_u.xnv_bm_tail)
#endif

/* Does the SV have a Boyer-Moore table attached as magic?
 * 'VALID' is a poor name, but is kept for historical reasons.  */
#define SvVALID(_svvalid) (                                  \
               SvPOKp(_svvalid)                              \
            && SvSMAGICAL(_svvalid)                          \
            && SvMAGIC(_svvalid)                             \
            && (SvMAGIC(_svvalid)->mg_type == PERL_MAGIC_bm  \
                || mg_find(_svvalid, PERL_MAGIC_bm))         \
        )

#define SvRVx(sv) SvRV(sv)

#ifdef PERL_DEBUG_COW
/* Need -0.0 for SvNVX to preserve IEEE FP "negative zero" because
   +0.0 + -0.0 => +0.0 but -0.0 + -0.0 => -0.0 */
#  define SvIVX(sv) (0 + ((XPVIV*) SvANY(sv))->xiv_iv)
#  define SvUVX(sv) (0 + ((XPVUV*) SvANY(sv))->xuv_uv)
#  define SvNVX(sv) (-0.0 + ((XPVNV*) SvANY(sv))->xnv_u.xnv_nv)
#  define SvRV(sv) (0 + (sv)->sv_u.svu_rv)
#  define SvRV_const(sv) (0 + (sv)->sv_u.svu_rv)
/* Don't test the core XS code yet.  */
#  if defined (PERL_CORE) && PERL_DEBUG_COW > 1
#    define SvPVX(sv) (0 + (assert_(!SvREADONLY(sv)) (sv)->sv_u.svu_pv))
#  else
#  define SvPVX(sv) SvPVX_mutable(sv)
#  endif
#  define SvCUR(sv) (0 + ((XPV*) SvANY(sv))->xpv_cur)
#  define SvLEN(sv) (0 + ((XPV*) SvANY(sv))->xpv_len)
#  define SvEND(sv) ((sv)->sv_u.svu_pv + ((XPV*)SvANY(sv))->xpv_cur)

#  define SvMAGIC(sv)	(0 + *(assert_(SvTYPE(sv) >= SVt_PVMG) &((XPVMG*)  SvANY(sv))->xmg_u.xmg_magic))
#  define SvSTASH(sv)	(0 + *(assert_(SvTYPE(sv) >= SVt_PVMG) &((XPVMG*)  SvANY(sv))->xmg_stash))
#else   /* Below is not PERL_DEBUG_COW */
# ifdef PERL_CORE
#  define SvLEN(sv) (0 + ((XPV*) SvANY(sv))->xpv_len)
# else
#  define SvLEN(sv) ((XPV*) SvANY(sv))->xpv_len
# endif
#  define SvEND(sv) ((sv)->sv_u.svu_pv + ((XPV*)SvANY(sv))->xpv_cur)

#  if defined (DEBUGGING) && defined(PERL_USE_GCC_BRACE_GROUPS)
/* These get expanded inside other macros that already use a variable _sv  */
#    define SvPVX(sv)							\
        (*({ SV *const _svpvx = MUTABLE_SV(sv);				\
            assert(PL_valid_types_PVX[SvTYPE(_svpvx) & SVt_MASK]);	\
            assert(!isGV_with_GP(_svpvx));				\
            assert(!(SvTYPE(_svpvx) == SVt_PVIO				\
                     && !(IoFLAGS(_svpvx) & IOf_FAKE_DIRP)));		\
            &((_svpvx)->sv_u.svu_pv);					\
         }))
#   ifdef PERL_CORE
#    define SvCUR(sv)							\
        ({ const SV *const _svcur = (const SV *)(sv);			\
            assert(PL_valid_types_PVX[SvTYPE(_svcur) & SVt_MASK]);	\
            assert(!isGV_with_GP(_svcur));				\
            assert(!(SvTYPE(_svcur) == SVt_PVIO				\
                     && !(IoFLAGS(_svcur) & IOf_FAKE_DIRP)));		\
            (((XPV*) MUTABLE_PTR(SvANY(_svcur)))->xpv_cur);		\
         })
#   else
#    define SvCUR(sv)							\
        (*({ const SV *const _svcur = (const SV *)(sv);			\
            assert(PL_valid_types_PVX[SvTYPE(_svcur) & SVt_MASK]);	\
            assert(!isGV_with_GP(_svcur));				\
            assert(!(SvTYPE(_svcur) == SVt_PVIO				\
                     && !(IoFLAGS(_svcur) & IOf_FAKE_DIRP)));		\
            &(((XPV*) MUTABLE_PTR(SvANY(_svcur)))->xpv_cur);		\
         }))
#   endif
#    define SvIVX(sv)							\
        (*({ const SV *const _svivx = (const SV *)(sv);			\
            assert(PL_valid_types_IVX[SvTYPE(_svivx) & SVt_MASK]);	\
            assert(!isGV_with_GP(_svivx));				\
            &(((XPVIV*) MUTABLE_PTR(SvANY(_svivx)))->xiv_iv);		\
         }))
#    define SvUVX(sv)							\
        (*({ const SV *const _svuvx = (const SV *)(sv);			\
            assert(PL_valid_types_IVX[SvTYPE(_svuvx) & SVt_MASK]);	\
            assert(!isGV_with_GP(_svuvx));				\
            &(((XPVUV*) MUTABLE_PTR(SvANY(_svuvx)))->xuv_uv);		\
         }))
#    define SvNVX(sv)							\
        (*({ const SV *const _svnvx = (const SV *)(sv);			\
            assert(PL_valid_types_NVX[SvTYPE(_svnvx) & SVt_MASK]);	\
            assert(!isGV_with_GP(_svnvx));				\
            &(((XPVNV*) MUTABLE_PTR(SvANY(_svnvx)))->xnv_u.xnv_nv);	\
         }))
#    define SvRV(sv)							\
        (*({ SV *const _svrv = MUTABLE_SV(sv);				\
            assert(PL_valid_types_RV[SvTYPE(_svrv) & SVt_MASK]);	\
            assert(!isGV_with_GP(_svrv));				\
            assert(!(SvTYPE(_svrv) == SVt_PVIO				\
                     && !(IoFLAGS(_svrv) & IOf_FAKE_DIRP)));		\
            &((_svrv)->sv_u.svu_rv);					\
         }))
#    define SvRV_const(sv)						\
        ({ const SV *const _svrv = (const SV *)(sv);			\
            assert(PL_valid_types_RV[SvTYPE(_svrv) & SVt_MASK]);	\
            assert(!isGV_with_GP(_svrv));				\
            assert(!(SvTYPE(_svrv) == SVt_PVIO				\
                     && !(IoFLAGS(_svrv) & IOf_FAKE_DIRP)));		\
            (_svrv)->sv_u.svu_rv;					\
         })
#    define SvMAGIC(sv)							\
        (*({ const SV *const _svmagic = (const SV *)(sv);		\
            assert(SvTYPE(_svmagic) >= SVt_PVMG);			\
            &(((XPVMG*) MUTABLE_PTR(SvANY(_svmagic)))->xmg_u.xmg_magic); \
          }))
#    define SvSTASH(sv)							\
        (*({ const SV *const _svstash = (const SV *)(sv);		\
            assert(SvTYPE(_svstash) >= SVt_PVMG);			\
            &(((XPVMG*) MUTABLE_PTR(SvANY(_svstash)))->xmg_stash);	\
          }))
#  else     /* Below is not DEBUGGING or can't use brace groups */
#    define SvPVX(sv) ((sv)->sv_u.svu_pv)
#    define SvCUR(sv) ((XPV*) SvANY(sv))->xpv_cur
#    define SvIVX(sv) ((XPVIV*) SvANY(sv))->xiv_iv
#    define SvUVX(sv) ((XPVUV*) SvANY(sv))->xuv_uv
#    define SvNVX(sv) ((XPVNV*) SvANY(sv))->xnv_u.xnv_nv
#    define SvRV(sv) ((sv)->sv_u.svu_rv)
#    define SvRV_const(sv) (0 + (sv)->sv_u.svu_rv)
#    define SvMAGIC(sv)	((XPVMG*)  SvANY(sv))->xmg_u.xmg_magic
#    define SvSTASH(sv)	((XPVMG*)  SvANY(sv))->xmg_stash
#  endif
#endif

#ifndef PERL_POISON
/* Given that these two are new, there can't be any existing code using them
 *  as LVALUEs, so prevent that from happening  */
#  define SvPVX_mutable(sv)	(0 + (sv)->sv_u.svu_pv)
#  define SvPVX_const(sv)	((const char*)(0 + (sv)->sv_u.svu_pv))
#else
/* Except for the poison code, which uses & to scribble over the pointer after
   free() is called.  */
#  define SvPVX_mutable(sv)	((sv)->sv_u.svu_pv)
#  define SvPVX_const(sv)	((const char*)((sv)->sv_u.svu_pv))
#endif

#define SvIVXx(sv) SvIVX(sv)
#define SvUVXx(sv) SvUVX(sv)
#define SvNVXx(sv) SvNVX(sv)
#define SvPVXx(sv) SvPVX(sv)
#define SvLENx(sv) SvLEN(sv)
#define SvENDx(sv) ((PL_Sv = (sv)), SvEND(PL_Sv))


/* Ask a scalar nicely to try to become an IV, if possible.
   Not guaranteed to stay returning void */
/* Macro won't actually call sv_2iv if already IOK */
#define SvIV_please(sv) \
        STMT_START {if (!SvIOKp(sv) && (SvFLAGS(sv) & (SVf_NOK|SVf_POK))) \
                (void) SvIV(sv); } STMT_END
#define SvIV_please_nomg(sv) \
        (!(SvFLAGS(sv) & (SVf_IOK|SVp_IOK)) && (SvFLAGS(sv) & (SVf_NOK|SVf_POK)) \
            ? (sv_2iv_flags(sv, 0), SvIOK(sv))	  \
            : SvIOK(sv))
#define SvIV_set(sv, val) \
        STMT_START { \
                assert(PL_valid_types_IV_set[SvTYPE(sv) & SVt_MASK]);	\
                assert(!isGV_with_GP(sv));		\
                (((XPVIV*)  SvANY(sv))->xiv_iv = (val)); } STMT_END
#define SvNV_set(sv, val) \
        STMT_START { \
                assert(PL_valid_types_NV_set[SvTYPE(sv) & SVt_MASK]);	\
                assert(!isGV_with_GP(sv));		\
                (((XPVNV*)SvANY(sv))->xnv_u.xnv_nv = (val)); } STMT_END
#define SvPV_set(sv, val) \
        STMT_START { \
                assert(PL_valid_types_PVX[SvTYPE(sv) & SVt_MASK]);	\
                assert(!isGV_with_GP(sv));		\
                assert(!(SvTYPE(sv) == SVt_PVIO		\
                     && !(IoFLAGS(sv) & IOf_FAKE_DIRP))); \
                ((sv)->sv_u.svu_pv = (val)); } STMT_END
#define SvUV_set(sv, val) \
        STMT_START { \
                assert(PL_valid_types_IV_set[SvTYPE(sv) & SVt_MASK]);	\
                assert(!isGV_with_GP(sv));		\
                (((XPVUV*)SvANY(sv))->xuv_uv = (val)); } STMT_END
#define SvRV_set(sv, val) \
        STMT_START { \
                assert(PL_valid_types_RV[SvTYPE(sv) & SVt_MASK]);	\
                assert(!isGV_with_GP(sv));		\
                assert(!(SvTYPE(sv) == SVt_PVIO		\
                     && !(IoFLAGS(sv) & IOf_FAKE_DIRP))); \
                ((sv)->sv_u.svu_rv = (val)); } STMT_END
#define SvMAGIC_set(sv, val) \
        STMT_START { assert(SvTYPE(sv) >= SVt_PVMG); \
                (((XPVMG*)SvANY(sv))->xmg_u.xmg_magic = (val)); } STMT_END
#define SvSTASH_set(sv, val) \
        STMT_START { assert(SvTYPE(sv) >= SVt_PVMG); \
                (((XPVMG*)  SvANY(sv))->xmg_stash = (val)); } STMT_END
#define SvCUR_set(sv, val) \
        STMT_START { \
                assert(PL_valid_types_PVX[SvTYPE(sv) & SVt_MASK]);	\
                assert(!isGV_with_GP(sv));		\
                assert(!(SvTYPE(sv) == SVt_PVIO		\
                     && !(IoFLAGS(sv) & IOf_FAKE_DIRP))); \
                (((XPV*)  SvANY(sv))->xpv_cur = (val)); } STMT_END
#define SvLEN_set(sv, val) \
        STMT_START { \
                assert(PL_valid_types_PVX[SvTYPE(sv) & SVt_MASK]);	\
                assert(!isGV_with_GP(sv));	\
                assert(!(SvTYPE(sv) == SVt_PVIO		\
                     && !(IoFLAGS(sv) & IOf_FAKE_DIRP))); \
                (((XPV*)  SvANY(sv))->xpv_len = (val)); } STMT_END
#define SvEND_set(sv, val) \
        STMT_START { assert(SvTYPE(sv) >= SVt_PV); \
                SvCUR_set(sv, (val) - SvPVX(sv)); } STMT_END

/*
=for apidoc Am|void|SvPV_renew|SV* sv|STRLEN len
Low level micro optimization of C<L</SvGROW>>.  It is generally better to use
C<SvGROW> instead.  This is because C<SvPV_renew> ignores potential issues that
C<SvGROW> handles.  C<sv> needs to have a real C<PV> that is unencombered by
things like COW.  Using C<SV_CHECK_THINKFIRST> or
C<SV_CHECK_THINKFIRST_COW_DROP> before calling this should clean it up, but
why not just use C<SvGROW> if you're not sure about the provenance?

=cut
*/
#define SvPV_renew(sv,n) \
        STMT_START { SvLEN_set(sv, n); \
                SvPV_set((sv), (MEM_WRAP_CHECK_(n,char)			\
                                (char*)saferealloc((Malloc_t)SvPVX(sv), \
                                                   (MEM_SIZE)((n)))));  \
                 } STMT_END

#define SvPV_shrink_to_cur(sv) STMT_START { \
                   const STRLEN _lEnGtH = SvCUR(sv) + 1; \
                   SvPV_renew(sv, _lEnGtH); \
                 } STMT_END

/*
=for apidoc Am|void|SvPV_free|SV * sv

Frees the PV buffer in C<sv>, leaving things in a precarious state, so should
only be used as part of a larger operation

=cut
*/
#define SvPV_free(sv)							\
    STMT_START {							\
                     assert(SvTYPE(sv) >= SVt_PV);			\
                     if (SvLEN(sv)) {					\
                         assert(!SvROK(sv));				\
                         if(UNLIKELY(SvOOK(sv))) {			\
                             STRLEN zok; 				\
                             SvOOK_offset(sv, zok);			\
                             SvPV_set(sv, SvPVX_mutable(sv) - zok);	\
                             SvFLAGS(sv) &= ~SVf_OOK;			\
                         }						\
                         Safefree(SvPVX(sv));				\
                     }							\
                 } STMT_END

#ifdef PERL_CORE
/* Code that crops up in three places to take a scalar and ready it to hold
   a reference */
#  define prepare_SV_for_RV(sv)						\
    STMT_START {							\
                    if (SvTYPE(sv) < SVt_PV && SvTYPE(sv) != SVt_IV)	\
                        sv_upgrade(sv, SVt_IV);				\
                    else if (SvTYPE(sv) >= SVt_PV) {			\
                        SvPV_free(sv);					\
                        SvLEN_set(sv, 0);				\
                        SvCUR_set(sv, 0);				\
                    }							\
                 } STMT_END
#endif

#ifndef PERL_CORE
#  define BmFLAGS(sv)		(SvTAIL(sv) ? FBMcf_TAIL : 0)
#endif

#if defined (DEBUGGING) && defined(PERL_USE_GCC_BRACE_GROUPS)
#  define BmUSEFUL(sv)							\
        (*({ SV *const _bmuseful = MUTABLE_SV(sv);			\
            assert(SvTYPE(_bmuseful) >= SVt_PVIV);			\
            assert(SvVALID(_bmuseful));					\
            assert(!SvIOK(_bmuseful));					\
            &(((XPVIV*) SvANY(_bmuseful))->xiv_u.xivu_iv);              \
         }))
#else
#  define BmUSEFUL(sv)          ((XPVIV*) SvANY(sv))->xiv_u.xivu_iv

#endif

#ifndef PERL_CORE
# define BmRARE(sv)	0
# define BmPREVIOUS(sv)	0
#endif

#define FmLINES(sv)	((XPVIV*)  SvANY(sv))->xiv_iv

#define LvTYPE(sv)	((XPVLV*)  SvANY(sv))->xlv_type
#define LvTARG(sv)	((XPVLV*)  SvANY(sv))->xlv_targ
#define LvTARGOFF(sv)	((XPVLV*)  SvANY(sv))->xlv_targoff
#define LvSTARGOFF(sv)	((XPVLV*)  SvANY(sv))->xlv_targoff_u.xlvu_stargoff
#define LvTARGLEN(sv)	((XPVLV*)  SvANY(sv))->xlv_targlen
#define LvFLAGS(sv)	((XPVLV*)  SvANY(sv))->xlv_flags

#define LVf_NEG_OFF      0x1
#define LVf_NEG_LEN      0x2
#define LVf_OUT_OF_RANGE 0x4

#define IoIFP(sv)	(sv)->sv_u.svu_fp
#define IoOFP(sv)	((XPVIO*)  SvANY(sv))->xio_ofp
#define IoDIRP(sv)	((XPVIO*)  SvANY(sv))->xio_dirp
#define IoANY(sv)	((XPVIO*)  SvANY(sv))->xio_any
#define IoLINES(sv)	((XPVIO*)  SvANY(sv))->xiv_u.xivu_iv
#define IoPAGE(sv)	((XPVIO*)  SvANY(sv))->xio_page
#define IoPAGE_LEN(sv)	((XPVIO*)  SvANY(sv))->xio_page_len
#define IoLINES_LEFT(sv)((XPVIO*)  SvANY(sv))->xio_lines_left
#define IoTOP_NAME(sv)	((XPVIO*)  SvANY(sv))->xio_top_name
#define IoTOP_GV(sv)	((XPVIO*)  SvANY(sv))->xio_top_gv
#define IoFMT_NAME(sv)	((XPVIO*)  SvANY(sv))->xio_fmt_name
#define IoFMT_GV(sv)	((XPVIO*)  SvANY(sv))->xio_fmt_gv
#define IoBOTTOM_NAME(sv)((XPVIO*) SvANY(sv))->xio_bottom_name
#define IoBOTTOM_GV(sv)	((XPVIO*)  SvANY(sv))->xio_bottom_gv
#define IoTYPE(sv)	((XPVIO*)  SvANY(sv))->xio_type
#define IoFLAGS(sv)	((XPVIO*)  SvANY(sv))->xio_flags

/* IoTYPE(sv) is a single character telling the type of I/O connection. */
#define IoTYPE_RDONLY		'<'
#define IoTYPE_WRONLY		'>'
#define IoTYPE_RDWR		'+'
#define IoTYPE_APPEND 		'a'
#define IoTYPE_PIPE		'|'
#define IoTYPE_STD		'-'	/* stdin or stdout */
#define IoTYPE_SOCKET		's'
#define IoTYPE_CLOSED		' '
#define IoTYPE_IMPLICIT		'I'	/* stdin or stdout or stderr */
#define IoTYPE_NUMERIC		'#'	/* fdopen */

/*
=for apidoc_section $tainting
=for apidoc Am|bool|SvTAINTED|SV* sv
Checks to see if an SV is tainted.  Returns TRUE if it is, FALSE if
not.

=for apidoc Am|void|SvTAINTED_on|SV* sv
Marks an SV as tainted if tainting is enabled.

=for apidoc Am|void|SvTAINTED_off|SV* sv
Untaints an SV.  Be I<very> careful with this routine, as it short-circuits
some of Perl's fundamental security features.  XS module authors should not
use this function unless they fully understand all the implications of
unconditionally untainting the value.  Untainting should be done in the
standard perl fashion, via a carefully crafted regexp, rather than directly
untainting variables.

=for apidoc Am|void|SvTAINT|SV* sv
Taints an SV if tainting is enabled, and if some input to the current
expression is tainted--usually a variable, but possibly also implicit
inputs such as locale settings.  C<SvTAINT> propagates that taintedness to
the outputs of an expression in a pessimistic fashion; i.e., without paying
attention to precisely which outputs are influenced by which inputs.

=cut
*/

#define sv_taint(sv)	  sv_magic((sv), NULL, PERL_MAGIC_taint, NULL, 0)

#ifdef NO_TAINT_SUPPORT
#   define SvTAINTED(sv) 0
#else
#   define SvTAINTED(sv)	  (SvMAGICAL(sv) && sv_tainted(sv))
#endif
#define SvTAINTED_on(sv)  STMT_START{ if(UNLIKELY(TAINTING_get)){sv_taint(sv);}   }STMT_END
#define SvTAINTED_off(sv) STMT_START{ if(UNLIKELY(TAINTING_get)){sv_untaint(sv);} }STMT_END

#define SvTAINT(sv)			\
    STMT_START {			\
        assert(TAINTING_get || !TAINT_get); \
        if (UNLIKELY(TAINT_get))	\
            SvTAINTED_on(sv);	        \
    } STMT_END

/*
=for apidoc_section $SV
=for apidoc Am|char*|SvPV_force|SV* sv|STRLEN len
=for apidoc_item ||SvPV_force_nolen|SV* sv
=for apidoc_item ||SvPVx_force|SV* sv|STRLEN len
=for apidoc_item ||SvPV_force_nomg|SV* sv|STRLEN len
=for apidoc_item ||SvPV_force_nomg_nolen|SV * sv
=for apidoc_item ||SvPV_force_mutable|SV * sv|STRLEN len
=for apidoc_item ||SvPV_force_flags|SV * sv|STRLEN len|U32 flags
=for apidoc_item ||SvPV_force_flags_nolen|SV * sv|U32 flags
=for apidoc_item ||SvPV_force_flags_mutable|SV * sv|STRLEN len|U32 flags
=for apidoc_item ||SvPVbyte_force
=for apidoc_item ||SvPVbytex_force
=for apidoc_item ||SvPVutf8_force
=for apidoc_item ||SvPVutf8x_force

These are like C<L</SvPV>>, returning the string in the SV, but will force the
SV into containing a string (C<L</SvPOK>>), and only a string
(C<L</SvPOK_only>>), by hook or by crook.  You need to use one of these
C<force> routines if you are going to update the C<L</SvPVX>> directly.

Note that coercing an arbitrary scalar into a plain PV will potentially
strip useful data from it.  For example if the SV was C<SvROK>, then the
referent will have its reference count decremented, and the SV itself may
be converted to an C<SvPOK> scalar with a string buffer containing a value
such as C<"ARRAY(0x1234)">.

The differences between the forms are:

The forms with C<flags> in their names allow you to use the C<flags> parameter
to specify to perform 'get' magic (by setting the C<SV_GMAGIC> flag) or to skip
'get' magic (by clearing it).  The other forms do perform 'get' magic, except
for the ones with C<nomg> in their names, which skip 'get' magic.

The forms that take a C<len> parameter will set that variable to the byte
length of the resultant string (these are macros, so don't use C<&len>).

The forms with C<nolen> in their names indicate they don't have a C<len>
parameter.  They should be used only when it is known that the PV is a C
string, terminated by a NUL byte, and without intermediate NUL characters; or
when you don't care about its length.

The forms with C<mutable> in their names are effectively the same as those without,
but the name emphasizes that the string is modifiable by the caller, which it is
in all the forms.

C<SvPVutf8_force> is like C<SvPV_force>, but converts C<sv> to UTF-8 first if
not already UTF-8.

C<SvPVutf8x_force> is like C<SvPVutf8_force>, but guarantees to evaluate C<sv>
only once; use the more efficient C<SvPVutf8_force> otherwise.

C<SvPVbyte_force> is like C<SvPV_force>, but converts C<sv> to byte
representation first if currently encoded as UTF-8.  If the SV cannot be
downgraded from UTF-8, this croaks.

C<SvPVbytex_force> is like C<SvPVbyte_force>, but guarantees to evaluate C<sv>
only once; use the more efficient C<SvPVbyte_force> otherwise.

=for apidoc Am|char*|SvPV|SV* sv|STRLEN len
=for apidoc_item |char*|SvPVx|SV* sv|STRLEN len
=for apidoc_item |char*|SvPV_nomg|SV* sv|STRLEN len
=for apidoc_item |char*|SvPV_nolen|SV* sv
=for apidoc_item |char*|SvPVx_nolen|SV* sv
=for apidoc_item |char*|SvPV_nomg_nolen|SV* sv
=for apidoc_item |char*|SvPV_mutable|SV* sv|STRLEN len
=for apidoc_item |const char*|SvPV_const|SV* sv|STRLEN len
=for apidoc_item |const char*|SvPVx_const|SV* sv|STRLEN len
=for apidoc_item |const char*|SvPV_nolen_const|SV* sv
=for apidoc_item |const char*|SvPVx_nolen_const|SV* sv
=for apidoc_item |const char*|SvPV_nomg_const|SV* sv|STRLEN len
=for apidoc_item |const char*|SvPV_nomg_const_nolen|SV* sv
=for apidoc_item |char *|SvPV_flags|SV * sv|STRLEN len|U32 flags
=for apidoc_item |const char *|SvPV_flags_const|SV * sv|STRLEN len|U32 flags
=for apidoc_item |char *|SvPV_flags_mutable|SV * sv|STRLEN len|U32 flags
=for apidoc_item |char*|SvPVbyte|SV* sv|STRLEN len
=for apidoc_item |char*|SvPVbyte_nomg|SV* sv|STRLEN len
=for apidoc_item |char*|SvPVbyte_nolen|SV* sv
=for apidoc_item |char*|SvPVbytex_nolen|SV* sv
=for apidoc_item |char*|SvPVbytex|SV* sv|STRLEN len
=for apidoc_item |char*|SvPVbyte_or_null|SV* sv|STRLEN len
=for apidoc_item |char*|SvPVbyte_or_null_nomg|SV* sv|STRLEN len
=for apidoc_item |char*|SvPVutf8|SV* sv|STRLEN len
=for apidoc_item |char*|SvPVutf8x|SV* sv|STRLEN len
=for apidoc_item |char*|SvPVutf8_nomg|SV* sv|STRLEN len
=for apidoc_item |char*|SvPVutf8_nolen|SV* sv
=for apidoc_item |char*|SvPVutf8_or_null|SV* sv|STRLEN len
=for apidoc_item |char*|SvPVutf8_or_null_nomg|SV* sv|STRLEN len

All these return a pointer to the string in C<sv>, or a stringified form of
C<sv> if it does not contain a string.  The SV may cache the stringified
version becoming C<SvPOK>.

This is a very basic and common operation, so there are lots of slightly
different versions of it.

Note that there is no guarantee that the return value of C<SvPV(sv)>, for
example, is equal to C<SvPVX(sv)>, or that C<SvPVX(sv)> contains valid data, or
that successive calls to C<SvPV(sv)> (or another of these forms) will return
the same pointer value each time.  This is due to the way that things like
overloading and Copy-On-Write are handled.  In these cases, the return value
may point to a temporary buffer or similar.  If you absolutely need the
C<SvPVX> field to be valid (for example, if you intend to write to it), then
see C<L</SvPV_force>>.

The differences between the forms are:

The forms with neither C<byte> nor C<utf8> in their names (e.g., C<SvPV> or
C<SvPV_nolen>) can expose the SV's internal string buffer. If
that buffer consists entirely of bytes 0-255 and includes any bytes above
127, then you B<MUST> consult C<SvUTF8> to determine the actual code points
the string is meant to contain. Generally speaking, it is probably safer to
prefer C<SvPVbyte>, C<SvPVutf8>, and the like. See
L<perlguts/How do I pass a Perl string to a C library?> for more details.

The forms with C<flags> in their names allow you to use the C<flags> parameter
to specify to process 'get' magic (by setting the C<SV_GMAGIC> flag) or to skip
'get' magic (by clearing it).  The other forms process 'get' magic, except for
the ones with C<nomg> in their names, which skip 'get' magic.

The forms that take a C<len> parameter will set that variable to the byte
length of the resultant string (these are macros, so don't use C<&len>).

The forms with C<nolen> in their names indicate they don't have a C<len>
parameter.  They should be used only when it is known that the PV is a C
string, terminated by a NUL byte, and without intermediate NUL characters; or
when you don't care about its length.

The forms with C<const> in their names return S<C<const char *>> so that the
compiler will hopefully complain if you were to try to modify the contents of
the string (unless you cast away const yourself).

The other forms return a mutable pointer so that the string is modifiable by
the caller; this is emphasized for the ones with C<mutable> in their names.

The forms whose name ends in C<x> are the same as the corresponding form
without the C<x>, but the C<x> form is guaranteed to evaluate C<sv> exactly
once, with a slight loss of efficiency.  Use this if C<sv> is an expression
with side effects.

C<SvPVutf8> is like C<SvPV>, but converts C<sv> to UTF-8 first if not already
UTF-8.  Similiarly, the other forms with C<utf8> in their names correspond to
their respective forms without.

C<SvPVutf8_or_null> and C<SvPVutf8_or_null_nomg> don't have corresponding
non-C<utf8> forms.  Instead they are like C<SvPVutf8_nomg>, but when C<sv> is
undef, they return C<NULL>.

C<SvPVbyte> is like C<SvPV>, but converts C<sv> to byte representation first if
currently encoded as UTF-8.  If C<sv> cannot be downgraded from UTF-8, it
croaks.  Similiarly, the other forms with C<byte> in their names correspond to
their respective forms without.

C<SvPVbyte_or_null> doesn't have a corresponding non-C<byte> form.  Instead it
is like C<SvPVbyte>, but when C<sv> is undef, it returns C<NULL>.

=for apidoc Am|IV|SvIV|SV* sv
=for apidoc_item SvIVx
=for apidoc_item SvIV_nomg

These coerce the given SV to IV and return it.  The returned value in many
circumstances will get stored in C<sv>'s IV slot, but not in all cases.  (Use
C<L</sv_setiv>> to make sure it does).

C<SvIVx> is different from the others in that it is guaranteed to evaluate
C<sv> exactly once; the others may evaluate it multiple times.  Only use this
form if C<sv> is an expression with side effects, otherwise use the more
efficient C<SvIV>.

C<SvIV_nomg> is the same as C<SvIV>, but does not perform 'get' magic.

=for apidoc Am|NV|SvNV|SV* sv
=for apidoc_item SvNVx
=for apidoc_item SvNV_nomg

These coerce the given SV to NV and return it.  The returned value in many
circumstances will get stored in C<sv>'s NV slot, but not in all cases.  (Use
C<L</sv_setnv>> to make sure it does).

C<SvNVx> is different from the others in that it is guaranteed to evaluate
C<sv> exactly once; the others may evaluate it multiple times.  Only use this
form if C<sv> is an expression with side effects, otherwise use the more
efficient C<SvNV>.

C<SvNV_nomg> is the same as C<SvNV>, but does not perform 'get' magic.

=for apidoc Am|UV|SvUV|SV* sv
=for apidoc_item SvUVx
=for apidoc_item SvUV_nomg

These coerce the given SV to UV and return it.  The returned value in many
circumstances will get stored in C<sv>'s UV slot, but not in all cases.  (Use
C<L</sv_setuv>> to make sure it does).

C<SvUVx> is different from the others in that it is guaranteed to evaluate
C<sv> exactly once; the others may evaluate it multiple times.  Only use this
form if C<sv> is an expression with side effects, otherwise use the more
efficient C<SvUV>.

C<SvUV_nomg> is the same as C<SvUV>, but does not perform 'get' magic.

=for apidoc SvTRUE
=for apidoc_item SvTRUEx
=for apidoc_item SvTRUE_nomg
=for apidoc_item SvTRUE_NN
=for apidoc_item SvTRUE_nomg_NN

These return a boolean indicating whether Perl would evaluate the SV as true or
false.  See C<L</SvOK>> for a defined/undefined test.

As of Perl 5.32, all are guaranteed to evaluate C<sv> only once.  Prior to that
release, only C<SvTRUEx> guaranteed single evaluation; now C<SvTRUEx> is
identical to C<SvTRUE>.

C<SvTRUE_nomg> and C<TRUE_nomg_NN> do not perform 'get' magic; the others do
unless the scalar is already C<SvPOK>, C<SvIOK>, or C<SvNOK> (the public, not
the private flags).

C<SvTRUE_NN> is like C<L</SvTRUE>>, but C<sv> is assumed to be
non-null (NN).  If there is a possibility that it is NULL, use plain
C<SvTRUE>.

C<SvTRUE_nomg_NN> is like C<L</SvTRUE_nomg>>, but C<sv> is assumed to be
non-null (NN).  If there is a possibility that it is NULL, use plain
C<SvTRUE_nomg>.

=for apidoc Am|U32|SvIsCOW|SV* sv
Returns a U32 value indicating whether the SV is Copy-On-Write (either shared
hash key scalars, or full Copy On Write scalars if 5.9.0 is configured for
COW).

=for apidoc Am|bool|SvIsCOW_shared_hash|SV* sv
Returns a boolean indicating whether the SV is Copy-On-Write shared hash key
scalar.

=cut
*/

/* Let us hope that bitmaps for UV and IV are the same */
#define SvIV(sv) (SvIOK_nog(sv) ? SvIVX(sv) : sv_2iv(sv))
#define SvUV(sv) (SvUOK_nog(sv) ? SvUVX(sv) : sv_2uv(sv))
#define SvNV(sv) (SvNOK_nog(sv) ? SvNVX(sv) : sv_2nv(sv))

#define SvIV_nomg(sv) (SvIOK(sv) ? SvIVX(sv) : sv_2iv_flags(sv, 0))
#define SvUV_nomg(sv) (SvUOK(sv) ? SvUVX(sv) : sv_2uv_flags(sv, 0))
#define SvNV_nomg(sv) (SvNOK(sv) ? SvNVX(sv) : sv_2nv_flags(sv, 0))

/* ----*/

#define SvPV(sv, len)         SvPV_flags(sv, len, SV_GMAGIC)
#define SvPV_const(sv, len)   SvPV_flags_const(sv, len, SV_GMAGIC)
#define SvPV_mutable(sv, len) SvPV_flags_mutable(sv, len, SV_GMAGIC)

/* This test is "is there a cached PV that we can use directly?"
 * We can if
 * a) SVf_POK is true and there's definitely no get magic on the scalar
 * b) SVp_POK is true, there's no get magic, and we know that the cached PV
 *    came from an IV conversion.
 * For the latter case, we don't set SVf_POK so that we can distinguish whether
 * the value originated as a string or as an integer, before we cached the
 * second representation. */
#define SvPOK_or_cached_IV(sv) \
    (((SvFLAGS(sv) & (SVf_POK|SVs_GMG)) == SVf_POK) || ((SvFLAGS(sv) & (SVf_IOK|SVp_POK|SVs_GMG)) == (SVf_IOK|SVp_POK)))

#define SvPV_flags(sv, len, flags) \
    (SvPOK_or_cached_IV(sv) \
     ? ((len = SvCUR(sv)), SvPVX(sv)) : sv_2pv_flags(sv, &len, flags))
#define SvPV_flags_const(sv, len, flags) \
    (SvPOK_or_cached_IV(sv) \
     ? ((len = SvCUR(sv)), SvPVX_const(sv)) : \
     (const char*) sv_2pv_flags(sv, &len, (flags|SV_CONST_RETURN)))
#define SvPV_flags_const_nolen(sv, flags) \
    (SvPOK_or_cached_IV(sv) \
     ? SvPVX_const(sv) : \
     (const char*) sv_2pv_flags(sv, 0, (flags|SV_CONST_RETURN)))
#define SvPV_flags_mutable(sv, len, flags) \
    (SvPOK_or_cached_IV(sv) \
     ? ((len = SvCUR(sv)), SvPVX_mutable(sv)) : \
     sv_2pv_flags(sv, &len, (flags|SV_MUTABLE_RETURN)))

#define SvPV_force(sv, len) SvPV_force_flags(sv, len, SV_GMAGIC)
#define SvPV_force_nolen(sv) SvPV_force_flags_nolen(sv, SV_GMAGIC)
#define SvPV_force_mutable(sv, len) SvPV_force_flags_mutable(sv, len, SV_GMAGIC)

#define SvPV_force_nomg(sv, len) SvPV_force_flags(sv, len, 0)
#define SvPV_force_nomg_nolen(sv) SvPV_force_flags_nolen(sv, 0)

#define SvPV_force_flags(sv, len, flags) \
    (SvPOK_pure_nogthink(sv) \
     ? ((len = SvCUR(sv)), SvPVX(sv)) : sv_pvn_force_flags(sv, &len, flags))

#define SvPV_force_flags_nolen(sv, flags) \
    (SvPOK_pure_nogthink(sv) \
     ? SvPVX(sv) : sv_pvn_force_flags(sv, 0, flags))

#define SvPV_force_flags_mutable(sv, len, flags) \
    (SvPOK_pure_nogthink(sv) \
     ? ((len = SvCUR(sv)), SvPVX_mutable(sv)) \
     : sv_pvn_force_flags(sv, &len, flags|SV_MUTABLE_RETURN))

#define SvPV_nolen(sv) \
    (SvPOK_or_cached_IV(sv) \
     ? SvPVX(sv) : sv_2pv_flags(sv, 0, SV_GMAGIC))

/* "_nomg" in these defines means no mg_get() */
#define SvPV_nomg_nolen(sv) \
    (SvPOK_or_cached_IV(sv) \
     ? SvPVX(sv) : sv_2pv_flags(sv, 0, 0))

#define SvPV_nolen_const(sv) \
    (SvPOK_or_cached_IV(sv) \
     ? SvPVX_const(sv) : sv_2pv_flags(sv, 0, SV_GMAGIC|SV_CONST_RETURN))

#define SvPV_nomg(sv, len) SvPV_flags(sv, len, 0)
#define SvPV_nomg_const(sv, len) SvPV_flags_const(sv, len, 0)
#define SvPV_nomg_const_nolen(sv) SvPV_flags_const_nolen(sv, 0)

/* ----*/

#define SvPVutf8(sv, len) \
    (SvPOK_utf8_nog(sv) \
     ? ((len = SvCUR(sv)), SvPVX(sv)) : sv_2pvutf8(sv, &len))

#define SvPVutf8_or_null(sv, len) \
    (SvPOK_utf8_nog(sv) \
     ? ((len = SvCUR(sv)), SvPVX(sv)) : (SvGETMAGIC(sv), SvOK(sv)) \
     ? sv_2pvutf8_flags(sv, &len, 0) : ((len = 0), NULL))

#define SvPVutf8_nomg(sv, len) \
    (SvPOK_utf8_nog(sv) \
     ? ((len = SvCUR(sv)), SvPVX(sv)) : sv_2pvutf8_flags(sv, &len, 0))

#define SvPVutf8_or_null_nomg(sv, len) \
    (SvPOK_utf8_nog(sv) \
     ? ((len = SvCUR(sv)), SvPVX(sv)) : SvOK(sv) \
     ? sv_2pvutf8_flags(sv, &len, 0) : ((len = 0), NULL))

#define SvPVutf8_force(sv, len) \
    (SvPOK_utf8_pure_nogthink(sv) \
     ? ((len = SvCUR(sv)), SvPVX(sv)) : sv_pvutf8n_force(sv, &len))

#define SvPVutf8_nolen(sv) \
    (SvPOK_utf8_nog(sv) \
     ? SvPVX(sv) : sv_2pvutf8(sv, 0))

/* ----*/

#define SvPVbyte(sv, len) \
    (SvPOK_byte_nog(sv) \
     ? ((len = SvCUR(sv)), SvPVX(sv)) : sv_2pvbyte(sv, &len))

#define SvPVbyte_or_null(sv, len) \
    (SvPOK_byte_nog(sv) \
     ? ((len = SvCUR(sv)), SvPVX(sv)) : (SvGETMAGIC(sv), SvOK(sv)) \
