0.2 Checkout

  The "checkout" operation is to retrieve file content at a given revision,
  say X. It's doable by going through the file line by line and:

    - If meet ^AI rev, and rev > X, find the corresponding ^AE and jump there
    - If meet ^AD rev, and rev <= X, find the corresponding ^AE and jump there
    - Ignore ^AE
    - For normal lines, just output them

0.3 Annotate

  The "annotate" operation is to show extra metadata like the revision number
  and the original line number a line comes from.

  It's basically just a "Checkout". For the extra metadata, they can be stored
  side by side with the line contents. Alternatively, we can infer the
  revision number from "^AI"s.

  Some SCM tools have to calculate diffs on the fly and thus are much slower
  on this operation.

0.4 Tree Structure

  The word "interleaved" is used because "^AI" .. "^AE" and "^AD" .. "^AE"
  blocks can be interleaved.

  If we consider insertions and deletions separately, they can form tree
  structures, respectively.

    +--- ^AI 1        +--- ^AD 3
    | +- ^AI 2        | +- ^AD 2
    | |               | |
    | +- ^AE 2        | +- ^AE 2
    |                 |
    +--- ^AE 1        +--- ^AE 3

  More specifically, it's possible to build a tree for all insertions, where
  the tree node has the structure "(rev, startline, endline)". "startline" is
  the line number of "^AI" and "endline" is the line number of the matched
  "^AE".  The tree will have these properties:

    1. child.rev > parent.rev
    2. child.startline > parent.startline
    3. child.endline < parent.endline

  A similar tree for all deletions can also be built with the first property
  changed to:

    1. child.rev < parent.rev

0.5 Malformed Cases

  The following cases are considered malformed in our implementation:

    1. Interleaved insertions, or interleaved deletions.
       It can be rewritten to a non-interleaved tree structure.

       Take insertions as example, deletions are similar:

       ^AI x         ^AI x
       a             a
       ^AI x + 1  -> ^AI x + 1
       b             b
       ^AE x         ^AE x + 1
       c             ^AE x
       ^AE x + 1     ^AI x + 1
                     c
                     ^AE x + 1

    2. Nested insertions, where the inner one has a smaller revision number.
       Or nested deletions, where the inner one has a larger revision number.
       It can be rewritten to a non-nested form.

       Take insertions as example, deletions are similar:

       ^AI x + 1     ^AI x + 1
       a             a
       ^AI x      -> ^AE x + 1
       b             ^AI x
       ^AE x         b
       c             ^AE x
       ^AE x + 1     ^AI x + 1
                     c
                     ^AE x + 1

    3. Insertion inside deletion with a smaller revision number.

       Rewrite by duplicating the content inserted:

       ^AD x          ^AD x
       a              a
       ^AI x + 1  ->  b
       b              c
       ^AE x + 1      ^AE x
       c              ^AI x + 1
       ^AE x          b
                      ^AE x + 1

       Note: If "annotate" purely depends on "^AI" information, then the
       duplication content will lose track of where "b" is originally from.

  Some of them may be valid in other implementations for special purposes. For
  example, to "revive" a previously deleted block in a newer revision.

0.6 Cases Can Be Optimized

  It's always better to get things nested. For example, the left is more
  efficient than the right while they represent the same content:

    +--- ^AD 2          +- ^AD 1
    | +- ^AD 1          |   LINE A
    | |   LINE A        +- ^AE 1
    | +- ^AE 1          +- ^AD 2
    |     LINE B        |   LINE B
    +--- ^AE 2          +- ^AE 2

  Our implementation sometimes generates the less efficient data. To always
  get the optimal form, it requires extra code complexity that seems unworthy.

0.7 Inefficiency

  The file format can be slow because:

  - Inserting a new line at position P requires rewriting all data after P.
  - Finding "^AE" requires walking through the content (O(N), where N is the
    number of lines between "^AI/D" and "^AE").

1. Linelog

  The linelog is a binary format that dedicates to speed up mercurial (or
  git)'s "annotate" operation. It's designed to avoid issues mentioned in
  section 0.7.

1.1 Content Stored

  Linelog is not another storage for file contents. It only stores line
  numbers and corresponding revision numbers, instead of actual line content.
  This is okay for the "annotate" operation because usually the external
  source is fast to checkout the content of a file at a specific revision.

  A typical SCCS weave is also fast on the "grep" operation, which needs
  random accesses to line contents from different revisions of a file. This
  can be slow with linelog's no-line-content design. However we could use
  an extra map ((rev, line num) -> line content) to speed it up.

  Note the revision numbers in linelog should be independent from mercurial
  integer revision numbers. There should be some mapping between linelog rev
  and hg hash stored side by side, to make the files reusable after being
  copied to another machine.

1.2 Basic Format

  A linelog file consists of "instruction"s. An "instruction" can be either:

    - JGE  REV ADDR     # jump to ADDR if rev >= REV
    - JL   REV ADDR     # jump to ADDR if rev < REV
    - LINE REV LINENUM  # append the (LINENUM+1)-th line in revision REV

  For example, here is the example linelog representing the same file with
  3 revisions mentioned in section 0.1:

    SCCS  |    Linelog
    Weave | Addr : Instruction
    ------+------+-------------
    ^AI 1 |    0 : JL   1 8
    a     |    1 : LINE 1 0
    ^AD 3 |    2 : JGE  3 6
    b     |    3 : LINE 1 1
    ^AI 2 |    4 : JL   2 7
    1     |    5 : LINE 2 2
    ^AE 3 |
    2     |    6 : LINE 2 3
    ^AE 2 |
    c     |    7 : LINE 1 2
    ^AE 1 |
          |    8 : END

  This way, "find ^AE" is O(1) because we just jump there. And we can insert
  new lines without rewriting most part of the file by appending new lines and
  changing a single instruction to jump to them.

  The current implementation uses 64 bits for an instruction: The opcode (JGE,
  JL or LINE) takes 2 bits, REV takes 30 bits and ADDR or LINENUM takes 32
  bits. It also stores the max revision number and buffer size at the first
  64 bits for quick access to these values.

1.3 Comparing with Mercurial's revlog format

  Apparently, linelog is very different from revlog: linelog stores rev and
  line numbers, while revlog has line contents and other metadata (like
  parents, flags). However, the revlog format could also be used to store rev
  and line numbers. For example, to speed up the annotate operation, we could
  also pre-calculate annotate results and just store them using the revlog
  format.

  Therefore, linelog is actually somehow similar to revlog, with the important
  trade-off that it only supports linear history (mentioned in section 0.1).
  Essentially, the differences are:

    a) Linelog is full of deltas, while revlog could contain full file
       contents sometimes. So linelog is smaller. Revlog could trade
       reconstruction speed for file size - best case, revlog is as small as
       linelog.
    b) The interleaved delta structure allows skipping large portion of
       uninteresting deltas so linelog's content reconstruction is faster than
       the delta-only version of revlog (however it's possible to construct
       a case where interleaved deltas degrade to plain deltas, so linelog
       worst case would be delta-only revlog). Revlog could trade file size
       for reconstruction speed.
    c) Linelog implicitly maintains the order of all lines it stores. So it
       could dump all the lines from all revisions, with a reasonable order.
       While revlog could also dump all line additions, it requires extra
       computation to figure out the order putting those lines - that's some
       kind of "merge".

  "c" makes "hg absorb" easier to implement and makes it possible to do
  "annotate --deleted".

1.4 Malformed Cases Handling

  The following "case 1", "case 2", and "case 3" refer to cases mentioned
  in section 0.5.

  Using the exposed API (replacelines), case 1 is impossible to generate,
  although it's possible to generate it by constructing rawdata and load that
  via linelog.fromdata.

  Doing annotate(maxrev) before replacelines (aka. a1, a2 passed to
  replacelines are related to the latest revision) eliminates the possibility
  of case 3. That makes sense since usually you'd like to make edits on top of
  the latest revision. Practically, both absorb and fastannotate do this.

  Doing annotate(maxrev), plus replacelines(rev, ...) where rev >= maxrev
  eliminates the possibility of case 2. That makes sense since usually the
  edits belong to "new revisions", not "old revisions". Practically,
  fastannotate does this. Absorb calls replacelines with rev < maxrev to edit
  past revisions. So it needs some extra care to not generate case 2.

  If case 1 occurs, that probably means linelog file corruption (assuming
  linelog is edited via public APIs) the checkout or annotate result could
  be less meaningful or even error out, but linelog wouldn't enter an infinite
  loop.

  If either case 2 or 3 occurs, linelog works as if the inner "^AI/D" and "^AE"
  operations on the left side are silently ignored.
                                                                                                                                                                                                                                                                                                                                                                                                        usr/lib/python3/dist-packages/mercurial/helptext/internals/mergestate.txt                           0000644 0000000 0000000 00000005034 14355257011 025473  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        The active mergestate is stored in ``.hg/merge`` when a merge is triggered
by commands like ``hg merge``, ``hg rebase``, etc. until the merge is
completed or aborted to track the 3-way merge state of individual files.

The contents of the directory are:

Conflicting files
-----------------

The local version of the conflicting files are stored with their
filenames as the hash of their paths.

state
-----

This mergestate file record is used by hg version prior to 2.9.1
and contains less data than ``state2``. If there is no contradiction
with ``state2``, we can assume that both are written at the same time.
In this case, data from ``state2`` is used. Otherwise, we use ``state``.
We read/write both ``state`` and ``state2`` records to ensure backward
compatibility.

state2
------

This record stores a superset of data in ``state``, including new kinds
of records in the future.

Each record can contain arbitrary content and has an associated type. This
`type` should be a letter. If `type` is uppercase, the record is mandatory:
versions of Mercurial that don't support it should abort. If `type` is
lowercase, the record can be safely ignored.

Currently known records:

| * L: the node of the "local" part of the merge (hexified version)
| * O: the node of the "other" part of the merge (hexified version)
| * F: a file to be merged entry
| * C: a change/delete or delete/change conflict
| * P: a path conflict (file vs directory)
| * f: a (filename, dictionary) tuple of optional values for a given file
| * X: unsupported mandatory record type (used in tests)
| * x: unsupported advisory record type (used in tests)
| * l: the labels for the parts of the merge.

Merge record states (indexed by filename):

| * u: unresolved conflict
| * r: resolved conflict
| * pu: unresolved path conflict (file conflicts with directory)
| * pr: resolved path conflict

The resolve command transitions between 'u' and 'r' for conflicts and
'pu' and 'pr' for path conflicts.

This format is a list of arbitrary records of the form:

[type][length][content]

`type` is a single character, `length` is a 4 byte integer, and
`content` is an arbitrary byte sequence of length `length`.

Mercurial versions prior to 3.7 have a bug where if there are
unsupported mandatory merge records, attempting to clear out the merge
state with hg update --clean or similar aborts. The 't' record type
works around that by writing out what those versions treat as an
advisory record, but later versions interpret as special: the first
character is the 'real' record type and everything onwards is the data.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    usr/lib/python3/dist-packages/mercurial/helptext/internals/requirements.txt                         0000644 0000000 0000000 00000013407 14355257011 026061  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Repositories contain a file (``.hg/requires``) containing a list of
features/capabilities that are *required* for clients to interface
with the repository. This file has been present in Mercurial since
version 0.9.2 (released December 2006).

One of the first things clients do when opening a repository is read
``.hg/requires`` and verify that all listed requirements are supported,
aborting if not. Requirements are therefore a strong mechanism to
prevent incompatible clients from reading from unknown repository
formats or even corrupting them by writing to them.

Extensions may add requirements. When they do this, clients not running
an extension will be unable to read from repositories.

The following sections describe the requirements defined by the
Mercurial core distribution.

revlogv1
========

When present, revlogs are version 1 (RevlogNG). RevlogNG was introduced
in 2006. The ``revlogv1`` requirement has been enabled by default
since the ``requires`` file was introduced in Mercurial 0.9.2.

If this requirement is not present, version 0 revlogs are assumed.

store
=====

The *store* repository layout should be used.

This requirement has been enabled by default since the ``requires`` file
was introduced in Mercurial 0.9.2.

fncache
=======

The *fncache* repository layout should be used.

The *fncache* layout hash encodes filenames with long paths and
encodes reserved filenames.

This requirement is enabled by default when the *store* requirement is
enabled (which is the default behavior). It was introduced in Mercurial
1.1 (released December 2008).

shared
======

Denotes that the store for a repository is shared from another location
(defined by the ``.hg/sharedpath`` file).

This requirement is set when a repository is created via :hg:`share`.

The requirement was added in Mercurial 1.3 (released July 2009).

relshared
=========

Derivative of ``shared``; the location of the store is relative to the
store of this repository.

This requirement is set when a repository is created via :hg:`share`
using the ``--relative`` option.

The requirement was added in Mercurial 4.2 (released May 2017).

dotencode
=========

The *dotencode* repository layout should be used.

The *dotencode* layout encodes the first period or space in filenames
to prevent issues on OS X and Windows.

This requirement is enabled by default when the *store* requirement
is enabled (which is the default behavior). It was introduced in
Mercurial 1.7 (released November 2010).

parentdelta
===========

Denotes a revlog delta encoding format that was experimental and
replaced by *generaldelta*. It should not be seen in the wild because
it was never enabled by default.

This requirement was added in Mercurial 1.7 and removed in Mercurial
1.9.

generaldelta
============

Revlogs should be created with the *generaldelta* flag enabled. The
generaldelta flag will cause deltas to be encoded against a parent
revision instead of the previous revision in the revlog.

Support for this requirement was added in Mercurial 1.9 (released
July 2011). The requirement was disabled on new repositories by
default until Mercurial 3.7 (released February 2016).

manifestv2
==========

Denotes that version 2 of manifests are being used.

Support for this requirement was added in Mercurial 3.4 (released
May 2015). The new format failed to meet expectations and support
for the format and requirement were removed in Mercurial 4.6
(released May 2018) since the feature never graduated frome experiment
status.

treemanifest
============

Denotes that tree manifests are being used. Tree manifests are
one manifest per directory (as opposed to a single flat manifest).

Support for this requirement was added in Mercurial 3.4 (released
August 2015). The requirement is currently experimental and is
disabled by default.

exp-sparse
==========

The working directory is sparse (only contains a subset of files).

Support for this requirement was added in Mercurial 4.3 (released
August 2017). This requirement and feature are experimental and may
disappear in a future Mercurial release. The requirement will only
be present on repositories that have opted in to a sparse working
directory.

bookmarksinstore
================

Bookmarks are stored in ``.hg/store/`` instead of directly in ``.hg/``
where they used to be stored. The active bookmark is still stored
directly in ``.hg/``. This makes them always shared by ``hg share``,
whether or not ``-B`` was passed.

Support for this requirement was added in Mercurial 5.1 (released
August 2019). The requirement will only be present on repositories
that have opted in to this format (by having
``format.bookmarks-in-store=true`` set when they were created).

persistent-nodemap
==================

The `nodemap` index (mapping nodeid to local revision number) is persisted on
disk. This provides speed benefit (if the associated native code is used). The
persistent nodemap is only used for two revlogs: the changelog and the
manifestlog.

Support for this requirement was added in Mercurial 5.5 (released August 2020).
Note that as of 5.5, only installations compiled with the Rust extension will
benefit from a speedup. The other installations will do the necessary work to
keep the index up to date, but will suffer a slowdown.

share-safe
==========

Represents that the repository can be shared safely. Requirements and config of
the source repository will be shared.
Requirements are stored in ``.hg/store`` instead of directly in ``.hg/`` where
they used to be stored. Some working copy related requirements are still stored
in ``.hg/``.
Shares read the ``.hg/hgrc`` of the source repository.

Support for this requirement was added in Mercurial 5.7 (released
February 2021). The requirement will only be present on repositories that have
opted in to this format (by having ``format.use-share-safe=true`` set when
they were created).
                                                                                                                                                                                                                                                         usr/lib/python3/dist-packages/mercurial/helptext/internals/revlogs.txt                              0000644 0000000 0000000 00000026067 14355257011 025025  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Revision logs - or *revlogs* - are an append only data structure for
storing discrete entries, or *revisions*. They are the primary storage
mechanism of repository data.

Revlogs effectively model a directed acyclic graph (DAG). Each node
has edges to 1 or 2 *parent* nodes. Each node contains metadata and
the raw value for that node.

Revlogs consist of entries which have metadata and revision data.
Metadata includes the hash of the revision's content, sizes, and
links to its *parent* entries. The collective metadata is referred
to as the *index* and the revision data is the *data*.

Revision data is stored as a series of compressed deltas against
ancestor revisions.

Revlogs are written in an append-only fashion. We never need to rewrite
a file to insert nor do we need to remove data. Rolling back in-progress
writes can be performed by truncating files. Read locks can be avoided
using simple techniques. This means that references to other data in
the same revlog *always* refer to a previous entry.

Revlogs can be modeled as 0-indexed arrays. The first revision is
revision #0 and the second is revision #1. The revision -1 is typically
used to mean *does not exist* or *not defined*.

File Format
===========

A revlog begins with a 32-bit big endian integer holding version info
and feature flags. This integer overlaps with the first four bytes of
the first revision entry.

This integer is logically divided into 2 16-bit shorts. The least
significant half of the integer is the format/version short. The other
short holds feature flags that dictate behavior of the revlog.

The following values for the format/version short are defined:

0
   The original revlog version.
1
   RevlogNG (*next generation*). It replaced version 0 when it was
   implemented in 2006.
2
   In-development version incorporating accumulated knowledge and
   missing features from 10+ years of revlog version 1.
57005 (0xdead)
   Reserved for internal testing of new versions. No defined format
   beyond 32-bit header.

The feature flags short consists of bit flags. Where 0 is the least
significant bit. The bit flags vary by revlog version.

Version 0 revlogs have no defined flags and the presence of a flag
is considered an error.

Version 1 revlogs have the following flags at the specified bit offsets:

0
   Store revision data inline.
1
   Generaldelta encoding.

Version 2 revlogs have the following flags at the specified bit offsets:

0
   Store revision data inline.

The following header values are common:

00 00 00 01
   v1
00 01 00 01
   v1 + inline
00 02 00 01
   v1 + generaldelta
00 03 00 01
   v1 + inline + generaldelta

Following the 32-bit header is the remaining 60 bytes of the first index
entry. Following that are additional *index* entries. Inlined revision
data is possibly located between index entries. More on this inlined
layout is described below.

Version 1 Format
================

Version 1 (RevlogNG) begins with an index describing the revisions in
the revlog. If the ``inline`` flag is set, revision data is stored inline,
or between index entries (as opposed to in a separate container).

Each index entry is 64 bytes. The byte layout of each entry is as
follows, with byte 0 being the first byte (all data stored as big endian):

0-3 (4 bytes) (rev 0 only)
   Revlog header

0-5 (6 bytes)
   Absolute offset of revision data from beginning of revlog.

6-7 (2 bytes)
   Bit flags impacting revision behavior. The following bit offsets define:

   0: REVIDX_ISCENSORED revision has censor metadata, must be verified.

   1: REVIDX_ELLIPSIS revision hash does not match its data. Used by
   narrowhg

   2: REVIDX_EXTSTORED revision data is stored externally.

8-11 (4 bytes)
   Compressed length of revision data / chunk as stored in revlog.

12-15 (4 bytes)
   Uncompressed length of revision data. This is the size of the full
   revision data, not the size of the chunk post decompression.

16-19 (4 bytes)
   Base or previous revision this revision's delta was produced against.
   This revision holds full text (as opposed to a delta) if it points to
   itself. For generaldelta repos, this is the previous revision in the
   delta chain. For non-generaldelta repos, this is the base or first
   revision in the delta chain.

20-23 (4 bytes)
   A revision this revision is *linked* to. This allows a revision in
   one revlog to be forever associated with a revision in another
   revlog. For example, a file's revlog may point to the changelog
   revision that introduced it.

24-27 (4 bytes)
   Revision of 1st parent. -1 indicates no parent.

28-31 (4 bytes)
   Revision of 2nd parent. -1 indicates no 2nd parent.

32-63 (32 bytes)
   Hash of revision's full text. Currently, SHA-1 is used and only
   the first 20 bytes of this field are used. The rest of the bytes
   are ignored and should be stored as \0.

If inline revision data is being stored, the compressed revision data
(of length from bytes offset 8-11 from the index entry) immediately
follows the index entry. There is no header on the revision data. There
is no padding between it and the index entries before and after.

If revision data is not inline, then raw revision data is stored in a
separate byte container. The offsets from bytes 0-5 and the compressed
length from bytes 8-11 define how to access this data.

The 6 byte absolute offset field from the first revlog entry overlaps
with the revlog header. That is, the first 6 bytes of the first revlog
entry can be split into four bytes containing the header for the revlog
file and an additional two bytes containing the offset for the first
entry. Since this is the offset from the beginning of the file for the
first revision entry, the two bytes will always be set to zero.

Version 2 Format
================

(In development. Format not finalized or stable.)

Version 2 is identical to version 1 with the following differences.

There is no dedicated *generaldelta* revlog format flag. Instead,
the feature is implied enabled by default.

Delta Chains
============

Revision data is encoded as a chain of *chunks*. Each chain begins with
the compressed original full text for that revision. Each subsequent
*chunk* is a *delta* against the previous revision. We therefore call
these chains of chunks/deltas *delta chains*.

The full text for a revision is reconstructed by loading the original
full text for the base revision of a *delta chain* and then applying
*deltas* until the target revision is reconstructed.

*Delta chains* are limited in length so lookup time is bound. They are
limited to ~2x the length of the revision's data. The linear distance
between the base chunk and the final chunk is also limited so the
amount of read I/O to load all chunks in the delta chain is bound.

Deltas and delta chains are either computed against the previous
revision in the revlog or another revision (almost certainly one of
the parents of the revision). Historically, deltas were computed against
the previous revision. The *generaldelta* revlog feature flag (enabled
by default in Mercurial 3.7) activates the mode where deltas are
computed against an arbitrary revision (almost certainly a parent revision).

File Storage
============

Revlogs logically consist of an index (metadata of entries) and
revision data. This data may be stored together in a single file or in
separate files. The mechanism used is indicated by the ``inline`` feature
flag on the revlog.

Mercurial's behavior is to use inline storage until a revlog reaches a
certain size, at which point it will be converted to non-inline. The
reason there is a size limit on inline storage is to establish an upper
bound on how much data must be read to load the index. It would be a waste
to read tens or hundreds of extra megabytes of data just to access the
index data.

The actual layout of revlog files on disk is governed by the repository's
*store format*. Typically, a ``.i`` file represents the index revlog
(possibly containing inline data) and a ``.d`` file holds the revision data.

Revision Entries
================

Revision entries consist of an optional 1 byte header followed by an
encoding of the revision data. The headers are as follows:

\0  (0x00)
    Revision data is the entirety of the entry, including this header.
(   (0x28)
    zstd https://github.com/facebook/zstd
u   (0x75)
    Raw revision data follows.
x   (0x78)
    zlib (RFC 1950) data.

    The 0x78 value is actually the first byte of the zlib header (CMF byte).

Hash Computation
================

The hash of the revision is stored in the index and is used both as a primary
key and for data integrity verification.

Currently, SHA-1 is the only supported hashing algorithm. To obtain the SHA-1
hash of a revision:

1. Hash the parent nodes
2. Hash the fulltext of the revision

The 20 byte node ids of the parents are fed into the hasher in ascending order.

Changed Files side-data
=======================

(This feature is in active development and its behavior is not frozen yet. It
should not be used in any production repository)

When the `exp-copies-sidedata-changeset` requirement is in use, information
related to the changed files will be stored as "side-data" for every changeset
in the changelog.

These data contains the following information:

* set of files actively added by the changeset
* set of files actively removed by the changeset
* set of files actively merged by the changeset
* set of files actively touched by he changeset
* mapping of copy-source, copy-destination from first parent (p1)
* mapping of copy-source, copy-destination from second parent (p2)

The block itself is big-endian data, formatted in three sections: header, index,
and data. See below for details:

Header:

    4 bytes: unsigned integer

        total number of entry in the index

Index:

  The index contains an entry for every involved filename. It is sorted by
  filename. The entry use the following format:

    1 byte:  bits field

        This byte hold two different bit fields:

        The 2 lower bits carry copy information:

            `00`: file has not copy information,
            `10`: file is copied from a p1 source,
            `11`: file is copied from a p2 source.

        The 3 next bits carry action information.

            `000`: file was untouched, it exist in the index as copy source,
            `001`: file was actively added
            `010`: file was actively merged
            `011`: file was actively removed
            `100`: reserved for future use
            `101`: file was actively touched in any other way

        (The last 2 bites are unused)

    4 bytes: unsigned integer

        Address (in bytes) of the end of the associated filename in the data
        block. (This is the address of the first byte not part of the filename)

        The start of the filename can be retrieve by reading that field for the
        previous index entry. The filename of the first entry starts at zero.

    4 bytes: unsigned integer

        Index (in this very index) of the source of the copy (when a copy is
        happening). If no copy is happening the value of this field is
        irrelevant and could have any value. It is set to zero by convention

Data:

  raw bytes block containing all filename concatenated without any separator.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         usr/lib/python3/dist-packages/mercurial/helptext/internals/wireprotocol.txt                         0000644 0000000 0000000 00000122517 14355257011 026071  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        The Mercurial wire protocol is a request-response based protocol
with multiple wire representations.

Each request is modeled as a command name, a dictionary of arguments, and
optional raw input. Command arguments and their types are intrinsic
properties of commands. So is the response type of the command. This means
clients can't always send arbitrary arguments to servers and servers can't
return multiple response types.

The protocol is synchronous and does not support multiplexing (concurrent
commands).

Handshake
=========

It is required or common for clients to perform a *handshake* when connecting
to a server. The handshake serves the following purposes:

* Negotiating protocol/transport level options
* Allows the client to learn about server capabilities to influence
  future requests
* Ensures the underlying transport channel is in a *clean* state

An important goal of the handshake is to allow clients to use more modern
wire protocol features. By default, clients must assume they are talking
to an old version of Mercurial server (possibly even the very first
implementation). So, clients should not attempt to call or utilize modern
wire protocol features until they have confirmation that the server
supports them. The handshake implementation is designed to allow both
ends to utilize the latest set of features and capabilities with as
few round trips as possible.

The handshake mechanism varies by transport and protocol and is documented
in the sections below.

HTTP Protocol
=============

Handshake
---------

The client sends a ``capabilities`` command request (``?cmd=capabilities``)
as soon as HTTP requests may be issued.

By default, the server responds with a version 1 capabilities string, which
the client parses to learn about the server's abilities. The ``Content-Type``
for this response is ``application/mercurial-0.1`` or
``application/mercurial-0.2`` depending on whether the client advertised
support for version ``0.2`` in its request. (Clients aren't supposed to
advertise support for ``0.2`` until the capabilities response indicates
the server's support for that media type. However, a client could
conceivably cache this metadata and issue the capabilities request in such
a way to elicit an ``application/mercurial-0.2`` response.)

Clients wishing to switch to a newer API service may send an
``X-HgUpgrade-<X>`` header containing a space-delimited list of API service
names the client is capable of speaking. The request MUST also include an
``X-HgProto-<X>`` header advertising a known serialization format for the
response. ``cbor`` is currently the only defined serialization format.

If the request contains these headers, the response ``Content-Type`` MAY
be for a different media type. e.g. ``application/mercurial-cbor`` if the
client advertises support for CBOR.

The response MUST be deserializable to a map with the following keys:

apibase
   URL path to API services, relative to the repository root. e.g. ``api/``.

apis
   A map of API service names to API descriptors. An API descriptor contains
   more details about that API. In the case of the HTTP Version 2 Transport,
   it will be the normal response to a ``capabilities`` command.

   Only the services advertised by the client that are also available on
   the server are advertised.

v1capabilities
   The capabilities string that would be returned by a version 1 response.

The client can then inspect the server-advertised APIs and decide which
API to use, including continuing to use the HTTP Version 1 Transport.

HTTP Version 1 Transport
------------------------

Commands are issued as HTTP/1.0 or HTTP/1.1 requests. Commands are
sent to the base URL of the repository with the command name sent in
the ``cmd`` query string parameter. e.g.
``https://example.com/repo?cmd=capabilities``. The HTTP method is ``GET``
or ``POST`` depending on the command and whether there is a request
body.

Command arguments can be sent multiple ways.

The simplest is part of the URL query string using ``x-www-form-urlencoded``
encoding (see Python's ``urllib.urlencode()``. However, many servers impose
length limitations on the URL. So this mechanism is typically only used if
the server doesn't support other mechanisms.

If the server supports the ``httpheader`` capability, command arguments can
be sent in HTTP request headers named ``X-HgArg-<N>`` where ``<N>`` is an
integer starting at 1. A ``x-www-form-urlencoded`` representation of the
arguments is obtained. This full string is then split into chunks and sent
in numbered ``X-HgArg-<N>`` headers. The maximum length of each HTTP header
is defined by the server in the ``httpheader`` capability value, which defaults
to ``1024``. The server reassembles the encoded arguments string by
concatenating the ``X-HgArg-<N>`` headers then URL decodes them into a
dictionary.

The list of ``X-HgArg-<N>`` headers should be added to the ``Vary`` request
header to instruct caches to take these headers into consideration when caching
requests.

If the server supports the ``httppostargs`` capability, the client
may send command arguments in the HTTP request body as part of an
HTTP POST request. The command arguments will be URL encoded just like
they would for sending them via HTTP headers. However, no splitting is
performed: the raw arguments are included in the HTTP request body.

The client sends a ``X-HgArgs-Post`` header with the string length of the
encoded arguments data. Additional data may be included in the HTTP
request body immediately following the argument data. The offset of the
non-argument data is defined by the ``X-HgArgs-Post`` header. The
``X-HgArgs-Post`` header is not required if there is no argument data.

Additional command data can be sent as part of the HTTP request body. The
default ``Content-Type`` when sending data is ``application/mercurial-0.1``.
A ``Content-Length`` header is currently always sent.

Example HTTP requests::

    GET /repo?cmd=capabilities
    X-HgArg-1: foo=bar&baz=hello%20world

The request media type should be chosen based on server support. If the
``httpmediatype`` server capability is present, the client should send
the newest mutually supported media type. If this capability is absent,
the client must assume the server only supports the
``application/mercurial-0.1`` media type.

The ``Content-Type`` HTTP response header identifies the response as coming
from Mercurial and can also be used to signal an error has occurred.

The ``application/mercurial-*`` media types indicate a generic Mercurial
data type.

The ``application/mercurial-0.1`` media type is raw Mercurial data. It is the
predecessor of the format below.

The ``application/mercurial-0.2`` media type is compression framed Mercurial
data. The first byte of the payload indicates the length of the compression
format identifier that follows. Next are N bytes indicating the compression
format. e.g. ``zlib``. The remaining bytes are compressed according to that
compression format. The decompressed data behaves the same as with
``application/mercurial-0.1``.

The ``application/hg-error`` media type indicates a generic error occurred.
The content of the HTTP response body typically holds text describing the
error.

The ``application/mercurial-cbor`` media type indicates a CBOR payload
and should be interpreted as identical to ``application/cbor``.

Behavior of media types is further described in the ``Content Negotiation``
section below.

Clients should issue a ``User-Agent`` request header that identifies the client.
The server should not use the ``User-Agent`` for feature detection.

A command returning a ``string`` response issues a
``application/mercurial-0.*`` media type and the HTTP response body contains
the raw string value (after compression decoding, if used). A
``Content-Length`` header is typically issued, but not required.

A command returning a ``stream`` response issues a
``application/mercurial-0.*`` media type and the HTTP response is typically
using *chunked transfer* (``Transfer-Encoding: chunked``).

HTTP Version 2 Transport
------------------------

**Experimental - feature under active development**

Version 2 of the HTTP protocol is exposed under the ``/api/*`` URL space.
It's final API name is not yet formalized.

Commands are triggered by sending HTTP POST requests against URLs of the
form ``<permission>/<command>``, where ``<permission>`` is ``ro`` or
``rw``, meaning read-only and read-write, respectively and ``<command>``
is a named wire protocol command.

Non-POST request methods MUST be rejected by the server with an HTTP
405 response.

Commands that modify repository state in meaningful ways MUST NOT be
exposed under the ``ro`` URL prefix. All available commands MUST be
available under the ``rw`` URL prefix.

Server adminstrators MAY implement blanket HTTP authentication keyed
off the URL prefix. For example, a server may require authentication
