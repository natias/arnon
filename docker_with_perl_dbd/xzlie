
    SV*  get_sv("package::varname", GV_ADD);
    AV*  get_av("package::varname", GV_ADD);
    HV*  get_hv("package::varname", GV_ADD);

Notice the use of GV_ADD as the second parameter.  The new variable can now
be set, using the routines appropriate to the data type.

There are additional macros whose values may be bitwise OR'ed with the
C<GV_ADD> argument to enable certain extra features.  Those bits are:

=over

=item GV_ADDMULTI

Marks the variable as multiply defined, thus preventing the:

  Name <varname> used only once: possible typo

warning.

=item GV_ADDWARN

Issues the warning:

  Had to create <varname> unexpectedly

if the variable did not exist before the function was called.

=back

If you do not specify a package name, the variable is created in the current
package.

=head2 Reference Counts and Mortality

Perl uses a reference count-driven garbage collection mechanism.  SVs,
AVs, or HVs (xV for short in the following) start their life with a
reference count of 1.  If the reference count of an xV ever drops to 0,
then it will be destroyed and its memory made available for reuse.
At the most basic internal level, reference counts can be manipulated
with the following macros:

    int SvREFCNT(SV* sv);
    SV* SvREFCNT_inc(SV* sv);
    void SvREFCNT_dec(SV* sv);

(There are also suffixed versions of the increment and decrement macros,
for situations where the full generality of these basic macros can be
exchanged for some performance.)

However, the way a programmer should think about references is not so
much in terms of the bare reference count, but in terms of I<ownership>
of references.  A reference to an xV can be owned by any of a variety
of entities: another xV, the Perl interpreter, an XS data structure,
a piece of running code, or a dynamic scope.  An xV generally does not
know what entities own the references to it; it only knows how many
references there are, which is the reference count.

To correctly maintain reference counts, it is essential to keep track
of what references the XS code is manipulating.  The programmer should
always know where a reference has come from and who owns it, and be
aware of any creation or destruction of references, and any transfers
of ownership.  Because ownership isn't represented explicitly in the xV
data structures, only the reference count need be actually maintained
by the code, and that means that this understanding of ownership is not
actually evident in the code.  For example, transferring ownership of a
reference from one owner to another doesn't change the reference count
at all, so may be achieved with no actual code.  (The transferring code
doesn't touch the referenced object, but does need to ensure that the
former owner knows that it no longer owns the reference, and that the
new owner knows that it now does.)

An xV that is visible at the Perl level should not become unreferenced
and thus be destroyed.  Normally, an object will only become unreferenced
when it is no longer visible, often by the same means that makes it
invisible.  For example, a Perl reference value (RV) owns a reference to
its referent, so if the RV is overwritten that reference gets destroyed,
and the no-longer-reachable referent may be destroyed as a result.

Many functions have some kind of reference manipulation as
part of their purpose.  Sometimes this is documented in terms
of ownership of references, and sometimes it is (less helpfully)
documented in terms of changes to reference counts.  For example, the
L<newRV_inc()|perlapi/newRV_inc> function is documented to create a new RV
(with reference count 1) and increment the reference count of the referent
that was supplied by the caller.  This is best understood as creating
a new reference to the referent, which is owned by the created RV,
and returning to the caller ownership of the sole reference to the RV.
The L<newRV_noinc()|perlapi/newRV_noinc> function instead does not
increment the reference count of the referent, but the RV nevertheless
ends up owning a reference to the referent.  It is therefore implied
that the caller of C<newRV_noinc()> is relinquishing a reference to the
referent, making this conceptually a more complicated operation even
though it does less to the data structures.

For example, imagine you want to return a reference from an XSUB
function.  Inside the XSUB routine, you create an SV which initially
has just a single reference, owned by the XSUB routine.  This reference
needs to be disposed of before the routine is complete, otherwise it
will leak, preventing the SV from ever being destroyed.  So to create
an RV referencing the SV, it is most convenient to pass the SV to
C<newRV_noinc()>, which consumes that reference.  Now the XSUB routine
no longer owns a reference to the SV, but does own a reference to the RV,
which in turn owns a reference to the SV.  The ownership of the reference
to the RV is then transferred by the process of returning the RV from
the XSUB.

There are some convenience functions available that can help with the
destruction of xVs.  These functions introduce the concept of "mortality".
Much documentation speaks of an xV itself being mortal, but this is
misleading.  It is really I<a reference to> an xV that is mortal, and it
is possible for there to be more than one mortal reference to a single xV.
For a reference to be mortal means that it is owned by the temps stack,
one of perl's many internal stacks, which will destroy that reference
"a short time later".  Usually the "short time later" is the end of
the current Perl statement.  However, it gets more complicated around
dynamic scopes: there can be multiple sets of mortal references hanging
around at the same time, with different death dates.  Internally, the
actual determinant for when mortal xV references are destroyed depends
on two macros, SAVETMPS and FREETMPS.  See L<perlcall> and L<perlxs>
and L</Temporaries Stack> below for more details on these macros.

Mortal references are mainly used for xVs that are placed on perl's
main stack.  The stack is problematic for reference tracking, because it
contains a lot of xV references, but doesn't own those references: they
are not counted.  Currently, there are many bugs resulting from xVs being
destroyed while referenced by the stack, because the stack's uncounted
references aren't enough to keep the xVs alive.  So when putting an
(uncounted) reference on the stack, it is vitally important to ensure that
there will be a counted reference to the same xV that will last at least
as long as the uncounted reference.  But it's also important that that
counted reference be cleaned up at an appropriate time, and not unduly
prolong the xV's life.  For there to be a mortal reference is often the
best way to satisfy this requirement, especially if the xV was created
especially to be put on the stack and would otherwise be unreferenced.

To create a mortal reference, use the functions:

    SV*  sv_newmortal()
    SV*  sv_mortalcopy(SV*)
    SV*  sv_2mortal(SV*)

C<sv_newmortal()> creates an SV (with the undefined value) whose sole
reference is mortal.  C<sv_mortalcopy()> creates an xV whose value is a
copy of a supplied xV and whose sole reference is mortal.  C<sv_2mortal()>
mortalises an existing xV reference: it transfers ownership of a reference
from the caller to the temps stack.  Because C<sv_newmortal> gives the new
SV no value, it must normally be given one via C<sv_setpv>, C<sv_setiv>,
etc. :

    SV *tmp = sv_newmortal();
    sv_setiv(tmp, an_integer);

As that is multiple C statements it is quite common so see this idiom instead:

    SV *tmp = sv_2mortal(newSViv(an_integer));

The mortal routines are not just for SVs; AVs and HVs can be
made mortal by passing their address (type-casted to C<SV*>) to the
C<sv_2mortal> or C<sv_mortalcopy> routines.

=head2 Stashes and Globs

A B<stash> is a hash that contains all variables that are defined
within a package.  Each key of the stash is a symbol
name (shared by all the different types of objects that have the same
name), and each value in the hash table is a GV (Glob Value).  This GV
in turn contains references to the various objects of that name,
including (but not limited to) the following:

    Scalar Value
    Array Value
    Hash Value
    I/O Handle
    Format
    Subroutine

There is a single stash called C<PL_defstash> that holds the items that exist
in the C<main> package.  To get at the items in other packages, append the
string "::" to the package name.  The items in the C<Foo> package are in
the stash C<Foo::> in PL_defstash.  The items in the C<Bar::Baz> package are
in the stash C<Baz::> in C<Bar::>'s stash.

=for apidoc_section $GV
=for apidoc Amnh||PL_defstash

To get the stash pointer for a particular package, use the function:

    HV*  gv_stashpv(const char* name, I32 flags)
    HV*  gv_stashsv(SV*, I32 flags)

The first function takes a literal string, the second uses the string stored
in the SV.  Remember that a stash is just a hash table, so you get back an
C<HV*>.  The C<flags> flag will create a new package if it is set to GV_ADD.

The name that C<gv_stash*v> wants is the name of the package whose symbol table
you want.  The default package is called C<main>.  If you have multiply nested
packages, pass their names to C<gv_stash*v>, separated by C<::> as in the Perl
language itself.

Alternately, if you have an SV that is a blessed reference, you can find
out the stash pointer by using:

    HV*  SvSTASH(SvRV(SV*));

then use the following to get the package name itself:

    char*  HvNAME(HV* stash);

If you need to bless or re-bless an object you can use the following
function:

    SV*  sv_bless(SV*, HV* stash)

where the first argument, an C<SV*>, must be a reference, and the second
argument is a stash.  The returned C<SV*> can now be used in the same way
as any other SV.

For more information on references and blessings, consult L<perlref>.

=head2 I/O Handles

Like AVs and HVs, IO objects are another type of non-scalar SV which
may contain input and output L<PerlIO|perlapio> objects or a C<DIR *>
from opendir().

You can create a new IO object:

    IO*  newIO();

Unlike other SVs, a new IO object is automatically blessed into the
L<IO::File> class.

The IO object contains an input and output PerlIO handle:

  PerlIO *IoIFP(IO *io);
  PerlIO *IoOFP(IO *io);

=for apidoc_section $io
=for apidoc Amh|PerlIO *|IoIFP|IO *io
=for apidoc Amh|PerlIO *|IoOFP|IO *io

Typically if the IO object has been opened on a file, the input handle
is always present, but the output handle is only present if the file
is open for output.  For a file, if both are present they will be the
same PerlIO object.

Distinct input and output PerlIO objects are created for sockets and
character devices.

The IO object also contains other data associated with Perl I/O
handles:

  IV IoLINES(io);                /* $. */
  IV IoPAGE(io);                 /* $% */
  IV IoPAGE_LEN(io);             /* $= */
  IV IoLINES_LEFT(io);           /* $- */
  char *IoTOP_NAME(io);          /* $^ */
  GV *IoTOP_GV(io);              /* $^ */
  char *IoFMT_NAME(io);          /* $~ */
  GV *IoFMT_GV(io);              /* $~ */
  char *IoBOTTOM_NAME(io);
  GV *IoBOTTOM_GV(io);
  char IoTYPE(io);
  U8 IoFLAGS(io);

 =for apidoc_sections $io_scn, $formats_section
=for apidoc_section $reports
=for apidoc Amh|IV|IoLINES|IO *io
=for apidoc Amh|IV|IoPAGE|IO *io
=for apidoc Amh|IV|IoPAGE_LEN|IO *io
=for apidoc Amh|IV|IoLINES_LEFT|IO *io
=for apidoc Amh|char *|IoTOP_NAME|IO *io
=for apidoc Amh|GV *|IoTOP_GV|IO *io
=for apidoc Amh|char *|IoFMT_NAME|IO *io
=for apidoc Amh|GV *|IoFMT_GV|IO *io
=for apidoc Amh|char *|IoBOTTOM_NAME|IO *io
=for apidoc Amh|GV *|IoBOTTOM_GV|IO *io
=for apidoc_section $io
=for apidoc Amh|char|IoTYPE|IO *io
=for apidoc Amh|U8|IoFLAGS|IO *io

Most of these are involved with L<formats|perlform>.

IoFLAGs() may contain a combination of flags, the most interesting of
which are C<IOf_FLUSH> (C<$|>) for autoflush and C<IOf_UNTAINT>,
settable with L<< IO::Handle's untaint() method|IO::Handle/"$io->untaint" >>.

=for apidoc Amnh||IOf_FLUSH
=for apidoc Amnh||IOf_UNTAINT

The IO object may also contains a directory handle:

  DIR *IoDIRP(io);

=for apidoc Amh|DIR *|IoDIRP|IO *io

suitable for use with PerlDir_read() etc.

All of these accessors macros are lvalues, there are no distinct
C<_set()> macros to modify the members of the IO object.

=head2 Double-Typed SVs

Scalar variables normally contain only one type of value, an integer,
double, pointer, or reference.  Perl will automatically convert the
actual scalar data from the stored type into the requested type.

Some scalar variables contain more than one type of scalar data.  For
example, the variable C<$!> contains either the numeric value of C<errno>
or its string equivalent from either C<strerror> or C<sys_errlist[]>.

To force multiple data values into an SV, you must do two things: use the
C<sv_set*v> routines to add the additional scalar type, then set a flag
so that Perl will believe it contains more than one type of data.  The
four macros to set the flags are:

	SvIOK_on
	SvNOK_on
	SvPOK_on
	SvROK_on

The particular macro you must use depends on which C<sv_set*v> routine
you called first.  This is because every C<sv_set*v> routine turns on
only the bit for the particular type of data being set, and turns off
all the rest.

For example, to create a new Perl variable called "dberror" that contains
both the numeric and descriptive string error values, you could use the
following code:

    extern int  dberror;
    extern char *dberror_list;

    SV* sv = get_sv("dberror", GV_ADD);
    sv_setiv(sv, (IV) dberror);
    sv_setpv(sv, dberror_list[dberror]);
    SvIOK_on(sv);

If the order of C<sv_setiv> and C<sv_setpv> had been reversed, then the
macro C<SvPOK_on> would need to be called instead of C<SvIOK_on>.

=head2 Read-Only Values

In Perl 5.16 and earlier, copy-on-write (see the next section) shared a
flag bit with read-only scalars.  So the only way to test whether
C<sv_setsv>, etc., will raise a "Modification of a read-only value" error
in those versions is:

    SvREADONLY(sv) && !SvIsCOW(sv)

Under Perl 5.18 and later, SvREADONLY only applies to read-only variables,
and, under 5.20, copy-on-write scalars can also be read-only, so the above
check is incorrect.  You just want:

    SvREADONLY(sv)

If you need to do this check often, define your own macro like this:

    #if PERL_VERSION >= 18
    # define SvTRULYREADONLY(sv) SvREADONLY(sv)
    #else
    # define SvTRULYREADONLY(sv) (SvREADONLY(sv) && !SvIsCOW(sv))
    #endif

=head2 Copy on Write

Perl implements a copy-on-write (COW) mechanism for scalars, in which
string copies are not immediately made when requested, but are deferred
until made necessary by one or the other scalar changing.  This is mostly
transparent, but one must take care not to modify string buffers that are
shared by multiple SVs.

You can test whether an SV is using copy-on-write with C<SvIsCOW(sv)>.

You can force an SV to make its own copy of its string buffer by calling C<sv_force_normal(sv)> or SvPV_force_nolen(sv).

If you want to make the SV drop its string buffer, use
C<sv_force_normal_flags(sv, SV_COW_DROP_PV)> or simply
C<sv_setsv(sv, NULL)>.

All of these functions will croak on read-only scalars (see the previous
section for more on those).

To test that your code is behaving correctly and not modifying COW buffers,
on systems that support L<mmap(2)> (i.e., Unix) you can configure perl with
C<-Accflags=-DPERL_DEBUG_READONLY_COW> and it will turn buffer violations
into crashes.  You will find it to be marvellously slow, so you may want to
skip perl's own tests.

=head2 Magic Variables

[This section still under construction.  Ignore everything here.  Post no
bills.  Everything not permitted is forbidden.]

Any SV may be magical, that is, it has special features that a normal
SV does not have.  These features are stored in the SV structure in a
linked list of C<struct magic>'s, typedef'ed to C<MAGIC>.

    struct magic {
        MAGIC*      mg_moremagic;
        MGVTBL*     mg_virtual;
        U16         mg_private;
        char        mg_type;
        U8          mg_flags;
        I32         mg_len;
        SV*         mg_obj;
        char*       mg_ptr;
    };

Note this is current as of patchlevel 0, and could change at any time.

=head2 Assigning Magic

Perl adds magic to an SV using the sv_magic function:

  void sv_magic(SV* sv, SV* obj, int how, const char* name, I32 namlen);

The C<sv> argument is a pointer to the SV that is to acquire a new magical
feature.

If C<sv> is not already magical, Perl uses the C<SvUPGRADE> macro to
convert C<sv> to type C<SVt_PVMG>.
Perl then continues by adding new magic
to the beginning of the linked list of magical features.  Any prior entry
of the same type of magic is deleted.  Note that this can be overridden,
and multiple instances of the same type of magic can be associated with an
SV.

The C<name> and C<namlen> arguments are used to associate a string with
the magic, typically the name of a variable.  C<namlen> is stored in the
C<mg_len> field and if C<name> is non-null then either a C<savepvn> copy of
C<name> or C<name> itself is stored in the C<mg_ptr> field, depending on
whether C<namlen> is greater than zero or equal to zero respectively.  As a
special case, if C<(name && namlen == HEf_SVKEY)> then C<name> is assumed
to contain an C<SV*> and is stored as-is with its REFCNT incremented.

The sv_magic function uses C<how> to determine which, if any, predefined
"Magic Virtual Table" should be assigned to the C<mg_virtual> field.
See the L</Magic Virtual Tables> section below.  The C<how> argument is also
stored in the C<mg_type> field.  The value of
C<how> should be chosen from the set of macros
C<PERL_MAGIC_foo> found in F<perl.h>.  Note that before
these macros were added, Perl internals used to directly use character
literals, so you may occasionally come across old code or documentation
referring to 'U' magic rather than C<PERL_MAGIC_uvar> for example.

The C<obj> argument is stored in the C<mg_obj> field of the C<MAGIC>
structure.  If it is not the same as the C<sv> argument, the reference
count of the C<obj> object is incremented.  If it is the same, or if
the C<how> argument is C<PERL_MAGIC_arylen>, C<PERL_MAGIC_regdatum>,
C<PERL_MAGIC_regdata>, or if it is a NULL pointer, then C<obj> is merely
stored, without the reference count being incremented.

See also C<sv_magicext> in L<perlapi> for a more flexible way to add magic
to an SV.

There is also a function to add magic to an C<HV>:

    void hv_magic(HV *hv, GV *gv, int how);

This simply calls C<sv_magic> and coerces the C<gv> argument into an C<SV>.

To remove the magic from an SV, call the function sv_unmagic:

    int sv_unmagic(SV *sv, int type);

The C<type> argument should be equal to the C<how> value when the C<SV>
was initially made magical.

However, note that C<sv_unmagic> removes all magic of a certain C<type> from the
C<SV>.  If you want to remove only certain
magic of a C<type> based on the magic
virtual table, use C<sv_unmagicext> instead:

    int sv_unmagicext(SV *sv, int type, MGVTBL *vtbl);

=head2 Magic Virtual Tables

The C<mg_virtual> field in the C<MAGIC> structure is a pointer to an
C<MGVTBL>, which is a structure of function pointers and stands for
"Magic Virtual Table" to handle the various operations that might be
applied to that variable.

=for apidoc_section $magic
=for apidoc Ayh||MGVTBL

The C<MGVTBL> has five (or sometimes eight) pointers to the following
routine types:

    int  (*svt_get)  (pTHX_ SV* sv, MAGIC* mg);
    int  (*svt_set)  (pTHX_ SV* sv, MAGIC* mg);
    U32  (*svt_len)  (pTHX_ SV* sv, MAGIC* mg);
    int  (*svt_clear)(pTHX_ SV* sv, MAGIC* mg);
    int  (*svt_free) (pTHX_ SV* sv, MAGIC* mg);

    int  (*svt_copy) (pTHX_ SV *sv, MAGIC* mg, SV *nsv,
                                          const char *name, I32 namlen);
    int  (*svt_dup)  (pTHX_ MAGIC *mg, CLONE_PARAMS *param);
    int  (*svt_local)(pTHX_ SV *nsv, MAGIC *mg);


This MGVTBL structure is set at compile-time in F<perl.h> and there are
currently 32 types.  These different structures contain pointers to various
routines that perform additional actions depending on which function is
being called.

   Function pointer    Action taken
   ----------------    ------------
   svt_get             Do something before the value of the SV is
                       retrieved.
   svt_set             Do something after the SV is assigned a value.
   svt_len             Report on the SV's length.
   svt_clear           Clear something the SV represents.
   svt_free            Free any extra storage associated with the SV.

   svt_copy            copy tied variable magic to a tied element
   svt_dup             duplicate a magic structure during thread cloning
   svt_local           copy magic to local value during 'local'

For instance, the MGVTBL structure called C<vtbl_sv> (which corresponds
to an C<mg_type> of C<PERL_MAGIC_sv>) contains:

    { magic_get, magic_set, magic_len, 0, 0 }

Thus, when an SV is determined to be magical and of type C<PERL_MAGIC_sv>,
if a get operation is being performed, the routine C<magic_get> is
called.  All the various routines for the various magical types begin
with C<magic_>.  NOTE: the magic routines are not considered part of
the Perl API, and may not be exported by the Perl library.

The last three slots are a recent addition, and for source code
compatibility they are only checked for if one of the three flags
C<MGf_COPY>, C<MGf_DUP>, or C<MGf_LOCAL> is set in mg_flags.
This means that most code can continue declaring
a vtable as a 5-element value.  These three are
currently used exclusively by the threading code, and are highly subject
to change.

=for apidoc_section $magic
=for apidoc  Amnh||MGf_COPY
=for apidoc_item ||MGf_DUP
=for apidoc_item ||MGf_LOCAL

The current kinds of Magic Virtual Tables are:

=for comment
This table is generated by regen/mg_vtable.pl.  Any changes made here
will be lost.

=for mg_vtable.pl begin

 mg_type
 (old-style char and macro)   MGVTBL         Type of magic
 --------------------------   ------         -------------
 \0 PERL_MAGIC_sv             vtbl_sv        Special scalar variable
 #  PERL_MAGIC_arylen         vtbl_arylen    Array length ($#ary)
 %  PERL_MAGIC_rhash          (none)         Extra data for restricted
                                             hashes
 *  PERL_MAGIC_debugvar       vtbl_debugvar  $DB::single, signal, trace
                                             vars
 .  PERL_MAGIC_pos            vtbl_pos       pos() lvalue
 :  PERL_MAGIC_symtab         (none)         Extra data for symbol
                                             tables
 <  PERL_MAGIC_backref        vtbl_backref   For weak ref data
 @  PERL_MAGIC_arylen_p       (none)         To move arylen out of XPVAV
 B  PERL_MAGIC_bm             vtbl_regexp    Boyer-Moore
                                             (fast string search)
 c  PERL_MAGIC_overload_table vtbl_ovrld     Holds overload table
                                             (AMT) on stash
 D  PERL_MAGIC_regdata        vtbl_regdata   Regex match position data
                                             (@+ and @- vars)
 d  PERL_MAGIC_regdatum       vtbl_regdatum  Regex match position data
                                             element
 E  PERL_MAGIC_env            vtbl_env       %ENV hash
 e  PERL_MAGIC_envelem        vtbl_envelem   %ENV hash element
 f  PERL_MAGIC_fm             vtbl_regexp    Formline
                                             ('compiled' format)
 g  PERL_MAGIC_regex_global   vtbl_mglob     m//g target
 H  PERL_MAGIC_hints          vtbl_hints     %^H hash
 h  PERL_MAGIC_hintselem      vtbl_hintselem %^H hash element
 I  PERL_MAGIC_isa            vtbl_isa       @ISA array
 i  PERL_MAGIC_isaelem        vtbl_isaelem   @ISA array element
 k  PERL_MAGIC_nkeys          vtbl_nkeys     scalar(keys()) lvalue
 L  PERL_MAGIC_dbfile         (none)         Debugger %_<filename
 l  PERL_MAGIC_dbline         vtbl_dbline    Debugger %_<filename
                                             element
 N  PERL_MAGIC_shared         (none)         Shared between threads
 n  PERL_MAGIC_shared_scalar  (none)         Shared between threads
 o  PERL_MAGIC_collxfrm       vtbl_collxfrm  Locale transformation
 P  PERL_MAGIC_tied           vtbl_pack      Tied array or hash
 p  PERL_MAGIC_tiedelem       vtbl_packelem  Tied array or hash element
 q  PERL_MAGIC_tiedscalar     vtbl_packelem  Tied scalar or handle
 r  PERL_MAGIC_qr             vtbl_regexp    Precompiled qr// regex
 S  PERL_MAGIC_sig            vtbl_sig       %SIG hash
 s  PERL_MAGIC_sigelem        vtbl_sigelem   %SIG hash element
 t  PERL_MAGIC_taint          vtbl_taint     Taintedness
 U  PERL_MAGIC_uvar           vtbl_uvar      Available for use by
                                             extensions
 u  PERL_MAGIC_uvar_elem      (none)         Reserved for use by
                                             extensions
 V  PERL_MAGIC_vstring        (none)         SV was vstring literal
 v  PERL_MAGIC_vec            vtbl_vec       vec() lvalue
 w  PERL_MAGIC_utf8           vtbl_utf8      Cached UTF-8 information
 X  PERL_MAGIC_destruct       vtbl_destruct  destruct callback
 x  PERL_MAGIC_substr         vtbl_substr    substr() lvalue
 Y  PERL_MAGIC_nonelem        vtbl_nonelem   Array element that does not
                                             exist
 y  PERL_MAGIC_defelem        vtbl_defelem   Shadow "foreach" iterator
                                             variable / smart parameter
                                             vivification
 Z  PERL_MAGIC_hook           vtbl_hook      %{^HOOK} hash
 z  PERL_MAGIC_hookelem       vtbl_hookelem  %{^HOOK} hash element
 \  PERL_MAGIC_lvref          vtbl_lvref     Lvalue reference
                                             constructor
 ]  PERL_MAGIC_checkcall      vtbl_checkcall Inlining/mutation of call
                                             to this CV
 ^  PERL_MAGIC_extvalue       (none)         Value magic available for
                                             use by extensions
 ~  PERL_MAGIC_ext            (none)         Variable magic available
                                             for use by extensions


=for apidoc_section $magic
=for apidoc AmnhU||PERL_MAGIC_arylen
=for apidoc_item ||PERL_MAGIC_arylen_p
=for apidoc_item ||PERL_MAGIC_backref
=for apidoc_item ||PERL_MAGIC_bm
=for apidoc_item ||PERL_MAGIC_checkcall
=for apidoc_item ||PERL_MAGIC_collxfrm
=for apidoc_item ||PERL_MAGIC_dbfile
=for apidoc_item ||PERL_MAGIC_dbline
=for apidoc_item ||PERL_MAGIC_debugvar
=for apidoc_item ||PERL_MAGIC_defelem
=for apidoc_item ||PERL_MAGIC_destruct
=for apidoc_item ||PERL_MAGIC_env
=for apidoc_item ||PERL_MAGIC_envelem
=for apidoc_item ||PERL_MAGIC_ext
=for apidoc_item ||PERL_MAGIC_extvalue
=for apidoc_item ||PERL_MAGIC_fm
=for apidoc_item ||PERL_MAGIC_hints
=for apidoc_item ||PERL_MAGIC_hintselem
=for apidoc_item ||PERL_MAGIC_hook
=for apidoc_item ||PERL_MAGIC_hookelem
=for apidoc_item ||PERL_MAGIC_isa
=for apidoc_item ||PERL_MAGIC_isaelem
=for apidoc_item ||PERL_MAGIC_lvref
=for apidoc_item ||PERL_MAGIC_nkeys
=for apidoc_item ||PERL_MAGIC_nonelem
=for apidoc_item ||PERL_MAGIC_overload_table
=for apidoc_item ||PERL_MAGIC_pos
=for apidoc_item ||PERL_MAGIC_qr
=for apidoc_item ||PERL_MAGIC_regdata
=for apidoc_item ||PERL_MAGIC_regdatum
=for apidoc_item ||PERL_MAGIC_regex_global
=for apidoc_item ||PERL_MAGIC_rhash
=for apidoc_item ||PERL_MAGIC_shared
=for apidoc_item ||PERL_MAGIC_shared_scalar
=for apidoc_item ||PERL_MAGIC_sig
=for apidoc_item ||PERL_MAGIC_sigelem
=for apidoc_item ||PERL_MAGIC_substr
=for apidoc_item ||PERL_MAGIC_sv
=for apidoc_item ||PERL_MAGIC_symtab
=for apidoc_item ||PERL_MAGIC_taint
=for apidoc_item ||PERL_MAGIC_tied
=for apidoc_item ||PERL_MAGIC_tiedelem
=for apidoc_item ||PERL_MAGIC_tiedscalar
=for apidoc_item ||PERL_MAGIC_utf8
=for apidoc_item ||PERL_MAGIC_uvar
=for apidoc_item ||PERL_MAGIC_uvar_elem
=for apidoc_item ||PERL_MAGIC_vec
=for apidoc_item ||PERL_MAGIC_vstring

=for mg_vtable.pl end

When an uppercase and lowercase letter both exist in the table, then the
uppercase letter is typically used to represent some kind of composite type
(a list or a hash), and the lowercase letter is used to represent an element
of that composite type.  Some internals code makes use of this case
relationship.  However, 'v' and 'V' (vec and v-string) are in no way related.

The C<PERL_MAGIC_ext>, C<PERL_MAGIC_extvalue> and C<PERL_MAGIC_uvar> magic types
are defined specifically for use by extensions and will not be used by perl
itself.  Extensions can use C<PERL_MAGIC_ext> or C<PERL_MAGIC_extvalue> magic to
'attach' private information to variables (typically objects).  This is
especially useful because there is no way for normal perl code to corrupt this
private information (unlike using extra elements of a hash object).
C<PERL_MAGIC_extvalue> is value magic (unlike C<PERL_MAGIC_ext> and
C<PERL_MAGIC_uvar>) meaning that on localization the new value will not be
magical.

Similarly, C<PERL_MAGIC_uvar> magic can be used much like tie() to call a
C function any time a scalar's value is used or changed.  The C<MAGIC>'s
C<mg_ptr> field points to a C<ufuncs> structure:

    struct ufuncs {
        I32 (*uf_val)(pTHX_ IV, SV*);
        I32 (*uf_set)(pTHX_ IV, SV*);
        IV uf_index;
    };

When the SV is read from or written to, the C<uf_val> or C<uf_set>
function will be called with C<uf_index> as the first arg and a pointer to
the SV as the second.  A simple example of how to add C<PERL_MAGIC_uvar>
magic is shown below.  Note that the ufuncs structure is copied by
sv_magic, so you can safely allocate it on the stack.

    void
    Umagic(sv)
        SV *sv;
    PREINIT:
        struct ufuncs uf;
    CODE:
        uf.uf_val   = &my_get_fn;
        uf.uf_set   = &my_set_fn;
        uf.uf_index = 0;
        sv_magic(sv, 0, PERL_MAGIC_uvar, (char*)&uf, sizeof(uf));

Attaching C<PERL_MAGIC_uvar> to arrays is permissible but has no effect.

For hashes there is a specialized hook that gives control over hash
keys (but not values).  This hook calls C<PERL_MAGIC_uvar> 'get' magic
if the "set" function in the C<ufuncs> structure is NULL.  The hook
is activated whenever the hash is accessed with a key specified as
an C<SV> through the functions C<hv_store_ent>, C<hv_fetch_ent>,
C<hv_delete_ent>, and C<hv_exists_ent>.  Accessing the key as a string
through the functions without the C<..._ent> suffix circumvents the
hook.  See L<Hash::Util::FieldHash/GUTS> for a detailed description.

Note that because multiple extensions may be using C<PERL_MAGIC_ext>
or C<PERL_MAGIC_uvar> magic, it is important for extensions to take
extra care to avoid conflict.  Typically only using the magic on
objects blessed into the same class as the extension is sufficient.
For C<PERL_MAGIC_ext> magic, it is usually a good idea to define an
C<MGVTBL>, even if all its fields will be C<0>, so that individual
C<MAGIC> pointers can be identified as a particular kind of magic
using their magic virtual table.  C<mg_findext> provides an easy way
to do that:

    STATIC MGVTBL my_vtbl = { 0, 0, 0, 0, 0, 0, 0, 0 };

    MAGIC *mg;
    if ((mg = mg_findext(sv, PERL_MAGIC_ext, &my_vtbl))) {
        /* this is really ours, not another module's PERL_MAGIC_ext */
        my_priv_data_t *priv = (my_priv_data_t *)mg->mg_ptr;
        ...
    }

Also note that the C<sv_set*()> and C<sv_cat*()> functions described
earlier do B<not> invoke 'set' magic on their targets.  This must
be done by the user either by calling the C<SvSETMAGIC()> macro after
calling these functions, or by using one of the C<sv_set*_mg()> or
C<sv_cat*_mg()> functions.  Similarly, generic C code must call the
C<SvGETMAGIC()> macro to invoke any 'get' magic if they use an SV
obtained from external sources in functions that don't handle magic.
See L<perlapi> for a description of these functions.
For example, calls to the C<sv_cat*()> functions typically need to be
followed by C<SvSETMAGIC()>, but they don't need a prior C<SvGETMAGIC()>
since their implementation handles 'get' magic.

=head2 Finding Magic

    MAGIC *mg_find(SV *sv, int type); /* Finds the magic pointer of that
                                       * type */

This routine returns a pointer to a C<MAGIC> structure stored in the SV.
If the SV does not have that magical
feature, C<NULL> is returned.  If the
SV has multiple instances of that magical feature, the first one will be
returned.  C<mg_findext> can be used
to find a C<MAGIC> structure of an SV
based on both its magic type and its magic virtual table:

    MAGIC *mg_findext(SV *sv, int type, MGVTBL *vtbl);

Also, if the SV passed to C<mg_find> or C<mg_findext> is not of type
SVt_PVMG, Perl may core dump.

    int mg_copy(SV* sv, SV* nsv, const char* key, STRLEN klen);

This routine checks to see what types of magic C<sv> has.  If the mg_type
field is an uppercase letter, then the mg_obj is copied to C<nsv>, but
the mg_type field is changed to be the lowercase letter.

=head2 Understanding the Magic of Tied Hashes and Arrays

Tied hashes and arrays are magical beasts of the C<PERL_MAGIC_tied>
magic type.

WARNING: As of the 5.004 release, proper usage of the array and hash
access functions requires understanding a few caveats.  Some
of these caveats are actually considered bugs in the API, to be fixed
in later releases, and are bracketed with [MAYCHANGE] below.  If
you find yourself actually applying such information in this section, be
aware that the behavior may change in the future, umm, without warning.

The perl tie function associates a variable with an object that implements
the various GET, SET, etc methods.  To perform the equivalent of the perl
tie function from an XSUB, you must mimic this behaviour.  The code below
carries out the necessary steps -- firstly it creates a new hash, and then
creates a second hash which it blesses into the class which will implement
the tie methods.  Lastly it ties the two hashes together, and returns a
reference to the new tied hash.  Note that the code below does NOT call the
TIEHASH method in the MyTie class -
see L</Calling Perl Routines from within C Programs> for details on how
to do this.

    SV*
    mytie()
    PREINIT:
        HV *hash;
        HV *stash;
        SV *tie;
    CODE:
        hash = newHV();
        tie = newRV_noinc((SV*)newHV());
        stash = gv_stashpv("MyTie", GV_ADD);
        sv_bless(tie, stash);
        hv_magic(hash, (GV*)tie, PERL_MAGIC_tied);
        SvREFCNT_dec(tie); /* hv_magic() increases tie ref count */
        RETVAL = newRV_noinc(hash);
    OUTPUT:
        RETVAL

The C<av_store> function, when given a tied array argument, merely
copies the magic of the array onto the value to be "stored", using
C<mg_copy>.  It may also return NULL, indicating that the value did not
actually need to be stored in the array.  [MAYCHANGE] After a call to
C<av_store> on a tied array, the caller will usually need to call
C<mg_set(val)> to actually invoke the perl level "STORE" method on the
TIEARRAY object.  If C<av_store> did return NULL, a call to
C<SvREFCNT_dec(val)> will also be usually necessary to avoid a memory
leak. [/MAYCHANGE]

The previous paragraph is applicable verbatim to tied hash access using the
C<hv_store> and C<hv_store_ent> functions as well.

C<av_fetch> and the corresponding hash functions C<hv_fetch> and
C<hv_fetch_ent> actually return an undefined mortal value whose magic
has been initialized using C<mg_copy>.  Note the value so returned does not
need to be deallocated, as it is already mortal.  [MAYCHANGE] But you will
need to call C<mg_get()> on the returned value in order to actually invoke
the perl level "FETCH" method on the underlying TIE object.  Similarly,
you may also call C<mg_set()> on the return value after possibly assigning
a suitable value to it using C<sv_setsv>,  which will invoke the "STORE"
method on the TIE object. [/MAYCHANGE]

[MAYCHANGE]
In other words, the array or hash fetch/store functions don't really
fetch and store actual values in the case of tied arrays and hashes.  They
merely call C<mg_copy> to attach magic to the values that were meant to be
"stored" or "fetched".  Later calls to C<mg_get> and C<mg_set> actually
do the job of invoking the TIE methods on the underlying objects.  Thus
the magic mechanism currently implements a kind of lazy access to arrays
and hashes.

Currently (as of perl version 5.004), use of the hash and array access
functions requires the user to be aware of whether they are operating on
"normal" hashes and arrays, or on their tied variants.  The API may be
changed to provide more transparent access to both tied and normal data
types in future versions.
[/MAYCHANGE]

You would do well to understand that the TIEARRAY and TIEHASH interfaces
are mere sugar to invoke some perl method calls while using the uniform hash
and array syntax.  The use of this sugar imposes some overhead (typically
about two to four extra opcodes per FETCH/STORE operation, in addition to
the creation of all the mortal variables required to invoke the methods).
This overhead will be comparatively small if the TIE methods are themselves
substantial, but if they are only a few statements long, the overhead
will not be insignificant.

=head2 Localizing changes

Perl has a very handy construction

  {
    local $var = 2;
    ...
  }

This construction is I<approximately> equivalent to

  {
    my $oldvar = $var;
    $var = 2;
    ...
    $var = $oldvar;
  }

The biggest difference is that the first construction would
reinstate the initial value of $var, irrespective of how control exits
the block: C<goto>, C<return>, C<die>/C<eval>, etc.  It is a little bit
more efficient as well.

There is a way to achieve a similar task from C via Perl API: create a
I<pseudo-block>, and arrange for some changes to be automatically
undone at the end of it, either explicit, or via a non-local exit (via
die()).  A I<block>-like construct is created by a pair of
C<ENTER>/C<LEAVE> macros (see L<perlcall/"Returning a Scalar">).
Such a construct may be created specially for some important localized
task, or an existing one (like boundaries of enclosing Perl
subroutine/block, or an existing pair for freeing TMPs) may be
used.  (In the second case the overhead of additional localization must
be almost negligible.)  Note that any XSUB is automatically enclosed in
an C<ENTER>/C<LEAVE> pair.

Inside such a I<pseudo-block> the following service is available:

=over 4

=item C<SAVEINT(int i)>

=item C<SAVEIV(IV i)>

=item C<SAVEI32(I32 i)>

=item C<SAVELONG(long i)>

=item C<SAVEI8(I8 i)>

=item C<SAVEI16(I16 i)>

=item C<SAVEBOOL(int i)>

=item C<SAVESTRLEN(STRLEN i)>

These macros arrange things to restore the value of integer variable
C<i> at the end of the enclosing I<pseudo-block>.

=for apidoc_section $callback
=for apidoc Amh||SAVEINT|int i
=for apidoc Amh||SAVEIV|IV i
=for apidoc Amh||SAVEI32|I32 i
=for apidoc Amh||SAVELONG|long i
=for apidoc Amh||SAVEI8|I8 i
=for apidoc Amh||SAVEI16|I16 i
=for apidoc Amh||SAVEBOOL|bool i
=for apidoc Amh||SAVESTRLEN|STRLEN i

=item C<SAVESPTR(s)>

=item C<SAVEPPTR(p)>

These macros arrange things to restore the value of pointers C<s> and
C<p>.  C<s> must be a pointer of a type which survives conversion to
C<SV*> and back, C<p> should be able to survive conversion to C<char*>
and back.

=for apidoc Amh||SAVESPTR|SV * s
=for apidoc Amh||SAVEPPTR|char * p

=item C<SAVERCPV(char **ppv)>

This macro arranges to restore the value of a C<char *> variable which
was allocated with a call to C<rcpv_new()> to its previous state when
the current pseudo block is completed. The pointer stored in C<*ppv> at
the time of the call will be refcount incremented and stored on the save
stack. Later when the current I<pseudo-block> is completed the value
stored in C<*ppv> will be refcount decremented, and the previous value
restored from the savestack which will also be refcount decremented.

This is the C<RCPV> equivalent of C<SAVEGENERICSV()>.

=for apidoc Amh||SAVERCPV|char *pv

=item C<SAVEGENERICSV(SV **psv)>

This macro arranges to restore the value of a C<SV *> variable to its
previous state when the current pseudo block is completed. The pointer
stored in C<*psv> at the time of the call will be refcount incremented
and stored on the save stack. Later when the current I<pseudo-block> is
completed the value stored in C<*ppv> will be refcount decremented, and
the previous value restored from the savestack which will also be refcount
decremented. This the C equivalent of C<local $sv>.

=for apidoc Amh||SAVEGENERICSV|char **psv

=item C<SAVEFREESV(SV *sv)>

The refcount of C<sv> will be decremented at the end of
I<pseudo-block>.  This is similar to C<sv_2mortal> in that it is also a
mechanism for doing a delayed C<SvREFCNT_dec>.  However, while C<sv_2mortal>
extends the lifetime of C<sv> until the beginning of the next statement,
C<SAVEFREESV> extends it until the end of the enclosing scope.  These
lifetimes can be wildly different.

Also compare C<SAVEMORTALIZESV>.

=for apidoc Amh||SAVEFREESV|SV* sv

=item C<SAVEMORTALIZESV(SV *sv)>

Just like C<SAVEFREESV>, but mortalizes C<sv> at the end of the current
scope instead of decrementing its reference count.  This usually has the
effect of keeping C<sv> alive until the statement that called the currently
live scope has finished executing.

=for apidoc Amh||SAVEMORTALIZESV|SV* sv
