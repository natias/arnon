  $exp_doc .= <<EOD unless $skip_exporter;
#=head2 Exportable functions
#
EOD

#  $exp_doc .= <<EOD if $opt_p;
#When accessing these functions from Perl, prefix C<$opt_p> should be removed.
#
#EOD
  $exp_doc .= <<EOD unless $skip_exporter;
#  @{[join "\n  ", @known_fnames{@fnames}]}
#
EOD
}

my $meth_doc = '';

if ($opt_x && $opt_a) {
  my($name, $struct);
  $meth_doc .= accessor_docs($name, $struct)
    while ($name, $struct) = each %structs;
}

# Prefix the default licence with hash symbols.
# Is this just cargo cult - it seems that the first thing that happens to this
# block is that all the hashes are then s///g out.
my $licence_hash = $licence;
$licence_hash =~ s/^/#/gm;

my $pod;
$pod = <<"END" unless $opt_P;
## Below is stub documentation for your module. You'd better edit it!
#
#=head1 NAME
#
#$module - Perl extension for blah blah blah
#
#=head1 SYNOPSIS
#
#  use $module;
#  blah blah blah
#
#=head1 DESCRIPTION
#
#Stub documentation for $module, created by h2xs. It looks like the
#author of the extension was negligent enough to leave the stub
#unedited.
#
#Blah blah blah.
$exp_doc$meth_doc$revhist
#
#=head1 SEE ALSO
#
#Mention other useful documentation such as the documentation of
#related modules or operating system documentation (such as man pages
#in UNIX), or any relevant external documentation such as RFCs or
#standards.
#
#If you have a mailing list set up for your module, mention it here.
#
#If you have a web site set up for your module, mention it here.
#
#=head1 AUTHOR
#
#$author, E<lt>${email}E<gt>
#
#=head1 COPYRIGHT AND LICENSE
#
$licence_hash
#
#=cut
END

$pod =~ s/^\#//gm unless $opt_P;
print PM $pod unless $opt_P;

close PM;


if( ! $opt_X ){ # print XS, unless it is disabled
warn "Writing $ext$modpname/$modfname.xs\n";

print XS <<"END";
#define PERL_NO_GET_CONTEXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

END

print XS <<"END" unless $skip_ppport;
#include "ppport.h"

END

if( @path_h ){
    foreach my $path_h (@path_h_ini) {
	my($h) = $path_h;
	$h =~ s#^/usr/include/##;
	if ($^O eq 'VMS') { $h =~ s#.*vms\]#sys/# or $h =~ s#.*[:>\]]##; }
        print XS qq{#include <$h>\n};
    }
    print XS "\n";
}

print XS <<"END" if $opt_g;

/* Global Data */

#define MY_CXT_KEY "${module}::_guts" XS_VERSION

typedef struct {
    /* Put Global Data in here */
    int dummy;		/* you can access this elsewhere as MY_CXT.dummy */
} my_cxt_t;

START_MY_CXT

END

my %pointer_typedefs;
my %struct_typedefs;

sub td_is_pointer {
  my $type = shift;
  my $out = $pointer_typedefs{$type};
  return $out if defined $out;
  my $otype = $type;
  $out = ($type =~ /\*$/);
  # This converts only the guys which do not have trailing part in the typedef
  if (not $out
      and $typedef_rex and $type =~ s/($typedef_rex)/$typedefs_pre{$1}/go) {
    $type = normalize_type($type);
    print "Is-Pointer: Type mutation via typedefs: $otype ==> $type\n"
      if $opt_d;
    $out = td_is_pointer($type);
  }
  return ($pointer_typedefs{$otype} = $out);
}

sub td_is_struct {
  my $type = shift;
  my $out = $struct_typedefs{$type};
  return $out if defined $out;
  my $otype = $type;
  $out = ($type =~ /^(struct|union)\b/) && !td_is_pointer($type);
  # This converts only the guys which do not have trailing part in the typedef
  if (not $out
      and $typedef_rex and $type =~ s/($typedef_rex)/$typedefs_pre{$1}/go) {
    $type = normalize_type($type);
    print "Is-Struct: Type mutation via typedefs: $otype ==> $type\n"
      if $opt_d;
    $out = td_is_struct($type);
  }
  return ($struct_typedefs{$otype} = $out);
}

print_tievar_subs(\*XS, $_, $vdecl_hash{$_}) for @vdecls;

if( ! $opt_c ) {
  # We write the "sample" files used when this module is built by perl without
  # ExtUtils::Constant.
  # h2xs will later check that these are the same as those generated by the
  # code embedded into Makefile.PL
  unless (-d $fallbackdirname) {
    mkdir "$fallbackdirname" or die "Cannot mkdir $fallbackdirname: $!\n";
  }
  warn "Writing $ext$modpname/$fallbackdirname/$constscfname\n";
  warn "Writing $ext$modpname/$fallbackdirname/$constsxsfname\n";
  my $cfallback = File::Spec->catfile($fallbackdirname, $constscfname);
  my $xsfallback = File::Spec->catfile($fallbackdirname, $constsxsfname);
  WriteConstants ( C_FILE =>       $cfallback,
                   XS_FILE =>      $xsfallback,
                   DEFAULT_TYPE => $opt_t,
                   NAME =>         $module,
                   NAMES =>        \@const_specs,
                 );
  print XS "#include \"$constscfname\"\n";
}


my $prefix = defined $opt_p ? "PREFIX = $opt_p" : '';

# Now switch from C to XS by issuing the first MODULE declaration:
print XS <<"END";

MODULE = $module		PACKAGE = $module		$prefix

END

# If a constant() function was #included then output a corresponding
# XS declaration:
print XS "INCLUDE: $constsxsfname\n" unless $opt_c;

print XS <<"END" if $opt_g;

BOOT:
{
    MY_CXT_INIT;
    /* If any of the fields in the my_cxt_t struct need
       to be initialised, do it here.
     */
}

END

foreach (sort keys %const_xsub) {
    print XS <<"END";
char *
$_()

    CODE:
#ifdef $_
	RETVAL = $_;
#else
	croak("Your vendor has not defined the $module macro $_");
#endif

    OUTPUT:
	RETVAL

END
}

my %seen_decl;
my %typemap;

sub print_decl {
  my $fh = shift;
  my $decl = shift;
  my ($type, $name, $args) = @$decl;
  return if $seen_decl{$name}++; # Need to do the same for docs as well?

  my @argnames = map {$_->[1]} @$args;
  my @argtypes = map { normalize_type( $_->[0], 1 ) } @$args;
  if ($opt_k) {
    s/^\s*const\b\s*// for @argtypes;
  }
  my @argarrays = map { $_->[4] || '' } @$args;
  my $numargs = @$args;
  if ($numargs and $argtypes[-1] eq '...') {
    $numargs--;
    $argnames[-1] = '...';
  }
  local $" = ', ';
  $type = normalize_type($type, 1);

  print $fh <<"EOP";

$type
$name(@argnames)
EOP

  for my $arg (0 .. $numargs - 1) {
    print $fh <<"EOP";
	$argtypes[$arg]	$argnames[$arg]$argarrays[$arg]
EOP
  }
}

sub print_tievar_subs {
  my($fh, $name, $type) = @_;
  print $fh <<END;
I32
_get_$name(IV index, SV *sv) {
    dSP;
    PUSHMARK(SP);
    XPUSHs(sv);
    PUTBACK;
    (void)call_pv("$module\::_get_$name", G_DISCARD);
    return (I32)0;
}

I32
_set_$name(IV index, SV *sv) {
    dSP;
    PUSHMARK(SP);
    XPUSHs(sv);
    PUTBACK;
    (void)call_pv("$module\::_set_$name", G_DISCARD);
    return (I32)0;
}

END
}

sub print_tievar_xsubs {
  my($fh, $name, $type) = @_;
  print $fh <<END;
void
_tievar_$name(sv)
	SV* sv
    PREINIT:
	struct ufuncs uf;
    CODE:
	uf.uf_val = &_get_$name;
	uf.uf_set = &_set_$name;
	uf.uf_index = (IV)&_get_$name;
	sv_magic(sv, 0, 'U', (char*)&uf, sizeof(uf));

void
_get_$name(THIS)
	$type THIS = NO_INIT
    CODE:
	THIS = $name;
    OUTPUT:
	SETMAGIC: DISABLE
	THIS

void
_set_$name(THIS)
	$type THIS
    CODE:
	$name = THIS;

END
}

sub print_accessors {
  my($fh, $name, $struct) = @_;
  return unless defined $struct && $name !~ /\s|_ANON/;
  $name = normalize_type($name);
  my $ptrname = normalize_type("$name *");
  print $fh <<"EOF";

MODULE = $module		PACKAGE = ${name}		$prefix

$name *
_to_ptr(THIS)
	$name THIS = NO_INIT
    PROTOTYPE: \$
    CODE:
	if (sv_derived_from(ST(0), "$name")) {
	    STRLEN len;
	    char *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(THIS))
		croak("Size \%d of packed data != expected \%d",
			len, sizeof(THIS));
	    RETVAL = ($name *)s;
	}
	else
	    croak("THIS is not of type $name");
    OUTPUT:
	RETVAL

$name
new(CLASS)
	char *CLASS = NO_INIT
    PROTOTYPE: \$
    CODE:
	Zero((void*)&RETVAL, sizeof(RETVAL), char);
    OUTPUT:
	RETVAL

MODULE = $module		PACKAGE = ${name}Ptr		$prefix

EOF
  my @items = @$struct;
  while (@items) {
    my $item = shift @items;
    if ($item->[0] =~ /_ANON/) {
      if (defined $item->[2]) {
	push @items, map [
	  @$_[0, 1], "$item->[2]_$_->[2]", "$item->[2].$_->[2]",
	], @{ $structs{$item->[0]} };
      } else {
	push @items, @{ $structs{$item->[0]} };
      }
    } else {
      my $type = normalize_type($item->[0]);
      my $ttype = $structs{$type} ? normalize_type("$type *") : $type;
      print $fh <<"EOF";
$ttype
$item->[2](THIS, __value = NO_INIT)
	$ptrname THIS
	$type __value
    PROTOTYPE: \$;\$
    CODE:
	if (items > 1)
	    THIS->$item->[-1] = __value;
	RETVAL = @{[
	    $type eq $ttype ? "THIS->$item->[-1]" : "&(THIS->$item->[-1])"
	]};
    OUTPUT:
	RETVAL

EOF
    }
  }
}

sub accessor_docs {
  my($name, $struct) = @_;
  return unless defined $struct && $name !~ /\s|_ANON/;
  $name = normalize_type($name);
  my $ptrname = $name . 'Ptr';
  my @items = @$struct;
  my @list;
  while (@items) {
    my $item = shift @items;
    if ($item->[0] =~ /_ANON/) {
      if (defined $item->[2]) {
	push @items, map [
	  @$_[0, 1], "$item->[2]_$_->[2]", "$item->[2].$_->[2]",
	], @{ $structs{$item->[0]} };
      } else {
	push @items, @{ $structs{$item->[0]} };
      }
    } else {
      push @list, $item->[2];
    }
  }
  my $methods = (join '(...)>, C<', @list) . '(...)';

  my $pod = <<"EOF";
#
#=head2 Object and class methods for C<$name>/C<$ptrname>
#
#The principal Perl representation of a C object of type C<$name> is an
#object of class C<$ptrname> which is a reference to an integer
#representation of a C pointer.  To create such an object, one may use
#a combination
#
#  my \$buffer = $name->new();
#  my \$obj = \$buffer->_to_ptr();
#
#This exercises the following two methods, and an additional class
#C<$name>, the internal representation of which is a reference to a
#packed string with the C structure.  Keep in mind that \$buffer should
#better survive longer than \$obj.
#
#=over
#
#=item C<\$object_of_type_$name-E<gt>_to_ptr()>
#
#Converts an object of type C<$name> to an object of type C<$ptrname>.
#
#=item C<$name-E<gt>new()>
#
#Creates an empty object of type C<$name>.  The corresponding packed
#string is zeroed out.
#
#=item C<$methods>
#
#return the current value of the corresponding element if called
#without additional arguments.  Set the element to the supplied value
#(and return the new value) if called with an additional argument.
#
#Applicable to objects of type C<$ptrname>.
#
#=back
#
EOF
  $pod =~ s/^\#//gm;
  return $pod;
}

# Should be called before any actual call to normalize_type().
sub get_typemap {
  # We do not want to read ./typemap by obvios reasons.
  my @tm =  qw(../../../typemap ../../typemap ../typemap);
  my $stdtypemap =  "$Config::Config{privlib}/ExtUtils/typemap";
  unshift @tm, $stdtypemap;
  my $proto_re = "[" . quotemeta('\$%&*@;') . "]" ;

  # Start with useful default values
  $typemap{float} = 'T_NV';

  foreach my $typemap (@tm) {
    next unless -e $typemap ;
    # skip directories, binary files etc.
    warn " Scanning $typemap\n";
    warn("Warning: ignoring non-text typemap file '$typemap'\n"), next
      unless -T $typemap ;
    open(TYPEMAP, "<", $typemap)
      or warn ("Warning: could not open typemap file '$typemap': $!\n"), next;
    my $mode = 'Typemap';
    while (<TYPEMAP>) {
      next if /^\s*\#/;
      if (/^INPUT\s*$/)   { $mode = 'Input'; next; }
      elsif (/^OUTPUT\s*$/)  { $mode = 'Output'; next; }
      elsif (/^TYPEMAP\s*$/) { $mode = 'Typemap'; next; }
      elsif ($mode eq 'Typemap') {
	next if /^\s*($|\#)/ ;
	my ($type, $image);
	if ( ($type, $image) =
	     /^\s*(.*?\S)\s+(\S+)\s*($proto_re*)\s*$/o
	     # This may reference undefined functions:
	     and not ($image eq 'T_PACKED' and $typemap eq $stdtypemap)) {
	  $typemap{normalize_type($type)} = $image;
	}
      }
    }
    close(TYPEMAP) or die "Cannot close $typemap: $!";
  }
  %std_types = %types_seen;
  %types_seen = ();
}


sub normalize_type {		# Second arg: do not strip const's before \*
  my $type = shift;
  my $do_keep_deep_const = shift;
  # If $do_keep_deep_const this is heuristic only
  my $keep_deep_const = ($do_keep_deep_const ? '\b(?![^(,)]*\*)' : '');
  my $ignore_mods
    = "(?:\\b(?:(?:__const__|const)$keep_deep_const|static|inline|__inline__)\\b\\s*)*";
  if ($do_keep_deep_const) {	# Keep different compiled /RExen/o separately!
    $type =~ s/$ignore_mods//go;
  }
  else {
    $type =~ s/$ignore_mods//go;
  }
  $type =~ s/([^\s\w])/ $1 /g;
  $type =~ s/\s+$//;
  $type =~ s/^\s+//;
  $type =~ s/\s+/ /g;
  $type =~ s/\* (?=\*)/*/g;
  $type =~ s/\. \. \./.../g;
  $type =~ s/ ,/,/g;
  $types_seen{$type}++
    unless $type eq '...' or $type eq 'void' or $std_types{$type};
  $type;
}

my $need_opaque;

sub assign_typemap_entry {
  my $type = shift;
  my $otype = $type;
  my $entry;
  if ($tmask and $type =~ /$tmask/) {
    print "Type $type matches -o mask\n" if $opt_d;
    $entry = (td_is_struct($type) ? "T_OPAQUE_STRUCT" : "T_PTROBJ");
  }
  elsif ($typedef_rex and $type =~ s/($typedef_rex)/$typedefs_pre{$1}/go) {
    $type = normalize_type $type;
    print "Type mutation via typedefs: $otype ==> $type\n" if $opt_d;
    $entry = assign_typemap_entry($type);
  }
  # XXX good do better if our UV happens to be long long
  return "T_NV" if $type =~ /^(unsigned\s+)?long\s+(long|double)\z/;
  $entry ||= $typemap{$otype}
    || (td_is_struct($type) ? "T_OPAQUE_STRUCT" : "T_PTROBJ");
  $typemap{$otype} = $entry;
  $need_opaque = 1 if $entry eq "T_OPAQUE_STRUCT";
  return $entry;
}

for (@vdecls) {
  print_tievar_xsubs(\*XS, $_, $vdecl_hash{$_});
}

if ($opt_x) {
  for my $decl (@$fdecls_parsed) { print_decl(\*XS, $decl) }
  if ($opt_a) {
    while (my($name, $struct) = each %structs) {
      print_accessors(\*XS, $name, $struct);
    }
  }
}

close XS;

if (%types_seen) {
  my $type;
  warn "Writing $ext$modpname/typemap\n";
  open TM, ">", "typemap" or die "Cannot open typemap file for write: $!";

  for $type (sort keys %types_seen) {
    my $entry = assign_typemap_entry $type;
    print TM $type, "\t" x (5 - int((length $type)/8)), "\t$entry\n"
  }

  print TM <<'EOP' if $need_opaque; # Older Perls do not have correct entry
#############################################################################
INPUT
T_OPAQUE_STRUCT
	if (sv_derived_from($arg, \"${ntype}\")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV($arg), len);

	    if (len != sizeof($var))
		croak(\"Size %d of packed data != expected %d\",
			len, sizeof($var));
	    $var = *($type *)s;
	}
	else
	    croak(\"$var is not of type ${ntype}\")
#############################################################################
OUTPUT
T_OPAQUE_STRUCT
	sv_setref_pvn($arg, \"${ntype}\", (char *)&$var, sizeof($var));
EOP

  close TM or die "Cannot close typemap file for write: $!";
}

} # if( ! $opt_X )

warn "Writing $ext$modpname/Makefile.PL\n";
open(PL, ">", "Makefile.PL") || die "Can't create $ext$modpname/Makefile.PL: $!\n";

my $prereq_pm = '';

if ( $compat_version < 5.006002 and $new_test )
{
  $prereq_pm .= q%'Test::More'  =>  0, %;
}
elsif ( $compat_version < 5.006002 )
{
  $prereq_pm .= q%'Test'        =>  0, %;
}

if (!$opt_X and $use_xsloader)
{
  $prereq_pm .= q%'XSLoader'    =>  0, %;
}

print PL <<"END";
use $compat_version;
use ExtUtils::MakeMaker;
# See lib/ExtUtils/MakeMaker.pm for details of how to influence
# the contents of the Makefile that is written.
WriteMakefile(
    NAME              => '$module',
    VERSION_FROM      => '$modpmname', # finds \$VERSION, requires EU::MM from perl >= 5.5
    PREREQ_PM         => {$prereq_pm}, # e.g., Module::Name => 1.1
    ABSTRACT_FROM     => '$modpmname', # retrieve abstract from module
    AUTHOR            => '$author <$email>',
    #LICENSE           => 'perl',
    #Value must be from legacy list of licenses here
    #https://metacpan.org/pod/Module::Build::API
END
if (!$opt_X) { # print C stuff, unless XS is disabled
  $opt_F = '' unless defined $opt_F;
  my $I = (((glob '*.h') || (glob '*.hh')) ? '-I.' : '');
  my $Ihelp = ($I ? '-I. ' : '');
  my $Icomment = ($I ? '' : <<EOC);
	# Insert -I. if you add *.h files later:
EOC

  print PL <<END;
    LIBS              => ['$extralibs'], # e.g., '-lm'
    DEFINE            => '$opt_F', # e.g., '-DHAVE_SOMETHING'
$Icomment    INC               => '$I', # e.g., '${Ihelp}-I/usr/include/other'
END

  my $C = grep {$_ ne "$modfname.c"}
    (glob '*.c'), (glob '*.cc'), (glob '*.C');
  my $Cpre = ($C ? '' : '# ');
  my $Ccomment = ($C ? '' : <<EOC);
	# Un-comment this if you add C files to link with later:
EOC

  print PL <<END;
$Ccomment    ${Cpre}OBJECT            => '\$(O_FILES)', # link all the C files too
END
} # ' # Grr
print PL ");\n";
if (!$opt_c) {
  my $generate_code =
    WriteMakefileSnippet ( C_FILE =>       $constscfname,
                           XS_FILE =>      $constsxsfname,
                           DEFAULT_TYPE => $opt_t,
                           NAME =>         $module,
                           NAMES =>        \@const_specs,
                 );
  print PL <<"END";
if  (eval {require ExtUtils::Constant; 1}) {
  # If you edit these definitions to change the constants used by this module,
  # you will need to use the generated $constscfname and $constsxsfname
  # files to replace their "fallback" counterparts before distributing your
  # changes.
$generate_code
}
else {
  use File::Copy;
  use File::Spec;
  foreach my \$file ('$constscfname', '$constsxsfname') {
    my \$fallback = File::Spec->catfile('$fallbackdirname', \$file);
    copy (\$fallback, \$file) or die "Can't copy \$fallback to \$file: \$!";
  }
}
END

  eval $generate_code;
  if ($@) {
    warn <<"EOM";
Attempting to test constant code in $ext$modpname/Makefile.PL:
$generate_code
__END__
gave unexpected error $@
Please report the circumstances of this bug in h2xs version $H2XS_VERSION
using the issue tracker at https://github.com/Perl/perl5/issues.
EOM
  } else {
    my $fail;

    foreach my $file ($constscfname, $constsxsfname) {
      my $fallback = File::Spec->catfile($fallbackdirname, $file);
      if (compare($file, $fallback)) {
        warn << "EOM";
Files "$ext$modpname/$fallbackdirname/$file" and "$ext$modpname/$file" differ.
EOM
        $fail++;
      }
    }
    if ($fail) {
      warn fill ('','', <<"EOM") . "\n";
It appears that the code in $ext$modpname/Makefile.PL does not autogenerate
the files $ext$modpname/$constscfname and $ext$modpname/$constsxsfname
correctly.

Please report the circumstances of this bug in h2xs version $H2XS_VERSION
using the issue tracker at https://github.com/Perl/perl5/issues.
EOM
    } else {
      unlink $constscfname, $constsxsfname;
    }
  }
}
close(PL) || die "Can't close $ext$modpname/Makefile.PL: $!\n";

# Create a simple README since this is a CPAN requirement
# and it doesn't hurt to have one
warn "Writing $ext$modpname/README\n";
open(RM, ">", "README") || die "Can't create $ext$modpname/README:$!\n";
my $thisyear = (gmtime)[5] + 1900;
my $rmhead = "$modpname version $TEMPLATE_VERSION";
my $rmheadeq = "=" x length($rmhead);

my $rm_prereq;

if ( $compat_version < 5.006002 and $new_test )
{
  $rm_prereq = 'Test::More';
}
elsif ( $compat_version < 5.006002 )
{
  $rm_prereq = 'Test';
}
else
{
  $rm_prereq = 'blah blah blah';
}

print RM <<_RMEND_;
$rmhead
$rmheadeq

The README is used to introduce the module and provide instructions on
how to install the module, any machine dependencies it may have (for
example C compilers and installed libraries) and any other information
that should be provided before the module is installed.

A README file is required for CPAN modules since CPAN extracts the
README file from a module distribution so that people browsing the
archive can use it get an idea of the modules uses. It is usually a
good idea to provide version information here so that people can
decide whether fixes for the module are worth downloading.

INSTALLATION

To install this module type the following:

   perl Makefile.PL
   make
   make test
   make install

DEPENDENCIES

This module requires these other modules and libraries:

  $rm_prereq

COPYRIGHT AND LICENCE

Put the correct copyright and licence information here.

$licence

_RMEND_
close(RM) || die "Can't close $ext$modpname/README: $!\n";

my $testdir  = "t";
my $testfile = "$testdir/$modpname.t";
unless (-d "$testdir") {
  mkdir "$testdir" or die "Cannot mkdir $testdir: $!\n";
}
warn "Writing $ext$modpname/$testfile\n";
my $tests = @const_names ? 2 : 1;

open EX, ">", "$testfile" or die "Can't create $ext$modpname/$testfile: $!\n";

print EX <<_END_;
# Before 'make install' is performed this script should be runnable with
# 'make test'. After 'make install' it should work as 'perl $modpname.t'

#########################

# change 'tests => $tests' to 'tests => last_test_to_print';

use strict;
use warnings;

_END_

my $test_mod = 'Test::More';

if ( $old_test or ($compat_version < 5.006002 and not $new_test ))
{
  my $test_mod = 'Test';

  print EX <<_END_;
use Test;
BEGIN { plan tests => $tests };
use $module;
ok(1); # If we made it this far, we're ok.

_END_

   if (@const_names) {
     my $const_names = join " ", @const_names;
     print EX <<'_END_';

my $fail;
foreach my $constname (qw(
_END_

     print EX wrap ("\t", "\t", $const_names);
     print EX (")) {\n");

     print EX <<_END_;
  next if (eval "my \\\$a = \$constname; 1");
  if (\$\@ =~ /^Your vendor has not defined $module macro \$constname/) {
    print "# pass: \$\@";
  } else {
    print "# fail: \$\@";
    \$fail = 1;
  }
}
if (\$fail) {
  print "not ok 2\\n";
} else {
  print "ok 2\\n";
}

_END_
  }
}
else
{
  print EX <<_END_;
use Test::More tests => $tests;
BEGIN { use_ok('$module') };

_END_

   if (@const_names) {
     my $const_names = join " ", @const_names;
     print EX <<'_END_';

my $fail = 0;
foreach my $constname (qw(
_END_

     print EX wrap ("\t", "\t", $const_names);
     print EX (")) {\n");

     print EX <<_END_;
  next if (eval "my \\\$a = \$constname; 1");
  if (\$\@ =~ /^Your vendor has not defined $module macro \$constname/) {
    print "# pass: \$\@";
  } else {
    print "# fail: \$\@";
    \$fail = 1;
  }

}

ok( \$fail == 0 , 'Constants' );
_END_
  }
}

print EX <<_END_;
#########################

# Insert your test code below, the $test_mod module is use()ed here so read
# its man page ( perldoc $test_mod ) for help writing this test script.

_END_

close(EX) || die "Can't close $ext$modpname/$testfile: $!\n";

unless ($opt_C) {
  warn "Writing $ext$modpname/Changes\n";
  $" = ' ';
  open(EX, ">", "Changes") || die "Can't create $ext$modpname/Changes: $!\n";
  @ARGS = map {/[\s\"\'\`\$*?^|&<>\[\]\{\}\(\)]/ ? "'$_'" : $_} @ARGS;
  print EX <<EOP;
Revision history for Perl extension $module.

$TEMPLATE_VERSION  @{[scalar localtime]}
\t- original version; created by h2xs $H2XS_VERSION with options
\t\t@ARGS

EOP
  close(EX) || die "Can't close $ext$modpname/Changes: $!\n";
}

warn "Writing $ext$modpname/MANIFEST\n";
open(MANI, '>', 'MANIFEST') or die "Can't create MANIFEST: $!";
my @files = grep { -f } (<*>, <t/*>, <$fallbackdirname/*>, <$modpmdir/*>);
if (!@files) {
  eval {opendir(D,'.');};
  unless ($@) { @files = readdir(D); closedir(D); }
}
if (!@files) { @files = map {chomp && $_} `ls`; }
if ($^O eq 'VMS') {
  foreach (@files) {
    # Clip trailing '.' for portability -- non-VMS OSs don't expect it
    s%\.$%%;
    # Fix up for case-sensitive file systems
    s/$modfname/$modfname/i && next;
    $_ = "\U$_" if $_ eq 'manifest' or $_ eq 'changes';
    $_ = 'Makefile.PL' if $_ eq 'makefile.pl';
  }
}
print MANI join("\n",@files), "\n";
close MANI;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              usr/local/bin/instmodsh                                                                             0000755 0000000 0000000 00000010316 14714567415 013674  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/local/bin/perl
    eval 'exec /usr/local/bin/perl -S $0 ${1+"$@"}'
	if 0; # ^ Run only under a shell
#!/usr/bin/perl -w

BEGIN { pop @INC if $INC[-1] eq '.' }
use strict;
use IO::File;
use ExtUtils::Packlist;
use ExtUtils::Installed;

use vars qw($Inst @Modules);


=head1 NAME

instmodsh - A shell to examine installed modules

=head1 SYNOPSIS

    instmodsh

=head1 DESCRIPTION

A little interface to ExtUtils::Installed to examine installed modules,
validate your packlists and even create a tarball from an installed module.

=head1 SEE ALSO

ExtUtils::Installed

=cut


my $Module_Help = <<EOF;
Available commands are:
   f [all|prog|doc]   - List installed files of a given type
   d [all|prog|doc]   - List the directories used by a module
   v                  - Validate the .packlist - check for missing files
   t <tarfile>        - Create a tar archive of the module
   h                  - Display module help
   q                  - Quit the module
EOF

my %Module_Commands = (
                       f => \&list_installed,
                       d => \&list_directories,
                       v => \&validate_packlist,
                       t => \&create_archive,
                       h => \&module_help,
                      );

sub do_module($) {
    my ($module) = @_;

    print($Module_Help);
    MODULE_CMD: while (1) {
        print("$module cmd? ");

        my $reply = <STDIN>; chomp($reply);
        my($cmd) = $reply =~ /^(\w)\b/;

        last if $cmd eq 'q';

        if( $Module_Commands{$cmd} ) {
            $Module_Commands{$cmd}->($reply, $module);
        }
