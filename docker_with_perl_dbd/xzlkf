    Example_reg_numbered_buff_store(pTHX_
                                    REGEXP * const rx,
                                    const I32 paren,
                                    SV const * const value)
    {
        PERL_UNUSED_ARG(rx);
        PERL_UNUSED_ARG(paren);
        PERL_UNUSED_ARG(value);

        if (!PL_localizing)
            Perl_croak(aTHX_ PL_no_modify);
    }

Actually Perl will not I<always> croak in a statement that looks
like it would modify a numbered capture variable.  This is because the
STORE callback will not be called if Perl can determine that it
doesn't have to modify the value.  This is exactly how tied variables
behave in the same situation:

    package CaptureVar;
    use parent 'Tie::Scalar';

    sub TIESCALAR { bless [] }
    sub FETCH { undef }
    sub STORE { die "This doesn't get called" }

    package main;

    tie my $sv => "CaptureVar";
    $sv =~ y/a/b/;

Because C<$sv> is C<undef> when the C<y///> operator is applied to it,
the transliteration won't actually execute and the program won't
C<die>.  This is different to how 5.8 and earlier versions behaved
since the capture variables were READONLY variables then; now they'll
just die when assigned to in the default engine.

=head3 numbered_buff_LENGTH

    I32 numbered_buff_LENGTH (pTHX_
                              REGEXP * const rx,
                              const SV * const sv,
                              const I32 paren);

Get the C<length> of a capture variable.  There's a special callback
for this so that Perl doesn't have to do a FETCH and run C<length> on
the result, since the length is (in Perl's case) known from an offset
stored in C<< rx->offs >>, this is much more efficient:

    I32 s1  = rx->offs[paren].start;
    I32 s2  = rx->offs[paren].end;
    I32 len = t1 - s1;

This is a little bit more complex in the case of UTF-8, see what
C<Perl_reg_numbered_buff_length> does with
L<is_utf8_string_loclen|perlapi/is_utf8_string_loclen>.

=head2 Named capture callbacks

Called to get/set the value of C<%+> and C<%->, as well as by some
utility functions in L<re>.

There are two callbacks, C<named_buff> is called in all the cases the
FETCH, STORE, DELETE, CLEAR, EXISTS and SCALAR L<Tie::Hash> callbacks
would be on changes to C<%+> and C<%-> and C<named_buff_iter> in the
same cases as FIRSTKEY and NEXTKEY.

The C<flags> parameter can be used to determine which of these
operations the callbacks should respond to.  The following flags are
currently defined:

Which L<Tie::Hash> operation is being performed from the Perl level on
C<%+> or C<%+>, if any:

    RXapif_FETCH
    RXapif_STORE
    RXapif_DELETE
    RXapif_CLEAR
    RXapif_EXISTS
    RXapif_SCALAR
    RXapif_FIRSTKEY
    RXapif_NEXTKEY

=for apidoc Amnh ||RXapif_ALL
=for apidoc_item   RXapif_CLEAR
=for apidoc_item   RXapif_DELETE
=for apidoc_item   RXapif_EXISTS
=for apidoc_item   RXapif_FETCH
=for apidoc_item   RXapif_FIRSTKEY
=for apidoc_item   RXapif_NEXTKEY
=for apidoc_item   RXapif_ONE
=for apidoc_item   RXapif_REGNAME
=for apidoc_item   RXapif_REGNAMES
=for apidoc_item   RXapif_REGNAMES_COUNT
=for apidoc_item   RXapif_SCALAR
=for apidoc_item   RXapif_STORE

If C<%+> or C<%-> is being operated on, if any.

    RXapif_ONE /* %+ */
    RXapif_ALL /* %- */

If this is being called as C<re::regname>, C<re::regnames> or
C<re::regnames_count>, if any.  The first two will be combined with
C<RXapif_ONE> or C<RXapif_ALL>.

    RXapif_REGNAME
    RXapif_REGNAMES
    RXapif_REGNAMES_COUNT


Internally C<%+> and C<%-> are implemented with a real tied interface
via L<Tie::Hash::NamedCapture>.  The methods in that package will call
back into these functions.  However the usage of
L<Tie::Hash::NamedCapture> for this purpose might change in future
releases.  For instance this might be implemented by magic instead
(would need an extension to mgvtbl).

=head3 named_buff

    SV*     (*named_buff) (pTHX_ REGEXP * const rx, SV * const key,
                           SV * const value, U32 flags);

=head3 named_buff_iter

    SV*     (*named_buff_iter) (pTHX_
                                REGEXP * const rx,
                                const SV * const lastkey,
                                const U32 flags);

=head2 qr_package

    SV* qr_package(pTHX_ REGEXP * const rx);

The package the qr// magic object is blessed into (as seen by C<ref
qr//>).  It is recommended that engines change this to their package
name for identification regardless of if they implement methods
on the object.

The package this method returns should also have the internal
C<Regexp> package in its C<@ISA>.  C<< qr//->isa("Regexp") >> should always
be true regardless of what engine is being used.

Example implementation might be:

    SV*
    Example_qr_package(pTHX_ REGEXP * const rx)
    {
    	PERL_UNUSED_ARG(rx);
    	return newSVpvs("re::engine::Example");
    }

Any method calls on an object created with C<qr//> will be dispatched to the
package as a normal object.

    use re::engine::Example;
    my $re = qr//;
    $re->meth; # dispatched to re::engine::Example::meth()

To retrieve the C<REGEXP> object from the scalar in an XS function use
the C<SvRX> macro, see L<"REGEXP Functions" in perlapi|perlapi/REGEXP
Functions>.

    void meth(SV * rv)
    PPCODE:
        REGEXP * re = SvRX(sv);

=head2 dupe

    void* dupe(pTHX_ REGEXP * const rx, CLONE_PARAMS *param);

On threaded builds a regexp may need to be duplicated so that the pattern
can be used by multiple threads.  This routine is expected to handle the
duplication of any private data pointed to by the C<pprivate> member of
the C<regexp> structure.  It will be called with the preconstructed new
C<regexp> structure as an argument, the C<pprivate> member will point at
the B<old> private structure, and it is this routine's responsibility to
construct a copy and return a pointer to it (which Perl will then use to
overwrite the field as passed to this routine.)

This allows the engine to dupe its private data but also if necessary
modify the final structure if it really must.

On unthreaded builds this field doesn't exist.

=head2 op_comp

This is private to the Perl core and subject to change. Should be left
null.

=head1 The REGEXP structure

The REGEXP struct is defined in F<regexp.h>.
All regex engines must be able to
correctly build such a structure in their L</comp> routine.

=for apidoc Ayh||struct regexp
=for apidoc Ayh||REGEXP

The REGEXP structure contains all the data that Perl needs to be aware of
to properly work with the regular expression.  It includes data about
optimisations that Perl can use to determine if the regex engine should
really be used, and various other control info that is needed to properly
execute patterns in various contexts, such as if the pattern anchored in
some way, or what flags were used during the compile, or if the
program contains special constructs that Perl needs to be aware of.

In addition it contains two fields that are intended for the private
use of the regex engine that compiled the pattern.  These are the
C<intflags> and C<pprivate> members.  C<pprivate> is a void pointer to
an arbitrary structure, whose use and management is the responsibility
of the compiling engine.  Perl will never modify either of these
values.

    /* copied from: regexp.h */
    typedef struct regexp {
        /*----------------------------------------------------------------------
         * Fields required for compatibility with SV types
         */
        _XPV_HEAD;

        /*----------------------------------------------------------------------
         * Operational fields
         */
        const struct regexp_engine* engine; /* what engine created this regexp? */
        REGEXP *mother_re; /* what re is this a lightweight copy of? */
        HV *paren_names;   /* Optional hash of paren names */

        /*----------------------------------------------------------------------
         * Information about the match that the perl core uses to manage things
         */

        /* see comment in regcomp_internal.h about branch reset to understand
           the distinction between physical and logical capture buffers */
        U32 nparens;                    /* physical number of capture buffers */
        U32 logical_nparens;            /* logical_number of capture buffers */
        I32 *logical_to_parno;          /* map logical parno to first physcial */
        I32 *parno_to_logical;          /* map every physical parno to logical */
        I32 *parno_to_logical_next;     /* map every physical parno to the next
                                           physical with the same logical id */

        SSize_t maxlen;    /* maximum possible number of chars in string to match */
        SSize_t minlen;    /* minimum possible number of chars in string to match */
        SSize_t minlenret; /* minimum possible number of chars in $& */
        STRLEN gofs;       /* chars left of pos that we search from */
                           /* substring data about strings that must appear in
                            * the final match, used for optimisations */

        struct reg_substr_data *substrs;

        /* private engine specific data */

        void *pprivate;    /* Data private to the regex engine which
                            * created this object. */
        U32 extflags;      /* Flags used both externally and internally */
        U32 intflags;      /* Engine Specific Internal flags */

        /*----------------------------------------------------------------------
         * Data about the last/current match. These are modified during matching
         */

        U32 lastparen;           /* highest close paren matched ($+) */
        U32 lastcloseparen;      /* last close paren matched ($^N) */
        regexp_paren_pair *offs; /* Array of offsets for (@-) and (@+) */
        char **recurse_locinput; /* used to detect infinite recursion, XXX: move to internal */


        /*---------------------------------------------------------------------- */

        /* offset from wrapped to the start of precomp */
        PERL_BITFIELD32 pre_prefix:4;

        /* original flags used to compile the pattern, may differ from
         * extflags in various ways */
        PERL_BITFIELD32 compflags:9;

        /*---------------------------------------------------------------------- */

        char *subbeg;       /* saved or original string so \digit works forever. */
        SV_SAVED_COPY       /* If non-NULL, SV which is COW from original */
        SSize_t sublen;     /* Length of string pointed by subbeg */
        SSize_t suboffset;  /* byte offset of subbeg from logical start of str */
        SSize_t subcoffset; /* suboffset equiv, but in chars (for @-/@+) */

        /*----------------------------------------------------------------------
         * More Operational fields
         */

        CV *qr_anoncv;      /* the anon sub wrapped round qr/(?{..})/ */
    } regexp;

Most of the fields contained in this structure are accessed via macros
with a prefix of C<RX_> or C<RXp_>. The fields are discussed in more detail
below:

=head2 C<engine>

This field points at a C<regexp_engine> structure which contains pointers
to the subroutines that are to be used for performing a match.  It
is the compiling routine's responsibility to populate this field before
returning the regexp object.

Internally this is set to C<NULL> unless a custom engine is specified in
C<$^H{regcomp}>, Perl's own set of callbacks can be accessed in the struct
pointed to by C<RE_ENGINE_PTR>.

=for apidoc Amnh||SV_SAVED_COPY

=head2 C<mother_re>

This is a pointer to another struct regexp which this one was derived
from. C<qr//> objects means that the same regexp pattern can be used in
different contexts at the same time, and as long as match status
information is stored in the structure (there are plans to change this
eventually) we need to support having multiple copies of the structure
in use at the same time. The fields related to the regexp program itself
are copied from the mother_re, and owned by the mother_re, whereas the
match state variables are owned by the struct itself.

=head2 C<extflags>

This will be used by Perl to see what flags the regexp was compiled
with, this will normally be set to the value of the flags parameter by
the L<comp|/comp> callback.  See the L<comp|/comp> documentation for
valid flags.

=head2 C<minlen> C<minlenret>

The minimum string length (in characters) required for the pattern to match.
This is used to
prune the search space by not bothering to match any closer to the end of a
string than would allow a match.  For instance there is no point in even
starting the regex engine if the minlen is 10 but the string is only 5
characters long.  There is no way that the pattern can match.

C<minlenret> is the minimum length (in characters) of the string that would
be found in $& after a match.

The difference between C<minlen> and C<minlenret> can be seen in the
following pattern:

    /ns(?=\d)/

where the C<minlen> would be 3 but C<minlenret> would only be 2 as the \d is
required to match but is not actually
included in the matched content.  This
distinction is particularly important as the substitution logic uses the
C<minlenret> to tell if it can do in-place substitutions (these can
result in considerable speed-up).

=head2 C<gofs>

Left offset from pos() to start match at.

=head2 C<substrs>

Substring data about strings that must appear in the final match.  This
is currently only used internally by Perl's engine, but might be
used in the future for all engines for optimisations.

=head2 C<nparens>, C<logical_nparens>


These fields are used to keep track of the number of physical and logical
paren capture groups there are in the pattern, which may differ if the
pattern includes the use of the branch reset construct C<(?| ... | ... )>.
For instance the pattern C</(?|(foo)|(bar))/> contains two physical capture
buffers, but only one logical capture buffer. Most internals logic in the
regex engine uses the physical capture buffer ids, but the user exposed
logic uses logical capture buffer ids. See the next section for data-structures
that allow mapping from one to the other.

=head2 C<logical_to_parno>, C<parno_to_logical>, C<parno_to_logical_next>

These fields facilitate mapping between logical and physical capture
buffer numbers. C<logical_to_parno> is an array whose Kth element
contains the lowest physical capture buffer id for the Kth logical
capture buffer. C<parno_to_logical> is an array whose Kth element
contains the logical capture buffer associated with the Kth physical
capture buffer. C<parno_to_logical_next> is an array whose Kth element
contains the next physical capture buffer with the same logical id, or 0
if there is none.

Note that all three of these arrays are ONLY populated when the pattern
includes the use of the branch reset concept. Patterns which do not use
branch-reset effectively have a 1:1 to mapping between logical and
physical so there is no need for this meta-data.

The following table gives an example of how this works.

     Pattern /(a) (?| (b) (c) (d) | (e) (f) | (g) ) (h)/
     Logical: $1      $2  $3  $4    $2  $3    $2    $5
     Physical: 1       2   3   4     5   6     7     8
     Next:     0       5   6   0     7   0     0     0

Also note that the 0th element of any of these arrays is not used as it
represents the "entire pattern".

=head2 C<lastparen>, and C<lastcloseparen>

These fields are used to keep track of: which was the highest paren to
be closed (see L<perlvar/$+>); and which was the most recent paren to be
closed (see L<perlvar/$^N>).

=head2 C<intflags>

The engine's private copy of the flags the pattern was compiled with. Usually
this is the same as C<extflags> unless the engine chose to modify one of them.

=head2 C<pprivate>

A void* pointing to an engine-defined
data structure.  The Perl engine uses the
C<regexp_internal> structure (see L<perlreguts/Base Structures>) but a custom
engine should use something else.

=head2 C<offs>

A C<regexp_paren_pair> structure which defines offsets into the string being
matched which correspond to the C<$&> and C<$1>, C<$2> etc. captures, the
C<regexp_paren_pair> struct is defined as follows:

    typedef struct regexp_paren_pair {
        I32 start;
        I32 end;
    } regexp_paren_pair;

=for apidoc Ayh||regexp_paren_pair

If C<< ->offs[num].start >> or C<< ->offs[num].end >> is C<-1> then that
capture group did not match.
C<< ->offs[0].start/end >> represents C<$&> (or
C<${^MATCH}> under C</p>) and C<< ->offs[paren].end >> matches C<$$paren> where
C<$paren >= 1>.

=head2 C<RX_PRECOMP> C<RX_PRELEN>

Used for optimisations.  C<RX_PRECOMP> holds a copy of the pattern that
was compiled and C<RX_PRELEN> its length.  When a new pattern is to be
compiled (such as inside a loop) the internal C<regcomp> operator
checks if the last compiled C<REGEXP>'s C<RX_PRECOMP> and C<RX_PRELEN>
are equivalent to the new one, and if so uses the old pattern instead
of compiling a new one.

In older perls these two macros were actually fields in the structure
with the names C<precomp> and C<prelen> respectively.

=head2 C<paren_names>

This is a hash used internally to track named capture groups and their
offsets.  The keys are the names of the buffers the values are dualvars,
with the IV slot holding the number of buffers with the given name and the
pv being an embedded array of I32.  The values may also be contained
independently in the data array in cases where named backreferences are
used.

=head2 C<substrs>

Holds information on the longest string that must occur at a fixed
offset from the start of the pattern, and the longest string that must
occur at a floating offset from the start of the pattern.  Used to do
Fast-Boyer-Moore searches on the string to find out if its worth using
the regex engine at all, and if so where in the string to search.

=head2 C<subbeg> C<sublen> C<saved_copy> C<suboffset> C<subcoffset>

Used during the execution phase for managing search and replace patterns,
and for providing the text for C<$&>, C<$1> etc. C<subbeg> points to a
buffer (either the original string, or a copy in the case of
C<RX_MATCH_COPIED(rx_sv)>), and C<sublen> is the length of the buffer.  The
C<RX_OFFS_START(rx_sv,n)> and C<RX_OFFS_END(rx_sv,n)> macros index into this
buffer. as does the data structure returned by C<RX_OFFSp(rx_sv)> but you
should not use that directly.

=for apidoc Amh||RX_MATCH_COPIED|const REGEXP * rx_sv

In the presence of the C<REXEC_COPY_STR> flag, but with the addition of
the C<REXEC_COPY_SKIP_PRE> or C<REXEC_COPY_SKIP_POST> flags, an engine
can choose not to copy the full buffer (although it must still do so in
the presence of C<RXf_PMf_KEEPCOPY> or the relevant bits being set in
C<PL_sawampersand>).  In this case, it may set C<suboffset> to indicate the
number of bytes from the logical start of the buffer to the physical start
(i.e. C<subbeg>).  It should also set C<subcoffset>, the number of
characters in the offset. The latter is needed to support C<@-> and C<@+>
which work in characters, not bytes.

=for apidoc Amnh ||REXEC_COPY_SKIP_POST
=for apidoc_item ||REXEC_COPY_SKIP_PRE
=for apidoc_item ||REXEC_COPY_STR

=head2 C<RX_WRAPPED> C<RX_WRAPLEN>

Macros which access the string the C<qr//> stringifies to. The Perl
engine for example stores C<(?^:eek)> in the case of C<qr/eek/>.

When using a custom engine that doesn't support the C<(?:)> construct
for inline modifiers, it's probably best to have C<qr//> stringify to
the supplied pattern, note that this will create undesired patterns in
cases such as:

    my $x = qr/a|b/;  # "a|b"
    my $y = qr/c/i;   # "c"
    my $z = qr/$x$y/; # "a|bc"

There's no solution for this problem other than making the custom
engine understand a construct like C<(?:)>.

=head2 C<RX_REFCNT()>

The number of times the structure is referenced. When this falls to 0,
the regexp is automatically freed by a call to C<pregfree>. This should
be set to 1 in each engine's L</comp> routine. Note that in older perls
this was a member in the struct called C<refcnt> but in more modern
perls where the regexp structure was unified with the SV structure this
is an alias to SvREFCNT().

=head1 HISTORY

Originally part of L<perlreguts>.

=head1 AUTHORS

Originally written by Yves Orton, expanded by E<AElig>var ArnfjE<ouml>rE<eth>
Bjarmason.

=head1 LICENSE

Copyright 2006 Yves Orton and 2007 E<AElig>var ArnfjE<ouml>rE<eth> Bjarmason.

This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                                                                                                                                                    usr/local/lib/perl5/5.40.0/pod/perlrebackslash.pod                                                  0000644 0000000 0000000 00000100617 14714567415 020146  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =head1 NAME

perlrebackslash - Perl Regular Expression Backslash Sequences and Escapes

=head1 DESCRIPTION

The top level documentation about Perl regular expressions
is found in L<perlre>.

This document describes all backslash and escape sequences. After
explaining the role of the backslash, it lists all the sequences that have
a special meaning in Perl regular expressions (in alphabetical order),
then describes each of them.

Most sequences are described in detail in different documents; the primary
purpose of this document is to have a quick reference guide describing all
backslash and escape sequences.

=head2 The backslash

In a regular expression, the backslash can perform one of two tasks:
it either takes away the special meaning of the character following it
(for instance, C<\|> matches a vertical bar, it's not an alternation),
or it is the start of a backslash or escape sequence.

The rules determining what it is are quite simple: if the character
following the backslash is an ASCII punctuation (non-word) character (that is,
anything that is not a letter, digit, or underscore), then the backslash just
takes away any special meaning of the character following it.

If the character following the backslash is an ASCII letter or an ASCII digit,
then the sequence may be special; if so, it's listed below. A few letters have
not been used yet, so escaping them with a backslash doesn't change them to be
special.  A future version of Perl may assign a special meaning to them, so if
you have warnings turned on, Perl issues a warning if you use such a
sequence.  [1].

It is however guaranteed that backslash or escape sequences never have a
punctuation character following the backslash, not now, and not in a future
version of Perl 5. So it is safe to put a backslash in front of a non-word
character.

Note that the backslash itself is special; if you want to match a backslash,
you have to escape the backslash with a backslash: C</\\/> matches a single
backslash.

=over 4

=item [1]

There is one exception. If you use an alphanumeric character as the
delimiter of your pattern (which you probably shouldn't do for readability
reasons), you have to escape the delimiter if you want to match
it. Perl won't warn then. See also L<perlop/Gory details of parsing
quoted constructs>.

=back


=head2 All the sequences and escapes

Those not usable within a bracketed character class (like C<[\da-z]>) are marked
as C<Not in [].>

 \000              Octal escape sequence.  See also \o{}.
 \1                Absolute backreference.  Not in [].
 \a                Alarm or bell.
 \A                Beginning of string.  Not in [].
 \b{}, \b          Boundary. (\b is a backspace in []).
 \B{}, \B          Not a boundary.  Not in [].
 \cX               Control-X.
 \d                Match any digit character.
 \D                Match any character that isn't a digit.
 \e                Escape character.
 \E                Turn off \Q, \L and \U processing.  Not in [].
 \f                Form feed.
 \F                Foldcase till \E.  Not in [].
 \g{}, \g1         Named, absolute or relative backreference.
                   Not in [].
 \G                Pos assertion.  Not in [].
 \h                Match any horizontal whitespace character.
 \H                Match any character that isn't horizontal whitespace.
 \k{}, \k<>, \k''  Named backreference.  Not in [].
 \K                Keep the stuff left of \K.  Not in [].
 \l                Lowercase next character.  Not in [].
 \L                Lowercase till \E.  Not in [].
 \n                (Logical) newline character.
 \N                Match any character but newline.  Not in [].
 \N{}              Named or numbered (Unicode) character or sequence.
 \o{}              Octal escape sequence.
 \p{}, \pP         Match any character with the given Unicode property.
 \P{}, \PP         Match any character without the given property.
 \Q                Quote (disable) pattern metacharacters till \E.  Not
                   in [].
 \r                Return character.
 \R                Generic new line.  Not in [].
 \s                Match any whitespace character.
 \S                Match any character that isn't a whitespace.
 \t                Tab character.
 \u                Titlecase next character.  Not in [].
 \U                Uppercase till \E.  Not in [].
 \v                Match any vertical whitespace character.
 \V                Match any character that isn't vertical whitespace
 \w                Match any word character.
 \W                Match any character that isn't a word character.
 \x{}, \x00        Hexadecimal escape sequence.
 \X                Unicode "extended grapheme cluster".  Not in [].
 \z                End of string.  Not in [].
 \Z                End of string.  Not in [].

=head2 Character Escapes

=head3  Fixed characters

A handful of characters have a dedicated I<character escape>. The following
table shows them, along with their ASCII code points (in decimal and hex),
their ASCII name, the control escape on ASCII platforms and a short
description.  (For EBCDIC platforms, see L<perlebcdic/OPERATOR DIFFERENCES>.)

 Seq.  Code Point  ASCII   Cntrl   Description.
       Dec    Hex
  \a     7     07    BEL    \cG    alarm or bell
  \b     8     08     BS    \cH    backspace [1]
  \e    27     1B    ESC    \c[    escape character
  \f    12     0C     FF    \cL    form feed
  \n    10     0A     LF    \cJ    line feed [2]
  \r    13     0D     CR    \cM    carriage return
  \t     9     09    TAB    \cI    tab

=over 4

=item [1]

C<\b> is the backspace character only inside a character class. Outside a
character class, C<\b> alone is a word-character/non-word-character
boundary, and C<\b{}> is some other type of boundary.

=item [2]

C<\n> matches a logical newline. Perl converts between C<\n> and your
OS's native newline character when reading from or writing to text files.

=back

=head4 Example

 $str =~ /\t/;   # Matches if $str contains a (horizontal) tab.

=head3 Control characters

C<\c> is used to denote a control character; the character following C<\c>
determines the value of the construct.  For example the value of C<\cA> is
C<chr(1)>, and the value of C<\cb> is C<chr(2)>, etc.
The gory details are in L<perlop/"Regexp Quote-Like Operators">.  A complete
list of what C<chr(1)>, etc. means for ASCII and EBCDIC platforms is in
L<perlebcdic/OPERATOR DIFFERENCES>.

Note that C<\c\> alone at the end of a regular expression (or doubled-quoted
string) is not valid.  The backslash must be followed by another character.
That is, C<\c\I<X>> means C<chr(28) . 'I<X>'> for all characters I<X>.

To write platform-independent code, you must use C<\N{I<NAME>}> instead, like
C<\N{ESCAPE}> or C<\N{U+001B}>, see L<charnames>.

Mnemonic: I<c>ontrol character.

=head4 Example

 $str =~ /\cK/;  # Matches if $str contains a vertical tab (control-K).

=head3 Named or numbered characters and character sequences

Unicode characters have a Unicode name and numeric code point (ordinal)
value.  Use the
C<\N{}> construct to specify a character by either of these values.
Certain sequences of characters also have names.

To specify by name, the name of the character or character sequence goes
between the curly braces.

To specify a character by Unicode code point, use the form C<\N{U+I<code
point>}>, where I<code point> is a number in hexadecimal that gives the
code point that Unicode has assigned to the desired character.  It is
customary but not required to use leading zeros to pad the number to 4
digits.  Thus C<\N{U+0041}> means C<LATIN CAPITAL LETTER A>, and you will
rarely see it written without the two leading zeros.  C<\N{U+0041}> means
"A" even on EBCDIC machines (where the ordinal value of "A" is not 0x41).

Blanks may freely be inserted adjacent to but within the braces
enclosing the name or code point.  So S<C<\N{ U+0041 }>> is perfectly
legal.

It is even possible to give your own names to characters and character
sequences by using the L<charnames> module.  These custom names are
lexically scoped, and so a given code point may have different names
in different scopes.  The name used is what is in effect at the time the
C<\N{}> is expanded.  For patterns in double-quotish context, that means
at the time the pattern is parsed.  But for patterns that are delimitted
by single quotes, the expansion is deferred until pattern compilation
time, which may very well have a different C<charnames> translator in
effect.

(There is an expanded internal form that you may see in debug output:
C<\N{U+I<code point>.I<code point>...}>.
The C<...> means any number of these I<code point>s separated by dots.
This represents the sequence formed by the characters.  This is an internal
form only, subject to change, and you should not try to use it yourself.)

Mnemonic: I<N>amed character.

Note that a character or character sequence expressed as a named
or numbered character is considered a character without special
meaning by the regex engine, and will match "as is".

=head4 Example

 $str =~ /\N{THAI CHARACTER SO SO}/;  # Matches the Thai SO SO character

 use charnames 'Cyrillic';            # Loads Cyrillic names.
 $str =~ /\N{ZHE}\N{KA}/;             # Match "ZHE" followed by "KA".

=head3 Octal escapes

There are two forms of octal escapes.  Each is used to specify a character by
its code point specified in base 8.

One form, available starting in Perl 5.14 looks like C<\o{...}>, where the dots
represent one or more octal digits.  It can be used for any Unicode character.

It was introduced to avoid the potential problems with the other form,
available in all Perls.  That form consists of a backslash followed by three
octal digits.  One problem with this form is that it can look exactly like an
old-style backreference (see
L</Disambiguation rules between old-style octal escapes and backreferences>
below.)  You can avoid this by making the first of the three digits always a
zero, but that makes \077 the largest code point specifiable.

In some contexts, a backslash followed by two or even one octal digits may be
interpreted as an octal escape, sometimes with a warning, and because of some
bugs, sometimes with surprising results.  Also, if you are creating a regex
out of smaller snippets concatenated together, and you use fewer than three
digits, the beginning of one snippet may be interpreted as adding digits to the
ending of the snippet before it.  See L</Absolute referencing> for more
discussion and examples of the snippet problem.

Note that a character expressed as an octal escape is considered
a character without special meaning by the regex engine, and will match
"as is".

To summarize, the C<\o{}> form is always safe to use, and the other form is
safe to use for code points through \077 when you use exactly three digits to
specify them.

Mnemonic: I<0>ctal or I<o>ctal.

=head4 Examples (assuming an ASCII platform)

 $str = "Perl";
 $str =~ /\o{120}/;  # Match, "\120" is "P".
 $str =~ /\120/;     # Same.
 $str =~ /\o{120}+/; # Match, "\120" is "P",
                     # it's repeated at least once.
 $str =~ /\120+/;    # Same.
 $str =~ /P\053/;    # No match, "\053" is "+" and taken literally.
 /\o{23073}/         # Black foreground, white background smiling face.
 /\o{4801234567}/    # Raises a warning, and yields chr(4).
 /\o{ 400}/          # LATIN CAPITAL LETTER A WITH MACRON
 /\o{ 400 }/         # Same. These show blanks are allowed adjacent to
                     # the braces

=head4 Disambiguation rules between old-style octal escapes and backreferences

Octal escapes of the C<\000> form outside of bracketed character classes
potentially clash with old-style backreferences (see L</Absolute referencing>
below).  They both consist of a backslash followed by numbers.  So Perl has to
use heuristics to determine whether it is a backreference or an octal escape.
Perl uses the following rules to disambiguate:

=over 4

=item 1

If the backslash is followed by a single digit, it's a backreference.

=item 2

If the first digit following the backslash is a 0, it's an octal escape.

=item 3

If the number following the backslash is N (in decimal), and Perl already
has seen N capture groups, Perl considers this a backreference.  Otherwise,
it considers it an octal escape. If N has more than three digits, Perl
takes only the first three for the octal escape; the rest are matched as is.

 my $pat  = "(" x 999;
    $pat .= "a";
    $pat .= ")" x 999;
 /^($pat)\1000$/;   #  Matches 'aa'; there are 1000 capture groups.
 /^$pat\1000$/;     #  Matches 'a@0'; there are 999 capture groups
                    #  and \1000 is seen as \100 (a '@') and a '0'.

=back

You can force a backreference interpretation always by using the C<\g{...}>
form.  You can the force an octal interpretation always by using the C<\o{...}>
form, or for numbers up through \077 (= 63 decimal), by using three digits,
beginning with a "0".

=head3 Hexadecimal escapes

Like octal escapes, there are two forms of hexadecimal escapes, but both start
with the sequence C<\x>.  This is followed by either exactly two hexadecimal
digits forming a number, or a hexadecimal number of arbitrary length surrounded
by curly braces. The hexadecimal number is the code point of the character you
want to express.

Note that a character expressed as one of these escapes is considered a
character without special meaning by the regex engine, and will match
"as is".

Mnemonic: heI<x>adecimal.

=head4 Examples (assuming an ASCII platform)

 $str = "Perl";
 $str =~ /\x50/;    # Match, "\x50" is "P".
 $str =~ /\x50+/;   # Match, "\x50" is "P", it is repeated at least once
 $str =~ /P\x2B/;   # No match, "\x2B" is "+" and taken literally.

 /\x{2603}\x{2602}/ # Snowman with an umbrella.
                    # The Unicode character 2603 is a snowman,
                    # the Unicode character 2602 is an umbrella.
 /\x{263B}/         # Black smiling face.
 /\x{263b}/         # Same, the hex digits A - F are case insensitive.
 /\x{ 263b }/       # Same, showing optional blanks adjacent to the
                    # braces

=head2 Modifiers

A number of backslash sequences have to do with changing the character,
or characters following them. C<\l> will lowercase the character following
it, while C<\u> will uppercase (or, more accurately, titlecase) the
character following it. They provide functionality similar to the
functions C<lcfirst> and C<ucfirst>.

To uppercase or lowercase several characters, one might want to use
C<\L> or C<\U>, which will lowercase/uppercase all characters following
them, until either the end of the pattern or the next occurrence of
C<\E>, whichever comes first. They provide functionality similar to what
the functions C<lc> and C<uc> provide.

C<\Q> is used to quote (disable) pattern metacharacters, up to the next
C<\E> or the end of the pattern. C<\Q> adds a backslash to any character
that could have special meaning to Perl.  In the ASCII range, it quotes
every character that isn't a letter, digit, or underscore.  See
L<perlfunc/quotemeta> for details on what gets quoted for non-ASCII
code points.  Using this ensures that any character between C<\Q> and
C<\E> will be matched literally, not interpreted as a metacharacter by
the regex engine.

C<\F> can be used to casefold all characters following, up to the next C<\E>
or the end of the pattern. It provides the functionality similar to
the C<fc> function.

Mnemonic: I<L>owercase, I<U>ppercase, I<F>old-case, I<Q>uotemeta, I<E>nd.

=head4 Examples

 $sid     = "sid";
 $greg    = "GrEg";
 $miranda = "(Miranda)";
 $str     =~ /\u$sid/;        # Matches 'Sid'
 $str     =~ /\L$greg/;       # Matches 'greg'
 $str     =~ /\Q$miranda\E/;  # Matches '(Miranda)', as if the pattern
                              #   had been written as /\(Miranda\)/

=head2 Character classes

Perl regular expressions have a large range of character classes. Some of
the character classes are written as a backslash sequence. We will briefly
discuss those here; full details of character classes can be found in
L<perlrecharclass>.

C<\w> is a character class that matches any single I<word> character
(letters, digits, Unicode marks, and connector punctuation (like the
underscore)).  C<\d> is a character class that matches any decimal
digit, while the character class C<\s> matches any whitespace character.
New in perl 5.10.0 are the classes C<\h> and C<\v> which match horizontal
and vertical whitespace characters.

The exact set of characters matched by C<\d>, C<\s>, and C<\w> varies
depending on various pragma and regular expression modifiers.  It is
possible to restrict the match to the ASCII range by using the C</a>
regular expression modifier.  See L<perlrecharclass>.

The uppercase variants (C<\W>, C<\D>, C<\S>, C<\H>, and C<\V>) are
character classes that match, respectively, any character that isn't a
word character, digit, whitespace, horizontal whitespace, or vertical
whitespace.

Mnemonics: I<w>ord, I<d>igit, I<s>pace, I<h>orizontal, I<v>ertical.

=head3 Unicode classes

C<\pP> (where C<P> is a single letter) and C<\p{Property}> are used to
match a character that matches the given Unicode property; properties
include things like "letter", or "thai character". Capitalizing the
sequence to C<\PP> and C<\P{Property}> make the sequence match a character
that doesn't match the given Unicode property. For more details, see
L<perlrecharclass/Backslash sequences> and
L<perlunicode/Unicode Character Properties>.

Mnemonic: I<p>roperty.

=head2 Referencing

If capturing parenthesis are used in a regular expression, we can refer
to the part of the source string that was matched, and match exactly the
same thing. There are three ways of referring to such I<backreference>:
absolutely, relatively, and by name.

=for later add link to perlrecapture

=head3 Absolute referencing

Either C<\gI<N>> (starting in Perl 5.10.0), or C<\I<N>> (old-style) where I<N>
is a positive (unsigned) decimal number of any length is an absolute reference
to a capturing group.

I<N> refers to the Nth set of parentheses, so C<\gI<N>> refers to whatever has
been matched by that set of parentheses.  Thus C<\g1> refers to the first
capture group in the regex.

The C<\gI<N>> form can be equivalently written as C<\g{I<N>}>
which avoids ambiguity when building a regex by concatenating shorter
strings.  Otherwise if you had a regex C<qr/$x$y/>, and C<$x> contained
C<"\g1">, and C<$y> contained C<"37">, you would get C</\g137/> which is
probably not what you intended.

In the C<\I<N>> form, I<N> must not begin with a "0", and there must be at
least I<N> capturing groups, or else I<N> is considered an octal escape
(but something like C<\18> is the same as C<\0018>; that is, the octal escape
C<"\001"> followed by a literal digit C<"8">).

Mnemonic: I<g>roup.

=head4 Examples

 /(\w+) \g1/;    # Finds a duplicated word, (e.g. "cat cat").
 /(\w+) \1/;     # Same thing; written old-style.
 /(\w+) \g{1}/;  # Same, using the safer braced notation
 /(\w+) \g{ 1 }/;# Same, showing optional blanks adjacent to the braces
 /(.)(.)\g2\g1/; # Match a four letter palindrome (e.g. "ABBA").


=head3 Relative referencing

C<\g-I<N>> (starting in Perl 5.10.0) is used for relative addressing.  (It can
be written as C<\g{-I<N>}>.)  It refers to the I<N>th group before the
C<\g{-I<N>}>.

The big advantage of this form is that it makes it much easier to write
patterns with references that can be interpolated in larger patterns,
even if the larger pattern also contains capture groups.

=head4 Examples
