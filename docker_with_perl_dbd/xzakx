
    Returns an Element instance.

    """
    if not parser:
        parser = XMLParser(target=TreeBuilder())
    parser.feed(text)
    return parser.close()


def XMLID(text, parser=None):
    """Parse XML document from string constant for its IDs.

    *text* is a string containing XML data, *parser* is an
    optional parser instance, defaulting to the standard XMLParser.

    Returns an (Element, dict) tuple, in which the
    dict maps element id:s to elements.

    """
    if not parser:
        parser = XMLParser(target=TreeBuilder())
    parser.feed(text)
    tree = parser.close()
    ids = {}
    for elem in tree.iter():
        id = elem.get("id")
        if id:
            ids[id] = elem
    return tree, ids

# Parse XML document from string constant.  Alias for XML().
fromstring = XML

def fromstringlist(sequence, parser=None):
    """Parse XML document from sequence of string fragments.

    *sequence* is a list of other sequence, *parser* is an optional parser
    instance, defaulting to the standard XMLParser.

    Returns an Element instance.

    """
    if not parser:
        parser = XMLParser(target=TreeBuilder())
    for text in sequence:
        parser.feed(text)
    return parser.close()

# --------------------------------------------------------------------


class TreeBuilder:
    """Generic element structure builder.

    This builder converts a sequence of start, data, and end method
    calls to a well-formed element structure.

    You can use this class to build an element structure using a custom XML
    parser, or a parser for some other XML-like format.

    *element_factory* is an optional element factory which is called
    to create new Element instances, as necessary.

    *comment_factory* is a factory to create comments to be used instead of
    the standard factory.  If *insert_comments* is false (the default),
    comments will not be inserted into the tree.

    *pi_factory* is a factory to create processing instructions to be used
    instead of the standard factory.  If *insert_pis* is false (the default),
    processing instructions will not be inserted into the tree.
    """
    def __init__(self, element_factory=None, *,
                 comment_factory=None, pi_factory=None,
                 insert_comments=False, insert_pis=False):
        self._data = [] # data collector
        self._elem = [] # element stack
        self._last = None # last element
        self._root = None # root element
        self._tail = None # true if we're after an end tag
        if comment_factory is None:
            comment_factory = Comment
        self._comment_factory = comment_factory
        self.insert_comments = insert_comments
        if pi_factory is None:
            pi_factory = ProcessingInstruction
        self._pi_factory = pi_factory
        self.insert_pis = insert_pis
        if element_factory is None:
            element_factory = Element
        self._factory = element_factory

    def close(self):
        """Flush builder buffers and return toplevel document Element."""
        assert len(self._elem) == 0, "missing end tags"
        assert self._root is not None, "missing toplevel element"
        return self._root

    def _flush(self):
        if self._data:
            if self._last is not None:
                text = "".join(self._data)
                if self._tail:
                    assert self._last.tail is None, "internal error (tail)"
                    self._last.tail = text
                else:
                    assert self._last.text is None, "internal error (text)"
                    self._last.text = text
            self._data = []

    def data(self, data):
        """Add text to current element."""
        self._data.append(data)

    def start(self, tag, attrs):
        """Open new element and return it.

        *tag* is the element name, *attrs* is a dict containing element
        attributes.

        """
        self._flush()
        self._last = elem = self._factory(tag, attrs)
        if self._elem:
            self._elem[-1].append(elem)
        elif self._root is None:
            self._root = elem
        self._elem.append(elem)
        self._tail = 0
        return elem

    def end(self, tag):
        """Close and return current Element.

        *tag* is the element name.

        """
        self._flush()
        self._last = self._elem.pop()
        assert self._last.tag == tag,\
               "end tag mismatch (expected %s, got %s)" % (
                   self._last.tag, tag)
        self._tail = 1
        return self._last

    def comment(self, text):
        """Create a comment using the comment_factory.

        *text* is the text of the comment.
        """
        return self._handle_single(
            self._comment_factory, self.insert_comments, text)

    def pi(self, target, text=None):
        """Create a processing instruction using the pi_factory.

        *target* is the target name of the processing instruction.
        *text* is the data of the processing instruction, or ''.
        """
        return self._handle_single(
            self._pi_factory, self.insert_pis, target, text)

    def _handle_single(self, factory, insert, *args):
        elem = factory(*args)
        if insert:
            self._flush()
            self._last = elem
            if self._elem:
                self._elem[-1].append(elem)
            self._tail = 1
        return elem


# also see ElementTree and TreeBuilder
class XMLParser:
    """Element structure builder for XML source data based on the expat parser.

    *target* is an optional target object which defaults to an instance of the
    standard TreeBuilder class, *encoding* is an optional encoding string
    which if given, overrides the encoding specified in the XML file:
    http://www.iana.org/assignments/character-sets

    """

    def __init__(self, *, target=None, encoding=None):
        try:
            from xml.parsers import expat
        except ImportError:
            try:
                import pyexpat as expat
            except ImportError:
                raise ImportError(
                    "No module named expat; use SimpleXMLTreeBuilder instead"
                    )
        parser = expat.ParserCreate(encoding, "}")
        if target is None:
            target = TreeBuilder()
        # underscored names are provided for compatibility only
        self.parser = self._parser = parser
        self.target = self._target = target
        self._error = expat.error
        self._names = {} # name memo cache
        # main callbacks
        parser.DefaultHandlerExpand = self._default
        if hasattr(target, 'start'):
            parser.StartElementHandler = self._start
        if hasattr(target, 'end'):
            parser.EndElementHandler = self._end
        if hasattr(target, 'start_ns'):
            parser.StartNamespaceDeclHandler = self._start_ns
        if hasattr(target, 'end_ns'):
            parser.EndNamespaceDeclHandler = self._end_ns
        if hasattr(target, 'data'):
            parser.CharacterDataHandler = target.data
        # miscellaneous callbacks
        if hasattr(target, 'comment'):
            parser.CommentHandler = target.comment
        if hasattr(target, 'pi'):
            parser.ProcessingInstructionHandler = target.pi
        # Configure pyexpat: buffering, new-style attribute handling.
        parser.buffer_text = 1
        parser.ordered_attributes = 1
        self._doctype = None
        self.entity = {}
        try:
            self.version = "Expat %d.%d.%d" % expat.version_info
        except AttributeError:
            pass # unknown

    def _setevents(self, events_queue, events_to_report):
        # Internal API for XMLPullParser
        # events_to_report: a list of events to report during parsing (same as
        # the *events* of XMLPullParser's constructor.
        # events_queue: a list of actual parsing events that will be populated
        # by the underlying parser.
        #
        parser = self._parser
        append = events_queue.append
        for event_name in events_to_report:
            if event_name == "start":
                parser.ordered_attributes = 1
                def handler(tag, attrib_in, event=event_name, append=append,
                            start=self._start):
                    append((event, start(tag, attrib_in)))
                parser.StartElementHandler = handler
            elif event_name == "end":
                def handler(tag, event=event_name, append=append,
                            end=self._end):
                    append((event, end(tag)))
                parser.EndElementHandler = handler
            elif event_name == "start-ns":
                # TreeBuilder does not implement .start_ns()
                if hasattr(self.target, "start_ns"):
                    def handler(prefix, uri, event=event_name, append=append,
                                start_ns=self._start_ns):
                        append((event, start_ns(prefix, uri)))
                else:
                    def handler(prefix, uri, event=event_name, append=append):
                        append((event, (prefix or '', uri or '')))
                parser.StartNamespaceDeclHandler = handler
            elif event_name == "end-ns":
                # TreeBuilder does not implement .end_ns()
                if hasattr(self.target, "end_ns"):
                    def handler(prefix, event=event_name, append=append,
                                end_ns=self._end_ns):
                        append((event, end_ns(prefix)))
                else:
                    def handler(prefix, event=event_name, append=append):
                        append((event, None))
                parser.EndNamespaceDeclHandler = handler
            elif event_name == 'comment':
                def handler(text, event=event_name, append=append, self=self):
                    append((event, self.target.comment(text)))
                parser.CommentHandler = handler
            elif event_name == 'pi':
                def handler(pi_target, data, event=event_name, append=append,
                            self=self):
                    append((event, self.target.pi(pi_target, data)))
                parser.ProcessingInstructionHandler = handler
            else:
                raise ValueError("unknown event %r" % event_name)

    def _raiseerror(self, value):
        err = ParseError(value)
        err.code = value.code
        err.position = value.lineno, value.offset
        raise err

    def _fixname(self, key):
        # expand qname, and convert name string to ascii, if possible
        try:
            name = self._names[key]
        except KeyError:
            name = key
            if "}" in name:
                name = "{" + name
            self._names[key] = name
        return name

    def _start_ns(self, prefix, uri):
        return self.target.start_ns(prefix or '', uri or '')

    def _end_ns(self, prefix):
        return self.target.end_ns(prefix or '')

    def _start(self, tag, attr_list):
        # Handler for expat's StartElementHandler. Since ordered_attributes
        # is set, the attributes are reported as a list of alternating
        # attribute name,value.
        fixname = self._fixname
        tag = fixname(tag)
        attrib = {}
        if attr_list:
            for i in range(0, len(attr_list), 2):
                attrib[fixname(attr_list[i])] = attr_list[i+1]
        return self.target.start(tag, attrib)

    def _end(self, tag):
        return self.target.end(self._fixname(tag))

    def _default(self, text):
        prefix = text[:1]
        if prefix == "&":
            # deal with undefined entities
            try:
                data_handler = self.target.data
            except AttributeError:
                return
            try:
                data_handler(self.entity[text[1:-1]])
            except KeyError:
                from xml.parsers import expat
                err = expat.error(
                    "undefined entity %s: line %d, column %d" %
                    (text, self.parser.ErrorLineNumber,
                    self.parser.ErrorColumnNumber)
                    )
                err.code = 11 # XML_ERROR_UNDEFINED_ENTITY
                err.lineno = self.parser.ErrorLineNumber
                err.offset = self.parser.ErrorColumnNumber
                raise err
        elif prefix == "<" and text[:9] == "<!DOCTYPE":
            self._doctype = [] # inside a doctype declaration
        elif self._doctype is not None:
            # parse doctype contents
            if prefix == ">":
                self._doctype = None
                return
            text = text.strip()
            if not text:
                return
            self._doctype.append(text)
            n = len(self._doctype)
            if n > 2:
                type = self._doctype[1]
                if type == "PUBLIC" and n == 4:
                    name, type, pubid, system = self._doctype
                    if pubid:
                        pubid = pubid[1:-1]
                elif type == "SYSTEM" and n == 3:
                    name, type, system = self._doctype
                    pubid = None
                else:
                    return
                if hasattr(self.target, "doctype"):
                    self.target.doctype(name, pubid, system[1:-1])
                elif hasattr(self, "doctype"):
                    warnings.warn(
                        "The doctype() method of XMLParser is ignored.  "
                        "Define doctype() method on the TreeBuilder target.",
                        RuntimeWarning)

                self._doctype = None

    def feed(self, data):
        """Feed encoded data to parser."""
        try:
            self.parser.Parse(data, False)
        except self._error as v:
            self._raiseerror(v)

    def close(self):
        """Finish feeding data to parser and return element structure."""
        try:
            self.parser.Parse(b"", True) # end of data
        except self._error as v:
            self._raiseerror(v)
        try:
            close_handler = self.target.close
        except AttributeError:
            pass
        else:
            return close_handler()
        finally:
            # get rid of circular references
            del self.parser, self._parser
            del self.target, self._target


# --------------------------------------------------------------------
# C14N 2.0

def canonicalize(xml_data=None, *, out=None, from_file=None, **options):
    """Convert XML to its C14N 2.0 serialised form.

    If *out* is provided, it must be a file or file-like object that receives
    the serialised canonical XML output (text, not bytes) through its ``.write()``
    method.  To write to a file, open it in text mode with encoding "utf-8".
    If *out* is not provided, this function returns the output as text string.

    Either *xml_data* (an XML string) or *from_file* (a file path or
    file-like object) must be provided as input.

    The configuration options are the same as for the ``C14NWriterTarget``.
    """
    if xml_data is None and from_file is None:
        raise ValueError("Either 'xml_data' or 'from_file' must be provided as input")
    sio = None
    if out is None:
        sio = out = io.StringIO()

    parser = XMLParser(target=C14NWriterTarget(out.write, **options))

    if xml_data is not None:
        parser.feed(xml_data)
        parser.close()
    elif from_file is not None:
        parse(from_file, parser=parser)

    return sio.getvalue() if sio is not None else None


_looks_like_prefix_name = re.compile(r'^\w+:\w+$', re.UNICODE).match


class C14NWriterTarget:
    """
    Canonicalization writer target for the XMLParser.

    Serialises parse events to XML C14N 2.0.

    The *write* function is used for writing out the resulting data stream
    as text (not bytes).  To write to a file, open it in text mode with encoding
    "utf-8" and pass its ``.write`` method.

    Configuration options:

    - *with_comments*: set to true to include comments
    - *strip_text*: set to true to strip whitespace before and after text content
    - *rewrite_prefixes*: set to true to replace namespace prefixes by "n{number}"
    - *qname_aware_tags*: a set of qname aware tag names in which prefixes
                          should be replaced in text content
    - *qname_aware_attrs*: a set of qname aware attribute names in which prefixes
                           should be replaced in text content
    - *exclude_attrs*: a set of attribute names that should not be serialised
    - *exclude_tags*: a set of tag names that should not be serialised
    """
    def __init__(self, write, *,
                 with_comments=False, strip_text=False, rewrite_prefixes=False,
                 qname_aware_tags=None, qname_aware_attrs=None,
                 exclude_attrs=None, exclude_tags=None):
        self._write = write
        self._data = []
        self._with_comments = with_comments
        self._strip_text = strip_text
        self._exclude_attrs = set(exclude_attrs) if exclude_attrs else None
        self._exclude_tags = set(exclude_tags) if exclude_tags else None

        self._rewrite_prefixes = rewrite_prefixes
        if qname_aware_tags:
            self._qname_aware_tags = set(qname_aware_tags)
        else:
            self._qname_aware_tags = None
        if qname_aware_attrs:
            self._find_qname_aware_attrs = set(qname_aware_attrs).intersection
        else:
            self._find_qname_aware_attrs = None

        # Stack with globally and newly declared namespaces as (uri, prefix) pairs.
        self._declared_ns_stack = [[
            ("http://www.w3.org/XML/1998/namespace", "xml"),
        ]]
        # Stack with user declared namespace prefixes as (uri, prefix) pairs.
        self._ns_stack = []
        if not rewrite_prefixes:
            self._ns_stack.append(list(_namespace_map.items()))
        self._ns_stack.append([])
        self._prefix_map = {}
        self._preserve_space = [False]
        self._pending_start = None
        self._root_seen = False
        self._root_done = False
        self._ignored_depth = 0

    def _iter_namespaces(self, ns_stack, _reversed=reversed):
        for namespaces in _reversed(ns_stack):
            if namespaces:  # almost no element declares new namespaces
                yield from namespaces

    def _resolve_prefix_name(self, prefixed_name):
        prefix, name = prefixed_name.split(':', 1)
        for uri, p in self._iter_namespaces(self._ns_stack):
            if p == prefix:
                return f'{{{uri}}}{name}'
        raise ValueError(f'Prefix {prefix} of QName "{prefixed_name}" is not declared in scope')

    def _qname(self, qname, uri=None):
        if uri is None:
            uri, tag = qname[1:].rsplit('}', 1) if qname[:1] == '{' else ('', qname)
        else:
            tag = qname

        prefixes_seen = set()
        for u, prefix in self._iter_namespaces(self._declared_ns_stack):
            if u == uri and prefix not in prefixes_seen:
                return f'{prefix}:{tag}' if prefix else tag, tag, uri
            prefixes_seen.add(prefix)

        # Not declared yet => add new declaration.
        if self._rewrite_prefixes:
            if uri in self._prefix_map:
                prefix = self._prefix_map[uri]
            else:
                prefix = self._prefix_map[uri] = f'n{len(self._prefix_map)}'
            self._declared_ns_stack[-1].append((uri, prefix))
            return f'{prefix}:{tag}', tag, uri

        if not uri and '' not in prefixes_seen:
            # No default namespace declared => no prefix needed.
            return tag, tag, uri

        for u, prefix in self._iter_namespaces(self._ns_stack):
            if u == uri:
                self._declared_ns_stack[-1].append((uri, prefix))
                return f'{prefix}:{tag}' if prefix else tag, tag, uri

        if not uri:
            # As soon as a default namespace is defined,
            # anything that has no namespace (and thus, no prefix) goes there.
            return tag, tag, uri

        raise ValueError(f'Namespace "{uri}" is not declared in scope')

    def data(self, data):
        if not self._ignored_depth:
            self._data.append(data)

    def _flush(self, _join_text=''.join):
        data = _join_text(self._data)
        del self._data[:]
        if self._strip_text and not self._preserve_space[-1]:
            data = data.strip()
        if self._pending_start is not None:
            args, self._pending_start = self._pending_start, None
            qname_text = data if data and _looks_like_prefix_name(data) else None
            self._start(*args, qname_text)
            if qname_text is not None:
                return
        if data and self._root_seen:
            self._write(_escape_cdata_c14n(data))

    def start_ns(self, prefix, uri):
        if self._ignored_depth:
            return
        # we may have to resolve qnames in text content
        if self._data:
            self._flush()
        self._ns_stack[-1].append((uri, prefix))

    def start(self, tag, attrs):
        if self._exclude_tags is not None and (
                self._ignored_depth or tag in self._exclude_tags):
            self._ignored_depth += 1
            return
        if self._data:
            self._flush()

        new_namespaces = []
        self._declared_ns_stack.append(new_namespaces)

        if self._qname_aware_tags is not None and tag in self._qname_aware_tags:
            # Need to parse text first to see if it requires a prefix declaration.
            self._pending_start = (tag, attrs, new_namespaces)
            return
        self._start(tag, attrs, new_namespaces)

    def _start(self, tag, attrs, new_namespaces, qname_text=None):
        if self._exclude_attrs is not None and attrs:
            attrs = {k: v for k, v in attrs.items() if k not in self._exclude_attrs}

        qnames = {tag, *attrs}
        resolved_names = {}

        # Resolve prefixes in attribute and tag text.
        if qname_text is not None:
            qname = resolved_names[qname_text] = self._resolve_prefix_name(qname_text)
            qnames.add(qname)
        if self._find_qname_aware_attrs is not None and attrs:
            qattrs = self._find_qname_aware_attrs(attrs)
            if qattrs:
                for attr_name in qattrs:
                    value = attrs[attr_name]
                    if _looks_like_prefix_name(value):
                        qname = resolved_names[value] = self._resolve_prefix_name(value)
                        qnames.add(qname)
            else:
                qattrs = None
        else:
            qattrs = None

        # Assign prefixes in lexicographical order of used URIs.
        parse_qname = self._qname
        parsed_qnames = {n: parse_qname(n) for n in sorted(
            qnames, key=lambda n: n.split('}', 1))}

        # Write namespace declarations in prefix order ...
        if new_namespaces:
            attr_list = [
                ('xmlns:' + prefix if prefix else 'xmlns', uri)
                for uri, prefix in new_namespaces
            ]
            attr_list.sort()
        else:
            # almost always empty
            attr_list = []

        # ... followed by attributes in URI+name order
        if attrs:
            for k, v in sorted(attrs.items()):
                if qattrs is not None and k in qattrs and v in resolved_names:
                    v = parsed_qnames[resolved_names[v]][0]
                attr_qname, attr_name, uri = parsed_qnames[k]
                # No prefix for attributes in default ('') namespace.
                attr_list.append((attr_qname if uri else attr_name, v))

        # Honour xml:space attributes.
        space_behaviour = attrs.get('{http://www.w3.org/XML/1998/namespace}space')
        self._preserve_space.append(
            space_behaviour == 'preserve' if space_behaviour
            else self._preserve_space[-1])

        # Write the tag.
        write = self._write
        write('<' + parsed_qnames[tag][0])
        if attr_list:
            write(''.join([f' {k}="{_escape_attrib_c14n(v)}"' for k, v in attr_list]))
        write('>')

        # Write the resolved qname text content.
        if qname_text is not None:
            write(_escape_cdata_c14n(parsed_qnames[resolved_names[qname_text]][0]))

        self._root_seen = True
        self._ns_stack.append([])

    def end(self, tag):
        if self._ignored_depth:
            self._ignored_depth -= 1
            return
        if self._data:
            self._flush()
        self._write(f'</{self._qname(tag)[0]}>')
        self._preserve_space.pop()
        self._root_done = len(self._preserve_space) == 1
        self._declared_ns_stack.pop()
        self._ns_stack.pop()

    def comment(self, text):
        if not self._with_comments:
            return
        if self._ignored_depth:
            return
        if self._root_done:
            self._write('\n')
        elif self._root_seen and self._data:
            self._flush()
        self._write(f'<!--{_escape_cdata_c14n(text)}-->')
        if not self._root_seen:
            self._write('\n')

    def pi(self, target, data):
        if self._ignored_depth:
            return
        if self._root_done:
            self._write('\n')
        elif self._root_seen and self._data:
            self._flush()
        self._write(
            f'<?{target} {_escape_cdata_c14n(data)}?>' if data else f'<?{target}?>')
        if not self._root_seen:
            self._write('\n')


def _escape_cdata_c14n(text):
    # escape character data
    try:
        # it's worth avoiding do-nothing calls for strings that are
        # shorter than 500 character, or so.  assume that's, by far,
        # the most common case in most applications.
        if '&' in text:
            text = text.replace('&', '&amp;')
        if '<' in text:
            text = text.replace('<', '&lt;')
        if '>' in text:
            text = text.replace('>', '&gt;')
        if '\r' in text:
            text = text.replace('\r', '&#xD;')
        return text
    except (TypeError, AttributeError):
        _raise_serialization_error(text)


def _escape_attrib_c14n(text):
    # escape attribute value
    try:
        if '&' in text:
            text = text.replace('&', '&amp;')
        if '<' in text:
            text = text.replace('<', '&lt;')
        if '"' in text:
            text = text.replace('"', '&quot;')
        if '\t' in text:
            text = text.replace('\t', '&#x9;')
        if '\n' in text:
            text = text.replace('\n', '&#xA;')
        if '\r' in text:
            text = text.replace('\r', '&#xD;')
        return text
    except (TypeError, AttributeError):
        _raise_serialization_error(text)


# --------------------------------------------------------------------

# Import the C accelerators
try:
    # Element is going to be shadowed by the C implementation. We need to keep
    # the Python version of it accessible for some "creative" by external code
    # (see tests)
    _Element_Py = Element

    # Element, SubElement, ParseError, TreeBuilder, XMLParser, _set_factories
    from _elementtree import *
    from _elementtree import _set_factories
except ImportError:
    pass
else:
    _set_factories(Comment, ProcessingInstruction)
                                                                                                                                                                                                                                                                                                                                                                                                                                                usr/lib/python3.11/xml/etree/__init__.py                                                            0000644 0000000 0000000 00000003105 14671176116 016475  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # $Id: __init__.py 3375 2008-02-13 08:05:08Z fredrik $
# elementtree package

# --------------------------------------------------------------------
# The ElementTree toolkit is
#
# Copyright (c) 1999-2008 by Fredrik Lundh
#
# By obtaining, using, and/or copying this software and/or its
# associated documentation, you agree that you have read, understood,
# and will comply with the following terms and conditions:
#
# Permission to use, copy, modify, and distribute this software and
# its associated documentation for any purpose and without fee is
# hereby granted, provided that the above copyright notice appears in
# all copies, and that both that copyright notice and this permission
# notice appear in supporting documentation, and that the name of
# Secret Labs AB or the author not be used in advertising or publicity
# pertaining to distribution of the software without specific, written
# prior permission.
#
# SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
# TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-
# ABILITY AND FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR
# BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
# OF THIS SOFTWARE.
# --------------------------------------------------------------------

# Licensed to PSF under a Contributor Agreement.
# See https://www.python.org/psf/license for licensing details.
                                                                                                                                                                                                                                                                                                                                                                                                                                                           usr/lib/python3.11/xml/etree/__pycache__/                                                           0000755 0000000 0000000 00000000000 14714551121 016564  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python3.11/xml/etree/__pycache__/ElementInclude.cpython-311.pyc                             0000644 0000000 0000000 00000011014 14714551121 024160  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        §
    Nüäfâ  ã                   ó–   — d dl Z ddlmZ d dlmZ dZedz   Zedz   ZdZ G d	„ d
e	¦  «        Z
 G d„ de
¦  «        Zdd„Zddefd„Zd„ ZdS )é    Né   )ÚElementTree)Úurljoinz!{http://www.w3.org/2001/XInclude}ÚincludeÚfallbacké   c                   ó   — e Zd ZdS )ÚFatalIncludeErrorN©Ú__name__Ú
__module__Ú__qualname__© ó    ú//usr/lib/python3.11/xml/etree/ElementInclude.pyr
   r
   C   ó   € € € € € Ø€Dr   r
   c                   ó   — e Zd ZdS )ÚLimitedRecursiveIncludeErrorNr   r   r   r   r   r   G   r   r   r   c                 ó4  — |dk    rOt          | d¦  «        5 }t          j        |¦  «                             ¦   «         }d d d ¦  «         n# 1 swxY w Y   nB|sd}t          | d|¬¦  «        5 }|                     ¦   «         }d d d ¦  «         n# 1 swxY w Y   |S )NÚxmlÚrbzUTF-8Úr)Úencoding)Úopenr   ÚparseÚgetrootÚread)Úhrefr   r   ÚfileÚdatas        r   Údefault_loaderr!   W   s  € Ø‚~€~İ$˜ÑÔğ 	5 İÔ$ TÑ*Ô*×2Ò2Ñ4Ô4ˆDğ	5ğ 	5ğ 	5ñ 	5ô 	5ğ 	5ğ 	5ğ 	5ğ 	5ğ 	5ğ 	5øøøğ 	5ğ 	5ğ 	5ğ 	5øğ ğ 	ØˆHİ$˜ hĞ/Ñ/Ô/ğ 	°4Ø—9’9‘;”;ˆDğ	ğ 	ğ 	ñ 	ô 	ğ 	ğ 	ğ 	ğ 	ğ 	ğ 	øøøğ 	ğ 	ğ 	ğ 	à€Ks#   —'A
Á
AÁAÁ,BÂBÂBc                 óØ   — |€d}n|dk     rt          d|z  ¦  «        ‚t          | d¦  «        r|                      ¦   «         } |€t          }t	          | |||t          ¦   «         ¦  «         d S )Néÿÿÿÿr   z;expected non-negative depth or None for 'max_depth', got %rr   )Ú
ValueErrorÚhasattrr   r!   Ú_includeÚset)ÚelemÚloaderÚbase_urlÚ	max_depths       r   r   r   t   sv   € àĞØˆ	ˆ	Ø	QŠˆİĞVĞYbÑbÑcÔcĞcåˆtYÑÔğ Ø|Š|‰~Œ~ˆØ€~İˆåˆT6˜8 Yµ±´Ñ6Ô6Ğ6Ğ6Ğ6r   c                 óN  — d}|t          | ¦  «        k     r| |         }|j        t          k    r |                     d¦  «        }|rt	          ||¦  «        }|                     dd¦  «        }|dk    rÈ||v rt          d|z  ¦  «        ‚|dk    rt          d|z  ¦  «        ‚|                     |¦  «          |||¦  «        }	|	€t          d|›d|›¦  «        ‚t          j        |	¦  «        }	t          |	|||d	z
  |¦  «         | 
                    |¦  «         |j        r|	j        pd
|j        z   |	_        |	| |<   nÏ|dk    r} ||||                     d¦  «        ¦  «        }
|
€t          d|›d|›¦  «        ‚|j        r
|
|j        z  }
|r| |d	z
           }	|	j        pd
|
z   |	_        n| j        pd
|
z   | _        | |= Œ»t          d|z  ¦  «        ‚|j        t          k    rt          d|j        z  ¦  «        ‚t          |||||¦  «         |d	z  }|t          | ¦  «        k     °d S d S )Nr   r   r   r   zrecursive include of %sz5maximum xinclude depth reached when including file %szcannot load z as r   Ú Útextr   z)unknown parse type in xi:include tag (%r)z0xi:fallback tag must be child of xi:include (%r))ÚlenÚtagÚXINCLUDE_INCLUDEÚgetr   r
   r   ÚaddÚcopyr&   ÚremoveÚtailr.   ÚXINCLUDE_FALLBACK)r(   r)   r*   r+   Ú_parent_hrefsÚiÚer   r   Únoder.   s              r   r&   r&   ƒ   s•  € à	€AØ
c$‰iŒiŠ-‰-ØŒGˆØŒ5Õ$Ò$Ñ$à—5’5˜‘=”=ˆDØğ /İ˜x¨Ñ.Ô.Ø—E’E˜' 5Ñ)Ô)ˆEØ˜Š~ˆ~Ø˜=Ğ(Ğ(İ+Ğ,EÈÑ,LÑMÔMĞMØ ’>>İ6ØOĞRVÑVñXô Xğ Xà×!Ò! $Ñ'Ô'Ğ'Øv˜d EÑ*Ô*Ø<İ+Ğ+Ø26°$°$¸¸Ğ>ñô ğ õ ”y ‘”İ˜˜v t¨Y¸©]¸MÑJÔJĞJØ×$Ò$ TÑ*Ô*Ğ*Ø”6ğ ;Ø!%¤ ¨b°A´FÑ :D”IØQ‘Ø˜&’Øv˜d E¨1¯5ª5°Ñ+<Ô+<Ñ=Ô=Ø<İ+Ğ+Ø26°$°$¸¸Ğ>ñô ğ ğ ”6ğ #Ø˜AœF‘NDØğ 9Ø  !¡œ9DØ!%¤ ¨b°DÑ 8D”IIà!%¤ ¨b°DÑ 8D”IØ˜GÙå'Ø?À%ÑGñô ğ ğ ŒUÕ'Ò'Ğ'İ#ØBÀQÄUÑJñô ğ õ Q˜ ¨)°]ÑCÔCĞCØ	ˆQ‰ˆğg c$‰iŒiŠ-‰-ˆ-ˆ-ˆ-ˆ-r   )N)r4   r-   r   Úurllib.parser   ÚXINCLUDEr1   r7   ÚDEFAULT_MAX_INCLUSION_DEPTHÚSyntaxErrorr
   r   r!   r   r&   r   r   r   ú<module>r@      sø   ğğf €€€Ø Ğ Ğ Ğ Ğ Ğ Ø  Ğ  Ğ  Ğ  Ğ  Ğ  à.€à˜iÑ'Ğ Ø˜zÑ)Ğ ğ  Ğ ğ	ğ 	ğ 	ğ 	ğ 	˜ñ 	ô 	ğ 	ğ	ğ 	ğ 	ğ 	ğ 	Ğ#4ñ 	ô 	ğ 	ğ 	ğ 	ğ 	ğ 	ğ: ¨Ø1ğ7ğ 7ğ 7ğ 7ğ6ğ 6ğ 6ğ 6ğ 6r                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/lib/python3.11/xml/etree/__pycache__/ElementPath.cpython-311.pyc                                0000644 0000000 0000000 00000041517 14714551121 023504  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        §
    Nüäf­6  ã                   ó¼   — d dl Z  e j        d¦  «        Zdd„Zd„ Zd„ Zd„ Zd„ Zd„ Zd	„ Z	d
„ Z
d„ Zd„ Zeee	ee
edœZi Z G d„ d¦  «        Zdd„Zdd„Zdd„Zdd„ZdS )é    Nz`('[^']*'|\"[^\"]*\"|::|//?|\.\.|\(\)|!=|[/.*:\[\]\(\)@=])|((?:\{[^}]+\})?[^/\[\]\(\)@!=\s]+)|\s+c              #   óš  K  — |r|                      d¦  «        nd }d}t                               | ¦  «        D ]’}|\  }}|r|d         dk    rsd|v rW|                     dd¦  «        \  }}	 |st          ‚|d||         ›d|›fV — n6# t          $ r t          d|z  ¦  «        d ‚w xY w|r|s|d|›d|›fV — n|V — d}Œˆ|V — |d	k    }Œ“d S )
NÚ Fr   ú{ú:é   ú}z!prefix %r not found in prefix mapú@)ÚgetÚxpath_tokenizer_reÚfindallÚsplitÚKeyErrorÚSyntaxError)	ÚpatternÚ
namespacesÚdefault_namespaceÚparsing_attributeÚtokenÚttypeÚtagÚprefixÚuris	            ú,/usr/lib/python3.11/xml/etree/ElementPath.pyÚxpath_tokenizerr   J   sY  è è € Ø.8ĞB˜
Ÿš rÑ*Ô*Ğ*¸dĞØĞİ#×+Ò+¨GÑ4Ô4ğ -ğ -ˆØ‰
ˆˆsØğ 	-3q”6˜S’==ØcˆzˆzØ!Ÿiši¨¨QÑ/Ô/‘˜ğ^Ø%ğ 'İ&˜Ø˜%¨Z¸Ô-?Ğ-?Ğ-?ÀÀĞ!EĞEĞEĞEĞEĞEøİğ ^ğ ^ğ ^İ%Ğ&IÈFÑ&RÑSÔSĞY]Ğ]ğ^øøøà"ğ Ğ+<ğ ØeĞ):Ğ):Ğ):¸C¸CĞ@Ğ@Ğ@Ğ@Ğ@Ğ@àØ %ĞĞàˆKˆKˆKØ %¨¢ĞĞğ%-ğ -s   Á+BÂB%c                 óv   — | j         }|€/i x| _         }| j                             ¦   «         D ]}|D ]}|||<   ŒŒ|S ©N)Ú
parent_mapÚrootÚiter)Úcontextr   ÚpÚes       r   Úget_parent_mapr#   b   s_   € ØÔ#€JØĞØ*,Ğ,ˆÔ˜ZØ”×"Ò"Ñ$Ô$ğ 	"ğ 	"ˆAØğ "ğ "Ø !
˜1‘ğ"àĞó    c                 ó:   — | d d…         dk    p| dd …         dk    S )Né   ú{*}éşÿÿÿú}*© ©r   s    r   Ú_is_wildcard_tagr,   l   s'   € ØˆrˆrŒ7eÒĞ/˜s 2 3 3œx¨4Ò/Ğ/r$   c                 óš  ‡ ‡‡‡‡‡‡— t           t          cŠŠ‰ dk    rˆˆfd„}n§‰ dk    rˆˆfd„}nš‰ d d…         dk    r<‰ dd …         Št          t          ‰¦  «         d ¦  «        Š‰ dd …         Š ˆˆˆˆˆ fd„}nP‰ d	d …         d
k    r0‰ d d…         Št          d t          ‰¦  «        ¦  «        Šˆˆˆˆfd„}nt	          d‰ › ¦  «        ‚|S )Nz{*}*c              3   ó@   •K  — |D ]} ‰|j         ‰¦  «        r|V — Œd S r   r+   )r    ÚresultÚelemÚ_isinstanceÚ_strs      €€r   Úselectz_prepare_tag.<locals>.selectv   s@   øè è € Øğ ğ Ø;˜tœx¨Ñ.Ô.ğ ØJJJøğğ r$   z{}*c              3   ó\   •K  — |D ]%}|j         } ‰|‰¦  «        r|d         dk    r|V — Œ&d S )Nr   r   r+   )r    r/   r0   Úel_tagr1   r2   s       €€r   r3   z_prepare_tag.<locals>.select|   sS   øè è € Øğ ğ ØœØ;˜v tÑ,Ô,ğ °¸´¸cÒ1AĞ1AØJJJøğğ r$   r&   r'   é   c              3   óh   •K  — |D ]+}|j         }|‰k    s ‰|‰¦  «        r|‰         ‰k    r|V — Œ,d S r   r+   )	r    r/   r0   r5   r1   r2   Úno_nsÚsuffixr   s	       €€€€€r   r3   z_prepare_tag.<locals>.select†   sY   øè è € Øğ ğ ØœØ˜S’== K K°¸Ñ$=Ô$==À&ÈÄ-ĞSYÒBYĞBYØJJJøğğ r$   r(   r)   éÿÿÿÿc              3   ó\   •K  — |D ]%}|j         } ‰|‰¦  «        r|‰         ‰k    r|V — Œ&d S r   r+   )r    r/   r0   r5   r1   r2   ÚnsÚns_onlys       €€€€r   r3   z_prepare_tag.<locals>.select   sS   øè è € Øğ ğ ØœØ;˜v tÑ,Ô,ğ °¸´ÀBÒ1FĞ1FØJJJøğğ r$   zinternal parser error, got )Ú
isinstanceÚstrÚsliceÚlenÚRuntimeError)r   r3   r1   r2   r8   r<   r=   r9   s   ` @@@@@@r   Ú_prepare_tagrC   p   si  øøøøøøø€ İ"¥CĞ€KØ
ˆf‚}€}ğ	ğ 	ğ 	ğ 	ğ 	ğ 	ğ 	ğ 
Šˆğ	ğ 	ğ 	ğ 	ğ 	ğ 	ğ 	ğ
 
ˆRˆaˆRŒEÒ	Ğ	àQRR”ˆİ•s˜6‘{”{l DÑ)Ô)ˆØ!""Œgˆğ	ğ 	ğ 	ğ 	ğ 	ğ 	ğ 	ğ 	ğ 	ğ 	ğ
 
ˆRˆSˆSŒTÒ	Ğ	à"ŒXˆİ˜c "™gœgÑ&Ô&ˆğ	ğ 	ğ 	ğ 	ğ 	ğ 	ğ 	ğ 	ğ 	õ Ğ>¸Ğ>Ğ>Ñ?Ô?Ğ?Ø€Mr$   c                 óœ   ‡‡— |d         Št          ‰¦  «        rt          ‰¦  «        Šˆfd„}n‰d d…         dk    r
‰dd …         Šˆfd„}|S )Nr   c                 ó4   •— d„ } ‰|  ||¦  «        ¦  «        S )Nc              3   ó$   K  — | D ]
}|E d {V —† Œd S r   r*   )r/   r0   s     r   Úselect_childz3prepare_child.<locals>.select.<locals>.select_child   s2   è è € Ø"ğ $ğ $DØ#OOOOOOOOğ$ğ $r$   r*   ©r    r/   rG   Ú
select_tags      €r   r3   zprepare_child.<locals>.select   s0   ø€ ğ$ğ $ğ $ğ :˜g | |°FÑ';Ô';Ñ<Ô<Ğ<r$   r6   ú{}c              3   ó>   •K  — |D ]}|D ]}|j         ‰k    r|V — ŒŒd S r   r+   ©r    r/   r0   r"   r   s       €r   r3   zprepare_child.<locals>.select¥   sI   øè è € Øğ  ğ  Øğ  ğ  AØ”u ’||Ø˜˜˜øğ ğ ğ  r$   )r,   rC   ©Únextr   r3   rI   r   s      @@r   Úprepare_childrO   ™   sˆ   øø€ Ø
Œ(€Cİ˜ÑÔğ  İ! #Ñ&Ô&ˆ
ğ	=ğ 	=ğ 	=ğ 	=ğ 	=ğ 	=ğ ˆrˆrŒ7dŠ?ˆ?Øabb”'ˆCğ	 ğ 	 ğ 	 ğ 	 ğ 	 ğ
 €Mr$   c                 ó   — d„ }|S )Nc              3   ó$   K  — |D ]
}|E d {V —† Œd S r   r*   )r    r/   r0   s      r   r3   zprepare_star.<locals>.select­   s2   è è € Øğ 	ğ 	ˆDØˆOˆOˆOˆOˆOˆOˆOˆOğ	ğ 	r$   r*   ©rN   r   r3   s      r   Úprepare_starrS   ¬   s   € ğğ ğ ğ €Mr$   c                 ó   — d„ }|S )Nc              3   ó   K  — |E d {V —† d S r   r*   )r    r/   s     r   r3   zprepare_self.<locals>.select³   s$   è è € ØĞĞĞĞĞĞĞĞĞr$   r*   rR   s      r   Úprepare_selfrV   ²   s   € ğğ ğ à€Mr$   c                 ó$  ‡‡— 	  | ¦   «         }n# t           $ r Y d S w xY w|d         dk    rdŠn |d         s	|d         Šnt          d¦  «        ‚t          ‰¦  «        rt          ‰¦  «        Šˆfd„}n‰d d…         dk    r
‰dd …         Šˆfd„}|S )	Nr   Ú*r   zinvalid descendantc                 ó4   •— d„ } ‰|  ||¦  «        ¦  «        S )Nc              3   óR   K  — | D ]!}|                      ¦   «         D ]
}||ur|V — ŒŒ"d S r   ©r   )r/   r0   r"   s      r   rG   z8prepare_descendant.<locals>.select.<locals>.select_childÆ   sN   è è € Ø"ğ $ğ $DØ!ŸYšY™[œ[ğ $ğ $˜Ø D˜=˜=Ø"#˜G˜G˜Gøğ$ğ$ğ $r$   r*   rH   s      €r   r3   z"prepare_descendant.<locals>.selectÅ   s0   ø€ ğ$ğ $ğ $ğ
 :˜g | |°FÑ';Ô';Ñ<Ô<Ğ<r$   r6   rJ   c              3   óV   •K  — |D ]"}|                      ‰¦  «        D ]
}||ur|V — ŒŒ#d S r   r[   rL   s       €r   r3   z"prepare_descendant.<locals>.selectÏ   sQ   øè è € Øğ  ğ  ØŸš 3™œğ  ğ  AØ }}Ø˜˜˜øğ ğ ğ  r$   )ÚStopIterationr   r,   rC   rM   s      @@r   Úprepare_descendantr^   ·   sí   øø€ ğØ‘”ˆˆøİğ ğ ğ ØˆˆğøøøàˆQ„x3‚€ØˆˆØ1ŒXğ 0ØAŒhˆˆåĞ.Ñ/Ô/Ğ/å˜ÑÔğ  İ! #Ñ&Ô&ˆ
ğ	=ğ 	=ğ 	=ğ 	=ğ 	=ğ 	=ğ ˆrˆrŒ7dŠ?ˆ?Øabb”'ˆCğ	 ğ 	 ğ 	 ğ 	 ğ 	 ğ
 €Ms   „
 
œc                 ó   — d„ }|S )Nc              3   óh   K  — t          | ¦  «        }i }|D ]}||v r||         }||vr	d ||<   |V — Œd S r   )r#   )r    r/   r   Ú
result_mapr0   Úparents         r   r3   zprepare_parent.<locals>.select×   se   è è € å# GÑ,Ô,ˆ
Øˆ
Øğ 	!ğ 	!ˆDØzĞ!Ğ!Ø# DÔ)Ø Ğ+Ğ+Ø)-J˜vÑ&Ø LLLøğ	!ğ 	!r$   r*   rR   s      r   Úprepare_parentrc   Ö   s   € ğ	!ğ 	!ğ 	!ğ €Mr$   c                 ó´  ‡‡‡‡	— g }g }	 	  | ¦   «         }n# t           $ r Y d S w xY w|d         dk    rnl|dk    rŒ2|d         r$|d         d d…         dv rd|d         dd…         f}|                     |d         pd¦  «         |                     |d         ¦  «         Œ–d	                     |¦  «        }|d
k    r|d         Šˆfd„}|S |dk    s|dk    r$|d         Š|d         Š	ˆˆ	fd„}ˆˆ	fd„}d|v r|n|S |dk    r*t          j        d|d         ¦  «        s|d         Šˆfd„}|S |dk    s-|dk    s'|dk    s|dk    rLt          j        d|d         ¦  «        s1|d         Š|d         Š	‰rˆˆ	fd„}ˆˆ	fd„}n
ˆ	fd„}ˆ	fd„}d|v r|n|S |dk    s|dk    s|dk    r«|dk    r.t          |d         ¦  «        dz
  Š‰dk     rt          d¦  «        ‚np|d         dk    rt          d¦  «        ‚|dk    rM	 t          |d          ¦  «        dz
  Šn# t          $ r t          d!¦  «        ‚w xY w‰d"k    rt          d#¦  «        ‚ndŠˆfd$„}|S t          d%¦  «        ‚)&Nr   r   ú])r   r   z'"ú'r:   ú-r   z@-c              3   óH   •K  — |D ]}|                      ‰¦  «        |V — Œd S r   ©r
   )r    r/   r0   Úkeys      €r   r3   z!prepare_predicate.<locals>.selectû   s:   øè è € Øğ ğ Ø—8’8˜C‘=”=Ğ,ØJJJøğğ r$   z@-='z@-!='c              3   óP   •K  — |D ]}|                      ‰¦  «        ‰k    r|V — Œ d S r   ri   )r    r/   r0   rj   Úvalues      €€r   r3   z!prepare_predicate.<locals>.select  s?   øè è € Øğ ğ Ø—8’8˜C‘=”= EÒ)Ğ)ØJJJøğğ r$   c              3   óX   •K  — |D ]#}|                      ‰¦  «        x}
|‰k    r|V — Œ$d S r   ri   )r    r/   r0   Ú
attr_valuerj   rl   s       €€r   Úselect_negatedz)prepare_predicate.<locals>.select_negated  sI   øè è € Øğ ğ Ø"&§(¢(¨3¡-¤-Ğ/JĞ<ÀÈuÒATĞATØJJJøğğ r$   z!=z\-?\d+$c              3   óH   •K  — |D ]}|                      ‰¦  «        |V — Œd S r   )Úfind)r    r/   r0   r   s      €r   r3   z!prepare_predicate.<locals>.select  s:   øè è € Øğ ğ Ø—9’9˜S‘>”>Ğ-ØJJJøğğ r$   z.='z.!='z-='z-!='c              3   ó¨   •K  — |D ]K}|                      ‰¦  «        D ]3}d                     |                     ¦   «         ¦  «        ‰k    r|V —  nŒ4ŒLd S ©Nr   )r   ÚjoinÚitertext©r    r/   r0   r"   r   rl   s       €€r   r3   z!prepare_predicate.<locals>.select  sn   øè è € Ø"ğ "ğ "DØ!Ÿ\š\¨#Ñ.Ô.ğ "ğ "˜ØŸ7š7 1§:¢:¡<¤<Ñ0Ô0°EÒ9Ğ9Ø"&˜J˜J˜JØ!˜Eğ :øğ"ğ "r$   c              3   ó¨   •K  — |D ]K}|                      ‰¦  «        D ]3}d                     |                     ¦   «         ¦  «        ‰k    r|V —  nŒ4ŒLd S rs   )Úiterfindrt   ru   rv   s       €€r   ro   z)prepare_predicate.<locals>.select_negated"  sn   øè è € Ø"ğ "ğ "DØ!Ÿ]š]¨3Ñ/Ô/ğ "ğ "˜ØŸ7š7 1§:¢:¡<¤<Ñ0Ô0°EÒ9Ğ9Ø"&˜J˜J˜JØ!˜Eğ :øğ"ğ "r$   c              3   ót   •K  — |D ]1}d                      |                     ¦   «         ¦  «        ‰k    r|V — Œ2d S rs   ©rt   ru   ©r    r/   r0   rl   s      €r   r3   z!prepare_predicate.<locals>.select)  óI   øè è € Ø"ğ #ğ #DØ—w’w˜tŸ}š}™œÑ/Ô/°5Ò8Ğ8Ø"˜
˜
˜
øğ#ğ #r$   c              3   ót   •K  — |D ]1}d                      |                     ¦   «         ¦  «        ‰k    r|V — Œ2d S rs   rz   r{   s      €r   ro   z)prepare_predicate.<locals>.select_negated-  r|   r$   z-()z-()-zXPath position >= 1 expectedÚlastzunsupported functionr6   zunsupported expressionr(   z)XPath offset from last() must be negativec              3   óŞ   •K  — t          | ¦  «        }|D ]W}	 ||         }t          |                     |j        ¦  «        ¦  «        }|‰         |u r|V — ŒA# t          t
          f$ r Y ŒTw xY wd S r   )r#   Úlistr   r   Ú
IndexErrorr   )r    r/   r   r0   rb   ÚelemsÚindexs         €r   r3   z!prepare_predicate.<locals>.selectE  s•   øè è € İ'¨Ñ0Ô0ˆJØğ ğ ğØ'¨Ô-Få  §¢°´Ñ!9Ô!9Ñ:Ô:EØ˜U”| tĞ+Ğ+Ø"˜
˜
˜
øøİ"¥HĞ-ğ ğ ğ ØDğøøøğğ s   ˜=AÁA*Á)A*zinvalid predicate)r]   Úappendrt   ÚreÚmatchÚintr   Ú
ValueError)
rN   r   Ú	signatureÚ	predicater3   ro   rƒ   rj   r   rl   s
         @@@@r   Úprepare_predicater‹   ã   sñ  øøøø€ ğ €IØ€Iğ#ğ	ØD‘F”FˆEˆEøİğ 	ğ 	ğ 	ØˆFˆFğ	øøøàŒ8sŠ?ˆ?ØØHÒĞàØŒ8ğ 	(˜˜aœ  ! œ¨Ğ-Ğ-Ø˜˜qœ ! B $œĞ'ˆEØ×Ò˜˜qœ˜ SÑ)Ô)Ğ)Ø×Ò˜˜qœÑ"Ô"Ğ"ğ#ğ —’˜	Ñ"Ô"€IàDÒĞà˜Œlˆğ	ğ 	ğ 	ğ 	ğ 	ğ ˆØFÒĞ˜i¨7Ò2Ğ2à˜ŒlˆØ˜"”ˆğ	ğ 	ğ 	ğ 	ğ 	ğ 	ğ	ğ 	ğ 	ğ 	ğ 	ğ 	ğ "&¨Ğ!2Ğ!2ˆ~ˆ~¸Ğ>ØCÒĞ¥¤¨°Y¸q´\Ñ BÔ BĞà˜Œlˆğ	ğ 	ğ 	ğ 	ğ 	ğ ˆØEÒĞ˜Y¨&Ò0Ğ0Ø˜%ÒĞ 9°Ò#6Ğ#6İ”H˜Z¨°1¬Ñ6Ô6ğ $7ğ ˜ŒlˆØ˜"”ˆØğ 	#ğ"ğ "ğ "ğ "ğ "ğ "ğ"ğ "ğ "ğ "ğ "ğ "ğ "ğ#ğ #ğ #ğ #ğ #ğ#ğ #ğ #ğ #ğ #ğ "&¨Ğ!2Ğ!2ˆ~ˆ~¸Ğ>ØCÒĞ˜9¨Ò-Ğ-°¸fÒ1DĞ1Dà˜ÒĞå˜	 !œÑ%Ô%¨Ñ)ˆEØqŠyˆyİ!Ğ"@ÑAÔAĞAğ ğ ˜Œ|˜vÒ%Ğ%İ!Ğ"8Ñ9Ô9Ğ9Ø˜FÒ"Ğ"ğ@İ 	¨!¤Ñ-Ô-°Ñ1EEøİ!ğ @ğ @ğ @İ%Ğ&>Ñ?Ô?Ğ?ğ@øøøà˜2’::İ%Ğ&QÑRÔRĞRğ ğ ğ
	ğ 
	ğ 
	ğ 
	ğ 
	ğ ˆİ
Ğ)Ñ
*Ô
*Ğ*s   ‹
 –
$£$Ç6H ÈH))r   rX   ú.z..z//ú[c                   ó   — e Zd ZdZd„ ZdS )Ú_SelectorContextNc                 ó   — || _         d S r   )r   )Úselfr   s     r   Ú__init__z_SelectorContext.__init__`  s   € ØˆŒ	ˆ	ˆ	r$   )Ú__name__Ú
__module__Ú__qualname__r   r’   r*   r$   r   r   r   ^  s(   € € € € € Ø€Jğğ ğ ğ ğ r$   r   c                 óZ  — |dd …         dk    r|dz   }|f}|r1|t          t          |                     ¦   «         ¦  «        ¦  «        z  }	 t          |         }n.# t          $ r  t          t          ¦  «        dk    rt                               ¦   «          |d d…         dk    rt          d¦  «        ‚t          t          ||¦  «        ¦  «        j
        }	  |¦   «         }n# t          $ r Y Y d S w xY wg }	 	 |                     t          |d                  ||¦  «        ¦  «         n# t          $ r t          d¦  «        d ‚w xY w	  |¦   «         }|d         dk    r
 |¦   «         }n# t          $ r Y nw xY wŒ‚|t          |<   Y nw xY w| g}t          | ¦  «        }|D ]}	 |	||¦  «        }Œ|S )	Nr:   ú/rX   éd   r   z#cannot use absolute path on elementr   zinvalid path)ÚtupleÚsortedÚitemsÚ_cacher   rA   Úclearr   r   r   Ú__next__r]   r„   Úopsr   )
r0   Úpathr   Ú	cache_keyÚselectorrN   r   r/   r    r3   s
             r   rx   rx   h  s  € àˆBˆCˆC„yCÒĞØc‰zˆà€IØğ 7Ø•U6 *×"2Ò"2Ñ"4Ô"4Ñ5Ô5Ñ6Ô6Ñ6ˆ	ğ%İ˜)Ô$ˆ‰øİğ %ñ %ğ %İv‰;Œ;˜ÒĞİLŠL‰NŒNˆNØŒ8sŠ?ˆ?İĞCÑDÔDĞDİ•O D¨*Ñ5Ô5Ñ6Ô6Ô?ˆğ	ØD‘F”FˆEˆEøİğ 	ğ 	ğ 	ØˆFˆFˆFğ	øøøàˆğ
	ğ<Ø—’¥ E¨!¤H¤¨d°EÑ :Ô :Ñ;Ô;Ğ;Ğ;øİ ğ <ğ <ğ <İ! .Ñ1Ô1°tĞ;ğ<øøøğØ˜™œØ˜”8˜s’??Ø ˜D™FœFEøøİ ğ ğ ğ Øğøøøğ
	ğ %ˆyÑĞĞğ-%øøøğ0 ˆV€Fİ˜tÑ$Ô$€GØğ )ğ )ˆØ˜ Ñ(Ô(ˆˆØ€Mss   ÁA ÁA;FÃ
C!Ã FÃ!
C0Ã+FÃ/C0Ã0FÃ7/D'Ä&FÄ'EÅFÅ E'Å&FÅ'
E4Å1FÅ3E4Å4FÆFc                 ó@   — t          t          | ||¦  «        d ¦  «        S r   )rN   rx   ©r0   r    r   s      r   rq   rq   ”  s   € İ•˜˜t ZÑ0Ô0°$Ñ7Ô7Ğ7r$   c                 ó>   — t          t          | ||¦  «        ¦  «        S r   )r€   rx   r¤   s      r   r   r   š  s   € İ•˜˜t ZÑ0Ô0Ñ1Ô1Ğ1r$   c                 ó„   — 	 t          t          | ||¦  «        ¦  «        } | j        €dS | j        S # t          $ r |cY S w xY wrs   )rN   rx   Útextr]   )r0   r    Údefaultr   s       r   Úfindtextr©      sY   € ğİ•H˜T 4¨Ñ4Ô4Ñ5Ô5ˆØŒ9ĞØ2ØŒyĞøİğ ğ ğ Øˆˆˆğøøøs   ‚%0 ©0 °?¾?r   )NN)r…   Úcompiler   r   r#   r,   rC   rO   rS   rV   r^   rc   r‹   rŸ   rœ   r   rx   rq   r   r©   r*   r$   r   ú<module>r«      st  ğğv 
€	€	€	àR”Zğ	ñô Ğ ğ-ğ -ğ -ğ -ğ0ğ ğ ğ0ğ 0ğ 0ğ&ğ &ğ &ğRğ ğ ğ&ğ ğ ğğ ğ ğ
ğ ğ ğ>ğ ğ ğn+ğ n+ğ n+ğb 	Ø	Ø	Ø
Ø
Ø	ğğ €ğ 
€ğğ ğ ğ ğ ñ ô ğ ğ'ğ 'ğ 'ğ 'ğX8ğ 8ğ 8ğ 8ğ2ğ 2ğ 2ğ 2ğğ ğ ğ ğ ğ r$                                                                                                                                                                                    usr/lib/python3.11/xml/etree/__pycache__/ElementTree.cpython-311.pyc                                0000644 0000000 0000000 00000255674 14714551121 023522  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        §
    NüäfP  ã                   óş  — d Z g d¢ZdZddlZddlZddlZddlZddlZddlZddl	Z	ddl
mZ  G d„ de¦  «        Zd	„ Z G d
„ d¦  «        Zi fd„ZdDd„ZdDd„ZeZ G d„ d¦  «        Z G d„ d¦  «        Ze	j        d„ ¦   «         ZdDd„Zd„ Zh d£Zd„ Zd„ ZeeedœZd„ Zdddddd d!d"œZee_        d#„ Z d$„ Z!d%„ Z"d&„ Z#dEddd'd(œd)„Z$ G d*„ d+ej%        ¦  «        Z&dEddd'd(œd,„Z'd-„ Z(dFd/„Z)dDd0„Z*dEd1„Z+ G d2„ d3¦  «        Z,dDd4„Z-dDd5„Z.e-Z/dDd6„Z0 G d7„ d8¦  «        Z1 G d9„ d:¦  «        Z2dDddd;œd<„Z3 ej4        d=ej5        ¦  «        j6        Z7 G d>„ d?¦  «        Z8d@„ Z9dA„ Z:	 eZ;ddBl<T ddCl<m=Z=  e=ee¦  «         dS # e>$ r Y dS w xY w)Ga  Lightweight XML support for Python.

 XML is an inherently hierarchical data format, and the most natural way to
 represent it is with a tree.  This module has two classes for this purpose:

    1. ElementTree represents the whole XML document as a tree and

    2. Element represents a single node in this tree.

 Interactions with the whole document (reading and writing to/from files) are
 usually done on the ElementTree level.  Interactions with a single XML element
 and its sub-elements are done on the Element level.

 Element is a flexible container object designed to store hierarchical data
 structures in memory. It can be described as a cross between a list and a
 dictionary.  Each Element has a number of properties associated with it:

    'tag' - a string containing the element's name.

    'attributes' - a Python dictionary storing the element's attributes.

    'text' - a string containing the element's text content.

    'tail' - an optional string containing text after the element's end tag.

    And a number of child elements stored in a Python sequence.

 To create an element instance, use the Element constructor,
 or the SubElement factory function.

 You can also use the ElementTree class to wrap an element structure
 and convert it to and from XML.

)ÚCommentÚdumpÚElementÚElementTreeÚ
fromstringÚfromstringlistÚindentÚ	iselementÚ	iterparseÚparseÚ
ParseErrorÚPIÚProcessingInstructionÚQNameÚ
SubElementÚtostringÚtostringlistÚTreeBuilderÚVERSIONÚXMLÚXMLIDÚ	XMLParserÚXMLPullParserÚregister_namespaceÚcanonicalizeÚC14NWriterTargetz1.3.0é    Né   )ÚElementPathc                   ó   — e Zd ZdZdS )r   zìAn error when parsing an XML document.

    In addition to its exception value, a ParseError contains
    two extra attributes:
        'code'     - the specific exception code
        'position' - the line and column of the error

    N)Ú__name__Ú
__module__Ú__qualname__Ú__doc__© ó    ú,/usr/lib/python3.11/xml/etree/ElementTree.pyr   r   j   s   € € € € € ğğ ğ 	€Dr%   r   c                 ó"   — t          | d¦  «        S )z2Return True if *element* appears to be an Element.Útag)Úhasattr)Úelements    r&   r	   r	   x   s   € å7˜EÑ"Ô"Ğ"r%   c                   óÖ   — e Zd ZdZdZ	 dZ	 dZ	 dZ	 i fd„Zd„ Z	d„ Z
d„ Zd„ Zd„ Zd	„ Zd
„ Zd„ Zd„ Zd„ Zd„ Zd„ Zd„ Zd„ Zdd„Zdd„Zdd„Zdd„Zd„ Zdd„Zd„ Zd„ Zd„ Zdd„Z d„ Z!dS )r   ah  An XML element.

    This class is the reference implementation of the Element interface.

    An element's length is its number of subelements.  That means if you
    want to check if an element is truly empty, you should check BOTH
    its length AND its text attribute.

    The element tag, attribute names, and attribute values can be either
    bytes or strings.

    *tag* is the element name.  *attrib* is an optional dictionary containing
    element attributes. *extra* are additional element attributes given as
    keyword arguments.

    Example form:
        <tag attrib>text<child/>...</tag>tail

    Nc                 óš   — t          |t          ¦  «        st          d|j        j        ›¦  «        ‚|| _        i |¥|¥| _        g | _        d S )Nzattrib must be dict, not )Ú
isinstanceÚdictÚ	TypeErrorÚ	__class__r    r(   ÚattribÚ	_children)Úselfr(   r1   Úextras       r&   Ú__init__zElement.__init__©   s\   € İ˜&¥$Ñ'Ô'ğ 	-İ)ØÔ Ô)Ğ)ğ,ñ -ô -ğ -àˆŒØ)˜Ğ) 5Ğ)ˆŒØˆŒˆˆr%   c                 óJ   — d| j         j        | j        t          | ¦  «        fz  S )Nz<%s %r at %#x>)r0   r    r(   Úid©r3   s    r&   Ú__repr__zElement.__repr__±   s!   € Ø 4¤>Ô#:¸D¼HÅbÈÁhÄhĞ"OÑOĞOr%   c                 ó.   — |                       ||¦  «        S )zıCreate a new element with the same type.

        *tag* is a string containing the element name.
        *attrib* is a dictionary containing the element attributes.

        Do not call this method, use the SubElement factory function instead.

        )r0   )r3   r(   r1   s      r&   ÚmakeelementzElement.makeelement´   s   € ğ ~Š~˜c 6Ñ*Ô*Ğ*r%   c                 ó^   — t          j        dt          ¦  «         |                      ¦   «         S )zŠReturn copy of current element.

        This creates a shallow copy. Subelements will be shared with the
        original tree.

        z7elem.copy() is deprecated. Use copy.copy(elem) instead.)ÚwarningsÚwarnÚDeprecationWarningÚ__copy__r8   s    r&   ÚcopyzElement.copy¿   s.   € õ 	ŒØEİñ	ô 	ğ 	ğ }Š}‰ŒĞr%   c                 ó„   — |                       | j        | j        ¦  «        }| j        |_        | j        |_        | |d d …<   |S ©N)r;   r(   r1   ÚtextÚtail)r3   Úelems     r&   r@   zElement.__copy__Ì   s?   € Ø×Ò ¤¨$¬+Ñ6Ô6ˆØ”IˆŒ	Ø”IˆŒ	ØˆˆQˆQˆQ‰Øˆr%   c                 ó*   — t          | j        ¦  «        S rC   )Úlenr2   r8   s    r&   Ú__len__zElement.__len__Ó   s   € İ4”>Ñ"Ô"Ğ"r%   c                 ój   — t          j        dt          d¬¦  «         t          | j        ¦  «        dk    S )NzyThe behavior of this method will change in future versions.  Use specific 'len(elem)' or 'elem is not None' test instead.é   ©Ú
stacklevelr   )r=   r>   ÚFutureWarningrH   r2   r8   s    r&   Ú__bool__zElement.__bool__Ö   s=   € İŒğKå ağ	ñ 	ô 	ğ 	õ
 4”>Ñ"Ô" aÒ'Ğ'r%   c                 ó   — | j         |         S rC   ©r2   ©r3   Úindexs     r&   Ú__getitem__zElement.__getitem__Ş   s   € ØŒ~˜eÔ$Ğ$r%   c                 ó¤   — t          |t          ¦  «        r|D ]}|                      |¦  «         Œn|                      |¦  «         || j        |<   d S rC   )r-   ÚsliceÚ_assert_is_elementr2   )r3   rS   r*   Úelts       r&   Ú__setitem__zElement.__setitem__á   sg   € İeUÑ#Ô#ğ 	-Øğ -ğ -Ø×'Ò'¨Ñ,Ô,Ğ,Ğ,ğ-ğ ×#Ò# GÑ,Ô,Ğ,Ø 'ˆŒuÑĞĞr%   c                 ó   — | j         |= d S rC   rQ   rR   s     r&   Ú__delitem__zElement.__delitem__é   s   € ØŒN˜5Ğ!Ğ!Ğ!r%   c                 ód   — |                       |¦  «         | j                             |¦  «         dS )a  Add *subelement* to the end of this element.

        The new element will appear in document order after the last existing
        subelement (or directly after the text, if it's the first subelement),
        but before the end tag for this element.

        N©rW   r2   Úappend©r3   Ú
subelements     r&   r^   zElement.appendì   s4   € ğ 	×Ò 
Ñ+Ô+Ğ+ØŒ×Ò˜jÑ)Ô)Ğ)Ğ)Ğ)r%   c                 ón   — |D ]1}|                       |¦  «         | j                             |¦  «         Œ2dS )zkAppend subelements from a sequence.

        *elements* is a sequence with zero or more elements.

        Nr]   )r3   Úelementsr*   s      r&   ÚextendzElement.extend÷   sJ   € ğ  ğ 	+ğ 	+ˆGØ×#Ò# GÑ,Ô,Ğ,ØŒN×!Ò! 'Ñ*Ô*Ğ*Ğ*ğ	+ğ 	+r%   c                 óf   — |                       |¦  «         | j                             ||¦  «         dS )z(Insert *subelement* at position *index*.N)rW   r2   Úinsert)r3   rS   r`   s      r&   re   zElement.insert  s4   € à×Ò 
Ñ+Ô+Ğ+ØŒ×Ò˜e ZÑ0Ô0Ğ0Ğ0Ğ0r%   c                 óx   — t          |t          ¦  «        s$t          dt          |¦  «        j        z  ¦  «        ‚d S )Nzexpected an Element, not %s)r-   Ú_Element_Pyr/   Útyper    )r3   Úes     r&   rW   zElement._assert_is_element  s@   € õ ˜![Ñ)Ô)ğ 	NİĞ9½DÀ¹G¼GÔ<LÑLÑMÔMĞMğ	Nğ 	Nr%   c                 ó:   — | j                              |¦  «         dS )a±  Remove matching subelement.

        Unlike the find methods, this method compares elements based on
        identity, NOT ON tag value or contents.  To remove subelements by
        other means, the easiest way is to use a list comprehension to
        select what elements to keep, and then use slice assignment to update
        the parent element.

        ValueError is raised if a matching element could not be found.

        N)r2   Úremover_   s     r&   rk   zElement.remove  s    € ğ 	Œ×Ò˜jÑ)Ô)Ğ)Ğ)Ğ)r%   c                 ó.   — t          j        | ||¦  «        S )a  Find first matching element by tag name or path.

        *path* is a string having either an element tag or an XPath,
        *namespaces* is an optional mapping from namespace prefix to full name.

        Return the first matching element, or None if no element was found.

        )r   Úfind©r3   ÚpathÚ
