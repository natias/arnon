#   define isSPACE_L1(c)  _generic_isCC(c, _CC_SPACE)
#   define isUPPER_L1(c)  _generic_isCC(c, _CC_UPPER)
#   define isWORDCHAR_L1(c) _generic_isCC(c, _CC_WORDCHAR)
#   define isIDFIRST_L1(c) _generic_isCC(c, _CC_IDFIRST)

#   ifdef EBCDIC
#       define isASCII(c) _generic_isCC(c, _CC_ASCII)
#   endif

    /* Participates in a single-character fold with a character above 255 */
#   if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)
#     define HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(c)                          \
        ((   ! cBOOL(FITS_IN_8_BITS(c)))                                    \
          || (PL_charclass[(U8) (c)] & _CC_mask(_CC_NONLATIN1_SIMPLE_FOLD)))

#   define IS_NON_FINAL_FOLD(c)   _generic_isCC(c, _CC_NON_FINAL_FOLD)
#   define IS_IN_SOME_FOLD_L1(c)  _generic_isCC(c, _CC_IS_IN_SOME_FOLD)
#  endif

    /* Like the above, but also can be part of a multi-char fold */
#   define HAS_NONLATIN1_FOLD_CLOSURE(c)                                    \
      (   (! cBOOL(FITS_IN_8_BITS(c)))                                      \
       || (PL_charclass[(U8) (c)] & _CC_mask(_CC_NONLATIN1_FOLD)))

#   define _isQUOTEMETA(c) _generic_isCC(c, _CC_QUOTEMETA)

/* is c a control character for which we have a mnemonic? */
#  if defined(PERL_CORE) || defined(PERL_EXT)
#     define isMNEMONIC_CNTRL(c) _generic_isCC(c, _CC_MNEMONIC_CNTRL)
#  endif
#else   /* else we don't have perl.h H_PERL */

    /* If we don't have perl.h, we are compiling a utility program.  Below we
     * hard-code various macro definitions that wouldn't otherwise be available
     * to it. Most are coded based on first principles.  These are written to
     * avoid EBCDIC vs. ASCII #ifdef's as much as possible. */
#   define isDIGIT_A(c)  inRANGE(c, '0', '9')
#   define isBLANK_A(c)  ((c) == ' ' || (c) == '\t')
#   define isSPACE_A(c)  (isBLANK_A(c)                                   \
                          || (c) == '\n'                                 \
                          || (c) == '\r'                                 \
                          || (c) == '\v'                                 \
                          || (c) == '\f')
    /* On EBCDIC, there are gaps between 'i' and 'j'; 'r' and 's'.  Same for
     * uppercase.  The tests for those aren't necessary on ASCII, but hurt only
     * performance (if optimization isn't on), and allow the same code to be
     * used for both platform types */
#   define isLOWER_A(c)  inRANGE((c), 'a', 'i')                         \
                      || inRANGE((c), 'j', 'r')                         \
                      || inRANGE((c), 's', 'z')
#   define isUPPER_A(c)  inRANGE((c), 'A', 'I')                         \
                      || inRANGE((c), 'J', 'R')                         \
                      || inRANGE((c), 'S', 'Z')
#   define isALPHA_A(c)  (isUPPER_A(c) || isLOWER_A(c))
#   define isALPHANUMERIC_A(c) (isALPHA_A(c) || isDIGIT_A(c))
#   define isWORDCHAR_A(c)   (isALPHANUMERIC_A(c) || (c) == '_')
#   define isIDFIRST_A(c)    (isALPHA_A(c) || (c) == '_')
#   define isXDIGIT_A(c) (   isDIGIT_A(c)                               \
                          || inRANGE((c), 'a', 'f')                     \
                          || inRANGE((c), 'A', 'F')
#   define isPUNCT_A(c)  ((c) == '-' || (c) == '!' || (c) == '"'        \
                       || (c) == '#' || (c) == '$' || (c) == '%'        \
                       || (c) == '&' || (c) == '\'' || (c) == '('       \
                       || (c) == ')' || (c) == '*' || (c) == '+'        \
                       || (c) == ',' || (c) == '.' || (c) == '/'        \
                       || (c) == ':' || (c) == ';' || (c) == '<'        \
                       || (c) == '=' || (c) == '>' || (c) == '?'        \
                       || (c) == '@' || (c) == '[' || (c) == '\\'       \
                       || (c) == ']' || (c) == '^' || (c) == '_'        \
                       || (c) == '`' || (c) == '{' || (c) == '|'        \
                       || (c) == '}' || (c) == '~')
#   define isGRAPH_A(c)  (isALPHANUMERIC_A(c) || isPUNCT_A(c))
#   define isPRINT_A(c)  (isGRAPH_A(c) || (c) == ' ')

#   ifdef EBCDIC
        /* The below is accurate for the 3 EBCDIC code pages traditionally
         * supported by perl.  The only difference between them in the controls
         * is the position of \n, and that is represented symbolically below */
#       define isCNTRL_A(c)  ((c) == '\0' || (c) == '\a' || (c) == '\b'     \
                          ||  (c) == '\f' || (c) == '\n' || (c) == '\r'     \
                          ||  (c) == '\t' || (c) == '\v'                    \
                          || inRANGE((c), 1, 3)     /* SOH, STX, ETX */     \
                          ||  (c) == 7F   /* U+7F DEL */                    \
                          || inRANGE((c), 0x0E, 0x13) /* SO SI DLE          \
                                                         DC[1-3] */         \
                          ||  (c) == 0x18 /* U+18 CAN */                    \
                          ||  (c) == 0x19 /* U+19 EOM */                    \
                          || inRANGE((c), 0x1C, 0x1F) /* [FGRU]S */         \
                          ||  (c) == 0x26 /* U+17 ETB */                    \
                          ||  (c) == 0x27 /* U+1B ESC */                    \
                          ||  (c) == 0x2D /* U+05 ENQ */                    \
                          ||  (c) == 0x2E /* U+06 ACK */                    \
                          ||  (c) == 0x32 /* U+16 SYN */                    \
                          ||  (c) == 0x37 /* U+04 EOT */                    \
                          ||  (c) == 0x3C /* U+14 DC4 */                    \
                          ||  (c) == 0x3D /* U+15 NAK */                    \
                          ||  (c) == 0x3F)/* U+1A SUB */
#       define isASCII(c)    (isCNTRL_A(c) || isPRINT_A(c))
#   else /* isASCII is already defined for ASCII platforms, so can use that to
            define isCNTRL */
#       define isCNTRL_A(c)  (isASCII(c) && ! isPRINT_A(c))
#   endif

    /* The _L1 macros may be unnecessary for the utilities; I (khw) added them
     * during debugging, and it seems best to keep them.  We may be called
     * without NATIVE_TO_LATIN1 being defined.  On ASCII platforms, it doesn't
     * do anything anyway, so make it not a problem */
#   if ! defined(EBCDIC) && ! defined(NATIVE_TO_LATIN1)
#       define NATIVE_TO_LATIN1(ch) (ch)
#   endif
#   define isALPHA_L1(c)     (isUPPER_L1(c) || isLOWER_L1(c))
#   define isALPHANUMERIC_L1(c) (isALPHA_L1(c) || isDIGIT_A(c))
#   define isBLANK_L1(c)     (isBLANK_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && NATIVE_TO_LATIN1((U8) c) == 0xA0))
#   define isCNTRL_L1(c)     (FITS_IN_8_BITS(c) && (! isPRINT_L1(c)))
#   define isGRAPH_L1(c)     (isPRINT_L1(c) && (! isBLANK_L1(c)))
#   define isLOWER_L1(c)     (isLOWER_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && ((   NATIVE_TO_LATIN1((U8) c) >= 0xDF   \
                                       && NATIVE_TO_LATIN1((U8) c) != 0xF7)  \
                                       || NATIVE_TO_LATIN1((U8) c) == 0xAA   \
                                       || NATIVE_TO_LATIN1((U8) c) == 0xBA   \
                                       || NATIVE_TO_LATIN1((U8) c) == 0xB5)))
#   define isPRINT_L1(c)     (isPRINT_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && NATIVE_TO_LATIN1((U8) c) >= 0xA0))
#   define isPUNCT_L1(c)     (isPUNCT_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && (   NATIVE_TO_LATIN1((U8) c) == 0xA1    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xA7    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xAB    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xB6    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xB7    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xBB    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xBF)))
#   define isSPACE_L1(c)     (isSPACE_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && (   NATIVE_TO_LATIN1((U8) c) == 0x85    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xA0)))
#   define isUPPER_L1(c)     (isUPPER_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && (   IN_RANGE(NATIVE_TO_LATIN1((U8) c),  \
                                                  0xC0, 0xDE)                \
                                      && NATIVE_TO_LATIN1((U8) c) != 0xD7)))
#   define isWORDCHAR_L1(c)  (isIDFIRST_L1(c) || isDIGIT_A(c))
#   define isIDFIRST_L1(c)   (isALPHA_L1(c) || NATIVE_TO_LATIN1(c) == '_')
#   define isCHARNAME_CONT(c) (isWORDCHAR_L1(c)                              \
                               || isBLANK_L1(c)                              \
                               || (c) == '-'                                 \
                               || (c) == '('                                 \
                               || (c) == ')')
    /* The following are not fully accurate in the above-ASCII range.  I (khw)
     * don't think it's necessary to be so for the purposes where this gets
     * compiled */
#   define _isQUOTEMETA(c)      (FITS_IN_8_BITS(c) && ! isWORDCHAR_L1(c))
#   define _IS_IN_SOME_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c) isALPHA_L1(c)

    /*  And these aren't accurate at all.  They are useful only for above
     *  Latin1, which utilities and bootstrapping don't deal with */
#   define _IS_NON_FINAL_FOLD_ONLY_FOR_USE_BY_REGCOMP_DOT_C(c) 0
#   define _HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(c) 0
#   define _HAS_NONLATIN1_FOLD_CLOSURE_ONLY_FOR_USE_BY_REGCOMP_DOT_C_AND_REGEXEC_DOT_C(c) 0

    /* Many of the macros later in this file are defined in terms of these.  By
     * implementing them with a function, which converts the class number into
     * a call to the desired macro, all of the later ones work.  However, that
     * function won't be actually defined when building a utility program (no
     * perl.h), and so a compiler error will be generated if one is attempted
     * to be used.  And the above-Latin1 code points require Unicode tables to
     * be present, something unlikely to be the case when bootstrapping */
#   define _generic_isCC(c, classnum)                                        \
         (FITS_IN_8_BITS(c) && S_bootstrap_ctype((U8) (c), (classnum), TRUE))
#   define _generic_isCC_A(c, classnum)                                      \
         (FITS_IN_8_BITS(c) && S_bootstrap_ctype((U8) (c), (classnum), FALSE))
#endif  /* End of no perl.h H_PERL */

#define isALPHANUMERIC(c)  isALPHANUMERIC_A(c)
#define isALPHA(c)   isALPHA_A(c)
#define isASCII_A(c)  isASCII(c)
#define isASCII_L1(c)  isASCII(c)
#define isBLANK(c)   isBLANK_A(c)
#define isCNTRL(c)   isCNTRL_A(c)
#define isDIGIT(c)   isDIGIT_A(c)
#define isGRAPH(c)   isGRAPH_A(c)
#define isIDFIRST(c) isIDFIRST_A(c)
#define isLOWER(c)   isLOWER_A(c)
#define isPRINT(c)   isPRINT_A(c)
#define isPSXSPC_A(c) isSPACE_A(c)
#define isPSXSPC(c)  isPSXSPC_A(c)
#define isPSXSPC_L1(c) isSPACE_L1(c)
#define isPUNCT(c)   isPUNCT_A(c)
#define isSPACE(c)   isSPACE_A(c)
#define isUPPER(c)   isUPPER_A(c)
#define isWORDCHAR(c) isWORDCHAR_A(c)
#define isXDIGIT(c)  isXDIGIT_A(c)

/* ASCII casing.  These could also be written as
    #define toLOWER(c) (isASCII(c) ? toLOWER_LATIN1(c) : (c))
    #define toUPPER(c) (isASCII(c) ? toUPPER_LATIN1_MOD(c) : (c))
   which uses table lookup and mask instead of subtraction.  (This would
   work because the _MOD does not apply in the ASCII range).

   These actually are UTF-8 invariant casing, not just ASCII, as any non-ASCII
   UTF-8 invariants are neither upper nor lower.  (Only on EBCDIC platforms are
   there non-ASCII invariants, and all of them are controls.) */
#define toLOWER(c)  (isUPPER(c) ? (U8)((c) + ('a' - 'A')) : (c))
#define toUPPER(c)  (isLOWER(c) ? (U8)((c) - ('a' - 'A')) : (c))

/* In the ASCII range, these are equivalent to what they're here defined to be.
 * But by creating these definitions, other code doesn't have to be aware of
 * this detail.  Actually this works for all UTF-8 invariants, not just the
 * ASCII range. (EBCDIC platforms can have non-ASCII invariants.) */
#define toFOLD(c)    toLOWER(c)
#define toTITLE(c)   toUPPER(c)

#define toLOWER_A(c) toLOWER(c)
#define toUPPER_A(c) toUPPER(c)
#define toFOLD_A(c)  toFOLD(c)
#define toTITLE_A(c) toTITLE(c)

/* Use table lookup for speed; returns the input itself if is out-of-range */
#define toLOWER_LATIN1(c)    ((! FITS_IN_8_BITS(c))                        \
                             ? (c)                                         \
                             : PL_latin1_lc[ (U8) (c) ])
#define toLOWER_L1(c)    toLOWER_LATIN1(c)  /* Synonym for consistency */

/* Modified uc.  Is correct uc except for three non-ascii chars which are
 * all mapped to one of them, and these need special handling; returns the
 * input itself if is out-of-range */
#define toUPPER_LATIN1_MOD(c) ((! FITS_IN_8_BITS(c))                       \
                               ? (c)                                       \
                               : PL_mod_latin1_uc[ (U8) (c) ])
#define IN_UTF8_CTYPE_LOCALE PL_in_utf8_CTYPE_locale

/* Use foo_LC_uvchr() instead  of these for beyond the Latin1 range */

/* For internal core Perl use only: the base macro for defining macros like
 * isALPHA_LC, which uses the current LC_CTYPE locale.  'c' is the code point
 * (0-255) to check.  In a UTF-8 locale, the result is the same as calling
 * isFOO_L1(); the 'utf8_locale_classnum' parameter is something like
 * _CC_UPPER, which gives the class number for doing this.  For non-UTF-8
 * locales, the code to actually do the test this is passed in 'non_utf8'.  If
 * 'c' is above 255, 0 is returned.  For accessing the full range of possible
 * code points under locale rules, use the macros based on _generic_LC_uvchr
 * instead of this. */
#define _generic_LC_base(c, utf8_locale_classnum, non_utf8)                    \
           (! FITS_IN_8_BITS(c)                                                \
           ? 0                                                                 \
           : IN_UTF8_CTYPE_LOCALE                                              \
             ? cBOOL(PL_charclass[(U8) (c)] & _CC_mask(utf8_locale_classnum))  \
             : cBOOL(non_utf8))

/* For internal core Perl use only: a helper macro for defining macros like
 * isALPHA_LC.  'c' is the code point (0-255) to check.  The function name to
 * actually do this test is passed in 'non_utf8_func', which is called on 'c',
 * casting 'c' to the macro _LC_CAST, which should not be parenthesized.  See
 * _generic_LC_base for more info */
#define _generic_LC(c, utf8_locale_classnum, non_utf8_func)                    \
                        _generic_LC_base(c,utf8_locale_classnum,               \
                                         non_utf8_func( (_LC_CAST) (c)))

/* For internal core Perl use only: like _generic_LC, but also returns TRUE if
 * 'c' is the platform's native underscore character */
#define _generic_LC_underscore(c,utf8_locale_classnum,non_utf8_func)           \
                        _generic_LC_base(c, utf8_locale_classnum,              \
                                         (non_utf8_func( (_LC_CAST) (c))       \
                                          || (char)(c) == '_'))

/* These next three are also for internal core Perl use only: case-change
 * helper macros.  The reason for using the PL_latin arrays is in case the
 * system function is defective; it ensures uniform results that conform to the
 * Unicod standard.   It does not handle the anomalies in UTF-8 Turkic locales */
#define _generic_toLOWER_LC(c, function, cast)  (! FITS_IN_8_BITS(c)           \
                                                ? (c)                          \
                                                : (IN_UTF8_CTYPE_LOCALE)       \
                                                  ? PL_latin1_lc[ (U8) (c) ]   \
                                                  : (cast)function((cast)(c)))

/* Note that the result can be larger than a byte in a UTF-8 locale.  It
 * returns a single value, so can't adequately return the upper case of LATIN
 * SMALL LETTER SHARP S in a UTF-8 locale (which should be a string of two
 * values "SS");  instead it asserts against that under DEBUGGING, and
 * otherwise returns its input.  It does not handle the anomalies in UTF-8
 * Turkic locales. */
#define _generic_toUPPER_LC(c, function, cast)                                 \
                    (! FITS_IN_8_BITS(c)                                       \
                    ? (c)                                                      \
                    : ((! IN_UTF8_CTYPE_LOCALE)                                \
                      ? (cast)function((cast)(c))                              \
                      : ((((U8)(c)) == MICRO_SIGN)                             \
                        ? GREEK_CAPITAL_LETTER_MU                              \
                        : ((((U8)(c)) == LATIN_SMALL_LETTER_Y_WITH_DIAERESIS)  \
                          ? LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS              \
                          : ((((U8)(c)) == LATIN_SMALL_LETTER_SHARP_S)         \
                            ? (__ASSERT_(0) (c))                               \
                            : PL_mod_latin1_uc[ (U8) (c) ])))))

/* Note that the result can be larger than a byte in a UTF-8 locale.  It
 * returns a single value, so can't adequately return the fold case of LATIN
 * SMALL LETTER SHARP S in a UTF-8 locale (which should be a string of two
 * values "ss"); instead it asserts against that under DEBUGGING, and
 * otherwise returns its input.  It does not handle the anomalies in UTF-8
 * Turkic locales */
#define _generic_toFOLD_LC(c, function, cast)                                  \
                    ((UNLIKELY((c) == MICRO_SIGN) && IN_UTF8_CTYPE_LOCALE)     \
                      ? GREEK_SMALL_LETTER_MU                                  \
                      : (__ASSERT_(! IN_UTF8_CTYPE_LOCALE                      \
                                   || (c) != LATIN_SMALL_LETTER_SHARP_S)       \
                         _generic_toLOWER_LC(c, function, cast)))

/* Use the libc versions for these if available. */
#if defined(HAS_ISASCII)
#   define isASCII_LC(c) (FITS_IN_8_BITS(c) && isascii( (U8) (c)))
#else
#   define isASCII_LC(c) isASCII(c)
#endif

#if defined(HAS_ISBLANK)
#   define isBLANK_LC(c) _generic_LC(c, _CC_BLANK, isblank)
#else /* Unlike isASCII, varies if in a UTF-8 locale */
#   define isBLANK_LC(c) ((IN_UTF8_CTYPE_LOCALE) ? isBLANK_L1(c) : isBLANK(c))
#endif

#define _LC_CAST U8

#ifdef WIN32
    /* The Windows functions don't bother to follow the POSIX standard, which
     * for example says that something can't both be a printable and a control.
     * But Windows treats the \t control as a printable, and does such things
     * as making superscripts into both digits and punctuation.  This tames
     * these flaws by assuming that the definitions of both controls and space
     * are correct, and then making sure that other definitions don't have
     * weirdnesses, by making sure that isalnum() isn't also ispunct(), etc.
     * Not all possible weirdnesses are checked for, just the ones that were
     * detected on actual Microsoft code pages */

#  define isCNTRL_LC(c)  _generic_LC(c, _CC_CNTRL, iscntrl)
#  define isSPACE_LC(c)  _generic_LC(c, _CC_SPACE, isspace)

#  define isALPHA_LC(c)  (_generic_LC(c, _CC_ALPHA, isalpha)                  \
                                                    && isALPHANUMERIC_LC(c))
#  define isALPHANUMERIC_LC(c)  (_generic_LC(c, _CC_ALPHANUMERIC, isalnum) && \
                                                              ! isPUNCT_LC(c))
#  define isDIGIT_LC(c)  (_generic_LC(c, _CC_DIGIT, isdigit) &&               \
                                                         isALPHANUMERIC_LC(c))
#  define isGRAPH_LC(c)  (_generic_LC(c, _CC_GRAPH, isgraph) && isPRINT_LC(c))
#  define isIDFIRST_LC(c) (((c) == '_')                                       \
                 || (_generic_LC(c, _CC_IDFIRST, isalpha) && ! isPUNCT_LC(c)))
#  define isLOWER_LC(c)  (_generic_LC(c, _CC_LOWER, islower) && isALPHA_LC(c))
#  define isPRINT_LC(c)  (_generic_LC(c, _CC_PRINT, isprint) && ! isCNTRL_LC(c))
#  define isPUNCT_LC(c)  (_generic_LC(c, _CC_PUNCT, ispunct) && ! isCNTRL_LC(c))
#  define isUPPER_LC(c)  (_generic_LC(c, _CC_UPPER, isupper) && isALPHA_LC(c))
#  define isWORDCHAR_LC(c) (((c) == '_') || isALPHANUMERIC_LC(c))
#  define isXDIGIT_LC(c) (_generic_LC(c, _CC_XDIGIT, isxdigit)                \
                                                    && isALPHANUMERIC_LC(c))

#  define toLOWER_LC(c) _generic_toLOWER_LC((c), tolower, U8)
#  define toUPPER_LC(c) _generic_toUPPER_LC((c), toupper, U8)
#  define toFOLD_LC(c)  _generic_toFOLD_LC((c), tolower, U8)

#elif defined(CTYPE256) || (!defined(isascii) && !defined(HAS_ISASCII))
    /* For most other platforms */

#  define isALPHA_LC(c)   _generic_LC(c, _CC_ALPHA, isalpha)
#  define isALPHANUMERIC_LC(c)  _generic_LC(c, _CC_ALPHANUMERIC, isalnum)
#  define isCNTRL_LC(c)    _generic_LC(c, _CC_CNTRL, iscntrl)
#  define isDIGIT_LC(c)    _generic_LC(c, _CC_DIGIT, isdigit)
#  ifdef OS390  /* This system considers NBSP to be a graph */
#    define isGRAPH_LC(c)    _generic_LC(c, _CC_GRAPH, isgraph)             \
                        && ! isSPACE_LC(c)
#  else
#    define isGRAPH_LC(c)    _generic_LC(c, _CC_GRAPH, isgraph)
#  endif
#  define isIDFIRST_LC(c)  _generic_LC_underscore(c, _CC_IDFIRST, isalpha)
#  define isLOWER_LC(c)    _generic_LC(c, _CC_LOWER, islower)
#  define isPRINT_LC(c)    _generic_LC(c, _CC_PRINT, isprint)
#  define isPUNCT_LC(c)    _generic_LC(c, _CC_PUNCT, ispunct)
#  define isSPACE_LC(c)    _generic_LC(c, _CC_SPACE, isspace)
#  define isUPPER_LC(c)    _generic_LC(c, _CC_UPPER, isupper)
#  define isWORDCHAR_LC(c) _generic_LC_underscore(c, _CC_WORDCHAR, isalnum)
#  define isXDIGIT_LC(c)   _generic_LC(c, _CC_XDIGIT, isxdigit)


#  define toLOWER_LC(c) _generic_toLOWER_LC((c), tolower, U8)
#  define toUPPER_LC(c) _generic_toUPPER_LC((c), toupper, U8)
#  define toFOLD_LC(c)  _generic_toFOLD_LC((c), tolower, U8)

#else  /* The final fallback position */

#  define isALPHA_LC(c)	        (isascii(c) && isalpha(c))
#  define isALPHANUMERIC_LC(c)  (isascii(c) && isalnum(c))
#  define isCNTRL_LC(c)	        (isascii(c) && iscntrl(c))
#  define isDIGIT_LC(c)	        (isascii(c) && isdigit(c))
#  define isGRAPH_LC(c)	        (isascii(c) && isgraph(c))
#  define isIDFIRST_LC(c)	(isascii(c) && (isalpha(c) || (c) == '_'))
#  define isLOWER_LC(c)	        (isascii(c) && islower(c))
#  define isPRINT_LC(c)	        (isascii(c) && isprint(c))
#  define isPUNCT_LC(c)	        (isascii(c) && ispunct(c))
#  define isSPACE_LC(c)	        (isascii(c) && isspace(c))
#  define isUPPER_LC(c)	        (isascii(c) && isupper(c))
#  define isWORDCHAR_LC(c)	(isascii(c) && (isalnum(c) || (c) == '_'))
#  define isXDIGIT_LC(c)        (isascii(c) && isxdigit(c))

#  define toLOWER_LC(c)	(isascii(c) ? tolower(c) : (c))
#  define toUPPER_LC(c)	(isascii(c) ? toupper(c) : (c))
#  define toFOLD_LC(c)	(isascii(c) ? tolower(c) : (c))

#endif

#define isIDCONT(c)             isWORDCHAR(c)
#define isIDCONT_A(c)           isWORDCHAR_A(c)
#define isIDCONT_L1(c)	        isWORDCHAR_L1(c)
#define isIDCONT_LC(c)	        isWORDCHAR_LC(c)
#define isPSXSPC_LC(c)		isSPACE_LC(c)

/* For internal core Perl use only: the base macros for defining macros like
 * isALPHA_uvchr.  'c' is the code point to check.  'classnum' is the POSIX class
 * number defined earlier in this file.  _generic_uvchr() is used for POSIX
 * classes where there is a macro or function 'above_latin1' that takes the
 * single argument 'c' and returns the desired value.  These exist for those
 * classes which have simple definitions, avoiding the overhead of an inversion
 * list binary search.  _generic_invlist_uvchr() can be used
 * for classes where that overhead is faster than a direct lookup.
 * _generic_uvchr() won't compile if 'c' isn't unsigned, as it won't match the
 * 'above_latin1' prototype. _generic_isCC() macro does bounds checking, so
 * have duplicate checks here, so could create versions of the macros that
 * don't, but experiments show that gcc optimizes them out anyway. */

/* Note that all ignore 'use bytes' */
#define _generic_uvchr(classnum, above_latin1, c) ((c) < 256                \
                                             ? _generic_isCC(c, classnum)   \
                                             : above_latin1(c))
#define _generic_invlist_uvchr(classnum, c) ((c) < 256                        \
                                             ? _generic_isCC(c, classnum)   \
                                             : _is_uni_FOO(classnum, c))
#define isALPHA_uvchr(c)      _generic_invlist_uvchr(_CC_ALPHA, c)
#define isALPHANUMERIC_uvchr(c) _generic_invlist_uvchr(_CC_ALPHANUMERIC, c)
#define isASCII_uvchr(c)      isASCII(c)
#define isBLANK_uvchr(c)      _generic_uvchr(_CC_BLANK, is_HORIZWS_cp_high, c)
#define isCNTRL_uvchr(c)      isCNTRL_L1(c) /* All controls are in Latin1 */
#define isDIGIT_uvchr(c)      _generic_invlist_uvchr(_CC_DIGIT, c)
#define isGRAPH_uvchr(c)      _generic_invlist_uvchr(_CC_GRAPH, c)
#define isIDCONT_uvchr(c)                                                   \
                    _generic_uvchr(_CC_WORDCHAR, _is_uni_perl_idcont, c)
#define isIDFIRST_uvchr(c)                                                  \
                    _generic_uvchr(_CC_IDFIRST, _is_uni_perl_idstart, c)
#define isLOWER_uvchr(c)      _generic_invlist_uvchr(_CC_LOWER, c)
#define isPRINT_uvchr(c)      _generic_invlist_uvchr(_CC_PRINT, c)

#define isPUNCT_uvchr(c)      _generic_invlist_uvchr(_CC_PUNCT, c)
#define isSPACE_uvchr(c)      _generic_uvchr(_CC_SPACE, is_XPERLSPACE_cp_high, c)
#define isPSXSPC_uvchr(c)     isSPACE_uvchr(c)

#define isUPPER_uvchr(c)      _generic_invlist_uvchr(_CC_UPPER, c)
#define isVERTWS_uvchr(c)     _generic_uvchr(_CC_VERTSPACE, is_VERTWS_cp_high, c)
#define isWORDCHAR_uvchr(c)   _generic_invlist_uvchr(_CC_WORDCHAR, c)
#define isXDIGIT_uvchr(c)     _generic_uvchr(_CC_XDIGIT, is_XDIGIT_cp_high, c)

#define toFOLD_uvchr(c,s,l)	to_uni_fold(c,s,l)
#define toLOWER_uvchr(c,s,l)	to_uni_lower(c,s,l)
#define toTITLE_uvchr(c,s,l)	to_uni_title(c,s,l)
#define toUPPER_uvchr(c,s,l)	to_uni_upper(c,s,l)

/* For backwards compatibility, even though '_uni' should mean official Unicode
 * code points, in Perl it means native for those below 256 */
#define isALPHA_uni(c)          isALPHA_uvchr(c)
#define isALPHANUMERIC_uni(c)   isALPHANUMERIC_uvchr(c)
#define isASCII_uni(c)          isASCII_uvchr(c)
#define isBLANK_uni(c)          isBLANK_uvchr(c)
#define isCNTRL_uni(c)          isCNTRL_uvchr(c)
#define isDIGIT_uni(c)          isDIGIT_uvchr(c)
#define isGRAPH_uni(c)          isGRAPH_uvchr(c)
#define isIDCONT_uni(c)         isIDCONT_uvchr(c)
#define isIDFIRST_uni(c)        isIDFIRST_uvchr(c)
#define isLOWER_uni(c)          isLOWER_uvchr(c)
#define isPRINT_uni(c)          isPRINT_uvchr(c)
#define isPUNCT_uni(c)          isPUNCT_uvchr(c)
#define isSPACE_uni(c)          isSPACE_uvchr(c)
#define isPSXSPC_uni(c)         isPSXSPC_uvchr(c)
#define isUPPER_uni(c)          isUPPER_uvchr(c)
#define isVERTWS_uni(c)         isVERTWS_uvchr(c)
#define isWORDCHAR_uni(c)       isWORDCHAR_uvchr(c)
#define isXDIGIT_uni(c)         isXDIGIT_uvchr(c)
#define toFOLD_uni(c,s,l)       toFOLD_uvchr(c,s,l)
#define toLOWER_uni(c,s,l)      toLOWER_uvchr(c,s,l)
#define toTITLE_uni(c,s,l)      toTITLE_uvchr(c,s,l)
#define toUPPER_uni(c,s,l)      toUPPER_uvchr(c,s,l)

/* For internal core Perl use only: the base macros for defining macros like
 * isALPHA_LC_uvchr.  These are like isALPHA_LC, but the input can be any code
 * point, not just 0-255.  Like _generic_uvchr, there are two versions, one for
 * simple class definitions; the other for more complex.  These are like
 * _generic_uvchr, so see it for more info. */
#define _generic_LC_uvchr(latin1, above_latin1, c)                            \
                                    (c < 256 ? latin1(c) : above_latin1(c))
#define _generic_LC_invlist_uvchr(latin1, classnum, c)                          \
                            (c < 256 ? latin1(c) : _is_uni_FOO(classnum, c))

#define isALPHA_LC_uvchr(c)  _generic_LC_invlist_uvchr(isALPHA_LC, _CC_ALPHA, c)
#define isALPHANUMERIC_LC_uvchr(c)  _generic_LC_invlist_uvchr(isALPHANUMERIC_LC, \
                                                         _CC_ALPHANUMERIC, c)
#define isASCII_LC_uvchr(c)   isASCII_LC(c)
#define isBLANK_LC_uvchr(c)  _generic_LC_uvchr(isBLANK_LC,                    \
                                                        is_HORIZWS_cp_high, c)
#define isCNTRL_LC_uvchr(c)  (c < 256 ? isCNTRL_LC(c) : 0)
#define isDIGIT_LC_uvchr(c)  _generic_LC_invlist_uvchr(isDIGIT_LC, _CC_DIGIT, c)
#define isGRAPH_LC_uvchr(c)  _generic_LC_invlist_uvchr(isGRAPH_LC, _CC_GRAPH, c)
#define isIDCONT_LC_uvchr(c) _generic_LC_uvchr(isIDCONT_LC,                   \
                                                  _is_uni_perl_idcont, c)
#define isIDFIRST_LC_uvchr(c) _generic_LC_uvchr(isIDFIRST_LC,                 \
                                                  _is_uni_perl_idstart, c)
#define isLOWER_LC_uvchr(c)  _generic_LC_invlist_uvchr(isLOWER_LC, _CC_LOWER, c)
#define isPRINT_LC_uvchr(c)  _generic_LC_invlist_uvchr(isPRINT_LC, _CC_PRINT, c)
#define isPSXSPC_LC_uvchr(c)  isSPACE_LC_uvchr(c)
#define isPUNCT_LC_uvchr(c)  _generic_LC_invlist_uvchr(isPUNCT_LC, _CC_PUNCT, c)
#define isSPACE_LC_uvchr(c)  _generic_LC_uvchr(isSPACE_LC,                    \
                                                    is_XPERLSPACE_cp_high, c)
#define isUPPER_LC_uvchr(c)  _generic_LC_invlist_uvchr(isUPPER_LC, _CC_UPPER, c)
#define isWORDCHAR_LC_uvchr(c) _generic_LC_invlist_uvchr(isWORDCHAR_LC,         \
                                                           _CC_WORDCHAR, c)
#define isXDIGIT_LC_uvchr(c) _generic_LC_uvchr(isXDIGIT_LC,                  \
                                                       is_XDIGIT_cp_high, c)

#define isBLANK_LC_uni(c)    isBLANK_LC_uvchr(UNI_TO_NATIVE(c))

/* The "_safe" macros make sure that we don't attempt to read beyond 'e', but
 * they don't otherwise go out of their way to look for malformed UTF-8.  If
 * they can return accurate results without knowing if the input is otherwise
 * malformed, they do so.  For example isASCII is accurate in spite of any
 * non-length malformations because it looks only at a single byte. Likewise
 * isDIGIT looks just at the first byte for code points 0-255, as all UTF-8
 * variant ones return FALSE.  But, if the input has to be well-formed in order
 * for the results to be accurate, the macros will test and if malformed will
 * call a routine to die
 *
 * Except for toke.c, the macros do assume that e > p, asserting that on
 * DEBUGGING builds.  Much code that calls these depends on this being true,
 * for other reasons.  toke.c is treated specially as using the regular
 * assertion breaks it in many ways.  All strings that these operate on there
 * are supposed to have an extra NUL character at the end,  so that *e = \0. A
 * bunch of code in toke.c assumes that this is true, so the assertion allows
 * for that */
#ifdef PERL_IN_TOKE_C
#  define _utf8_safe_assert(p,e) ((e) > (p) || ((e) == (p) && *(p) == '\0'))
#else
#  define _utf8_safe_assert(p,e) ((e) > (p))
#endif

#define _generic_utf8_safe(classnum, p, e, above_latin1)                    \
    ((! _utf8_safe_assert(p, e))                                            \
      ? (_force_out_malformed_utf8_message((U8 *) (p), (U8 *) (e), 0, 1), 0)\
      : (UTF8_IS_INVARIANT(*(p)))                                           \
          ? _generic_isCC(*(p), classnum)                                   \
          : (UTF8_IS_DOWNGRADEABLE_START(*(p))                              \
             ? ((LIKELY((e) - (p) > 1 && UTF8_IS_CONTINUATION(*((p)+1))))   \
                ? _generic_isCC(EIGHT_BIT_UTF8_TO_NATIVE(*(p), *((p)+1 )),  \
                                classnum)                                   \
                : (_force_out_malformed_utf8_message(                       \
                                        (U8 *) (p), (U8 *) (e), 0, 1), 0))  \
             : above_latin1))
/* Like the above, but calls 'above_latin1(p)' to get the utf8 value.
 * 'above_latin1' can be a macro */
#define _generic_func_utf8_safe(classnum, above_latin1, p, e)               \
                    _generic_utf8_safe(classnum, p, e, above_latin1(p, e))
#define _generic_non_invlist_utf8_safe(classnum, above_latin1, p, e)          \
          _generic_utf8_safe(classnum, p, e,                                \
                             (UNLIKELY((e) - (p) < UTF8SKIP(p))             \
                              ? (_force_out_malformed_utf8_message(         \
                                      (U8 *) (p), (U8 *) (e), 0, 1), 0)     \
                              : above_latin1(p)))
/* Like the above, but passes classnum to _isFOO_utf8(), instead of having an
 * 'above_latin1' parameter */
#define _generic_invlist_utf8_safe(classnum, p, e)                            \
            _generic_utf8_safe(classnum, p, e, _is_utf8_FOO(classnum, p, e))

/* Like the above, but should be used only when it is known that there are no
 * characters in the upper-Latin1 range (128-255 on ASCII platforms) which the
 * class is TRUE for.  Hence it can skip the tests for this range.
 * 'above_latin1' should include its arguments */
#define _generic_utf8_safe_no_upper_latin1(classnum, p, e, above_latin1)    \
         (__ASSERT_(_utf8_safe_assert(p, e))                                \
         (isASCII(*(p)))                                                    \
          ? _generic_isCC(*(p), classnum)                                   \
          : (UTF8_IS_DOWNGRADEABLE_START(*(p)))                             \
             ? 0 /* Note that doesn't check validity for latin1 */          \
             : above_latin1)


#define isALPHA_utf8(p, e)         isALPHA_utf8_safe(p, e)
#define isALPHANUMERIC_utf8(p, e)  isALPHANUMERIC_utf8_safe(p, e)
#define isASCII_utf8(p, e)         isASCII_utf8_safe(p, e)
#define isBLANK_utf8(p, e)         isBLANK_utf8_safe(p, e)
#define isCNTRL_utf8(p, e)         isCNTRL_utf8_safe(p, e)
#define isDIGIT_utf8(p, e)         isDIGIT_utf8_safe(p, e)
#define isGRAPH_utf8(p, e)         isGRAPH_utf8_safe(p, e)
#define isIDCONT_utf8(p, e)        isIDCONT_utf8_safe(p, e)
#define isIDFIRST_utf8(p, e)       isIDFIRST_utf8_safe(p, e)
#define isLOWER_utf8(p, e)         isLOWER_utf8_safe(p, e)
#define isPRINT_utf8(p, e)         isPRINT_utf8_safe(p, e)
#define isPSXSPC_utf8(p, e)        isPSXSPC_utf8_safe(p, e)
#define isPUNCT_utf8(p, e)         isPUNCT_utf8_safe(p, e)
#define isSPACE_utf8(p, e)         isSPACE_utf8_safe(p, e)
#define isUPPER_utf8(p, e)         isUPPER_utf8_safe(p, e)
#define isVERTWS_utf8(p, e)        isVERTWS_utf8_safe(p, e)
#define isWORDCHAR_utf8(p, e)      isWORDCHAR_utf8_safe(p, e)
#define isXDIGIT_utf8(p, e)        isXDIGIT_utf8_safe(p, e)

#define isALPHA_utf8_safe(p, e)  _generic_invlist_utf8_safe(_CC_ALPHA, p, e)
#define isALPHANUMERIC_utf8_safe(p, e)                                      \
                        _generic_invlist_utf8_safe(_CC_ALPHANUMERIC, p, e)
#define isASCII_utf8_safe(p, e)                                             \
    /* Because ASCII is invariant under utf8, the non-utf8 macro            \
    * works */                                                              \
    (__ASSERT_(_utf8_safe_assert(p, e)) isASCII(*(p)))
#define isBLANK_utf8_safe(p, e)                                             \
        _generic_non_invlist_utf8_safe(_CC_BLANK, is_HORIZWS_high, p, e)

#ifdef EBCDIC
    /* Because all controls are UTF-8 invariants in EBCDIC, we can use this
     * more efficient macro instead of the more general one */
#   define isCNTRL_utf8_safe(p, e)                                          \
                    (__ASSERT_(_utf8_safe_assert(p, e)) isCNTRL_L1(*(p)))
#else
#   define isCNTRL_utf8_safe(p, e)  _generic_utf8_safe(_CC_CNTRL, p, e, 0)
#endif

#define isDIGIT_utf8_safe(p, e)                                             \
            _generic_utf8_safe_no_upper_latin1(_CC_DIGIT, p, e,             \
                                            _is_utf8_FOO(_CC_DIGIT, p, e))
#define isGRAPH_utf8_safe(p, e)    _generic_invlist_utf8_safe(_CC_GRAPH, p, e)
#define isIDCONT_utf8_safe(p, e)   _generic_func_utf8_safe(_CC_WORDCHAR,    \
                                                 _is_utf8_perl_idcont, p, e)

/* To prevent S_scan_word in toke.c from hanging, we have to make sure that
 * IDFIRST is an alnum.  See
 * https://github.com/Perl/perl5/issues/10275 for more detail than you
 * ever wanted to know about.  (In the ASCII range, there isn't a difference.)
 * This used to be not the XID version, but we decided to go with the more
 * modern Unicode definition */
#define isIDFIRST_utf8_safe(p, e)                                           \
    _generic_func_utf8_safe(_CC_IDFIRST,                                    \
                            _is_utf8_perl_idstart, (U8 *) (p), (U8 *) (e))

#define isLOWER_utf8_safe(p, e)     _generic_invlist_utf8_safe(_CC_LOWER, p, e)
#define isPRINT_utf8_safe(p, e)     _generic_invlist_utf8_safe(_CC_PRINT, p, e)
#define isPSXSPC_utf8_safe(p, e)     isSPACE_utf8_safe(p, e)
#define isPUNCT_utf8_safe(p, e)     _generic_invlist_utf8_safe(_CC_PUNCT, p, e)
#define isSPACE_utf8_safe(p, e)                                             \
    _generic_non_invlist_utf8_safe(_CC_SPACE, is_XPERLSPACE_high, p, e)
#define isUPPER_utf8_safe(p, e)  _generic_invlist_utf8_safe(_CC_UPPER, p, e)
#define isVERTWS_utf8_safe(p, e)                                            \
        _generic_non_invlist_utf8_safe(_CC_VERTSPACE, is_VERTWS_high, p, e)
#define isWORDCHAR_utf8_safe(p, e)                                          \
                             _generic_invlist_utf8_safe(_CC_WORDCHAR, p, e)
#define isXDIGIT_utf8_safe(p, e)                                            \
                   _generic_utf8_safe_no_upper_latin1(_CC_XDIGIT, p, e,     \
                             (UNLIKELY((e) - (p) < UTF8SKIP(p))             \
                              ? (_force_out_malformed_utf8_message(         \
                                      (U8 *) (p), (U8 *) (e), 0, 1), 0)     \
                              : is_XDIGIT_high(p)))

#define toFOLD_utf8(p,e,s,l)	toFOLD_utf8_safe(p,e,s,l)
#define toLOWER_utf8(p,e,s,l)	toLOWER_utf8_safe(p,e,s,l)
#define toTITLE_utf8(p,e,s,l)	toTITLE_utf8_safe(p,e,s,l)
#define toUPPER_utf8(p,e,s,l)	toUPPER_utf8_safe(p,e,s,l)

/* For internal core use only, subject to change */
#define _toFOLD_utf8_flags(p,e,s,l,f)  _to_utf8_fold_flags (p,e,s,l,f)
#define _toLOWER_utf8_flags(p,e,s,l,f) _to_utf8_lower_flags(p,e,s,l,f)
#define _toTITLE_utf8_flags(p,e,s,l,f) _to_utf8_title_flags(p,e,s,l,f)
#define _toUPPER_utf8_flags(p,e,s,l,f) _to_utf8_upper_flags(p,e,s,l,f)

#define toFOLD_utf8_safe(p,e,s,l)   _toFOLD_utf8_flags(p,e,s,l, FOLD_FLAGS_FULL)
#define toLOWER_utf8_safe(p,e,s,l)  _toLOWER_utf8_flags(p,e,s,l, 0)
#define toTITLE_utf8_safe(p,e,s,l)  _toTITLE_utf8_flags(p,e,s,l, 0)
#define toUPPER_utf8_safe(p,e,s,l)  _toUPPER_utf8_flags(p,e,s,l, 0)

#define isALPHA_LC_utf8(p, e)         isALPHA_LC_utf8_safe(p, e)
#define isALPHANUMERIC_LC_utf8(p, e)  isALPHANUMERIC_LC_utf8_safe(p, e)
#define isASCII_LC_utf8(p, e)         isASCII_LC_utf8_safe(p, e)
#define isBLANK_LC_utf8(p, e)         isBLANK_LC_utf8_safe(p, e)
#define isCNTRL_LC_utf8(p, e)         isCNTRL_LC_utf8_safe(p, e)
#define isDIGIT_LC_utf8(p, e)         isDIGIT_LC_utf8_safe(p, e)
#define isGRAPH_LC_utf8(p, e)         isGRAPH_LC_utf8_safe(p, e)
#define isIDCONT_LC_utf8(p, e)        isIDCONT_LC_utf8_safe(p, e)
#define isIDFIRST_LC_utf8(p, e)       isIDFIRST_LC_utf8_safe(p, e)
#define isLOWER_LC_utf8(p, e)         isLOWER_LC_utf8_safe(p, e)
#define isPRINT_LC_utf8(p, e)         isPRINT_LC_utf8_safe(p, e)
#define isPSXSPC_LC_utf8(p, e)        isPSXSPC_LC_utf8_safe(p, e)
#define isPUNCT_LC_utf8(p, e)         isPUNCT_LC_utf8_safe(p, e)
#define isSPACE_LC_utf8(p, e)         isSPACE_LC_utf8_safe(p, e)
#define isUPPER_LC_utf8(p, e)         isUPPER_LC_utf8_safe(p, e)
#define isWORDCHAR_LC_utf8(p, e)      isWORDCHAR_LC_utf8_safe(p, e)
#define isXDIGIT_LC_utf8(p, e)        isXDIGIT_LC_utf8_safe(p, e)

/* For internal core Perl use only: the base macros for defining macros like
 * isALPHA_LC_utf8_safe.  These are like _generic_utf8, but if the first code
 * point in 'p' is within the 0-255 range, it uses locale rules from the
 * passed-in 'macro' parameter */
#define _generic_LC_utf8_safe(macro, p, e, above_latin1)                    \
         (__ASSERT_(_utf8_safe_assert(p, e))                                \
         (UTF8_IS_INVARIANT(*(p)))                                          \
          ? macro(*(p))                                                     \
          : (UTF8_IS_DOWNGRADEABLE_START(*(p))                              \
             ? ((LIKELY((e) - (p) > 1 && UTF8_IS_CONTINUATION(*((p)+1))))   \
                ? macro(EIGHT_BIT_UTF8_TO_NATIVE(*(p), *((p)+1)))           \
                : (_force_out_malformed_utf8_message(                       \
                                        (U8 *) (p), (U8 *) (e), 0, 1), 0))  \
              : above_latin1))

#define _generic_LC_invlist_utf8_safe(macro, classnum, p, e)                  \
            _generic_LC_utf8_safe(macro, p, e,                              \
                                            _is_utf8_FOO(classnum, p, e))

#define _generic_LC_func_utf8_safe(macro, above_latin1, p, e)               \
            _generic_LC_utf8_safe(macro, p, e, above_latin1(p, e))

#define _generic_LC_non_invlist_utf8_safe(classnum, above_latin1, p, e)       \
          _generic_LC_utf8_safe(classnum, p, e,                             \
                             (UNLIKELY((e) - (p) < UTF8SKIP(p))             \
                              ? (_force_out_malformed_utf8_message(         \
                                      (U8 *) (p), (U8 *) (e), 0, 1), 0)     \
                              : above_latin1(p)))

#define isALPHANUMERIC_LC_utf8_safe(p, e)                                   \
            _generic_LC_invlist_utf8_safe(isALPHANUMERIC_LC,                  \
                                        _CC_ALPHANUMERIC, p, e)
#define isALPHA_LC_utf8_safe(p, e)                                          \
            _generic_LC_invlist_utf8_safe(isALPHA_LC, _CC_ALPHA, p, e)
#define isASCII_LC_utf8_safe(p, e)                                          \
                    (__ASSERT_(_utf8_safe_assert(p, e)) isASCII_LC(*(p)))
#define isBLANK_LC_utf8_safe(p, e)                                          \
        _generic_LC_non_invlist_utf8_safe(isBLANK_LC, is_HORIZWS_high, p, e)
#define isCNTRL_LC_utf8_safe(p, e)                                          \
            _generic_LC_utf8_safe(isCNTRL_LC, p, e, 0)
#define isDIGIT_LC_utf8_safe(p, e)                                          \
            _generic_LC_invlist_utf8_safe(isDIGIT_LC, _CC_DIGIT, p, e)
#define isGRAPH_LC_utf8_safe(p, e)                                          \
            _generic_LC_invlist_utf8_safe(isGRAPH_LC, _CC_GRAPH, p, e)
#define isIDCONT_LC_utf8_safe(p, e)                                         \
            _generic_LC_func_utf8_safe(isIDCONT_LC,                         \
                                                _is_utf8_perl_idcont, p, e)
#define isIDFIRST_LC_utf8_safe(p, e)                                        \
            _generic_LC_func_utf8_safe(isIDFIRST_LC,                        \
                                               _is_utf8_perl_idstart, p, e)
#define isLOWER_LC_utf8_safe(p, e)                                          \
            _generic_LC_invlist_utf8_safe(isLOWER_LC, _CC_LOWER, p, e)
#define isPRINT_LC_utf8_safe(p, e)                                          \
            _generic_LC_invlist_utf8_safe(isPRINT_LC, _CC_PRINT, p, e)
#define isPSXSPC_LC_utf8_safe(p, e)    isSPACE_LC_utf8_safe(p, e)
#define isPUNCT_LC_utf8_safe(p, e)                                          \
            _generic_LC_invlist_utf8_safe(isPUNCT_LC, _CC_PUNCT, p, e)
#define isSPACE_LC_utf8_safe(p, e)                                          \
    _generic_LC_non_invlist_utf8_safe(isSPACE_LC, is_XPERLSPACE_high, p, e)
#define isUPPER_LC_utf8_safe(p, e)                                          \
            _generic_LC_invlist_utf8_safe(isUPPER_LC, _CC_UPPER, p, e)
#define isWORDCHAR_LC_utf8_safe(p, e)                                       \
            _generic_LC_invlist_utf8_safe(isWORDCHAR_LC, _CC_WORDCHAR, p, e)
#define isXDIGIT_LC_utf8_safe(p, e)                                         \
        _generic_LC_non_invlist_utf8_safe(isXDIGIT_LC, is_XDIGIT_high, p, e)

/* Macros for backwards compatibility and for completeness when the ASCII and
 * Latin1 values are identical */
#define isALPHAU(c)         isALPHA_L1(c)
#define isDIGIT_L1(c)       isDIGIT_A(c)
#define isOCTAL(c)          isOCTAL_A(c)
#define isOCTAL_L1(c)       isOCTAL_A(c)
#define isXDIGIT_L1(c)      isXDIGIT_A(c)
#define isALNUM(c)          isWORDCHAR(c)
#define isALNUM_A(c)        isALNUM(c)
#define isALNUMU(c)         isWORDCHAR_L1(c)
#define isALNUM_LC(c)       isWORDCHAR_LC(c)
#define isALNUM_uni(c)      isWORDCHAR_uni(c)
#define isALNUM_LC_uvchr(c) isWORDCHAR_LC_uvchr(c)
#define isALNUM_utf8(p,e)   isWORDCHAR_utf8(p,e)
#define isALNUM_utf8_safe(p,e) isWORDCHAR_utf8_safe(p,e)
#define isALNUM_LC_utf8(p,e)isWORDCHAR_LC_utf8(p,e)
#define isALNUM_LC_utf8_safe(p,e)isWORDCHAR_LC_utf8_safe(p,e)
#define isALNUMC_A(c)       isALPHANUMERIC_A(c)      /* Mnemonic: "C's alnum" */
#define isALNUMC_L1(c)      isALPHANUMERIC_L1(c)
#define isALNUMC(c)	    isALPHANUMERIC(c)
#define isALNUMC_LC(c)	    isALPHANUMERIC_LC(c)
#define isALNUMC_uni(c)     isALPHANUMERIC_uni(c)
#define isALNUMC_LC_uvchr(c) isALPHANUMERIC_LC_uvchr(c)
#define isALNUMC_utf8(p,e)  isALPHANUMERIC_utf8(p,e)
#define isALNUMC_utf8_safe(p,e)  isALPHANUMERIC_utf8_safe(p,e)
#define isALNUMC_LC_utf8_safe(p,e) isALPHANUMERIC_LC_utf8_safe(p,e)

/* On EBCDIC platforms, CTRL-@ is 0, CTRL-A is 1, etc, just like on ASCII,
 * except that they don't necessarily mean the same characters, e.g. CTRL-D is
 * 4 on both systems, but that is EOT on ASCII;  ST on EBCDIC.
 * '?' is special-cased on EBCDIC to APC, which is the control there that is
 * the outlier from the block that contains the other controls, just like
 * toCTRL('?') on ASCII yields DEL, the control that is the outlier from the C0
 * block.  If it weren't special cased, it would yield a non-control.
 * The conversion works both ways, so toCTRL('D') is 4, and toCTRL(4) is D,
 * etc. */
#ifndef EBCDIC
#  define toCTRL(c)    (__ASSERT_(FITS_IN_8_BITS(c)) toUPPER(((U8)(c))) ^ 64)
#else
#  define toCTRL(c)   (__ASSERT_(FITS_IN_8_BITS(c))                     \
                      ((isPRINT_A(c))                                   \
                       ? (UNLIKELY((c) == '?')                          \
                         ? QUESTION_MARK_CTRL                           \
                         : (NATIVE_TO_LATIN1(toUPPER((U8) (c))) ^ 64))  \
                       : (UNLIKELY((c) == QUESTION_MARK_CTRL)           \
                         ? '?'                                          \
                         : (LATIN1_TO_NATIVE(((U8) (c)) ^ 64)))))
#endif

/*
=for apidoc Ay||line_t
The typedef to use to declare variables that are to hold line numbers.

=cut

  Line numbers are unsigned, 32 bits.
*/
typedef U32 line_t;
#define NOLINE ((line_t) 4294967295UL)  /* = FFFFFFFF */

/* Helpful alias for version prescan */
#define is_LAX_VERSION(a,b) \
        (a != Perl_prescan_version(aTHX_ a, FALSE, b, NULL, NULL, NULL, NULL))

#define is_STRICT_VERSION(a,b) \
        (a != Perl_prescan_version(aTHX_ a, TRUE, b, NULL, NULL, NULL, NULL))

#define BADVERSION(a,b,c) \
        if (b) { \
            *b = c; \
        } \
        return a;

/* Converts a character KNOWN to represent a hexadecimal digit (0-9, A-F, or
 * a-f) to its numeric value without using any branches.  The input is
 * validated only by an assert() in DEBUGGING builds.
 *
 * It works by right shifting and isolating the bit that is 0 for the digits,
 * and 1 for at least the alphas A-F, a-f.  The bit is shifted to the ones
 * position, and then to the eights position.  Both are added together to form
 * 0 if the input is '0'-'9' and to form 9 if alpha.  This is added to the
 * final four bits of the input to form the correct value. */
#define XDIGIT_VALUE(c) (__ASSERT_(isXDIGIT(c))                             \
           ((NATIVE_TO_LATIN1(c) >> 6) & 1)  /* 1 if alpha; 0 if not */     \
         + ((NATIVE_TO_LATIN1(c) >> 3) & 8)  /* 8 if alpha; 0 if not */     \
         + ((c) & 0xF))   /* 0-9 if input valid hex digit */

/* The argument is a string pointer, which is advanced. */
#define READ_XDIGIT(s)  ((s)++, XDIGIT_VALUE(*((s) - 1)))

/* Converts a character known to represent an octal digit (0-7) to its numeric
 * value.  The input is validated only by an assert() in DEBUGGING builds.  In
 * both ASCII and EBCDIC the last 3 bits of the octal digits range from 0-7. */
#define OCTAL_VALUE(c) (__ASSERT_(isOCTAL(c)) (7 & (c)))

/* Efficiently returns a boolean as to if two native characters are equivalent
 * case-insensitively.  At least one of the characters must be one of [A-Za-z];
 * the ALPHA in the name is to remind you of that.  This is asserted() in
 * DEBUGGING builds.  Because [A-Za-z] are invariant under UTF-8, this macro
 * works (on valid input) for both non- and UTF-8-encoded bytes.
 *
 * When one of the inputs is a compile-time constant and gets folded by the
 * compiler, this reduces to an AND and a TEST.  On both EBCDIC and ASCII
 * machines, 'A' and 'a' differ by a single bit; the same with the upper and
 * lower case of all other ASCII-range alphabetics.  On ASCII platforms, they
 * are 32 apart; on EBCDIC, they are 64.  At compile time, this uses an
 * exclusive 'or' to find that bit and then inverts it to form a mask, with
 * just a single 0, in the bit position where the upper- and lowercase differ.
 * */
#define isALPHA_FOLD_EQ(c1, c2)                                         \
                      (__ASSERT_(isALPHA_A(c1) || isALPHA_A(c2))        \
                      ((c1) & ~('A' ^ 'a')) ==  ((c2) & ~('A' ^ 'a')))
#define isALPHA_FOLD_NE(c1, c2) (! isALPHA_FOLD_EQ((c1), (c2)))

/*
=for apidoc_section $memory

=for apidoc Am|void|Newx|void* ptr|int nitems|type
=for apidoc_item |void*|safemalloc|size_t size

The XSUB-writer's interface to the C C<malloc> function.

Memory obtained by this should B<ONLY> be freed with L</"Safefree">.

In 5.9.3, Newx() and friends replace the older New() API, and drops
the first parameter, I<x>, a debug aid which allowed callers to identify
themselves.  This aid has been superseded by a new build option,
PERL_MEM_LOG (see L<perlhacktips/PERL_MEM_LOG>).  The older API is still
there for use in XS modules supporting older perls.

=for apidoc Am|void|Newxc|void* ptr|int nitems|type|cast
The XSUB-writer's interface to the C C<malloc> function, with
cast.  See also C<L</Newx>>.

Memory obtained by this should B<ONLY> be freed with L</"Safefree">.

=for apidoc Am|void|Newxz|void* ptr|int nitems|type
=for apidoc_item |void*|safecalloc|size_t nitems|size_t item_size

The XSUB-writer's interface to the C C<malloc> function.  The allocated
memory is zeroed with C<memzero>.  See also C<L</Newx>>.

Memory obtained by this should B<ONLY> be freed with L</"Safefree">.

=for apidoc Am|void|Renew|void* ptr|int nitems|type
=for apidoc_item |void*|saferealloc|void *ptr|size_t size

The XSUB-writer's interface to the C C<realloc> function.

Memory obtained by this should B<ONLY> be freed with L</"Safefree">.

=for apidoc Am|void|Renewc|void* ptr|int nitems|type|cast
The XSUB-writer's interface to the C C<realloc> function, with
cast.

Memory obtained by this should B<ONLY> be freed with L</"Safefree">.

=for apidoc Am|void|Safefree|void* ptr
The XSUB-writer's interface to the C C<free> function.

This should B<ONLY> be used on memory obtained using L</"Newx"> and friends.

=for apidoc_section $string
=for apidoc    Am|void  |Move |void* src|void* dest|int nitems|type
=for apidoc_item |void *|MoveD|void* src|void* dest|int nitems|type
The XSUB-writer's interface to the C C<memmove> function.  The C<src> is the
source, C<dest> is the destination, C<nitems> is the number of items, and
C<type> is the type.  Can do overlapping moves.  See also C<L</Copy>>.

C<MoveD> is like C<Move> but returns C<dest>.  Useful
for encouraging compilers to tail-call
optimise.

=for apidoc    Am|void  |Copy |void* src|void* dest|int nitems|type
=for apidoc_item |void *|CopyD|void* src|void* dest|int nitems|type
The XSUB-writer's interface to the C C<memcpy> function.  The C<src> is the
source, C<dest> is the destination, C<nitems> is the number of items, and
C<type> is the type.  May fail on overlapping copies.  See also C<L</Move>>.

C<CopyD> is like C<Copy> but returns C<dest>.  Useful
for encouraging compilers to tail-call
optimise.

=for apidoc    Am|void  |Zero |void* dest|int nitems|type
=for apidoc_item |void *|ZeroD|void* dest|int nitems|type

The XSUB-writer's interface to the C C<memzero> function.  The C<dest> is the
destination, C<nitems> is the number of items, and C<type> is the type.

C<ZeroD> is like C<Zero> but returns C<dest>.  Useful
for encouraging compilers to tail-call
optimise.

=for apidoc_section $utility
=for apidoc Amu|void|StructCopy|type *src|type *dest|type
This is an architecture-independent macro to copy one structure to another.

=for apidoc Am|void|PoisonWith|void* dest|int nitems|type|U8 byte

Fill up memory with a byte pattern (a byte repeated over and over
again) that hopefully catches attempts to access uninitialized memory.

=for apidoc Am|void|PoisonNew|void* dest|int nitems|type

PoisonWith(0xAB) for catching access to allocated but uninitialized memory.

=for apidoc Am|void|PoisonFree|void* dest|int nitems|type

PoisonWith(0xEF) for catching access to freed memory.

=for apidoc Am|void|Poison|void* dest|int nitems|type

PoisonWith(0xEF) for catching access to freed memory.

=cut */

/* Maintained for backwards-compatibility only. Use newSV() instead. */
#ifndef PERL_CORE
#define NEWSV(x,len)	newSV(len)
#endif

#define MEM_SIZE_MAX ((MEM_SIZE)-1)

#define _PERL_STRLEN_ROUNDUP_UNCHECKED(n) (((n) - 1 + PERL_STRLEN_ROUNDUP_QUANTUM) & ~((MEM_SIZE)PERL_STRLEN_ROUNDUP_QUANTUM - 1))

#ifdef PERL_MALLOC_WRAP

/* This expression will be constant-folded at compile time.  It checks
 * whether or not the type of the count n is so small (e.g. U8 or U16, or
 * U32 on 64-bit systems) that there's no way a wrap-around could occur.
 * As well as avoiding the need for a run-time check in some cases, it's
 * designed to avoid compiler warnings like:
 *     comparison is always false due to limited range of data type
 * It's mathematically equivalent to
 *    max(n) * sizeof(t) > MEM_SIZE_MAX
 */

#  define _MEM_WRAP_NEEDS_RUNTIME_CHECK(n,t) \
