          'to\n'
          '      this from within a trace function jumps to the given line '
          '(only\n'
          '      for the bottom-most frame).  A debugger can implement a Jump\n'
          '      command (aka Set Next Statement) by writing to f_lineno.\n'
          '\n'
          '      Frame objects support one method:\n'
          '\n'
          '      frame.clear()\n'
          '\n'
          '         This method clears all references to local variables held '
          'by\n'
          '         the frame.  Also, if the frame belonged to a generator, '
          'the\n'
          '         generator is finalized.  This helps break reference '
          'cycles\n'
          '         involving frame objects (for example when catching an\n'
          '         exception and storing its traceback for later use).\n'
          '\n'
          '         "RuntimeError" is raised if the frame is currently '
          'executing.\n'
          '\n'
          '         New in version 3.4.\n'
          '\n'
          '   Traceback objects\n'
          '      Traceback objects represent a stack trace of an exception.  '
          'A\n'
          '      traceback object is implicitly created when an exception '
          'occurs,\n'
          '      and may also be explicitly created by calling\n'
          '      "types.TracebackType".\n'
          '\n'
          '      For implicitly created tracebacks, when the search for an\n'
          '      exception handler unwinds the execution stack, at each '
          'unwound\n'
          '      level a traceback object is inserted in front of the current\n'
          '      traceback.  When an exception handler is entered, the stack\n'
          '      trace is made available to the program. (See section The try\n'
          '      statement.) It is accessible as the third item of the tuple\n'
          '      returned by "sys.exc_info()", and as the "__traceback__"\n'
          '      attribute of the caught exception.\n'
          '\n'
          '      When the program contains no suitable handler, the stack '
          'trace\n'
          '      is written (nicely formatted) to the standard error stream; '
          'if\n'
          '      the interpreter is interactive, it is also made available to '
          'the\n'
          '      user as "sys.last_traceback".\n'
          '\n'
          '      For explicitly created tracebacks, it is up to the creator '
          'of\n'
          '      the traceback to determine how the "tb_next" attributes '
          'should\n'
          '      be linked to form a full stack trace.\n'
          '\n'
          '      Special read-only attributes: "tb_frame" points to the '
          'execution\n'
          '      frame of the current level; "tb_lineno" gives the line '
          'number\n'
          '      where the exception occurred; "tb_lasti" indicates the '
          'precise\n'
          '      instruction. The line number and last instruction in the\n'
          '      traceback may differ from the line number of its frame object '
          'if\n'
          '      the exception occurred in a "try" statement with no matching\n'
          '      except clause or with a finally clause.\n'
          '\n'
          '      Accessing "tb_frame" raises an auditing event\n'
          '      "object.__getattr__" with arguments "obj" and ""tb_frame"".\n'
          '\n'
          '      Special writable attribute: "tb_next" is the next level in '
          'the\n'
          '      stack trace (towards the frame where the exception occurred), '
          'or\n'
          '      "None" if there is no next level.\n'
          '\n'
          '      Changed in version 3.7: Traceback objects can now be '
          'explicitly\n'
          '      instantiated from Python code, and the "tb_next" attribute '
          'of\n'
          '      existing instances can be updated.\n'
          '\n'
          '   Slice objects\n'
          '      Slice objects are used to represent slices for '
          '"__getitem__()"\n'
          '      methods.  They are also created by the built-in "slice()"\n'
          '      function.\n'
          '\n'
          '      Special read-only attributes: "start" is the lower bound; '
          '"stop"\n'
          '      is the upper bound; "step" is the step value; each is "None" '
          'if\n'
          '      omitted.  These attributes can have any type.\n'
          '\n'
          '      Slice objects support one method:\n'
          '\n'
          '      slice.indices(self, length)\n'
          '\n'
          '         This method takes a single integer argument *length* and\n'
          '         computes information about the slice that the slice '
          'object\n'
          '         would describe if applied to a sequence of *length* '
          'items.\n'
          '         It returns a tuple of three integers; respectively these '
          'are\n'
          '         the *start* and *stop* indices and the *step* or stride\n'
          '         length of the slice. Missing or out-of-bounds indices are\n'
          '         handled in a manner consistent with regular slices.\n'
          '\n'
          '   Static method objects\n'
          '      Static method objects provide a way of defeating the\n'
          '      transformation of function objects to method objects '
          'described\n'
          '      above. A static method object is a wrapper around any other\n'
          '      object, usually a user-defined method object. When a static\n'
          '      method object is retrieved from a class or a class instance, '
          'the\n'
          '      object actually returned is the wrapped object, which is not\n'
          '      subject to any further transformation. Static method objects '
          'are\n'
          '      also callable. Static method objects are created by the '
          'built-in\n'
          '      "staticmethod()" constructor.\n'
          '\n'
          '   Class method objects\n'
          '      A class method object, like a static method object, is a '
          'wrapper\n'
          '      around another object that alters the way in which that '
          'object\n'
          '      is retrieved from classes and class instances. The behaviour '
          'of\n'
          '      class method objects upon such retrieval is described above,\n'
          '      under “User-defined methods”. Class method objects are '
          'created\n'
          '      by the built-in "classmethod()" constructor.\n',
 'typesfunctions': 'Functions\n'
                   '*********\n'
                   '\n'
                   'Function objects are created by function definitions.  The '
                   'only\n'
                   'operation on a function object is to call it: '
                   '"func(argument-list)".\n'
                   '\n'
                   'There are really two flavors of function objects: built-in '
                   'functions\n'
                   'and user-defined functions.  Both support the same '
                   'operation (to call\n'
                   'the function), but the implementation is different, hence '
                   'the\n'
                   'different object types.\n'
                   '\n'
                   'See Function definitions for more information.\n',
 'typesmapping': 'Mapping Types — "dict"\n'
                 '**********************\n'
                 '\n'
                 'A *mapping* object maps *hashable* values to arbitrary '
                 'objects.\n'
                 'Mappings are mutable objects.  There is currently only one '
                 'standard\n'
                 'mapping type, the *dictionary*.  (For other containers see '
                 'the built-\n'
                 'in "list", "set", and "tuple" classes, and the "collections" '
                 'module.)\n'
                 '\n'
                 'A dictionary’s keys are *almost* arbitrary values.  Values '
                 'that are\n'
                 'not *hashable*, that is, values containing lists, '
                 'dictionaries or\n'
                 'other mutable types (that are compared by value rather than '
                 'by object\n'
                 'identity) may not be used as keys. Values that compare equal '
                 '(such as\n'
                 '"1", "1.0", and "True") can be used interchangeably to index '
                 'the same\n'
                 'dictionary entry.\n'
                 '\n'
                 'class dict(**kwargs)\n'
                 'class dict(mapping, **kwargs)\n'
                 'class dict(iterable, **kwargs)\n'
                 '\n'
                 '   Return a new dictionary initialized from an optional '
                 'positional\n'
                 '   argument and a possibly empty set of keyword arguments.\n'
                 '\n'
                 '   Dictionaries can be created by several means:\n'
                 '\n'
                 '   * Use a comma-separated list of "key: value" pairs within '
                 'braces:\n'
                 '     "{\'jack\': 4098, \'sjoerd\': 4127}" or "{4098: '
                 "'jack', 4127:\n"
                 '     \'sjoerd\'}"\n'
                 '\n'
                 '   * Use a dict comprehension: "{}", "{x: x ** 2 for x in '
                 'range(10)}"\n'
                 '\n'
                 '   * Use the type constructor: "dict()", "dict([(\'foo\', '
                 "100), ('bar',\n"
                 '     200)])", "dict(foo=100, bar=200)"\n'
                 '\n'
                 '   If no positional argument is given, an empty dictionary '
                 'is created.\n'
                 '   If a positional argument is given and it is a mapping '
                 'object, a\n'
                 '   dictionary is created with the same key-value pairs as '
                 'the mapping\n'
                 '   object.  Otherwise, the positional argument must be an '
                 '*iterable*\n'
                 '   object.  Each item in the iterable must itself be an '
                 'iterable with\n'
                 '   exactly two objects.  The first object of each item '
                 'becomes a key\n'
                 '   in the new dictionary, and the second object the '
                 'corresponding\n'
                 '   value.  If a key occurs more than once, the last value '
                 'for that key\n'
                 '   becomes the corresponding value in the new dictionary.\n'
                 '\n'
                 '   If keyword arguments are given, the keyword arguments and '
                 'their\n'
                 '   values are added to the dictionary created from the '
                 'positional\n'
                 '   argument.  If a key being added is already present, the '
                 'value from\n'
                 '   the keyword argument replaces the value from the '
                 'positional\n'
                 '   argument.\n'
                 '\n'
                 '   To illustrate, the following examples all return a '
                 'dictionary equal\n'
                 '   to "{"one": 1, "two": 2, "three": 3}":\n'
                 '\n'
                 '      >>> a = dict(one=1, two=2, three=3)\n'
                 "      >>> b = {'one': 1, 'two': 2, 'three': 3}\n"
                 "      >>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))\n"
                 "      >>> d = dict([('two', 2), ('one', 1), ('three', 3)])\n"
                 "      >>> e = dict({'three': 3, 'one': 1, 'two': 2})\n"
                 "      >>> f = dict({'one': 1, 'three': 3}, two=2)\n"
                 '      >>> a == b == c == d == e == f\n'
                 '      True\n'
                 '\n'
                 '   Providing keyword arguments as in the first example only '
                 'works for\n'
                 '   keys that are valid Python identifiers.  Otherwise, any '
                 'valid keys\n'
                 '   can be used.\n'
                 '\n'
                 '   These are the operations that dictionaries support (and '
                 'therefore,\n'
                 '   custom mapping types should support too):\n'
                 '\n'
                 '   list(d)\n'
                 '\n'
                 '      Return a list of all the keys used in the dictionary '
                 '*d*.\n'
                 '\n'
                 '   len(d)\n'
                 '\n'
                 '      Return the number of items in the dictionary *d*.\n'
                 '\n'
                 '   d[key]\n'
                 '\n'
                 '      Return the item of *d* with key *key*.  Raises a '
                 '"KeyError" if\n'
                 '      *key* is not in the map.\n'
                 '\n'
                 '      If a subclass of dict defines a method "__missing__()" '
                 'and *key*\n'
                 '      is not present, the "d[key]" operation calls that '
                 'method with\n'
                 '      the key *key* as argument.  The "d[key]" operation '
                 'then returns\n'
                 '      or raises whatever is returned or raised by the\n'
                 '      "__missing__(key)" call. No other operations or '
                 'methods invoke\n'
                 '      "__missing__()". If "__missing__()" is not defined, '
                 '"KeyError"\n'
                 '      is raised. "__missing__()" must be a method; it cannot '
                 'be an\n'
                 '      instance variable:\n'
                 '\n'
                 '         >>> class Counter(dict):\n'
                 '         ...     def __missing__(self, key):\n'
                 '         ...         return 0\n'
                 '         >>> c = Counter()\n'
                 "         >>> c['red']\n"
                 '         0\n'
                 "         >>> c['red'] += 1\n"
                 "         >>> c['red']\n"
                 '         1\n'
                 '\n'
                 '      The example above shows part of the implementation of\n'
                 '      "collections.Counter".  A different "__missing__" '
                 'method is used\n'
                 '      by "collections.defaultdict".\n'
                 '\n'
                 '   d[key] = value\n'
                 '\n'
                 '      Set "d[key]" to *value*.\n'
                 '\n'
                 '   del d[key]\n'
                 '\n'
                 '      Remove "d[key]" from *d*.  Raises a "KeyError" if '
                 '*key* is not\n'
                 '      in the map.\n'
                 '\n'
                 '   key in d\n'
                 '\n'
                 '      Return "True" if *d* has a key *key*, else "False".\n'
                 '\n'
                 '   key not in d\n'
                 '\n'
                 '      Equivalent to "not key in d".\n'
                 '\n'
                 '   iter(d)\n'
                 '\n'
                 '      Return an iterator over the keys of the dictionary.  '
                 'This is a\n'
                 '      shortcut for "iter(d.keys())".\n'
                 '\n'
                 '   clear()\n'
                 '\n'
                 '      Remove all items from the dictionary.\n'
                 '\n'
                 '   copy()\n'
                 '\n'
                 '      Return a shallow copy of the dictionary.\n'
                 '\n'
                 '   classmethod fromkeys(iterable[, value])\n'
                 '\n'
                 '      Create a new dictionary with keys from *iterable* and '
                 'values set\n'
                 '      to *value*.\n'
                 '\n'
                 '      "fromkeys()" is a class method that returns a new '
                 'dictionary.\n'
                 '      *value* defaults to "None".  All of the values refer '
                 'to just a\n'
                 '      single instance, so it generally doesn’t make sense '
                 'for *value*\n'
                 '      to be a mutable object such as an empty list.  To get '
                 'distinct\n'
                 '      values, use a dict comprehension instead.\n'
                 '\n'
                 '   get(key[, default])\n'
                 '\n'
                 '      Return the value for *key* if *key* is in the '
                 'dictionary, else\n'
                 '      *default*. If *default* is not given, it defaults to '
                 '"None", so\n'
                 '      that this method never raises a "KeyError".\n'
                 '\n'
                 '   items()\n'
                 '\n'
                 '      Return a new view of the dictionary’s items ("(key, '
                 'value)"\n'
                 '      pairs). See the documentation of view objects.\n'
                 '\n'
                 '   keys()\n'
                 '\n'
                 '      Return a new view of the dictionary’s keys.  See the\n'
                 '      documentation of view objects.\n'
                 '\n'
                 '   pop(key[, default])\n'
                 '\n'
                 '      If *key* is in the dictionary, remove it and return '
                 'its value,\n'
                 '      else return *default*.  If *default* is not given and '
                 '*key* is\n'
                 '      not in the dictionary, a "KeyError" is raised.\n'
                 '\n'
                 '   popitem()\n'
                 '\n'
                 '      Remove and return a "(key, value)" pair from the '
                 'dictionary.\n'
                 '      Pairs are returned in LIFO (last-in, first-out) '
                 'order.\n'
                 '\n'
                 '      "popitem()" is useful to destructively iterate over a\n'
                 '      dictionary, as often used in set algorithms.  If the '
                 'dictionary\n'
                 '      is empty, calling "popitem()" raises a "KeyError".\n'
                 '\n'
                 '      Changed in version 3.7: LIFO order is now guaranteed. '
                 'In prior\n'
                 '      versions, "popitem()" would return an arbitrary '
                 'key/value pair.\n'
                 '\n'
                 '   reversed(d)\n'
                 '\n'
                 '      Return a reverse iterator over the keys of the '
                 'dictionary. This\n'
                 '      is a shortcut for "reversed(d.keys())".\n'
                 '\n'
                 '      New in version 3.8.\n'
                 '\n'
                 '   setdefault(key[, default])\n'
                 '\n'
                 '      If *key* is in the dictionary, return its value.  If '
                 'not, insert\n'
                 '      *key* with a value of *default* and return *default*.  '
                 '*default*\n'
                 '      defaults to "None".\n'
                 '\n'
                 '   update([other])\n'
                 '\n'
                 '      Update the dictionary with the key/value pairs from '
                 '*other*,\n'
                 '      overwriting existing keys.  Return "None".\n'
                 '\n'
                 '      "update()" accepts either another dictionary object or '
                 'an\n'
                 '      iterable of key/value pairs (as tuples or other '
                 'iterables of\n'
                 '      length two).  If keyword arguments are specified, the '
                 'dictionary\n'
                 '      is then updated with those key/value pairs: '
                 '"d.update(red=1,\n'
                 '      blue=2)".\n'
                 '\n'
                 '   values()\n'
                 '\n'
                 '      Return a new view of the dictionary’s values.  See '
                 'the\n'
                 '      documentation of view objects.\n'
                 '\n'
                 '      An equality comparison between one "dict.values()" '
                 'view and\n'
                 '      another will always return "False". This also applies '
                 'when\n'
                 '      comparing "dict.values()" to itself:\n'
                 '\n'
                 "         >>> d = {'a': 1}\n"
                 '         >>> d.values() == d.values()\n'
                 '         False\n'
                 '\n'
                 '   d | other\n'
                 '\n'
                 '      Create a new dictionary with the merged keys and '
                 'values of *d*\n'
                 '      and *other*, which must both be dictionaries. The '
                 'values of\n'
                 '      *other* take priority when *d* and *other* share '
                 'keys.\n'
                 '\n'
                 '      New in version 3.9.\n'
                 '\n'
                 '   d |= other\n'
                 '\n'
                 '      Update the dictionary *d* with keys and values from '
                 '*other*,\n'
                 '      which may be either a *mapping* or an *iterable* of '
                 'key/value\n'
                 '      pairs. The values of *other* take priority when *d* '
                 'and *other*\n'
                 '      share keys.\n'
                 '\n'
                 '      New in version 3.9.\n'
                 '\n'
                 '   Dictionaries compare equal if and only if they have the '
                 'same "(key,\n'
                 '   value)" pairs (regardless of ordering). Order comparisons '
                 '(‘<’,\n'
                 '   ‘<=’, ‘>=’, ‘>’) raise "TypeError".\n'
                 '\n'
                 '   Dictionaries preserve insertion order.  Note that '
                 'updating a key\n'
                 '   does not affect the order.  Keys added after deletion are '
                 'inserted\n'
                 '   at the end.\n'
                 '\n'
                 '      >>> d = {"one": 1, "two": 2, "three": 3, "four": 4}\n'
                 '      >>> d\n'
                 "      {'one': 1, 'two': 2, 'three': 3, 'four': 4}\n"
                 '      >>> list(d)\n'
                 "      ['one', 'two', 'three', 'four']\n"
                 '      >>> list(d.values())\n'
                 '      [1, 2, 3, 4]\n'
                 '      >>> d["one"] = 42\n'
                 '      >>> d\n'
                 "      {'one': 42, 'two': 2, 'three': 3, 'four': 4}\n"
                 '      >>> del d["two"]\n'
                 '      >>> d["two"] = None\n'
                 '      >>> d\n'
                 "      {'one': 42, 'three': 3, 'four': 4, 'two': None}\n"
                 '\n'
                 '   Changed in version 3.7: Dictionary order is guaranteed to '
                 'be\n'
                 '   insertion order.  This behavior was an implementation '
                 'detail of\n'
                 '   CPython from 3.6.\n'
                 '\n'
                 '   Dictionaries and dictionary views are reversible.\n'
                 '\n'
                 '      >>> d = {"one": 1, "two": 2, "three": 3, "four": 4}\n'
                 '      >>> d\n'
                 "      {'one': 1, 'two': 2, 'three': 3, 'four': 4}\n"
                 '      >>> list(reversed(d))\n'
                 "      ['four', 'three', 'two', 'one']\n"
                 '      >>> list(reversed(d.values()))\n'
                 '      [4, 3, 2, 1]\n'
                 '      >>> list(reversed(d.items()))\n'
                 "      [('four', 4), ('three', 3), ('two', 2), ('one', 1)]\n"
                 '\n'
                 '   Changed in version 3.8: Dictionaries are now reversible.\n'
                 '\n'
                 'See also:\n'
                 '\n'
                 '  "types.MappingProxyType" can be used to create a read-only '
                 'view of a\n'
                 '  "dict".\n'
                 '\n'
                 '\n'
                 'Dictionary view objects\n'
                 '=======================\n'
                 '\n'
                 'The objects returned by "dict.keys()", "dict.values()" and\n'
                 '"dict.items()" are *view objects*.  They provide a dynamic '
                 'view on the\n'
                 'dictionary’s entries, which means that when the dictionary '
                 'changes,\n'
                 'the view reflects these changes.\n'
                 '\n'
                 'Dictionary views can be iterated over to yield their '
                 'respective data,\n'
                 'and support membership tests:\n'
                 '\n'
                 'len(dictview)\n'
                 '\n'
                 '   Return the number of entries in the dictionary.\n'
                 '\n'
                 'iter(dictview)\n'
                 '\n'
                 '   Return an iterator over the keys, values or items '
                 '(represented as\n'
                 '   tuples of "(key, value)") in the dictionary.\n'
                 '\n'
                 '   Keys and values are iterated over in insertion order. '
                 'This allows\n'
                 '   the creation of "(value, key)" pairs using "zip()": '
                 '"pairs =\n'
                 '   zip(d.values(), d.keys())".  Another way to create the '
                 'same list is\n'
                 '   "pairs = [(v, k) for (k, v) in d.items()]".\n'
                 '\n'
                 '   Iterating views while adding or deleting entries in the '
                 'dictionary\n'
                 '   may raise a "RuntimeError" or fail to iterate over all '
                 'entries.\n'
                 '\n'
                 '   Changed in version 3.7: Dictionary order is guaranteed to '
                 'be\n'
                 '   insertion order.\n'
                 '\n'
                 'x in dictview\n'
                 '\n'
                 '   Return "True" if *x* is in the underlying dictionary’s '
                 'keys, values\n'
                 '   or items (in the latter case, *x* should be a "(key, '
                 'value)"\n'
                 '   tuple).\n'
                 '\n'
                 'reversed(dictview)\n'
                 '\n'
                 '   Return a reverse iterator over the keys, values or items '
                 'of the\n'
                 '   dictionary. The view will be iterated in reverse order of '
                 'the\n'
                 '   insertion.\n'
                 '\n'
                 '   Changed in version 3.8: Dictionary views are now '
                 'reversible.\n'
                 '\n'
                 'dictview.mapping\n'
                 '\n'
                 '   Return a "types.MappingProxyType" that wraps the '
                 'original\n'
                 '   dictionary to which the view refers.\n'
                 '\n'
                 '   New in version 3.10.\n'
                 '\n'
                 'Keys views are set-like since their entries are unique and '
                 'hashable.\n'
                 'If all values are hashable, so that "(key, value)" pairs are '
                 'unique\n'
                 'and hashable, then the items view is also set-like.  (Values '
                 'views are\n'
                 'not treated as set-like since the entries are generally not '
                 'unique.)\n'
                 'For set-like views, all of the operations defined for the '
                 'abstract\n'
                 'base class "collections.abc.Set" are available (for example, '
                 '"==",\n'
                 '"<", or "^").\n'
                 '\n'
                 'An example of dictionary view usage:\n'
                 '\n'
                 "   >>> dishes = {'eggs': 2, 'sausage': 1, 'bacon': 1, "
                 "'spam': 500}\n"
                 '   >>> keys = dishes.keys()\n'
                 '   >>> values = dishes.values()\n'
                 '\n'
                 '   >>> # iteration\n'
                 '   >>> n = 0\n'
                 '   >>> for val in values:\n'
                 '   ...     n += val\n'
                 '   >>> print(n)\n'
                 '   504\n'
                 '\n'
                 '   >>> # keys and values are iterated over in the same order '
                 '(insertion order)\n'
                 '   >>> list(keys)\n'
                 "   ['eggs', 'sausage', 'bacon', 'spam']\n"
                 '   >>> list(values)\n'
                 '   [2, 1, 1, 500]\n'
                 '\n'
                 '   >>> # view objects are dynamic and reflect dict changes\n'
                 "   >>> del dishes['eggs']\n"
                 "   >>> del dishes['sausage']\n"
                 '   >>> list(keys)\n'
                 "   ['bacon', 'spam']\n"
                 '\n'
                 '   >>> # set operations\n'
                 "   >>> keys & {'eggs', 'bacon', 'salad'}\n"
                 "   {'bacon'}\n"
                 "   >>> keys ^ {'sausage', 'juice'}\n"
                 "   {'juice', 'sausage', 'bacon', 'spam'}\n"
                 '\n'
                 '   >>> # get back a read-only proxy for the original '
                 'dictionary\n'
                 '   >>> values.mapping\n'
                 "   mappingproxy({'bacon': 1, 'spam': 500})\n"
                 "   >>> values.mapping['spam']\n"
                 '   500\n',
 'typesmethods': 'Methods\n'
                 '*******\n'
                 '\n'
                 'Methods are functions that are called using the attribute '
                 'notation.\n'
                 'There are two flavors: built-in methods (such as "append()" '
                 'on lists)\n'
                 'and class instance methods.  Built-in methods are described '
                 'with the\n'
                 'types that support them.\n'
                 '\n'
                 'If you access a method (a function defined in a class '
                 'namespace)\n'
                 'through an instance, you get a special object: a *bound '
                 'method* (also\n'
                 'called *instance method*) object. When called, it will add '
                 'the "self"\n'
                 'argument to the argument list.  Bound methods have two '
                 'special read-\n'
                 'only attributes: "m.__self__" is the object on which the '
                 'method\n'
                 'operates, and "m.__func__" is the function implementing the '
                 'method.\n'
                 'Calling "m(arg-1, arg-2, ..., arg-n)" is completely '
                 'equivalent to\n'
                 'calling "m.__func__(m.__self__, arg-1, arg-2, ..., arg-n)".\n'
                 '\n'
                 'Like function objects, bound method objects support getting '
                 'arbitrary\n'
                 'attributes.  However, since method attributes are actually '
                 'stored on\n'
                 'the underlying function object ("meth.__func__"), setting '
                 'method\n'
                 'attributes on bound methods is disallowed.  Attempting to '
                 'set an\n'
                 'attribute on a method results in an "AttributeError" being '
                 'raised.  In\n'
                 'order to set a method attribute, you need to explicitly set '
                 'it on the\n'
                 'underlying function object:\n'
                 '\n'
                 '   >>> class C:\n'
                 '   ...     def method(self):\n'
                 '   ...         pass\n'
                 '   ...\n'
                 '   >>> c = C()\n'
                 "   >>> c.method.whoami = 'my name is method'  # can't set on "
                 'the method\n'
                 '   Traceback (most recent call last):\n'
                 '     File "<stdin>", line 1, in <module>\n'
                 "   AttributeError: 'method' object has no attribute "
                 "'whoami'\n"
                 "   >>> c.method.__func__.whoami = 'my name is method'\n"
                 '   >>> c.method.whoami\n'
                 "   'my name is method'\n"
                 '\n'
                 'See The standard type hierarchy for more information.\n',
 'typesmodules': 'Modules\n'
                 '*******\n'
                 '\n'
                 'The only special operation on a module is attribute access: '
                 '"m.name",\n'
                 'where *m* is a module and *name* accesses a name defined in '
                 '*m*’s\n'
                 'symbol table. Module attributes can be assigned to.  (Note '
                 'that the\n'
                 '"import" statement is not, strictly speaking, an operation '
                 'on a module\n'
                 'object; "import foo" does not require a module object named '
                 '*foo* to\n'
                 'exist, rather it requires an (external) *definition* for a '
                 'module\n'
                 'named *foo* somewhere.)\n'
                 '\n'
                 'A special attribute of every module is "__dict__". This is '
                 'the\n'
                 'dictionary containing the module’s symbol table. Modifying '
                 'this\n'
                 'dictionary will actually change the module’s symbol table, '
                 'but direct\n'
                 'assignment to the "__dict__" attribute is not possible (you '
                 'can write\n'
                 '"m.__dict__[\'a\'] = 1", which defines "m.a" to be "1", but '
                 'you can’t\n'
                 'write "m.__dict__ = {}").  Modifying "__dict__" directly is '
                 'not\n'
                 'recommended.\n'
                 '\n'
                 'Modules built into the interpreter are written like this: '
                 '"<module\n'
                 '\'sys\' (built-in)>".  If loaded from a file, they are '
                 'written as\n'
                 '"<module \'os\' from '
                 '\'/usr/local/lib/pythonX.Y/os.pyc\'>".\n',
 'typesseq': 'Sequence Types — "list", "tuple", "range"\n'
             '*****************************************\n'
             '\n'
             'There are three basic sequence types: lists, tuples, and range\n'
             'objects. Additional sequence types tailored for processing of '
             'binary\n'
             'data and text strings are described in dedicated sections.\n'
             '\n'
             '\n'
             'Common Sequence Operations\n'
             '==========================\n'
             '\n'
             'The operations in the following table are supported by most '
             'sequence\n'
             'types, both mutable and immutable. The '
             '"collections.abc.Sequence" ABC\n'
             'is provided to make it easier to correctly implement these '
             'operations\n'
             'on custom sequence types.\n'
             '\n'
             'This table lists the sequence operations sorted in ascending '
             'priority.\n'
             'In the table, *s* and *t* are sequences of the same type, *n*, '
             '*i*,\n'
             '*j* and *k* are integers and *x* is an arbitrary object that '
             'meets any\n'
             'type and value restrictions imposed by *s*.\n'
             '\n'
             'The "in" and "not in" operations have the same priorities as '
             'the\n'
             'comparison operations. The "+" (concatenation) and "*" '
             '(repetition)\n'
             'operations have the same priority as the corresponding numeric\n'
             'operations. [3]\n'
             '\n'
             '+----------------------------+----------------------------------+------------+\n'
             '| Operation                  | Result                           '
             '| Notes      |\n'
             '|============================|==================================|============|\n'
             '| "x in s"                   | "True" if an item of *s* is      '
             '| (1)        |\n'
             '|                            | equal to *x*, else "False"       '
             '|            |\n'
             '+----------------------------+----------------------------------+------------+\n'
             '| "x not in s"               | "False" if an item of *s* is     '
             '| (1)        |\n'
             '|                            | equal to *x*, else "True"        '
             '|            |\n'
             '+----------------------------+----------------------------------+------------+\n'
             '| "s + t"                    | the concatenation of *s* and *t* '
             '| (6)(7)     |\n'
             '+----------------------------+----------------------------------+------------+\n'
             '| "s * n" or "n * s"         | equivalent to adding *s* to      '
             '| (2)(7)     |\n'
             '|                            | itself *n* times                 '
             '|            |\n'
             '+----------------------------+----------------------------------+------------+\n'
             '| "s[i]"                     | *i*th item of *s*, origin 0      '
             '| (3)        |\n'
             '+----------------------------+----------------------------------+------------+\n'
             '| "s[i:j]"                   | slice of *s* from *i* to *j*     '
             '| (3)(4)     |\n'
             '+----------------------------+----------------------------------+------------+\n'
             '| "s[i:j:k]"                 | slice of *s* from *i* to *j*     '
             '| (3)(5)     |\n'
             '|                            | with step *k*                    '
             '|            |\n'
             '+----------------------------+----------------------------------+------------+\n'
             '| "len(s)"                   | length of *s*                    '
             '|            |\n'
             '+----------------------------+----------------------------------+------------+\n'
             '| "min(s)"                   | smallest item of *s*             '
             '|            |\n'
             '+----------------------------+----------------------------------+------------+\n'
             '| "max(s)"                   | largest item of *s*              '
             '|            |\n'
             '+----------------------------+----------------------------------+------------+\n'
             '| "s.index(x[, i[, j]])"     | index of the first occurrence of '
             '| (8)        |\n'
             '|                            | *x* in *s* (at or after index    '
             '|            |\n'
             '|                            | *i* and before index *j*)        '
             '|            |\n'
             '+----------------------------+----------------------------------+------------+\n'
             '| "s.count(x)"               | total number of occurrences of   '
             '|            |\n'
             '|                            | *x* in *s*                       '
             '|            |\n'
             '+----------------------------+----------------------------------+------------+\n'
             '\n'
             'Sequences of the same type also support comparisons.  In '
             'particular,\n'
             'tuples and lists are compared lexicographically by comparing\n'
             'corresponding elements. This means that to compare equal, every\n'
             'element must compare equal and the two sequences must be of the '
             'same\n'
             'type and have the same length.  (For full details see '
             'Comparisons in\n'
             'the language reference.)\n'
             '\n'
             'Forward and reversed iterators over mutable sequences access '
             'values\n'
             'using an index.  That index will continue to march forward (or\n'
             'backward) even if the underlying sequence is mutated.  The '
             'iterator\n'
             'terminates only when an "IndexError" or a "StopIteration" is\n'
             'encountered (or when the index drops below zero).\n'
             '\n'
             'Notes:\n'
             '\n'
             '1. While the "in" and "not in" operations are used only for '
             'simple\n'
             '   containment testing in the general case, some specialised '
             'sequences\n'
             '   (such as "str", "bytes" and "bytearray") also use them for\n'
             '   subsequence testing:\n'
             '\n'
             '      >>> "gg" in "eggs"\n'
             '      True\n'
             '\n'
             '2. Values of *n* less than "0" are treated as "0" (which yields '
             'an\n'
             '   empty sequence of the same type as *s*).  Note that items in '
             'the\n'
             '   sequence *s* are not copied; they are referenced multiple '
             'times.\n'
             '   This often haunts new Python programmers; consider:\n'
             '\n'
             '      >>> lists = [[]] * 3\n'
             '      >>> lists\n'
             '      [[], [], []]\n'
             '      >>> lists[0].append(3)\n'
             '      >>> lists\n'
             '      [[3], [3], [3]]\n'
             '\n'
             '   What has happened is that "[[]]" is a one-element list '
             'containing\n'
             '   an empty list, so all three elements of "[[]] * 3" are '
             'references\n'
             '   to this single empty list.  Modifying any of the elements of\n'
             '   "lists" modifies this single list. You can create a list of\n'
             '   different lists this way:\n'
             '\n'
             '      >>> lists = [[] for i in range(3)]\n'
             '      >>> lists[0].append(3)\n'
             '      >>> lists[1].append(5)\n'
             '      >>> lists[2].append(7)\n'
             '      >>> lists\n'
             '      [[3], [5], [7]]\n'
             '\n'
             '   Further explanation is available in the FAQ entry How do I '
             'create a\n'
             '   multidimensional list?.\n'
             '\n'
             '3. If *i* or *j* is negative, the index is relative to the end '
             'of\n'
             '   sequence *s*: "len(s) + i" or "len(s) + j" is substituted.  '
             'But\n'
             '   note that "-0" is still "0".\n'
             '\n'
             '4. The slice of *s* from *i* to *j* is defined as the sequence '
             'of\n'
             '   items with index *k* such that "i <= k < j".  If *i* or *j* '
             'is\n'
             '   greater than "len(s)", use "len(s)".  If *i* is omitted or '
             '"None",\n'
             '   use "0".  If *j* is omitted or "None", use "len(s)".  If *i* '
             'is\n'
             '   greater than or equal to *j*, the slice is empty.\n'
             '\n'
             '5. The slice of *s* from *i* to *j* with step *k* is defined as '
             'the\n'
             '   sequence of items with index  "x = i + n*k" such that "0 <= n '
             '<\n'
             '   (j-i)/k".  In other words, the indices are "i", "i+k", '
             '"i+2*k",\n'
             '   "i+3*k" and so on, stopping when *j* is reached (but never\n'
             '   including *j*).  When *k* is positive, *i* and *j* are '
             'reduced to\n'
             '   "len(s)" if they are greater. When *k* is negative, *i* and '
             '*j* are\n'
             '   reduced to "len(s) - 1" if they are greater.  If *i* or *j* '
             'are\n'
             '   omitted or "None", they become “end” values (which end '
             'depends on\n'
             '   the sign of *k*).  Note, *k* cannot be zero. If *k* is '
             '"None", it\n'
             '   is treated like "1".\n'
             '\n'
             '6. Concatenating immutable sequences always results in a new '
             'object.\n'
             '   This means that building up a sequence by repeated '
             'concatenation\n'
             '   will have a quadratic runtime cost in the total sequence '
             'length.\n'
             '   To get a linear runtime cost, you must switch to one of the\n'
             '   alternatives below:\n'
             '\n'
             '   * if concatenating "str" objects, you can build a list and '
             'use\n'
             '     "str.join()" at the end or else write to an "io.StringIO"\n'
             '     instance and retrieve its value when complete\n'
             '\n'
             '   * if concatenating "bytes" objects, you can similarly use\n'
             '     "bytes.join()" or "io.BytesIO", or you can do in-place\n'
             '     concatenation with a "bytearray" object.  "bytearray" '
             'objects are\n'
             '     mutable and have an efficient overallocation mechanism\n'
             '\n'
             '   * if concatenating "tuple" objects, extend a "list" instead\n'
             '\n'
             '   * for other types, investigate the relevant class '
             'documentation\n'
             '\n'
             '7. Some sequence types (such as "range") only support item '
             'sequences\n'
             '   that follow specific patterns, and hence don’t support '
             'sequence\n'
             '   concatenation or repetition.\n'
             '\n'
             '8. "index" raises "ValueError" when *x* is not found in *s*. Not '
             'all\n'
             '   implementations support passing the additional arguments *i* '
             'and\n'
             '   *j*. These arguments allow efficient searching of subsections '
             'of\n'
             '   the sequence. Passing the extra arguments is roughly '
             'equivalent to\n'
             '   using "s[i:j].index(x)", only without copying any data and '
             'with the\n'
             '   returned index being relative to the start of the sequence '
             'rather\n'
             '   than the start of the slice.\n'
             '\n'
             '\n'
             'Immutable Sequence Types\n'
             '========================\n'
             '\n'
             'The only operation that immutable sequence types generally '
             'implement\n'
             'that is not also implemented by mutable sequence types is '
             'support for\n'
             'the "hash()" built-in.\n'
             '\n'
             'This support allows immutable sequences, such as "tuple" '
             'instances, to\n'
             'be used as "dict" keys and stored in "set" and "frozenset" '
             'instances.\n'
             '\n'
             'Attempting to hash an immutable sequence that contains '
             'unhashable\n'
             'values will result in "TypeError".\n'
             '\n'
             '\n'
             'Mutable Sequence Types\n'
             '======================\n'
             '\n'
             'The operations in the following table are defined on mutable '
             'sequence\n'
             'types. The "collections.abc.MutableSequence" ABC is provided to '
             'make\n'
             'it easier to correctly implement these operations on custom '
             'sequence\n'
             'types.\n'
             '\n'
             'In the table *s* is an instance of a mutable sequence type, *t* '
             'is any\n'
             'iterable object and *x* is an arbitrary object that meets any '
             'type and\n'
             'value restrictions imposed by *s* (for example, "bytearray" '
             'only\n'
             'accepts integers that meet the value restriction "0 <= x <= '
