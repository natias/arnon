#define PERL_ARGS_ASSERT_MAGIC_GETPOS	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_getsig(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_GETSIG	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_getsubstr(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_GETSUBSTR	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_gettaint(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_GETTAINT	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_getuvar(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_GETUVAR	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_getvec(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_GETVEC	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_killbackrefs(pTHX_ SV *sv, MAGIC *mg);
#define PERL_ARGS_ASSERT_MAGIC_KILLBACKREFS	\
	assert(sv); assert(mg)
PERL_CALLCONV SV*	Perl_magic_methcall(pTHX_ SV *sv, const MAGIC *mg, SV *meth, U32 flags, U32 argc, ...);
#define PERL_ARGS_ASSERT_MAGIC_METHCALL	\
	assert(sv); assert(mg); assert(meth)
PERL_CALLCONV int	Perl_magic_nextpack(pTHX_ SV *sv, MAGIC *mg, SV *key);
#define PERL_ARGS_ASSERT_MAGIC_NEXTPACK	\
	assert(sv); assert(mg); assert(key)
PERL_CALLCONV U32	Perl_magic_regdata_cnt(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_REGDATA_CNT	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_regdatum_get(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_REGDATUM_GET	\
	assert(sv); assert(mg)
PERL_CALLCONV SV*	Perl_magic_scalarpack(pTHX_ HV *hv, MAGIC *mg);
#define PERL_ARGS_ASSERT_MAGIC_SCALARPACK	\
	assert(hv); assert(mg)
PERL_CALLCONV int	Perl_magic_set(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SET	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_set_all_env(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SET_ALL_ENV	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setarylen(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETARYLEN	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setdbline(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETDBLINE	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setdebugvar(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETDEBUGVAR	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setdefelem(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETDEFELEM	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setenv(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETENV	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_sethint(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETHINT	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setisa(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETISA	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setlvref(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETLVREF	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setmglob(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETMGLOB	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setnkeys(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETNKEYS	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setnonelem(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETNONELEM	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setpack(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETPACK	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setpos(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETPOS	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setregexp(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETREGEXP	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setsig(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETSIG	\
	assert(mg)
PERL_CALLCONV int	Perl_magic_setsigall(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETSIGALL	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setsubstr(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETSUBSTR	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_settaint(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETTAINT	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setutf8(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETUTF8	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setuvar(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETUVAR	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_setvec(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SETVEC	\
	assert(sv); assert(mg)
PERL_CALLCONV U32	Perl_magic_sizepack(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_SIZEPACK	\
	assert(sv); assert(mg)
PERL_CALLCONV int	Perl_magic_wipepack(pTHX_ SV* sv, MAGIC* mg);
#define PERL_ARGS_ASSERT_MAGIC_WIPEPACK	\
	assert(sv); assert(mg)
PERL_CALLCONV Malloc_t	Perl_malloc(MEM_SIZE nbytes)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_MALLOC

PERL_CALLCONV I32 *	Perl_markstack_grow(pTHX);
#define PERL_ARGS_ASSERT_MARKSTACK_GROW
PERL_CALLCONV SV*	Perl_mess(pTHX_ const char* pat, ...)
			__attribute__format__(__printf__,pTHX_1,pTHX_2);
#define PERL_ARGS_ASSERT_MESS	\
	assert(pat)

PERL_CALLCONV SV*	Perl_mess_sv(pTHX_ SV* basemsg, bool consume);
#define PERL_ARGS_ASSERT_MESS_SV	\
	assert(basemsg)
PERL_CALLCONV Free_t	Perl_mfree(Malloc_t where);
#define PERL_ARGS_ASSERT_MFREE
PERL_CALLCONV int	Perl_mg_clear(pTHX_ SV* sv);
#define PERL_ARGS_ASSERT_MG_CLEAR	\
	assert(sv)
PERL_CALLCONV int	Perl_mg_copy(pTHX_ SV *sv, SV *nsv, const char *key, I32 klen);
#define PERL_ARGS_ASSERT_MG_COPY	\
	assert(sv); assert(nsv)
PERL_CALLCONV MAGIC*	Perl_mg_find(const SV* sv, int type)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_MG_FIND

PERL_CALLCONV MAGIC*	Perl_mg_find_mglob(pTHX_ SV* sv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_MG_FIND_MGLOB	\
	assert(sv)

PERL_CALLCONV MAGIC*	Perl_mg_findext(const SV* sv, int type, const MGVTBL *vtbl)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_MG_FINDEXT

PERL_CALLCONV int	Perl_mg_free(pTHX_ SV* sv);
#define PERL_ARGS_ASSERT_MG_FREE	\
	assert(sv)
PERL_CALLCONV void	Perl_mg_free_type(pTHX_ SV* sv, int how);
#define PERL_ARGS_ASSERT_MG_FREE_TYPE	\
	assert(sv)
PERL_CALLCONV void	Perl_mg_freeext(pTHX_ SV* sv, int how, const MGVTBL *vtbl);
#define PERL_ARGS_ASSERT_MG_FREEEXT	\
	assert(sv)
PERL_CALLCONV int	Perl_mg_get(pTHX_ SV* sv);
#define PERL_ARGS_ASSERT_MG_GET	\
	assert(sv)
PERL_CALLCONV U32	Perl_mg_length(pTHX_ SV* sv)
			__attribute__deprecated__;
#define PERL_ARGS_ASSERT_MG_LENGTH	\
	assert(sv)

PERL_CALLCONV void	Perl_mg_localize(pTHX_ SV* sv, SV* nsv, bool setmagic);
#define PERL_ARGS_ASSERT_MG_LOCALIZE	\
	assert(sv); assert(nsv)
PERL_CALLCONV void	Perl_mg_magical(SV* sv);
#define PERL_ARGS_ASSERT_MG_MAGICAL	\
	assert(sv)
PERL_CALLCONV int	Perl_mg_set(pTHX_ SV* sv);
#define PERL_ARGS_ASSERT_MG_SET	\
	assert(sv)
PERL_CALLCONV I32	Perl_mg_size(pTHX_ SV* sv);
#define PERL_ARGS_ASSERT_MG_SIZE	\
	assert(sv)
PERL_CALLCONV void	Perl_mini_mktime(struct tm *ptm);
#define PERL_ARGS_ASSERT_MINI_MKTIME	\
	assert(ptm)
PERL_CALLCONV int	Perl_mode_from_discipline(pTHX_ const char* s, STRLEN len);
#define PERL_ARGS_ASSERT_MODE_FROM_DISCIPLINE
PERL_CALLCONV void *	Perl_more_bodies(pTHX_ const svtype sv_type, const size_t body_size, const size_t arena_size);
#define PERL_ARGS_ASSERT_MORE_BODIES
PERL_CALLCONV const char*	Perl_moreswitches(pTHX_ const char* s);
#define PERL_ARGS_ASSERT_MORESWITCHES	\
	assert(s)
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE char *	Perl_mortal_getenv(const char * str)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_MORTAL_GETENV	\
	assert(str)
#endif

PERL_CALLCONV const struct mro_alg *	Perl_mro_get_from_name(pTHX_ SV *name);
#define PERL_ARGS_ASSERT_MRO_GET_FROM_NAME	\
	assert(name)
PERL_CALLCONV AV*	Perl_mro_get_linear_isa(pTHX_ HV* stash);
#define PERL_ARGS_ASSERT_MRO_GET_LINEAR_ISA	\
	assert(stash)
PERL_CALLCONV SV*	Perl_mro_get_private_data(pTHX_ struct mro_meta *const smeta, const struct mro_alg *const which);
#define PERL_ARGS_ASSERT_MRO_GET_PRIVATE_DATA	\
	assert(smeta); assert(which)
PERL_CALLCONV void	Perl_mro_isa_changed_in(pTHX_ HV* stash);
#define PERL_ARGS_ASSERT_MRO_ISA_CHANGED_IN	\
	assert(stash)
PERL_CALLCONV struct mro_meta*	Perl_mro_meta_init(pTHX_ HV* stash);
#define PERL_ARGS_ASSERT_MRO_META_INIT	\
	assert(stash)
PERL_CALLCONV void	Perl_mro_method_changed_in(pTHX_ HV* stash);
#define PERL_ARGS_ASSERT_MRO_METHOD_CHANGED_IN	\
	assert(stash)
PERL_CALLCONV void	Perl_mro_package_moved(pTHX_ HV * const stash, HV * const oldstash, const GV * const gv, U32 flags);
#define PERL_ARGS_ASSERT_MRO_PACKAGE_MOVED	\
	assert(gv)
PERL_CALLCONV void	Perl_mro_register(pTHX_ const struct mro_alg *mro);
#define PERL_ARGS_ASSERT_MRO_REGISTER	\
	assert(mro)
PERL_CALLCONV void	Perl_mro_set_mro(pTHX_ struct mro_meta *const meta, SV *const name);
#define PERL_ARGS_ASSERT_MRO_SET_MRO	\
	assert(meta); assert(name)
PERL_CALLCONV SV*	Perl_mro_set_private_data(pTHX_ struct mro_meta *const smeta, const struct mro_alg *const which, SV *const data);
#define PERL_ARGS_ASSERT_MRO_SET_PRIVATE_DATA	\
	assert(smeta); assert(which); assert(data)
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE unsigned	Perl_msbit_pos32(U32 word)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_MSBIT_POS32
#endif

PERL_CALLCONV SV*	Perl_multiconcat_stringify(pTHX_ const OP* o);
#define PERL_ARGS_ASSERT_MULTICONCAT_STRINGIFY	\
	assert(o)
PERL_CALLCONV SV*	Perl_multideref_stringify(pTHX_ const OP* o, CV *cv);
#define PERL_ARGS_ASSERT_MULTIDEREF_STRINGIFY	\
	assert(o)
PERL_CALLCONV NV	Perl_my_atof(pTHX_ const char *s);
#define PERL_ARGS_ASSERT_MY_ATOF	\
	assert(s)
PERL_CALLCONV char*	Perl_my_atof2(pTHX_ const char *orig, NV* value);
#define PERL_ARGS_ASSERT_MY_ATOF2	\
	assert(orig); assert(value)
PERL_CALLCONV char*	Perl_my_atof3(pTHX_ const char *orig, NV* value, const STRLEN len);
#define PERL_ARGS_ASSERT_MY_ATOF3	\
	assert(orig); assert(value)
PERL_CALLCONV OP *	Perl_my_attrs(pTHX_ OP *o, OP *attrs);
#define PERL_ARGS_ASSERT_MY_ATTRS	\
	assert(o)
PERL_CALLCONV void	Perl_my_clearenv(pTHX);
#define PERL_ARGS_ASSERT_MY_CLEARENV
PERL_CALLCONV int	Perl_my_dirfd(DIR* dir);
#define PERL_ARGS_ASSERT_MY_DIRFD
PERL_CALLCONV_NO_RET void	Perl_my_exit(pTHX_ U32 status)
			__attribute__noreturn__;
#define PERL_ARGS_ASSERT_MY_EXIT

PERL_CALLCONV_NO_RET void	Perl_my_failure_exit(pTHX)
			__attribute__noreturn__;
#define PERL_ARGS_ASSERT_MY_FAILURE_EXIT

PERL_CALLCONV I32	Perl_my_fflush_all(pTHX);
#define PERL_ARGS_ASSERT_MY_FFLUSH_ALL
PERL_CALLCONV Pid_t	Perl_my_fork(void);
#define PERL_ARGS_ASSERT_MY_FORK
/* PERL_CALLCONV I32	my_lstat(pTHX); */
#define PERL_ARGS_ASSERT_MY_LSTAT
PERL_CALLCONV I32	Perl_my_lstat_flags(pTHX_ const U32 flags);
#define PERL_ARGS_ASSERT_MY_LSTAT_FLAGS
PERL_CALLCONV int	Perl_my_mkostemp_cloexec(char *templte, int flags)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_MY_MKOSTEMP_CLOEXEC	\
	assert(templte)

PERL_CALLCONV int	Perl_my_mkstemp_cloexec(char *templte)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_MY_MKSTEMP_CLOEXEC	\
	assert(templte)

PERL_CALLCONV PerlIO*	Perl_my_popen_list(pTHX_ const char* mode, int n, SV ** args);
#define PERL_ARGS_ASSERT_MY_POPEN_LIST	\
	assert(mode); assert(args)
PERL_CALLCONV void	Perl_my_setenv(pTHX_ const char* nam, const char* val);
#define PERL_ARGS_ASSERT_MY_SETENV
PERL_CALLCONV int	Perl_my_snprintf(char *buffer, const Size_t len, const char *format, ...)
			__attribute__format__(__printf__,3,4);
#define PERL_ARGS_ASSERT_MY_SNPRINTF	\
	assert(buffer); assert(format)

PERL_CALLCONV int	Perl_my_socketpair(int family, int type, int protocol, int fd[2]);
#define PERL_ARGS_ASSERT_MY_SOCKETPAIR
/* PERL_CALLCONV I32	my_stat(pTHX); */
#define PERL_ARGS_ASSERT_MY_STAT
PERL_CALLCONV I32	Perl_my_stat_flags(pTHX_ const U32 flags);
#define PERL_ARGS_ASSERT_MY_STAT_FLAGS
PERL_CALLCONV char*	Perl_my_strerror(pTHX_ const int errnum);
#define PERL_ARGS_ASSERT_MY_STRERROR
PERL_CALLCONV char *	Perl_my_strftime(pTHX_ const char *fmt, int sec, int min, int hour, int mday, int mon, int year, int wday, int yday, int isdst)
			__attribute__format__(__strftime__,pTHX_1,0);
#define PERL_ARGS_ASSERT_MY_STRFTIME	\
	assert(fmt)

PERL_CALLCONV NV	Perl_my_strtod(const char * const s, char ** e)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_MY_STRTOD	\
	assert(s)

PERL_CALLCONV void	Perl_my_unexec(pTHX);
#define PERL_ARGS_ASSERT_MY_UNEXEC
PERL_CALLCONV int	Perl_my_vsnprintf(char *buffer, const Size_t len, const char *format, va_list ap);
#define PERL_ARGS_ASSERT_MY_VSNPRINTF	\
	assert(buffer); assert(format)
PERL_CALLCONV OP*	Perl_newANONATTRSUB(pTHX_ I32 floor, OP *proto, OP *attrs, OP *block);
#define PERL_ARGS_ASSERT_NEWANONATTRSUB
PERL_CALLCONV OP*	Perl_newANONHASH(pTHX_ OP* o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWANONHASH

PERL_CALLCONV OP*	Perl_newANONLIST(pTHX_ OP* o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWANONLIST

PERL_CALLCONV OP*	Perl_newANONSUB(pTHX_ I32 floor, OP* proto, OP* block);
#define PERL_ARGS_ASSERT_NEWANONSUB
PERL_CALLCONV OP*	Perl_newASSIGNOP(pTHX_ I32 flags, OP* left, I32 optype, OP* right)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWASSIGNOP

/* PERL_CALLCONV CV*	newATTRSUB(pTHX_ I32 floor, OP *o, OP *proto, OP *attrs, OP *block); */
#define PERL_ARGS_ASSERT_NEWATTRSUB
PERL_CALLCONV CV*	Perl_newATTRSUB_x(pTHX_ I32 floor, OP *o, OP *proto, OP *attrs, OP *block, bool o_is_gv);
#define PERL_ARGS_ASSERT_NEWATTRSUB_X
#ifndef NO_MATHOMS
PERL_CALLCONV AV*	Perl_newAV(pTHX)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWAV
#endif

PERL_CALLCONV OP*	Perl_newAVREF(pTHX_ OP* o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWAVREF	\
	assert(o)

/* PERL_CALLCONV AV*	newAV_alloc_x(pTHX_ SSize_t size)
			__attribute__warn_unused_result__; */
#define PERL_ARGS_ASSERT_NEWAV_ALLOC_X

/* PERL_CALLCONV AV*	newAV_alloc_xz(pTHX_ SSize_t size)
			__attribute__warn_unused_result__; */
#define PERL_ARGS_ASSERT_NEWAV_ALLOC_XZ

PERL_CALLCONV OP*	Perl_newBINOP(pTHX_ I32 type, I32 flags, OP* first, OP* last)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWBINOP

PERL_CALLCONV OP*	Perl_newCONDOP(pTHX_ I32 flags, OP* first, OP* trueop, OP* falseop)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWCONDOP	\
	assert(first)

PERL_CALLCONV CV*	Perl_newCONSTSUB(pTHX_ HV* stash, const char* name, SV* sv);
#define PERL_ARGS_ASSERT_NEWCONSTSUB
PERL_CALLCONV CV*	Perl_newCONSTSUB_flags(pTHX_ HV* stash, const char* name, STRLEN len, U32 flags, SV* sv);
#define PERL_ARGS_ASSERT_NEWCONSTSUB_FLAGS
PERL_CALLCONV OP*	Perl_newCVREF(pTHX_ I32 flags, OP* o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWCVREF

PERL_CALLCONV OP*	Perl_newDEFEROP(pTHX_ I32 flags, OP *block)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWDEFEROP	\
	assert(block)

PERL_CALLCONV OP*	Perl_newDEFSVOP(pTHX)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWDEFSVOP

PERL_CALLCONV void	Perl_newFORM(pTHX_ I32 floor, OP* o, OP* block);
#define PERL_ARGS_ASSERT_NEWFORM
PERL_CALLCONV OP*	Perl_newFOROP(pTHX_ I32 flags, OP* sv, OP* expr, OP* block, OP* cont)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWFOROP	\
	assert(expr)

PERL_CALLCONV OP*	Perl_newGIVENOP(pTHX_ OP* cond, OP* block, PADOFFSET defsv_off)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWGIVENOP	\
	assert(cond); assert(block)

PERL_CALLCONV GP *	Perl_newGP(pTHX_ GV *const gv);
#define PERL_ARGS_ASSERT_NEWGP	\
	assert(gv)
PERL_CALLCONV OP*	Perl_newGVOP(pTHX_ I32 type, I32 flags, GV* gv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWGVOP	\
	assert(gv)

PERL_CALLCONV OP*	Perl_newGVREF(pTHX_ I32 type, OP* o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWGVREF

/* PERL_CALLCONV GV*	newGVgen(pTHX_ const char* pack); */
#define PERL_ARGS_ASSERT_NEWGVGEN
PERL_CALLCONV GV*	Perl_newGVgen_flags(pTHX_ const char* pack, U32 flags)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWGVGEN_FLAGS	\
	assert(pack)

#ifndef NO_MATHOMS
PERL_CALLCONV HV*	Perl_newHV(pTHX)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWHV
#endif

PERL_CALLCONV OP*	Perl_newHVREF(pTHX_ OP* o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWHVREF	\
	assert(o)

PERL_CALLCONV HV*	Perl_newHVhv(pTHX_ HV *hv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWHVHV

#ifndef NO_MATHOMS
PERL_CALLCONV IO*	Perl_newIO(pTHX)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWIO
#endif

PERL_CALLCONV OP*	Perl_newLISTOP(pTHX_ I32 type, I32 flags, OP* first, OP* last)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWLISTOP

PERL_CALLCONV OP*	Perl_newLOGOP(pTHX_ I32 optype, I32 flags, OP *first, OP *other)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWLOGOP	\
	assert(first); assert(other)

PERL_CALLCONV OP*	Perl_newLOOPEX(pTHX_ I32 type, OP* label)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWLOOPEX	\
	assert(label)

PERL_CALLCONV OP*	Perl_newLOOPOP(pTHX_ I32 flags, I32 debuggable, OP* expr, OP* block)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWLOOPOP

PERL_CALLCONV OP*	Perl_newMETHOP(pTHX_ I32 type, I32 flags, OP* dynamic_meth)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWMETHOP	\
	assert(dynamic_meth)

PERL_CALLCONV OP*	Perl_newMETHOP_named(pTHX_ I32 type, I32 flags, SV* const_meth)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWMETHOP_NAMED	\
	assert(const_meth)

PERL_CALLCONV CV *	Perl_newMYSUB(pTHX_ I32 floor, OP *o, OP *proto, OP *attrs, OP *block);
#define PERL_ARGS_ASSERT_NEWMYSUB	\
	assert(o)
PERL_CALLCONV OP*	Perl_newNULLLIST(pTHX)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWNULLLIST

PERL_CALLCONV OP*	Perl_newOP(pTHX_ I32 optype, I32 flags)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWOP

PERL_CALLCONV PADNAMELIST *	Perl_newPADNAMELIST(size_t max)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWPADNAMELIST

PERL_CALLCONV PADNAME *	Perl_newPADNAMEouter(PADNAME *outer)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWPADNAMEOUTER	\
	assert(outer)

PERL_CALLCONV PADNAME *	Perl_newPADNAMEpvn(const char *s, STRLEN len)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWPADNAMEPVN	\
	assert(s)

PERL_CALLCONV OP*	Perl_newPMOP(pTHX_ I32 type, I32 flags)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWPMOP

PERL_CALLCONV void	Perl_newPROG(pTHX_ OP* o);
#define PERL_ARGS_ASSERT_NEWPROG	\
	assert(o)
PERL_CALLCONV OP*	Perl_newPVOP(pTHX_ I32 type, I32 flags, char* pv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWPVOP

PERL_CALLCONV OP*	Perl_newRANGE(pTHX_ I32 flags, OP* left, OP* right)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWRANGE	\
	assert(left); assert(right)

PERL_CALLCONV SV*	Perl_newRV(pTHX_ SV *const sv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWRV	\
	assert(sv)

PERL_CALLCONV SV*	Perl_newRV_noinc(pTHX_ SV *const tmpRef)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWRV_NOINC	\
	assert(tmpRef)

PERL_CALLCONV OP*	Perl_newSLICEOP(pTHX_ I32 flags, OP* subscript, OP* listop)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWSLICEOP

PERL_CALLCONV OP*	Perl_newSTATEOP(pTHX_ I32 flags, char* label, OP* o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWSTATEOP

PERL_CALLCONV CV*	Perl_newSTUB(pTHX_ GV *gv, bool fake);
#define PERL_ARGS_ASSERT_NEWSTUB	\
	assert(gv)
#ifndef NO_MATHOMS
PERL_CALLCONV CV*	Perl_newSUB(pTHX_ I32 floor, OP* o, OP* proto, OP* block);
#define PERL_ARGS_ASSERT_NEWSUB
#endif
PERL_CALLCONV SV*	Perl_newSV(pTHX_ const STRLEN len)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWSV

PERL_CALLCONV OP*	Perl_newSVOP(pTHX_ I32 type, I32 flags, SV* sv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWSVOP	\
	assert(sv)

PERL_CALLCONV OP*	Perl_newSVREF(pTHX_ OP* o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWSVREF	\
	assert(o)

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE SV*	Perl_newSV_type(pTHX_ const svtype type)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWSV_TYPE
#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_FORCE_INLINE SV*	Perl_newSV_type_mortal(pTHX_ const svtype type)
			__attribute__warn_unused_result__
			__attribute__always_inline__;
#define PERL_ARGS_ASSERT_NEWSV_TYPE_MORTAL
#endif

PERL_CALLCONV SV*	Perl_newSVavdefelem(pTHX_ AV *av, SSize_t ix, bool extendible)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWSVAVDEFELEM	\
	assert(av)

PERL_CALLCONV SV*	Perl_newSVhek(pTHX_ const HEK *const hek)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWSVHEK

PERL_CALLCONV SV*	Perl_newSViv(pTHX_ const IV i)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWSVIV

PERL_CALLCONV SV*	Perl_newSVnv(pTHX_ const NV n)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWSVNV

PERL_CALLCONV SV*	Perl_newSVpv(pTHX_ const char *const s, const STRLEN len)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWSVPV

PERL_CALLCONV SV*	Perl_newSVpv_share(pTHX_ const char* s, U32 hash)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWSVPV_SHARE

PERL_CALLCONV SV*	Perl_newSVpvf(pTHX_ const char *const pat, ...)
			__attribute__warn_unused_result__
			__attribute__format__(__printf__,pTHX_1,pTHX_2);
#define PERL_ARGS_ASSERT_NEWSVPVF	\
	assert(pat)

PERL_CALLCONV SV*	Perl_newSVpvn(pTHX_ const char *const buffer, const STRLEN len)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWSVPVN

PERL_CALLCONV SV*	Perl_newSVpvn_flags(pTHX_ const char *const s, const STRLEN len, const U32 flags)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWSVPVN_FLAGS

PERL_CALLCONV SV*	Perl_newSVpvn_share(pTHX_ const char* s, I32 len, U32 hash)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWSVPVN_SHARE

PERL_CALLCONV SV*	Perl_newSVrv(pTHX_ SV *const rv, const char *const classname);
#define PERL_ARGS_ASSERT_NEWSVRV	\
	assert(rv)
#ifndef NO_MATHOMS
PERL_CALLCONV SV*	Perl_newSVsv(pTHX_ SV *const old)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWSVSV
#endif

PERL_CALLCONV SV*	Perl_newSVsv_flags(pTHX_ SV *const old, I32 flags)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWSVSV_FLAGS

/* PERL_CALLCONV SV*	newSVsv_nomg(pTHX_ SV *const old)
			__attribute__warn_unused_result__; */
#define PERL_ARGS_ASSERT_NEWSVSV_NOMG

PERL_CALLCONV SV*	Perl_newSVuv(pTHX_ const UV u)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWSVUV

PERL_CALLCONV OP*	Perl_newTRYCATCHOP(pTHX_ I32 flags, OP* tryblock, OP *catchvar, OP* catchblock)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWTRYCATCHOP	\
	assert(tryblock); assert(catchvar); assert(catchblock)

PERL_CALLCONV OP*	Perl_newUNOP(pTHX_ I32 type, I32 flags, OP* first)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWUNOP

PERL_CALLCONV OP*	Perl_newUNOP_AUX(pTHX_ I32 type, I32 flags, OP* first, UNOP_AUX_item *aux)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWUNOP_AUX

PERL_CALLCONV OP*	Perl_newWHENOP(pTHX_ OP* cond, OP* block)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWWHENOP	\
	assert(block)

PERL_CALLCONV OP*	Perl_newWHILEOP(pTHX_ I32 flags, I32 debuggable, LOOP* loop, OP* expr, OP* block, OP* cont, I32 has_my)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWWHILEOP

PERL_CALLCONV CV*	Perl_newXS(pTHX_ const char *name, XSUBADDR_t subaddr, const char *filename);
#define PERL_ARGS_ASSERT_NEWXS	\
	assert(subaddr); assert(filename)
PERL_CALLCONV CV *	Perl_newXS_deffile(pTHX_ const char *name, XSUBADDR_t subaddr);
#define PERL_ARGS_ASSERT_NEWXS_DEFFILE	\
	assert(name); assert(subaddr)
PERL_CALLCONV CV *	Perl_newXS_flags(pTHX_ const char *name, XSUBADDR_t subaddr, const char *const filename, const char *const proto, U32 flags);
#define PERL_ARGS_ASSERT_NEWXS_FLAGS	\
	assert(subaddr); assert(filename)
PERL_CALLCONV CV *	Perl_newXS_len_flags(pTHX_ const char *name, STRLEN len, XSUBADDR_t subaddr, const char *const filename, const char *const proto, SV **const_svp, U32 flags);
#define PERL_ARGS_ASSERT_NEWXS_LEN_FLAGS	\
	assert(subaddr)
PERL_CALLCONV PERL_SI*	Perl_new_stackinfo(pTHX_ I32 stitems, I32 cxitems)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEW_STACKINFO

PERL_CALLCONV SV*	Perl_new_version(pTHX_ SV *ver);
#define PERL_ARGS_ASSERT_NEW_VERSION	\
	assert(ver)
PERL_CALLCONV STRLEN *	Perl_new_warnings_bitfield(pTHX_ STRLEN *buffer, const char *const bits, STRLEN size)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEW_WARNINGS_BITFIELD	\
	assert(bits)

PERL_CALLCONV PerlIO*	Perl_nextargv(pTHX_ GV* gv, bool nomagicopen);
#define PERL_ARGS_ASSERT_NEXTARGV	\
	assert(gv)
PERL_CALLCONV char*	Perl_ninstr(const char* big, const char* bigend, const char* little, const char* lend)
			__attribute__warn_unused_result__
			__attribute__pure__;
#define PERL_ARGS_ASSERT_NINSTR	\
	assert(big); assert(bigend); assert(little); assert(lend)

PERL_CALLCONV void	Perl_no_bareword_filehandle(pTHX_ const char *fhname);
#define PERL_ARGS_ASSERT_NO_BAREWORD_FILEHANDLE	\
	assert(fhname)
PERL_CALLCONV_NO_RET void	Perl_noperl_die(const char* pat, ...)
			__attribute__noreturn__
			__attribute__format__(__printf__,1,2);
#define PERL_ARGS_ASSERT_NOPERL_DIE	\
	assert(pat)

PERL_CALLCONV int	Perl_nothreadhook(pTHX);
#define PERL_ARGS_ASSERT_NOTHREADHOOK
PERL_CALLCONV void	Perl_notify_parser_that_changed_to_utf8(pTHX);
#define PERL_ARGS_ASSERT_NOTIFY_PARSER_THAT_CHANGED_TO_UTF8
PERL_CALLCONV OP*	Perl_oopsAV(pTHX_ OP* o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_OOPSAV	\
	assert(o)

PERL_CALLCONV OP*	Perl_oopsHV(pTHX_ OP* o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_OOPSHV	\
	assert(o)

PERL_CALLCONV OP*	Perl_op_append_elem(pTHX_ I32 optype, OP* first, OP* last);
#define PERL_ARGS_ASSERT_OP_APPEND_ELEM
PERL_CALLCONV OP*	Perl_op_append_list(pTHX_ I32 optype, OP* first, OP* last);
#define PERL_ARGS_ASSERT_OP_APPEND_LIST
PERL_CALLCONV OPclass	Perl_op_class(pTHX_ const OP *o);
#define PERL_ARGS_ASSERT_OP_CLASS
PERL_CALLCONV void	Perl_op_clear(pTHX_ OP* o);
#define PERL_ARGS_ASSERT_OP_CLEAR	\
	assert(o)
PERL_CALLCONV OP*	Perl_op_contextualize(pTHX_ OP* o, I32 context);
#define PERL_ARGS_ASSERT_OP_CONTEXTUALIZE	\
	assert(o)
PERL_CALLCONV OP*	Perl_op_convert_list(pTHX_ I32 optype, I32 flags, OP* o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_OP_CONVERT_LIST

PERL_CALLCONV void	Perl_op_dump(pTHX_ const OP *o);
#define PERL_ARGS_ASSERT_OP_DUMP	\
	assert(o)
PERL_CALLCONV void	Perl_op_free(pTHX_ OP* arg);
#define PERL_ARGS_ASSERT_OP_FREE
PERL_CALLCONV OP*	Perl_op_linklist(pTHX_ OP *o);
#define PERL_ARGS_ASSERT_OP_LINKLIST	\
	assert(o)
/* PERL_CALLCONV OP*	op_lvalue(pTHX_ OP* o, I32 type); */
#define PERL_ARGS_ASSERT_OP_LVALUE
PERL_CALLCONV OP*	Perl_op_lvalue_flags(pTHX_ OP* o, I32 type, U32 flags);
#define PERL_ARGS_ASSERT_OP_LVALUE_FLAGS
PERL_CALLCONV void	Perl_op_null(pTHX_ OP* o);
#define PERL_ARGS_ASSERT_OP_NULL	\
	assert(o)
PERL_CALLCONV OP*	Perl_op_parent(OP *o);
#define PERL_ARGS_ASSERT_OP_PARENT	\
	assert(o)
PERL_CALLCONV OP*	Perl_op_prepend_elem(pTHX_ I32 optype, OP* first, OP* last);
#define PERL_ARGS_ASSERT_OP_PREPEND_ELEM
PERL_CALLCONV void	Perl_op_refcnt_lock(pTHX);
#define PERL_ARGS_ASSERT_OP_REFCNT_LOCK
PERL_CALLCONV void	Perl_op_refcnt_unlock(pTHX);
#define PERL_ARGS_ASSERT_OP_REFCNT_UNLOCK
PERL_CALLCONV OP*	Perl_op_scope(pTHX_ OP* o);
#define PERL_ARGS_ASSERT_OP_SCOPE
PERL_CALLCONV OP*	Perl_op_sibling_splice(OP *parent, OP *start, int del_count, OP* insert);
#define PERL_ARGS_ASSERT_OP_SIBLING_SPLICE
PERL_CALLCONV OP*	Perl_op_unscope(pTHX_ OP* o);
#define PERL_ARGS_ASSERT_OP_UNSCOPE
PERL_CALLCONV OP*	Perl_op_wrap_finally(pTHX_ OP *block, OP *finally)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_OP_WRAP_FINALLY	\
	assert(block); assert(finally)

PERL_CALLCONV void	Perl_optimize_optree(pTHX_ OP* o);
#define PERL_ARGS_ASSERT_OPTIMIZE_OPTREE	\
	assert(o)
#ifndef NO_MATHOMS
PERL_CALLCONV void	Perl_pack_cat(pTHX_ SV *cat, const char *pat, const char *patend, SV **beglist, SV **endlist, SV ***next_in_list, U32 flags)
			__attribute__deprecated__;
#define PERL_ARGS_ASSERT_PACK_CAT	\
	assert(cat); assert(pat); assert(patend); assert(beglist); assert(endlist); assert(next_in_list)
#endif

PERL_CALLCONV void	Perl_package(pTHX_ OP* o);
#define PERL_ARGS_ASSERT_PACKAGE	\
	assert(o)
PERL_CALLCONV void	Perl_package_version(pTHX_ OP* v);
#define PERL_ARGS_ASSERT_PACKAGE_VERSION	\
	assert(v)
PERL_CALLCONV void	Perl_packlist(pTHX_ SV *cat, const char *pat, const char *patend, SV **beglist, SV **endlist);
#define PERL_ARGS_ASSERT_PACKLIST	\
	assert(cat); assert(pat); assert(patend); assert(beglist); assert(endlist)
PERL_CALLCONV PADOFFSET	Perl_pad_add_anon(pTHX_ CV* func, I32 optype);
#define PERL_ARGS_ASSERT_PAD_ADD_ANON	\
	assert(func)
PERL_CALLCONV PADOFFSET	Perl_pad_add_name_pv(pTHX_ const char *name, const U32 flags, HV *typestash, HV *ourstash);
#define PERL_ARGS_ASSERT_PAD_ADD_NAME_PV	\
	assert(name)
PERL_CALLCONV PADOFFSET	Perl_pad_add_name_pvn(pTHX_ const char *namepv, STRLEN namelen, U32 flags, HV *typestash, HV *ourstash);
#define PERL_ARGS_ASSERT_PAD_ADD_NAME_PVN	\
	assert(namepv)
PERL_CALLCONV PADOFFSET	Perl_pad_add_name_sv(pTHX_ SV *name, U32 flags, HV *typestash, HV *ourstash);
#define PERL_ARGS_ASSERT_PAD_ADD_NAME_SV	\
	assert(name)
PERL_CALLCONV void	Perl_pad_add_weakref(pTHX_ CV* func);
#define PERL_ARGS_ASSERT_PAD_ADD_WEAKREF	\
	assert(func)
PERL_CALLCONV PADOFFSET	Perl_pad_alloc(pTHX_ I32 optype, U32 tmptype);
#define PERL_ARGS_ASSERT_PAD_ALLOC
PERL_CALLCONV void	Perl_pad_block_start(pTHX_ int full);
#define PERL_ARGS_ASSERT_PAD_BLOCK_START
#ifndef NO_MATHOMS
PERL_CALLCONV HV*	Perl_pad_compname_type(pTHX_ const PADOFFSET po)
			__attribute__deprecated__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_PAD_COMPNAME_TYPE
#endif

PERL_CALLCONV PADOFFSET	Perl_pad_findmy_pv(pTHX_ const char* name, U32 flags);
#define PERL_ARGS_ASSERT_PAD_FINDMY_PV	\
	assert(name)
PERL_CALLCONV PADOFFSET	Perl_pad_findmy_pvn(pTHX_ const char* namepv, STRLEN namelen, U32 flags);
#define PERL_ARGS_ASSERT_PAD_FINDMY_PVN	\
	assert(namepv)
PERL_CALLCONV PADOFFSET	Perl_pad_findmy_sv(pTHX_ SV* name, U32 flags);
#define PERL_ARGS_ASSERT_PAD_FINDMY_SV	\
	assert(name)
PERL_CALLCONV void	Perl_pad_fixup_inner_anons(pTHX_ PADLIST *padlist, CV *old_cv, CV *new_cv);
#define PERL_ARGS_ASSERT_PAD_FIXUP_INNER_ANONS	\
	assert(padlist); assert(old_cv); assert(new_cv)
PERL_CALLCONV void	Perl_pad_free(pTHX_ PADOFFSET po);
#define PERL_ARGS_ASSERT_PAD_FREE
PERL_CALLCONV OP *	Perl_pad_leavemy(pTHX);
#define PERL_ARGS_ASSERT_PAD_LEAVEMY
PERL_CALLCONV PADLIST*	Perl_pad_new(pTHX_ int flags)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_PAD_NEW

PERL_CALLCONV void	Perl_pad_push(pTHX_ PADLIST *padlist, int depth);
#define PERL_ARGS_ASSERT_PAD_PUSH	\
	assert(padlist)
PERL_CALLCONV void	Perl_pad_swipe(pTHX_ PADOFFSET po, bool refadjust);
#define PERL_ARGS_ASSERT_PAD_SWIPE
PERL_CALLCONV void	Perl_pad_tidy(pTHX_ padtidy_type type);
#define PERL_ARGS_ASSERT_PAD_TIDY
PERL_CALLCONV PAD **	Perl_padlist_store(pTHX_ PADLIST *padlist, I32 key, PAD *val);
#define PERL_ARGS_ASSERT_PADLIST_STORE	\
	assert(padlist)
PERL_CALLCONV void	Perl_padname_free(pTHX_ PADNAME *pn);
#define PERL_ARGS_ASSERT_PADNAME_FREE	\
	assert(pn)
PERL_CALLCONV PADNAME *	Perl_padnamelist_fetch(PADNAMELIST *pnl, SSize_t key)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_PADNAMELIST_FETCH	\
	assert(pnl)

PERL_CALLCONV void	Perl_padnamelist_free(pTHX_ PADNAMELIST *pnl);
#define PERL_ARGS_ASSERT_PADNAMELIST_FREE	\
	assert(pnl)
PERL_CALLCONV PADNAME **	Perl_padnamelist_store(pTHX_ PADNAMELIST *pnl, SSize_t key, PADNAME *val);
#define PERL_ARGS_ASSERT_PADNAMELIST_STORE	\
	assert(pnl)
PERL_CALLCONV OP*	Perl_parse_arithexpr(pTHX_ U32 flags);
#define PERL_ARGS_ASSERT_PARSE_ARITHEXPR
PERL_CALLCONV OP*	Perl_parse_barestmt(pTHX_ U32 flags);
#define PERL_ARGS_ASSERT_PARSE_BARESTMT
PERL_CALLCONV OP*	Perl_parse_block(pTHX_ U32 flags);
#define PERL_ARGS_ASSERT_PARSE_BLOCK
PERL_CALLCONV OP*	Perl_parse_fullexpr(pTHX_ U32 flags);
#define PERL_ARGS_ASSERT_PARSE_FULLEXPR
PERL_CALLCONV OP*	Perl_parse_fullstmt(pTHX_ U32 flags);
#define PERL_ARGS_ASSERT_PARSE_FULLSTMT
PERL_CALLCONV SV*	Perl_parse_label(pTHX_ U32 flags);
#define PERL_ARGS_ASSERT_PARSE_LABEL
PERL_CALLCONV OP*	Perl_parse_listexpr(pTHX_ U32 flags);
#define PERL_ARGS_ASSERT_PARSE_LISTEXPR
PERL_CALLCONV OP*	Perl_parse_stmtseq(pTHX_ U32 flags);
#define PERL_ARGS_ASSERT_PARSE_STMTSEQ
PERL_CALLCONV OP*	Perl_parse_subsignature(pTHX_ U32 flags);
#define PERL_ARGS_ASSERT_PARSE_SUBSIGNATURE
PERL_CALLCONV OP*	Perl_parse_termexpr(pTHX_ U32 flags);
#define PERL_ARGS_ASSERT_PARSE_TERMEXPR
PERL_CALLCONV U32	Perl_parse_unicode_opts(pTHX_ const char **popt);
#define PERL_ARGS_ASSERT_PARSE_UNICODE_OPTS	\
	assert(popt)
PERL_CALLCONV void	Perl_parser_free(pTHX_ const yy_parser *parser);
#define PERL_ARGS_ASSERT_PARSER_FREE	\
	assert(parser)
PERL_CALLCONV void	Perl_peep(pTHX_ OP* o);
#define PERL_ARGS_ASSERT_PEEP
PERL_CALLCONV PerlInterpreter*	perl_alloc(void);
#define PERL_ARGS_ASSERT_PERL_ALLOC
PERL_CALLCONV void	perl_construct(PerlInterpreter *my_perl);
#define PERL_ARGS_ASSERT_PERL_CONSTRUCT	\
	assert(my_perl)
PERL_CALLCONV int	perl_destruct(PerlInterpreter *my_perl);
#define PERL_ARGS_ASSERT_PERL_DESTRUCT	\
	assert(my_perl)
PERL_CALLCONV void	perl_free(PerlInterpreter *my_perl);
#define PERL_ARGS_ASSERT_PERL_FREE	\
	assert(my_perl)
PERL_CALLCONV int	perl_parse(PerlInterpreter *my_perl, XSINIT_t xsinit, int argc, char** argv, char** env);
#define PERL_ARGS_ASSERT_PERL_PARSE	\
	assert(my_perl)
PERL_CALLCONV int	perl_run(PerlInterpreter *my_perl);
#define PERL_ARGS_ASSERT_PERL_RUN	\
	assert(my_perl)
PERL_CALLCONV Signal_t	Perl_perly_sighandler(int sig, Siginfo_t *info, void *uap, bool safe);
#define PERL_ARGS_ASSERT_PERLY_SIGHANDLER
/* PERL_CALLCONV const char *const	phase_name(pTHX_ enum perl_phase); */
#define PERL_ARGS_ASSERT_PHASE_NAME
PERL_CALLCONV void	Perl_pmop_dump(pTHX_ PMOP* pm);
#define PERL_ARGS_ASSERT_PMOP_DUMP
PERL_CALLCONV OP*	Perl_pmruntime(pTHX_ OP *o, OP *expr, OP *repl, UV flags, I32 floor);
#define PERL_ARGS_ASSERT_PMRUNTIME	\
	assert(o); assert(expr)
PERL_CALLCONV void	Perl_pop_scope(pTHX);
#define PERL_ARGS_ASSERT_POP_SCOPE
PERL_CALLCONV void	Perl_populate_isa(pTHX_ const char *name, STRLEN len, ...);
#define PERL_ARGS_ASSERT_POPULATE_ISA	\
	assert(name)
PERL_CALLCONV REGEXP*	Perl_pregcomp(pTHX_ SV * const pattern, const U32 flags);
#define PERL_ARGS_ASSERT_PREGCOMP	\
	assert(pattern)
PERL_CALLCONV I32	Perl_pregexec(pTHX_ REGEXP * const prog, char* stringarg, char* strend, char* strbeg, SSize_t minend, SV* screamer, U32 nosave);
#define PERL_ARGS_ASSERT_PREGEXEC	\
	assert(prog); assert(stringarg); assert(strend); assert(strbeg); assert(screamer)
PERL_CALLCONV void	Perl_pregfree(pTHX_ REGEXP* r);
#define PERL_ARGS_ASSERT_PREGFREE
PERL_CALLCONV void	Perl_pregfree2(pTHX_ REGEXP *rx);
#define PERL_ARGS_ASSERT_PREGFREE2	\
	assert(rx)
PERL_CALLCONV const char*	Perl_prescan_version(pTHX_ const char *s, bool strict, const char** errstr, bool *sqv, int *ssaw_decimal, int *swidth, bool *salpha);
#define PERL_ARGS_ASSERT_PRESCAN_VERSION	\
	assert(s)
PERL_CALLCONV void*	Perl_ptr_table_fetch(pTHX_ PTR_TBL_t *const tbl, const void *const sv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_PTR_TABLE_FETCH	\
	assert(tbl)

PERL_CALLCONV void	Perl_ptr_table_free(pTHX_ PTR_TBL_t *const tbl);
#define PERL_ARGS_ASSERT_PTR_TABLE_FREE
PERL_CALLCONV PTR_TBL_t*	Perl_ptr_table_new(pTHX)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_PTR_TABLE_NEW

PERL_CALLCONV void	Perl_ptr_table_split(pTHX_ PTR_TBL_t *const tbl);
#define PERL_ARGS_ASSERT_PTR_TABLE_SPLIT	\
	assert(tbl)
PERL_CALLCONV void	Perl_ptr_table_store(pTHX_ PTR_TBL_t *const tbl, const void *const oldsv, void *const newsv);
#define PERL_ARGS_ASSERT_PTR_TABLE_STORE	\
	assert(tbl); assert(newsv)
PERL_CALLCONV void	Perl_push_scope(pTHX);
#define PERL_ARGS_ASSERT_PUSH_SCOPE
PERL_CALLCONV char*	Perl_pv_display(pTHX_ SV *dsv, const char *pv, STRLEN cur, STRLEN len, STRLEN pvlim);
#define PERL_ARGS_ASSERT_PV_DISPLAY	\
	assert(dsv); assert(pv)
PERL_CALLCONV char*	Perl_pv_escape(pTHX_ SV *dsv, char const * const str, const STRLEN count, const STRLEN max, STRLEN * const escaped, const U32 flags);
#define PERL_ARGS_ASSERT_PV_ESCAPE	\
	assert(str)
PERL_CALLCONV char*	Perl_pv_pretty(pTHX_ SV *dsv, char const * const str, const STRLEN count, const STRLEN max, char const * const start_color, char const * const end_color, const U32 flags);
#define PERL_ARGS_ASSERT_PV_PRETTY	\
	assert(dsv); assert(str)
PERL_CALLCONV char*	Perl_pv_uni_display(pTHX_ SV *dsv, const U8 *spv, STRLEN len, STRLEN pvlim, UV flags);
#define PERL_ARGS_ASSERT_PV_UNI_DISPLAY	\
	assert(dsv); assert(spv)
PERL_CALLCONV void	Perl_qerror(pTHX_ SV* err);
#define PERL_ARGS_ASSERT_QERROR	\
	assert(err)
PERL_CALLCONV REGEXP*	Perl_re_compile(pTHX_ SV * const pattern, U32 orig_rx_flags);
#define PERL_ARGS_ASSERT_RE_COMPILE	\
	assert(pattern)
PERL_CALLCONV char*	Perl_re_intuit_start(pTHX_ REGEXP * const rx, SV* sv, const char* const strbeg, char* strpos, char* strend, const U32 flags, re_scream_pos_data *data);
#define PERL_ARGS_ASSERT_RE_INTUIT_START	\
	assert(rx); assert(strbeg); assert(strpos); assert(strend)
PERL_CALLCONV SV*	Perl_re_intuit_string(pTHX_ REGEXP  *const r);
#define PERL_ARGS_ASSERT_RE_INTUIT_STRING	\
	assert(r)
PERL_CALLCONV REGEXP*	Perl_re_op_compile(pTHX_ SV ** const patternp, int pat_count, OP *expr, const regexp_engine* eng, REGEXP *old_re, bool *is_bare_re, const U32 rx_flags, const U32 pm_flags);
#define PERL_ARGS_ASSERT_RE_OP_COMPILE	\
	assert(eng)
PERL_CALLCONV Malloc_t	Perl_realloc(Malloc_t where, MEM_SIZE nbytes)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_REALLOC

PERL_CALLCONV void	Perl_reentrant_free(pTHX);
#define PERL_ARGS_ASSERT_REENTRANT_FREE
PERL_CALLCONV void	Perl_reentrant_init(pTHX);
#define PERL_ARGS_ASSERT_REENTRANT_INIT
PERL_CALLCONV void*	Perl_reentrant_retry(const char *f, ...);
#define PERL_ARGS_ASSERT_REENTRANT_RETRY	\
	assert(f)
PERL_CALLCONV void	Perl_reentrant_size(pTHX);
#define PERL_ARGS_ASSERT_REENTRANT_SIZE
PERL_CALLCONV HV *	Perl_refcounted_he_chain_2hv(pTHX_ const struct refcounted_he *c, U32 flags);
#define PERL_ARGS_ASSERT_REFCOUNTED_HE_CHAIN_2HV
PERL_CALLCONV SV *	Perl_refcounted_he_fetch_pv(pTHX_ const struct refcounted_he *chain, const char *key, U32 hash, U32 flags);
#define PERL_ARGS_ASSERT_REFCOUNTED_HE_FETCH_PV	\
	assert(key)
PERL_CALLCONV SV *	Perl_refcounted_he_fetch_pvn(pTHX_ const struct refcounted_he *chain, const char *keypv, STRLEN keylen, U32 hash, U32 flags);
#define PERL_ARGS_ASSERT_REFCOUNTED_HE_FETCH_PVN	\
	assert(keypv)
PERL_CALLCONV SV *	Perl_refcounted_he_fetch_sv(pTHX_ const struct refcounted_he *chain, SV *key, U32 hash, U32 flags);
#define PERL_ARGS_ASSERT_REFCOUNTED_HE_FETCH_SV	\
	assert(key)
PERL_CALLCONV void	Perl_refcounted_he_free(pTHX_ struct refcounted_he *he);
#define PERL_ARGS_ASSERT_REFCOUNTED_HE_FREE
PERL_CALLCONV struct refcounted_he *	Perl_refcounted_he_inc(pTHX_ struct refcounted_he *he);
#define PERL_ARGS_ASSERT_REFCOUNTED_HE_INC
PERL_CALLCONV struct refcounted_he *	Perl_refcounted_he_new_pv(pTHX_ struct refcounted_he *parent, const char *key, U32 hash, SV *value, U32 flags);
#define PERL_ARGS_ASSERT_REFCOUNTED_HE_NEW_PV	\
	assert(key)
PERL_CALLCONV struct refcounted_he *	Perl_refcounted_he_new_pvn(pTHX_ struct refcounted_he *parent, const char *keypv, STRLEN keylen, U32 hash, SV *value, U32 flags);
#define PERL_ARGS_ASSERT_REFCOUNTED_HE_NEW_PVN	\
	assert(keypv)
PERL_CALLCONV struct refcounted_he *	Perl_refcounted_he_new_sv(pTHX_ struct refcounted_he *parent, SV *key, U32 hash, SV *value, U32 flags);
#define PERL_ARGS_ASSERT_REFCOUNTED_HE_NEW_SV	\
	assert(key)
PERL_CALLCONV SV*	Perl_reg_named_buff(pTHX_ REGEXP * const rx, SV * const key, SV * const value, const U32 flags);
#define PERL_ARGS_ASSERT_REG_NAMED_BUFF	\
	assert(rx)
PERL_CALLCONV SV*	Perl_reg_named_buff_all(pTHX_ REGEXP * const rx, const U32 flags);
#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_ALL	\
	assert(rx)
PERL_CALLCONV bool	Perl_reg_named_buff_exists(pTHX_ REGEXP * const rx, SV * const key, const U32 flags);
#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_EXISTS	\
	assert(rx); assert(key)
PERL_CALLCONV SV*	Perl_reg_named_buff_fetch(pTHX_ REGEXP * const rx, SV * const namesv, const U32 flags);
#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_FETCH	\
	assert(rx); assert(namesv)
PERL_CALLCONV SV*	Perl_reg_named_buff_firstkey(pTHX_ REGEXP * const rx, const U32 flags);
#define PERL_ARGS_ASSERT_REG_NAMED_BUFF_FIRSTKEY	\
	assert(rx)
