						*i_CTRL-X* *insert_expand*
CTRL-X enters a sub-mode where several commands can be used.  Most of these
commands do keyword completion; see |ins-completion|.

Two commands can be used to scroll the window up or down, without exiting
insert mode:

						*i_CTRL-X_CTRL-E*
CTRL-X CTRL-E		scroll window one line up.
			When doing completion look here: |complete_CTRL-E|

						*i_CTRL-X_CTRL-Y*
CTRL-X CTRL-Y		scroll window one line down.
			When doing completion look here: |complete_CTRL-Y|

After CTRL-X is pressed, each CTRL-E (CTRL-Y) scrolls the window up (down) by
one line unless that would cause the cursor to move from its current position
in the file.  As soon as another key is pressed, CTRL-X mode is exited and
that key is interpreted as in Insert mode.


==============================================================================
2. Special special keys				*ins-special-special*

The following keys are special.  They stop the current insert, do something,
and then restart insertion.  This means you can do something without getting
out of Insert mode.  This is very handy if you prefer to use the Insert mode
all the time, just like editors that don't have a separate Normal mode.  You
may also want to set the 'backspace' option to "indent,eol,start" and set the
'insertmode' option.  You can use CTRL-O if you want to map a function key to
a command.

The changes (inserted or deleted characters) before and after these keys can
be undone separately.  Only the last change can be redone and always behaves
like an "i" command.

char		action	~
-----------------------------------------------------------------------
<Up>		cursor one line up			     *i_<Up>*
<Down>		cursor one line down			     *i_<Down>*
CTRL-G <Up>	cursor one line up, insert start column	     *i_CTRL-G_<Up>*
CTRL-G k	cursor one line up, insert start column	     *i_CTRL-G_k*
CTRL-G CTRL-K	cursor one line up, insert start column	     *i_CTRL-G_CTRL-K*
CTRL-G <Down>	cursor one line down, insert start column    *i_CTRL-G_<Down>*
CTRL-G j	cursor one line down, insert start column    *i_CTRL-G_j*
CTRL-G CTRL-J	cursor one line down, insert start column    *i_CTRL-G_CTRL-J*
<Left>		cursor one character left		     *i_<Left>*
<Right>		cursor one character right		     *i_<Right>*
<S-Left>	cursor one word back (like "b" command)	     *i_<S-Left>*
<C-Left>	cursor one word back (like "b" command)	     *i_<C-Left>*
<S-Right>	cursor one word forward (like "w" command)   *i_<S-Right>*
<C-Right>	cursor one word forward (like "w" command)   *i_<C-Right>*
<Home>		cursor to first char in the line	     *i_<Home>*
<End>		cursor to after last char in the line	     *i_<End>*
<C-Home>	cursor to first char in the file	     *i_<C-Home>*
<C-End>		cursor to after last char in the file	     *i_<C-End>*
<LeftMouse>	cursor to position of mouse click	     *i_<LeftMouse>*
<S-Up>		move window one page up			     *i_<S-Up>*
<PageUp>	move window one page up			     *i_<PageUp>*
<S-Down>	move window one page down		     *i_<S-Down>*
<PageDown>	move window one page down		     *i_<PageDown>*
<ScrollWheelDown>    move window three lines down	*i_<ScrollWheelDown>*
<S-ScrollWheelDown>  move window one page down		*i_<S-ScrollWheelDown>*
<ScrollWheelUp>      move window three lines up		*i_<ScrollWheelUp>*
<S-ScrollWheelUp>    move window one page up		*i_<S-ScrollWheelUp>*
<ScrollWheelLeft>    move window six columns left	*i_<ScrollWheelLeft>*
<S-ScrollWheelLeft>  move window one page left		*i_<S-ScrollWheelLeft>*
<ScrollWheelRight>   move window six columns right	*i_<ScrollWheelRight>*
<S-ScrollWheelRight> move window one page right		*i_<S-ScrollWheelRight>*
CTRL-O		execute one command, return to Insert mode   *i_CTRL-O*
CTRL-\ CTRL-O	like CTRL-O but don't move the cursor	     *i_CTRL-\_CTRL-O*
CTRL-L		when 'insertmode' is set: go to Normal mode  *i_CTRL-L*
CTRL-G u	close undo sequence, start new change	     *i_CTRL-G_u*
CTRL-G U	don't start a new undo block with the next   *i_CTRL-G_U*
		left/right cursor movement, if the cursor
		stays within the same line
-----------------------------------------------------------------------

Note: If the cursor keys take you out of Insert mode, check the 'noesckeys'
option.

The CTRL-O command sometimes has a side effect: If the cursor was beyond the
end of the line, it will be put on the last character in the line.  In
mappings it's often better to use <Esc> (first put an "x" in the text, <Esc>
will then always put the cursor on it).  Or use CTRL-\ CTRL-O, but then
beware of the cursor possibly being beyond the end of the line.  Note that the
command following CTRL-\ CTRL-O can still move the cursor, it is not restored
to its original position.

The CTRL-O command takes you to Normal mode.  If you then use a command enter
Insert mode again it normally doesn't nest.  Thus when typing "a<C-O>a" and
then <Esc> takes you back to Normal mode, you do not need to type <Esc> twice.
An exception is when not typing the command, e.g. when executing a mapping or
sourcing a script.  This makes mappings work that briefly switch to Insert
mode.

The shifted cursor keys are not available on all terminals.

Another side effect is that a count specified before the "i" or "a" command is
ignored.  That is because repeating the effect of the command after CTRL-O is
too complicated.

An example for using CTRL-G u: >

	:inoremap <C-H> <C-G>u<C-H>

This redefines the backspace key to start a new undo sequence.  You can now
undo the effect of the backspace key, without changing what you typed before
that, with CTRL-O u.  Another example: >

	:inoremap <CR> <C-]><C-G>u<CR>

This starts a new undo block at each line break.  It also expands
abbreviations before this.

An example for using CTRL-G U: >

	inoremap <Left>  <C-G>U<Left>
	inoremap <Right> <C-G>U<Right>
	inoremap <expr> <Home> col('.') == match(getline('.'), '\S') + 1 ?
	 \ repeat('<C-G>U<Left>', col('.') - 1) :
	 \ (col('.') < match(getline('.'), '\S') ?
	 \     repeat('<C-G>U<Right>', match(getline('.'), '\S') + 0) :
	 \     repeat('<C-G>U<Left>', col('.') - 1 - match(getline('.'), '\S')))
	inoremap <expr> <End> repeat('<C-G>U<Right>', col('$') - col('.'))
	inoremap ( ()<C-G>U<Left>

This makes it possible to use the cursor keys in Insert mode, without starting
a new undo block and therefore using |.| (redo) will work as expected.  Also
entering a text like (with the "(" mapping from above):

   Lorem ipsum (dolor

will be repeatable by using |.| to the expected

   Lorem ipsum (dolor)

Using CTRL-O splits undo: the text typed before and after it is undone
separately.  If you want to avoid this (e.g., in a mapping) you might be able
to use CTRL-R = |i_CTRL-R|.  E.g., to call a function: >
	:imap <F2> <C-R>=MyFunc()<CR>

When the 'whichwrap' option is set appropriately, the <Left> and <Right>
keys on the first/last character in the line make the cursor wrap to the
previous/next line.

The CTRL-G j and CTRL-G k commands can be used to insert text in front of a
column.  Example: >
   int i;
   int j;
Position the cursor on the first "int", type "istatic <C-G>j       ".  The
result is: >
   static int i;
	  int j;
When inserting the same text in front of the column in every line, use the
Visual blockwise command "I" |v_b_I|.

==============================================================================
3. 'textwidth' and 'wrapmargin' options			*ins-textwidth*

The 'textwidth' option can be used to automatically break a line before it
gets too long.  Set the 'textwidth' option to the desired maximum line
length.  If you then type more characters (not spaces or tabs), the
last word will be put on a new line (unless it is the only word on the
line).  If you set 'textwidth' to 0, this feature is disabled.

The 'wrapmargin' option does almost the same.  The difference is that
'textwidth' has a fixed width while 'wrapmargin' depends on the width of the
screen.  When using 'wrapmargin' this is equal to using 'textwidth' with a
value equal to (columns - 'wrapmargin'), where columns is the width of the
screen.

When 'textwidth' and 'wrapmargin' are both set, 'textwidth' is used.

If you don't really want to break the line, but view the line wrapped at a
convenient place, see the 'linebreak' option.

The line is only broken automatically when using Insert mode, or when
appending to a line.  When in replace mode and the line length is not
changed, the line will not be broken.

Long lines are broken if you enter a non-white character after the margin.
The situations where a line will be broken can be restricted by adding
characters to the 'formatoptions' option:
"l"  Only break a line if it was not longer than 'textwidth' when the insert
     started.
"v"  Only break at a white character that has been entered during the
     current insert command.  This is mostly Vi-compatible.
"lv" Only break if the line was not longer than 'textwidth' when the insert
     started and only at a white character that has been entered during the
     current insert command.  Only differs from "l" when entering non-white
     characters while crossing the 'textwidth' boundary.

Normally an internal function will be used to decide where to break the line.
If you want to do it in a different way set the 'formatexpr' option to an
expression that will take care of the line break.

If you want to format a block of text, you can use the "gq" operator.  Type
"gq" and a movement command to move the cursor to the end of the block.  In
many cases, the command "gq}" will do what you want (format until the end of
paragraph).  Alternatively, you can use "gqap", which will format the whole
paragraph, no matter where the cursor currently is.  Or you can use Visual
mode: hit "v", move to the end of the block, and type "gq".  See also |gq|.

==============================================================================
4. 'expandtab', 'smarttab' and 'softtabstop' options	*ins-expandtab*

If the 'expandtab' option is on, spaces will be used to fill the amount of
whitespace of the tab.  If you want to enter a real <Tab>, type CTRL-V first
(use CTRL-Q when CTRL-V is mapped |i_CTRL-Q|).
The 'expandtab' option is off by default.  Note that in Replace mode, a single
character is replaced with several spaces.  The result of this is that the
number of characters in the line increases.  Backspacing will delete one
space at a time.  The original character will be put back for only one space
that you backspace over (the last one).

							*ins-smarttab*
When the 'smarttab' option is on, a <Tab> inserts 'shiftwidth' positions at
the beginning of a line and 'tabstop' positions in other places.  This means
that often spaces instead of a <Tab> character are inserted.  When 'smarttab'
is off, a <Tab> always inserts 'tabstop' positions, and 'shiftwidth' is only
used for ">>" and the like.

							*ins-softtabstop*
When the 'softtabstop' option is non-zero, a <Tab> inserts 'softtabstop'
positions, and a <BS> used to delete white space, will delete 'softtabstop'
positions.  This feels like 'tabstop' was set to 'softtabstop', but a real
<Tab> character still takes 'tabstop' positions, so your file will still look
correct when used by other applications.

If 'softtabstop' is non-zero, a <BS> will try to delete as much white space to
move to the previous 'softtabstop' position, except when the previously
inserted character is a space, then it will only delete the character before
the cursor.  Otherwise you cannot always delete a single character before the
cursor.  You will have to delete 'softtabstop' characters first, and then type
extra spaces to get where you want to be.

==============================================================================
5. Replace mode				*Replace* *Replace-mode* *mode-replace*

Enter Replace mode with the "R" command in normal mode.

In Replace mode, one character in the line is deleted for every character you
type.  If there is no character to delete (at the end of the line), the
typed character is appended (as in Insert mode).  Thus the number of
characters in a line stays the same until you get to the end of the line.
If a <NL> is typed, a line break is inserted and no character is deleted.

Be careful with <Tab> characters.  If you type a normal printing character in
its place, the number of characters is still the same, but the number of
columns will become smaller.

If you delete characters in Replace mode (with <BS>, CTRL-W, or CTRL-U), what
happens is that you delete the changes.  The characters that were replaced
are restored.  If you had typed past the existing text, the characters you
added are deleted.  This is effectively a character-at-a-time undo.

If the 'expandtab' option is on, a <Tab> will replace one character with
several spaces.  The result of this is that the number of characters in the
line increases.  Backspacing will delete one space at a time.  The original
character will be put back for only one space that you backspace over (the
last one).

==============================================================================
6. Virtual Replace mode		*vreplace-mode* *Virtual-Replace-mode*

Enter Virtual Replace mode with the "gR" command in normal mode.
{not available when compiled without the |+vreplace| feature}

Virtual Replace mode is similar to Replace mode, but instead of replacing
actual characters in the file, you are replacing screen real estate, so that
characters further on in the file never appear to move.

So if you type a <Tab> it may replace several normal characters, and if you
type a letter on top of a <Tab> it may not replace anything at all, since the
<Tab> will still line up to the same place as before.

Typing a <NL> still doesn't cause characters later in the file to appear to
move.  The rest of the current line will be replaced by the <NL> (that is,
they are deleted), and replacing continues on the next line.  A new line is
NOT inserted unless you go past the end of the file.

Interesting effects are seen when using CTRL-T and CTRL-D.  The characters
before the cursor are shifted sideways as normal, but characters later in the
line still remain still.  CTRL-T will hide some of the old line under the
shifted characters, but CTRL-D will reveal them again.

As with Replace mode, using <BS> etc will bring back the characters that were
replaced.  This still works in conjunction with 'smartindent', CTRL-T and
CTRL-D, 'expandtab', 'smarttab', 'softtabstop', etc.

In 'list' mode, Virtual Replace mode acts as if it was not in 'list' mode,
unless "L" is in 'cpoptions'.

Note that the only situations for which characters beyond the cursor should
appear to move are in List mode |'list'|, and occasionally when 'wrap' is set
(and the line changes length to become shorter or wider than the width of the
screen).  In other cases spaces may be inserted to avoid following characters
to move.

This mode is very useful for editing <Tab> separated columns in tables, for
entering new data while keeping all the columns aligned.

==============================================================================
7. Insert mode completion				*ins-completion*

In Insert and Replace mode, there are several commands to complete part of a
keyword or line that has been typed.  This is useful if you are using
complicated keywords (e.g., function names with capitals and underscores).

Completion can be done for:

1. Whole lines						|i_CTRL-X_CTRL-L|
2. keywords in the current file				|i_CTRL-X_CTRL-N|
3. keywords in 'dictionary'				|i_CTRL-X_CTRL-K|
4. keywords in 'thesaurus', thesaurus-style		|i_CTRL-X_CTRL-T|
5. keywords in the current and included files		|i_CTRL-X_CTRL-I|
6. tags							|i_CTRL-X_CTRL-]|
7. file names						|i_CTRL-X_CTRL-F|
8. definitions or macros				|i_CTRL-X_CTRL-D|
9. Vim command-line					|i_CTRL-X_CTRL-V|
10. User defined completion				|i_CTRL-X_CTRL-U|
11. omni completion					|i_CTRL-X_CTRL-O|
12. Spelling suggestions				|i_CTRL-X_s|
13. keywords in 'complete'				|i_CTRL-N| |i_CTRL-P|

Additionally, |i_CTRL-X_CTRL-Z| stops completion without changing the text.

All these, except CTRL-N and CTRL-P, are done in CTRL-X mode.  This is a
sub-mode of Insert and Replace modes.  You enter CTRL-X mode by typing CTRL-X
and one of the CTRL-X commands.  You exit CTRL-X mode by typing a key that is
not a valid CTRL-X mode command.  Valid keys are the CTRL-X command itself,
CTRL-N (next), and CTRL-P (previous).

To get the current completion information, |complete_info()| can be used.
Also see the 'infercase' option if you want to adjust the case of the match.

							*complete_CTRL-E*
When completion is active you can use CTRL-E to stop it and go back to the
originally typed text.  The CTRL-E will not be inserted.

							*complete_CTRL-Y*
When the popup menu is displayed you can use CTRL-Y to stop completion and
accept the currently selected entry.  The CTRL-Y is not inserted.  Typing a
space, Enter, or some other unprintable character will leave completion mode
and insert that typed character.

When the popup menu is displayed there are a few more special keys, see
|popupmenu-keys|.

Note: The keys that are valid in CTRL-X mode are not mapped.  This allows for
`:map <C-F> <C-X><C-F>` to work (assuming "<" is not in 'cpo').  The key that
ends CTRL-X mode (any key that is not a valid CTRL-X mode command) is mapped.
Also, when doing completion with 'complete' mappings apply as usual.

								*E565*
Note: While completion is active Insert mode can't be used recursively and
buffer text cannot be changed.  Mappings that somehow invoke ":normal i.."
will generate an E565 error.

The following mappings are suggested to make typing the completion commands
a bit easier (although they will hide other commands; this requires "<" is not
in 'cpo'): >
    :inoremap <C-]> <C-X><C-]>
    :inoremap <C-F> <C-X><C-F>
    :inoremap <C-D> <C-X><C-D>
    :inoremap <C-L> <C-X><C-L>

As a special case, typing CTRL-R to perform register insertion (see
|i_CTRL-R|) will not exit CTRL-X mode.  This is primarily to allow the use of
the '=' register to call some function to determine the next operation.  If
the contents of the register (or result of the '=' register evaluation) are
not valid CTRL-X mode keys, then CTRL-X mode will be exited as if those keys
had been typed.

For example, the following will map <Tab> to either actually insert a <Tab> if
the current line is currently only whitespace, or start/continue a CTRL-N
completion operation: >

	function! CleverTab()
	   if strpart( getline('.'), 0, col('.')-1 ) =~ '^\s*$'
	      return "\<Tab>"
	   else
	      return "\<C-N>"
	   endif
	endfunction
	inoremap <Tab> <C-R>=CleverTab()<CR>



Completing whole lines					*compl-whole-line*

							*i_CTRL-X_CTRL-L*
CTRL-X CTRL-L		Search backwards for a line that starts with the
			same characters as those in the current line before
			the cursor.  Indent is ignored.  The matching line is
			inserted in front of the cursor.
			The 'complete' option is used to decide which buffers
			are searched for a match.  Both loaded and unloaded
			buffers are used.
	CTRL-L	or
	CTRL-P		Search backwards for next matching line.  This line
			replaces the previous matching line.

	CTRL-N		Search forward for next matching line.  This line
			replaces the previous matching line.

	CTRL-X CTRL-L	After expanding a line you can additionally get the
			line next to it by typing CTRL-X CTRL-L again, unless
			a double CTRL-X is used.  Only works for loaded
			buffers.

Completing keywords in current file			*compl-current*

							*i_CTRL-X_CTRL-P*
							*i_CTRL-X_CTRL-N*
CTRL-X CTRL-N		Search forwards for words that start with the keyword
			in front of the cursor.  The found keyword is inserted
			in front of the cursor.

CTRL-X CTRL-P		Search backwards for words that start with the keyword
			in front of the cursor.  The found keyword is inserted
			in front of the cursor.

	CTRL-N		Search forward for next matching keyword.  This
			keyword replaces the previous matching keyword.

	CTRL-P		Search backwards for next matching keyword.  This
			keyword replaces the previous matching keyword.

	CTRL-X CTRL-N or
	CTRL-X CTRL-P	Further use of CTRL-X CTRL-N or CTRL-X CTRL-P will
			copy the words following the previous expansion in
			other contexts unless a double CTRL-X is used.

If there is a keyword in front of the cursor (a name made out of alphabetic
characters and characters in 'iskeyword'), it is used as the search pattern,
with "\<" prepended (meaning: start of a word).  Otherwise "\<\k\k" is used
as search pattern (start of any keyword of at least two characters).

In Replace mode, the number of characters that are replaced depends on the
length of the matched string.  This works like typing the characters of the
matched string in Replace mode.

If there is not a valid keyword character before the cursor, any keyword of
at least two characters is matched.
	e.g., to get:
	    printf("(%g, %g, %g)", vector[0], vector[1], vector[2]);
	just type:
	    printf("(%g, %g, %g)", vector[0], ^P[1], ^P[2]);

The search wraps around the end of the file, the value of 'wrapscan' is not
used here.

Multiple repeats of the same completion are skipped; thus a different match
will be inserted at each CTRL-N and CTRL-P (unless there is only one
matching keyword).

Single character matches are never included, as they usually just get in
the way of what you were really after.
	e.g., to get:
		printf("name = %s\n", name);
	just type:
		printf("name = %s\n", n^P);
	or even:
		printf("name = %s\n", ^P);
The 'n' in '\n' is skipped.

After expanding a word, you can use CTRL-X CTRL-P or CTRL-X CTRL-N to get the
word following the expansion in other contexts.  These sequences search for
the text just expanded and further expand by getting an extra word.  This is
useful if you need to repeat a sequence of complicated words.  Although CTRL-P
and CTRL-N look just for strings of at least two characters, CTRL-X CTRL-P and
CTRL-X CTRL-N can be used to expand words of just one character.
	e.g., to get:
		M&eacute;xico
	you can type:
		M^N^P^X^P^X^P
CTRL-N starts the expansion and then CTRL-P takes back the single character
"M", the next two CTRL-X CTRL-P's get the words "&eacute" and ";xico".

If the previous expansion was split, because it got longer than 'textwidth',
then just the text in the current line will be used.

If the match found is at the end of a line, then the first word in the next
line will be inserted and the message "Word from other line" displayed, if
this word is accepted the next CTRL-X CTRL-P or CTRL-X CTRL-N will search
for those lines starting with this word.


Completing keywords in 'dictionary'			*compl-dictionary*

							*i_CTRL-X_CTRL-K*
CTRL-X CTRL-K		Search the files given with the 'dictionary' option
			for words that start with the keyword in front of the
			cursor.  This is like CTRL-N, but only the dictionary
			files are searched, not the current file.  The found
			keyword is inserted in front of the cursor.  This
			could potentially be pretty slow, since all matches
			are found before the first match is used.  By default,
			the 'dictionary' option is empty.
			For suggestions where to find a list of words, see the
			'dictionary' option.
			'ignorecase', 'smartcase' and 'infercase' apply.

	CTRL-K	or
	CTRL-N		Search forward for next matching keyword.  This
			keyword replaces the previous matching keyword.

	CTRL-P		Search backwards for next matching keyword.  This
			keyword replaces the previous matching keyword.


Completing words in 'thesaurus'				*compl-thesaurus*

							*i_CTRL-X_CTRL-T*
CTRL-X CTRL-T		Works as CTRL-X CTRL-K, but in a special way.  It uses
			the 'thesaurus' option instead of 'dictionary'.  If a
			match is found in the thesaurus file, all the
			remaining words on the same line are included as
			matches, even though they don't complete the word.
			Thus a word can be completely replaced.

	CTRL-T	or
	CTRL-N		Search forward for next matching keyword.  This
			keyword replaces the previous matching keyword.

	CTRL-P		Search backwards for next matching keyword.  This
			keyword replaces the previous matching keyword.

In the file used by the 'thesaurus' option each line in the file should
contain words with similar meaning, separated by non-keyword characters (white
space is preferred).  Maximum line length is 510 bytes.

For an example, imagine the 'thesaurus' file has a line like this: >
	angry furious mad enraged
Placing the cursor after the letters "ang" and typing CTRL-X CTRL-T would
complete the word "angry"; subsequent presses would change the word to
"furious", "mad" etc.

Other uses include translation between two languages, or grouping API
functions by keyword.

An English word list was added to this github issue:
https://github.com/vim/vim/issues/629#issuecomment-443293282
Unpack thesaurus_pkg.zip, put the thesaurus.txt file somewhere, e.g.
~/.vim/thesaurus/english.txt, and the 'thesaurus' option to this file name.


Completing keywords with 'thesaurusfunc'		*compl-thesaurusfunc*

If the 'thesaurusfunc' option is set, then the user specified function is
invoked to get the list of completion matches and the 'thesaurus' option is
not used. See |complete-functions| for an explanation of how the function is
invoked and what it should return.

Here is an example that uses the "aiksaurus" command (provided by Magnus
Groß): >

    func Thesaur(findstart, base)
      if a:findstart
	return searchpos('\<', 'bnW', line('.'))[1] - 1
      endif
      let res = []
      let h = ''
      for l in systemlist('aiksaurus ' .. shellescape(a:base))
	if l[:3] == '=== '
	  let h = '(' .. substitute(l[4:], ' =*$', ')', '')
	elseif l ==# 'Alphabetically similar known words are: '
	  let h = "\U0001f52e"
	elseif l[0] =~ '\a' || (h ==# "\U0001f52e" && l[0] ==# "\t")
	  call extend(res, map(split(substitute(l, '^\t', '', ''), ', '), {_, val -> {'word': val, 'menu': h}}))
	endif
      endfor
      return res
    endfunc

    if exists('+thesaurusfunc')
      set thesaurusfunc=Thesaur
    endif


Completing keywords in the current and included files	*compl-keyword*

The 'include' option is used to specify a line that contains an include file
name.  The 'path' option is used to search for include files.

							*i_CTRL-X_CTRL-I*
CTRL-X CTRL-I		Search for the first keyword in the current and
			included files that starts with the same characters
			as those before the cursor.  The matched keyword is
			inserted in front of the cursor.

	CTRL-N		Search forwards for next matching keyword.  This
			keyword replaces the previous matching keyword.
			Note: CTRL-I is the same as <Tab>, which is likely to
			be typed after a successful completion, therefore
			CTRL-I is not used for searching for the next match.

	CTRL-P		Search backward for previous matching keyword.  This
			keyword replaces the previous matching keyword.

	CTRL-X CTRL-I	Further use of CTRL-X CTRL-I will copy the words
			following the previous expansion in other contexts
			unless a double CTRL-X is used.

Completing tags						*compl-tag*
							*i_CTRL-X_CTRL-]*
CTRL-X CTRL-]		Search for the first tag that starts with the same
			characters as before the cursor.  The matching tag is
			inserted in front of the cursor.  Alphabetic
			characters and characters in 'iskeyword' are used
			to decide which characters are included in the tag
			name (same as for a keyword).  See also |CTRL-]|.
			The 'showfulltag' option can be used to add context
			from around the tag definition.
	CTRL-]	or
	CTRL-N		Search forwards for next matching tag.  This tag
			replaces the previous matching tag.

	CTRL-P		Search backward for previous matching tag.  This tag
			replaces the previous matching tag.


Completing file names					*compl-filename*
							*i_CTRL-X_CTRL-F*
CTRL-X CTRL-F		Search for the first file name that starts with the
			same characters as before the cursor.  The matching
			file name is inserted in front of the cursor.
			Alphabetic characters and characters in 'isfname'
			are used to decide which characters are included in
			the file name.  Note: the 'path' option is not used
			here (yet).
	CTRL-F	or
	CTRL-N		Search forwards for next matching file name.  This
			file name replaces the previous matching file name.

	CTRL-P		Search backward for previous matching file name.
			This file name replaces the previous matching file
			name.


Completing definitions or macros			*compl-define*

The 'define' option is used to specify a line that contains a definition.
The 'include' option is used to specify a line that contains an include file
name.  The 'path' option is used to search for include files.

							*i_CTRL-X_CTRL-D*
CTRL-X CTRL-D		Search in the current and included files for the
			first definition (or macro) name that starts with
			the same characters as before the cursor.  The found
			definition name is inserted in front of the cursor.
	CTRL-D	or
	CTRL-N		Search forwards for next matching macro name.  This
			macro name replaces the previous matching macro
			name.

	CTRL-P		Search backward for previous matching macro name.
			This macro name replaces the previous matching macro
			name.

	CTRL-X CTRL-D	Further use of CTRL-X CTRL-D will copy the words
			following the previous expansion in other contexts
			unless a double CTRL-X is used.


Completing Vim commands					*compl-vim*

Completion is context-sensitive.  It works like on the Command-line.  It
completes an Ex command as well as its arguments.  This is useful when writing
a Vim script.

							*i_CTRL-X_CTRL-V*
CTRL-X CTRL-V		Guess what kind of item is in front of the cursor and
			find the first match for it.
			Note: When CTRL-V is mapped you can often use CTRL-Q
			instead of |i_CTRL-Q|.
	CTRL-V	or
	CTRL-N		Search forwards for next match.  This match replaces
			the previous one.

	CTRL-P		Search backwards for previous match.  This match
			replaces the previous one.

	CTRL-X CTRL-V	Further use of CTRL-X CTRL-V will do the same as
			CTRL-V.  This allows mapping a key to do Vim command
			completion, for example: >
				:imap <Tab> <C-X><C-V>

User defined completion					*compl-function*

Completion is done by a function that can be defined by the user with the
'completefunc' option.  See below for how the function is called and an
example |complete-functions|.

							*i_CTRL-X_CTRL-U*
CTRL-X CTRL-U		Guess what kind of item is in front of the cursor and
			find the first match for it.
	CTRL-U	or
	CTRL-N		Use the next match.  This match replaces the previous
			one.

	CTRL-P		Use the previous match.  This match replaces the
			previous one.


Omni completion						*compl-omni*

Completion is done by a function that can be defined by the user with the
'omnifunc' option.  This is to be used for filetype-specific completion.

See below for how the function is called and an example |complete-functions|.
For remarks about specific filetypes see |compl-omni-filetypes|.
More completion scripts will appear, check www.vim.org.  Currently there is a
first version for C++.

							*i_CTRL-X_CTRL-O*
CTRL-X CTRL-O		Guess what kind of item is in front of the cursor and
			find the first match for it.
	CTRL-O	or
	CTRL-N		Use the next match.  This match replaces the previous
			one.

	CTRL-P		Use the previous match.  This match replaces the
			previous one.


Spelling suggestions					*compl-spelling*

A word before or at the cursor is located and correctly spelled words are
suggested to replace it.  If there is a badly spelled word in the line, before
or under the cursor, the cursor is moved to after it.  Otherwise the word just
before the cursor is used for suggestions, even though it isn't badly spelled.

NOTE: CTRL-S suspends display in many Unix terminals.  Use 's' instead.  Type
CTRL-Q to resume displaying.

						*i_CTRL-X_CTRL-S* *i_CTRL-X_s*
CTRL-X CTRL-S   or
CTRL-X s		Locate the word in front of the cursor and find the
			first spell suggestion for it.
	CTRL-S	or
	CTRL-N		Use the next suggestion.  This replaces the previous
			one.  Note that you can't use 's' here.

	CTRL-P		Use the previous suggestion.  This replaces the
			previous one.


Completing keywords from different sources		*compl-generic*

							*i_CTRL-N*
CTRL-N			Find next match for words that start with the
			keyword in front of the cursor, looking in places
			specified with the 'complete' option.  The found
			keyword is inserted in front of the cursor.

							*i_CTRL-P*
CTRL-P			Find previous match for words that start with the
			keyword in front of the cursor, looking in places
			specified with the 'complete' option.  The found
			keyword is inserted in front of the cursor.

	CTRL-N		Search forward for next matching keyword.  This
			keyword replaces the previous matching keyword.

	CTRL-P		Search backwards for next matching keyword.  This
			keyword replaces the previous matching keyword.

	CTRL-X CTRL-N or
	CTRL-X CTRL-P	Further use of CTRL-X CTRL-N or CTRL-X CTRL-P will
			copy the words following the previous expansion in
			other contexts unless a double CTRL-X is used.


Stop completion						*compl-stop*

							*i_CTRL-X_CTRL-Z*
CTRL-X CTRL-Z		Stop completion without changing the text.


FUNCTIONS FOR FINDING COMPLETIONS			*complete-functions*

This applies to 'completefunc', 'thesaurusfunc' and 'omnifunc'.

The function is called in two different ways:
- First the function is called to find the start of the text to be completed.
- Later the function is called to actually find the matches.

On the first invocation the arguments are:
   a:findstart  1
   a:base	empty

The function must return the column where the completion starts.  It must be a
number between zero and the cursor column "col('.')".  This involves looking
at the characters just before the cursor and including those characters that
could be part of the completed item.  The text between this column and the
cursor column will be replaced with the matches.  If the returned value is
larger than the cursor column, the cursor column is used.

Negative return values:
   -2	To cancel silently and stay in completion mode.
   -3	To cancel silently and leave completion mode.
   Another negative value: completion starts at the cursor column

On the second invocation the arguments are:
   a:findstart  0
   a:base	the text with which matches should match; the text that was
		located in the first call (can be empty)

The function must return a List with the matching words.  These matches
usually include the "a:base" text.  When there are no matches return an empty
List.  Note that the cursor may have moved since the first invocation, the
text may have been changed.

In order to return more information than the matching words, return a Dict
that contains the List.  The Dict can have these items:
	words		The List of matching words (mandatory).
	refresh		A string to control re-invocation of the function
			(optional).
			The only value currently recognized is "always", the
			effect is that the function is called whenever the
			leading text is changed.

If you want to suppress the warning message for an empty result, return
|v:none|.  This is useful to implement asynchronous completion with
|complete()|.

Other items are ignored.

For acting upon end of completion, see the |CompleteDonePre| and
|CompleteDone| autocommand event.

For example, the function can contain this: >
	let matches = ... list of words ...
	return {'words': matches, 'refresh': 'always'}
<
						*complete-items*
Each list item can either be a string or a Dictionary.  When it is a string it
is used as the completion.  When it is a Dictionary it can contain these
items:
	word		the text that will be inserted, mandatory
	abbr		abbreviation of "word"; when not empty it is used in
			the menu instead of "word"
	menu		extra text for the popup menu, displayed after "word"
			or "abbr"
	info		more information about the item, can be displayed in a
			preview or popup window
	kind		single letter indicating the type of completion
	icase		when non-zero case is to be ignored when comparing
			items to be equal; when omitted zero is used, thus
			items that only differ in case are added
	equal		when non-zero, always treat this item to be equal when
			comparing. Which means, "equal=1" disables filtering
			of this item.
	dup		when non-zero this match will be added even when an
			item with the same word is already present.
	empty		when non-zero this match will be added even when it is
			an empty string
	user_data	custom data which is associated with the item and
			available in |v:completed_item|; it can be any type;
			defaults to an empty string

All of these except "icase", "equal", "dup" and "empty" must be a string.  If
an item does not meet these requirements then an error message is given and
further items in the list are not used.  You can mix string and Dictionary
items in the returned list.

The "menu" item is used in the popup menu and may be truncated, thus it should
be relatively short.  The "info" item can be longer, it will  be displayed in
the preview window when "preview" appears in 'completeopt' or in a popup
window when "popup" appears in 'completeopt'.  In the preview window the
"info" item will also remain displayed after the popup menu has been removed.
This is useful for function arguments.  Use a single space for "info" to
remove existing text in the preview window.  The size of the preview window is
three lines, but 'previewheight' is used when it has a value of 1 or 2.

						*complete-popup*
When "popup" is in 'completeopt' a popup window is used to display the "info".
Then the 'completepopup' option specifies the properties of the popup.  This
is used when the info popup is created.  The option is a comma-separated list
of values:
	height		maximum height of the popup
	width		maximum width of the popup
	highlight	highlight group of the popup (default is PmenuSel)
	align		"item" (default) or "menu"
	border		"on" (default) or "off"
Example: >
	:set completepopup=height:10,width:60,highlight:InfoPopup

When the "align" value is "item" then the popup is positioned close to the
selected item.  Changing the selection will also move the popup.  When "align"
is "menu" then the popup is aligned with the top of the menu if the menu is
below the text, and the bottom of the menu otherwise.

After the info popup is created it can be found with |popup_findinfo()| and
properties can be changed with |popup_setoptions()|.

						*complete-popuphidden*
If the information for the popup is obtained asynchronously, use "popuphidden"
in 'completeopt'.  The info popup will then be initially hidden and
|popup_show()| must be called once it has been filled with the info.  This can
be done with a |CompleteChanged| autocommand, something like this: >
	set completeopt+=popuphidden
	au CompleteChanged * call UpdateCompleteInfo()
	func UpdateCompleteInfo()
	  " Cancel any pending info fetch
	  let item = v:event.completed_item
	  " Start fetching info for the item then call ShowCompleteInfo(info)
	endfunc
	func ShowCompleteInfo(info)
	  let id = popup_findinfo()
	  if id
	    call popup_settext(id, 'async info: ' .. a:info)
	    call popup_show(id)
	  endif
	endfunc

<						*complete-item-kind*
The "kind" item uses a single letter to indicate the kind of completion.  This
may be used to show the completion differently (different color or icon).
Currently these types can be used:
	v	variable
	f	function or method
	m	member of a struct or class
	t	typedef
	d	#define or macro

When searching for matches takes some time call |complete_add()| to add each
match to the total list.  These matches should then not appear in the returned
list!  Call |complete_check()| now and then to allow the user to press a key
while still searching for matches.  Stop searching when it returns non-zero.

							*E840*
The function is allowed to move the cursor, it is restored afterwards.
The function is not allowed to move to another window or delete text.

An example that completes the names of the months: >
	fun! CompleteMonths(findstart, base)
	  if a:findstart
	    " locate the start of the word
	    let line = getline('.')
	    let start = col('.') - 1
	    while start > 0 && line[start - 1] =~ '\a'
	      let start -= 1
	    endwhile
	    return start
	  else
	    " find months matching with "a:base"
	    let res = []
	    for m in split("Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec")
	      if m =~ '^' .. a:base
		call add(res, m)
	      endif
	    endfor
	    return res
	  endif
	endfun
	set completefunc=CompleteMonths
<
The same, but now pretending searching for matches is slow: >
	fun! CompleteMonths(findstart, base)
	  if a:findstart
	    " locate the start of the word
	    let line = getline('.')
	    let start = col('.') - 1
	    while start > 0 && line[start - 1] =~ '\a'
	      let start -= 1
	    endwhile
	    return start
	  else
	    " find months matching with "a:base"
	    for m in split("Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec")
	      if m =~ '^' .. a:base
		call complete_add(m)
	      endif
	      sleep 300m	" simulate searching for next match
	      if complete_check()
		break
	      endif
	    endfor
	    return []
	  endif
	endfun
	set completefunc=CompleteMonths
<

INSERT COMPLETION POPUP MENU				*ins-completion-menu*
							*popupmenu-completion*
Vim can display the matches in a simplistic popup menu.

The menu is used when:
- The 'completeopt' option contains "menu" or "menuone".
- The terminal supports at least 8 colors.
- There are at least two matches.  One if "menuone" is used.

The 'pumheight' option can be used to set a maximum height.  The default is to
use all space available.
The 'pumwidth' option can be used to set a minimum width.  The default is 15
