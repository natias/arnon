                _count_elements(self, iterable)
        if kwds:
            self.update(kwds)

    def subtract(self, iterable=None, /, **kwds):
        '''Like dict.update() but subtracts counts instead of replacing them.
        Counts can be reduced below zero.  Both the inputs and outputs are
        allowed to contain zero and negative counts.

        Source can be an iterable, a dictionary, or another Counter instance.

        >>> c = Counter('which')
        >>> c.subtract('witch')             # subtract elements from another iterable
        >>> c.subtract(Counter('watch'))    # subtract elements from another counter
        >>> c['h']                          # 2 in which, minus 1 in witch, minus 1 in watch
        0
        >>> c['w']                          # 1 in which, minus 1 in witch, minus 1 in watch
        -1

        '''
        if iterable is not None:
            self_get = self.get
            if isinstance(iterable, _collections_abc.Mapping):
                for elem, count in iterable.items():
                    self[elem] = self_get(elem, 0) - count
            else:
                for elem in iterable:
                    self[elem] = self_get(elem, 0) - 1
        if kwds:
            self.subtract(kwds)

    def copy(self):
        'Return a shallow copy.'
        return self.__class__(self)

    def __reduce__(self):
        return self.__class__, (dict(self),)

    def __delitem__(self, elem):
        'Like dict.__delitem__() but does not raise KeyError for missing values.'
        if elem in self:
            super().__delitem__(elem)

    def __repr__(self):
        if not self:
            return f'{self.__class__.__name__}()'
        try:
            # dict() preserves the ordering returned by most_common()
            d = dict(self.most_common())
        except TypeError:
            # handle case where values are not orderable
            d = dict(self)
        return f'{self.__class__.__name__}({d!r})'

    # Multiset-style mathematical operations discussed in:
    #       Knuth TAOCP Volume II section 4.6.3 exercise 19
    #       and at http://en.wikipedia.org/wiki/Multiset
    #
    # Outputs guaranteed to only include positive counts.
    #
    # To strip negative and zero counts, add-in an empty counter:
    #       c += Counter()
    #
    # Results are ordered according to when an element is first
    # encountered in the left operand and then by the order
    # encountered in the right operand.
    #
    # When the multiplicities are all zero or one, multiset operations
    # are guaranteed to be equivalent to the corresponding operations
    # for regular sets.
    #     Given counter multisets such as:
    #         cp = Counter(a=1, b=0, c=1)
    #         cq = Counter(c=1, d=0, e=1)
    #     The corresponding regular sets would be:
    #         sp = {'a', 'c'}
    #         sq = {'c', 'e'}
    #     All of the following relations would hold:
    #         set(cp + cq) == sp | sq
    #         set(cp - cq) == sp - sq
    #         set(cp | cq) == sp | sq
    #         set(cp & cq) == sp & sq
    #         (cp == cq) == (sp == sq)
    #         (cp != cq) == (sp != sq)
    #         (cp <= cq) == (sp <= sq)
    #         (cp < cq) == (sp < sq)
    #         (cp >= cq) == (sp >= sq)
    #         (cp > cq) == (sp > sq)

    def __eq__(self, other):
        'True if all counts agree. Missing counts are treated as zero.'
        if not isinstance(other, Counter):
            return NotImplemented
        return all(self[e] == other[e] for c in (self, other) for e in c)

    def __ne__(self, other):
        'True if any counts disagree. Missing counts are treated as zero.'
        if not isinstance(other, Counter):
            return NotImplemented
        return not self == other

    def __le__(self, other):
        'True if all counts in self are a subset of those in other.'
        if not isinstance(other, Counter):
            return NotImplemented
        return all(self[e] <= other[e] for c in (self, other) for e in c)

    def __lt__(self, other):
        'True if all counts in self are a proper subset of those in other.'
        if not isinstance(other, Counter):
            return NotImplemented
        return self <= other and self != other

    def __ge__(self, other):
        'True if all counts in self are a superset of those in other.'
        if not isinstance(other, Counter):
            return NotImplemented
        return all(self[e] >= other[e] for c in (self, other) for e in c)

    def __gt__(self, other):
        'True if all counts in self are a proper superset of those in other.'
        if not isinstance(other, Counter):
            return NotImplemented
        return self >= other and self != other

    def __add__(self, other):
        '''Add counts from two counters.

        >>> Counter('abbb') + Counter('bcc')
        Counter({'b': 4, 'c': 2, 'a': 1})

        '''
        if not isinstance(other, Counter):
            return NotImplemented
        result = Counter()
        for elem, count in self.items():
            newcount = count + other[elem]
            if newcount > 0:
                result[elem] = newcount
        for elem, count in other.items():
            if elem not in self and count > 0:
                result[elem] = count
        return result

    def __sub__(self, other):
        ''' Subtract count, but keep only results with positive counts.

        >>> Counter('abbbc') - Counter('bccd')
        Counter({'b': 2, 'a': 1})

        '''
        if not isinstance(other, Counter):
            return NotImplemented
        result = Counter()
        for elem, count in self.items():
            newcount = count - other[elem]
            if newcount > 0:
                result[elem] = newcount
        for elem, count in other.items():
            if elem not in self and count < 0:
                result[elem] = 0 - count
        return result

    def __or__(self, other):
        '''Union is the maximum of value in either of the input counters.

        >>> Counter('abbb') | Counter('bcc')
        Counter({'b': 3, 'c': 2, 'a': 1})

        '''
        if not isinstance(other, Counter):
            return NotImplemented
        result = Counter()
        for elem, count in self.items():
            other_count = other[elem]
            newcount = other_count if count < other_count else count
            if newcount > 0:
                result[elem] = newcount
        for elem, count in other.items():
            if elem not in self and count > 0:
                result[elem] = count
        return result

    def __and__(self, other):
        ''' Intersection is the minimum of corresponding counts.

        >>> Counter('abbb') & Counter('bcc')
        Counter({'b': 1})

        '''
        if not isinstance(other, Counter):
            return NotImplemented
        result = Counter()
        for elem, count in self.items():
            other_count = other[elem]
            newcount = count if count < other_count else other_count
            if newcount > 0:
                result[elem] = newcount
        return result

    def __pos__(self):
        'Adds an empty counter, effectively stripping negative and zero counts'
        result = Counter()
        for elem, count in self.items():
            if count > 0:
                result[elem] = count
        return result

    def __neg__(self):
        '''Subtracts from an empty counter.  Strips positive and zero counts,
        and flips the sign on negative counts.

        '''
        result = Counter()
        for elem, count in self.items():
            if count < 0:
                result[elem] = 0 - count
        return result

    def _keep_positive(self):
        '''Internal method to strip elements with a negative or zero count'''
        nonpositive = [elem for elem, count in self.items() if not count > 0]
        for elem in nonpositive:
            del self[elem]
        return self

    def __iadd__(self, other):
        '''Inplace add from another counter, keeping only positive counts.

        >>> c = Counter('abbb')
        >>> c += Counter('bcc')
        >>> c
        Counter({'b': 4, 'c': 2, 'a': 1})

        '''
        for elem, count in other.items():
            self[elem] += count
        return self._keep_positive()

    def __isub__(self, other):
        '''Inplace subtract counter, but keep only results with positive counts.

        >>> c = Counter('abbbc')
        >>> c -= Counter('bccd')
        >>> c
        Counter({'b': 2, 'a': 1})

        '''
        for elem, count in other.items():
            self[elem] -= count
        return self._keep_positive()

    def __ior__(self, other):
        '''Inplace union is the maximum of value from either counter.

        >>> c = Counter('abbb')
        >>> c |= Counter('bcc')
        >>> c
        Counter({'b': 3, 'c': 2, 'a': 1})

        '''
        for elem, other_count in other.items():
            count = self[elem]
            if other_count > count:
                self[elem] = other_count
        return self._keep_positive()

    def __iand__(self, other):
        '''Inplace intersection is the minimum of corresponding counts.

        >>> c = Counter('abbb')
        >>> c &= Counter('bcc')
        >>> c
        Counter({'b': 1})

        '''
        for elem, count in self.items():
            other_count = other[elem]
            if other_count < count:
                self[elem] = other_count
        return self._keep_positive()


########################################################################
###  ChainMap
########################################################################

class ChainMap(_collections_abc.MutableMapping):
    ''' A ChainMap groups multiple dicts (or other mappings) together
    to create a single, updateable view.

    The underlying mappings are stored in a list.  That list is public and can
    be accessed or updated using the *maps* attribute.  There is no other
    state.

    Lookups search the underlying mappings successively until a key is found.
    In contrast, writes, updates, and deletions only operate on the first
    mapping.

    '''

    def __init__(self, *maps):
        '''Initialize a ChainMap by setting *maps* to the given mappings.
        If no mappings are provided, a single empty dictionary is used.

        '''
        self.maps = list(maps) or [{}]          # always at least one map

    def __missing__(self, key):
        raise KeyError(key)

    def __getitem__(self, key):
        for mapping in self.maps:
            try:
                return mapping[key]             # can't use 'key in mapping' with defaultdict
            except KeyError:
                pass
        return self.__missing__(key)            # support subclasses that define __missing__

    def get(self, key, default=None):
        return self[key] if key in self else default

    def __len__(self):
        return len(set().union(*self.maps))     # reuses stored hash values if possible

    def __iter__(self):
        d = {}
        for mapping in reversed(self.maps):
            d.update(dict.fromkeys(mapping))    # reuses stored hash values if possible
        return iter(d)

    def __contains__(self, key):
        return any(key in m for m in self.maps)

    def __bool__(self):
        return any(self.maps)

    @_recursive_repr()
    def __repr__(self):
        return f'{self.__class__.__name__}({", ".join(map(repr, self.maps))})'

    @classmethod
    def fromkeys(cls, iterable, *args):
        'Create a ChainMap with a single dict created from the iterable.'
        return cls(dict.fromkeys(iterable, *args))

    def copy(self):
        'New ChainMap or subclass with a new copy of maps[0] and refs to maps[1:]'
        return self.__class__(self.maps[0].copy(), *self.maps[1:])

    __copy__ = copy

    def new_child(self, m=None, **kwargs):      # like Django's Context.push()
        '''New ChainMap with a new map followed by all previous maps.
        If no map is provided, an empty dict is used.
        Keyword arguments update the map or new empty dict.
        '''
        if m is None:
            m = kwargs
        elif kwargs:
            m.update(kwargs)
        return self.__class__(m, *self.maps)

    @property
    def parents(self):                          # like Django's Context.pop()
        'New ChainMap from maps[1:].'
        return self.__class__(*self.maps[1:])

    def __setitem__(self, key, value):
        self.maps[0][key] = value

    def __delitem__(self, key):
        try:
            del self.maps[0][key]
        except KeyError:
            raise KeyError(f'Key not found in the first mapping: {key!r}')

    def popitem(self):
        'Remove and return an item pair from maps[0]. Raise KeyError is maps[0] is empty.'
        try:
            return self.maps[0].popitem()
        except KeyError:
            raise KeyError('No keys found in the first mapping.')

    def pop(self, key, *args):
        'Remove *key* from maps[0] and return its value. Raise KeyError if *key* not in maps[0].'
        try:
            return self.maps[0].pop(key, *args)
        except KeyError:
            raise KeyError(f'Key not found in the first mapping: {key!r}')

    def clear(self):
        'Clear maps[0], leaving maps[1:] intact.'
        self.maps[0].clear()

    def __ior__(self, other):
        self.maps[0].update(other)
        return self

    def __or__(self, other):
        if not isinstance(other, _collections_abc.Mapping):
            return NotImplemented
        m = self.copy()
        m.maps[0].update(other)
        return m

    def __ror__(self, other):
        if not isinstance(other, _collections_abc.Mapping):
            return NotImplemented
        m = dict(other)
        for child in reversed(self.maps):
            m.update(child)
        return self.__class__(m)


################################################################################
### UserDict
################################################################################

class UserDict(_collections_abc.MutableMapping):

    # Start by filling-out the abstract methods
    def __init__(self, dict=None, /, **kwargs):
        self.data = {}
        if dict is not None:
            self.update(dict)
        if kwargs:
            self.update(kwargs)

    def __len__(self):
        return len(self.data)

    def __getitem__(self, key):
        if key in self.data:
            return self.data[key]
        if hasattr(self.__class__, "__missing__"):
            return self.__class__.__missing__(self, key)
        raise KeyError(key)

    def __setitem__(self, key, item):
        self.data[key] = item

    def __delitem__(self, key):
        del self.data[key]

    def __iter__(self):
        return iter(self.data)

    # Modify __contains__ to work correctly when __missing__ is present
    def __contains__(self, key):
        return key in self.data

    # Now, add the methods in dicts but not in MutableMapping
    def __repr__(self):
        return repr(self.data)

    def __or__(self, other):
        if isinstance(other, UserDict):
            return self.__class__(self.data | other.data)
        if isinstance(other, dict):
            return self.__class__(self.data | other)
        return NotImplemented

    def __ror__(self, other):
        if isinstance(other, UserDict):
            return self.__class__(other.data | self.data)
        if isinstance(other, dict):
            return self.__class__(other | self.data)
        return NotImplemented

    def __ior__(self, other):
        if isinstance(other, UserDict):
            self.data |= other.data
        else:
            self.data |= other
        return self

    def __copy__(self):
        inst = self.__class__.__new__(self.__class__)
        inst.__dict__.update(self.__dict__)
        # Create a copy and avoid triggering descriptors
        inst.__dict__["data"] = self.__dict__["data"].copy()
        return inst

    def copy(self):
        if self.__class__ is UserDict:
            return UserDict(self.data.copy())
        import copy
        data = self.data
        try:
            self.data = {}
            c = copy.copy(self)
        finally:
            self.data = data
        c.update(self)
        return c

    @classmethod
    def fromkeys(cls, iterable, value=None):
        d = cls()
        for key in iterable:
            d[key] = value
        return d


################################################################################
### UserList
################################################################################

class UserList(_collections_abc.MutableSequence):
    """A more or less complete user-defined wrapper around list objects."""

    def __init__(self, initlist=None):
        self.data = []
        if initlist is not None:
            # XXX should this accept an arbitrary sequence?
            if type(initlist) == type(self.data):
                self.data[:] = initlist
            elif isinstance(initlist, UserList):
                self.data[:] = initlist.data[:]
            else:
                self.data = list(initlist)

    def __repr__(self):
        return repr(self.data)

    def __lt__(self, other):
        return self.data < self.__cast(other)

    def __le__(self, other):
        return self.data <= self.__cast(other)

    def __eq__(self, other):
        return self.data == self.__cast(other)

    def __gt__(self, other):
        return self.data > self.__cast(other)

    def __ge__(self, other):
        return self.data >= self.__cast(other)

    def __cast(self, other):
        return other.data if isinstance(other, UserList) else other

    def __contains__(self, item):
        return item in self.data

    def __len__(self):
        return len(self.data)

    def __getitem__(self, i):
        if isinstance(i, slice):
            return self.__class__(self.data[i])
        else:
            return self.data[i]

    def __setitem__(self, i, item):
        self.data[i] = item

    def __delitem__(self, i):
        del self.data[i]

    def __add__(self, other):
        if isinstance(other, UserList):
            return self.__class__(self.data + other.data)
        elif isinstance(other, type(self.data)):
            return self.__class__(self.data + other)
        return self.__class__(self.data + list(other))

    def __radd__(self, other):
        if isinstance(other, UserList):
            return self.__class__(other.data + self.data)
        elif isinstance(other, type(self.data)):
            return self.__class__(other + self.data)
        return self.__class__(list(other) + self.data)

    def __iadd__(self, other):
        if isinstance(other, UserList):
            self.data += other.data
        elif isinstance(other, type(self.data)):
            self.data += other
        else:
            self.data += list(other)
        return self

    def __mul__(self, n):
        return self.__class__(self.data * n)

    __rmul__ = __mul__

    def __imul__(self, n):
        self.data *= n
        return self

    def __copy__(self):
        inst = self.__class__.__new__(self.__class__)
        inst.__dict__.update(self.__dict__)
        # Create a copy and avoid triggering descriptors
        inst.__dict__["data"] = self.__dict__["data"][:]
        return inst

    def append(self, item):
        self.data.append(item)

    def insert(self, i, item):
        self.data.insert(i, item)

    def pop(self, i=-1):
        return self.data.pop(i)

    def remove(self, item):
        self.data.remove(item)

    def clear(self):
        self.data.clear()

    def copy(self):
        return self.__class__(self)

    def count(self, item):
        return self.data.count(item)

    def index(self, item, *args):
        return self.data.index(item, *args)

    def reverse(self):
        self.data.reverse()

    def sort(self, /, *args, **kwds):
        self.data.sort(*args, **kwds)

    def extend(self, other):
        if isinstance(other, UserList):
            self.data.extend(other.data)
        else:
            self.data.extend(other)


################################################################################
### UserString
################################################################################

class UserString(_collections_abc.Sequence):

    def __init__(self, seq):
        if isinstance(seq, str):
            self.data = seq
        elif isinstance(seq, UserString):
            self.data = seq.data[:]
        else:
            self.data = str(seq)

    def __str__(self):
        return str(self.data)

    def __repr__(self):
        return repr(self.data)

    def __int__(self):
        return int(self.data)

    def __float__(self):
        return float(self.data)

    def __complex__(self):
        return complex(self.data)

    def __hash__(self):
        return hash(self.data)

    def __getnewargs__(self):
        return (self.data[:],)

    def __eq__(self, string):
        if isinstance(string, UserString):
            return self.data == string.data
        return self.data == string

    def __lt__(self, string):
        if isinstance(string, UserString):
            return self.data < string.data
        return self.data < string

    def __le__(self, string):
        if isinstance(string, UserString):
            return self.data <= string.data
        return self.data <= string

    def __gt__(self, string):
        if isinstance(string, UserString):
            return self.data > string.data
        return self.data > string

    def __ge__(self, string):
        if isinstance(string, UserString):
            return self.data >= string.data
        return self.data >= string

    def __contains__(self, char):
        if isinstance(char, UserString):
            char = char.data
        return char in self.data

    def __len__(self):
        return len(self.data)

    def __getitem__(self, index):
        return self.__class__(self.data[index])

    def __add__(self, other):
        if isinstance(other, UserString):
            return self.__class__(self.data + other.data)
        elif isinstance(other, str):
            return self.__class__(self.data + other)
        return self.__class__(self.data + str(other))

    def __radd__(self, other):
        if isinstance(other, str):
            return self.__class__(other + self.data)
        return self.__class__(str(other) + self.data)

    def __mul__(self, n):
        return self.__class__(self.data * n)

    __rmul__ = __mul__

    def __mod__(self, args):
        return self.__class__(self.data % args)

    def __rmod__(self, template):
        return self.__class__(str(template) % self)

    # the following methods are defined in alphabetical order:
    def capitalize(self):
        return self.__class__(self.data.capitalize())

    def casefold(self):
        return self.__class__(self.data.casefold())

    def center(self, width, *args):
        return self.__class__(self.data.center(width, *args))

    def count(self, sub, start=0, end=_sys.maxsize):
        if isinstance(sub, UserString):
            sub = sub.data
        return self.data.count(sub, start, end)

    def removeprefix(self, prefix, /):
        if isinstance(prefix, UserString):
            prefix = prefix.data
        return self.__class__(self.data.removeprefix(prefix))

    def removesuffix(self, suffix, /):
        if isinstance(suffix, UserString):
            suffix = suffix.data
        return self.__class__(self.data.removesuffix(suffix))

    def encode(self, encoding='utf-8', errors='strict'):
        encoding = 'utf-8' if encoding is None else encoding
        errors = 'strict' if errors is None else errors
        return self.data.encode(encoding, errors)

    def endswith(self, suffix, start=0, end=_sys.maxsize):
        return self.data.endswith(suffix, start, end)

    def expandtabs(self, tabsize=8):
        return self.__class__(self.data.expandtabs(tabsize))

    def find(self, sub, start=0, end=_sys.maxsize):
        if isinstance(sub, UserString):
            sub = sub.data
        return self.data.find(sub, start, end)

    def format(self, /, *args, **kwds):
        return self.data.format(*args, **kwds)

    def format_map(self, mapping):
        return self.data.format_map(mapping)

    def index(self, sub, start=0, end=_sys.maxsize):
        return self.data.index(sub, start, end)

    def isalpha(self):
        return self.data.isalpha()

    def isalnum(self):
        return self.data.isalnum()

    def isascii(self):
        return self.data.isascii()

    def isdecimal(self):
        return self.data.isdecimal()

    def isdigit(self):
        return self.data.isdigit()

    def isidentifier(self):
        return self.data.isidentifier()

    def islower(self):
        return self.data.islower()

    def isnumeric(self):
        return self.data.isnumeric()

    def isprintable(self):
        return self.data.isprintable()

    def isspace(self):
        return self.data.isspace()

    def istitle(self):
        return self.data.istitle()

    def isupper(self):
        return self.data.isupper()

    def join(self, seq):
        return self.data.join(seq)

    def ljust(self, width, *args):
        return self.__class__(self.data.ljust(width, *args))

    def lower(self):
        return self.__class__(self.data.lower())

    def lstrip(self, chars=None):
        return self.__class__(self.data.lstrip(chars))

    maketrans = str.maketrans

    def partition(self, sep):
        return self.data.partition(sep)

    def replace(self, old, new, maxsplit=-1):
        if isinstance(old, UserString):
            old = old.data
        if isinstance(new, UserString):
            new = new.data
        return self.__class__(self.data.replace(old, new, maxsplit))

    def rfind(self, sub, start=0, end=_sys.maxsize):
        if isinstance(sub, UserString):
            sub = sub.data
        return self.data.rfind(sub, start, end)

    def rindex(self, sub, start=0, end=_sys.maxsize):
        return self.data.rindex(sub, start, end)

    def rjust(self, width, *args):
        return self.__class__(self.data.rjust(width, *args))

    def rpartition(self, sep):
        return self.data.rpartition(sep)

    def rstrip(self, chars=None):
        return self.__class__(self.data.rstrip(chars))

    def split(self, sep=None, maxsplit=-1):
        return self.data.split(sep, maxsplit)

    def rsplit(self, sep=None, maxsplit=-1):
        return self.data.rsplit(sep, maxsplit)

    def splitlines(self, keepends=False):
        return self.data.splitlines(keepends)

    def startswith(self, prefix, start=0, end=_sys.maxsize):
        return self.data.startswith(prefix, start, end)

    def strip(self, chars=None):
        return self.__class__(self.data.strip(chars))

    def swapcase(self):
        return self.__class__(self.data.swapcase())

    def title(self):
        return self.__class__(self.data.title())

    def translate(self, *args):
        return self.__class__(self.data.translate(*args))

    def upper(self):
        return self.__class__(self.data.upper())

    def zfill(self, width):
        return self.__class__(self.data.zfill(width))
                                                                                                                                                                                                                                                                                                       usr/lib/python3.11/collections/__pycache__/                                                         0000755 0000000 0000000 00000000000 14714551116 017202  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python3.11/collections/__pycache__/__init__.cpython-311.pyc                                 0000644 0000000 0000000 00000230325 14714551116 023450  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        §
    NüäfÙÊ  ã                   óî  — d Z g d¢ZddlZddlZddlmZ ddlmZ	 ddlm
Z ddlmZ ddlmZ dd	lmZ dd
lmZ ddlmZ 	 ddlmZ ej                             e¦  «         n# e$ r Y nw xY w	 ddlmZ n# e$ r Y nw xY w G d„ dej         ¦  «        Z! G d„ dej"        ¦  «        Z# G d„ dej$        ¦  «        Z% G d„ de&¦  «        Z' G d„ de(¦  «        Z)	 ddlm)Z) n# e$ r Y nw xY w	 ddlm*Z* n# e$ r d„ Z*Y nw xY wddddœd„Z+d„ Z,	 ddlm,Z, n# e$ r Y nw xY w G d „ d!e(¦  «        Z- G d"„ d#ej.        ¦  «        Z/ G d$„ d%ej.        ¦  «        Z0 G d&„ d'ej        ¦  «        Z1 G d(„ d)ej2        ¦  «        Z3dS )*a?  This module implements specialized container datatypes providing
alternatives to Python's general purpose built-in containers, dict,
list, set, and tuple.

* namedtuple   factory function for creating tuple subclasses with named fields
* deque        list-like container with fast appends and pops on either end
* ChainMap     dict-like class for creating a single view of multiple mappings
* Counter      dict subclass for counting hashable objects
* OrderedDict  dict subclass that remembers the order entries were added
* defaultdict  dict subclass that calls a factory function to supply missing values
* UserDict     wrapper around dictionary objects for easier dict subclassing
* UserList     wrapper around list objects for easier list subclassing
* UserString   wrapper around string objects for easier string subclassing

)	ÚChainMapÚCounterÚOrderedDictÚUserDictÚUserListÚ
UserStringÚdefaultdictÚdequeÚ
namedtupleé    N)Úchain)Úrepeat)Ústarmap)Ú	iskeyword)Úeq)Ú
itemgetter)Úrecursive_repr)Úproxy)r	   )r   c                   ó   — e Zd Zd„ ZdS )Ú_OrderedDictKeysViewc              #   ó>   K  — t          | j        ¦  «        E d {V —† d S ©N©ÚreversedÚ_mapping©Úselfs    ú+/usr/lib/python3.11/collections/__init__.pyÚ__reversed__z!_OrderedDictKeysView.__reversed__<   s.   è è € İ˜DœMÑ*Ô*Ğ*Ğ*Ğ*Ğ*Ğ*Ğ*Ğ*Ğ*Ğ*ó    N©Ú__name__Ú
__module__Ú__qualname__r   © r   r   r   r   :   s#   € € € € € ğ+ğ +ğ +ğ +ğ +r   r   c                   ó   — e Zd Zd„ ZdS )Ú_OrderedDictItemsViewc              #   óZ   K  — t          | j        ¦  «        D ]}|| j        |         fV — Œd S r   r   ©r   Úkeys     r   r   z"_OrderedDictItemsView.__reversed__A   sD   è è € İ˜DœMÑ*Ô*ğ 	,ğ 	,ˆCØ˜œ cÔ*Ğ+Ğ+Ğ+Ğ+Ğ+ğ	,ğ 	,r   Nr    r$   r   r   r&   r&   ?   s#   € € € € € ğ,ğ ,ğ ,ğ ,ğ ,r   r&   c                   ó   — e Zd Zd„ ZdS )Ú_OrderedDictValuesViewc              #   óV   K  — t          | j        ¦  «        D ]}| j        |         V — Œd S r   r   r(   s     r   r   z#_OrderedDictValuesView.__reversed__G   s?   è è € İ˜DœMÑ*Ô*ğ 	%ğ 	%ˆCØ”- Ô$Ğ$Ğ$Ğ$Ğ$ğ	%ğ 	%r   Nr    r$   r   r   r+   r+   E   s#   € € € € € ğ%ğ %ğ %ğ %ğ %r   r+   c                   ó   — e Zd ZdZdS )Ú_Link)ÚprevÚnextr)   Ú__weakref__N)r!   r"   r#   Ú	__slots__r$   r   r   r.   r.   K   s   € € € € € Ø4€I€I€Ir   r.   c                   ó<  — e Zd ZdZdd„Zej        eefd„Zej	        fd„Z	d„ Z
d„ Zd„ Zdd
„Zdd„Zd„ Zej        j        xZZd„ Zd„ Zd„ Zej        j        Z e¦   «         Zefd„Zdd„Z e¦   «         d„ ¦   «         Zd„ Zd„ Ze dd„¦   «         Z!d„ Z"d„ Z#d„ Z$d„ Z%dS )r   z)Dictionary that remembers insertion orderr$   c                óÚ   — 	 | j          nS# t          $ rF t          ¦   «         | _        t	          | j        ¦  «        x| _         }|x|_        |_        i | _        Y nw xY w | j        |fi |¤ dS )zŒInitialize an ordered dictionary.  The signature is the same as
        regular dictionaries.  Keyword argument order is preserved.
        N)	Ú_OrderedDict__rootÚAttributeErrorr.   Ú_OrderedDict__hardrootÚ_proxyr/   r0   Ú_OrderedDict__mapÚ_OrderedDict__update)r   ÚotherÚkwdsÚroots       r   Ú__init__zOrderedDict.__init__]   s‡   € ğ	ØŒKˆKˆKøİğ 	ğ 	ğ 	İ#™gœgˆDŒOİ!'¨¬Ñ!8Ô!8Ğ8ˆDŒK˜$Ø$(Ğ(ˆDŒI˜œ	ØˆDŒJˆJˆJğ		øøøğ
 	ˆŒeĞ$Ğ$˜tĞ$Ğ$Ğ$Ğ$Ğ$s   ‚
 ŠAAÁAc                 óÆ   — || vrO |¦   «         x| j         |<   }| j        }|j        }|||c|_        |_        |_        ||_         ||¦  «        |_         || ||¦  «         dS )z!od.__setitem__(i, y) <==> od[i]=yN)r9   r5   r/   r0   r)   )	r   r)   ÚvalueÚdict_setitemr   ÚLinkÚlinkr=   Úlasts	            r   Ú__setitem__zOrderedDict.__setitem__j   sw   € ğ
 dˆ?ˆ?Ø%) T¡V¤VĞ+ˆDŒJs‰O˜dØ”;ˆDØ”9ˆDØ-1°4¸Ğ*ˆDŒIt”y $¤(ØˆDŒIØ˜˜d™œˆDŒIØˆT˜3 Ñ&Ô&Ğ&Ğ&Ğ&r   c                 ó¦   —  || |¦  «         | j                              |¦  «        }|j        }|j        }||_        ||_        d|_        d|_        dS )z od.__delitem__(y) <==> del od[y]N)r9   Úpopr/   r0   )r   r)   Údict_delitemrC   Ú	link_prevÚ	link_nexts         r   Ú__delitem__zOrderedDict.__delitem__x   sW   € ğ 	ˆT˜3ÑÔĞØŒz~Š~˜cÑ"Ô"ˆØ”Iˆ	Ø”Iˆ	Ø"ˆ	ŒØ"ˆ	ŒØˆŒ	ØˆŒ	ˆ	ˆ	r   c              #   óZ   K  — | j         }|j        }||ur|j        V — |j        }||u°dS dS )zod.__iter__() <==> iter(od)N)r5   r0   r)   ©r   r=   Úcurrs      r   Ú__iter__zOrderedDict.__iter__…   óL   è è € ğ Œ{ˆØŒyˆØ˜$ĞĞØ”(ˆNˆNˆNØ”9ˆDğ ˜$ĞĞĞĞĞĞr   c              #   óZ   K  — | j         }|j        }||ur|j        V — |j        }||u°dS dS )z#od.__reversed__() <==> reversed(od)N)r5   r/   r)   rM   s      r   r   zOrderedDict.__reversed__   rP   r   c                 ó–   — | j         }|x|_        |_        | j                             ¦   «          t
                               | ¦  «         dS )z.od.clear() -> None.  Remove all items from od.N)r5   r/   r0   r9   ÚclearÚdict)r   r=   s     r   rS   zOrderedDict.clear—   sC   € àŒ{ˆØ $Ğ$ˆŒ	D”IØŒ
×ÒÑÔĞİ
Š
4ÑÔĞĞĞr   Tc                 ó  — | st          d¦  «        ‚| j        }|r|j        }|j        }||_        ||_        n|j        }|j        }||_        ||_        |j        }| j        |= t                               | |¦  «        }||fS )z•Remove and return a (key, value) pair from the dictionary.

        Pairs are returned in LIFO order if last is true or FIFO order if false.
        zdictionary is empty)ÚKeyErrorr5   r/   r0   r)   r9   rT   rG   )r   rD   r=   rC   rI   rJ   r)   r@   s           r   ÚpopitemzOrderedDict.popitem   s‘   € ğ
 ğ 	2İĞ0Ñ1Ô1Ğ1ØŒ{ˆØğ 		"Ø”9ˆDØœ	ˆIØ!ˆIŒNØ!ˆDŒIˆIà”9ˆDØœ	ˆIØ!ˆDŒIØ!ˆIŒNØŒhˆØŒJsˆOİ—’˜˜sÑ#Ô#ˆØEˆzĞr   c                 ó  — | j         |         }|j        }|j        }|j        }||_        ||_        | j        }|r%|j        }||_        ||_        ||_        ||_        dS |j        }||_        ||_        ||_        ||_        dS )z„Move an existing element to the end (or beginning if last is false).

        Raise KeyError if the element does not exist.
        N)r9   r/   r0   r5   )	r   r)   rD   rC   rI   rJ   Ú	soft_linkr=   Úfirsts	            r   Úmove_to_endzOrderedDict.move_to_endµ   s   € ğ
 Œz˜#ŒˆØ”Iˆ	Ø”Iˆ	Ø”Nˆ	Ø"ˆ	ŒØ"ˆ	ŒØŒ{ˆØğ 	Ø”9ˆDØˆDŒIØˆDŒIØ!ˆDŒIØˆDŒIˆIˆIà”IˆEØˆDŒIØˆDŒIØ"ˆEŒJØˆDŒIˆIˆIr   c                 óæ   — t           j        }t          | ¦  «        dz   } || j        ¦  «        }| || j        ¦  «        dz  z  }| || j        ¦  «        |z  z  }| || j        ¦  «        |z  z  }|S )Né   é   )Ú_sysÚ	getsizeofÚlenÚ__dict__r9   r7   r5   )r   ÚsizeofÚnÚsizes       r   Ú
__sizeof__zOrderedDict.__sizeof__Î   s   € İ”ˆİ‰IŒI˜‰MˆØˆvd”mÑ$Ô$ˆØt”zÑ"Ô" QÑ&Ñ&ˆØt”Ñ'Ô'¨!Ñ+Ñ+ˆØt”{Ñ#Ô# aÑ'Ñ'ˆØˆr   c                 ó    — t          | ¦  «        S )z:D.keys() -> a set-like object providing a view on D's keys)r   r   s    r   ÚkeyszOrderedDict.keysÙ   s   € å# DÑ)Ô)Ğ)r   c                 ó    — t          | ¦  «        S )z<D.items() -> a set-like object providing a view on D's items)r&   r   s    r   ÚitemszOrderedDict.itemsİ   s   € å$ TÑ*Ô*Ğ*r   c                 ó    — t          | ¦  «        S )z6D.values() -> an object providing a view on D's values)r+   r   s    r   ÚvalueszOrderedDict.valuesá   s   € å% dÑ+Ô+Ğ+r   c                 ó  — | j         }t                               | ||¦  «        }||urF| j                             |¦  «        }|j        }|j        }||_        ||_        d|_        d|_        |S ||u rt          |¦  «        ‚|S )z²od.pop(k[,d]) -> v, remove specified key and return the corresponding
        value.  If key is not found, d is returned if given, otherwise KeyError
        is raised.

        N)Ú_OrderedDict__markerrT   rG   r9   r/   r0   rV   )r   r)   ÚdefaultÚmarkerÚresultrC   rI   rJ   s           r   rG   zOrderedDict.popé   s‰   € ğ ”ˆİ—’˜$  VÑ,Ô,ˆØ˜ĞĞà”:—>’> #Ñ&Ô&ˆDØœ	ˆIØœ	ˆIØ&ˆIŒNØ&ˆIŒNØˆDŒIØˆDŒIØˆMØfĞĞİ˜3‘-”-ĞØˆr   Nc                 ó(   — || v r| |         S || |<   |S )z™Insert key with a value of default if key is not in the dictionary.

        Return the value for key if key is in the dictionary, else default.
        r$   ©r   r)   ro   s      r   Ú
setdefaultzOrderedDict.setdefaultÿ   s%   € ğ
 $ˆ;ˆ;Ø˜”9ĞØˆˆS‰	Øˆr   c                 ó†   — | s| j         j        ›dS | j         j        ›dt          |                      ¦   «         ¦  «        ›dS )zod.__repr__() <==> repr(od)ú()ú(ú))Ú	__class__r!   Úlistrj   r   s    r   Ú__repr__zOrderedDict.__repr__	  sL   € ğ ğ 	7Ø!œ^Ô4Ğ4Ğ4Ğ6Ğ6Øœ>Ô2Ğ2Ğ2µD¸¿º¹¼Ñ4FÔ4FĞ4FĞ4FĞGĞGr   c                 ó¸  — |                       ¦   «         }|ršt          |t          ¦  «        r|\  }}ni }|                     ¦   «         }|                     ¦   «         }t	          t          ¦   «         ¦  «        D ].}|                     |d¦  «         |                     |d¦  «         Œ/|r||f}n|pd}| j        d|dt          |  	                    ¦   «         ¦  «        fS )z%Return state information for picklingNr$   )
Ú__getstate__Ú
isinstanceÚtupleÚcopyÚvarsr   rG   ry   Úiterrj   )r   ÚstateÚslotsÚks       r   Ú
__reduce__zOrderedDict.__reduce__  sÜ   € à×!Ò!Ñ#Ô#ˆØğ 	&İ˜%¥Ñ'Ô'ğ Ø$‘uuàØ—J’J‘L”LˆEØ—J’J‘L”LˆEİ+™-œ-Ñ(Ô(ğ #ğ #Ø—	’	˜!˜TÑ"Ô"Ğ"Ø—	’	˜!˜TÑ"Ô"Ğ"Ğ"Øğ &Ø˜u˜à˜ ØŒ~˜r 5¨$µ°T·Z²Z±\´\Ñ0BÔ0BĞBĞBr   c                 ó,   — |                       | ¦  «        S )z!od.copy() -> a shallow copy of od©ry   r   s    r   r€   zOrderedDict.copy#  ó   € à~Š~˜dÑ#Ô#Ğ#r   c                 ó.   —  | ¦   «         }|D ]}|||<   Œ|S )zYCreate a new ordered dictionary with keys from iterable and values set to value.
        r$   )ÚclsÚiterabler@   r   r)   s        r   ÚfromkeyszOrderedDict.fromkeys'  s.   € ğ ˆs‰uŒuˆØğ 	ğ 	ˆCØˆD‰IˆIØˆr   c                 óŞ   — t          |t          ¦  «        r>t                               | |¦  «        o"t	          t          t          | |¦  «        ¦  «        S t                               | |¦  «        S )z“od.__eq__(y) <==> od==y.  Comparison to another OD is order-sensitive
        while comparison to a regular mapping is order-insensitive.

        )r~   r   rT   Ú__eq__ÚallÚmapÚ_eq©r   r;   s     r   r   zOrderedDict.__eq__0  sX   € õ
 e[Ñ)Ô)ğ 	Kİ—;’;˜t UÑ+Ô+ĞJµµC½¸TÀ5Ñ4IÔ4IÑ0JÔ0JĞJİ{Š{˜4 Ñ'Ô'Ğ'r   c                 ó0   — |                       |¦  «         | S r   )Úupdater“   s     r   Ú__ior__zOrderedDict.__ior__9  s   € ØŠEÑÔĞØˆr   c                 ó’   — t          |t          ¦  «        st          S |                      | ¦  «        }|                     |¦  «         |S r   ©r~   rT   ÚNotImplementedry   r•   ©r   r;   Únews      r   Ú__or__zOrderedDict.__or__=  sB   € İ˜%¥Ñ&Ô&ğ 	"İ!Ğ!ØnŠn˜TÑ"Ô"ˆØ
Š
5ÑÔĞØˆ
r   c                 ó’   — t          |t          ¦  «        st          S |                      |¦  «        }|                     | ¦  «         |S r   r˜   rš   s      r   Ú__ror__zOrderedDict.__ror__D  sB   € İ˜%¥Ñ&Ô&ğ 	"İ!Ğ!ØnŠn˜UÑ#Ô#ˆØ
Š
4ÑÔĞØˆ
r   )r$   )Tr   )&r!   r"   r#   Ú__doc__r>   rT   rE   r8   r.   rK   rO   r   rS   rW   r[   rf   Ú_collections_abcÚMutableMappingr•   r:   rh   rj   rl   Ú__ne__Úobjectrn   rG   rt   Ú_recursive_reprr{   r†   r€   Úclassmethodr   r   r–   rœ   r   r$   r   r   r   r   N   sô  € € € € € Ø/Ğ/ğ%ğ %ğ %ğ %ğ "&Ô!1¸Àeğ'ğ 'ğ 'ğ 'ğ -1Ô,<ğ ğ ğ ğ ğğ ğ ğğ ğ ğğ ğ ğğ ğ ğ ğ.ğ ğ ğ ğ2ğ ğ ğ )Ô7Ô>Ğ>€FˆXğ*ğ *ğ *ğ+ğ +ğ +ğ,ğ ,ğ ,ğ Ô,Ô3€Fàˆv‰xŒx€Hà'ğ ğ ğ ğ ğ,ğ ğ ğ ğ €_ÑÔğHğ Hñ ÔğHğCğ Cğ Cğ&$ğ $ğ $ğ ğğ ğ ñ „[ğğ(ğ (ğ (ğğ ğ ğğ ğ ğğ ğ ğ ğ r   r   )r   )Ú_tuplegetterc                 ó>   — t          t          | ¦  «        |¬¦  «        S )N)Údoc)ÚpropertyÚ_itemgetter)Úindexr¨   s     r   ú<lambda>r¬   Z  s   € ¥h­{¸5Ñ/AÔ/AÀsĞ&KÑ&KÔ&K€ r   F)ÚrenameÚdefaultsÚmodulec                ó	  ‡‡‡‡‡‡‡‡‡— t          ‰t          ¦  «        r(‰                     dd¦  «                             ¦   «         Št	          t          t          ‰¦  «        ¦  «        Št          j        t          | ¦  «        ¦  «        } |r|t          ¦   «         }t          ‰¦  «        D ]^\  }}| 
                    ¦   «         r(t          |¦  «        s|                     d¦  «        s||v rd|› ‰|<   |                     |¦  «         Œ_| g‰z   D ]n}t          |¦  «        t          urt          d¦  «        ‚| 
                    ¦   «         st!          d|›¦  «        ‚t          |¦  «        rt!          d|›¦  «        ‚Œot          ¦   «         }‰D ]V}|                     d¦  «        r|st!          d|›¦  «        ‚||v rt!          d|›¦  «        ‚|                     |¦  «         ŒWi }|t#          |¦  «        }t%          |¦  «        t%          ‰¦  «        k    rt          d
¦  «        ‚t'          t)          t	          t+          t)          ‰¦  «        t)          |¦  «        ¦  «        ¦  «        ¦  «        ¦  «        }t#          t          t          j        ‰¦  «        ¦  «        Št%          ‰¦  «        Šd                     ‰¦  «        }	‰dk    r|	dz  }	dd                     d„ ‰D ¦   «         ¦  «        z   dz   Št"          j        Št&          t"          t$          t
          t*          f\  ŠŠŠŠŠ‰i d| › dœ}
d|	› d|	› d}t1          ||
¦  «        }d|_        d| › d|	› d|_        |||_        t8          ˆˆˆfd„¦   «         }d| › d|j        _        ˆˆfd„}d| › d|_        ˆfd„}ˆˆfd„}ˆfd„}||j        ||||fD ]}| › d |j        › |_        Œ| › d|	› dd!‰|||||||‰d"œ}t          ‰¦  «        D ]/\  }}t          j        d#|› ¦  «        }t?          ||¦  «        ||<   Œ0t          | t"          f|¦  «        }|€F	 t          j         d¦  «        j!         "                    d$d%¦  «        }n# tF          t           f$ r Y nw xY w|||_$        |S )&aC  Returns a new subclass of tuple with named fields.

    >>> Point = namedtuple('Point', ['x', 'y'])
    >>> Point.__doc__                   # docstring for the new class
    'Point(x, y)'
    >>> p = Point(11, y=22)             # instantiate with positional args or keywords
    >>> p[0] + p[1]                     # indexable like a plain tuple
    33
    >>> x, y = p                        # unpack like a regular tuple
    >>> x, y
    (11, 22)
    >>> p.x + p.y                       # fields also accessible by name
    33
    >>> d = p._asdict()                 # convert to a dictionary
    >>> d['x']
    11
    >>> Point(**d)                      # convert from a dictionary
    Point(x=11, y=22)
    >>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields
    Point(x=100, y=22)

    ú,ú Ú_z*Type names and field names must be stringsz6Type names and field names must be valid identifiers: z0Type names and field names cannot be a keyword: z-Field names cannot start with an underscore: z"Encountered duplicate field name: Nz(Got more default values than field namesú, r]   rw   c              3   ó    K  — | ]	}|› d V — Œ
dS )z=%rNr$   )Ú.0Únames     r   ú	<genexpr>znamedtuple.<locals>.<genexpr>¦  s(   è è € ĞDĞD° $˜|˜|˜|ĞDĞDĞDĞDĞDĞDr   rx   Únamedtuple_)Ú
_tuple_newÚ__builtins__r!   zlambda _cls, z: _tuple_new(_cls, (z))Ú__new__zCreate new instance of c                 ó‚   •—  ‰| |¦  «        } ‰|¦  «        ‰k    r"t          d‰› dt          |¦  «        › ¦  «        ‚|S )Nz	Expected z arguments, got )Ú	TypeErrorra   )r‹   rŒ   rq   Ú_lenÚ
num_fieldsÚ	tuple_news      €€€r   Ú_makeznamedtuple.<locals>._make¸  sQ   ø€ à˜3 Ñ)Ô)ˆØˆ4‰<Œ<˜:Ò%Ğ%İĞQ¨
ĞQĞQÅCÈÁKÄKĞQĞQÑRÔRĞRØˆr   zMake a new z# object from a sequence or iterablec                ó”   •— |                        ‰|j        ‰| ¦  «        ¦  «        }|rt          dt          |¦  «        ›¦  «        ‚|S )NzGot unexpected field names: )rÂ   rG   Ú
ValueErrorrz   )r   r<   rq   Ú_mapÚfield_namess      €€r   Ú_replaceznamedtuple.<locals>._replaceÂ  sO   ø€ Ø—’˜D˜D ¤¨;¸Ñ=Ô=Ñ>Ô>ˆØğ 	LİĞJ½DÀ¹J¼JĞJĞJÑKÔKĞKØˆr   zReturn a new z2 object replacing specified fields with new valuesc                 ó(   •— | j         j        ‰| z  z   S )z/Return a nicely formatted representation string)ry   r!   )r   Úrepr_fmts    €r   r{   znamedtuple.<locals>.__repr__Ë  s   ø€ àŒ~Ô&¨°D©Ñ8Ğ8r   c                 ó8   •—  ‰ ‰| j         | ¦  «        ¦  «        S )z9Return a new dict which maps field names to their values.)Ú_fields)r   Ú_dictÚ_zips    €€r   Ú_asdictznamedtuple.<locals>._asdictÏ  s!   ø€ àˆuTT˜$œ,¨Ñ-Ô-Ñ.Ô.Ğ.r   c                 ó   •—  ‰| ¦  «        S )z7Return self as a plain tuple.  Used by copy and pickle.r$   )r   Ú_tuples    €r   Ú__getnewargs__z"namedtuple.<locals>.__getnewargs__Ó  s   ø€ àˆvd‰|Œ|Ğr   ú.r$   )rŸ   r2   rË   Ú_field_defaultsr¼   rÂ   rÇ   r{   rÎ   rÑ   Ú__match_args__zAlias for field number r!   Ú__main__)%r~   ÚstrÚreplaceÚsplitrz   r‘   r_   ÚinternÚsetÚ	enumerateÚisidentifierÚ
_iskeywordÚ
startswithÚaddÚtyper¾   rÄ   r   ra   rT   r   ÚzipÚjoinr¼   Úevalr!   rŸ   Ú__defaults__r¥   Ú__func__r#   r¦   Ú	_getframeÚ	f_globalsÚgetr6   r"   )ÚtypenamerÆ   r­   r®   r¯   Úseenr«   r·   Úfield_defaultsÚarg_listÚ	namespaceÚcoder¼   rÂ   rÇ   r{   rÎ   rÑ   ÚmethodÚclass_namespacer¨   rq   rÌ   r¿   rÅ   rĞ   rÍ   rÀ   rÉ   rÁ   s    `                    @@@@@@@@r   r
   r
   \  sé  øøøøøøøøø€ õ4 +sÑ#Ô#ğ <Ø!×)Ò)¨#¨sÑ3Ô3×9Ò9Ñ;Ô;ˆİ•s3 Ñ,Ô,Ñ-Ô-€KİŒ{3˜x™=œ=Ñ)Ô)€Hàğ İ‰uŒuˆİ$ [Ñ1Ô1ğ 	ğ 	‰KˆE4Ø×%Ò%Ñ'Ô'ğ 1İ˜dÑ#Ô#ğ1à—?’? 3Ñ'Ô'ğ1ğ ˜4<<Ø%0¨ [ [˜EÑ"ØHŠHT‰NŒNˆNˆNà
˜[Ñ(ğ 3ğ 3ˆİ‰:Œ:SĞ Ğ İĞHÑIÔIĞIØ× Ò Ñ"Ô"ğ 	7İğ 6Ø-1ğ6ğ 6ñ 7ô 7ğ 7ådÑÔğ 	3İğ 2Ø)-ğ2ğ 2ñ 3ô 3ğ 3ğ	3õ ‰5Œ5€DØğ ğ ˆØ?Š?˜3ÑÔğ 	*¨ğ 	*İğ )Ø $ğ)ğ )ñ *ô *ğ *à4ˆ<ˆ<İĞJÀ$ĞJĞJÑKÔKĞKØŠ‰Œˆˆà€NØĞİ˜‘?”?ˆİˆx‰=Œ=3˜{Ñ+Ô+Ò+Ğ+İĞFÑGÔGĞGİh¥t­Cµ¸Ñ0EÔ0Eİ08¸Ñ0BÔ0Bñ-Dô -Dñ (Eô (Eñ Fô Fñ Gô Gˆõ DœK¨Ñ5Ô5Ñ6Ô6€Kİ[Ñ!Ô!€JØyŠy˜Ñ%Ô%€HØQ‚€ØC‰ˆØT—Y’YĞDĞD¸ĞDÑDÔDÑDÔDÑDÀsÑJ€Hİ”€Iİ&*­Eµ3½½SĞ&@Ñ#€Eˆ64˜˜tğ
  ØØ, (Ğ,Ğ,ğğ €Iğ
 F˜8ĞEĞE¸ĞEĞEĞE€Dİ4˜Ñ#Ô#€GØ €GÔØF°ĞFĞF¸8ĞFĞFĞF€G„OØĞØ'ˆÔåğğ ğ ğ ğ ğ ñ „[ğğ,¨Hğ ,ğ ,ğ ,€E„NÔğğ ğ ğ ğ ğ ğ1¨ğ 1ğ 1ğ 1€HÔğ9ğ 9ğ 9ğ 9ğ 9ğ/ğ /ğ /ğ /ğ /ğ /ğğ ğ ğ ğ ğ 	ØŒØØØØğğ >ğ >ˆğ "*Ğ=Ğ=¨F¬OĞ=Ğ=ˆÔĞğ
 Ğ,Ğ, Ğ,Ğ,Ğ,ØØØ)ØØØØØØ(Ø%ğğ €Oõ ! Ñ-Ô-ğ 9ğ 9‰ˆˆtİŒkĞ;°EĞ;Ğ;Ñ<Ô<ˆİ ,¨U°CÑ 8Ô 8ˆ˜ÑĞå(U˜H oÑ6Ô6€Fğ €~ğ	İ”^ AÑ&Ô&Ô0×4Ò4°ZÀÑLÔLˆFˆFøİ¥
Ğ+ğ 	ğ 	ğ 	ØˆDğ	øøøàĞØ"ˆÔà€Ms   Ğ7-Q% Ñ%Q9Ñ8Q9c                 óB   — | j         }|D ]} ||d¦  «        dz   | |<   ŒdS )z!Tally elements from the iterable.r   r]   N)rè   )ÚmappingrŒ   Úmapping_getÚelems       r   Ú_count_elementsrõ     s>   € à”+€KØğ 1ğ 1ˆØ#˜ D¨!Ñ,Ô,¨qÑ0ˆ‰ˆğ1ğ 1r   )rõ   c                   óì   ‡ — e Zd ZdZd ˆ fd„	Zd„ Zd„ Zd d„Zd„ Ze	d d„¦   «         Z
d ˆ fd	„	Zd d
„Zd„ Zd„ Zˆ fd„Zd„ Zd„ Zd„ Zd„ Zd„ Zd„ Zd„ Zd„ Zd„ Zd„ Zd„ Zd„ Zd„ Zd„ Zd„ Zd„ Zd„ Z d„ Z!ˆ xZ"S )!r   aŸ  Dict subclass for counting hashable items.  Sometimes called a bag
    or multiset.  Elements are stored as dictionary keys and their counts
    are stored as dictionary values.

    >>> c = Counter('abcdeabcdabcaba')  # count elements from a string

