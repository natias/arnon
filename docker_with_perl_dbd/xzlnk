=item Intel C++ Compiler

Experimental support for using Intel C++ Compiler has been added. Edit
F<win32/Makefile> and pick the correct C<CCTYPE> for the Visual C that Intel C
was installed into. Also uncomment C<__ICC> to enable Intel C on Visual C support.
To set up the build environment, from the Start Menu run
IA-32 Visual Studio 20__ mode or Intel 64 Visual Studio 20__ mode as
appropriate. Then run C<nmake> as usual in that prompt box.

Only Intel C++ Compiler v12.1 has been tested. Other versions probably will
work. Using Intel C++ Compiler instead of Visual C has the benefit of C99
compatibility which is needed by some CPAN XS modules, while maintaining
compatibility with Visual C object code and Visual C debugging infrastructure
unlike GCC.

=back

=head2 Building

=over 4

=item *

Make sure you are in the F<win32> subdirectory under the perl toplevel.
This directory contains a F<Makefile> that will work with
versions of C<nmake> that come with Visual C++, and
a GNU make F<GNUmakefile> that will work for all supported compilers.
The defaults in the C<gmake> makefile are set up to build with MinGW/gcc.

=item *

Edit the F<GNUmakefile> (or F<Makefile>, if you're using F<nmake>) and change
the values of I<INST_DRV> and C<INST_TOP>. You can also enable various build
flags. These are explained in the makefiles.

Note that it is generally not a good idea to try to build a C<perl> with
C<INST_DRV> and C<INST_TOP> set to a path that already exists from a previous
build.  In particular, this may cause problems with the
F<lib/ExtUtils/t/Embed.t> test, which attempts to build a test program and
may end up building against the installed C<perl>'s F<lib/CORE> directory
rather than the one being tested.

You will have to make sure that C<CCTYPE> is set correctly and that
C<CCHOME> points to wherever you installed your compiler.  For GCC this
should be the directory that contains the F<bin>, F<include> and
F<lib> directories.

If building with the cross-compiler provided by
mingw-w64.org you'll need to uncomment the line that sets
C<GCCCROSS> in the F<GNUmakefile>. Do this only if it's the cross-compiler,
ie. only if the F<bin> folder doesn't contain a F<gcc.exe>. (The cross-compiler
does not provide a F<gcc.exe>, F<g++.exe>, F<ar.exe>, etc. Instead, all of these
executables are prefixed with C<x86_64-w64-mingw32->.)

The default value for C<CCHOME> in the makefiles for Visual C++
may not be correct for some versions.  Make sure the default exists
and is valid.

If you want build some core extensions statically into C<perl>'s DLL,
specify them in the C<STATIC_EXT> macro.

Be sure to read the instructions near the top of the makefiles carefully.

=item *

Type C<gmake> (or C<nmake> if you are using that version of C<make>).

This should build everything.  Specifically, it will create F<perl.exe>,
F<perl540.dll> at the perl toplevel, and various other extension DLL's
under the F<lib\auto> directory.  If the build fails for any reason, make
sure you have done the previous steps correctly.

To try C<gmake>'s parallel mode, type C<gmake -j2> where C<2> is the maximum number
of parallel jobs you want to run. A number of things in the build process will
run in parallel, but there are serialization points where you will see just 1
CPU maxed out. This is normal.

If you are advanced enough with building C code, here is a suggestion to speed
up building C<perl>, and the later C<make test>. Try to keep your C<PATH> environment
variable with the least number of folders possible (remember to keep your C
compiler's folders there). F<C:\WINDOWS\system32> or F<C:\WINNT\system32>
depending on your OS version should be first folder in C<PATH>, since C<cmd.exe>
is the most commonly launched program during the build and later testing.

=back

=head2 Testing Perl on Windows

Type "gmake test" (or "nmake test").  This will run most
of the tests from the testsuite (many tests will be skipped).

There should be no test failures.

If you build with Visual C++ 2015 or later then F<ext/XS-APItest/t/locale.t>
may crash (after all its tests have passed). This is due to a regression in the
Universal CRT introduced in the Windows 10 April 2018 Update, and will be fixed
in the May 2019 Update, as explained here: L<https://developercommunity.visualstudio.com/content/problem/519486/setlocalelc-numeric-iso-latin-16-fails-then-succee.html>.

If you build with certain versions (e.g. 4.8.1) of gcc from mingw then
F<ext/POSIX/t/time.t> may fail test 17 due to a known bug in those gcc builds:
see L<https://sourceforge.net/p/mingw/bugs/2152/>.

Some test failures may occur if you use a command shell other than the
native "cmd.exe", or if you are building from a path that contains
spaces.  So don't do that.

If you are running the tests from a emacs shell window, you may see
failures in op/stat.t.  Run "gmake test-notty" in that case.

Furthermore, you should make sure that during C<make test> you do not
have any GNU tool packages in your path: some toolkits like Unixutils
include some tools (C<type> for instance) which override the Windows
ones and makes tests fail. Remove them from your path while testing to
avoid these errors.

To see the output of specific failing tests run the harness from the t
directory:

  # assuming you're starting from the win32 directory
  cd ..\win32
  .\perl harness <list of tests>

Please report any other failures as described under L</BUGS AND CAVEATS>.

=head2 Installation of Perl on Windows

Type "gmake install" ("nmake install").  This will
put the newly built perl and the libraries under whatever C<INST_TOP>
points to in the Makefile.  It will also install the pod documentation
under C<$INST_TOP\$INST_VER\lib\pod> and HTML versions of the same
under C<$INST_TOP\$INST_VER\lib\pod\html>.

To use the Perl you just installed you will need to add a new entry to
your PATH environment variable: C<$INST_TOP\bin>, e.g.

    set PATH=c:\perl\bin;%PATH%

If you opted to uncomment C<INST_VER> and C<INST_ARCH> in the makefile
then the installation structure is a little more complicated and you will
need to add two new PATH components instead: C<$INST_TOP\$INST_VER\bin> and
C<$INST_TOP\$INST_VER\bin\$ARCHNAME>, e.g.

    set PATH=c:\perl\5.6.0\bin;c:\perl\5.6.0\bin\MSWin32-x86;%PATH%

=head2 Usage Hints for Perl on Windows

=over 4

=item Environment Variables

The installation paths that you set during the build get compiled
into perl, so you don't have to do anything additional to start
using that perl (except add its location to your PATH variable).

If you put extensions in unusual places, you can set PERL5LIB
to a list of paths separated by semicolons where you want perl
to look for libraries.  Look for descriptions of other environment
variables you can set in L<perlrun>.

You can also control the shell that perl uses to run system() and
backtick commands via PERL5SHELL.  See L<perlrun>.

Perl does not depend on the registry, but it can look up certain default
values if you choose to put them there unless disabled at build time with
USE_NO_REGISTRY.  On Perl process start Perl checks if
C<HKEY_CURRENT_USER\Software\Perl> and C<HKEY_LOCAL_MACHINE\Software\Perl>
exist.  If the keys exists, they will be checked for remainder of the Perl
process's run life for certain entries.  Entries in
C<HKEY_CURRENT_USER\Software\Perl> override entries in
C<HKEY_LOCAL_MACHINE\Software\Perl>.  One or more of the following entries
(of type REG_SZ or REG_EXPAND_SZ) may be set in the keys:

 lib-$]        version-specific standard library path to add to @INC
 lib           standard library path to add to @INC
 sitelib-$]    version-specific site library path to add to @INC
 sitelib       site library path to add to @INC
 vendorlib-$]  version-specific vendor library path to add to @INC
 vendorlib     vendor library path to add to @INC
 PERL*         fallback for all %ENV lookups that begin with "PERL"

Note the C<$]> in the above is not literal.  Substitute whatever version
of perl you want to honor that entry, e.g. C<5.6.0>.  Paths must be
separated with semicolons, as usual on Windows.

=item File Globbing

By default, perl handles file globbing using the File::Glob extension,
which provides portable globbing.

If you want perl to use globbing that emulates the quirks of DOS
filename conventions, you might want to consider using File::DosGlob
to override the internal glob() implementation.  See L<File::DosGlob> for
details.

=item Using perl from the command line

If you are accustomed to using perl from various command-line
shells found in UNIX environments, you will be less than pleased
with what Windows offers by way of a command shell.

The crucial thing to understand about the Windows environment is that
the command line you type in is processed twice before Perl sees it.
First, your command shell (usually CMD.EXE) preprocesses the command
line, to handle redirection, environment variable expansion, and
location of the executable to run. Then, the perl executable splits
the remaining command line into individual arguments, using the
C runtime library upon which Perl was built.

It is particularly important to note that neither the shell nor the C
runtime do any wildcard expansions of command-line arguments (so
wildcards need not be quoted).  Also, the quoting behaviours of the
shell and the C runtime are rudimentary at best (and may, if you are
using a non-standard shell, be inconsistent).  The only (useful) quote
character is the double quote (").  It can be used to protect spaces
and other special characters in arguments.

The Windows documentation describes the shell parsing rules here:
L<https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/cmd>
and the C runtime parsing rules here:
L<https://msdn.microsoft.com/en-us/library/17w5ykft%28v=VS.100%29.aspx>.

Here are some further observations based on experiments: The C runtime
breaks arguments at spaces and passes them to programs in argc/argv.
Double quotes can be used to prevent arguments with spaces in them from
being split up.  You can put a double quote in an argument by escaping
it with a backslash and enclosing the whole argument within double quotes.
The backslash and the pair of double quotes surrounding the argument will
be stripped by the C runtime.

The file redirection characters "E<lt>", "E<gt>", and "|" can be quoted by
double quotes (although there are suggestions that this may not always
be true).  Single quotes are not treated as quotes by the shell or
the C runtime, they don't get stripped by the shell (just to make
this type of quoting completely useless).  The caret "^" has also
been observed to behave as a quoting character, but this appears
to be a shell feature, and the caret is not stripped from the command
line, so Perl still sees it (and the C runtime phase does not treat
the caret as a quote character).

Here are some examples of usage of the "cmd" shell:

This prints two doublequotes:

    perl -e "print '\"\"' "

This does the same:

    perl -e "print \"\\\"\\\"\" "

This prints "bar" and writes "foo" to the file "blurch":

    perl -e "print 'foo'; print STDERR 'bar'" > blurch

This prints "foo" ("bar" disappears into nowhereland):

    perl -e "print 'foo'; print STDERR 'bar'" 2> nul

This prints "bar" and writes "foo" into the file "blurch":

    perl -e "print 'foo'; print STDERR 'bar'" 1> blurch

This pipes "foo" to the "less" pager and prints "bar" on the console:

    perl -e "print 'foo'; print STDERR 'bar'" | less

This pipes "foo\nbar\n" to the less pager:

    perl -le "print 'foo'; print STDERR 'bar'" 2>&1 | less

This pipes "foo" to the pager and writes "bar" in the file "blurch":

    perl -e "print 'foo'; print STDERR 'bar'" 2> blurch | less


Discovering the usefulness of the "command.com" shell on Windows 9x
is left as an exercise to the reader :)

One particularly pernicious problem with the 4NT command shell for
Windows is that it (nearly) always treats a % character as indicating
that environment variable expansion is needed.  Under this shell, it is
therefore important to always double any % characters which you want
Perl to see (for example, for hash variables), even when they are
quoted.

=item Building Extensions

The Comprehensive Perl Archive Network (CPAN) offers a wealth
of extensions, some of which require a C compiler to build.
Look in L<https://www.cpan.org/> for more information on CPAN.

Note that not all of the extensions available from CPAN may work
in the Windows environment; you should check the information at
L<https://www.cpantesters.org/> before investing too much effort into
porting modules that don't readily build.

Most extensions (whether they require a C compiler or not) can
be built, tested and installed with the standard mantra:

    perl Makefile.PL
    $MAKE
    $MAKE test
    $MAKE install

where $MAKE is whatever 'make' program you have configured perl to
use.  Use "perl -V:make" to find out what this is.  Some extensions
may not provide a testsuite (so "$MAKE test" may not do anything or
fail), but most serious ones do.

It is important that you use a supported 'make' program, and
ensure Config.pm knows about it.

Note that MakeMaker actually emits makefiles with different syntax
depending on what 'make' it thinks you are using.  Therefore, it is
important that one of the following values appears in Config.pm:

    make='nmake'	# MakeMaker emits nmake syntax
    any other value	# MakeMaker emits generic make syntax
    			    (e.g GNU make, or Perl make)

If the value doesn't match the 'make' program you want to use,
edit Config.pm to fix it.

If a module implements XSUBs, you will need one of the supported
C compilers.  You must make sure you have set up the environment for
the compiler for command-line compilation before running C<perl Makefile.PL>
or any invocation of make.

If a module does not build for some reason, look carefully for
why it failed, and report problems to the module author.  If
it looks like the extension building support is at fault, report
that with full details of how the build failed using the GitHub
issue tracker at L<https://github.com/Perl/perl5/issues>.

=item Command-line Wildcard Expansion

The default command shells on DOS descendant operating systems (such
as they are) usually do not expand wildcard arguments supplied to
programs.  They consider it the application's job to handle that.
This is commonly achieved by linking the application (in our case,
perl) with startup code that the C runtime libraries usually provide.
However, doing that results in incompatible perl versions (since the
behavior of the argv expansion code differs depending on the
compiler, and it is even buggy on some compilers).  Besides, it may
be a source of frustration if you use such a perl binary with an
alternate shell that *does* expand wildcards.

Instead, the following solution works rather well. The nice things
about it are 1) you can start using it right away; 2) it is more
powerful, because it will do the right thing with a pattern like
*/*/*.c; 3) you can decide whether you do/don't want to use it; and
4) you can extend the method to add any customizations (or even
entirely different kinds of wildcard expansion).

 C:\> copy con c:\perl\lib\Wild.pm
 # Wild.pm - emulate shell @ARGV expansion on shells that don't
 use File::DosGlob;
 @ARGV = map {
	      my @g = File::DosGlob::glob($_) if /[*?]/;
	      @g ? @g : $_;
	    } @ARGV;
 1;
 ^Z
 C:\> set PERL5OPT=-MWild
 C:\> perl -le "for (@ARGV) { print }" */*/perl*.c
 p4view/perl/perl.c
 p4view/perl/perlio.c
 p4view/perl/perly.c
 perl5.005/win32/perlglob.c
 perl5.005/win32/perllib.c
 perl5.005/win32/perlglob.c
 perl5.005/win32/perllib.c
 perl5.005/win32/perlglob.c
 perl5.005/win32/perllib.c

Note there are two distinct steps there: 1) You'll have to create
Wild.pm and put it in your perl lib directory. 2) You'll need to
set the PERL5OPT environment variable.  If you want argv expansion
to be the default, just set PERL5OPT in your default startup
environment.

If you are using the Visual C compiler, you can get the C runtime's
command line wildcard expansion built into perl binary.  The resulting
binary will always expand unquoted command lines, which may not be
what you want if you use a shell that does that for you.  The expansion
done is also somewhat less powerful than the approach suggested above.

=item Notes on 64-bit Windows

Windows .NET Server supports the LLP64 data model on the Intel Itanium
architecture.

The LLP64 data model is different from the LP64 data model that is the
norm on 64-bit Unix platforms.  In the former, C<int> and C<long> are
both 32-bit data types, while pointers are 64 bits wide.  In addition,
there is a separate 64-bit wide integral type, C<__int64>.  In contrast,
the LP64 data model that is pervasive on Unix platforms provides C<int>
as the 32-bit type, while both the C<long> type and pointers are of
64-bit precision.  Note that both models provide for 64-bits of
addressability.

64-bit Windows running on Itanium is capable of running 32-bit x86
binaries transparently.  This means that you could use a 32-bit build
of Perl on a 64-bit system.  Given this, why would one want to build
a 64-bit build of Perl?  Here are some reasons why you would bother:

=over

=item *

A 64-bit native application will run much more efficiently on
Itanium hardware.

=item *

There is no 2GB limit on process size.

=item *

Perl automatically provides large file support when built under
64-bit Windows.

=item *

Embedding Perl inside a 64-bit application.

=back

=back

=head2 Running Perl Scripts

Perl scripts on UNIX use the "#!" (a.k.a "shebang") line to
indicate to the OS that it should execute the file using perl.
Windows has no comparable means to indicate arbitrary files are
executables.

Instead, all available methods to execute plain text files on
Windows rely on the file "extension".  There are three methods
to use this to execute perl scripts:

=over 8

=item 1

There is a facility called "file extension associations".  This can be
manipulated via the two commands "assoc" and "ftype" that come
standard with Windows.  Type "ftype /?" for a complete example of how
to set this up for perl scripts (Say what?  You thought Windows
wasn't perl-ready? :).

=item 2

Since file associations don't work everywhere, and there are
reportedly bugs with file associations where it does work, the
old method of wrapping the perl script to make it look like a
regular batch file to the OS, may be used.  The install process
makes available the "pl2bat.bat" script which can be used to wrap
perl scripts into batch files.  For example:

	pl2bat foo.pl

will create the file "FOO.BAT".  Note "pl2bat" strips any
.pl suffix and adds a .bat suffix to the generated file.

If you use the 4DOS/NT or similar command shell, note that
"pl2bat" uses the "%*" variable in the generated batch file to
refer to all the command line arguments, so you may need to make
sure that construct works in batch files.  As of this writing,
4DOS/NT users will need a "ParameterChar = *" statement in their
4NT.INI file or will need to execute "setdos /p*" in the 4DOS/NT
startup file to enable this to work.

=item 3

Using "pl2bat" has a few problems:  the file name gets changed,
so scripts that rely on C<$0> to find what they must do may not
run properly; running "pl2bat" replicates the contents of the
original script, and so this process can be maintenance intensive
if the originals get updated often.  A different approach that
avoids both problems is possible.

A script called "runperl.bat" is available that can be copied
to any filename (along with the .bat suffix).  For example,
if you call it "foo.bat", it will run the file "foo" when it is
executed.  Since you can run batch files on Windows platforms simply
by typing the name (without the extension), this effectively
runs the file "foo", when you type either "foo" or "foo.bat".
With this method, "foo.bat" can even be in a different location
than the file "foo", as long as "foo" is available somewhere on
the PATH.  If your scripts are on a filesystem that allows symbolic
links, you can even avoid copying "runperl.bat".

Here's a diversion:  copy "runperl.bat" to "runperl", and type
"runperl".  Explain the observed behavior, or lack thereof. :)
Hint: .gnidnats llits er'uoy fi ,"lrepnur" eteled :tniH

=back

=head2 Miscellaneous Things

A full set of HTML documentation is installed, so you should be
able to use it if you have a web browser installed on your
system.

C<perldoc> is also a useful tool for browsing information contained
in the documentation, especially in conjunction with a pager
like C<less> (recent versions of which have Windows support).  You may
have to set the PAGER environment variable to use a specific pager.
"perldoc -f foo" will print information about the perl operator
"foo".

One common mistake when using this port with a GUI library like C<Tk>
is assuming that Perl's normal behavior of opening a command-line
window will go away.  This isn't the case.  If you want to start a copy
of C<perl> without opening a command-line window, use the C<wperl>
executable built during the installation process.  Usage is exactly
the same as normal C<perl> on Windows, except that options like C<-h>
don't work (since they need a command-line window to print to).

If you find bugs in perl, you can report them to
L<https://github.com/Perl/perl5/issues>.

=head1 BUGS AND CAVEATS

Norton AntiVirus interferes with the build process, particularly if
set to "AutoProtect, All Files, when Opened". Unlike large applications
the perl build process opens and modifies a lot of files. Having the
AntiVirus scan each and every one slows build the process significantly.
Worse, with PERLIO=stdio the build process fails with peculiar messages
as the virus checker interacts badly with miniperl.exe writing configure
files (it seems to either catch file part written and treat it as suspicious,
or virus checker may have it "locked" in a way which inhibits miniperl
updating it). The build does complete with

   set PERLIO=perlio

but that may be just luck. Other AntiVirus software may have similar issues.

A git GUI shell extension for Windows such as TortoiseGit will cause the build
and later C<make test> to run much slower since every file is checked for its
git status as soon as it is created and/or modified. TortoiseGit doesn't cause
any test failures or build problems unlike the antivirus software described
above, but it does cause similar slowness. It is suggested to use Task Manager
to look for background processes which use high CPU amounts during the building
process.

Some of the built-in functions do not act exactly as documented in
L<perlfunc>, and a few are not implemented at all.  To avoid
surprises, particularly if you have had prior exposure to Perl
in other operating environments or if you intend to write code
that will be portable to other environments, see L<perlport>
for a reasonably definitive list of these differences.

Not all extensions available from CPAN may build or work properly
in the Windows environment.  See L</"Building Extensions">.

Most C<socket()> related calls are supported, but they may not
behave as on Unix platforms.  See L<perlport> for the full list.

Signal handling may not behave as on Unix platforms (where it
doesn't exactly "behave", either :).  For instance, calling C<die()>
or C<exit()> from signal handlers will cause an exception, since most
implementations of C<signal()> on Windows are severely crippled.
Thus, signals may work only for simple things like setting a flag
variable in the handler.  Using signals under this port should
currently be considered unsupported.

Please report detailed descriptions of any problems and solutions that
you may find at E<lt>L<https://github.com/Perl/perl5/issues>E<gt>,
along with the output produced by C<perl -V>.

=head1 ACKNOWLEDGEMENTS

The use of a camel with the topic of Perl is a trademark
of O'Reilly and Associates, Inc. Used with permission.

=head1 AUTHORS

=over 4

=item Gary Ng E<lt>71564.1743@CompuServe.COME<gt>

=item Gurusamy Sarathy E<lt>gsar@activestate.comE<gt>

=item Nick Ing-Simmons E<lt>nick@ing-simmons.netE<gt>

=item Jan Dubois E<lt>jand@activestate.comE<gt>

=item Steve Hay E<lt>steve.m.hay@googlemail.comE<gt>

=back

This document is maintained by Jan Dubois.

=head1 SEE ALSO

L<perl>

=head1 HISTORY

This port was originally contributed by Gary Ng around 5.003_24,
and borrowed from the Hip Communications port that was available
at the time.  Various people have made numerous and sundry hacks
since then.

GCC/mingw32 support was added in 5.005 (Nick Ing-Simmons).

Support for PERL_OBJECT was added in 5.005 (ActiveState Tool Corp).

Support for fork() emulation was added in 5.6 (ActiveState Tool Corp).

Win9x support was added in 5.6 (Benjamin Stuhl).

Support for 64-bit Windows added in 5.8 (ActiveState Corp).

Last updated: 06 October 2021

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                               usr/local/lib/perl5/5.40.0/pod/perlxs.pod                                                           0000644 0000000 0000000 00000226425 14714567415 016324  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =head1 NAME

perlxs - XS language reference manual

=head1 DESCRIPTION

=head2 Introduction

XS is an interface description file format used to create an extension
interface between Perl and C code (or a C library) which one wishes
to use with Perl.  The XS interface is combined with the library to
create a new library which can then be either dynamically loaded
or statically linked into perl.  The XS interface description is
written in the XS language and is the core component of the Perl
extension interface.

This documents the XS language, but it's important to first note that XS
code has full access to system calls including C library functions.  It
thus has the capability of interfering with things that the Perl core or
other modules have set up, such as signal handlers or file handles.  It
could mess with the memory, or any number of harmful things.  Don't.
Further detail is in L<perlclib>, which you should read before actually
writing any production XS.

An B<XSUB> forms the basic unit of the XS interface.  After compilation
by the B<xsubpp> compiler, each XSUB amounts to a C function definition
which will provide the glue between Perl calling conventions and C
calling conventions.

The glue code pulls the arguments from the Perl stack, converts these
Perl values to the formats expected by a C function, calls this C function,
and then transfers the return values of the C function back to Perl.
Return values here may be a conventional C return value or any C
function arguments that may serve as output parameters.  These return
values may be passed back to Perl either by putting them on the
Perl stack, or by modifying the arguments supplied from the Perl side.

The above is a somewhat simplified view of what really happens.  Since
Perl allows more flexible calling conventions than C, XSUBs may do much
more in practice, such as checking input parameters for validity,
throwing exceptions (or returning undef/empty list) if the return value
from the C function indicates failure, calling different C functions
based on numbers and types of the arguments, providing an object-oriented
interface, etc.

Of course, one could write such glue code directly in C.  However, this
would be a tedious task, especially if one needs to write glue for
multiple C functions, and/or one is not familiar enough with the Perl
stack discipline and other such arcana.  XS comes to the rescue here:
instead of writing this glue C code in long-hand, one can write
a more concise short-hand I<description> of what should be done by
the glue, and let the XS compiler B<xsubpp> handle the rest.

The XS language allows one to describe the mapping between how the C
routine is used, and how the corresponding Perl routine is used.  It
also allows creation of Perl routines which are directly translated to
C code and which are not related to a pre-existing C function.  In cases
when the C interface coincides with the Perl interface, the XSUB
declaration is almost identical to a declaration of a C function (in K&R
style).  In such circumstances, there is another tool called C<h2xs>
that is able to translate an entire C header file into a corresponding
XS file that will provide glue to the functions/macros described in
the header file.

The XS compiler is called B<xsubpp>.  This compiler creates
the constructs necessary to let an XSUB manipulate Perl values, and
creates the glue necessary to let Perl call the XSUB.  The compiler
uses B<typemaps> to determine how to map C function parameters
and output values to Perl values and back.  The default typemap
(which comes with Perl) handles many common C types.  A supplementary
typemap may also be needed to handle any special structures and types
for the library being linked. For more information on typemaps,
see L<perlxstypemap>.

A file in XS format starts with a C language section which goes until the
first C<MODULE =Z<>> directive.  Other XS directives and XSUB definitions
may follow this line.  The "language" used in this part of the file
is usually referred to as the XS language.  B<xsubpp> recognizes and
skips POD (see L<perlpod>) in both the C and XS language sections, which
allows the XS file to contain embedded documentation.

See L<perlxstut> for a tutorial on the whole extension creation process.

Note: For some extensions, Dave Beazley's SWIG system may provide a
significantly more convenient mechanism for creating the extension
glue code.  See L<http://www.swig.org/> for more information.

For simple bindings to C libraries as well as other machine code libraries,
consider instead using the much simpler
L<libffi|http://sourceware.org/libffi/> interface via CPAN modules like
L<FFI::Platypus> or L<FFI::Raw>.

=head2 On The Road

Many of the examples which follow will concentrate on creating an interface
between Perl and the ONC+ RPC bind library functions.  The rpcb_gettime()
function is used to demonstrate many features of the XS language.  This
function has two parameters; the first is an input parameter and the second
is an output parameter.  The function also returns a status value.

	bool_t rpcb_gettime(const char *host, time_t *timep);

From C this function will be called with the following
statements.

     #include <rpc/rpc.h>
     bool_t status;
     time_t timep;
     status = rpcb_gettime( "localhost", &timep );

If an XSUB is created to offer a direct translation between this function
and Perl, then this XSUB will be used from Perl with the following code.
The $status and $timep variables will contain the output of the function.

     use RPC;
     $status = rpcb_gettime( "localhost", $timep );

The following XS file shows an XS subroutine, or XSUB, which
demonstrates one possible interface to the rpcb_gettime()
function.  This XSUB represents a direct translation between
C and Perl and so preserves the interface even from Perl.
This XSUB will be invoked from Perl with the usage shown
above.  Note that the first three #include statements, for
C<EXTERN.h>, C<perl.h>, and C<XSUB.h>, will always be present at the
beginning of an XS file.  This approach and others will be
expanded later in this document.  A #define for C<PERL_NO_GET_CONTEXT>
should be present to fetch the interpreter context more efficiently,
see L<perlguts|perlguts/How multiple interpreters and concurrency are
supported> for details.

     #define PERL_NO_GET_CONTEXT
     #include "EXTERN.h"
     #include "perl.h"
     #include "XSUB.h"
     #include <rpc/rpc.h>

     MODULE = RPC  PACKAGE = RPC

     bool_t
     rpcb_gettime(host,timep)
          char *host
          time_t &timep
        OUTPUT:
          timep

Any extension to Perl, including those containing XSUBs,
should have a Perl module to serve as the bootstrap which
pulls the extension into Perl.  This module will export the
extension's functions and variables to the Perl program and
will cause the extension's XSUBs to be linked into Perl.
The following module will be used for most of the examples
in this document and should be used from Perl with the C<use>
command as shown earlier.  Perl modules are explained in
more detail later in this document.

     package RPC;

     require Exporter;
     require DynaLoader;
     @ISA = qw(Exporter DynaLoader);
     @EXPORT = qw( rpcb_gettime );

     bootstrap RPC;
     1;

Throughout this document a variety of interfaces to the rpcb_gettime()
XSUB will be explored.  The XSUBs will take their parameters in different
orders or will take different numbers of parameters.  In each case the
XSUB is an abstraction between Perl and the real C rpcb_gettime()
function, and the XSUB must always ensure that the real rpcb_gettime()
function is called with the correct parameters.  This abstraction will
allow the programmer to create a more Perl-like interface to the C
function.

=head2 The Anatomy of an XSUB

The simplest XSUBs consist of 3 parts: a description of the return
value, the name of the XSUB routine and the names of its arguments,
and a description of types or formats of the arguments.

The following XSUB allows a Perl program to access a C library function
called sin().  The XSUB will imitate the C function which takes a single
argument and returns a single value.

     double
     sin(x)
       double x

Optionally, one can merge the description of types and the list of
argument names, rewriting this as

     double
     sin(double x)

This makes this XSUB look similar to an ANSI C declaration.  An optional
semicolon is allowed after the argument list, as in

     double
     sin(double x);

Parameters with C pointer types can have different semantic: C functions
with similar declarations

     bool string_looks_as_a_number(char *s);
     bool make_char_uppercase(char *c);

are used in absolutely incompatible manner.  Parameters to these functions
could be described to B<xsubpp> like this:

     char *  s
     char    &c

Both these XS declarations correspond to the C<char*> C type, but they have
different semantics, see L<"The & Unary Operator">.

It is convenient to think that the indirection operator
C<*> should be considered as a part of the type and the address operator C<&>
should be considered part of the variable.  See L<perlxstypemap>
for more info about handling qualifiers and unary operators in C types.

The function name and the return type must be placed on
separate lines and should be flush left-adjusted.

  INCORRECT                        CORRECT

  double sin(x)                    double
    double x                       sin(x)
				     double x

The rest of the function description may be indented or left-adjusted. The
following example shows a function with its body left-adjusted.  Most
examples in this document will indent the body for better readability.

  CORRECT

  double
  sin(x)
  double x

More complicated XSUBs may contain many other sections.  Each section of
an XSUB starts with the corresponding keyword, such as INIT: or CLEANUP:.
However, the first two lines of an XSUB always contain the same data:
descriptions of the return type and the names of the function and its
parameters.  Whatever immediately follows these is considered to be
an INPUT: section unless explicitly marked with another keyword.
(See L<The INPUT: Keyword>.)

An XSUB section continues until another section-start keyword is found.

=head2 The Argument Stack

The Perl argument stack is used to store the values which are
sent as parameters to the XSUB and to store the XSUB's
return value(s).  In reality all Perl functions (including non-XSUB
ones) keep their values on this stack all the same time, each limited
to its own range of positions on the stack.  In this document the
first position on that stack which belongs to the active
function will be referred to as position 0 for that function.

XSUBs refer to their stack arguments with the macro B<ST(x)>, where I<x>
refers to a position in this XSUB's part of the stack.  Position 0 for that
function would be known to the XSUB as ST(0).  The XSUB's incoming
parameters and outgoing return values always begin at ST(0).  For many
simple cases the B<xsubpp> compiler will generate the code necessary to
handle the argument stack by embedding code fragments found in the
typemaps.  In more complex cases the programmer must supply the code.

=head2 The RETVAL Variable

The RETVAL variable is a special C variable that is declared automatically
for you.  The C type of RETVAL matches the return type of the C library
function.  The B<xsubpp> compiler will declare this variable in each XSUB
with non-C<void> return type.  By default the generated C function
will use RETVAL to hold the return value of the C library function being
called.  In simple cases the value of RETVAL will be placed in ST(0) of
the argument stack where it can be received by Perl as the return value
of the XSUB.

If the XSUB has a return type of C<void> then the compiler will
not declare a RETVAL variable for that function.  When using
a PPCODE: section no manipulation of the RETVAL variable is required, the
section may use direct stack manipulation to place output values on the stack.

If PPCODE: directive is not used, C<void> return value should be used
only for subroutines which do not return a value, I<even if> CODE:
directive is used which sets ST(0) explicitly.

Older versions of this document recommended to use C<void> return
value in such cases. It was discovered that this could lead to
segfaults in cases when XSUB was I<truly> C<void>. This practice is
now deprecated, and may be not supported at some future version. Use
the return value C<SV *> in such cases. (Currently C<xsubpp> contains
some heuristic code which tries to disambiguate between "truly-void"
and "old-practice-declared-as-void" functions. Hence your code is at
mercy of this heuristics unless you use C<SV *> as return value.)

=head2 Returning SVs, AVs and HVs through RETVAL

When you're using RETVAL to return an C<SV *>, there's some magic
going on behind the scenes that should be mentioned. When you're
manipulating the argument stack using the ST(x) macro, for example,
you usually have to pay special attention to reference counts. (For
more about reference counts, see L<perlguts>.) To make your life
easier, the typemap file automatically makes C<RETVAL> mortal when
you're returning an C<SV *>. Thus, the following two XSUBs are more
or less equivalent:

  void
  alpha()
      PPCODE:
          ST(0) = newSVpv("Hello World",0);
          sv_2mortal(ST(0));
          XSRETURN(1);

  SV *
  beta()
      CODE:
          RETVAL = newSVpv("Hello World",0);
      OUTPUT:
          RETVAL

This is quite useful as it usually improves readability. While
this works fine for an C<SV *>, it's unfortunately not as easy
to have C<AV *> or C<HV *> as a return value. You I<should> be
able to write:

  AV *
  array()
      CODE:
          RETVAL = newAV();
          /* do something with RETVAL */
      OUTPUT:
          RETVAL

But due to an unfixable bug (fixing it would break lots of existing
CPAN modules) in the typemap file, the reference count of the C<AV *>
is not properly decremented. Thus, the above XSUB would leak memory
whenever it is being called. The same problem exists for C<HV *>,
C<CV *>, and C<SVREF> (which indicates a scalar reference, not
a general C<SV *>).
In XS code on perls starting with perl 5.16, you can override the
typemaps for any of these types with a version that has proper
handling of refcounts. In your C<TYPEMAP> section, do

  AV*	T_AVREF_REFCOUNT_FIXED

to get the repaired variant. For backward compatibility with older
versions of perl, you can instead decrement the reference count
manually when you're returning one of the aforementioned
types using C<sv_2mortal>:

  AV *
  array()
      CODE:
          RETVAL = newAV();
          sv_2mortal((SV*)RETVAL);
          /* do something with RETVAL */
      OUTPUT:
          RETVAL

Remember that you don't have to do this for an C<SV *>. The reference
documentation for all core typemaps can be found in L<perlxstypemap>.

=head2 The MODULE Keyword

The MODULE keyword is used to start the XS code and to specify the package
of the functions which are being defined.  All text preceding the first
MODULE keyword is considered C code and is passed through to the output with
POD stripped, but otherwise untouched.  Every XS module will have a
bootstrap function which is used to hook the XSUBs into Perl.  The package
name of this bootstrap function will match the value of the last MODULE
statement in the XS source files.  The value of MODULE should always remain
constant within the same XS file, though this is not required.

The following example will start the XS code and will place
all functions in a package named RPC.

     MODULE = RPC

=head2 The PACKAGE Keyword

When functions within an XS source file must be separated into packages
