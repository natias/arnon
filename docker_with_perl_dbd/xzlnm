Instead of writing an overloaded interface using pure Perl, you
can also use the OVERLOAD keyword to define additional Perl names
for your functions (like the ALIAS: keyword above).  However, the
overloaded functions must be defined in such a way as to accept the number
of parameters supplied by perl's overload system.  For most overload
methods, it will be three parameters; for the C<nomethod> function it will
be four.  However, the bitwise operators C<&>, C<|>, C<^>, and C<~> may be
called with three I<or> five arguments (see L<overload>).

If any
function has the OVERLOAD: keyword, several additional lines
will be defined in the c file generated by xsubpp in order to
register with the overload magic.

Since blessed objects are actually stored as RV's, it is useful
to use the typemap features to preprocess parameters and extract
the actual SV stored within the blessed RV.  See the sample for
T_PTROBJ_SPECIAL in L<perlxstypemap>.

To use the OVERLOAD: keyword, create an XS function which takes
three input parameters (or use the C-style '...' definition) like
this:

    SV *
    cmp (lobj, robj, swap)
    My_Module_obj    lobj
    My_Module_obj    robj
    IV               swap
    OVERLOAD: cmp <=>
    { /* function defined here */}

In this case, the function will overload both of the three way
comparison operators.  For all overload operations using non-alpha
characters, you must type the parameter without quoting, separating
multiple overloads with whitespace.  Note that "" (the stringify
overload) should be entered as \"\" (i.e. escaped).

Since, as mentioned above, bitwise operators may take extra arguments, you
may want to use something like C<(lobj, robj, swap, ...)> (with
literal C<...>) as your parameter list.

=head2 The FALLBACK: Keyword

In addition to the OVERLOAD keyword, if you need to control how
Perl autogenerates missing overloaded operators, you can set the
FALLBACK keyword in the module header section, like this:

    MODULE = RPC  PACKAGE = RPC

    FALLBACK: TRUE
    ...

where FALLBACK can take any of the three values TRUE, FALSE, or
UNDEF.  If you do not set any FALLBACK value when using OVERLOAD,
it defaults to UNDEF.  FALLBACK is not used except when one or
more functions using OVERLOAD have been defined.  Please see
L<overload/fallback> for more details.

=head2 The INTERFACE: Keyword

This keyword declares the current XSUB as a keeper of the given
calling signature.  If some text follows this keyword, it is
considered as a list of functions which have this signature, and
should be attached to the current XSUB.

For example, if you have 4 C functions multiply(), divide(), add(),
subtract() all having the signature:

    symbolic f(symbolic, symbolic);

you can make them all to use the same XSUB using this:

    symbolic
    interface_s_ss(arg1, arg2)
	symbolic	arg1
	symbolic	arg2
    INTERFACE:
	multiply divide
	add subtract

(This is the complete XSUB code for 4 Perl functions!)  Four generated
Perl function share names with corresponding C functions.

The advantage of this approach comparing to ALIAS: keyword is that there
is no need to code a switch statement, each Perl function (which shares
the same XSUB) knows which C function it should call.  Additionally, one
can attach an extra function remainder() at runtime by using

    CV *mycv = newXSproto("Symbolic::remainder",
			  XS_Symbolic_interface_s_ss, __FILE__, "$$");
    XSINTERFACE_FUNC_SET(mycv, remainder);

say, from another XSUB.  (This example supposes that there was no
INTERFACE_MACRO: section, otherwise one needs to use something else instead of
C<XSINTERFACE_FUNC_SET>, see the next section.)

=head2 The INTERFACE_MACRO: Keyword

This keyword allows one to define an INTERFACE using a different way
to extract a function pointer from an XSUB.  The text which follows
this keyword should give the name of macros which would extract/set a
function pointer.  The extractor macro is given return type, C<CV*>,
and C<XSANY.any_dptr> for this C<CV*>.  The setter macro is given cv,
and the function pointer.

The default value is C<XSINTERFACE_FUNC> and C<XSINTERFACE_FUNC_SET>.
An INTERFACE keyword with an empty list of functions can be omitted if
INTERFACE_MACRO keyword is used.

Suppose that in the previous example functions pointers for
multiply(), divide(), add(), subtract() are kept in a global C array
C<fp[]> with offsets being C<multiply_off>, C<divide_off>, C<add_off>,
C<subtract_off>.  Then one can use

    #define XSINTERFACE_FUNC_BYOFFSET(ret,cv,f) \
	((XSINTERFACE_CVT_ANON(ret))fp[CvXSUBANY(cv).any_i32])
    #define XSINTERFACE_FUNC_BYOFFSET_set(cv,f) \
	CvXSUBANY(cv).any_i32 = CAT2( f, _off )

in C section,

    symbolic
    interface_s_ss(arg1, arg2)
	symbolic	arg1
	symbolic	arg2
      INTERFACE_MACRO:
	XSINTERFACE_FUNC_BYOFFSET
	XSINTERFACE_FUNC_BYOFFSET_set
      INTERFACE:
	multiply divide
	add subtract

in XSUB section.

=head2 The INCLUDE: Keyword

This keyword can be used to pull other files into the XS module.  The other
files may have XS code.  INCLUDE: can also be used to run a command to
generate the XS code to be pulled into the module.

The file F<Rpcb1.xsh> contains our C<rpcb_gettime()> function:

    bool_t
    rpcb_gettime(host,timep)
          char *host
          time_t &timep
        OUTPUT:
          timep

The XS module can use INCLUDE: to pull that file into it.

    INCLUDE: Rpcb1.xsh

If the parameters to the INCLUDE: keyword are followed by a pipe (C<|>) then
the compiler will interpret the parameters as a command. This feature is
mildly deprecated in favour of the C<INCLUDE_COMMAND:> directive, as documented
below.

    INCLUDE: cat Rpcb1.xsh |

Do not use this to run perl: C<INCLUDE: perl |> will run the perl that
happens to be the first in your path and not necessarily the same perl that is
used to run C<xsubpp>. See L<"The INCLUDE_COMMAND: Keyword">.

=head2 The INCLUDE_COMMAND: Keyword

Runs the supplied command and includes its output into the current XS
document. C<INCLUDE_COMMAND> assigns special meaning to the C<$^X> token
in that it runs the same perl interpreter that is running C<xsubpp>:

    INCLUDE_COMMAND: cat Rpcb1.xsh

    INCLUDE_COMMAND: $^X -e ...

=head2 The CASE: Keyword

The CASE: keyword allows an XSUB to have multiple distinct parts with each
part acting as a virtual XSUB.  CASE: is greedy and if it is used then all
other XS keywords must be contained within a CASE:.  This means nothing may
precede the first CASE: in the XSUB and anything following the last CASE: is
included in that case.

A CASE: might switch via a parameter of the XSUB, via the C<ix> ALIAS:
variable (see L<"The ALIAS: Keyword">), or maybe via the C<items> variable
(see L<"Variable-length Parameter Lists">).  The last CASE: becomes the
B<default> case if it is not associated with a conditional.  The following
example shows CASE switched via C<ix> with a function C<rpcb_gettime()>
having an alias C<x_gettime()>.  When the function is called as
C<rpcb_gettime()> its parameters are the usual C<(char *host, time_t *timep)>,
but when the function is called as C<x_gettime()> its parameters are
reversed, C<(time_t *timep, char *host)>.

    long
    rpcb_gettime(a,b)
      CASE: ix == 1
	ALIAS:
	  x_gettime = 1
	INPUT:
	  # 'a' is timep, 'b' is host
          char *b
          time_t a = NO_INIT
        CODE:
               RETVAL = rpcb_gettime( b, &a );
        OUTPUT:
          a
          RETVAL
      CASE:
	  # 'a' is host, 'b' is timep
          char *a
          time_t &b = NO_INIT
        OUTPUT:
          b
          RETVAL

That function can be called with either of the following statements.  Note
the different argument lists.

	$status = rpcb_gettime( $host, $timep );

	$status = x_gettime( $timep, $host );

=head2 The EXPORT_XSUB_SYMBOLS: Keyword

The EXPORT_XSUB_SYMBOLS: keyword is likely something you will never need.
In perl versions earlier than 5.16.0, this keyword does nothing. Starting
with 5.16, XSUB symbols are no longer exported by default. That is, they
are C<static> functions. If you include

  EXPORT_XSUB_SYMBOLS: ENABLE

in your XS code, the XSUBs following this line will not be declared C<static>.
You can later disable this with

  EXPORT_XSUB_SYMBOLS: DISABLE

which, again, is the default that you should probably never change.
You cannot use this keyword on versions of perl before 5.16 to make
XSUBs C<static>.

=head2 The & Unary Operator

The C<&> unary operator in the INPUT: section is used to tell B<xsubpp>
that it should convert a Perl value to/from C using the C type to the left
of C<&>, but provide a pointer to this value when the C function is called.

This is useful to avoid a CODE: block for a C function which takes a parameter
by reference.  Typically, the parameter should be not a pointer type (an
C<int> or C<long> but not an C<int*> or C<long*>).

The following XSUB will generate incorrect C code.  The B<xsubpp> compiler will
turn this into code which calls C<rpcb_gettime()> with parameters C<(char
*host, time_t timep)>, but the real C<rpcb_gettime()> wants the C<timep>
parameter to be of type C<time_t*> rather than C<time_t>.

    bool_t
    rpcb_gettime(host,timep)
          char *host
          time_t timep
        OUTPUT:
          timep

That problem is corrected by using the C<&> operator.  The B<xsubpp> compiler
will now turn this into code which calls C<rpcb_gettime()> correctly with
parameters C<(char *host, time_t *timep)>.  It does this by carrying the
C<&> through, so the function call looks like C<rpcb_gettime(host, &timep)>.

    bool_t
    rpcb_gettime(host,timep)
          char *host
          time_t &timep
        OUTPUT:
          timep

=head2 Inserting POD, Comments and C Preprocessor Directives

C preprocessor directives are allowed within BOOT:, PREINIT: INIT:, CODE:,
PPCODE:, POSTCALL:, and CLEANUP: blocks, as well as outside the functions.
Comments are allowed anywhere after the MODULE keyword.  The compiler will
pass the preprocessor directives through untouched and will remove the
commented lines. POD documentation is allowed at any point, both in the
C and XS language sections. POD must be terminated with a C<=cut> command;
C<xsubpp> will exit with an error if it does not. It is very unlikely that
human generated C code will be mistaken for POD, as most indenting styles
result in whitespace in front of any line starting with C<=>. Machine
generated XS files may fall into this trap unless care is taken to
ensure that a space breaks the sequence "\n=".

Comments can be added to XSUBs by placing a C<#> as the first
non-whitespace of a line.  Care should be taken to avoid making the
comment look like a C preprocessor directive, lest it be interpreted as
such.  The simplest way to prevent this is to put whitespace in front of
the C<#>.

If you use preprocessor directives to choose one of two
versions of a function, use

    #if ... version1
    #else /* ... version2  */
    #endif

and not

    #if ... version1
    #endif
    #if ... version2
    #endif

because otherwise B<xsubpp> will believe that you made a duplicate
definition of the function.  Also, put a blank line before the
#else/#endif so it will not be seen as part of the function body.

=head2 Using XS With C++

If an XSUB name contains C<::>, it is considered to be a C++ method.
The generated Perl function will assume that
its first argument is an object pointer.  The object pointer
will be stored in a variable called THIS.  The object should
have been created by C++ with the new() function and should
be blessed by Perl with the sv_setref_pv() macro.  The
blessing of the object by Perl can be handled by a typemap.  An example
typemap is shown at the end of this section.

If the return type of the XSUB includes C<static>, the method is considered
to be a static method.  It will call the C++
function using the class::method() syntax.  If the method is not static
the function will be called using the THIS-E<gt>method() syntax.

The next examples will use the following C++ class.

     class color {
          public:
          color();
          ~color();
          int blue();
          void set_blue( int );

          private:
          int c_blue;
     };

The XSUBs for the blue() and set_blue() methods are defined with the class
name but the parameter for the object (THIS, or "self") is implicit and is
not listed.

     int
     color::blue()

     void
     color::set_blue( val )
          int val

Both Perl functions will expect an object as the first parameter.  In the
generated C++ code the object is called C<THIS>, and the method call will
be performed on this object.  So in the C++ code the blue() and set_blue()
methods will be called as this:

     RETVAL = THIS->blue();

     THIS->set_blue( val );

You could also write a single get/set method using an optional argument:

     int
     color::blue( val = NO_INIT )
         int val
         PROTOTYPE $;$
         CODE:
             if (items > 1)
                 THIS->set_blue( val );
             RETVAL = THIS->blue();
         OUTPUT:
             RETVAL

If the function's name is B<DESTROY> then the C++ C<delete> function will be
called and C<THIS> will be given as its parameter.  The generated C++ code for

     void
     color::DESTROY()

will look like this:

     color *THIS = ...;  // Initialized as in typemap

     delete THIS;

If the function's name is B<new> then the C++ C<new> function will be called
to create a dynamic C++ object.  The XSUB will expect the class name, which
will be kept in a variable called C<CLASS>, to be given as the first
argument.

     color *
     color::new()

The generated C++ code will call C<new>.

     RETVAL = new color();

The following is an example of a typemap that could be used for this C++
example.

    TYPEMAP
    color *  O_OBJECT

    OUTPUT
    # The Perl object is blessed into 'CLASS', which should be a
    # char* having the name of the package for the blessing.
    O_OBJECT
        sv_setref_pv( $arg, CLASS, (void*)$var );

    INPUT
    O_OBJECT
        if( sv_isobject($arg) && (SvTYPE(SvRV($arg)) == SVt_PVMG) )
            $var = ($type)SvIV((SV*)SvRV( $arg ));
        else{
            warn(\"${Package}::$func_name() -- \"
                \"$var is not a blessed SV reference\");
            XSRETURN_UNDEF;
        }

=head2 Interface Strategy

When designing an interface between Perl and a C library a straight
translation from C to XS (such as created by C<h2xs -x>) is often sufficient.
However, sometimes the interface will look
very C-like and occasionally nonintuitive, especially when the C function
modifies one of its parameters, or returns failure inband (as in "negative
return values mean failure").  In cases where the programmer wishes to
create a more Perl-like interface the following strategy may help to
identify the more critical parts of the interface.

Identify the C functions with input/output or output parameters.  The XSUBs for
these functions may be able to return lists to Perl.

Identify the C functions which use some inband info as an indication
of failure.  They may be
candidates to return undef or an empty list in case of failure.  If the
failure may be detected without a call to the C function, you may want to use
an INIT: section to report the failure.  For failures detectable after the C
function returns one may want to use a POSTCALL: section to process the
failure.  In more complicated cases use CODE: or PPCODE: sections.

If many functions use the same failure indication based on the return value,
you may want to create a special typedef to handle this situation.  Put

  typedef int negative_is_failure;

near the beginning of XS file, and create an OUTPUT typemap entry
for C<negative_is_failure> which converts negative values to C<undef>, or
maybe croak()s.  After this the return value of type C<negative_is_failure>
will create more Perl-like interface.

Identify which values are used by only the C and XSUB functions
themselves, say, when a parameter to a function should be a contents of a
global variable.  If Perl does not need to access the contents of the value
then it may not be necessary to provide a translation for that value
from C to Perl.

Identify the pointers in the C function parameter lists and return
values.  Some pointers may be used to implement input/output or
output parameters, they can be handled in XS with the C<&> unary operator,
and, possibly, using the NO_INIT keyword.
Some others will require handling of types like C<int *>, and one needs
to decide what a useful Perl translation will do in such a case.  When
the semantic is clear, it is advisable to put the translation into a typemap
file.

Identify the structures used by the C functions.  In many
cases it may be helpful to use the T_PTROBJ typemap for
these structures so they can be manipulated by Perl as
blessed objects.  (This is handled automatically by C<h2xs -x>.)

If the same C type is used in several different contexts which require
different translations, C<typedef> several new types mapped to this C type,
and create separate F<typemap> entries for these new types.  Use these
types in declarations of return type and parameters to XSUBs.

=head2 Perl Objects And C Structures

When dealing with C structures one should select either
B<T_PTROBJ> or B<T_PTRREF> for the XS type.  Both types are
designed to handle pointers to complex objects.  The
T_PTRREF type will allow the Perl object to be unblessed
while the T_PTROBJ type requires that the object be blessed.
By using T_PTROBJ one can achieve a form of type-checking
because the XSUB will attempt to verify that the Perl object
is of the expected type.

The following XS code shows the getnetconfigent() function which is used
with ONC+ TIRPC.  The getnetconfigent() function will return a pointer to a
C structure and has the C prototype shown below.  The example will
demonstrate how the C pointer will become a Perl reference.  Perl will
consider this reference to be a pointer to a blessed object and will
attempt to call a destructor for the object.  A destructor will be
provided in the XS source to free the memory used by getnetconfigent().
Destructors in XS can be created by specifying an XSUB function whose name
ends with the word B<DESTROY>.  XS destructors can be used to free memory
which may have been malloc'd by another XSUB.

     struct netconfig *getnetconfigent(const char *netid);

A C<typedef> will be created for C<struct netconfig>.  The Perl
object will be blessed in a class matching the name of the C
type, with the tag C<Ptr> appended, and the name should not
have embedded spaces if it will be a Perl package name.  The
destructor will be placed in a class corresponding to the
class of the object and the PREFIX keyword will be used to
trim the name to the word DESTROY as Perl will expect.

     typedef struct netconfig Netconfig;

     MODULE = RPC  PACKAGE = RPC

     Netconfig *
     getnetconfigent(netid)
          char *netid

     MODULE = RPC  PACKAGE = NetconfigPtr  PREFIX = rpcb_

     void
     rpcb_DESTROY(netconf)
          Netconfig *netconf
        CODE:
          printf("Now in NetconfigPtr::DESTROY\n");
          free( netconf );

This example requires the following typemap entry.  Consult
L<perlxstypemap> for more information about adding new typemaps
for an extension.

     TYPEMAP
     Netconfig *  T_PTROBJ

This example will be used with the following Perl statements.

     use RPC;
     $netconf = getnetconfigent("udp");

When Perl destroys the object referenced by $netconf it will send the
object to the supplied XSUB DESTROY function.  Perl cannot determine, and
does not care, that this object is a C struct and not a Perl object.  In
this sense, there is no difference between the object created by the
getnetconfigent() XSUB and an object created by a normal Perl subroutine.

=head2 Safely Storing Static Data in XS

Starting with Perl 5.8, a macro framework has been defined to allow
static data to be safely stored in XS modules that will be accessed from
a multi-threaded Perl.

Although primarily designed for use with multi-threaded Perl, the macros
have been designed so that they will work with non-threaded Perl as well.

It is therefore strongly recommended that these macros be used by all
XS modules that make use of static data.

The easiest way to get a template set of macros to use is by specifying
the C<-g> (C<--global>) option with h2xs (see L<h2xs>).

Below is an example module that makes use of the macros.

    #define PERL_NO_GET_CONTEXT
    #include "EXTERN.h"
    #include "perl.h"
    #include "XSUB.h"

    /* Global Data */

    #define MY_CXT_KEY "BlindMice::_guts" XS_VERSION

    typedef struct {
        int count;
        char name[3][100];
    } my_cxt_t;

    START_MY_CXT

    MODULE = BlindMice           PACKAGE = BlindMice

    BOOT:
    {
        MY_CXT_INIT;
        MY_CXT.count = 0;
        strcpy(MY_CXT.name[0], "None");
        strcpy(MY_CXT.name[1], "None");
        strcpy(MY_CXT.name[2], "None");
    }

    int
    newMouse(char * name)
        PREINIT:
          dMY_CXT;
        CODE:
          if (MY_CXT.count >= 3) {
              warn("Already have 3 blind mice");
              RETVAL = 0;
          }
          else {
              RETVAL = ++ MY_CXT.count;
              strcpy(MY_CXT.name[MY_CXT.count - 1], name);
          }
        OUTPUT:
          RETVAL

    char *
    get_mouse_name(index)
          int index
        PREINIT:
          dMY_CXT;
        CODE:
          if (index > MY_CXT.count)
            croak("There are only 3 blind mice.");
          else
            RETVAL = MY_CXT.name[index - 1];
        OUTPUT:
          RETVAL

    void
    CLONE(...)
	CODE:
	  MY_CXT_CLONE;

=head3 MY_CXT REFERENCE

=over 5

=item MY_CXT_KEY

This macro is used to define a unique key to refer to the static data
for an XS module. The suggested naming scheme, as used by h2xs, is to
use a string that consists of the module name, the string "::_guts"
and the module version number.

    #define MY_CXT_KEY "MyModule::_guts" XS_VERSION

=item typedef my_cxt_t

This struct typedef I<must> always be called C<my_cxt_t>. The other
C<CXT*> macros assume the existence of the C<my_cxt_t> typedef name.

Declare a typedef named C<my_cxt_t> that is a structure that contains
all the data that needs to be interpreter-local.

    typedef struct {
        int some_value;
    } my_cxt_t;

=item START_MY_CXT

Always place the START_MY_CXT macro directly after the declaration
of C<my_cxt_t>.

=for apidoc Amnh||START_MY_CXT

=item MY_CXT_INIT

The MY_CXT_INIT macro initializes storage for the C<my_cxt_t> struct.

It I<must> be called exactly once, typically in a BOOT: section. If you
are maintaining multiple interpreters, it should be called once in each
interpreter instance, except for interpreters cloned from existing ones.
(But see L</MY_CXT_CLONE> below.)

=for apidoc Amnh||MY_CXT_INIT

=item dMY_CXT

Use the dMY_CXT macro (a declaration) in all the functions that access
MY_CXT.

=for apidoc Amnh||dMY_CXT

=item MY_CXT

Use the MY_CXT macro to access members of the C<my_cxt_t> struct. For
example, if C<my_cxt_t> is

    typedef struct {
        int index;
    } my_cxt_t;

then use this to access the C<index> member

    dMY_CXT;
    MY_CXT.index = 2;

=item aMY_CXT/pMY_CXT

C<dMY_CXT> may be quite expensive to calculate, and to avoid the overhead
of invoking it in each function it is possible to pass the declaration
onto other functions using the C<aMY_CXT>/C<pMY_CXT> macros, eg

=for apidoc Amnh||_aMY_CXT
=for apidoc Amnh||aMY_CXT
=for apidoc Amnh||aMY_CXT_
=for apidoc Amnh||_pMY_CXT
=for apidoc Amnh||pMY_CXT
=for apidoc Amnh||pMY_CXT_
=for apidoc Amnh||MY_CXT

    void sub1() {
	dMY_CXT;
	MY_CXT.index = 1;
	sub2(aMY_CXT);
    }

    void sub2(pMY_CXT) {
	MY_CXT.index = 2;
    }

Analogously to C<pTHX>, there are equivalent forms for when the macro is the
first or last in multiple arguments, where an underscore represents a
comma, i.e.  C<_aMY_CXT>, C<aMY_CXT_>, C<_pMY_CXT> and C<pMY_CXT_>.

=item MY_CXT_CLONE

By default, when a new interpreter is created as a copy of an existing one
(eg via C<< threads->create() >>), both interpreters share the same physical
my_cxt_t structure. Calling C<MY_CXT_CLONE> (typically via the package's
C<CLONE()> function), causes a byte-for-byte copy of the structure to be
taken, and any future dMY_CXT will cause the copy to be accessed instead.

=for apidoc Amnh||MY_CXT_CLONE

=item MY_CXT_INIT_INTERP(my_perl)

=item dMY_CXT_INTERP(my_perl)

These are versions of the macros which take an explicit interpreter as an
argument.

=back

Note that these macros will only work together within the I<same> source
file; that is, a dMY_CTX in one source file will access a different structure
than a dMY_CTX in another source file.

=head1 EXAMPLES

File C<RPC.xs>: Interface to some ONC+ RPC bind library functions.

     #define PERL_NO_GET_CONTEXT
     #include "EXTERN.h"
     #include "perl.h"
     #include "XSUB.h"

     /* Note: On glibc 2.13 and earlier, this needs be <rpc/rpc.h> */
     #include <tirpc/rpc.h>

     typedef struct netconfig Netconfig;

     MODULE = RPC  PACKAGE = RPC

     SV *
     rpcb_gettime(host="localhost")
          char *host
	PREINIT:
          time_t  timep;
        CODE:
          ST(0) = sv_newmortal();
          if( rpcb_gettime( host, &timep ) )
               sv_setnv( ST(0), (double)timep );

     Netconfig *
     getnetconfigent(netid="udp")
          char *netid

     MODULE = RPC  PACKAGE = NetconfigPtr  PREFIX = rpcb_

     void
     rpcb_DESTROY(netconf)
          Netconfig *netconf
        CODE:
          printf("NetconfigPtr::DESTROY\n");
          free( netconf );

File C<typemap>: Custom typemap for RPC.xs. (cf. L<perlxstypemap>)

     TYPEMAP
     Netconfig *  T_PTROBJ

File C<RPC.pm>: Perl module for the RPC extension.

     package RPC;

     require Exporter;
     require DynaLoader;
     @ISA = qw(Exporter DynaLoader);
     @EXPORT = qw(rpcb_gettime getnetconfigent);

     bootstrap RPC;
     1;

File C<rpctest.pl>: Perl test program for the RPC extension.

     use RPC;

     $netconf = getnetconfigent();
     $a = rpcb_gettime();
     print "time = $a\n";
     print "netconf = $netconf\n";

     $netconf = getnetconfigent("tcp");
     $a = rpcb_gettime("poplar");
     print "time = $a\n";
     print "netconf = $netconf\n";

In Makefile.PL add -ltirpc and -I/usr/include/tirpc.

=head1 CAVEATS

=head2 Use of standard C library functions

See L<perlclib>.

=head2 Event loops and control flow

Some modules have an event loop, waiting for user-input.  It is highly
unlikely that two such modules would work adequately together in a
single Perl application.

In general, the perl interpreter views itself as the center of the
universe as far as the Perl program goes.  XS code is viewed as a
help-mate, to accomplish things that perl doesn't do, or doesn't do fast
enough, but always subservient to perl.  The closer XS code adheres to
this model, the less likely conflicts will occur.

=head1 XS VERSION

This document covers features supported by C<ExtUtils::ParseXS>
(also known as C<xsubpp>) 3.51

=head1 AUTHOR DIAGNOSTICS

As of version 3.49 certain warnings are disabled by default. While developing
you can set C<$ENV{AUTHOR_WARNINGS}> to true in your environment or in your
Makefile.PL, or set C<$ExtUtils::ParseXS::AUTHOR_WARNINGS> to true via code, or
pass C<< author_warnings=>1 >> into process_file() explicitly.  Currently this will
enable stricter alias checking but more warnings might be added in the future.
The kind of warnings this will enable are only helpful to the author of the XS
file, and the diagnostics produced will not include installation specific
details so they are only useful to the maintainer of the XS code itself.

=head1 AUTHOR

Originally written by Dean Roehrich <F<roehrich@cray.com>>.

Maintained since 1996 by The Perl Porters <F<perl5-porters@perl.org>>.
                                                                                                                                                                                                                                           usr/local/lib/perl5/5.40.0/pod/perlxstut.pod                                                        0000644 0000000 0000000 00000142437 14714567415 017061  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =head1 NAME

perlxstut - Tutorial for writing XSUBs

=head1 DESCRIPTION

This tutorial will educate the reader on the steps involved in creating
a Perl extension.  The reader is assumed to have access to L<perlguts>,
L<perlclib>, L<perlapi>, and L<perlxs>.

This tutorial starts with very simple examples and becomes more complex,
with each new example adding new features.  Certain concepts may not be
completely explained until later in the tutorial in order to slowly ease
the reader into building extensions.

This tutorial was written from a Unix point of view.  Where I know them
to be otherwise different for other platforms (e.g. Win32), I will list
them.  If you find something that was missed, please let me know.

=head1 SPECIAL NOTES

=head2 make

This tutorial assumes that the make program that Perl is configured to
use is called C<make>.  Instead of running "make" in the examples that
follow, you may have to substitute whatever make program Perl has been
configured to use.  Running B<perl -V:make> should tell you what it is.

=head2 Version caveat

When writing a Perl extension for general consumption, one should expect that
the extension will be used with versions of Perl different from the
version available on your machine.  Since you are reading this document,
the version of Perl on your machine is probably 5.005 or later, but the users
of your extension may have more ancient versions.

To understand what kinds of incompatibilities one may expect, and in the rare
case that the version of Perl on your machine is older than this document,
see the section on "Troubleshooting these Examples" for more information.

If your extension uses some features of Perl which are not available on older
releases of Perl, your users would appreciate an early meaningful warning.
You would probably put this information into the F<README> file, but nowadays
installation of extensions may be performed automatically, guided by F<CPAN.pm>
module or other tools.

In MakeMaker-based installations, F<Makefile.PL> provides the earliest
opportunity to perform version checks.  One can put something like this
in F<Makefile.PL> for this purpose:

    eval { require 5.007 }
        or die <<EOD;
    ############
    ### This module uses frobnication framework which is not available
    ### before version 5.007 of Perl.  Upgrade your Perl before
    ### installing Kara::Mba.
    ############
    EOD

=head2 Dynamic Loading versus Static Loading

It is commonly thought that if a system does not have the capability to
dynamically load a library, you cannot build XSUBs.  This is incorrect.
You I<can> build them, but you must link the XSUBs subroutines with the
rest of Perl, creating a new executable.  This situation is similar to
Perl 4.

This tutorial can still be used on such a system.  The XSUB build mechanism
will check the system and build a dynamically-loadable library if possible,
or else a static library and then, optionally, a new statically-linked
executable with that static library linked in.

Should you wish to build a statically-linked executable on a system which
can dynamically load libraries, you may, in all the following examples,
where the command "C<make>" with no arguments is executed, run the command
"C<make perl>" instead.

If you have generated such a statically-linked executable by choice, then
instead of saying "C<make test>", you should say "C<make test_static>".
On systems that cannot build dynamically-loadable libraries at all, simply
saying "C<make test>" is sufficient.

=head2 Threads and PERL_NO_GET_CONTEXT

For threaded builds, perl requires the context pointer for the current
thread, without C<PERL_NO_GET_CONTEXT>, perl will call a function to
retrieve the context.

For improved performance, include:

  #define PERL_NO_GET_CONTEXT

as shown below.

For more details, see L<perlguts|perlguts/How multiple interpreters
and concurrency are supported>.

=head1 TUTORIAL

Now let's go on with the show!

=head2 EXAMPLE 1

Our first extension will be very simple.  When we call the routine in the
extension, it will print out a well-known message and return.

Run "C<h2xs -A -n Mytest>".  This creates a directory named Mytest,
possibly under ext/ if that directory exists in the current working
directory.  Several files will be created under the Mytest dir, including
MANIFEST, Makefile.PL, lib/Mytest.pm, Mytest.xs, t/Mytest.t, and Changes.

The MANIFEST file contains the names of all the files just created in the
Mytest directory.

The file Makefile.PL should look something like this:

    use ExtUtils::MakeMaker;

    # See lib/ExtUtils/MakeMaker.pm for details of how to influence
    # the contents of the Makefile that is written.
    WriteMakefile(
        NAME         => 'Mytest',
        VERSION_FROM => 'Mytest.pm', # finds $VERSION
        LIBS         => [''],        # e.g., '-lm'
        DEFINE       => '',          # e.g., '-DHAVE_SOMETHING'
        INC          => '-I',        # e.g., '-I. -I/usr/include/other'
    );

The file Mytest.pm should start with something like this:

    package Mytest;

    use 5.008008;
    use strict;
    use warnings;

    require Exporter;

    our @ISA = qw(Exporter);
    our %EXPORT_TAGS = ( 'all' => [ qw(

    ) ] );

    our @EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );

    our @EXPORT = qw(

    );

    our $VERSION = '0.01';

    require XSLoader;
    XSLoader::load('Mytest', $VERSION);
