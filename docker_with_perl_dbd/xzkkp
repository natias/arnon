    # Creates templates for an extension named RPC
    h2xs -cfn RPC

    # Extension is ONC::RPC.
    h2xs -cfn ONC::RPC

    # Extension is a pure Perl module with no XS code.
    h2xs -X My::Module

    # Extension is Lib::Foo which works at least with Perl5.005_03.
    # Constants are created for all #defines and enums h2xs can find
    # in foo.h.
    h2xs -b 5.5.3 -n Lib::Foo foo.h

    # Extension is Lib::Foo which works at least with Perl5.005_03.
    # Constants are created for all #defines but only for enums
    # whose names do not start with 'bar_'.
    h2xs -b 5.5.3 -e '^bar_' -n Lib::Foo foo.h

    # Makefile.PL will look for library -lrpc in
    # additional directory /opt/net/lib
    h2xs rpcsvc/rusers -L/opt/net/lib -lrpc

    # Extension is DCE::rgynbase
    # prefix "sec_rgy_" is dropped from perl function names
    h2xs -n DCE::rgynbase -p sec_rgy_ dce/rgynbase

    # Extension is DCE::rgynbase
    # prefix "sec_rgy_" is dropped from perl function names
    # subroutines are created for sec_rgy_wildcard_name and
    # sec_rgy_wildcard_sid
    h2xs -n DCE::rgynbase -p sec_rgy_ \
    -s sec_rgy_wildcard_name,sec_rgy_wildcard_sid dce/rgynbase

    # Make XS without defines in perl.h, but with function declarations
    # visible from perl.h. Name of the extension is perl1.
    # When scanning perl.h, define -DEXT=extern -DdEXT= -DINIT(x)=
    # Extra backslashes below because the string is passed to shell.
    # Note that a directory with perl header files would
    #  be added automatically to include path.
    h2xs -xAn perl1 -F "-DEXT=extern -DdEXT= -DINIT\(x\)=" perl.h

    # Same with function declaration in proto.h as visible from perl.h.
    h2xs -xAn perl2 perl.h,proto.h

    # Same but select only functions which match /^av_/
    h2xs -M '^av_' -xAn perl2 perl.h,proto.h

    # Same but treat SV* etc as "opaque" types
    h2xs -o '^[S]V \*$' -M '^av_' -xAn perl2 perl.h,proto.h

=head2 Extension based on F<.h> and F<.c> files

Suppose that you have some C files implementing some functionality,
and the corresponding header files.  How to create an extension which
makes this functionality accessible in Perl?  The example below
assumes that the header files are F<interface_simple.h> and
I<interface_hairy.h>, and you want the perl module be named as
C<Ext::Ension>.  If you need some preprocessor directives and/or
linking with external libraries, see the flags C<-F>, C<-L> and C<-l>
in L<"OPTIONS">.

=over

=item Find the directory name

Start with a dummy run of h2xs:

  h2xs -Afn Ext::Ension

The only purpose of this step is to create the needed directories, and
let you know the names of these directories.  From the output you can
see that the directory for the extension is F<Ext/Ension>.

=item Copy C files

Copy your header files and C files to this directory F<Ext/Ension>.

=item Create the extension

Run h2xs, overwriting older autogenerated files:

  h2xs -Oxan Ext::Ension interface_simple.h interface_hairy.h

h2xs looks for header files I<after> changing to the extension
directory, so it will find your header files OK.

=item Archive and test

As usual, run

  cd Ext/Ension
  perl Makefile.PL
  make dist
  make
  make test

=item Hints

It is important to do C<make dist> as early as possible.  This way you
can easily merge(1) your changes to autogenerated files if you decide
to edit your C<.h> files and rerun h2xs.

Do not forget to edit the documentation in the generated F<.pm> file.

Consider the autogenerated files as skeletons only, you may invent
better interfaces than what h2xs could guess.

Consider this section as a guideline only, some other options of h2xs
may better suit your needs.

=back

=head1 ENVIRONMENT

No environment variables are used.

=head1 AUTHOR

Larry Wall and others

=head1 SEE ALSO

L<perl>, L<perlxstut>, L<ExtUtils::MakeMaker>, and L<AutoLoader>.

=head1 DIAGNOSTICS

The usual warnings if it cannot read or write the files involved.

=head1 LIMITATIONS of B<-x>

F<h2xs> would not distinguish whether an argument to a C function
which is of the form, say, C<int *>, is an input, output, or
input/output parameter.  In particular, argument declarations of the
form

    int
    foo(n)
	int *n

should be better rewritten as

    int
    foo(n)
	int &n

if C<n> is an input parameter.

Additionally, F<h2xs> has no facilities to intuit that a function

   int
   foo(addr,l)
	char *addr
	int   l

takes a pair of address and length of data at this address, so it is better
to rewrite this function as

    int
    foo(sv)
	    SV *addr
	PREINIT:
	    STRLEN len;
	    char *s;
	CODE:
	    s = SvPV(sv,len);
	    RETVAL = foo(s, len);
	OUTPUT:
	    RETVAL

or alternately

    static int
    my_foo(SV *sv)
    {
	STRLEN len;
	char *s = SvPV(sv,len);

	return foo(s, len);
    }

    MODULE = foo	PACKAGE = foo	PREFIX = my_

    int
    foo(sv)
	SV *sv

See L<perlxs> and L<perlxstut> for additional details.

=cut

# ' # Grr
use strict;


my( $H2XS_VERSION ) = ' $Revision: 1.23 $ ' =~ /\$Revision:\s+([^\s]+)/;
my $TEMPLATE_VERSION = '0.01';
my @ARGS = @ARGV;
my $compat_version = $];

use Getopt::Long;
use Config;
use Text::Wrap;
$Text::Wrap::huge = 'overflow';
$Text::Wrap::columns = 80;
use ExtUtils::Constant qw (WriteConstants WriteMakefileSnippet autoload);
use File::Compare;
use File::Path;

sub usage {
    warn "@_\n" if @_;
    die <<EOFUSAGE;
h2xs [OPTIONS ... ] [headerfile [extra_libraries]]
version: $H2XS_VERSION
OPTIONS:
    -A, --omit-autoload   Omit all autoloading facilities (implies -c).
    -B, --beta-version    Use beta \$VERSION of 0.00_01 (ignored if -v).
    -C, --omit-changes    Omit creating the Changes file, add HISTORY heading
                          to stub POD.
    -F, --cpp-flags       Additional flags for C preprocessor/compile.
    -M, --func-mask       Mask to select C functions/macros
                          (default is select all).
    -O, --overwrite-ok    Allow overwriting of a pre-existing extension directory.
    -P, --omit-pod        Omit the stub POD section.
    -X, --omit-XS         Omit the XS portion (implies both -c and -f).
    -a, --gen-accessors   Generate get/set accessors for struct and union members
                          (used with -x).
    -b, --compat-version  Specify a perl version to be backwards compatible with.
    -c, --omit-constant   Omit the constant() function and specialised AUTOLOAD
                          from the XS file.
    -d, --debugging       Turn on debugging messages.
    -e, --omit-enums      Omit constants from enums in the constant() function.
                          If a pattern is given, only the matching enums are
                          ignored.
    -f, --force           Force creation of the extension even if the C header
                          does not exist.
    -g, --global          Include code for safely storing static data in the .xs file.
    -h, -?, --help        Display this help message.
    -k, --omit-const-func Omit 'const' attribute on function arguments
                          (used with -x).
    -m, --gen-tied-var    Generate tied variables for access to declared
                          variables.
    -n, --name            Specify a name to use for the extension (recommended).
    -o, --opaque-re       Regular expression for \"opaque\" types.
    -p, --remove-prefix   Specify a prefix which should be removed from the
                          Perl function names.
    -s, --const-subs      Create subroutines for specified macros.
    -t, --default-type    Default type for autoloaded constants (default is IV).
        --use-new-tests   Use Test::More in backward compatible modules.
        --use-old-tests   Use the module Test rather than Test::More.
        --skip-exporter   Do not export symbols.
        --skip-ppport     Do not use portability layer.
        --skip-autoloader Do not use the module C<AutoLoader>.
        --skip-strict     Do not use the pragma C<strict>.
        --skip-warnings   Do not use the pragma C<warnings>.
    -v, --version         Specify a version number for this extension.
    -x, --autogen-xsubs   Autogenerate XSUBs using C::Scan.
        --use-xsloader    Use XSLoader in backward compatible modules (ignored
                          when used with -X).

extra_libraries
         are any libraries that might be needed for loading the
         extension, e.g. -lm would try to link in the math library.
EOFUSAGE
}

my ($opt_A,
    $opt_B,
    $opt_C,
    $opt_F,
    $opt_M,
    $opt_O,
    $opt_P,
    $opt_X,
    $opt_a,
    $opt_c,
    $opt_d,
    $opt_e,
    $opt_f,
    $opt_g,
    $opt_h,
    $opt_k,
    $opt_m,
    $opt_n,
    $opt_o,
    $opt_p,
    $opt_s,
    $opt_v,
    $opt_x,
    $opt_b,
    $opt_t,
    $new_test,
    $old_test,
    $skip_exporter,
    $skip_ppport,
    $skip_autoloader,
    $skip_strict,
    $skip_warnings,
    $use_xsloader
   );

Getopt::Long::Configure('bundling');
Getopt::Long::Configure('pass_through');

my %options = (
                'omit-autoload|A'    => \$opt_A,
                'beta-version|B'     => \$opt_B,
                'omit-changes|C'     => \$opt_C,
                'cpp-flags|F=s'      => \$opt_F,
                'func-mask|M=s'      => \$opt_M,
                'overwrite_ok|O'     => \$opt_O,
                'omit-pod|P'         => \$opt_P,
                'omit-XS|X'          => \$opt_X,
                'gen-accessors|a'    => \$opt_a,
                'compat-version|b=s' => \$opt_b,
                'omit-constant|c'    => \$opt_c,
                'debugging|d'        => \$opt_d,
                'omit-enums|e:s'     => \$opt_e,
                'force|f'            => \$opt_f,
                'global|g'           => \$opt_g,
                'help|h|?'           => \$opt_h,
                'omit-const-func|k'  => \$opt_k,
                'gen-tied-var|m'     => \$opt_m,
                'name|n=s'           => \$opt_n,
                'opaque-re|o=s'      => \$opt_o,
                'remove-prefix|p=s'  => \$opt_p,
                'const-subs|s=s'     => \$opt_s,
                'default-type|t=s'   => \$opt_t,
                'version|v=s'        => \$opt_v,
                'autogen-xsubs|x'    => \$opt_x,
                'use-new-tests'      => \$new_test,
                'use-old-tests'      => \$old_test,
                'skip-exporter'      => \$skip_exporter,
                'skip-ppport'        => \$skip_ppport,
                'skip-autoloader'    => \$skip_autoloader,
                'skip-warnings'      => \$skip_warnings,
                'skip-strict'        => \$skip_strict,
                'use-xsloader'       => \$use_xsloader,
              );

GetOptions(%options) || usage;

usage if $opt_h;

if( $opt_b ){
    usage "You cannot use -b and -m at the same time.\n" if ($opt_b && $opt_m);
    $opt_b =~ /^v?(\d+)\.(\d+)\.(\d+)/ ||
    usage "You must provide the backwards compatibility version in X.Y.Z form. "
          .  "(i.e. 5.5.0)\n";
    my ($maj,$min,$sub) = ($1,$2,$3);
    if ($maj < 5 || ($maj == 5 && $min < 6)) {
        $compat_version =
	    $sub ? sprintf("%d.%03d%02d",$maj,$min,$sub) :
	           sprintf("%d.%03d",    $maj,$min);
    } else {
        $compat_version = sprintf("%d.%03d%03d",$maj,$min,$sub);
    }
} else {
    my ($maj,$min,$sub) = $compat_version =~ /(\d+)\.(\d\d\d)(\d*)/;
    $sub ||= 0;
    warn sprintf <<'EOF', $maj,$min,$sub;
Defaulting to backwards compatibility with perl %d.%d.%d
If you intend this module to be compatible with earlier perl versions, please
specify a minimum perl version with the -b option.

EOF
}

if( $opt_B ){
    $TEMPLATE_VERSION = '0.00_01';
}

if( $opt_v ){
	$TEMPLATE_VERSION = $opt_v;

    # check if it is numeric
    my $temp_version = $TEMPLATE_VERSION;
    my $beta_version = $temp_version =~ s/(\d)_(\d\d)/$1$2/;
    my $notnum;
    {
        local $SIG{__WARN__} = sub { $notnum = 1 };
        use warnings 'numeric';
        $temp_version = 0+$temp_version;
    }

    if ($notnum) {
        my $module = $opt_n || 'Your::Module';
        warn <<"EOF";
You have specified a non-numeric version.  Unless you supply an
appropriate VERSION class method, users may not be able to specify a
minimum required version with C<use $module versionnum>.

EOF
    }
    else {
        $opt_B = $beta_version;
    }
}

# -A implies -c.
$skip_autoloader = $opt_c = 1 if $opt_A;

# -X implies -c and -f
$opt_c = $opt_f = 1 if $opt_X;

$opt_t ||= 'IV';

my %const_xsub;
%const_xsub = map { $_,1 } split(/,+/, $opt_s) if $opt_s;

my $extralibs = '';

my @path_h;

while (my $arg = shift) {
    if ($arg =~ /^-l/i) {
        $extralibs .= "$arg ";
        next;
    }
    last if $extralibs;
    push(@path_h, $arg);
}

usage "Must supply header file or module name\n"
        unless (@path_h or $opt_n);

my $fmask;
my $tmask;

$fmask = qr{$opt_M} if defined $opt_M;
$tmask = qr{$opt_o} if defined $opt_o;
my $tmask_all = $tmask && $opt_o eq '.';

if ($opt_x) {
  eval {require C::Scan; 1}
    or die <<EOD;
C::Scan required if you use -x option.
To install C::Scan, execute
   perl -MCPAN -e "install C::Scan"
EOD
  unless ($tmask_all) {
    $C::Scan::VERSION >= 0.70
      or die <<EOD;
C::Scan v. 0.70 or later required unless you use -o . option.
You have version $C::Scan::VERSION installed as $INC{'C/Scan.pm'}.
To install C::Scan, execute
   perl -MCPAN -e "install C::Scan"
EOD
  }
  if (($opt_m || $opt_a) && $C::Scan::VERSION < 0.73) {
    die <<EOD;
C::Scan v. 0.73 or later required to use -m or -a options.
You have version $C::Scan::VERSION installed as $INC{'C/Scan.pm'}.
To install C::Scan, execute
   perl -MCPAN -e "install C::Scan"
EOD
  }
}
elsif ($opt_o or $opt_F) {
  warn <<EOD if $opt_o;
Option -o does not make sense without -x.
EOD
  warn <<EOD if $opt_F and $opt_X ;
Option -F does not make sense with -X.
EOD
}

my @path_h_ini = @path_h;
my ($name, %fullpath, %prefix, %seen_define, %prefixless, %const_names);

my $module = $opt_n;

if( @path_h ){
    use File::Spec;
    my @paths;
    my $pre_sub_tri_graphs = 1;
    if ($^O eq 'VMS') {  # Consider overrides of default location
      # XXXX This is not equivalent to what the older version did:
      #		it was looking at $hadsys header-file per header-file...
      my($hadsys) = grep s!^sys/!!i , @path_h;
      @paths = qw( Sys$Library VAXC$Include );
      push @paths, ($hadsys ? 'GNU_CC_Include[vms]' : 'GNU_CC_Include[000000]');
      push @paths, qw( DECC$Library_Include DECC$System_Include );
    }
    else {
      @paths = (File::Spec->curdir(), $Config{usrinc},
		(split / +/, $Config{locincpth} // ""), '/usr/include');
    }
    foreach my $path_h (@path_h) {
        $name ||= $path_h;
    $module ||= do {
      $name =~ s/\.h$//;
      if ( $name !~ /::/ ) {
	$name =~ s#^.*/##;
	$name = "\u$name";
      }
      $name;
    };

    if( $path_h =~ s#::#/#g && $opt_n ){
	warn "Nesting of headerfile ignored with -n\n";
    }
    $path_h .= ".h" unless $path_h =~ /\.h$/;
    my $fullpath = $path_h;
    $path_h =~ s/,.*$// if $opt_x;
    $fullpath{$path_h} = $fullpath;

    # Minor trickery: we can't chdir() before we processed the headers
    # (so know the name of the extension), but the header may be in the
    # extension directory...
    my $tmp_path_h = $path_h;
    my $rel_path_h = $path_h;
    my @dirs = @paths;
    if (not -f $path_h) {
      my $found;
      for my $dir (@paths) {
	$found++, last
	  if -f ($path_h = File::Spec->catfile($dir, $tmp_path_h));
      }
      if ($found) {
	$rel_path_h = $path_h;
	$fullpath{$path_h} = $fullpath;
      } else {
	(my $epath = $module) =~ s,::,/,g;
	$epath = File::Spec->catdir('ext', $epath) if -d 'ext';
	$rel_path_h = File::Spec->catfile($epath, $tmp_path_h);
	$path_h = $tmp_path_h;	# Used during -x
	push @dirs, $epath;
      }
    }

    if (!$opt_c) {
      die "Can't find $tmp_path_h in @dirs\n"
	if ( ! $opt_f && ! -f "$rel_path_h" );
      # Scan the header file (we should deal with nested header files)
      # Record the names of simple #define constants into const_names
            # Function prototypes are processed below.
      open(CH, "<", "$rel_path_h") || die "Can't open $rel_path_h: $!\n";
    defines:
      while (<CH>) {
	if ($pre_sub_tri_graphs) {
	    # Preprocess all tri-graphs
	    # including things stuck in quoted string constants.
	    s/\?\?=/#/g;                         # | ??=|  #|
	    s/\?\?\!/|/g;                        # | ??!|  ||
	    s/\?\?'/^/g;                         # | ??'|  ^|
	    s/\?\?\(/[/g;                        # | ??(|  [|
	    s/\?\?\)/]/g;                        # | ??)|  ]|
	    s/\?\?\-/~/g;                        # | ??-|  ~|
	    s/\?\?\//\\/g;                       # | ??/|  \|
	    s/\?\?</{/g;                         # | ??<|  {|
	    s/\?\?>/}/g;                         # | ??>|  }|
	}
	if (/^[ \t]*#[ \t]*define\s+([\$\w]+)\b(?!\()\s*(?=[^"\s])(.*)/) {
	    my $def = $1;
	    my $rest = $2;
	    $rest =~ s!/\*.*?(\*/|\n)|//.*!!g; # Remove comments
	    $rest =~ s/^\s+//;
	    $rest =~ s/\s+$//;
	    if ($rest eq '') {
	      print("Skip empty $def\n") if $opt_d;
	      next defines;
	    }
	    # Cannot do: (-1) and ((LHANDLE)3) are OK:
	    #print("Skip non-wordy $def => $rest\n"),
	    #  next defines if $rest =~ /[^\w\$]/;
	    if ($rest =~ /"/) {
	      print("Skip stringy $def => $rest\n") if $opt_d;
	      next defines;
	    }
	    print "Matched $_ ($def)\n" if $opt_d;
	    $seen_define{$def} = $rest;
	    $_ = $def;
	    next if /^_.*_h_*$/i; # special case, but for what?
	    if (defined $opt_p) {
	      if (!/^$opt_p(\d)/) {
		++$prefix{$_} if s/^$opt_p//;
	      }
	      else {
		warn "can't remove $opt_p prefix from '$_'!\n";
	      }
	    }
	    $prefixless{$def} = $_;
	    if (!$fmask or /$fmask/) {
		print "... Passes mask of -M.\n" if $opt_d and $fmask;
		$const_names{$_}++;
	    }
	  }
      }
      if (defined $opt_e and !$opt_e) {
        close(CH);
      }
      else {
	# Work from miniperl too - on "normal" systems
        my $SEEK_SET = eval 'use Fcntl qw/SEEK_SET/; SEEK_SET' || 0;
        seek CH, 0, $SEEK_SET;
        my $src = do { local $/; <CH> };
        close CH;
        no warnings 'uninitialized';

        # Remove C and C++ comments
        $src =~ s#/\*[^*]*\*+([^/*][^*]*\*+)*/|("(\\.|[^"\\])*"|'(\\.|[^'\\])*'|.[^/"'\\]*)#$2#gs;
        $src =~ s#//.*$##gm;

	while ($src =~ /\benum\s*([\w_]*)\s*\{\s([^}]+)\}/gsc) {
	    my ($enum_name, $enum_body) = ($1, $2);
            # skip enums matching $opt_e
            next if $opt_e && $enum_name =~ /$opt_e/;
            my $val = 0;
            for my $item (split /,/, $enum_body) {
                next if $item =~ /\A\s*\Z/;
                my ($key, $declared_val) = $item =~ /(\w+)\s*(?:=\s*(.*))?/;
                $val = defined($declared_val) && length($declared_val) ? $declared_val : 1 + $val;
                $seen_define{$key} = $val;
                $const_names{$key} = { name => $key, macro => 1 };
            }
        } # while (...)
      } # if (!defined $opt_e or $opt_e)
    }
    }
}

# Save current directory so that C::Scan can use it
my $cwd = File::Spec->rel2abs( File::Spec->curdir );

# As Ilya suggested, use a name that contains - and then it can't clash with
# the names of any packages. A directory 'fallback' will clash with any
# new pragmata down the fallback:: tree, but that seems unlikely.
my $constscfname = 'const-c.inc';
my $constsxsfname = 'const-xs.inc';
my $fallbackdirname = 'fallback';

my $ext = chdir 'ext' ? 'ext/' : '';

my @modparts  = split(/::/,$module);
my $modpname  = join('-', @modparts);
my $modfname  = pop @modparts;
my $modpmdir  = join '/', 'lib', @modparts;
my $modpmname = join '/', $modpmdir, $modfname.'.pm';

if ($opt_O) {
	warn "Overwriting existing $ext$modpname!!!\n" if -e $modpname;
}
else {
	die "Won't overwrite existing $ext$modpname\n" if -e $modpname;
}
-d "$modpname"   || mkpath([$modpname], 0, 0775);
chdir($modpname) || die "Can't chdir $ext$modpname: $!\n";

my %types_seen;
my %std_types;
my $fdecls = [];
my $fdecls_parsed = [];
my $typedef_rex;
my %typedefs_pre;
my %known_fnames;
my %structs;

my @fnames;
my @fnames_no_prefix;
my %vdecl_hash;
my @vdecls;

if( ! $opt_X ){  # use XS, unless it was disabled
  unless ($skip_ppport) {
    require Devel::PPPort;
    warn "Writing $ext$modpname/ppport.h\n";
    Devel::PPPort::WriteFile('ppport.h')
        || die "Can't create $ext$modpname/ppport.h: $!\n";
  }
  open(XS, ">", "$modfname.xs") || die "Can't create $ext$modpname/$modfname.xs: $!\n";
  if ($opt_x) {
    warn "Scanning typemaps...\n";
    get_typemap();
    my @td;
    my @good_td;
    my $addflags = $opt_F || '';

    foreach my $filename (@path_h) {
      my $c;
      my $filter;

      if ($fullpath{$filename} =~ /,/) {
	$filename = $`;
	$filter = $';
      }
      warn "Scanning $filename for functions...\n";
      my @styles = $Config{gccversion} ? qw(C++ C9X GNU) : qw(C++ C9X);
      $c = C::Scan->new('filename' => $filename, 'filename_filter' => $filter,
        'add_cppflags' => $addflags, 'c_styles' => \@styles);
      $c->set('includeDirs' => ["$Config::Config{archlib}/CORE", $cwd]);

      $c->get('keywords')->{'__restrict'} = 1;

      push @$fdecls_parsed, @{ $c->get('parsed_fdecls') };
      push(@$fdecls, @{$c->get('fdecls')});

      push @td, @{$c->get('typedefs_maybe')};
      if ($opt_a) {
	my $structs = $c->get('typedef_structs');
	@structs{keys %$structs} = values %$structs;
      }

      if ($opt_m) {
	%vdecl_hash = %{ $c->get('vdecl_hash') };
	@vdecls = sort keys %vdecl_hash;
	for (local $_ = 0; $_ < @vdecls; ++$_) {
	  my $var = $vdecls[$_];
	  my($type, $post) = @{ $vdecl_hash{$var} };
	  if (defined $post) {
	    warn "Can't handle variable '$type $var $post', skipping.\n";
	    splice @vdecls, $_, 1;
	    redo;
	  }
	  $type = normalize_type($type);
	  $vdecl_hash{$var} = $type;
	}
      }

      unless ($tmask_all) {
	warn "Scanning $filename for typedefs...\n";
	my $td = $c->get('typedef_hash');
	# eval {require 'dumpvar.pl'; ::dumpValue($td)} or warn $@ if $opt_d;
	my @f_good_td = grep $td->{$_}[1] eq '', keys %$td;
	push @good_td, @f_good_td;
	@typedefs_pre{@f_good_td}  = map $_->[0], @$td{@f_good_td};
      }
    }
    { local $" = '|';
      $typedef_rex = qr(\b(?<!struct )(?<!enum )(?:@good_td)\b) if @good_td;
    }
    %known_fnames = map @$_[1,3], @$fdecls_parsed; # [1,3] is NAME, FULLTEXT
    if ($fmask) {
      my @good;
      for my $i (0..$#$fdecls_parsed) {
	next unless $fdecls_parsed->[$i][1] =~ /$fmask/; # [1] is NAME
	push @good, $i;
	print "... Function $fdecls_parsed->[$i][1] passes -M mask.\n"
	  if $opt_d;
      }
      $fdecls = [@$fdecls[@good]];
      $fdecls_parsed = [@$fdecls_parsed[@good]];
    }
    @fnames = sort map $_->[1], @$fdecls_parsed; # 1 is NAME
    # Sort declarations:
    {
      my %h = map( ($_->[1], $_), @$fdecls_parsed);
      $fdecls_parsed = [ @h{@fnames} ];
    }
    @fnames_no_prefix = @fnames;
    @fnames_no_prefix
      = sort map { ++$prefix{$_} if s/^$opt_p(?!\d)//; $_ } @fnames_no_prefix
         if defined $opt_p;
    # Remove macros which expand to typedefs
    print "Typedefs are @td.\n" if $opt_d;
    my %td = map {($_, $_)} @td;
    # Add some other possible but meaningless values for macros
    for my $k (qw(char double float int long short unsigned signed void)) {
      $td{"$_$k"} = "$_$k" for ('', 'signed ', 'unsigned ');
    }
    # eval {require 'dumpvar.pl'; ::dumpValue( [\@td, \%td] ); 1} or warn $@;
    my $n = 0;
    my %bad_macs;
    while (keys %td > $n) {
      $n = keys %td;
      my ($k, $v);
      while (($k, $v) = each %seen_define) {
	# print("found '$k'=>'$v'\n"),
	$bad_macs{$k} = $td{$k} = $td{$v} if exists $td{$v};
      }
    }
    # Now %bad_macs contains names of bad macros
    for my $k (keys %bad_macs) {
      delete $const_names{$prefixless{$k}};
      print "Ignoring macro $k which expands to a typedef name '$bad_macs{$k}'\n" if $opt_d;
    }
  }
}
my (@const_specs, @const_names);

for (sort(keys(%const_names))) {
    my $v = $const_names{$_};
    
    push(@const_specs, ref($v) ? $v : $_);
    push(@const_names, $_);
}

-d $modpmdir || mkpath([$modpmdir], 0, 0775);
open(PM, ">", "$modpmname") || die "Can't create $ext$modpname/$modpmname: $!\n";

$" = "\n\t";
warn "Writing $ext$modpname/$modpmname\n";

print PM <<"END";
package $module;

use $compat_version;
END

print PM <<"END" unless $skip_strict;
use strict;
END

print PM "use warnings;\n" unless $skip_warnings or $compat_version < 5.006;

unless( $opt_X || $opt_c || $opt_A ){
	# we'll have an AUTOLOAD(), and it will have $AUTOLOAD and
	# will want Carp.
	print PM <<'END';
use Carp;
END
}

print PM <<'END' unless $skip_exporter;

require Exporter;
END

my $use_Dyna = (not $opt_X and $compat_version < 5.006 and not $use_xsloader);
print PM <<"END" if $use_Dyna;  # use DynaLoader, unless XS was disabled
require DynaLoader;
END


# Are we using AutoLoader or not?
unless ($skip_autoloader) { # no autoloader whatsoever.
	unless ($opt_c) { # we're doing the AUTOLOAD
		print PM "use AutoLoader;\n";
	}
	else {
		print PM "use AutoLoader qw(AUTOLOAD);\n"
	}
}

if ( $compat_version < 5.006 ) {
    my $vars = '$VERSION @ISA';
    $vars .= ' @EXPORT @EXPORT_OK %EXPORT_TAGS' unless $skip_exporter;
    $vars .= ' $AUTOLOAD' unless $opt_X || $opt_c || $opt_A;
    $vars .= ' $XS_VERSION' if $opt_B && !$opt_X;
    print PM "use vars qw($vars);";
}

# Determine @ISA.
my @modISA;
push @modISA, 'Exporter'	unless $skip_exporter;
push @modISA, 'DynaLoader' 	if $use_Dyna;  # no XS
my $myISA = "our \@ISA = qw(@modISA);";
$myISA =~ s/^our // if $compat_version < 5.006;

print PM "\n$myISA\n\n";

my @exported_names = (@const_names, @fnames_no_prefix, map '$'.$_, @vdecls);

my $tmp='';
$tmp .= <<"END" unless $skip_exporter;
# Items to export into callers namespace by default. Note: do not export
# names by default without a very good reason. Use EXPORT_OK instead.
# Do not simply export all your public functions/methods/constants.

# This allows declaration	use $module ':all';
# If you do not need this, moving things directly into \@EXPORT or \@EXPORT_OK
# will save memory.
our %EXPORT_TAGS = ( 'all' => [ qw(
	@exported_names
) ] );

our \@EXPORT_OK = ( \@{ \$EXPORT_TAGS{'all'} } );

our \@EXPORT = qw(
	@const_names
);

END

$tmp .= "our \$VERSION = '$TEMPLATE_VERSION';\n";
if ($opt_B) {
    $tmp .= "our \$XS_VERSION = \$VERSION;\n" unless $opt_X;
    $tmp .= "\$VERSION = eval \$VERSION;  # see L<perlmodstyle>\n";
}
$tmp .= "\n";

$tmp =~ s/^our //mg if $compat_version < 5.006;
print PM $tmp;

if (@vdecls) {
    printf PM "our(@{[ join ', ', map '$'.$_, @vdecls ]});\n\n";
}


print PM autoload ($module, $compat_version) unless $opt_c or $opt_X;

if( ! $opt_X ){ # print bootstrap, unless XS is disabled
  if ($use_Dyna) {
	$tmp = <<"END";
bootstrap $module \$VERSION;
END
  } else {
	$tmp = <<"END";
require XSLoader;
XSLoader::load('$module', \$VERSION);
END
  }
  $tmp =~ s:\$VERSION:\$XS_VERSION:g if $opt_B;
  print PM $tmp;
}

# tying the variables can happen only after bootstrap
if (@vdecls) {
    printf PM <<END;
{
@{[ join "\n", map "    _tievar_$_(\$$_);", @vdecls ]}
}

END
}

my $after;
if( $opt_P ){ # if POD is disabled
	$after = '__END__';
}
else {
	$after = '=cut';
}

print PM <<"END";

# Preloaded methods go here.
END

print PM <<"END" unless $opt_A;

# Autoload methods go after $after, and are processed by the autosplit program.
END

print PM <<"END";

1;
__END__
END

my ($email,$author,$licence);

eval {
       my $username;
       ($username,$author) = (getpwuid($>))[0,6];
       if (defined $username && defined $author) {
	   $author =~ s/,.*$//; # in case of sub fields
	   my $domain = $Config{'mydomain'};
	   $domain =~ s/^\.//;
	   $email = "$username\@$domain";
       }
     };

$author =~ s/'/\\'/g if defined $author;
$author ||= "A. U. Thor";
$email  ||= 'a.u.thor@a.galaxy.far.far.away';

$licence = sprintf << "DEFAULT", $^V;
Copyright (C) ${\(1900 + (localtime) [5])} by $author

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version %vd or,
at your option, any later version of Perl 5 you may have available.
DEFAULT

my $revhist = '';
$revhist = <<EOT if $opt_C;
#
#=head1 HISTORY
#
#=over 8
#
#=item $TEMPLATE_VERSION
#
#Original version; created by h2xs $H2XS_VERSION with options
#
#  @ARGS
#
#=back
#
EOT

my $exp_doc = $skip_exporter ? '' : <<EOD;
#
#=head2 EXPORT
#
#None by default.
#
EOD

if (@const_names and not $opt_P) {
  $exp_doc .= <<EOD unless $skip_exporter;
#=head2 Exportable constants
#
#  @{[join "\n  ", @const_names]}
#
EOD
}

if (defined $fdecls and @$fdecls and not $opt_P) {
