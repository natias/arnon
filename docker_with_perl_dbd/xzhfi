       if @* != keepregstar | sil! let @* = keepregstar | endif
       if @+ != keepregplus | sil! let @+ = keepregplus | endif
      endif
      sil! let @/ = keepregslash
"      call Dret("netrw#Explore")
      return
     endif
     let indx= w:netrw_explore_indx
     if indx < 0                        | let indx= 0                           | endif
     if indx >= w:netrw_explore_listlen | let indx= w:netrw_explore_listlen - 1 | endif
     let curfile= w:netrw_explore_list[indx]
"     call Decho("....indx=".indx." curfile<".curfile.">",'~'.expand("<slnum>"))
     while indx < w:netrw_explore_listlen && curfile == w:netrw_explore_list[indx]
      let indx= indx + 1
"      call Decho("....indx=".indx." (Nexplore while loop)",'~'.expand("<slnum>"))
     endwhile
     if indx >= w:netrw_explore_listlen | let indx= w:netrw_explore_listlen - 1 | endif
"     call Decho("....Nexplore: indx= [w:netrw_explore_indx=".w:netrw_explore_indx."]=".indx,'~'.expand("<slnum>"))

    elseif indx == -2
     " Pexplore
"     call Decho("case Pexplore with starpat=".starpat.": (indx=".indx.")",'~'.expand("<slnum>"))
     if !exists("w:netrw_explore_list") " sanity check
      NetrwKeepj call netrw#ErrorMsg(s:WARNING,"using Pexplore or <s-up> improperly; see help for netrw-starstar",41)
      if has("clipboard") && g:netrw_clipboard
"       call Decho("(netrw#Explore) restore @* and @+",'~'.expand("<slnum>"))
       if @* != keepregstar | sil! let @* = keepregstar | endif
       if @+ != keepregplus | sil! let @+ = keepregplus | endif
      endif
      sil! let @/ = keepregslash
"      call Dret("netrw#Explore")
      return
     endif
     let indx= w:netrw_explore_indx
     if indx < 0                        | let indx= 0                           | endif
     if indx >= w:netrw_explore_listlen | let indx= w:netrw_explore_listlen - 1 | endif
     let curfile= w:netrw_explore_list[indx]
"     call Decho("....indx=".indx." curfile<".curfile.">",'~'.expand("<slnum>"))
     while indx >= 0 && curfile == w:netrw_explore_list[indx]
      let indx= indx - 1
"      call Decho("....indx=".indx." (Pexplore while loop)",'~'.expand("<slnum>"))
     endwhile
     if indx < 0                        | let indx= 0                           | endif
"     call Decho("....Pexplore: indx= [w:netrw_explore_indx=".w:netrw_explore_indx."]=".indx,'~'.expand("<slnum>"))

    else
     " Explore -- initialize
     " build list of files to Explore with Nexplore/Pexplore
"     call Decho("..starpat=".starpat.": case Explore: initialize (indx=".indx.")",'~'.expand("<slnum>"))
     NetrwKeepj keepalt call s:NetrwClearExplore()
     let w:netrw_explore_indx= 0
     if !exists("b:netrw_curdir")
      let b:netrw_curdir= getcwd()
     endif
"     call Decho("....starpat=".starpat.": b:netrw_curdir<".b:netrw_curdir.">",'~'.expand("<slnum>"))

     " switch on starpat to build the w:netrw_explore_list of files
     if starpat == 1
      " starpat=1: Explore *//pattern  (current directory only search for files containing pattern)
"      call Decho("..case starpat=".starpat.": build *//pattern list  (curdir-only srch for files containing pattern)  &hls=".&hls,'~'.expand("<slnum>"))
"      call Decho("....pattern<".pattern.">",'~'.expand("<slnum>"))
      try
       exe "NetrwKeepj noautocmd vimgrep /".pattern."/gj ".fnameescape(b:netrw_curdir)."/*"
      catch /^Vim\%((\a\+)\)\=:E480/
       keepalt call netrw#ErrorMsg(s:WARNING,"no match with pattern<".pattern.">",76)
"       call Dret("netrw#Explore : unable to find pattern<".pattern.">")
       return
      endtry
      let w:netrw_explore_list = s:NetrwExploreListUniq(map(getqflist(),'bufname(v:val.bufnr)'))
      if &hls | let keepregslash= s:ExplorePatHls(pattern) | endif

     elseif starpat == 2
      " starpat=2: Explore **//pattern (recursive descent search for files containing pattern)
"      call Decho("..case starpat=".starpat.": build **//pattern list  (recursive descent files containing pattern)",'~'.expand("<slnum>"))
"      call Decho("....pattern<".pattern.">",'~'.expand("<slnum>"))
      try
       exe "sil NetrwKeepj noautocmd keepalt vimgrep /".pattern."/gj "."**/*"
      catch /^Vim\%((\a\+)\)\=:E480/
       keepalt call netrw#ErrorMsg(s:WARNING,'no files matched pattern<'.pattern.'>',45)
       if &hls | let keepregslash= s:ExplorePatHls(pattern) | endif
       if has("clipboard") && g:netrw_clipboard
"        call Decho("(netrw#Explore) restore @* and @+",'~'.expand("<slnum>"))
        if @* != keepregstar | sil! let @* = keepregstar | endif
        if @+ != keepregplus | sil! let @+ = keepregplus | endif
       endif
       sil! let @/ = keepregslash
"       call Dret("netrw#Explore : no files matched pattern")
       return
      endtry
      let s:netrw_curdir       = b:netrw_curdir
      let w:netrw_explore_list = getqflist()
      let w:netrw_explore_list = s:NetrwExploreListUniq(map(w:netrw_explore_list,'s:netrw_curdir."/".bufname(v:val.bufnr)'))
      if &hls | let keepregslash= s:ExplorePatHls(pattern) | endif

     elseif starpat == 3
      " starpat=3: Explore */filepat   (search in current directory for filenames matching filepat)
"      call Decho("..case starpat=".starpat.": build */filepat list  (curdir-only srch filenames matching filepat)  &hls=".&hls,'~'.expand("<slnum>"))
      let filepat= substitute(dirname,'^\*/','','')
      let filepat= substitute(filepat,'^[%#<]','\\&','')
"      call Decho("....b:netrw_curdir<".b:netrw_curdir.">",'~'.expand("<slnum>"))
"      call Decho("....filepat<".filepat.">",'~'.expand("<slnum>"))
      let w:netrw_explore_list= s:NetrwExploreListUniq(split(expand(b:netrw_curdir."/".filepat),'\n'))
      if &hls | let keepregslash= s:ExplorePatHls(filepat) | endif

     elseif starpat == 4
      " starpat=4: Explore **/filepat  (recursive descent search for filenames matching filepat)
"      call Decho("..case starpat=".starpat.": build **/filepat list  (recursive descent srch filenames matching filepat)  &hls=".&hls,'~'.expand("<slnum>"))
      let w:netrw_explore_list= s:NetrwExploreListUniq(split(expand(b:netrw_curdir."/".dirname),'\n'))
      if &hls | let keepregslash= s:ExplorePatHls(dirname) | endif
     endif " switch on starpat to build w:netrw_explore_list

     let w:netrw_explore_listlen = len(w:netrw_explore_list)
"     call Decho("....w:netrw_explore_list<".string(w:netrw_explore_list).">",'~'.expand("<slnum>"))
"     call Decho("....w:netrw_explore_listlen=".w:netrw_explore_listlen,'~'.expand("<slnum>"))

     if w:netrw_explore_listlen == 0 || (w:netrw_explore_listlen == 1 && w:netrw_explore_list[0] =~ '\*\*\/')
      keepalt NetrwKeepj call netrw#ErrorMsg(s:WARNING,"no files matched",42)
      if has("clipboard") && g:netrw_clipboard
"       call Decho("(netrw#Explore) restore @* and @+",'~'.expand("<slnum>"))
        if @* != keepregstar | sil! let @* = keepregstar | endif
        if @+ != keepregplus | sil! let @+ = keepregplus | endif
      endif
      sil! let @/ = keepregslash
"      call Dret("netrw#Explore : no files matched")
      return
     endif
    endif  " if indx ... endif

    " NetrwStatusLine support - for exploring support
    let w:netrw_explore_indx= indx
"    call Decho("....w:netrw_explore_list<".join(w:netrw_explore_list,',')."> len=".w:netrw_explore_listlen,'~'.expand("<slnum>"))

    " wrap the indx around, but issue a note
    if indx >= w:netrw_explore_listlen || indx < 0
"     call Decho("....wrap indx (indx=".indx." listlen=".w:netrw_explore_listlen.")",'~'.expand("<slnum>"))
     let indx                = (indx < 0)? ( w:netrw_explore_listlen - 1 ) : 0
     let w:netrw_explore_indx= indx
     keepalt NetrwKeepj call netrw#ErrorMsg(s:NOTE,"no more files match Explore pattern",43)
    endif

    exe "let dirfile= w:netrw_explore_list[".indx."]"
"    call Decho("....dirfile=w:netrw_explore_list[indx=".indx."]= <".dirfile.">",'~'.expand("<slnum>"))
    let newdir= substitute(dirfile,'/[^/]*$','','e')
"    call Decho("....newdir<".newdir.">",'~'.expand("<slnum>"))

"    call Decho("....calling LocalBrowseCheck(newdir<".newdir.">)",'~'.expand("<slnum>"))
    call netrw#LocalBrowseCheck(newdir)
    if !exists("w:netrw_liststyle")
     let w:netrw_liststyle= g:netrw_liststyle
    endif
    if w:netrw_liststyle == s:THINLIST || w:netrw_liststyle == s:LONGLIST
     keepalt NetrwKeepj call search('^'.substitute(dirfile,"^.*/","","").'\>',"W")
    else
     keepalt NetrwKeepj call search('\<'.substitute(dirfile,"^.*/","","").'\>',"w")
    endif
    let w:netrw_explore_mtchcnt = indx + 1
    let w:netrw_explore_bufnr   = bufnr("%")
    let w:netrw_explore_line    = line(".")
    keepalt NetrwKeepj call s:SetupNetrwStatusLine('%f %h%m%r%=%9*%{NetrwStatusLine()}')
"    call Decho("....explore: mtchcnt=".w:netrw_explore_mtchcnt." bufnr=".w:netrw_explore_bufnr." line#".w:netrw_explore_line,'~'.expand("<slnum>"))

   else
"    call Decho("..your vim does not have +path_extra",'~'.expand("<slnum>"))
    if !exists("g:netrw_quiet")
     keepalt NetrwKeepj call netrw#ErrorMsg(s:WARNING,"your vim needs the +path_extra feature for Exploring with **!",44)
    endif
    if has("clipboard") && g:netrw_clipboard
"     call Decho("(netrw#Explore) restore @* and @+",'~'.expand("<slnum>"))
      if @* != keepregstar | sil! let @* = keepregstar | endif
      if @+ != keepregplus | sil! let @+ = keepregplus | endif
    endif
    sil! let @/ = keepregslash
"    call Dret("netrw#Explore : missing +path_extra")
    return
   endif

  else
"   call Decho("..default case: Explore newdir<".dirname.">",'~'.expand("<slnum>"))
   if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && dirname =~ '/'
    sil! unlet w:netrw_treedict
    sil! unlet w:netrw_treetop
   endif
   let newdir= dirname
   if !exists("b:netrw_curdir")
    NetrwKeepj call netrw#LocalBrowseCheck(getcwd())
   else
    NetrwKeepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,newdir))
   endif
  endif

  " visual display of **/ **// */ Exploration files
"  call Decho("w:netrw_explore_indx=".(exists("w:netrw_explore_indx")? w:netrw_explore_indx : "doesn't exist"),'~'.expand("<slnum>"))
"  call Decho("b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "n/a").">",'~'.expand("<slnum>"))
  if exists("w:netrw_explore_indx") && exists("b:netrw_curdir")
"   call Decho("s:explore_prvdir<".(exists("s:explore_prvdir")? s:explore_prvdir : "-doesn't exist-"),'~'.expand("<slnum>"))
   if !exists("s:explore_prvdir") || s:explore_prvdir != b:netrw_curdir
    " only update match list when current directory isn't the same as before
"    call Decho("only update match list when current directory not the same as before",'~'.expand("<slnum>"))
    let s:explore_prvdir = b:netrw_curdir
    let s:explore_match  = ""
    let dirlen           = strlen(b:netrw_curdir)
    if b:netrw_curdir !~ '/$'
     let dirlen= dirlen + 1
    endif
    let prvfname= ""
    for fname in w:netrw_explore_list
"     call Decho("fname<".fname.">",'~'.expand("<slnum>"))
     if fname =~ '^'.b:netrw_curdir
      if s:explore_match == ""
       let s:explore_match= '\<'.escape(strpart(fname,dirlen),g:netrw_markfileesc).'\>'
      else
       let s:explore_match= s:explore_match.'\|\<'.escape(strpart(fname,dirlen),g:netrw_markfileesc).'\>'
      endif
     elseif fname !~ '^/' && fname != prvfname
      if s:explore_match == ""
       let s:explore_match= '\<'.escape(fname,g:netrw_markfileesc).'\>'
      else
       let s:explore_match= s:explore_match.'\|\<'.escape(fname,g:netrw_markfileesc).'\>'
      endif
     endif
     let prvfname= fname
    endfor
"    call Decho("explore_match<".s:explore_match.">",'~'.expand("<slnum>"))
    if has("syntax") && exists("g:syntax_on") && g:syntax_on
     exe "2match netrwMarkFile /".s:explore_match."/"
    endif
   endif
   echo "<s-up>==Pexplore  <s-down>==Nexplore"
  else
   2match none
   if exists("s:explore_match")  | unlet s:explore_match  | endif
   if exists("s:explore_prvdir") | unlet s:explore_prvdir | endif
   echo " "
"   call Decho("cleared explore match list",'~'.expand("<slnum>"))
  endif

  " since Explore may be used to initialize netrw's browser,
  " there's no danger of a late FocusGained event on initialization.
  " Consequently, set s:netrw_events to 2.
  let s:netrw_events= 2
  if has("clipboard") && g:netrw_clipboard
"   call Decho("(netrw#Explore) restore @* and @+",'~'.expand("<slnum>"))
   if @* != keepregstar | sil! let @* = keepregstar | endif
   if @+ != keepregplus | sil! let @+ = keepregplus | endif
  endif
  sil! let @/ = keepregslash
"  call Dret("netrw#Explore : @/<".@/.">")
endfun

" ---------------------------------------------------------------------
" netrw#Lexplore: toggle Explorer window, keeping it on the left of the current tab {{{2
fun! netrw#Lexplore(count,rightside,...)
"  call Dfunc("netrw#Lexplore(count=".a:count." rightside=".a:rightside.",...) a:0=".a:0." ft=".&ft)
  let curwin= winnr()

  if a:0 > 0 && a:1 != ""
   " if a netrw window is already on the left-side of the tab
   " and a directory has been specified, explore with that
   " directory.
"   call Decho("case has input argument(s) (a:1<".a:1.">)")
   let a1 = expand(a:1)
"   call Decho("a:1<".a:1.">  curwin#".curwin,'~'.expand("<slnum>"))
   exe "1wincmd w"
   if &ft == "netrw"
"    call Decho("exe Explore ".fnameescape(a:1),'~'.expand("<slnum>"))
    exe "Explore ".fnameescape(a1)
    exe curwin."wincmd w"
    if exists("t:netrw_lexposn")
"     call Decho("forgetting t:netrw_lexposn",'~'.expand("<slnum>"))
     unlet t:netrw_lexposn
    endif
"    call Dret("netrw#Lexplore")
    return
   endif
   exe curwin."wincmd w"
  else
   let a1= ""
"   call Decho("no input arguments")
  endif

  if exists("t:netrw_lexbufnr")
   " check if t:netrw_lexbufnr refers to a netrw window
   let lexwinnr = bufwinnr(t:netrw_lexbufnr)
"   call Decho("lexwinnr= bufwinnr(t:netrw_lexbufnr#".t:netrw_lexbufnr.")=".lexwinnr)
  else
   let lexwinnr= 0
"   call Decho("t:netrw_lexbufnr doesn't exist")
  endif
"  call Decho("lexwinnr=".lexwinnr,'~'.expand("<slnum>"))

  if lexwinnr > 0
   " close down netrw explorer window
"   call Decho("t:netrw_lexbufnr#".t:netrw_lexbufnr.": close down netrw window",'~'.expand("<slnum>"))
   exe lexwinnr."wincmd w"
   let g:netrw_winsize = -winwidth(0)
   let t:netrw_lexposn = winsaveview()
"   call Decho("saving posn to t:netrw_lexposn<".string(t:netrw_lexposn).">",'~'.expand("<slnum>"))
"   call Decho("saving t:netrw_lexposn",'~'.expand("<slnum>"))
   close
   if lexwinnr < curwin
    let curwin= curwin - 1
   endif
   if lexwinnr != curwin
    exe curwin."wincmd w"
   endif
   unlet t:netrw_lexbufnr
"   call Decho("unlet t:netrw_lexbufnr")

  else
   " open netrw explorer window
"   call Decho("t:netrw_lexbufnr<n/a>: open netrw explorer window",'~'.expand("<slnum>"))
   exe "1wincmd w"
   let keep_altv    = g:netrw_altv
   let g:netrw_altv = 0
   if a:count != 0
    let netrw_winsize   = g:netrw_winsize
    let g:netrw_winsize = a:count
   endif
   let curfile= expand("%")
"   call Decho("curfile<".curfile.">",'~'.expand("<slnum>"))
   exe (a:rightside? "botright" : "topleft")." vertical ".((g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize) . " new"
"   call Decho("new buf#".bufnr("%")." win#".winnr())
   if a:0 > 0 && a1 != ""
"    call Decho("case 1: Explore ".a1,'~'.expand("<slnum>"))
    call netrw#Explore(0,0,0,a1)
    exe "Explore ".fnameescape(a1)
   elseif curfile =~ '^\a\{3,}://'
"    call Decho("case 2: Explore ".substitute(curfile,'[^/\\]*$','',''),'~'.expand("<slnum>"))
    call netrw#Explore(0,0,0,substitute(curfile,'[^/\\]*$','',''))
   else
"    call Decho("case 3: Explore .",'~'.expand("<slnum>"))
    call netrw#Explore(0,0,0,".")
   endif
   if a:count != 0
    let g:netrw_winsize = netrw_winsize
   endif
   setlocal winfixwidth
   let g:netrw_altv     = keep_altv
   let t:netrw_lexbufnr = bufnr("%")
   " done to prevent build-up of hidden buffers due to quitting and re-invocation of :Lexplore.
   " Since the intended use of :Lexplore is to have an always-present explorer window, the extra
   " effort to mis-use :Lex is warranted.
   set bh=wipe
"   call Decho("let t:netrw_lexbufnr=".t:netrw_lexbufnr) 
"   call Decho("t:netrw_lexposn".(exists("t:netrw_lexposn")? string(t:netrw_lexposn) : " n/a"))
   if exists("t:netrw_lexposn")
"    call Decho("restoring to t:netrw_lexposn",'~'.expand("<slnum>"))
"    call Decho("restoring posn to t:netrw_lexposn<".string(t:netrw_lexposn).">",'~'.expand("<slnum>"))
    call winrestview(t:netrw_lexposn)
    unlet t:netrw_lexposn
   endif
  endif

  " set up default window for editing via <cr>
  if exists("g:netrw_chgwin") && g:netrw_chgwin == -1
   if a:rightside
    let g:netrw_chgwin= 1
   else
    let g:netrw_chgwin= 2
   endif
"   call Decho("let g:netrw_chgwin=".g:netrw_chgwin)
  endif

"  call Dret("netrw#Lexplore")
endfun

" ---------------------------------------------------------------------
" netrw#Clean: remove netrw {{{2
" supports :NetrwClean  -- remove netrw from first directory on runtimepath
"          :NetrwClean! -- remove netrw from all directories on runtimepath
fun! netrw#Clean(sys)
"  call Dfunc("netrw#Clean(sys=".a:sys.")")

  if a:sys
   let choice= confirm("Remove personal and system copies of netrw?","&Yes\n&No")
  else
   let choice= confirm("Remove personal copy of netrw?","&Yes\n&No")
  endif
"  call Decho("choice=".choice,'~'.expand("<slnum>"))
  let diddel= 0
  let diddir= ""

  if choice == 1
   for dir in split(&rtp,',')
    if filereadable(dir."/plugin/netrwPlugin.vim")
"     call Decho("removing netrw-related files from ".dir,'~'.expand("<slnum>"))
     if s:NetrwDelete(dir."/plugin/netrwPlugin.vim")        |call netrw#ErrorMsg(1,"unable to remove ".dir."/plugin/netrwPlugin.vim",55)        |endif
     if s:NetrwDelete(dir."/autoload/netrwFileHandlers.vim")|call netrw#ErrorMsg(1,"unable to remove ".dir."/autoload/netrwFileHandlers.vim",55)|endif
     if s:NetrwDelete(dir."/autoload/netrwSettings.vim")    |call netrw#ErrorMsg(1,"unable to remove ".dir."/autoload/netrwSettings.vim",55)    |endif
     if s:NetrwDelete(dir."/autoload/netrw.vim")            |call netrw#ErrorMsg(1,"unable to remove ".dir."/autoload/netrw.vim",55)            |endif
     if s:NetrwDelete(dir."/syntax/netrw.vim")              |call netrw#ErrorMsg(1,"unable to remove ".dir."/syntax/netrw.vim",55)              |endif
     if s:NetrwDelete(dir."/syntax/netrwlist.vim")          |call netrw#ErrorMsg(1,"unable to remove ".dir."/syntax/netrwlist.vim",55)          |endif
     let diddir= dir
     let diddel= diddel + 1
     if !a:sys|break|endif
    endif
   endfor
  endif

   echohl WarningMsg
  if diddel == 0
   echomsg "netrw is either not installed or not removable"
  elseif diddel == 1
   echomsg "removed one copy of netrw from <".diddir.">"
  else
   echomsg "removed ".diddel." copies of netrw"
  endif
   echohl None

"  call Dret("netrw#Clean")
endfun

" ---------------------------------------------------------------------
" netrw#MakeTgt: make a target out of the directory name provided {{{2
fun! netrw#MakeTgt(dname)
"  call Dfunc("netrw#MakeTgt(dname<".a:dname.">)")
   " simplify the target (eg. /abc/def/../ghi -> /abc/ghi)
  let svpos               = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let s:netrwmftgt_islocal= (a:dname !~ '^\a\{3,}://')
"  call Decho("s:netrwmftgt_islocal=".s:netrwmftgt_islocal,'~'.expand("<slnum>"))
  if s:netrwmftgt_islocal
   let netrwmftgt= simplify(a:dname)
  else
   let netrwmftgt= a:dname
  endif
  if exists("s:netrwmftgt") && netrwmftgt == s:netrwmftgt
   " re-selected target, so just clear it
   unlet s:netrwmftgt s:netrwmftgt_islocal
  else
   let s:netrwmftgt= netrwmftgt
  endif
  if g:netrw_fastbrowse <= 1
   call s:NetrwRefresh((b:netrw_curdir !~ '\a\{3,}://'),b:netrw_curdir)
  endif
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))"
  call winrestview(svpos)
"  call Dret("netrw#MakeTgt")
endfun

" ---------------------------------------------------------------------
" netrw#Obtain: {{{2
"   netrw#Obtain(islocal,fname[,tgtdirectory])
"     islocal=0  obtain from remote source
"            =1  obtain from local source
"     fname  :   a filename or a list of filenames
"     tgtdir :   optional place where files are to go  (not present, uses getcwd())
fun! netrw#Obtain(islocal,fname,...)
"  call Dfunc("netrw#Obtain(islocal=".a:islocal." fname<".((type(a:fname) == 1)? a:fname : string(a:fname)).">) a:0=".a:0)
  " NetrwStatusLine support - for obtaining support

  if type(a:fname) == 1
   let fnamelist= [ a:fname ]
  elseif type(a:fname) == 3
   let fnamelist= a:fname
  else
   call netrw#ErrorMsg(s:ERROR,"attempting to use NetrwObtain on something not a filename or a list",62)
"   call Dret("netrw#Obtain")
   return
  endif
"  call Decho("fnamelist<".string(fnamelist).">",'~'.expand("<slnum>"))
  if a:0 > 0
   let tgtdir= a:1
  else
   let tgtdir= getcwd()
  endif
"  call Decho("tgtdir<".tgtdir.">",'~'.expand("<slnum>"))

  if exists("b:netrw_islocal") && b:netrw_islocal
   " obtain a file from local b:netrw_curdir to (local) tgtdir
"   call Decho("obtain a file from local ".b:netrw_curdir." to ".tgtdir,'~'.expand("<slnum>"))
   if exists("b:netrw_curdir") && getcwd() != b:netrw_curdir
    let topath= s:ComposePath(tgtdir,"")
    if (has("win32") || has("win95") || has("win64") || has("win16"))
     " transfer files one at time
"     call Decho("transfer files one at a time",'~'.expand("<slnum>"))
     for fname in fnamelist
"      call Decho("system(".g:netrw_localcopycmd." ".s:ShellEscape(fname)." ".s:ShellEscape(topath).")",'~'.expand("<slnum>"))
      call system(g:netrw_localcopycmd.g:netrw_localcopycmdopt." ".s:ShellEscape(fname)." ".s:ShellEscape(topath))
      if v:shell_error != 0
       call netrw#ErrorMsg(s:WARNING,"consider setting g:netrw_localcopycmd<".g:netrw_localcopycmd."> to something that works",80)
"       call Dret("s:NetrwObtain 0 : failed: ".g:netrw_localcopycmd." ".s:ShellEscape(fname)." ".s:ShellEscape(topath))
       return
      endif
     endfor
    else
     " transfer files with one command
"     call Decho("transfer files with one command",'~'.expand("<slnum>"))
     let filelist= join(map(deepcopy(fnamelist),"s:ShellEscape(v:val)"))
"     call Decho("system(".g:netrw_localcopycmd." ".filelist." ".s:ShellEscape(topath).")",'~'.expand("<slnum>"))
     call system(g:netrw_localcopycmd.g:netrw_localcopycmdopt." ".filelist." ".s:ShellEscape(topath))
     if v:shell_error != 0
      call netrw#ErrorMsg(s:WARNING,"consider setting g:netrw_localcopycmd<".g:netrw_localcopycmd."> to something that works",80)
"      call Dret("s:NetrwObtain 0 : failed: ".g:netrw_localcopycmd." ".filelist." ".s:ShellEscape(topath))
      return
     endif
    endif
   elseif !exists("b:netrw_curdir")
    call netrw#ErrorMsg(s:ERROR,"local browsing directory doesn't exist!",36)
   else
    call netrw#ErrorMsg(s:WARNING,"local browsing directory and current directory are identical",37)
   endif

  else
   " obtain files from remote b:netrw_curdir to local tgtdir
"   call Decho("obtain a file from remote ".b:netrw_curdir." to ".tgtdir,'~'.expand("<slnum>"))
   if type(a:fname) == 1
    call s:SetupNetrwStatusLine('%f %h%m%r%=%9*Obtaining '.a:fname)
   endif
   call s:NetrwMethod(b:netrw_curdir)

   if b:netrw_method == 4
    " obtain file using scp
"    call Decho("obtain via scp (method#4)",'~'.expand("<slnum>"))
    if exists("g:netrw_port") && g:netrw_port != ""
     let useport= " ".g:netrw_scpport." ".g:netrw_port
    else
     let useport= ""
    endif
    if b:netrw_fname =~ '/'
     let path= substitute(b:netrw_fname,'^\(.*/\).\{-}$','\1','')
    else
     let path= ""
    endif
    let filelist= join(map(deepcopy(fnamelist),'escape(s:ShellEscape(g:netrw_machine.":".path.v:val,1)," ")'))
    call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_scp_cmd.s:ShellEscape(useport,1)." ".filelist." ".s:ShellEscape(tgtdir,1))

   elseif b:netrw_method == 2
    " obtain file using ftp + .netrc
"     call Decho("obtain via ftp+.netrc (method #2)",'~'.expand("<slnum>"))
     call s:SaveBufVars()|sil NetrwKeepj new|call s:RestoreBufVars()
     let tmpbufnr= bufnr("%")
     setl ff=unix
     if exists("g:netrw_ftpmode") && g:netrw_ftpmode != ""
      NetrwKeepj put =g:netrw_ftpmode
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     endif

     if exists("b:netrw_fname") && b:netrw_fname != ""
      call setline(line("$")+1,'cd "'.b:netrw_fname.'"')
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     endif

     if exists("g:netrw_ftpextracmd")
      NetrwKeepj put =g:netrw_ftpextracmd
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     endif
     for fname in fnamelist
      call setline(line("$")+1,'get "'.fname.'"')
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     endfor
     if exists("g:netrw_port") && g:netrw_port != ""
      call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1)." ".s:ShellEscape(g:netrw_port,1))
     else
      call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1))
     endif
     " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
     if getline(1) !~ "^$" && !exists("g:netrw_quiet") && getline(1) !~ '^Trying '
      let debugkeep= &debug
      setl debug=msg
      call netrw#ErrorMsg(s:ERROR,getline(1),4)
      let &debug= debugkeep
     endif

   elseif b:netrw_method == 3
    " obtain with ftp + machine, id, passwd, and fname (ie. no .netrc)
"    call Decho("obtain via ftp+mipf (method #3)",'~'.expand("<slnum>"))
    call s:SaveBufVars()|sil NetrwKeepj new|call s:RestoreBufVars()
    let tmpbufnr= bufnr("%")
    setl ff=unix

    if exists("g:netrw_port") && g:netrw_port != ""
     NetrwKeepj put ='open '.g:netrw_machine.' '.g:netrw_port
"     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
    else
     NetrwKeepj put ='open '.g:netrw_machine
"     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
    endif

    if exists("g:netrw_uid") && g:netrw_uid != ""
     if exists("g:netrw_ftp") && g:netrw_ftp == 1
      NetrwKeepj put =g:netrw_uid
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
      if exists("s:netrw_passwd") && s:netrw_passwd != ""
       NetrwKeepj put ='\"'.s:netrw_passwd.'\"'
      endif
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     elseif exists("s:netrw_passwd")
      NetrwKeepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     endif
    endif

    if exists("g:netrw_ftpmode") && g:netrw_ftpmode != ""
     NetrwKeepj put =g:netrw_ftpmode
"     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
    endif

    if exists("b:netrw_fname") && b:netrw_fname != ""
     NetrwKeepj call setline(line("$")+1,'cd "'.b:netrw_fname.'"')
"     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
    endif

    if exists("g:netrw_ftpextracmd")
     NetrwKeepj put =g:netrw_ftpextracmd
"     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
    endif

    if exists("g:netrw_ftpextracmd")
     NetrwKeepj put =g:netrw_ftpextracmd
"     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
    endif
    for fname in fnamelist
     NetrwKeepj call setline(line("$")+1,'get "'.fname.'"')
    endfor
"    call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))

    " perform ftp:
    " -i       : turns off interactive prompting from ftp
    " -n  unix : DON'T use <.netrc>, even though it exists
    " -n  win32: quit being obnoxious about password
    "  Note: using "_dd to delete to the black hole register; avoids messing up @@
    NetrwKeepj norm! 1G"_dd
    call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
    " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
    if getline(1) !~ "^$"
"     call Decho("error<".getline(1).">",'~'.expand("<slnum>"))
     if !exists("g:netrw_quiet")
      NetrwKeepj call netrw#ErrorMsg(s:ERROR,getline(1),5)
     endif
    endif

   elseif b:netrw_method == 9
    " obtain file using sftp
"    call Decho("obtain via sftp (method #9)",'~'.expand("<slnum>"))
    if a:fname =~ '/'
     let localfile= substitute(a:fname,'^.*/','','')
    else
     let localfile= a:fname
    endif
    call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_sftp_cmd." ".s:ShellEscape(g:netrw_machine.":".b:netrw_fname,1).s:ShellEscape(localfile)." ".s:ShellEscape(tgtdir))

   elseif !exists("b:netrw_method") || b:netrw_method < 0
    " probably a badly formed url; protocol not recognized
"    call Dret("netrw#Obtain : unsupported method")
    return

   else
    " protocol recognized but not supported for Obtain (yet?)
    if !exists("g:netrw_quiet")
     NetrwKeepj call netrw#ErrorMsg(s:ERROR,"current protocol not supported for obtaining file",97)
    endif
"    call Dret("netrw#Obtain : current protocol not supported for obtaining file")
    return
   endif

   " restore status line
   if type(a:fname) == 1 && exists("s:netrw_users_stl")
    NetrwKeepj call s:SetupNetrwStatusLine(s:netrw_users_stl)
   endif

  endif

  " cleanup
  if exists("tmpbufnr")
   if bufnr("%") != tmpbufnr
    exe tmpbufnr."bw!"
   else
    q!
   endif
  endif

"  call Dret("netrw#Obtain")
endfun

" ---------------------------------------------------------------------
" netrw#Nread: save position, call netrw#NetRead(), and restore position {{{2
fun! netrw#Nread(mode,fname)
"  call Dfunc("netrw#Nread(mode=".a:mode." fname<".a:fname.">)")
  let svpos= winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  call netrw#NetRead(a:mode,a:fname)
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  call winrestview(svpos)

  if exists("w:netrw_liststyle") && w:netrw_liststyle != s:TREELIST
   if exists("w:netrw_bannercnt")
    " start with cursor just after the banner
    exe w:netrw_bannercnt
   endif
  endif
"  call Dret("netrw#Nread")
endfun

" ------------------------------------------------------------------------
" s:NetrwOptionsSave: save options prior to setting to "netrw-buffer-standard" form {{{2
"             Options get restored by s:NetrwOptionsRestore()
"
"             Option handling:
"              * save user's options                                     (s:NetrwOptionsSave)
"              * set netrw-safe options                                  (s:NetrwOptionsSafe)
"                - change an option only when user option != safe option (s:netrwSetSafeSetting)
"              * restore user's options                                  (s:netrwOPtionsRestore)
"                - restore a user option when != safe option             (s:NetrwRestoreSetting)
"             vt: (variable type) normally its either "w:" or "s:"
fun! s:NetrwOptionsSave(vt)
"  call Dfunc("s:NetrwOptionsSave(vt<".a:vt.">) win#".winnr()." buf#".bufnr("%")."<".bufname(bufnr("%")).">"." winnr($)=".winnr("$")." mod=".&mod." ma=".&ma)
"  call Decho(a:vt."netrw_optionsave".(exists("{a:vt}netrw_optionsave")? ("=".{a:vt}netrw_optionsave) : " doesn't exist"),'~'.expand("<slnum>"))
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt." hid=".&hid,'~'.expand("<slnum>"))
"  call Decho("(s:NetrwOptionsSave) lines=".&lines)

  if !exists("{a:vt}netrw_optionsave")
   let {a:vt}netrw_optionsave= 1
  else
"   call Dret("s:NetrwOptionsSave : options already saved")
   return
  endif
"  call Decho("prior to save: fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist")." diff=".&l:diff,'~'.expand("<slnum>"))

  " Save current settings and current directory
"  call Decho("saving current settings and current directory",'~'.expand("<slnum>"))
  let s:yykeep          = @@
  if exists("&l:acd")|let {a:vt}netrw_acdkeep  = &l:acd|endif
  let {a:vt}netrw_aikeep    = &l:ai
  let {a:vt}netrw_awkeep    = &l:aw
  let {a:vt}netrw_bhkeep    = &l:bh
  let {a:vt}netrw_blkeep    = &l:bl
  let {a:vt}netrw_btkeep    = &l:bt
  let {a:vt}netrw_bombkeep  = &l:bomb
  let {a:vt}netrw_cedit     = &cedit
  let {a:vt}netrw_cikeep    = &l:ci
  let {a:vt}netrw_cinkeep   = &l:cin
  let {a:vt}netrw_cinokeep  = &l:cino
  let {a:vt}netrw_comkeep   = &l:com
  let {a:vt}netrw_cpokeep   = &l:cpo
  let {a:vt}netrw_cuckeep   = &l:cuc
  let {a:vt}netrw_culkeep   = &l:cul
"  call Decho("(s:NetrwOptionsSave) COMBAK: cuc=".&l:cuc." cul=".&l:cul)
  let {a:vt}netrw_diffkeep  = &l:diff
  let {a:vt}netrw_fenkeep   = &l:fen
  if !exists("g:netrw_ffkeep") || g:netrw_ffkeep
   let {a:vt}netrw_ffkeep    = &l:ff
  endif
  let {a:vt}netrw_fokeep    = &l:fo           " formatoptions
  let {a:vt}netrw_gdkeep    = &l:gd           " gdefault
  let {a:vt}netrw_gokeep    = &l:go           " guioptions
  let {a:vt}netrw_hidkeep   = &l:hidden
  let {a:vt}netrw_imkeep    = &l:im
  let {a:vt}netrw_iskkeep   = &l:isk
  let {a:vt}netrw_lines     = &lines
  let {a:vt}netrw_lskeep    = &l:ls
  let {a:vt}netrw_makeep    = &l:ma
  let {a:vt}netrw_magickeep = &l:magic
  let {a:vt}netrw_modkeep   = &l:mod
  let {a:vt}netrw_nukeep    = &l:nu
  let {a:vt}netrw_rnukeep   = &l:rnu
  let {a:vt}netrw_repkeep   = &l:report
  let {a:vt}netrw_rokeep    = &l:ro
  let {a:vt}netrw_selkeep   = &l:sel
  let {a:vt}netrw_spellkeep = &l:spell
  if !g:netrw_use_noswf
   let {a:vt}netrw_swfkeep  = &l:swf
  endif
  let {a:vt}netrw_tskeep    = &l:ts
  let {a:vt}netrw_twkeep    = &l:tw           " textwidth
  let {a:vt}netrw_wigkeep   = &l:wig          " wildignore
  let {a:vt}netrw_wrapkeep  = &l:wrap
  let {a:vt}netrw_writekeep = &l:write

  " save a few selected netrw-related variables
"  call Decho("saving a few selected netrw-related variables",'~'.expand("<slnum>"))
  if g:netrw_keepdir
   let {a:vt}netrw_dirkeep  = getcwd()
"   call Decho("saving to ".a:vt."netrw_dirkeep<".{a:vt}netrw_dirkeep.">",'~'.expand("<slnum>"))
  endif
  if has("clipboard") && g:netrw_clipboard
   sil! let {a:vt}netrw_starkeep = @*
   sil! let {a:vt}netrw_pluskeep = @+
  endif
  sil! let {a:vt}netrw_slashkeep= @/

"  call Decho("(s:NetrwOptionsSave) lines=".&lines)
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
"  call Dret("s:NetrwOptionsSave : tab#".tabpagenr()." win#".winnr())
endfun

" ---------------------------------------------------------------------
" s:NetrwOptionsSafe: sets options to help netrw do its job {{{2
"                     Use  s:NetrwSaveOptions() to save user settings
"                     Use  s:NetrwOptionsRestore() to restore user settings
fun! s:NetrwOptionsSafe(islocal)
"  call Dfunc("s:NetrwOptionsSafe(islocal=".a:islocal.") win#".winnr()." buf#".bufnr("%")."<".bufname(bufnr("%"))."> winnr($)=".winnr("$"))
"  call Decho("win#".winnr()."'s ft=".&ft,'~'.expand("<slnum>"))
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
  if exists("+acd") | call s:NetrwSetSafeSetting("&l:acd",0)|endif
  call s:NetrwSetSafeSetting("&l:ai",0)
  call s:NetrwSetSafeSetting("&l:aw",0)
  call s:NetrwSetSafeSetting("&l:bl",0)
  call s:NetrwSetSafeSetting("&l:bomb",0)
  if a:islocal
   call s:NetrwSetSafeSetting("&l:bt","nofile")
  else
   call s:NetrwSetSafeSetting("&l:bt","acwrite")
  endif
  call s:NetrwSetSafeSetting("&l:ci",0)
  call s:NetrwSetSafeSetting("&l:cin",0)
  if g:netrw_fastbrowse > a:islocal
   call s:NetrwSetSafeSetting("&l:bh","hide")
  else
   call s:NetrwSetSafeSetting("&l:bh","delete")
  endif
  call s:NetrwSetSafeSetting("&l:cino","")
  call s:NetrwSetSafeSetting("&l:com","")
  if &cpo =~ 'a' | call s:NetrwSetSafeSetting("&cpo",substitute(&cpo,'a','','g')) | endif
  if &cpo =~ 'A' | call s:NetrwSetSafeSetting("&cpo",substitute(&cpo,'A','','g')) | endif
  setl fo=nroql2
  " call s:NetrwSetSafeSetting("&go","begmr")
  if &go =~ '\ca' | call s:NetrwSetSafeSetting("&go",substitute(&go,'\ca','','g')) | endif
  call s:NetrwSetSafeSetting("&l:hid",0)
  call s:NetrwSetSafeSetting("&l:im",0)
  setl isk+=@ isk+=* isk+=/
  call s:NetrwSetSafeSetting("&l:magic",1)
  if g:netrw_use_noswf
   call s:NetrwSetSafeSetting("swf",0)
  endif
  call s:NetrwSetSafeSetting("&l:report",10000)
  call s:NetrwSetSafeSetting("&l:sel","inclusive")
  call s:NetrwSetSafeSetting("&l:spell",0)
  call s:NetrwSetSafeSetting("&l:tw",0)
  call s:NetrwSetSafeSetting("&l:wig","")
  setl cedit&

  " set up cuc and cul based on g:netrw_cursor and listing style
  " COMBAK -- cuc cul related
  call s:NetrwCursor(0)

  " allow the user to override safe options
"  call Decho("ft<".&ft."> ei=".&ei,'~'.expand("<slnum>"))
  if &ft == "netrw"
"   call Decho("do any netrw FileType autocmds (doau FileType netrw)",'~'.expand("<slnum>"))
   keepalt NetrwKeepj doau FileType netrw
  endif

"  call Decho("fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist")." bh=".&l:bh." bt<".&bt.">",'~'.expand("<slnum>"))
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
"  call Dret("s:NetrwOptionsSafe")
endfun

" ---------------------------------------------------------------------
" s:NetrwOptionsRestore: restore options (based on prior s:NetrwOptionsSave) {{{2
fun! s:NetrwOptionsRestore(vt)
"  call Dfunc("s:NetrwOptionsRestore(vt<".a:vt.">) win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> winnr($)=".winnr("$"))
"  call Decho("(s:NetrwOptionsRestore) lines=".&lines)
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
  if !exists("{a:vt}netrw_optionsave")
"   call Decho("case ".a:vt."netrw_optionsave : doesn't exist",'~'.expand("<slnum>"))
   if !isdirectory(expand('%'))
"    call Decho("..doing filetype detect anyway")
     filetype detect
   endif
"   call Decho("..settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
"   call Decho("..ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
"   call Dret("s:NetrwOptionsRestore : ".a:vt."netrw_optionsave doesn't exist")
   return
  endif
  unlet {a:vt}netrw_optionsave

  if exists("+acd")
   if exists("{a:vt}netrw_acdkeep")
"    call Decho("g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd,'~'.expand("<slnum>"))
    let curdir = getcwd()
    let &l:acd = {a:vt}netrw_acdkeep
    unlet {a:vt}netrw_acdkeep
    if &l:acd
     call s:NetrwLcd(curdir)
    endif
   endif
  endif
"  call Decho("(s:NetrwOptionsRestore) #1 lines=".&lines)
  call s:NetrwRestoreSetting(a:vt."netrw_aikeep","&l:ai")
  call s:NetrwRestoreSetting(a:vt."netrw_awkeep","&l:aw")
  call s:NetrwRestoreSetting(a:vt."netrw_blkeep","&l:bl")
  call s:NetrwRestoreSetting(a:vt."netrw_btkeep","&l:bt")
  call s:NetrwRestoreSetting(a:vt."netrw_bombkeep","&l:bomb")
"  call Decho("(s:NetrwOptionsRestore) #2 lines=".&lines)
  call s:NetrwRestoreSetting(a:vt."netrw_cedit","&cedit")
  call s:NetrwRestoreSetting(a:vt."netrw_cikeep","&l:ci")
  call s:NetrwRestoreSetting(a:vt."netrw_cinkeep","&l:cin")
  call s:NetrwRestoreSetting(a:vt."netrw_cinokeep","&l:cino")
  call s:NetrwRestoreSetting(a:vt."netrw_comkeep","&l:com")
"  call Decho("(s:NetrwOptionsRestore) #3 lines=".&lines)
  call s:NetrwRestoreSetting(a:vt."netrw_cpokeep","&l:cpo")
  call s:NetrwRestoreSetting(a:vt."netrw_diffkeep","&l:diff")
  call s:NetrwRestoreSetting(a:vt."netrw_fenkeep","&l:fen")
  if exists("g:netrw_ffkeep") && g:netrw_ffkeep
   call s:NetrwRestoreSetting(a:vt."netrw_ffkeep")","&l:ff")
  endif
"  call Decho("(s:NetrwOptionsRestore) #4 lines=".&lines)
  call s:NetrwRestoreSetting(a:vt."netrw_fokeep"   ,"&l:fo")
  call s:NetrwRestoreSetting(a:vt."netrw_gdkeep"   ,"&l:gd")
  call s:NetrwRestoreSetting(a:vt."netrw_gokeep"   ,"&l:go")
  call s:NetrwRestoreSetting(a:vt."netrw_hidkeep"  ,"&l:hidden")
"  call Decho("(s:NetrwOptionsRestore) #5 lines=".&lines)
  call s:NetrwRestoreSetting(a:vt."netrw_imkeep"   ,"&l:im")
  call s:NetrwRestoreSetting(a:vt."netrw_iskkeep"  ,"&l:isk")
"  call Decho("(s:NetrwOptionsRestore) #6 lines=".&lines)
  call s:NetrwRestoreSetting(a:vt."netrw_lines"    ,"&lines")
"  call Decho("(s:NetrwOptionsRestore) #7 lines=".&lines)
  call s:NetrwRestoreSetting(a:vt."netrw_lskeep"   ,"&l:ls")
  call s:NetrwRestoreSetting(a:vt."netrw_makeep"   ,"&l:ma")
  call s:NetrwRestoreSetting(a:vt."netrw_magickeep","&l:magic")
  call s:NetrwRestoreSetting(a:vt."netrw_modkeep"  ,"&l:mod")
  call s:NetrwRestoreSetting(a:vt."netrw_nukeep"   ,"&l:nu")
"  call Decho("(s:NetrwOptionsRestore) #8 lines=".&lines)
  call s:NetrwRestoreSetting(a:vt."netrw_rnukeep"  ,"&l:rnu")
  call s:NetrwRestoreSetting(a:vt."netrw_repkeep"  ,"&l:report")
  call s:NetrwRestoreSetting(a:vt."netrw_rokeep"   ,"&l:ro")
  call s:NetrwRestoreSetting(a:vt."netrw_selkeep"  ,"&l:sel")
"  call Decho("(s:NetrwOptionsRestore) #9 lines=".&lines)
  call s:NetrwRestoreSetting(a:vt."netrw_spellkeep","&l:spell")
  call s:NetrwRestoreSetting(a:vt."netrw_twkeep"   ,"&l:tw")
  call s:NetrwRestoreSetting(a:vt."netrw_wigkeep"  ,"&l:wig")
  call s:NetrwRestoreSetting(a:vt."netrw_wrapkeep" ,"&l:wrap")
  call s:NetrwRestoreSetting(a:vt."netrw_writekeep","&l:write")
"  call Decho("(s:NetrwOptionsRestore) #10 lines=".&lines)
  call s:NetrwRestoreSetting("s:yykeep","@@")
  " former problem: start with liststyle=0; press <i> : result, following line resets l:ts.
  " Fixed; in s:PerformListing, when w:netrw_liststyle is s:LONGLIST, will use a printf to pad filename with spaces
  "        rather than by appending a tab which previously was using "&ts" to set the desired spacing.  (Sep 28, 2018)
  call s:NetrwRestoreSetting(a:vt."netrw_tskeep","&l:ts")

  if exists("{a:vt}netrw_swfkeep")
   if &directory == ""
    " user hasn't specified a swapfile directory;
    " netrw will temporarily set the swapfile directory
    " to the current directory as returned by getcwd().
    let &l:directory= getcwd()
    sil! let &l:swf = {a:vt}netrw_swfkeep
    setl directory=
    unlet {a:vt}netrw_swfkeep
   elseif &l:swf != {a:vt}netrw_swfkeep
    if !g:netrw_use_noswf
     " following line causes a Press ENTER in windows -- can't seem to work around it!!!
     sil! let &l:swf= {a:vt}netrw_swfkeep
    endif
    unlet {a:vt}netrw_swfkeep
   endif
  endif
  if exists("{a:vt}netrw_dirkeep") && isdirectory(s:NetrwFile({a:vt}netrw_dirkeep)) && g:netrw_keepdir
   let dirkeep = substitute({a:vt}netrw_dirkeep,'\\','/','g')
   if exists("{a:vt}netrw_dirkeep")
    call s:NetrwLcd(dirkeep)
    unlet {a:vt}netrw_dirkeep
   endif
  endif
  if has("clipboard") && g:netrw_clipboard
"   call Decho("has clipboard",'~'.expand("<slnum>"))
   call s:NetrwRestoreSetting(a:vt."netrw_starkeep","@*")
   call s:NetrwRestoreSetting(a:vt."netrw_pluskeep","@+")
  endif
  call s:NetrwRestoreSetting(a:vt."netrw_slashkeep","@/")

"  call Decho("g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd,'~'.expand("<slnum>"))
"  call Decho("fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist"),'~'.expand("<slnum>"))
"  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
"  call Decho("diff=".&l:diff." win#".winnr()." w:netrw_diffkeep=".(exists("w:netrw_diffkeep")? w:netrw_diffkeep : "doesn't exist"),'~'.expand("<slnum>"))
"  call Decho("ts=".&l:ts,'~'.expand("<slnum>"))
  " Moved the filetype detect here from NetrwGetFile() because remote files
  " were having their filetype detect-generated settings overwritten by
  " NetrwOptionRestore.
  if &ft != "netrw"
    if !isdirectory(expand('%'))
"     call Decho("before: filetype detect  (ft=".&ft.")",'~'.expand("<slnum>"))
      filetype detect
"     call Decho("after : filetype detect  (ft=".&ft.")",'~'.expand("<slnum>"))
    endif
  endif
"  call Decho("(s:NetrwOptionsRestore) lines=".&lines)
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
"  call Dret("s:NetrwOptionsRestore : tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)
endfun

" ---------------------------------------------------------------------
" s:NetrwSetSafeSetting: sets an option to a safe setting {{{2
"                        but only when the options' value and the safe setting differ
"                        Doing this means that netrw will not come up as having changed a
"                        setting last when it really didn't actually change it.
"
"                        Called from s:NetrwOptionsSafe
"                          ex. call s:NetrwSetSafeSetting("&l:sel","inclusive")
fun! s:NetrwSetSafeSetting(setting,safesetting)
"  call Dfunc("s:NetrwSetSafeSetting(setting<".a:setting."> safesetting<".a:safesetting.">)")

  if a:setting =~ '^&'
"   call Decho("fyi: a:setting starts with &")
   exe "let settingval= ".a:setting
"   call Decho("fyi: settingval<".settingval.">")

   if settingval != a:safesetting
"    call Decho("set setting<".a:setting."> to option value<".a:safesetting.">")
