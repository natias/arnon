'tags'		  'tag'     list of file names used by the tag command
'tagstack'	  'tgst'    push tags onto the tag stack
'tcldll'		    name of the Tcl dynamic library
'term'			    name of the terminal
'termbidi'	  'tbidi'   terminal takes care of bi-directionality
'termencoding'	  'tenc'    character encoding used by the terminal
'termguicolors'	  'tgc'     use GUI colors for the terminal
'termwinkey'	  'twk'	    key that precedes a Vim command in a terminal
'termwinscroll'   'twsl'    max number of scrollback lines in a terminal window
'termwinsize'	  'tws'	    size of a terminal window
'termwintype'	  'twt'	    MS-Windows: type of pty to use for terminal window
'terse'			    shorten some messages
'textauto'	  'ta'	    obsolete, use 'fileformats'
'textmode'	  'tx'	    obsolete, use 'fileformat'
'textwidth'	  'tw'	    maximum width of text that is being inserted
'thesaurus'	  'tsr'     list of thesaurus files for keyword completion
'thesaurusfunc'	  'tsrfu'   function to be used for thesaurus completion
'tildeop'	  'top'     tilde command "~" behaves like an operator
'timeout'	  'to'	    time out on mappings and key codes
'timeoutlen'	  'tm'	    time out time in milliseconds
'title'			    let Vim set the title of the window
'titlelen'		    percentage of 'columns' used for window title
'titleold'		    old title, restored when exiting
'titlestring'		    string to use for the Vim window title
'toolbar'	  'tb'	    GUI: which items to show in the toolbar
'toolbariconsize' 'tbis'    size of the toolbar icons (for GTK 2 only)
'ttimeout'		    time out on mappings
'ttimeoutlen'	  'ttm'     time out time for key codes in milliseconds
'ttybuiltin'	  'tbi'     use built-in termcap before external termcap
'ttyfast'	  'tf'	    indicates a fast terminal connection
'ttymouse'	  'ttym'    type of mouse codes generated
'ttyscroll'	  'tsl'     maximum number of lines for a scroll
'ttytype'	  'tty'     alias for 'term'
'undodir'	  'udir'    where to store undo files
'undofile'	  'udf'	    save undo information in a file
'undolevels'	  'ul'	    maximum number of changes that can be undone
'undoreload'	  'ur'	    max nr of lines to save for undo on a buffer reload
'updatecount'	  'uc'	    after this many characters flush swap file
'updatetime'	  'ut'	    after this many milliseconds flush swap file
'varsofttabstop'  'vsts'    a list of number of spaces when typing <Tab>
'vartabstop'	  'vts'	    a list of number of spaces for <Tab>s
'verbose'	  'vbs'     give informative messages
'verbosefile'	  'vfile'   file to write messages in
'viewdir'	  'vdir'    directory where to store files with :mkview
'viewoptions'	  'vop'     specifies what to save for :mkview
'viminfo'	  'vi'	    use .viminfo file upon startup and exiting
'viminfofile'	  'vif'	    file name used for the viminfo file
'virtualedit'	  've'	    when to use virtual editing
'visualbell'	  'vb'	    use visual bell instead of beeping
'warn'			    warn for shell command when buffer was changed
'weirdinvert'	  'wiv'	    for terminals that have weird inversion method
'whichwrap'	  'ww'	    allow specified keys to cross line boundaries
'wildchar'	  'wc'	    command-line character for wildcard expansion
'wildcharm'	  'wcm'     like 'wildchar' but also works when mapped
'wildignore'	  'wig'     files matching these patterns are not completed
'wildignorecase'  'wic'     ignore case when completing file names
'wildmenu'	  'wmnu'    use menu for command line completion
'wildmode'	  'wim'     mode for 'wildchar' command-line expansion
'wildoptions'	  'wop'     specifies how command line completion is done
'winaltkeys'	  'wak'     when the windows system handles ALT keys
'wincolor'	  'wcr'	    window-local highlighting
'window'	  'wi'	    nr of lines to scroll for CTRL-F and CTRL-B
'winheight'	  'wh'	    minimum number of lines for the current window
'winfixheight'	  'wfh'     keep window height when opening/closing windows
'winfixwidth'	  'wfw'     keep window width when opening/closing windows
'winminheight'	  'wmh'     minimum number of lines for any window
'winminwidth'	  'wmw'     minimal number of columns for any window
'winptydll'		    name of the winpty dynamic library
'winwidth'	  'wiw'     minimal number of columns for current window
'wrap'			    long lines wrap and continue on the next line
'wrapmargin'	  'wm'	    chars from the right where wrapping starts
'wrapscan'	  'ws'	    searches wrap around the end of the file
'write'			    writing to a file is allowed
'writeany'	  'wa'	    write to file with no need for "!" override
'writebackup'	  'wb'	    make a backup before overwriting a file
'writedelay'	  'wd'	    delay this many msec for each char (for debug)
'xtermcodes'		    request terminal codes from an xterm
------------------------------------------------------------------------------
*Q_ur*		Undo/Redo commands

|u|       N  u		undo last N changes
|CTRL-R|  N  CTRL-R	redo last N undone changes
|U|          U		restore last changed line
------------------------------------------------------------------------------
*Q_et*		External commands

|:shell|	:sh[ell]	start a shell
|:!|		:!{command}	execute {command} with a shell
|K|		   K		lookup keyword under the cursor with
				   'keywordprg' program (default: "man")
------------------------------------------------------------------------------
*Q_qf*		Quickfix commands

|:cc|		:cc [nr]	display error [nr] (default is the same again)
|:cnext|	:cn		display the next error
|:cprevious|	:cp		display the previous error
|:clist|	:cl		list all errors
|:cfile|	:cf		read errors from the file 'errorfile'
|:cgetbuffer|	:cgetb		like :cbuffer but don't jump to the first error
|:cgetfile|	:cg		like :cfile but don't jump to the first error
|:cgetexpr|	:cgete		like :cexpr but don't jump to the first error
|:caddfile|	:caddf		add errors from the error file to the current
				   quickfix list
|:caddexpr|	:cad		add errors from an expression to the current
				   quickfix list
|:cbuffer|	:cb		read errors from text in a buffer
|:cexpr|	:cex		read errors from an expression
|:cquit|	:cq		quit without writing and return error code (to
				   the compiler)
|:make|		:make [args]	start make, read errors, and jump to first
				   error
|:grep|		:gr[ep] [args]	execute 'grepprg' to find matches and jump to
				   the first one
------------------------------------------------------------------------------
*Q_vc*		Various commands

|CTRL-L|	   CTRL-L	clear and redraw the screen
|CTRL-G|	   CTRL-G	show current file name (with path) and cursor
				   position
|ga|		   ga		show ascii value of character under cursor in
				   decimal, hex, and octal
|g8|		   g8		for utf-8 encoding: show byte sequence for
				   character under cursor in hex
|g_CTRL-G|	   g CTRL-G	show cursor column, line, and character
				   position
|CTRL-C|	   CTRL-C	during searches: Interrupt the search
|dos-CTRL-Break|   CTRL-Break	MS-Windows: during searches: Interrupt the
				   search
|<Del>|		   <Del>	while entering a count: delete last character
|:version|	:ve[rsion]	show version information
|:mode|		:mode N		set screen mode to N (obsolete)
|:normal|	:norm[al][!] {commands}
				execute Normal mode commands
|Q|		   Q		switch to "Ex" mode

|:redir|	:redir >{file}		redirect messages to {file}
|:silent|	:silent[!] {command}	execute {command} silently
|:confirm|	:confirm {command}	quit, write, etc., asking about
					unsaved changes or read-only files
|:browse|	:browse {command}	open/read/write file, using a
					file selection dialog
------------------------------------------------------------------------------
*Q_ce*		Command-line editing

|c_<Esc>|	<Esc>		   abandon command-line (if 'wildchar' is
				      <Esc>, type it twice)

|c_CTRL-V|	CTRL-V {char}	   insert {char} literally
|c_CTRL-V|	CTRL-V {number}    enter decimal value of character (up to
				      three digits)
|c_CTRL-K|	CTRL-K {char1} {char2}
				   enter digraph (See |Q_di|)
|c_CTRL-R|	CTRL-R {register}  insert the contents of a register

|c_<Left>|	<Left>/<Right>	   cursor left/right
|c_<S-Left>|	<S-Left>/<S-Right> cursor one word left/right
|c_CTRL-B|	CTRL-B/CTRL-E	   cursor to beginning/end of command-line

|c_<BS>|	<BS>		   delete the character in front of the cursor
|c_<Del>|	<Del>		   delete the character under the cursor
|c_CTRL-W|	CTRL-W		   delete the word in front of the cursor
|c_CTRL-U|	CTRL-U		   remove all characters

|c_<Up>|	<Up>/<Down>	   recall older/newer command-line that starts
				      with current command
|c_<S-Up>|	<S-Up>/<S-Down>	   recall older/newer command-line from history
|c_CTRL-G|	CTRL-G		   next match when 'incsearch' is active
|c_CTRL-T|	CTRL-T		   previous match when 'incsearch' is active
|:history|	:his[tory]	   show older command-lines

Context-sensitive completion on the command-line:

|c_wildchar|	'wildchar'  (default: <Tab>)
				do completion on the pattern in front of the
				   cursor; if there are multiple matches,
				   beep and show the first one; further
				   'wildchar' will show the next ones
|c_CTRL-D|	CTRL-D		list all names that match the pattern in
				   front of the cursor
|c_CTRL-A|	CTRL-A		insert all names that match pattern in front
				   of cursor
|c_CTRL-L|	CTRL-L		insert longest common part of names that
				   match pattern
|c_CTRL-N|	CTRL-N		after 'wildchar' with multiple matches: go
				   to next match
|c_CTRL-P|	CTRL-P		after 'wildchar' with multiple matches: go
				   to previous match
------------------------------------------------------------------------------
*Q_ra*		Ex ranges

|:range|	,		separates two line numbers
|:range|	;		idem, set cursor to the first line number
				before interpreting the second one

|:range|	{number}	an absolute line number
|:range|	.		the current line
|:range|	$		the last line in the file
|:range|	%		equal to 1,$ (the entire file)
|:range|	*		equal to '<,'> (visual area)
|:range|	't		position of mark t
|:range|	/{pattern}[/]	the next line where {pattern} matches
|:range|	?{pattern}[?]	the previous line where {pattern} matches

|:range|	+[num]		add [num] to the preceding line number
				   (default: 1)
|:range|	-[num]		subtract [num] from the preceding line
				   number (default: 1)
------------------------------------------------------------------------------
*Q_ex*		Special Ex characters

|:bar|      |		separates two commands (not for ":global" and ":!")
|:quote|    "		begins comment

|:_%|       %		current file name (only where a file name is expected)
|:_#|       #[num]	alternate file name [num] (only where a file name is
			   expected)
	Note: The next seven are typed literally; these are not special keys!
|:<abuf>|   <abuf>	buffer number, for use in an autocommand (only where a
			   file name is expected)
|:<afile>|  <afile>	file name, for use in an autocommand (only where a
			   file name is expected)
|:<amatch>| <amatch>	what matched with the pattern, for use in an
			   autocommand (only where a file name is expected)
|:<cword>|  <cword>	word under the cursor (only where a file name is
			   expected)
|:<cWORD>|  <cWORD>	WORD under the cursor (only where a file name is
			   expected) (see |WORD|)
|:<cfile>|  <cfile>	file name under the cursor (only where a file name is
			   expected)
|:<sfile>|  <sfile>	file name of a ":source"d file, within that file (only
			   where a file name is expected)

		After "%", "#", "<cfile>", "<sfile>" or "<afile>"
		|::p|	    :p		full path
		|::h|	    :h		head (file name removed)
		|::t|	    :t		tail (file name only)
		|::r|	    :r		root (extension removed)
		|::e|	    :e		extension
		|::s|	    :s/{pat}/{repl}/	substitute {pat} with {repl}
------------------------------------------------------------------------------
*Q_st*		Starting Vim

|-vim|	   vim [options]		start editing with an empty buffer
|-file|	   vim [options] {file} ..	start editing one or more files
|--|	   vim [options] -		read file from stdin
|-tag|	   vim [options] -t {tag}	edit the file associated with {tag}
|-qf|	   vim [options] -q [fname]	start editing in QuickFix mode,
					   display the first error

	Most useful Vim arguments (for full list see |startup-options|)

|-gui|	-g		    start GUI (also allows other options)

|-+|	+[num]		    put the cursor at line [num] (default: last line)
|-+c|	+{command}	    execute {command} after loading the file
|-+/|	+/{pat} {file} ..   put the cursor at the first occurrence of {pat}
|-v|	-v		    Vi mode, start ex in Normal mode
|-e|	-e		    Ex mode, start vim in Ex mode
|-R|	-R		    Read-only mode, implies -n
|-m|	-m		    modifications not allowed (resets 'write' option)
|-d|	-d		    diff mode |diff|
|-b|	-b		    binary mode
|-l|	-l		    lisp mode
|-A|	-A		    Arabic mode ('arabic' is set)
|-F|	-F		    Farsi mode ('fkmap' and 'rightleft' are set)
|-H|	-H		    Hebrew mode ('hkmap' and 'rightleft' are set)
|-V|	-V		    Verbose, give informative messages
|-C|	-C		    Compatible, set the 'compatible' option
|-N|	-N		    Nocompatible, reset the 'compatible' option
|-r|	-r		    give list of swap files
|-r|	-r {file} ..	    recover aborted edit session
|-n|	-n		    do not create a swap file
|-o|	-o [num]	    open [num] windows (default: one for each file)
|-f|	-f		    GUI: foreground process, don't fork
			    Amiga: do not restart Vim to open a window (for
				e.g., mail)
|-s|	-s {scriptin}	    first read commands from the file {scriptin}
|-w|	-w {scriptout}	    write typed chars to file {scriptout} (append)
|-W|	-W {scriptout}	    write typed chars to file {scriptout} (overwrite)
|-T|	-T {terminal}	    set terminal name
|-d|	-d {device}	    Amiga: open {device} to be used as a console
|-u|	-u {vimrc}	    read inits from {vimrc} instead of other inits
|-U|	-U {gvimrc}	    idem, for when starting the GUI
|-i|	-i {viminfo}	    read info from {viminfo} instead of other files
|---|	--		    end of options, other arguments are file names
|--help|    --help	    show list of arguments and exit
|--version| --version	    show version info and exit
|--|	-		    read file from stdin
------------------------------------------------------------------------------
*Q_ed*		Editing a file

	   Without !: Fail if changes have been made to the current buffer.
	      With !: Discard any changes to the current buffer.
|:edit_f|  :e[dit][!] {file}	edit {file}
|:edit|    :e[dit][!]		reload the current file
|:enew|    :ene[w][!]		edit a new, unnamed buffer
|:find|    :fin[d][!] {file}	find {file} in 'path' and edit it

|CTRL-^|   N  CTRL-^		edit alternate file N (equivalent to ":e #N")
|gf|          gf  or ]f		edit the file whose name is under the cursor
|:pwd|     :pwd			print the current directory name
|:cd|      :cd [path]		change the current directory to [path]
|:cd-|     :cd -		back to previous current directory
|:file|    :f[ile]		print the current file name and the cursor
				   position
|:file|    :f[ile] {name}	set the current file name to {name}
|:files|   :files		show alternate file names
------------------------------------------------------------------------------
*Q_fl*		Using the argument list			|argument-list|

|:args|	   :ar[gs]		print the argument list, with the current file
				   in "[]"
|:all|	   :all  or :sall	open a window for every file in the arg list
|:wn|	   :wn[ext][!]		write file and edit next file
|:wn|	   :wn[ext][!] {file}	write to {file} and edit next file, unless
				   {file} exists; With !, overwrite existing
				   file
|:wN|	   :wN[ext][!] [file]	write file and edit previous file

	     in current window    in new window	~
|:argument|  :argu[ment] N	  :sar[gument] N	edit file N
|:next|      :n[ext]		  :sn[ext]		edit next file
|:next_f|    :n[ext] {arglist}	  :sn[ext] {arglist}	define new arg list
							   and edit first file
|:Next|      :N[ext]		  :sN[ext]		edit previous file
|:first|     :fir[st]		  :sfir[st]		edit first file
|:last|      :la[st]		  :sla[st]		edit last file
------------------------------------------------------------------------------
*Q_wq*		Writing and quitting

|:w|	  :[range]w[rite][!]		write to the current file
|:w_f|	  :[range]w[rite] {file}	write to {file}, unless it already
					   exists
|:w_f|	  :[range]w[rite]! {file}	write to {file}.  Overwrite an existing
					   file
|:w_a|	  :[range]w[rite][!] >>		append to the current file
|:w_a|	  :[range]w[rite][!] >> {file}	append to {file}
|:w_c|	  :[range]w[rite] !{cmd}	execute {cmd} with [range] lines as
					   standard input
|:up|	  :[range]up[date][!]		write to current file if modified
|:wall|	  :wa[ll][!]			write all changed buffers

|:q|	  :q[uit]		quit current buffer, unless changes have been
				   made; Exit Vim when there are no other
				   non-help buffers
|:q|	  :q[uit]!		quit current buffer always, discard any
				   changes.  Exit Vim when there are no other
				   non-help buffers
|:qa|	  :qa[ll]		exit Vim, unless changes have been made
|:qa|	  :qa[ll]!		exit Vim always, discard any changes
|:cq|	  :cq			quit without writing and return error code

|:wq|	  :wq[!]		write the current file and exit
|:wq|	  :wq[!] {file}		write to {file} and exit
|:xit|	  :x[it][!] [file]	like ":wq" but write only when changes have
				   been made
|ZZ|	     ZZ			same as ":x"
|ZQ|	     ZQ			same as ":q!"
|:xall|	  :xa[ll][!]  or :wqall[!]
				write all changed buffers and exit

|:stop|	  :st[op][!]		suspend Vim or start new shell; if 'aw' option
				   is set and [!] not given write the buffer
|CTRL-Z|     CTRL-Z		same as ":stop"
------------------------------------------------------------------------------
*Q_ac*		Automatic Commands

|viminfo-file|	read registers, marks, history at startup, save when exiting.

|:rviminfo|	:rv[iminfo] [file]	read info from viminfo file [file]
|:rviminfo|	:rv[iminfo]! [file]	idem, overwrite existing info
|:wviminfo|	:wv[iminfo] [file]	add info to viminfo file [file]
|:wviminfo|	:wv[iminfo]! [file]	write info to viminfo file [file]

|modeline|	Automatic option setting when editing a file

|modeline|	vim:{set-arg}: ..	In the first and last lines of the
					file (see 'ml' option), {set-arg} is
					given as an argument to ":set"

|autocommand|	Automatic execution of commands on certain events.

|:autocmd|	:au			  list all autocommands
|:autocmd|	:au {event}		  list all autocommands for {event}
|:autocmd|	:au {event} {pat}	  list all autocommands for {event}
					  with {pat}
|:autocmd|	:au {event} {pat} {cmd}	  enter new autocommands for {event}
					  with {pat}
|:autocmd|	:au!			  remove all autocommands
|:autocmd|	:au! {event}		  remove all autocommands for {event}
|:autocmd|	:au! * {pat}		  remove all autocommands for {pat}
|:autocmd|	:au! {event} {pat}	  remove all autocommands for {event}
					  with {pat}
|:autocmd|	:au! {event} {pat} {cmd}  remove all autocommands for {event}
					  with {pat} and enter new one
------------------------------------------------------------------------------
*Q_wi*		Multi-window commands

|CTRL-W_s|	CTRL-W s  or  :split	split window into two parts
|:split_f|	:split {file}		split window and edit {file} in one of
					   them
|:vsplit|	:vsplit {file}		same, but split vertically
|:vertical|	:vertical {cmd}		make {cmd} split vertically

|:sfind|	:sf[ind] {file}		split window, find {file} in 'path'
					   and edit it
|:terminal|	:terminal {cmd}		open a terminal window
|CTRL-W_]|	CTRL-W ]		split window and jump to tag under
					   cursor
|CTRL-W_f|	CTRL-W f		split window and edit file name under
					   the cursor
|CTRL-W_^|	CTRL-W ^		split window and edit alternate file
|CTRL-W_n|	CTRL-W n  or  :new	create new empty window
|CTRL-W_q|	CTRL-W q  or  :q[uit]	quit editing and close window
|CTRL-W_c|	CTRL-W c  or  :clo[se]	make buffer hidden and close window
|CTRL-W_o|	CTRL-W o  or  :on[ly]	make current window only one on the
					   screen

|CTRL-W_j|	CTRL-W j		move cursor to window below
|CTRL-W_k|	CTRL-W k		move cursor to window above
|CTRL-W_CTRL-W|	CTRL-W CTRL-W		move cursor to window below (wrap)
|CTRL-W_W|	CTRL-W W		move cursor to window above (wrap)
|CTRL-W_t|	CTRL-W t		move cursor to top window
|CTRL-W_b|	CTRL-W b		move cursor to bottom window
|CTRL-W_p|	CTRL-W p		move cursor to previous active window

|CTRL-W_r|	CTRL-W r		rotate windows downwards
|CTRL-W_R|	CTRL-W R		rotate windows upwards
|CTRL-W_x|	CTRL-W x		exchange current window with next one

|CTRL-W_=|	CTRL-W =		make all windows equal height & width
|CTRL-W_-|	CTRL-W -		decrease current window height
|CTRL-W_+|	CTRL-W +		increase current window height
|CTRL-W__|	CTRL-W _		set current window height (default:
					   very high)

|CTRL-W_<|	CTRL-W <		decrease current window width
|CTRL-W_>|	CTRL-W >		increase current window width
|CTRL-W_bar|	CTRL-W |		set current window width (default:
					   widest possible)
------------------------------------------------------------------------------
*Q_bu*		Buffer list commands

|:buffers|	:buffers  or  :files	list all known buffer and file names

|:ball|		:ball	  or  :sball	edit all args/buffers
|:unhide|	:unhide   or  :sunhide	edit all loaded buffers

|:badd|		:badd {fname}		add file name {fname} to the list
|:bunload|	:bunload[!] [N]		unload buffer [N] from memory
|:bdelete|	:bdelete[!] [N]		unload buffer [N] and delete it from
					   the buffer list

		in current window  in new window       ~
|:buffer|	:[N]buffer [N]     :[N]sbuffer [N]     to arg/buf N
|:bnext|	:[N]bnext [N]      :[N]sbnext [N]      to Nth next arg/buf
|:bNext|	:[N]bNext [N]      :[N]sbNext [N]      to Nth previous arg/buf
|:bprevious|	:[N]bprevious [N]  :[N]sbprevious [N]  to Nth previous arg/buf
|:bfirst|	:bfirst	           :sbfirst            to first arg/buf
|:blast|	:blast	           :sblast             to last arg/buf
|:bmodified|	:[N]bmod [N]       :[N]sbmod [N]       to Nth modified buf
------------------------------------------------------------------------------
*Q_sy*		Syntax Highlighting

|:syn-on|	:syntax on		start using syntax highlighting
|:syn-off|	:syntax off		stop using syntax highlighting

|:syn-keyword|	:syntax keyword {group-name} {keyword} ..
					add a syntax keyword item
|:syn-match|	:syntax match {group-name} {pattern} ...
					add syntax match item
|:syn-region|	:syntax region {group-name} {pattern} ...
					add syntax region item
|:syn-sync|	:syntax sync [ccomment | lines {N} | ...]
					tell syntax how to sync
|:syntax|	:syntax [list]		list current syntax items
|:syn-clear|	:syntax clear		clear all syntax info

|:highlight|	:highlight clear	clear all highlight info
|:highlight|	:highlight {group-name} {key}={arg} ..
					set highlighting for {group-name}

|:filetype|	:filetype on		switch on file type detection, without
					syntax highlighting
|:filetype|	:filetype plugin indent on
					switch on file type detection, with
					automatic indenting and settings
------------------------------------------------------------------------------
*Q_gu*		GUI commands

|:gui|		:gui			UNIX: start the GUI
|:gui|		:gui {fname} ..		idem, and edit {fname} ..

|:menu|		:menu			list all menus
|:menu|		:menu {mpath}		list menus starting with {mpath}
|:menu|		:menu {mpath} {rhs}	add menu {mpath}, giving {rhs}
|:menu|		:menu {pri} {mpath} {rhs}
					idem, with priorities {pri}
|:menu|		:menu ToolBar.{name} {rhs}
					add toolbar item, giving {rhs}
|:tmenu|	:tmenu {mpath} {text}	add tooltip to menu {mpath}
|:unmenu|	:unmenu {mpath}		remove menu {mpath}
------------------------------------------------------------------------------
*Q_fo*		Folding

|'foldmethod'|	set foldmethod=manual	manual folding
		set foldmethod=indent	folding by indent
		set foldmethod=expr	folding by 'foldexpr'
		set foldmethod=syntax	folding by syntax regions
		set foldmethod=marker	folding by 'foldmarker'

|zf|		zf{motion}		operator: Define a fold manually
|:fold|		:{range}fold		define a fold for {range} lines
|zd|		zd			delete one fold under the cursor
|zD|		zD			delete all folds under the cursor

|zo|		zo			open one fold under the cursor
|zO|		zO			open all folds under the cursor
|zc|		zc			close one fold under the cursor
|zC|		zC			close all folds under the cursor

|zm|		zm			fold more: decrease 'foldlevel'
|zM|		zM			close all folds: make 'foldlevel' zero
|zr|		zr			reduce folding: increase 'foldlevel'
|zR|		zR			open all folds: make 'foldlevel' max.

|zn|		zn			fold none: reset 'foldenable'
|zN|		zN			fold normal set 'foldenable'
|zi|		zi			invert 'foldenable'

 vim:tw=78:ts=8:noet:ft=help:norl:
                                                                                                                                                                                                                   usr/share/vim/vim90/doc/quotes.txt                                                                  0000644 0000000 0000000 00000030714 14424703754 015563  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        *quotes.txt*    For Vim version 9.0.  Last change: 2018 Mar 29


		  VIM REFERENCE MANUAL    by Bram Moolenaar


							*quotes*
Here are some nice quotes about Vim that I collected from news and mail.


vim (vim) noun - Ebullient vitality and energy.  [Latin, accusative of vis,
strength]  (Dictionary)

Vim is so much better than vi that a great many of my old vi :map's became
immediately obsolete! (Tony Nugent, Australia)

Coming with a very GUI mindset from Windows, I always thought of people using
Vi as some kind of outer space alien in human clothes.  Once I tried I really
got addicted by its power and now I found myself typing Vim keypresses in the
oddest places! That's why I would like to see Vim embedded in every
application which deals with text editing.  (Jos√© Fonseca)

I was a 12-year emacs user who switched to Vim about a year ago after finally
giving up on the multiple incompatible versions, flaky contributed packages,
disorganized keystrokes, etc.  And it was one of the best moves I ever made.
(Joel Burton)

Although all of the programs were used during the preparation of the new and
revised material, most of the editing was done with Vim versions 4.5 and 5.0
under GNU-Linux (Redhat 4.2).  (Arnold Robbins, Israel, author of "Learning
the Vi editor")

Out of all the open software i've ever seen and used, and i've seen a lot, Vim
is the best, most useful and highest quality to work with, second only to the
linux kernel itself.  (Peter Jay Salzman)

It's well worth noting that the _entirety_ of SourceForge was written using
Vim and its nifty PHP syntax highlighting.  I think the entire SF.net tech
staff uses Vim and we're all excited to have you aboard! (Tim Perdue)

Vim is one of a select bunch of tools for which I have no substitute.  It is
a brilliant piece of work! (Biju Chacko)

A previous girlfriend of mine switched to emacs.  Needless to say, the
relationship went nowhere.  (Geoffrey Mann)

I rarely think about Vim, in the same way that I guess a fish rarely thinks
about water.  It's the environment in which everything else happens.  I'm a
fairly busy system administrator working on a lot of different platforms.  Vim
is the only thing that's consistent across all my systems, and it's just about
the only thing that doesn't break from time to time.  When a new system comes
in the door without Vim, I install it right away.  Great to have a tool that's
the same everywhere, that's completely reliable, so I can ignore it and think
about other things.  (Pete Schaeffer)

Having recently succeeded in running Vim via telnet through a Nokia
Communicator, I can now report that it works nicely on a Palm Pilot too.
(Allan Kelly, Scotland)

You've done a tremendous job with 'VIM', Bram!  The more I use it, the more
impressed I get (I am an old 'vi' die hard who once started out with early
versions of 'emacs' in the late 1970's and was relieved by finding 'vi' in the
first UNIX I came across in 1983).  In my opinion, it's about time 'VIM'
replace 'emacs' as the standard for top editors.  (Bo Thide', Sweden)

I love and use Vim heavily too.  (Larry Wall)

Vi is like a Ferrari, if you're a beginner, it handles like a bitch, but once
you get the hang of it, it's small, powerful and FAST! (Unknown)
Vim is like a new model Ferrari, and sounds like one too - "VIIIIIIMMM!"
(Stephen Riehm, Germany)

Schon bei Nutzung eines Bruchteils der Vim-Funktionen wird der Benutzer recht
schnell die Vorzuege dieses Editors kennen- und schaetzenlernen.
Translated: Even when only using a fraction of Vim-functions, the user will
quickly get used to and appreciate the advantages of this editor.  (Garry
Glendown, conclusion of an article on Vim in iX magazine 9/1998)

I've recently acquired the O'Reilly book on Vi (it also discusses Vim
in-depth), and I'm amazed at just how powerful this application is.  (Jeffrey
Rankin)

This guide was written using the Windows 9.x distribution of gvim, which is
quite possibly the greatest thing to come along since God created the naked
girl.  (Michael DiBernardo)

Boy, I thought I knew almost everything about Vim, but every time I browse the
online documentation, I hit upon a minor but cool aspect of a Vim feature that
I didn't know before!  I must say the documentation is one the finest I've
ever seen in a product -- even better than most commercial products.
(Gautam Mudunuri)

Vim 4.5 is really a fantastic editor.  It has sooooo many features and more
importantly, the defaults are so well thought out that you really don't have
to change anything!!  Words cannot express my amazement and gratitude to the
creators of Vim.  Keep it up.  (Vikas, USA)

I wonder how long it will be before people will refer to other Vi editors as
Vim clones?  (Darren Hiebert)

I read about [auto-positioning-in-file-based-on-the-errors-from-make] in one
of those "Perfect Programmer's Editor" threads and was delighted to discover
that Vim already supports it.  (Brendan Macmillan, Australia)

I just discovered Vim (5.0) and I'm telling everyone I know about it!
I tell them Vim stands for Vi for the new (M)illenium.  Thanks so much!
(Matt F. Valentine)

I think from now on "vi" should be called "Vim Imitation", not the other way
around.  (Rungun Ramanathan)

The Law of Vim:
For each member b of the possible behaviour space B of program P, there exists
a finite time t before which at least one user u in the total user space U of
program P will request b becomes a member of the allowed behaviour space B'
(B' <= B).
In other words: Sooner or later everyone wants everything as an option.
(Negri)

Whenever I move to a new computing platform, the first thing I do is to port
Vim.  Lately, I am simply stunned by its ease of compilation using the
configure facility.  (A.M. Sabuncu, Turkey)

The options are really excellent and very powerful.  (Anish Maharaj)

The Spring user-interface designs are in, and word from the boutiques is that
80x24 text-only mode is back with a *vengeance! Vi editor clone Vim burst onto
March desk-tops with a dazzling show of pastel syntax highlights for its 5.0
look.  Strident and customizable, Vim raises eyebrows with its interpretation
of the classic Vi single-key macro collection.
http://www.ntk.net/index.cgi?back=archive98/now0327.txt&line=179#l

I just wanted to take this opportunity to let you know that Vim 5 ROCKS!
Syntax highlighting: how did I survive without it?!  Thank you for creating
mankind's best editor!  (Mun Johl, USA)

Thanks again for Vim.  I use it every day on Linux.  (Eric Foster-Johnson,
author of the book "UNIX Programming Tools")

The BEST EDITOR EVER (Stuart Woolford)

I have used most of Vim's fancy features at least once, many frequently, and I
can honestly say that I couldn't live with anything less anymore.  My
productivity has easily doubled compared to what it was when I used vi.
(Sitaram Chamarty)

I luv Vim.  It is incredible.  I'm naming my first-born Vimberly.  (Jose
Unpingco, USA)

Hint:  "Vim" is "vi improved" - much better! (Sven Guckes, Germany)

I use Vim every day.  I spend more time in Vim than in any other program...
It's the best vi clone there is.  I think it's great.  (Craig Sanders,
Australia)

I strongly advise using Vim--its infinite undo/redo saved me much grief.
(Terry Brown)

Thanks very much for writing what in my opinion is the finest text editor on
the planet.  If I were to get another cat, I would name it "Vim".
(Bob Sheehan, USA)

I typed :set all and the screen FILLED up with options.  A whole screen of
things to be set and unset.  I saw some of my old friends like wrapmargin,
modelines and showmode, but the screen was FILLED with new friends!   I love
them all!   I love Vim!   I'm so happy that I've found this editor!  I feel
like how I once felt when I started using vi after a couple of years of using
ed.  I never thought I'd forsake my beloved ed, but vi ... oh god, vi was
great.  And now, Vim.  (Peter Jay Salzman, USA)

I am really happy with such a wonderful software package.  Much better than
almost any expensive, off the shelf program.  (Jeff Walker)

Whenever I reread the Vim documentation I'm overcome with excitement at the
power of the editor.  (William Edward Webber, Australia)

Hurrah for Vim!! It is "at your fingertips" like vi, and has the extensions
that vi sorely needs: highlighting for executing commands on blocks, an easily
navigable and digestible help screen, and more.  (Paul Pax)

The reason WHY I don't have this amazingly useful macro anymore, is that I
now use Vim - and this is built in!! (Stephen Riehm, Germany)

I am a user of Vim and I love it.  I use it to do all my programming, C,
C++, HTML what ever.  (Tim Allwine)

I discovered Vim after years of struggling with the original vi, and I just
can't live without it anymore.  (Emmanuel Mogenet, USA)

Emacs has not a bit of chance to survive so long as Vim is around.  Besides,
it also has the most detailed software documentation I have ever seen---much
better than most commercial software!  (Leiming Qian)

This version of Vim will just blow people apart when they discover just how
fantastic it is! (Tony Nugent, Australia)

I took your advice & finally got Vim & I'm really impressed.  Instant convert.
(Patrick Killelea, USA)

Vim is by far my favorite piece of shareware and I have been particularly
pleased with version 3.0.  This is really a solid piece of work.  (Robert
Colon, USA)

Vim is a joy to use, it is so well thought and practical that I wonder why
anybody would use visual development tools.  Vim is powerful and elegant, it
looks deceptively simple but is almost as complex as a 747 (especially when I
look at my growing .vimrc), keep up that wonderful job, Vim is a centerpiece
of the free software world.  (Louis-David Mitterand, USA)

I cannot believe how great it is to use Vim.  I think the guys at work are
getting tired of hearing me bragging about it.  Others eyes are lighting up.
(Rick Croote)

Emacs takes way too much time to start up and run, it is too big and bulky for
effective use and the interface is more confusing than it is of any help.  Vim
however is short, it is fast, it is powerful, it has a good interface and it
is all purpose.  (Paal Ditlefsen Ekran)

From the first time I got Vim3.0, I was very enthusiastic.  It has almost no
problems.  The swapfile handling and the backup possibilities are robust, also
the protection against editing one file twice.  It is very compatible to the
real VI (and that is a MUST, because my brain is trained over years in using
it).  (Gert van Antwerpen, Holland)

Visual mode in Vim is a very powerful thing! (Tony Nugent, Australia)

I have to say that Vim is =THE= single greatest piece of source code to ever
come across the net (Jim Battle, USA).

In fact, if you do want to get a new vi I'd suggest Vim-3.0.  This is, by
far, the best version of vi I've ever seen (Albert W. Schueller).

I should mention that Vim is a very good editor and can compete with anything
(Ilya Beloozerov).

To tell the truth sometimes I used elvis, vile, xvi, calvin, etc.  And this is
the reason that I can state that Vim is the best! (Ferenc Deak, Hungary)

Vim is by far the best editor that I have used in a long time, and I have
looked at just about every thing that is available for every platform that I
use.  Vim is the best on all of them.  (Guy L. Oliver)

Vim is the greatest editor since the stone chisel.  (Jose Unpingco, USA)

I would like to say that with Vim I am finally making the 'emacs to vi'
transition - as an Editor it is so much better in many ways: keyboard layout,
memory usage, text alteration to name 3.  (Mark Adam)

In fact, now if I want to know what a particular setting does in vi, I fire up
Vim and check out its help!  (Nikhil Patel, USA)

As a vi user, Vim has made working with text a far more pleasant task than
before I encountered this program.  (Steinar Knutsen, Norway)

I use Vim since version 3.0.  Since that time, it is the ONLY editor I use,
with Solaris, Linux and OS/2 Warp.  I suggest all my friends to use Vim, they
try, and they continue using it.  Vim is really the best software I have ever
downloaded from the Internet, and the best editor I know of.  (Marco
Eccettuato, Italy)


In summary:
     __     ___		    _	    _	_  ___ _____ `
     \ \   / (_)_ __ ___   (_)___  | | | |/ _ \_   _| `
      \ \ / /| | '_ ` _ \  | / __| | |_| | | | || | `
       \ V / | | | | | | | | \__ \ |  _  | |_| || | `
	\_/  |_|_| |_| |_| |_|___/ |_| |_|\___/ |_| `
	     ____ _____ _   _ _____ _____ _ _ `
	    / ___|_   _| | | |	___|  ___| | | `
	    \___ \ | | | | | | |_  | |_  | | | `
	     ___) || | | |_| |	_| |  _| |_|_| `
	    |____/ |_|	\___/|_|   |_|	 (_|_)	    (Tony Nugent, Australia) `


 vim:tw=78:ts=8:noet:ft=help:norl:
                                                    usr/share/vim/vim90/doc/recover.txt                                                                 0000644 0000000 0000000 00000024740 14424703754 015712  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        *recover.txt*   For Vim version 9.0.  Last change: 2020 Aug 15


		  VIM REFERENCE MANUAL    by Bram Moolenaar


Recovery after a crash					*crash-recovery*

You have spent several hours typing in that text that has to be finished
next morning, and then disaster strikes: Your computer crashes.

			DON'T PANIC!

You can recover most of your changes from the files that Vim uses to store
the contents of the file.  Mostly you can recover your work with one command:
	vim -r filename

1. The swap file	|swap-file|
2. Recovery		|recovery|

==============================================================================
1. The swap file					*swap-file*

Vim stores the things you changed in a swap file.  Using the original file
you started from plus the swap file you can mostly recover your work.

You can see the name of the current swap file being used with the command:

	:sw[apname]					*:sw* *:swapname*

Or you can use the |swapname()| function, which also allows for seeing the
swap file name of other buffers.

The name of the swap file is normally the same as the file you are editing,
with the extension ".swp".
- On Unix, a '.' is prepended to swap file names in the same directory as the
  edited file.  This avoids that the swap file shows up in a directory
  listing.
- On MS-Windows machines and when the 'shortname' option is on, any '.' in the
  original file name is replaced with '_'.
- If this file already exists (e.g., when you are recovering from a crash) a
  warning is given and another extension is used, ".swo", ".swn", etc.
- An existing file will never be overwritten.
- The swap file is deleted as soon as Vim stops editing the file.

Technical: The replacement of '.' with '_' is done to avoid problems with
	   MS-DOS compatible filesystems (e.g., crossdos, multidos).  If Vim
	   is able to detect that the file is on an MS-DOS-like filesystem, a
	   flag is set that has the same effect as the 'shortname' option.
	   This flag is reset when you start editing another file.
							*E326*
	   If the ".swp" file name already exists, the last character is
	   decremented until there is no file with that name or ".saa" is
	   reached.  In the last case, no swap file is created.

By setting the 'directory' option you can place the swap file in another place
than where the edited file is.
Advantages:
- You will not pollute the directories with ".swp" files.
- When the 'directory' is on another partition, reduce the risk of damaging
  the file system where the file is (in a crash).
Disadvantages:
- You can get name collisions from files with the same name but in different
  directories (although Vim tries to avoid that by comparing the path name).
  This will result in bogus ATTENTION warning messages.
- When you use your home directory, and somebody else tries to edit the same
  file, that user will not see your swap file and will not get the ATTENTION
  warning message.
On the Amiga you can also use a recoverable ram disk, but there is no 100%
guarantee that this works.  Putting swap files in a normal ram disk (like RAM:
on the Amiga) or in a place that is cleared when rebooting (like /tmp on Unix)
makes no sense, you will lose the swap file in a crash.

If you want to put swap files in a fixed place, put a command resembling the
following ones in your .vimrc:
	:set dir=dh2:tmp	(for Amiga)
	:set dir=~/tmp		(for Unix)
	:set dir=c:\\tmp	(for Win32)
This is also very handy when editing files on floppy.  Of course you will have
to create that "tmp" directory for this to work!

For read-only files, a swap file is not used.  Unless the file is big, causing
the amount of memory used to be higher than given with 'maxmem' or
'maxmemtot'.  And when making a change to a read-only file, the swap file is
created anyway.

The 'swapfile' option can be reset to avoid creating a swapfile.  And the
|:noswapfile| modifier can be used to not create a swapfile for a new buffer.

:nos[wapfile]   {command}			*:nos* *:noswapfile*
		Execute {command}. If it contains a command that loads a new
		buffer, it will be loaded without creating a swapfile and the
		'swapfile' option will be reset.  If a buffer already had a
		swapfile it is not removed and 'swapfile' is not reset.


Detecting an existing swap file ~

You can find this in the user manual, section |11.3|.


Updating the swapfile ~

The swap file is updated after typing 200 characters or when you have not
typed anything for four seconds.  This only happens if the buffer was
changed, not when you only moved around.  The reason why it is not kept up to
date all the time is that this would slow down normal work too much.  You can
change the 200 character count with the 'updatecount' option.  You can set
the time with the 'updatetime' option.  The time is given in milliseconds.
After writing to the swap file Vim syncs the file to disk.  This takes some
time, especially on busy Unix systems.  If you don't want this you can set the
'swapsync' option to an empty string.  The risk of losing work becomes bigger
though.  On some non-Unix systems (MS-Windows, Amiga) the swap file won't be
written at all.

If the writing to the swap file is not wanted, it can be switched off by
setting the 'updatecount' option to 0.  The same is done when starting Vim
with the "-n" option.  Writing can be switched back on by setting the
'updatecount' option to non-zero.  Swap files will be created for all buffers
when doing this.  But when setting 'updatecount' to zero, the existing swap
files will not be removed, it will only affect files that will be opened
after this.

If you want to make sure that your changes are in the swap file use this
command:

					*:pre* *:preserve* *E313* *E314*
:pre[serve]		Write all text for the current buffer into its swap
			file.  The original file is no longer needed for
			recovery.  This sets a flag in the current buffer.
			When the '&' flag is present in 'cpoptions' the swap
			file will not be deleted for this buffer when Vim
			exits and the buffer is still loaded |cpo-&|.

A Vim swap file can be recognized by the first six characters: "b0VIM ".
After that comes the version number, e.g., "3.0".


Links and symbolic links ~

On Unix it is possible to have two names for the same file.  This can be done
with hard links and with symbolic links (symlinks).

For hard links Vim does not know the other name of the file.  Therefore, the
name of the swapfile will be based on the name you used to edit the file.
There is no check for editing the same file by the other name too, because Vim
cannot find the other swapfile (except for searching all of your harddisk,
which would be very slow).

For symbolic links Vim resolves the links to find the name of the actual file.
The swap file name is based on that name.  Thus it doesn't matter by what name
you edit the file, the swap file name will normally be the same.  However,
there are exceptions:
- When the directory of the actual file is not writable the swapfile is put
  elsewhere.
- When the symbolic links somehow create a loop you get an *E773* error
  message and the unmodified file name will be used.  You won't be able to
  save your file normally.

==============================================================================
2. Recovery					*recovery* *E308* *E311*

Basic file recovery is explained in the user manual: |usr_11.txt|.

Another way to do recovery is to start Vim and use the ":recover" command.
This is easy when you start Vim to edit a file and you get the "ATTENTION:
Found a swap file ..." message.  In this case the single command ":recover"
will do the work.  You can also give the name of the file or the swap file to
the recover command:
					*:rec* *:recover* *E305* *E306* *E307*
:rec[over] [file]	Try to recover [file] from the swap file.  If [file]
			is not given use the file name for the current
			buffer.  The current contents of the buffer are lost.
			This command fails if the buffer was modified.

:rec[over]! [file]	Like ":recover", but any changes in the current
			buffer are lost.

							*E312* *E309* *E310*
Vim has some intelligence about what to do if the swap file is corrupt in
some way.  If Vim has doubt about what it found, it will give an error
message and insert lines with "???" in the text.  If you see an error message
while recovering, search in the file for "???" to see what is wrong.  You may
want to cut and paste to get the text you need.

The most common remark is "???LINES MISSING".  This means that Vim cannot read
the text from the original file.  This can happen if the system crashed and
parts of the original file were not written to disk.

Be sure that the recovery was successful before overwriting the original
file or deleting the swap file.  It is good practice to write the recovered
file elsewhere and run 'diff' to find out if the changes you want are in the
recovered file.  Or use |:DiffOrig|.

