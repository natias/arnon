
    /*
     * Optional with default: Retrieve a master keyblock from the stash file
     * db_args, filling in *key and *kvno.  mname is the name of the master
     * principal for the realm.
     *
     * The default implementation reads the master keyblock from a keytab or
     * old-format stash file.
     */
    krb5_error_code (*fetch_master_key)(krb5_context kcontext,
                                        krb5_principal mname,
                                        krb5_keyblock *key, krb5_kvno *kvno,
                                        char *db_args);

    /*
     * Optional with default: Given a keyblock for some version of the
     * database's master key, fetch the decrypted master key values from the
     * database and store the list into *mkeys_list.  The caller will free
     * *mkeys_list using a libkdb5 function which uses the standard free()
     * function, so the module must not use a custom allocator.
     *
     * The caller may not know the version number of the master key it has, in
     * which case it will pass IGNORE_VNO.
     *
     * The default implementation ignores kvno and tries the key against the
     * current master key data and all KRB5_TL_MKEY_AUX values, which contain
     * copies of the master keys encrypted with old master keys.
     */
    krb5_error_code (*fetch_master_key_list)(krb5_context kcontext,
                                             krb5_principal mname,
                                             const krb5_keyblock *key,
                                             krb5_keylist_node **mkeys_list);

    /*
     * Optional with default: Save a list of master keyblocks, obtained from
     * fetch_master_key_list, into the stash file db_arg.  The caller will set
     * master_pwd to NULL, so the module should just ignore it.  mname is the
     * name of the master principal for the realm.
     *
     * The default implementation saves the list of master keys in a
     * keytab-format file.
     */
    krb5_error_code (*store_master_key_list)(krb5_context kcontext,
                                             char *db_arg,
                                             krb5_principal mname,
                                             krb5_keylist_node *keylist,
                                             char *master_pwd);

    /*
     * Optional with default: Starting at position *start, scan the key data of
     * a database entry for a key matching the enctype ktype, the salt type
     * stype, and the version kvno.  Store the resulting key into *kdatap and
     * set *start to the position after the key found.  If ktype is negative,
     * match any enctype.  If stype is negative, match any salt type.  If kvno
     * is zero or negative, find the most recent key version satisfying the
     * other constraints.
     */
    krb5_error_code (*dbe_search_enctype)(krb5_context kcontext,
                                          krb5_db_entry *dbentp,
                                          krb5_int32 *start, krb5_int32 ktype,
                                          krb5_int32 stype, krb5_int32 kvno,
                                          krb5_key_data **kdatap);


    /*
     * Optional with default: Change the key data for db_entry to include keys
     * derived from the password passwd in each of the specified key-salt
     * types, at version new_kvno.  Discard the old key data if keepold is not
     * set.
     *
     * The default implementation uses the keyblock master_key to encrypt each
     * new key, via the function encrypt_key_data.
     */
    krb5_error_code (*change_pwd)(krb5_context context,
                                  krb5_keyblock *master_key,
                                  krb5_key_salt_tuple *ks_tuple,
                                  int ks_tuple_count, char *passwd,
                                  int new_kvno, krb5_boolean keepold,
                                  krb5_db_entry *db_entry);

    /*
     * Optional: Promote a temporary database to be the live one.  context must
     * be initialized with an exclusively locked database created with the
     * "temporary" db_arg.  On success, the database object contained in
     * context will be finalized.
     *
     * This method is used by kdb5_util load to replace the live database with
     * minimal loss of read availability.
     */
    krb5_error_code (*promote_db)(krb5_context context, char *conf_section,
                                  char **db_args);

    /*
     * Optional with default: Decrypt the key in key_data with master keyblock
     * mkey, placing the result into dbkey.  Copy the salt from key_data, if
     * any, into keysalt.  Either dbkey or keysalt may be left unmodified on
     * successful return if key_data does not contain key or salt information.
     *
     * The default implementation expects the encrypted key (in krb5_c_encrypt
     * format) to be stored in key_data_contents[0], with length given by
     * key_data_length[0].  If key_data_ver is 2, it expects the salt to be
     * stored, unencrypted, in key_data_contents[1], with length given by
     * key_data_length[1].
     */
    krb5_error_code (*decrypt_key_data)(krb5_context kcontext,
                                        const krb5_keyblock *mkey,
                                        const krb5_key_data *key_data,
                                        krb5_keyblock *dbkey,
                                        krb5_keysalt *keysalt);

    /*
     * Optional with default: Encrypt dbkey with master keyblock mkey, placing
     * the result into key_data along with keysalt.
     *
     * The default implementation stores the encrypted key (in krb5_c_encrypt
     * format) in key_data_contents[0] and the length in key_data_length[0].
     * If keysalt is specified, it sets key_data_ver to 2, and stores the salt
     * in key_data_contents[1] and its length in key_data_length[1].  If
     * keysalt is not specified, key_data_ver is set to 1.
     */
    krb5_error_code (*encrypt_key_data)(krb5_context kcontext,
                                        const krb5_keyblock *mkey,
                                        const krb5_keyblock *dbkey,
                                        const krb5_keysalt *keysalt,
                                        int keyver, krb5_key_data *key_data);

    /*
     * Optional: Perform a policy check on a cross-realm ticket's transited
     * field.  Return 0 if the check authoritatively succeeds,
     * KRB5_PLUGIN_NO_HANDLE to use the core transited-checking mechanisms, or
     * another error (other than KRB5_PLUGIN_OP_NOTSUPP) if the check fails.
     */
    krb5_error_code (*check_transited_realms)(krb5_context kcontext,
                                              const krb5_data *tr_contents,
                                              const krb5_data *client_realm,
                                              const krb5_data *server_realm);

    /*
     * Optional: Perform a policy check on an AS request, in addition to the
     * standard policy checks.  Return 0 if the AS request is allowed.  If the
     * AS request is not allowed:
     *   - Place a short string literal into *status.
     *   - If desired, place data into e_data.  Any data placed here will be
     *     freed by the caller using the standard free function.
     *   - Return an appropriate error (such as KRB5KDC_ERR_POLICY).
     */
    krb5_error_code (*check_policy_as)(krb5_context kcontext,
                                       krb5_kdc_req *request,
                                       krb5_db_entry *client,
                                       krb5_db_entry *server,
                                       krb5_timestamp kdc_time,
                                       const char **status,
                                       krb5_pa_data ***e_data);

    /*
     * Optional: Perform a policy check on a TGS request, in addition to the
     * standard policy checks.  Return 0 if the TGS request is allowed.  If the
     * TGS request is not allowed:
     *   - Place a short string literal into *status.
     *   - If desired, place data into e_data.  Any data placed here will be
     *     freed by the caller using the standard free function.
     *   - Return an appropriate error (such as KRB5KDC_ERR_POLICY).
     * The input parameter ticket contains the TGT used in the TGS request.
     */
    krb5_error_code (*check_policy_tgs)(krb5_context kcontext,
                                        krb5_kdc_req *request,
                                        krb5_db_entry *server,
                                        krb5_ticket *ticket,
                                        const char **status,
                                        krb5_pa_data ***e_data);

    /*
     * Optional: This method informs the module of a successful or unsuccessful
     * AS request.
     */
    void (*audit_as_req)(krb5_context kcontext, krb5_kdc_req *request,
                         const krb5_address *local_addr,
                         const krb5_address *remote_addr,
                         krb5_db_entry *client, krb5_db_entry *server,
                         krb5_timestamp authtime, krb5_error_code error_code);

    /* Note: there is currently no method for auditing TGS requests. */

    /*
     * Optional: This method informs the module of a request to reload
     * configuration or other state (that is, the KDC received a SIGHUP).
     */
    void (*refresh_config)(krb5_context kcontext);

    /*
     * Optional: Perform a policy check on server being allowed to obtain
     * tickets from client to proxy.  If proxy is NULL, check if server has any
     * authorized delegation targets (client will also be NULL in this case).
     * (Note that proxy is the target of the delegation, not the delegating
     * service; the term "proxy" is from the viewpoint of the delegating
     * service asking another service to perform some of its work in the
     * authentication context of the client.  This terminology comes from the
     * Microsoft S4U protocol documentation.)  Return 0 if policy allows
     * delegation to the specified target (or to any target if proxy is NULL),
     * or KRB5KDC_ERR_BADOPTION if not.  If this method is not implemented, all
     * S4U2Proxy delegation requests will be rejected.
     */
    krb5_error_code (*check_allowed_to_delegate)(krb5_context context,
                                                 krb5_const_principal client,
                                                 const krb5_db_entry *server,
                                                 krb5_const_principal proxy);

    /*
     * Optional: Free the e_data pointer of a database entry.  If this method
     * is not implemented, the e_data pointer in principal entries will be
     * freed with free() as seen by libkdb5.
     */
    void (*free_principal_e_data)(krb5_context kcontext, krb5_octet *e_data);

    /*
     * Optional: get a client principal entry based on an X.509 certificate.
     *
     * If flags include KRB5_KDB_FLAG_REFERRAL_OK, the certificate was
     * presented in an AS request.  princ->realm indicates the request realm,
     * but the data components should be ignored.  The module can return an
     * out-of-realm client referral as it would for get_principal().
     *
     * Otherwise, princ is from a TGS request.  If it contains data components
     * (and not just a realm), the module should verify that it is the same as
     * the lookup result for client_cert.  The module should not return a
     * referral.
     */
    krb5_error_code (*get_s4u_x509_principal)(krb5_context kcontext,
                                              const krb5_data *client_cert,
                                              krb5_const_principal princ,
                                              unsigned int flags,
                                              krb5_db_entry **entry_out);

    /*
     * Optional: Perform a policy check on server being allowed to obtain
     * tickets from client to proxy.  This method is similar to
     * check_allowed_to_delegate, but it operates on the target server DB entry
     * (called "proxy" here as in Microsoft's protocol documentation) rather
     * than the intermediate server entry.  server_pac is the verified PAC from
     * the authdata of the intermediate server.  Return 0 if policy allows the
     * delegation, or KRB5KDC_ERR_BADOPTION if not.
     *
     * This method is called for S4U2Proxy requests and implements the
     * resource-based constrained delegation variant, which can support
     * cross-realm delegation.  If this method is not implemented or if it
     * returns a policy error, the KDC will fall back to
     * check_allowed_to_delegate if the intermediate and target servers are in
     * the same realm and the evidence ticket is forwardable.
     */
    krb5_error_code (*allowed_to_delegate_from)(krb5_context context,
                                                krb5_const_principal client,
                                                krb5_const_principal server,
                                                krb5_pac server_pac,
                                                const krb5_db_entry *proxy);

    /*
     * Optional: Add buffers to new_pac using krb5_pac_add_buffer() before it
     * is signed.
     *
     * The caller will handle the following buffer types, so do not copy or add
     * them:
     *
     *   KRB5_PAC_SERVER_CHECKSUM
     *   KRB5_PAC_PRIVSVR_CHECKSUM
     *   KRB5_PAC_TICKET_CHECKSUM
     *   KRB5_PAC_CLIENT_INFO
     *   KRB5_PAC_DELEGATION_INFO
     *
     * For TGS requests, old_pac is the PAC of the header ticket, except when
     * KRB5_KDB_FLAG_CONTRAINED_DELEGATION is present in flags, in which case
     * it is the PAC of the second ticket.  If
     * KRB5_KDB_FLAG_PROTOCOL_TRANSITION is present in flags and client is not
     * NULL, old_pac is the PAC of the requesting service, not the subject of
     * the S4U2Self request, and its buffers should not be copied into new_pac.
     * The signatures and PAC_CLIENT_INFO of old_pac have been verified by the
     * caller.
     *
     * If replaced_reply_key is not null, the request is an AS request and the
     * reply key was replaced by a preauth mechanism such as PKINIT, meaning
     * the Kerberos password or long-term key was not used.  The module may use
     * this key to encrypt a PAC_CREDENTIALS_INFO buffer containing credentials
     * (such as an NTLM hash) that the client would ordinarily derive from the
     * Kerberos password or long-term key.
     *
     * server is the database entry of the server the ticket will be issued to,
     * which may be a referral TGS.
     *
     * signing_krbtgt is the database entry of the krbtgt principal used to
     * verify old_pac (or null if old_pac is null).  If
     * KRB5_KDB_FLAG_CROSS_REALM is present in flags, this entry will be an
     * incoming cross-realm TGS, and the PAC fields should undergo appropriate
     * filtering based on the trust level of the cross-realm relationship.
     *
     * auth_indicators points to NULL or a null-terminated list of krb5_data
     * pointers, each containing an authentication indicator (RFC 8129).  The
     * method may modify this list, or free it and replace *auth_indicators
     * with NULL, to change which auth indicators will be included in the
     * ticket.
     */
    krb5_error_code (*issue_pac)(krb5_context context, unsigned int flags,
                                 krb5_db_entry *client,
                                 krb5_keyblock *replaced_reply_key,
                                 krb5_db_entry *server,
                                 krb5_db_entry *signing_krbtgt,
                                 krb5_timestamp authtime, krb5_pac old_pac,
                                 krb5_pac new_pac,
                                 krb5_data ***auth_indicators);

    /* End of minor version 0 for major version 9. */
} kdb_vftabl;

#endif /* !defined(_WIN32) */

#endif /* KRB5_KDB5__ */
                                                                                                                                                                                                                                                                                                                                                     usr/include/mit-krb5/krb5/                                                                          0000755 0000000 0000000 00000000000 14714557572 014016  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/include/mit-krb5/krb5/ccselect_plugin.h                                                         0000644 0000000 0000000 00000010165 14640563767 017336  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
 * Copyright (C) 2011 by the Massachusetts Institute of Technology.
 * All rights reserved.
 *
 * Export of this software from the United States of America may
 *   require a specific license from the United States Government.
 *   It is the responsibility of any person or organization contemplating
 *   export to obtain such a license before exporting.
 *
 * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and
 * distribute this software and its documentation for any purpose and
 * without fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation, and that
 * the name of M.I.T. not be used in advertising or publicity pertaining
 * to distribution of the software without specific, written prior
 * permission.  Furthermore if you modify this software you must label
 * your software as modified software and not distribute it in such a
 * fashion that it might be confused with the original M.I.T. software.
 * M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is" without express
 * or implied warranty.
 */

/*
 * Declarations for credential cache selection module implementors.
 *
 * The ccselect pluggable interface currently has only one supported major
 * version, which is 1.  Major version 1 has a current minor version number of
 * 1.
 *
 * Credential cache selection modules should define a function named
 * ccselect_<modulename>_initvt, matching the signature:
 *
 *   krb5_error_code
 *   ccselect_modname_initvt(krb5_context context, int maj_ver, int min_ver,
 *                           krb5_plugin_vtable vtable);
 *
 * The initvt function should:
 *
 * - Check that the supplied maj_ver number is supported by the module, or
 *   return KRB5_PLUGIN_VER_NOTSUPP if it is not.
 *
 * - Cast the vtable pointer as appropriate for maj_ver:
 *     maj_ver == 1: Cast to krb5_ccselect_vtable
 *
 * - Initialize the methods of the vtable, stopping as appropriate for the
 *   supplied min_ver.  Optional methods may be left uninitialized.
 *
 * Memory for the vtable is allocated by the caller, not by the module.
 */

#ifndef KRB5_CCSELECT_PLUGIN_H
#define KRB5_CCSELECT_PLUGIN_H

#include <krb5/krb5.h>
#include <krb5/plugin.h>

/* An abstract type for credential cache selection module data. */
typedef struct krb5_ccselect_moddata_st *krb5_ccselect_moddata;

#define KRB5_CCSELECT_PRIORITY_AUTHORITATIVE 2
#define KRB5_CCSELECT_PRIORITY_HEURISTIC     1

/*** Method type declarations ***/

/*
 * Mandatory: Initialize module data and set *priority_out to one of the
 * KRB5_CCSELECT_PRIORITY constants above.  Authoritative modules will be
 * consulted before heuristic ones.
 */
typedef krb5_error_code
(*krb5_ccselect_init_fn)(krb5_context context, krb5_ccselect_moddata *data_out,
                         int *priority_out);

/*
 * Mandatory: Select a cache based on a server principal.  Return 0 on success,
 * with *cache_out set to the selected cache and *princ_out set to its default
 * principal.  Return KRB5_PLUGIN_NO_HANDLE to defer to other modules.  Return
 * KRB5_CC_NOTFOUND with *princ_out set if the client principal can be
 * authoritatively determined but no cache exists for it.  Return other errors
 * as appropriate.
 */
typedef krb5_error_code
(*krb5_ccselect_choose_fn)(krb5_context context, krb5_ccselect_moddata data,
                           krb5_principal server, krb5_ccache *cache_out,
                           krb5_principal *princ_out);

/* Optional: Release resources used by module data. */
typedef void
(*krb5_ccselect_fini_fn)(krb5_context context, krb5_ccselect_moddata data);

/*** vtable declarations **/

/* Credential cache selection plugin vtable for major version 1. */
typedef struct krb5_ccselect_vtable_st {
    const char *name;           /* Mandatory: name of module. */
    krb5_ccselect_init_fn init;
    krb5_ccselect_choose_fn choose;
    krb5_ccselect_fini_fn fini;
    /* Minor version 1 ends here. */
} *krb5_ccselect_vtable;

#endif /* KRB5_CCSELECT_PLUGIN_H */
                                                                                                                                                                                                                                                                                                                                                                                                           usr/include/mit-krb5/krb5/certauth_plugin.h                                                         0000644 0000000 0000000 00000012604 14640563767 017370  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/* include/krb5/certauth_plugin.h - certauth plugin header. */
/*
 * Copyright (C) 2017 by Red Hat, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in
 *   the documentation and/or other materials provided with the
 *   distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Declarations for certauth plugin module implementors.
 *
 * The certauth pluggable interface currently has only one supported major
 * version, which is 1.  Major version 1 has a current minor version number of
 * 1.
 *
 * certauth plugin modules should define a function named
 * certauth_<modulename>_initvt, matching the signature:
 *
 *   krb5_error_code
 *   certauth_modname_initvt(krb5_context context, int maj_ver, int min_ver,
 *                           krb5_plugin_vtable vtable);
 *
 * The initvt function should:
 *
 * - Check that the supplied maj_ver number is supported by the module, or
 *   return KRB5_PLUGIN_VER_NOTSUPP if it is not.
 *
 * - Cast the vtable pointer as appropriate for maj_ver:
 *     maj_ver == 1: Cast to krb5_certauth_vtable
 *
 * - Initialize the methods of the vtable, stopping as appropriate for the
 *   supplied min_ver.  Optional methods may be left uninitialized.
 *
 * Memory for the vtable is allocated by the caller, not by the module.
 */

#ifndef KRB5_CERTAUTH_PLUGIN_H
#define KRB5_CERTAUTH_PLUGIN_H

#include <krb5/krb5.h>
#include <krb5/plugin.h>

/* Abstract module data type. */
typedef struct krb5_certauth_moddata_st *krb5_certauth_moddata;

/* A module can optionally include <kdb.h> to inspect the client principal
 * entry when authorizing a request. */
struct _krb5_db_entry_new;

/*
 * Optional: Initialize module data.
 */
typedef krb5_error_code
(*krb5_certauth_init_fn)(krb5_context context,
                         krb5_certauth_moddata *moddata_out);

/*
 * Optional: Clean up the module data.
 */
typedef void
(*krb5_certauth_fini_fn)(krb5_context context, krb5_certauth_moddata moddata);

/*
 * Mandatory: decode cert as an X.509 certificate and determine whether it is
 * authorized to authenticate as the requested client principal princ using
 * PKINIT.  Return 0 or KRB5_CERTAUTH_HWAUTH if the certificate is authorized.
 * Otherwise return one of the following error codes:
 *
 * - KRB5KDC_ERR_CLIENT_NAME_MISMATCH - incorrect SAN value
 * - KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE - incorrect EKU
 * - KRB5KDC_ERR_CERTIFICATE_MISMATCH - other extension error
 * - KRB5_PLUGIN_NO_HANDLE or KRB5_CERTAUTH_HWAUTH_PASS - the module has no
 *   opinion about whether cert is authorized
 *
 * Returning KRB5_CERTAUTH_HWAUTH will authorize the PKINIT authentication and
 * cause the hw-authent flag to be set in the issued ticket (new in release
 * 1.19).  Returning KRB5_CERTAUTH_HWAUTH_PASS does not authorize the PKINIT
 * authentication, but causes the hw-authent flag to be set if another module
 * authorizes it (new in release 1.20)
 *
 * - opts is used by built-in modules to receive internal data, and must be
 *   ignored by other modules.
 * - db_entry receives the client principal database entry, and can be ignored
 *   by modules that do not link with libkdb5.
 * - *authinds_out optionally returns a null-terminated list of authentication
 *   indicator strings upon KRB5_PLUGIN_NO_HANDLE or accepted authorization.
 */
typedef krb5_error_code
(*krb5_certauth_authorize_fn)(krb5_context context,
                              krb5_certauth_moddata moddata,
                              const uint8_t *cert, size_t cert_len,
                              krb5_const_principal princ, const void *opts,
                              const struct _krb5_db_entry_new *db_entry,
                              char ***authinds_out);

/*
 * Free indicators allocated by a module.  Mandatory if authorize returns
 * authentication indicators.
 */
typedef void
(*krb5_certauth_free_indicator_fn)(krb5_context context,
                                   krb5_certauth_moddata moddata,
                                   char **authinds);

typedef struct krb5_certauth_vtable_st {
    const char *name;
    krb5_certauth_init_fn init;
    krb5_certauth_fini_fn fini;
    krb5_certauth_authorize_fn authorize;
    krb5_certauth_free_indicator_fn free_ind;
} *krb5_certauth_vtable;

#endif /* KRB5_CERTAUTH_PLUGIN_H */
                                                                                                                            usr/include/mit-krb5/krb5/clpreauth_plugin.h                                                        0000644 0000000 0000000 00000036251 14640563767 017544  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
 * Copyright (c) 2006 Red Hat, Inc.
 * Portions copyright (c) 2006, 2011 Massachusetts Institute of Technology
 * All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *  * Neither the name of Red Hat, Inc., nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Declarations for clpreauth plugin module implementors.
 *
 * The clpreauth interface has a single supported major version, which is
 * 1.  Major version 1 has a current minor version of 2.  clpreauth modules
 * should define a function named clpreauth_<modulename>_initvt, matching
 * the signature:
 *
 *   krb5_error_code
 *   clpreauth_modname_initvt(krb5_context context, int maj_ver,
 *                            int min_ver, krb5_plugin_vtable vtable);
 * The initvt function should:
 *
 * - Check that the supplied maj_ver number is supported by the module, or
 *   return KRB5_PLUGIN_VER_NOTSUPP if it is not.
 *
 * - Cast the vtable pointer as appropriate for the interface and maj_ver:
 *     maj_ver == 1: Cast to krb5_clpreauth_vtable
 *
 * - Initialize the methods of the vtable, stopping as appropriate for the
 *   supplied min_ver.  Optional methods may be left uninitialized.
 *
 * Memory for the vtable is allocated by the caller, not by the module.
 */

#ifndef KRB5_CLPREAUTH_PLUGIN_H
#define KRB5_CLPREAUTH_PLUGIN_H

#include <krb5/krb5.h>
#include <krb5/plugin.h>

/* clpreauth mechanism property flags */

/* Provides a real answer which we can send back to the KDC.  The client
 * assumes that one real answer will be enough. */
#define PA_REAL         0x00000001

/* Doesn't provide a real answer, but must be given a chance to run before any
 * REAL mechanism callbacks. */
#define PA_INFO         0x00000002

/* Abstract type for a client request information handle. */
typedef struct krb5_clpreauth_rock_st *krb5_clpreauth_rock;

/* Abstract types for module data and per-request module data. */
typedef struct krb5_clpreauth_moddata_st *krb5_clpreauth_moddata;
typedef struct krb5_clpreauth_modreq_st *krb5_clpreauth_modreq;

/* Before using a callback after version 1, modules must check the vers
 * field of the callback structure. */
typedef struct krb5_clpreauth_callbacks_st {
    int vers;

    /*
     * If an AS-REP has been received, return the enctype of the AS-REP
     * encrypted part.  Otherwise return the enctype chosen from etype-info, or
     * the first requested enctype if no etype-info was received.
     */
    krb5_enctype (*get_etype)(krb5_context context, krb5_clpreauth_rock rock);

    /* Get a pointer to the FAST armor key, or NULL if the client is not using
     * FAST.  The returned pointer is an alias and should not be freed. */
    krb5_keyblock *(*fast_armor)(krb5_context context,
                                 krb5_clpreauth_rock rock);

    /*
     * Get a pointer to the client-supplied reply key, possibly invoking the
     * prompter to ask for a password if this has not already been done.  The
     * returned pointer is an alias and should not be freed.
     */
    krb5_error_code (*get_as_key)(krb5_context context,
                                  krb5_clpreauth_rock rock,
                                  krb5_keyblock **keyblock);

    /* Replace the reply key to be used to decrypt the AS response. */
    krb5_error_code (*set_as_key)(krb5_context context,
                                  krb5_clpreauth_rock rock,
                                  const krb5_keyblock *keyblock);

    /* End of version 1 clpreauth callbacks. */

    /*
     * Get the current time for use in a preauth response.  If
     * allow_unauth_time is true and the library has been configured to allow
     * it, the current time will be offset using unauthenticated timestamp
     * information received from the KDC in the preauth-required error, if one
     * has been received.  Otherwise, the timestamp in a preauth-required error
     * will only be used if it is protected by a FAST channel.  Only set
     * allow_unauth_time if using an unauthenticated time offset would not
     * create a security issue.
     */
    krb5_error_code (*get_preauth_time)(krb5_context context,
                                        krb5_clpreauth_rock rock,
                                        krb5_boolean allow_unauth_time,
                                        krb5_timestamp *time_out,
                                        krb5_int32 *usec_out);

    /* Set a question to be answered by the responder and optionally provide
     * a challenge. */
    krb5_error_code (*ask_responder_question)(krb5_context context,
                                              krb5_clpreauth_rock rock,
                                              const char *question,
                                              const char *challenge);

    /* Get an answer from the responder, or NULL if the question was
     * unanswered. */
    const char *(*get_responder_answer)(krb5_context context,
                                        krb5_clpreauth_rock rock,
                                        const char *question);

    /* Indicate interest in the AS key through the responder interface. */
    void (*need_as_key)(krb5_context context, krb5_clpreauth_rock rock);

    /*
     * Get a configuration/state item from an input ccache, which may allow it
     * to retrace the steps it took last time.  The returned data string is an
     * alias and should not be freed.
     */
    const char *(*get_cc_config)(krb5_context context,
                                 krb5_clpreauth_rock rock, const char *key);

    /*
     * Set a configuration/state item which will be recorded to an output
     * ccache, if the calling application supplied one.  Both key and data
     * should be valid UTF-8 text.
     */
    krb5_error_code (*set_cc_config)(krb5_context context,
                                     krb5_clpreauth_rock rock,
                                     const char *key, const char *data);

    /* End of version 2 clpreauth callbacks (added in 1.11). */

    /*
     * Prevent further fallbacks to other preauth mechanisms if the KDC replies
     * with an error.  (The module itself can still respond to errors with its
     * tryagain method, or continue after KDC_ERR_MORE_PREAUTH_DATA_REQUIRED
     * errors with its process method.)  A module should invoke this callback
     * from the process method when it generates an authenticated request using
     * credentials; often this will be the first or only client message
     * generated by the mechanism.
     */
    void (*disable_fallback)(krb5_context context, krb5_clpreauth_rock rock);

    /* End of version 3 clpreauth callbacks (added in 1.17). */
} *krb5_clpreauth_callbacks;

/*
 * Optional: per-plugin initialization/cleanup.  The init function is called by
 * libkrb5 when the plugin is loaded, and the fini function is called before
 * the plugin is unloaded.  These may be called multiple times in case the
 * plugin is used in multiple contexts.  The returned context lives the
 * lifetime of the krb5_context.
 */
typedef krb5_error_code
(*krb5_clpreauth_init_fn)(krb5_context context,
                          krb5_clpreauth_moddata *moddata_out);
typedef void
(*krb5_clpreauth_fini_fn)(krb5_context context,
                          krb5_clpreauth_moddata moddata);

/*
 * Optional (mandatory before MIT krb5 1.12): pa_type will be a member of the
 * vtable's pa_type_list.  Return PA_REAL if pa_type is a real
 * preauthentication type or PA_INFO if it is an informational type.  If this
 * function is not defined in 1.12 or later, all pa_type values advertised by
 * the module will be assumed to be real.
 */
typedef int
(*krb5_clpreauth_get_flags_fn)(krb5_context context, krb5_preauthtype pa_type);

/*
 * Optional: per-request initialization/cleanup.  The request_init function is
 * called when beginning to process a get_init_creds request and the
 * request_fini function is called when processing of the request is complete.
 * This is optional.  It may be called multiple times in the lifetime of a
 * krb5_context.
 */
typedef void
(*krb5_clpreauth_request_init_fn)(krb5_context context,
                                  krb5_clpreauth_moddata moddata,
                                  krb5_clpreauth_modreq *modreq_out);
typedef void
(*krb5_clpreauth_request_fini_fn)(krb5_context context,
                                  krb5_clpreauth_moddata moddata,
                                  krb5_clpreauth_modreq modreq);

/*
 * Optional: process server-supplied data in pa_data and set responder
 * questions.
 *
 * encoded_previous_request may be NULL if there has been no previous request
 * in the AS exchange.
 */
typedef krb5_error_code
(*krb5_clpreauth_prep_questions_fn)(krb5_context context,
                                    krb5_clpreauth_moddata moddata,
                                    krb5_clpreauth_modreq modreq,
                                    krb5_get_init_creds_opt *opt,
                                    krb5_clpreauth_callbacks cb,
                                    krb5_clpreauth_rock rock,
                                    krb5_kdc_req *request,
                                    krb5_data *encoded_request_body,
                                    krb5_data *encoded_previous_request,
                                    krb5_pa_data *pa_data);

/*
 * Mandatory: process server-supplied data in pa_data and return created data
 * in pa_data_out.  Also called after the AS-REP is received if the AS-REP
 * includes preauthentication data of the associated type.
 *
 * as_key contains the client-supplied key if known, or an empty keyblock if
 * not.  If it is empty, the module may use gak_fct to fill it in.
 *
 * encoded_previous_request may be NULL if there has been no previous request
 * in the AS exchange.
 */
typedef krb5_error_code
(*krb5_clpreauth_process_fn)(krb5_context context,
                             krb5_clpreauth_moddata moddata,
                             krb5_clpreauth_modreq modreq,
                             krb5_get_init_creds_opt *opt,
                             krb5_clpreauth_callbacks cb,
                             krb5_clpreauth_rock rock,
                             krb5_kdc_req *request,
                             krb5_data *encoded_request_body,
                             krb5_data *encoded_previous_request,
                             krb5_pa_data *pa_data,
                             krb5_prompter_fct prompter, void *prompter_data,
                             krb5_pa_data ***pa_data_out);

/*
 * Optional: Attempt to use error and error_padata to try to recover from the
 * given error.  To work with both FAST and non-FAST errors, an implementation
 * should generally consult error_padata rather than decoding error->e_data.
 * For non-FAST errors, it contains the e_data decoded as either pa-data or
 * typed-data.
 *
 * If this function is provided, and it returns 0 and stores data in
 * pa_data_out, then the client library will retransmit the request.
 */
typedef krb5_error_code
(*krb5_clpreauth_tryagain_fn)(krb5_context context,
                              krb5_clpreauth_moddata moddata,
                              krb5_clpreauth_modreq modreq,
                              krb5_get_init_creds_opt *opt,
                              krb5_clpreauth_callbacks cb,
                              krb5_clpreauth_rock rock,
                              krb5_kdc_req *request,
                              krb5_data *encoded_request_body,
                              krb5_data *encoded_previous_request,
                              krb5_preauthtype pa_type,
                              krb5_error *error,
                              krb5_pa_data **error_padata,
                              krb5_prompter_fct prompter, void *prompter_data,
                              krb5_pa_data ***pa_data_out);

/*
 * Optional: receive krb5_get_init_creds_opt information.  The attr and value
 * information supplied should be copied into moddata by the module if it
 * wishes to reference it after returning from this call.
 */
typedef krb5_error_code
(*krb5_clpreauth_supply_gic_opts_fn)(krb5_context context,
                                     krb5_clpreauth_moddata moddata,
                                     krb5_get_init_creds_opt *opt,
                                     const char *attr, const char *value);

typedef struct krb5_clpreauth_vtable_st {
    /* Mandatory: name of module. */
    const char *name;

    /* Mandatory: pointer to zero-terminated list of pa_types which this module
     * can provide services for. */
    krb5_preauthtype *pa_type_list;

    /* Optional: pointer to zero-terminated list of enc_types which this module
     * claims to add support for. */
    krb5_enctype *enctype_list;

    krb5_clpreauth_init_fn init;
    krb5_clpreauth_fini_fn fini;
    krb5_clpreauth_get_flags_fn flags;
    krb5_clpreauth_request_init_fn request_init;
    krb5_clpreauth_request_fini_fn request_fini;
    krb5_clpreauth_process_fn process;
    krb5_clpreauth_tryagain_fn tryagain;
    krb5_clpreauth_supply_gic_opts_fn gic_opts;
    /* Minor version 1 ends here. */

    krb5_clpreauth_prep_questions_fn prep_questions;
    /* Minor version 2 ends here. */
} *krb5_clpreauth_vtable;

/*
 * This function allows a clpreauth plugin to obtain preauth options.  The
 * preauth_data returned from this function should be freed by calling
 * krb5_get_init_creds_opt_free_pa().
 */
krb5_error_code KRB5_CALLCONV
krb5_get_init_creds_opt_get_pa(krb5_context context,
                               krb5_get_init_creds_opt *opt,
                               int *num_preauth_data,
                               krb5_gic_opt_pa_data **preauth_data);

/*
 * This function frees the preauth_data that was returned by
 * krb5_get_init_creds_opt_get_pa().
 */
void KRB5_CALLCONV
krb5_get_init_creds_opt_free_pa(krb5_context context,
                                int num_preauth_data,
                                krb5_gic_opt_pa_data *preauth_data);

#endif /* KRB5_CLPREAUTH_PLUGIN_H */
                                                                                                                                                                                                                                                                                                                                                       usr/include/mit-krb5/krb5/hostrealm_plugin.h                                                        0000644 0000000 0000000 00000012524 14640563767 017550  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
 * Copyright (C) 2013 by the Massachusetts Institute of Technology.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in
 *   the documentation and/or other materials provided with the
 *   distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Declarations for hostrealm plugin module implementors.
 *
 * The hostrealm pluggable interface currently has only one supported major
 * version, which is 1.  Major version 1 has a current minor version number of
 * 1.
 *
 * Hostrealm plugin modules should define a function named
 * hostrealm_<modulename>_initvt, matching the signature:
 *
 *   krb5_error_code
 *   hostrealm_modname_initvt(krb5_context context, int maj_ver, int min_ver,
 *                            krb5_plugin_vtable vtable);
 *
 * The initvt function should:
 *
 * - Check that the supplied maj_ver number is supported by the module, or
 *   return KRB5_PLUGIN_VER_NOTSUPP if it is not.
 *
 * - Cast the vtable pointer as appropriate for maj_ver:
 *     maj_ver == 1: Cast to krb5_hostrealm_vtable
 *
 * - Initialize the methods of the vtable, stopping as appropriate for the
 *   supplied min_ver.  Optional methods may be left uninitialized.
 *
 * Memory for the vtable is allocated by the caller, not by the module.
 */

#ifndef KRB5_HOSTREALM_PLUGIN_H
#define KRB5_HOSTREALM_PLUGIN_H

#include <krb5/krb5.h>
#include <krb5/plugin.h>

/* An abstract type for hostrealm module data. */
typedef struct krb5_hostrealm_moddata_st *krb5_hostrealm_moddata;

/*** Method type declarations ***/

/* Optional: Initialize module data. */
typedef krb5_error_code
(*krb5_hostrealm_init_fn)(krb5_context context,
                          krb5_hostrealm_moddata *data);

/*
 * Optional: Determine the possible realms of a hostname, using only secure,
 * authoritative mechanisms (ones which should be used prior to trying
 * referrals when getting a service ticket).  Return success with a
 * null-terminated list of realms in *realms_out, KRB5_PLUGIN_NO_HANDLE to
 * defer to later modules, or another error to terminate processing.
 */
typedef krb5_error_code
(*krb5_hostrealm_host_realm_fn)(krb5_context context,
                                krb5_hostrealm_moddata data,
                                const char *host, char ***realms_out);

/*
 * Optional: Determine the possible realms of a hostname, using heuristic or
 * less secure mechanisms (ones which should be used after trying referrals
 * when getting a service ticket).  Return success with a null-terminated list
 * of realms in *realms_out, KRB5_PLUGIN_NO_HANDLE to defer to later modules,
 * or another error to terminate processing.
 */
typedef krb5_error_code
(*krb5_hostrealm_fallback_realm_fn)(krb5_context context,
                                    krb5_hostrealm_moddata data,
                                    const char *host, char ***realms_out);
