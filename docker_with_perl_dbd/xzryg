                "      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));\n"
                "      for (ll = connections; ll != NULL; ll = ll->next)\n"
                "        {\n"
                "          GDBusConnection *connection = ll->data;\n"
                "\n"
                "          g_dbus_connection_emit_signal (connection,\n"
                "                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),\n"
                '                                         "org.freedesktop.DBus.Properties",\n'
                '                                         "PropertiesChanged",\n'
                "                                         signal_variant,\n"
                "                                         NULL);\n"
                "        }\n"
                "      g_variant_unref (signal_variant);\n"
                "      g_list_free_full (connections, g_object_unref);\n"
                "    }\n"
                "  else\n"
                "    {\n"
                "      g_variant_builder_clear (&builder);\n"
                "      g_variant_builder_clear (&invalidated_builder);\n"
                "    }\n" % (i.name)
            )
            self.outfile.write(
                "  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);\n"
            )
            self.outfile.write("  skeleton->priv->changed_properties = NULL;\n")
            self.outfile.write(
                "  skeleton->priv->changed_properties_idle_source = NULL;\n"
            )
            self.outfile.write("  g_mutex_unlock (&skeleton->priv->lock);\n")
            self.outfile.write("  return FALSE;\n" "}\n" "\n")
            # holding lock while being called
            self.outfile.write(
                "static void\n"
                "_%s_schedule_emit_changed (%sSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)\n"
                "{\n"
                "  ChangedProperty *cp;\n"
                "  GList *l;\n"
                "  cp = NULL;\n"
                "  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)\n"
                "    {\n"
                "      ChangedProperty *i_cp = l->data;\n"
                "      if (i_cp->info == info)\n"
                "        {\n"
                "          cp = i_cp;\n"
                "          break;\n"
                "        }\n"
                "    }\n" % (i.name_lower, i.camel_name)
            )
            self.outfile.write(
                "  if (cp == NULL)\n"
                "    {\n"
                "      cp = g_new0 (ChangedProperty, 1);\n"
                "      cp->prop_id = prop_id;\n"
                "      cp->info = info;\n"
                "      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);\n"
                "      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));\n"
                "      g_value_copy (orig_value, &cp->orig_value);\n"
                "    }\n"
                "}\n"
                "\n"
            )

            # Postpone setting up the refresh source until the ::notify signal is emitted as
            # this allows use of g_object_freeze_notify()/g_object_thaw_notify() ...
            # This is useful when updating several properties from another thread than
            # where the idle will be emitted from
            self.outfile.write(
                "static void\n"
                "%s_skeleton_notify (GObject      *object,\n"
                "  GParamSpec *pspec G_GNUC_UNUSED)\n"
                "{\n"
                "  %sSkeleton *skeleton = %s%s_SKELETON (object);\n"
                "  g_mutex_lock (&skeleton->priv->lock);\n"
                "  if (skeleton->priv->changed_properties != NULL &&\n"
                "      skeleton->priv->changed_properties_idle_source == NULL)\n"
                "    {\n"
                "      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();\n"
                "      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);\n"
                "      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _%s_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);\n"
                '      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _%s_emit_changed");\n'
                "      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);\n"
                "      g_source_unref (skeleton->priv->changed_properties_idle_source);\n"
                "    }\n"
                "  g_mutex_unlock (&skeleton->priv->lock);\n"
                "}\n"
                "\n"
                % (
                    i.name_lower,
                    i.camel_name,
                    i.ns_upper,
                    i.name_upper,
                    i.name_lower,
                    i.name_lower,
                )
            )

            self.outfile.write(
                "static void\n"
                "%s_skeleton_set_property (GObject      *object,\n"
                "  guint         prop_id,\n"
                "  const GValue *value,\n"
                "  GParamSpec   *pspec)\n"
                "{\n" % (i.name_lower)
            )
            self.outfile.write(
                "  const _ExtendedGDBusPropertyInfo *info;\n"
                "  %sSkeleton *skeleton = %s%s_SKELETON (object);\n"
                "  g_assert (prop_id != 0 && prop_id - 1 < %d);\n"
                "  info = (const _ExtendedGDBusPropertyInfo *) _%s_property_info_pointers[prop_id - 1];\n"
                "  g_mutex_lock (&skeleton->priv->lock);\n"
                "  g_object_freeze_notify (object);\n"
                "  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))\n"
                "    {\n"
                "      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL &&\n"
                "          info->emits_changed_signal)\n"
                "        _%s_schedule_emit_changed (skeleton, info, prop_id, &skeleton->priv->properties[prop_id - 1]);\n"
                "      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);\n"
                "      g_object_notify_by_pspec (object, pspec);\n"
                "    }\n"
                "  g_mutex_unlock (&skeleton->priv->lock);\n"
                "  g_object_thaw_notify (object);\n"
                % (
                    i.camel_name,
                    i.ns_upper,
                    i.name_upper,
                    len(i.properties),
                    i.name_lower,
                    i.name_lower,
                )
            )
            self.outfile.write("}\n" "\n")

        self.outfile.write(
            "static void\n"
            "%s_skeleton_init (%sSkeleton *skeleton)\n"
            "{\n"
            "#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38\n"
            "  skeleton->priv = %s_skeleton_get_instance_private (skeleton);\n"
            "#else\n"
            "  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, %sTYPE_%s_SKELETON, %sSkeletonPrivate);\n"
            "#endif\n\n"
            % (
                i.name_lower,
                i.camel_name,
                i.name_lower,
                i.ns_upper,
                i.name_upper,
                i.camel_name,
            )
        )
        self.outfile.write("  g_mutex_init (&skeleton->priv->lock);\n")
        self.outfile.write(
            "  skeleton->priv->context = g_main_context_ref_thread_default ();\n"
        )
        if len(i.properties) > 0:
            self.outfile.write(
                "  skeleton->priv->properties = g_new0 (GValue, %d);\n"
                % (len(i.properties))
            )
            n = 0
            for p in i.properties:
                self.outfile.write(
                    "  g_value_init (&skeleton->priv->properties[%d], %s);\n"
                    % (n, p.arg.gtype)
                )
                n += 1
        self.outfile.write("}\n" "\n")

        # property vfuncs
        n = 0
        for p in i.properties:
            self.outfile.write(
                "static %s\n"
                "%s_skeleton_get_%s (%s *object)\n"
                "{\n" % (p.arg.ctype_in, i.name_lower, p.name_lower, i.camel_name)
            )
            self.outfile.write(
                "  %sSkeleton *skeleton = %s%s_SKELETON (object);\n"
                % (i.camel_name, i.ns_upper, i.name_upper)
            )
            self.outfile.write(
                "  %svalue;\n"
                "  g_mutex_lock (&skeleton->priv->lock);\n"
                "  value = %s (&(skeleton->priv->properties[%d]));\n"
                "  g_mutex_unlock (&skeleton->priv->lock);\n"
                % (p.arg.ctype_in_g, p.arg.gvalue_get, n)
            )
            self.outfile.write("  return value;\n")
            self.outfile.write("}\n")
            self.outfile.write("\n")
            n += 1

        self.outfile.write(
            "static void\n"
            "%s_skeleton_class_init (%sSkeletonClass *klass)\n"
            "{\n"
            "  GObjectClass *gobject_class;\n"
            "  GDBusInterfaceSkeletonClass *skeleton_class;\n"
            "\n"
            "  gobject_class = G_OBJECT_CLASS (klass);\n"
            "  gobject_class->finalize = %s_skeleton_finalize;\n"
            % (i.name_lower, i.camel_name, i.name_lower)
        )
        if len(i.properties) > 0:
            self.outfile.write(
                "  gobject_class->get_property = %s_skeleton_get_property;\n"
                "  gobject_class->set_property = %s_skeleton_set_property;\n"
                "  gobject_class->notify       = %s_skeleton_notify;\n"
                "\n" % (i.name_lower, i.name_lower, i.name_lower)
            )
            self.outfile.write(
                "\n" "  %s_override_properties (gobject_class, 1);\n" % (i.name_lower)
            )
        self.outfile.write(
            "\n" "  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);\n"
        )
        self.outfile.write(
            "  skeleton_class->get_info = %s_skeleton_dbus_interface_get_info;\n"
            % (i.name_lower)
        )
        self.outfile.write(
            "  skeleton_class->get_properties = %s_skeleton_dbus_interface_get_properties;\n"
            % (i.name_lower)
        )
        self.outfile.write(
            "  skeleton_class->flush = %s_skeleton_dbus_interface_flush;\n"
            % (i.name_lower)
        )
        self.outfile.write(
            "  skeleton_class->get_vtable = %s_skeleton_dbus_interface_get_vtable;\n"
            % (i.name_lower)
        )

        self.outfile.write(
            "\n"
            "#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38\n"
            "  g_type_class_add_private (klass, sizeof (%sSkeletonPrivate));\n"
            "#endif\n" % (i.camel_name)
        )

        self.outfile.write("}\n" "\n")

        self.outfile.write(
            "static void\n"
            "%s_skeleton_iface_init (%sIface *iface" % (i.name_lower, i.camel_name)
        )
        if len(i.signals) == 0 and len(i.properties) == 0:
            self.outfile.write(" G_GNUC_UNUSED)\n")
        else:
            self.outfile.write(")\n")
        self.outfile.write("{\n")
        for s in i.signals:
            self.outfile.write(
                "  iface->%s = _%s_on_signal_%s;\n"
                % (s.name_lower, i.name_lower, s.name_lower)
            )
        for p in i.properties:
            self.outfile.write(
                "  iface->get_%s = %s_skeleton_get_%s;\n"
                % (p.name_lower, i.name_lower, p.name_lower)
            )
        self.outfile.write("}\n" "\n")

        # constructors
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %s_skeleton_new:\n"
                " *\n"
                " * Creates a skeleton object for the D-Bus interface #%s.\n"
                " *\n"
                " * Returns: (transfer full) (type %sSkeleton): The skeleton object.\n"
                % (i.name_lower, i.name, i.camel_name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write(
            "%s *\n"
            "%s_skeleton_new (void)\n"
            "{\n"
            "  return %s%s (g_object_new (%sTYPE_%s_SKELETON, NULL));\n"
            "}\n"
            "\n"
            % (
                i.camel_name,
                i.name_lower,
                i.ns_upper,
                i.name_upper,
                i.ns_upper,
                i.name_upper,
            )
        )

    # ---------------------------------------------------------------------------------------------------

    def generate_object(self):
        self.outfile.write(
            "/* ------------------------------------------------------------------------\n"
            " * Code for Object, ObjectProxy and ObjectSkeleton\n"
            " * ------------------------------------------------------------------------\n"
            " */\n"
            "\n"
        )

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * SECTION:%sObject\n"
                " * @title: %sObject\n"
                " * @short_description: Specialized GDBusObject types\n"
                " *\n"
                " * This section contains the #%sObject, #%sObjectProxy, and #%sObjectSkeleton types which make it easier to work with objects implementing generated types for D-Bus interfaces.\n"
                " */\n"
                % (
                    self.namespace,
                    self.namespace,
                    self.namespace,
                    self.namespace,
                    self.namespace,
                ),
                False,
            )
        )
        self.outfile.write("\n")

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sObject:\n"
                " *\n"
                " * The #%sObject type is a specialized container of interfaces.\n"
                " */\n" % (self.namespace, self.namespace),
                False,
            )
        )
        self.outfile.write("\n")

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sObjectIface:\n"
                " * @parent_iface: The parent interface.\n"
                " *\n"
                " * Virtual table for the #%sObject interface.\n"
                " */\n" % (self.namespace, self.namespace),
                False,
            )
        )
        self.outfile.write("\n")

        self.outfile.write(
            "typedef %sObjectIface %sObjectInterface;\n"
            % (self.namespace, self.namespace)
        )
        self.outfile.write(
            "G_DEFINE_INTERFACE_WITH_CODE (%sObject, %sobject, G_TYPE_OBJECT, g_type_interface_add_prerequisite (g_define_type_id, G_TYPE_DBUS_OBJECT);)\n"
            % (self.namespace, self.ns_lower)
        )
        self.outfile.write("\n")
        self.outfile.write(
            "static void\n"
            "%sobject_default_init (%sObjectIface *iface)\n"
            "{\n" % (self.ns_lower, self.namespace)
        )
        for i in self.ifaces:
            self.outfile.write(
                self.docbook_gen.expand(
                    "  /**\n"
                    "   * %sObject:%s:\n"
                    "   *\n"
                    "   * The #%s instance corresponding to the D-Bus interface #%s, if any.\n"
                    "   *\n"
                    "   * Connect to the #GObject::notify signal to get informed of property changes.\n"
                    % (self.namespace, i.name_hyphen, i.camel_name, i.name),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 2)
            flags = "G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS"
            if i.deprecated:
                flags = "G_PARAM_DEPRECATED | " + flags
            self.outfile.write(
                '  g_object_interface_install_property (iface, g_param_spec_object ("%s", "%s", "%s", %sTYPE_%s, %s));\n'
                "\n"
                % (
                    i.name_hyphen,
                    i.name_hyphen,
                    i.name_hyphen,
                    self.ns_upper,
                    i.name_upper,
                    flags,
                )
            )
        self.outfile.write("}\n" "\n")

        for i in self.ifaces:
            self.outfile.write(
                self.docbook_gen.expand(
                    "/**\n"
                    " * %sobject_get_%s:\n"
                    " * @object: A #%sObject.\n"
                    " *\n"
                    " * Gets the #%s instance for the D-Bus interface #%s on @object, if any.\n"
                    " *\n"
                    " * Returns: (transfer full) (nullable): A #%s that must be freed with g_object_unref() or %%NULL if @object does not implement the interface.\n"
                    % (
                        self.ns_lower,
                        i.name_upper.lower(),
                        self.namespace,
                        i.camel_name,
                        i.name,
                        i.camel_name,
                    ),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
            self.outfile.write(
                "%s *%sobject_get_%s (%sObject *object)\n"
                % (i.camel_name, self.ns_lower, i.name_upper.lower(), self.namespace)
            )
            self.outfile.write(
                "{\n"
                "  GDBusInterface *ret;\n"
                '  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "%s");\n'
                "  if (ret == NULL)\n"
                "    return NULL;\n"
                "  return %s%s (ret);\n"
                "}\n"
                "\n" % (i.name, self.ns_upper, i.name_upper)
            )
        self.outfile.write("\n")
        for i in self.ifaces:
            self.outfile.write(
                self.docbook_gen.expand(
                    "/**\n"
                    " * %sobject_peek_%s: (skip)\n"
                    " * @object: A #%sObject.\n"
                    " *\n"
                    " * Like %sobject_get_%s() but doesn't increase the reference count on the returned object.\n"
                    " *\n"
                    " * It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.\n"
                    " *\n"
                    " * Returns: (transfer none) (nullable): A #%s or %%NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.\n"
                    % (
                        self.ns_lower,
                        i.name_upper.lower(),
                        self.namespace,
                        self.ns_lower,
                        i.name_upper.lower(),
                        i.camel_name,
                    ),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
            self.outfile.write(
                "%s *%sobject_peek_%s (%sObject *object)\n"
                % (i.camel_name, self.ns_lower, i.name_upper.lower(), self.namespace)
            )
            self.outfile.write(
                "{\n"
                "  GDBusInterface *ret;\n"
                '  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "%s");\n'
                "  if (ret == NULL)\n"
                "    return NULL;\n"
                "  g_object_unref (ret);\n"
                "  return %s%s (ret);\n"
                "}\n"
                "\n" % (i.name, self.ns_upper, i.name_upper)
            )
        self.outfile.write("\n")
        # shared by ObjectProxy and ObjectSkeleton classes
        self.outfile.write(
            "static void\n"
            "%sobject_notify (GDBusObject *object, GDBusInterface *interface)\n"
            "{\n"
            "  _ExtendedGDBusInterfaceInfo *info = (_ExtendedGDBusInterfaceInfo *) g_dbus_interface_get_info (interface);\n"
            "  /* info can be NULL if the other end is using a D-Bus interface we don't know\n"
            "   * anything about, for example old generated code in this process talking to\n"
            "   * newer generated code in the other process. */\n"
            "  if (info != NULL)\n"
            "    g_object_notify (G_OBJECT (object), info->hyphen_name);\n"
            "}\n"
            "\n" % (self.ns_lower)
        )

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sObjectProxy:\n"
                " *\n"
                " * The #%sObjectProxy structure contains only private data and should only be accessed using the provided API.\n"
                % (self.namespace, self.namespace),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write("\n")
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sObjectProxyClass:\n"
                " * @parent_class: The parent class.\n"
                " *\n"
                " * Class structure for #%sObjectProxy.\n"
                % (self.namespace, self.namespace),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write("\n")
        # class boilerplate
        self.outfile.write(
            "static void\n"
            "%sobject_proxy__%sobject_iface_init (%sObjectIface *iface G_GNUC_UNUSED)\n"
            "{\n"
            "}\n"
            "\n" % (self.ns_lower, self.ns_lower, self.namespace)
        )
        self.outfile.write(
            "static void\n"
            "%sobject_proxy__g_dbus_object_iface_init (GDBusObjectIface *iface)\n"
            "{\n"
            "  iface->interface_added = %sobject_notify;\n"
            "  iface->interface_removed = %sobject_notify;\n"
            "}\n"
            "\n" % (self.ns_lower, self.ns_lower, self.ns_lower)
        )
        self.outfile.write("\n")
        self.outfile.write(
            "G_DEFINE_TYPE_WITH_CODE (%sObjectProxy, %sobject_proxy, G_TYPE_DBUS_OBJECT_PROXY,\n"
            "                         G_IMPLEMENT_INTERFACE (%sTYPE_OBJECT, %sobject_proxy__%sobject_iface_init)\n"
            "                         G_IMPLEMENT_INTERFACE (G_TYPE_DBUS_OBJECT, %sobject_proxy__g_dbus_object_iface_init))\n"
            "\n"
            % (
                self.namespace,
                self.ns_lower,
                self.ns_upper,
                self.ns_lower,
                self.ns_lower,
                self.ns_lower,
            )
        )
        # class boilerplate
        self.outfile.write(
            "static void\n"
            "%sobject_proxy_init (%sObjectProxy *object G_GNUC_UNUSED)\n"
            "{\n"
            "}\n"
            "\n" % (self.ns_lower, self.namespace)
        )
        self.outfile.write(
            "static void\n"
            "%sobject_proxy_set_property (GObject      *gobject,\n"
            "  guint         prop_id,\n"
            "  const GValue *value G_GNUC_UNUSED,\n"
            "  GParamSpec   *pspec)\n"
            "{\n"
            "  G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);\n"
            % (self.ns_lower)
        )
        self.outfile.write("}\n" "\n")
        self.outfile.write(
            "static void\n"
            "%sobject_proxy_get_property (GObject      *gobject,\n"
            "  guint         prop_id,\n"
            "  GValue       *value,\n"
            "  GParamSpec   *pspec)\n"
            "{\n"
            "  %sObjectProxy *object = %sOBJECT_PROXY (gobject);\n"
            "  GDBusInterface *interface;\n"
            "\n"
            "  switch (prop_id)\n"
            "    {\n" % (self.ns_lower, self.namespace, self.ns_upper)
        )
        n = 1
        for i in self.ifaces:
            self.outfile.write(
                "    case %d:\n"
                '      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "%s");\n'
                "      g_value_take_object (value, interface);\n"
                "      break;\n"
                "\n" % (n, i.name)
            )
            n += 1
        self.outfile.write(
            "    default:\n"
            "      G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);\n"
            "      break;\n"
            "  }\n"
            "}\n"
            "\n"
        )
        self.outfile.write(
            "static void\n"
            "%sobject_proxy_class_init (%sObjectProxyClass *klass)\n"
            "{\n"
            "  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);\n"
            "\n"
            "  gobject_class->set_property = %sobject_proxy_set_property;\n"
            "  gobject_class->get_property = %sobject_proxy_get_property;\n"
            "\n" % (self.ns_lower, self.namespace, self.ns_lower, self.ns_lower)
        )
        n = 1
        for i in self.ifaces:
            self.outfile.write(
                '  g_object_class_override_property (gobject_class, %d, "%s");'
                "\n" % (n, i.name_hyphen)
            )
            n += 1
        self.outfile.write("}\n" "\n")

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sobject_proxy_new:\n"
                " * @connection: A #GDBusConnection.\n"
                " * @object_path: An object path.\n"
                " *\n"
                " * Creates a new proxy object.\n"
                " *\n"
                " * Returns: (transfer full): The proxy object.\n"
                " */\n" % (self.ns_lower),
                False,
            )
        )
        self.outfile.write(
            "%sObjectProxy *\n"
            "%sobject_proxy_new (GDBusConnection *connection,\n"
            "  const gchar *object_path)\n"
            "{\n"
            "  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), NULL);\n"
            "  g_return_val_if_fail (g_variant_is_object_path (object_path), NULL);\n"
            '  return %sOBJECT_PROXY (g_object_new (%sTYPE_OBJECT_PROXY, "g-connection", connection, "g-object-path", object_path, NULL));\n'
            "}\n"
            "\n" % (self.namespace, self.ns_lower, self.ns_upper, self.ns_upper)
        )

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sObjectSkeleton:\n"
                " *\n"
                " * The #%sObjectSkeleton structure contains only private data and should only be accessed using the provided API.\n"
                % (self.namespace, self.namespace),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write("\n")
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sObjectSkeletonClass:\n"
                " * @parent_class: The parent class.\n"
                " *\n"
                " * Class structure for #%sObjectSkeleton.\n"
                % (self.namespace, self.namespace),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write("\n")
        # class boilerplate
        self.outfile.write(
            "static void\n"
            "%sobject_skeleton__%sobject_iface_init (%sObjectIface *iface G_GNUC_UNUSED)\n"
            "{\n"
            "}\n"
            "\n" % (self.ns_lower, self.ns_lower, self.namespace)
        )
        self.outfile.write("\n")
        self.outfile.write(
            "static void\n"
            "%sobject_skeleton__g_dbus_object_iface_init (GDBusObjectIface *iface)\n"
            "{\n"
            "  iface->interface_added = %sobject_notify;\n"
            "  iface->interface_removed = %sobject_notify;\n"
            "}\n"
            "\n" % (self.ns_lower, self.ns_lower, self.ns_lower)
        )
        self.outfile.write(
            "G_DEFINE_TYPE_WITH_CODE (%sObjectSkeleton, %sobject_skeleton, G_TYPE_DBUS_OBJECT_SKELETON,\n"
            "                         G_IMPLEMENT_INTERFACE (%sTYPE_OBJECT, %sobject_skeleton__%sobject_iface_init)\n"
            "                         G_IMPLEMENT_INTERFACE (G_TYPE_DBUS_OBJECT, %sobject_skeleton__g_dbus_object_iface_init))\n"
            "\n"
            % (
                self.namespace,
                self.ns_lower,
                self.ns_upper,
                self.ns_lower,
                self.ns_lower,
                self.ns_lower,
            )
        )
        # class boilerplate
        self.outfile.write(
            "static void\n"
            "%sobject_skeleton_init (%sObjectSkeleton *object G_GNUC_UNUSED)\n"
            "{\n"
            "}\n"
            "\n" % (self.ns_lower, self.namespace)
        )
        self.outfile.write(
            "static void\n"
            "%sobject_skeleton_set_property (GObject      *gobject,\n"
            "  guint         prop_id,\n"
            "  const GValue *value,\n"
            "  GParamSpec   *pspec)\n"
            "{\n"
            "  %sObjectSkeleton *object = %sOBJECT_SKELETON (gobject);\n"
            "  GDBusInterfaceSkeleton *interface;\n"
            "\n"
            "  switch (prop_id)\n"
            "    {\n" % (self.ns_lower, self.namespace, self.ns_upper)
        )
        n = 1
        for i in self.ifaces:
            self.outfile.write(
                "    case %d:\n"
                "      interface = g_value_get_object (value);\n"
                "      if (interface != NULL)\n"
                "        {\n"
                "          g_warn_if_fail (%sIS_%s (interface));\n"
                "          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);\n"
                "        }\n"
                "      else\n"
                "        {\n"
                '          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "%s");\n'
                "        }\n"
                "      break;\n"
                "\n" % (n, self.ns_upper, i.name_upper, i.name)
            )
            n += 1
        self.outfile.write(
            "    default:\n"
            "      G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);\n"
            "      break;\n"
            "  }\n"
            "}\n"
            "\n"
        )
        self.outfile.write(
            "static void\n"
            "%sobject_skeleton_get_property (GObject      *gobject,\n"
            "  guint         prop_id,\n"
            "  GValue       *value,\n"
            "  GParamSpec   *pspec)\n"
            "{\n"
            "  %sObjectSkeleton *object = %sOBJECT_SKELETON (gobject);\n"
            "  GDBusInterface *interface;\n"
            "\n"
            "  switch (prop_id)\n"
            "    {\n" % (self.ns_lower, self.namespace, self.ns_upper)
        )
        n = 1
        for i in self.ifaces:
            self.outfile.write(
                "    case %d:\n"
                '      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "%s");\n'
                "      g_value_take_object (value, interface);\n"
                "      break;\n"
                "\n" % (n, i.name)
            )
            n += 1
        self.outfile.write(
            "    default:\n"
            "      G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);\n"
            "      break;\n"
            "  }\n"
            "}\n"
            "\n"
        )
        self.outfile.write(
            "static void\n"
            "%sobject_skeleton_class_init (%sObjectSkeletonClass *klass)\n"
            "{\n"
            "  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);\n"
            "\n"
            "  gobject_class->set_property = %sobject_skeleton_set_property;\n"
            "  gobject_class->get_property = %sobject_skeleton_get_property;\n"
            "\n" % (self.ns_lower, self.namespace, self.ns_lower, self.ns_lower)
        )
        n = 1
        for i in self.ifaces:
            self.outfile.write(
                '  g_object_class_override_property (gobject_class, %d, "%s");'
                "\n" % (n, i.name_hyphen)
            )
            n += 1
        self.outfile.write("}\n" "\n")
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sobject_skeleton_new:\n"
                " * @object_path: An object path.\n"
                " *\n"
                " * Creates a new skeleton object.\n"
                " *\n"
                " * Returns: (transfer full): The skeleton object.\n"
                " */\n" % (self.ns_lower),
                False,
            )
        )
        self.outfile.write(
            "%sObjectSkeleton *\n"
            "%sobject_skeleton_new (const gchar *object_path)\n"
            "{\n"
            "  g_return_val_if_fail (g_variant_is_object_path (object_path), NULL);\n"
            '  return %sOBJECT_SKELETON (g_object_new (%sTYPE_OBJECT_SKELETON, "g-object-path", object_path, NULL));\n'
            "}\n"
            "\n" % (self.namespace, self.ns_lower, self.ns_upper, self.ns_upper)
        )
        for i in self.ifaces:
            self.outfile.write(
                self.docbook_gen.expand(
                    "/**\n"
                    " * %sobject_skeleton_set_%s:\n"
                    " * @object: A #%sObjectSkeleton.\n"
                    " * @interface_: (nullable): A #%s or %%NULL to clear the interface.\n"
                    " *\n"
                    " * Sets the #%s instance for the D-Bus interface #%s on @object.\n"
                    % (
                        self.ns_lower,
                        i.name_upper.lower(),
                        self.namespace,
                        i.camel_name,
                        i.camel_name,
                        i.name,
                    ),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
            self.outfile.write(
                "void %sobject_skeleton_set_%s (%sObjectSkeleton *object, %s *interface_)\n"
                % (self.ns_lower, i.name_upper.lower(), self.namespace, i.camel_name)
            )
            self.outfile.write(
                "{\n"
                '  g_object_set (G_OBJECT (object), "%s", interface_, NULL);\n'
                "}\n"
                "\n" % (i.name_hyphen)
            )
        self.outfile.write("\n")

    def generate_object_manager_client(self):
        self.outfile.write(
            "/* ------------------------------------------------------------------------\n"
            " * Code for ObjectManager client\n"
            " * ------------------------------------------------------------------------\n"
            " */\n"
            "\n"
        )

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * SECTION:%sObjectManagerClient\n"
                " * @title: %sObjectManagerClient\n"
                " * @short_description: Generated GDBusObjectManagerClient type\n"
                " *\n"
                " * This section contains a #GDBusObjectManagerClient that uses %sobject_manager_client_get_proxy_type() as the #GDBusProxyTypeFunc.\n"
                " */\n" % (self.namespace, self.namespace, self.ns_lower),
                False,
            )
        )
        self.outfile.write("\n")

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sObjectManagerClient:\n"
                " *\n"
                " * The #%sObjectManagerClient structure contains only private data and should only be accessed using the provided API.\n"
                % (self.namespace, self.namespace),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write("\n")

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sObjectManagerClientClass:\n"
                " * @parent_class: The parent class.\n"
                " *\n"
                " * Class structure for #%sObjectManagerClient.\n"
                % (self.namespace, self.namespace),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write("\n")

        # class boilerplate
        self.outfile.write(
            "G_DEFINE_TYPE (%sObjectManagerClient, %sobject_manager_client, G_TYPE_DBUS_OBJECT_MANAGER_CLIENT)\n"
            "\n" % (self.namespace, self.ns_lower)
        )

        # class boilerplate
        self.outfile.write(
            "static void\n"
            "%sobject_manager_client_init (%sObjectManagerClient *manager G_GNUC_UNUSED)\n"
            "{\n"
            "}\n"
            "\n" % (self.ns_lower, self.namespace)
        )
        self.outfile.write(
            "static void\n"
            "%sobject_manager_client_class_init (%sObjectManagerClientClass *klass G_GNUC_UNUSED)\n"
            "{\n"
            "}\n"
            "\n" % (self.ns_lower, self.namespace)
        )

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sobject_manager_client_get_proxy_type:\n"
                " * @manager: A #GDBusObjectManagerClient.\n"
                " * @object_path: The object path of the remote object (unused).\n"
                " * @interface_name: (nullable): Interface name of the remote object or %%NULL to get the object proxy #GType.\n"
                " * @user_data: User data (unused).\n"
                " *\n"
                " * A #GDBusProxyTypeFunc that maps @interface_name to the generated #GDBusObjectProxy derived and #GDBusProxy derived types.\n"
                " *\n"
                " * Returns: A #GDBusProxy derived #GType if @interface_name is not %%NULL, otherwise the #GType for #%sObjectProxy.\n"
                % (self.ns_lower, self.namespace),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write(
            "GType\n"
            "%sobject_manager_client_get_proxy_type (GDBusObjectManagerClient *manager G_GNUC_UNUSED, const gchar *object_path G_GNUC_UNUSED, const gchar *interface_name, gpointer user_data G_GNUC_UNUSED)\n"
            "{\n" % (self.ns_lower)
        )
        self.outfile.write(
            "  static gsize once_init_value = 0;\n"
            "  static GHashTable *lookup_hash;\n"
            "  GType ret;\n"
            "\n"
            "  if (interface_name == NULL)\n"
            "    return %sTYPE_OBJECT_PROXY;\n"
            "  if (g_once_init_enter (&once_init_value))\n"
            "    {\n"
            "      lookup_hash = g_hash_table_new (g_str_hash, g_str_equal);\n"
            % (self.ns_upper)
        )
        for i in self.ifaces:
            self.outfile.write(
                '      g_hash_table_insert (lookup_hash, (gpointer) "%s", GSIZE_TO_POINTER (%sTYPE_%s_PROXY));\n'
                % (i.name, i.ns_upper, i.name_upper)
            )
        self.outfile.write("      g_once_init_leave (&once_init_value, 1);\n" "    }\n")
        self.outfile.write(
            "  ret = (GType) GPOINTER_TO_SIZE (g_hash_table_lookup (lookup_hash, interface_name));\n"
            "  if (ret == (GType) 0)\n"
            "    ret = G_TYPE_DBUS_PROXY;\n"
        )
        self.outfile.write("  return ret;\n" "}\n" "\n")

        # constructors
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sobject_manager_client_new:\n"
                " * @connection: A #GDBusConnection.\n"
                " * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.\n"
                " * @name: (nullable): A bus name (well-known or unique) or %%NULL if @connection is not a message bus connection.\n"
                " * @object_path: An object path.\n"
                " * @cancellable: (nullable): A #GCancellable or %%NULL.\n"
                " * @callback: A #GAsyncReadyCallback to call when the request is satisfied.\n"
                " * @user_data: User data to pass to @callback.\n"
                " *\n"
                " * Asynchronously creates #GDBusObjectManagerClient using %sobject_manager_client_get_proxy_type() as the #GDBusProxyTypeFunc. See g_dbus_object_manager_client_new() for more details.\n"
                " *\n"
                " * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).\n"
                " * You can then call %sobject_manager_client_new_finish() to get the result of the operation.\n"
                " *\n"
                " * See %sobject_manager_client_new_sync() for the synchronous, blocking version of this constructor.\n"
                % (self.ns_lower, self.ns_lower, self.ns_lower, self.ns_lower),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write(
            "void\n"
            "%sobject_manager_client_new (\n"
            "    GDBusConnection        *connection,\n"
            "    GDBusObjectManagerClientFlags  flags,\n"
            "    const gchar            *name,\n"
            "    const gchar            *object_path,\n"
            "    GCancellable           *cancellable,\n"
            "    GAsyncReadyCallback     callback,\n"
