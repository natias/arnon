	struct {
		struct __db_txn *tqe_next;
		struct __db_txn **tqe_prev;
	} klinks;			/* Links of children in parent. */

	/*
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * TAILQ_HEAD(__my_cursors, __dbc) my_cursors;
	 */
	struct __my_cursors {
		struct __dbc *tqh_first;
		struct __dbc **tqh_last;
	} my_cursors;

	/*
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * TAILQ_HEAD(__femfs, MPOOLFILE) femfs;
	 *
	 * These are DBs involved in file extension in this transaction.
	 */
	struct __femfs {
		DB *tqh_first;
		DB **tqh_last;
	} femfs;

	DB_TXN_TOKEN	*token_buffer;	/* User's commit token buffer. */
	void	*api_internal;		/* C++ API private. */
	void	*xml_internal;		/* XML API private. */

	u_int32_t	cursors;	/* Number of cursors open for txn */

	/* DB_TXN PUBLIC HANDLE LIST BEGIN */
	int	  (*abort) __P((DB_TXN *));
	int	  (*commit) __P((DB_TXN *, u_int32_t));
	int	  (*discard) __P((DB_TXN *, u_int32_t));
	int	  (*get_name) __P((DB_TXN *, const char **));
	int	  (*get_priority) __P((DB_TXN *, u_int32_t *));
	u_int32_t (*id) __P((DB_TXN *));
	int	  (*prepare) __P((DB_TXN *, u_int8_t *));
	int	  (*set_commit_token) __P((DB_TXN *, DB_TXN_TOKEN *));
	int	  (*set_name) __P((DB_TXN *, const char *));
	int	  (*set_priority) __P((DB_TXN *, u_int32_t));
	int	  (*set_timeout) __P((DB_TXN *, db_timeout_t, u_int32_t));
	/* DB_TXN PUBLIC HANDLE LIST END */

	/* DB_TXN PRIVATE HANDLE LIST BEGIN */
	void	  (*set_txn_lsnp) __P((DB_TXN *txn, DB_LSN **, DB_LSN **));
	/* DB_TXN PRIVATE HANDLE LIST END */

#define	TXN_XA_THREAD_NOTA		0
#define	TXN_XA_THREAD_ASSOCIATED	1
#define	TXN_XA_THREAD_SUSPENDED		2
#define	TXN_XA_THREAD_UNASSOCIATED 	3
	u_int32_t	xa_thr_status;

#define	TXN_CHILDCOMMIT		0x00001	/* Txn has committed. */
#define	TXN_COMPENSATE		0x00002	/* Compensating transaction. */
#define	TXN_DEADLOCK		0x00004	/* Txn has deadlocked. */
#define	TXN_FAMILY		0x00008	/* Cursors/children are independent. */
#define	TXN_IGNORE_LEASE	0x00010	/* Skip lease check at commit time. */
#define	TXN_INFAMILY		0x00020	/* Part of a transaction family. */
#define	TXN_LOCKTIMEOUT		0x00040	/* Txn has a lock timeout. */
#define	TXN_MALLOC		0x00080	/* Structure allocated by TXN system. */
#define	TXN_NOSYNC		0x00100	/* Do not sync on prepare and commit. */
#define	TXN_NOWAIT		0x00200	/* Do not wait on locks. */
#define	TXN_PRIVATE		0x00400	/* Txn owned by cursor. */
#define	TXN_READONLY		0x00800	/* CDS group handle. */
#define	TXN_READ_COMMITTED	0x01000	/* Txn has degree 2 isolation. */
#define	TXN_READ_UNCOMMITTED	0x02000	/* Txn has degree 1 isolation. */
#define	TXN_RESTORED		0x04000	/* Txn has been restored. */
#define	TXN_SNAPSHOT		0x08000	/* Snapshot Isolation. */
#define	TXN_SYNC		0x10000	/* Write and sync on prepare/commit. */
#define	TXN_WRITE_NOSYNC	0x20000	/* Write only on prepare/commit. */
#define TXN_BULK		0x40000 /* Enable bulk loading optimization. */
	u_int32_t	flags;
};

#define	TXN_SYNC_FLAGS (TXN_SYNC | TXN_NOSYNC | TXN_WRITE_NOSYNC)

/*
 * Structure used for two phase commit interface.
 * We set the size of our global transaction id (gid) to be 128 in order
 * to match that defined by the XA X/Open standard.
 */
#define	DB_GID_SIZE	128
struct __db_preplist {
	DB_TXN	*txn;
	u_int8_t gid[DB_GID_SIZE];
};

/* Transaction statistics structure. */
struct __db_txn_active {
	u_int32_t txnid;		/* Transaction ID */
	u_int32_t parentid;		/* Transaction ID of parent */
	pid_t     pid;			/* Process owning txn ID */
	db_threadid_t tid;		/* Thread owning txn ID */

	DB_LSN	  lsn;			/* LSN when transaction began */

	DB_LSN	  read_lsn;		/* Read LSN for MVCC */
	u_int32_t mvcc_ref;		/* MVCC reference count */

	u_int32_t priority;		/* Deadlock resolution priority */

#define	TXN_ABORTED		1
#define	TXN_COMMITTED		2
#define	TXN_NEED_ABORT		3
#define	TXN_PREPARED		4
#define	TXN_RUNNING		5
	u_int32_t status;		/* Status of the transaction */

#define	TXN_XA_ACTIVE		1
#define	TXN_XA_DEADLOCKED	2
#define	TXN_XA_IDLE		3
#define	TXN_XA_PREPARED		4
#define	TXN_XA_ROLLEDBACK	5
	u_int32_t xa_status;		/* XA status */

	u_int8_t  gid[DB_GID_SIZE];	/* Global transaction ID */
	char	  name[51];		/* 50 bytes of name, nul termination */
};

struct __db_txn_stat {
	u_int32_t st_nrestores;		/* number of restored transactions
					   after recovery. */
#ifndef __TEST_DB_NO_STATISTICS
	DB_LSN	  st_last_ckp;		/* lsn of the last checkpoint */
	time_t	  st_time_ckp;		/* time of last checkpoint */
	u_int32_t st_last_txnid;	/* last transaction id given out */
	u_int32_t st_inittxns;		/* inital txns allocated */
	u_int32_t st_maxtxns;		/* maximum txns possible */
	uintmax_t st_naborts;		/* number of aborted transactions */
	uintmax_t st_nbegins;		/* number of begun transactions */
	uintmax_t st_ncommits;		/* number of committed transactions */
	u_int32_t st_nactive;		/* number of active transactions */
	u_int32_t st_nsnapshot;		/* number of snapshot transactions */
	u_int32_t st_maxnactive;	/* maximum active transactions */
	u_int32_t st_maxnsnapshot;	/* maximum snapshot transactions */
	uintmax_t st_region_wait;	/* Region lock granted after wait. */
	uintmax_t st_region_nowait;	/* Region lock granted without wait. */
	roff_t	  st_regsize;		/* Region size. */
	DB_TXN_ACTIVE *st_txnarray;	/* array of active transactions */
#endif
};

#define	DB_TXN_TOKEN_SIZE		20
struct __db_txn_token {
	u_int8_t buf[DB_TXN_TOKEN_SIZE];
};

/*******************************************************
 * Replication.
 *******************************************************/
/* Special, out-of-band environment IDs. */
#define	DB_EID_BROADCAST	-1
#define	DB_EID_INVALID		-2
#define	DB_EID_MASTER		-3

#define	DB_REP_DEFAULT_PRIORITY		100

/* Acknowledgement policies; 0 reserved as OOB. */
#define	DB_REPMGR_ACKS_ALL		1
#define	DB_REPMGR_ACKS_ALL_AVAILABLE	2
#define	DB_REPMGR_ACKS_ALL_PEERS	3
#define	DB_REPMGR_ACKS_NONE		4
#define	DB_REPMGR_ACKS_ONE		5
#define	DB_REPMGR_ACKS_ONE_PEER		6
#define	DB_REPMGR_ACKS_QUORUM		7

/* Replication timeout configuration values. */
#define	DB_REP_ACK_TIMEOUT		1	/* RepMgr acknowledgements. */
#define	DB_REP_CHECKPOINT_DELAY		2	/* Master checkpoint delay. */
#define	DB_REP_CONNECTION_RETRY		3	/* RepMgr connections. */
#define	DB_REP_ELECTION_RETRY		4	/* RepMgr elect retries. */
#define	DB_REP_ELECTION_TIMEOUT		5	/* Rep normal elections. */
#define	DB_REP_FULL_ELECTION_TIMEOUT	6	/* Rep full elections. */
#define	DB_REP_HEARTBEAT_MONITOR	7	/* RepMgr client HB monitor. */
#define	DB_REP_HEARTBEAT_SEND		8	/* RepMgr master send freq. */
#define	DB_REP_LEASE_TIMEOUT		9	/* Master leases. */

/*
 * Event notification types.  (Tcl testing interface currently assumes there are
 * no more than 32 of these.)
 */
#define	DB_EVENT_PANIC			 0
#define	DB_EVENT_REG_ALIVE		 1
#define	DB_EVENT_REG_PANIC		 2
#define	DB_EVENT_REP_CLIENT		 3
#define	DB_EVENT_REP_CONNECT_BROKEN	 4
#define	DB_EVENT_REP_CONNECT_ESTD	 5
#define	DB_EVENT_REP_CONNECT_TRY_FAILED	 6
#define	DB_EVENT_REP_DUPMASTER		 7
#define	DB_EVENT_REP_ELECTED		 8
#define	DB_EVENT_REP_ELECTION_FAILED	 9
#define	DB_EVENT_REP_INIT_DONE		10
#define	DB_EVENT_REP_JOIN_FAILURE	11
#define	DB_EVENT_REP_LOCAL_SITE_REMOVED	12
#define	DB_EVENT_REP_MASTER		13
#define	DB_EVENT_REP_MASTER_FAILURE	14
#define	DB_EVENT_REP_NEWMASTER		15
#define	DB_EVENT_REP_PERM_FAILED	16
#define	DB_EVENT_REP_SITE_ADDED		17
#define	DB_EVENT_REP_SITE_REMOVED	18
#define	DB_EVENT_REP_STARTUPDONE	19
#define	DB_EVENT_REP_WOULD_ROLLBACK	20	/* Undocumented; C API only. */
#define	DB_EVENT_WRITE_FAILED		21
#define	DB_EVENT_NO_SUCH_EVENT		 0xffffffff /* OOB sentinel value */

/* Replication Manager site status. */
struct __db_repmgr_site {
	int eid;
	char *host;
	u_int port;

#define	DB_REPMGR_CONNECTED	1
#define	DB_REPMGR_DISCONNECTED	2
	u_int32_t status;

#define	DB_REPMGR_ISPEER	0x01
	u_int32_t flags;
};

/* Replication statistics. */
struct __db_rep_stat { /* SHARED */
	/* !!!
	 * Many replication statistics fields cannot be protected by a mutex
	 * without an unacceptable performance penalty, since most message
	 * processing is done without the need to hold a region-wide lock.
	 * Fields whose comments end with a '+' may be updated without holding
	 * the replication or log mutexes (as appropriate), and thus may be
	 * off somewhat (or, on unreasonable architectures under unlucky
	 * circumstances, garbaged).
	 */
	u_int32_t st_startup_complete;	/* Site completed client sync-up. */
#ifndef __TEST_DB_NO_STATISTICS
	uintmax_t st_log_queued;	/* Log records currently queued.+ */
	u_int32_t st_status;		/* Current replication status. */
	DB_LSN st_next_lsn;		/* Next LSN to use or expect. */
	DB_LSN st_waiting_lsn;		/* LSN we're awaiting, if any. */
	DB_LSN st_max_perm_lsn;		/* Maximum permanent LSN. */
	db_pgno_t st_next_pg;		/* Next pg we expect. */
	db_pgno_t st_waiting_pg;	/* pg we're awaiting, if any. */

	u_int32_t st_dupmasters;	/* # of times a duplicate master
					   condition was detected.+ */
	db_ssize_t st_env_id;		/* Current environment ID. */
	u_int32_t st_env_priority;	/* Current environment priority. */
	uintmax_t st_bulk_fills;	/* Bulk buffer fills. */
	uintmax_t st_bulk_overflows;	/* Bulk buffer overflows. */
	uintmax_t st_bulk_records;	/* Bulk records stored. */
	uintmax_t st_bulk_transfers;	/* Transfers of bulk buffers. */
	uintmax_t st_client_rerequests;/* Number of forced rerequests. */
	uintmax_t st_client_svc_req;	/* Number of client service requests
					   received by this client. */
	uintmax_t st_client_svc_miss;	/* Number of client service requests
					   missing on this client. */
	u_int32_t st_gen;		/* Current generation number. */
	u_int32_t st_egen;		/* Current election gen number. */
	uintmax_t st_lease_chk;		/* Lease validity checks. */
	uintmax_t st_lease_chk_misses;	/* Lease checks invalid. */
	uintmax_t st_lease_chk_refresh;	/* Lease refresh attempts. */
	uintmax_t st_lease_sends;	/* Lease messages sent live. */

	uintmax_t st_log_duplicated;	/* Log records received multiply.+ */
	uintmax_t st_log_queued_max;	/* Max. log records queued at once.+ */
	uintmax_t st_log_queued_total;	/* Total # of log recs. ever queued.+ */
	uintmax_t st_log_records;	/* Log records received and put.+ */
	uintmax_t st_log_requested;	/* Log recs. missed and requested.+ */
	db_ssize_t st_master;		/* Env. ID of the current master. */
	uintmax_t st_master_changes;	/* # of times we've switched masters. */
	uintmax_t st_msgs_badgen;	/* Messages with a bad generation #.+ */
	uintmax_t st_msgs_processed;	/* Messages received and processed.+ */
	uintmax_t st_msgs_recover;	/* Messages ignored because this site
					   was a client in recovery.+ */
	uintmax_t st_msgs_send_failures;/* # of failed message sends.+ */
	uintmax_t st_msgs_sent;	/* # of successful message sends.+ */
	uintmax_t st_newsites;		/* # of NEWSITE msgs. received.+ */
	u_int32_t st_nsites;		/* Current number of sites we will
					   assume during elections. */
	uintmax_t st_nthrottles;	/* # of times we were throttled. */
	uintmax_t st_outdated;		/* # of times we detected and returned
					   an OUTDATED condition.+ */
	uintmax_t st_pg_duplicated;	/* Pages received multiply.+ */
	uintmax_t st_pg_records;	/* Pages received and stored.+ */
	uintmax_t st_pg_requested;	/* Pages missed and requested.+ */
	uintmax_t st_txns_applied;	/* # of transactions applied.+ */
	uintmax_t st_startsync_delayed;/* # of STARTSYNC msgs delayed.+ */

	/* Elections generally. */
	uintmax_t st_elections;	/* # of elections held.+ */
	uintmax_t st_elections_won;	/* # of elections won by this site.+ */

	/* Statistics about an in-progress election. */
	db_ssize_t st_election_cur_winner;	/* Current front-runner. */
	u_int32_t st_election_gen;	/* Election generation number. */
	u_int32_t st_election_datagen;	/* Election data generation number. */
	DB_LSN st_election_lsn;		/* Max. LSN of current winner. */
	u_int32_t st_election_nsites;	/* # of "registered voters". */
	u_int32_t st_election_nvotes;	/* # of "registered voters" needed. */
	u_int32_t st_election_priority;	/* Current election priority. */
	int32_t   st_election_status;	/* Current election status. */
	u_int32_t st_election_tiebreaker;/* Election tiebreaker value. */
	u_int32_t st_election_votes;	/* Votes received in this round. */
	u_int32_t st_election_sec;	/* Last election time seconds. */
	u_int32_t st_election_usec;	/* Last election time useconds. */
	u_int32_t st_max_lease_sec;	/* Maximum lease timestamp seconds. */
	u_int32_t st_max_lease_usec;	/* Maximum lease timestamp useconds. */

	/* Undocumented statistics only used by the test system. */
#ifdef	CONFIG_TEST
	u_int32_t st_filefail_cleanups;	/* # of FILE_FAIL cleanups done. */
#endif
#endif
};

/* Replication Manager statistics. */
struct __db_repmgr_stat { /* SHARED */
	uintmax_t st_perm_failed;	/* # of insufficiently ack'ed msgs. */
	uintmax_t st_msgs_queued;	/* # msgs queued for network delay. */
	uintmax_t st_msgs_dropped;	/* # msgs discarded due to excessive
					   queue length. */
	uintmax_t st_connection_drop;	/* Existing connections dropped. */
	uintmax_t st_connect_fail;	/* Failed new connection attempts. */
	uintmax_t st_elect_threads;	/* # of active election threads. */
	uintmax_t st_max_elect_threads;	/* Max concurrent e-threads ever. */
};

/* Replication Manager connection error. */
struct __db_repmgr_conn_err {
	int		eid;		/* Replication Environment ID. */
	int		error;		/* System networking error code. */
};

/*******************************************************
 * Sequences.
 *******************************************************/
/*
 * The storage record for a sequence.
 */
struct __db_seq_record {
	u_int32_t	seq_version;	/* Version size/number. */
	u_int32_t	flags;		/* DB_SEQ_XXX Flags. */
	db_seq_t	seq_value;	/* Current value. */
	db_seq_t	seq_max;	/* Max permitted. */
	db_seq_t	seq_min;	/* Min permitted. */
};

/*
 * Handle for a sequence object.
 */
struct __db_sequence {
	DB		*seq_dbp;	/* DB handle for this sequence. */
	db_mutex_t	mtx_seq;	/* Mutex if sequence is threaded. */
	DB_SEQ_RECORD	*seq_rp;	/* Pointer to current data. */
	DB_SEQ_RECORD	seq_record;	/* Data from DB_SEQUENCE. */
	int32_t		seq_cache_size; /* Number of values cached. */
	db_seq_t	seq_last_value;	/* Last value cached. */
	db_seq_t	seq_prev_value;	/* Last value returned. */
	DBT		seq_key;	/* DBT pointing to sequence key. */
	DBT		seq_data;	/* DBT pointing to seq_record. */

	/* API-private structure: used by C++ and Java. */
	void		*api_internal;

	/* DB_SEQUENCE PUBLIC HANDLE LIST BEGIN */
	int		(*close) __P((DB_SEQUENCE *, u_int32_t));
	int		(*get) __P((DB_SEQUENCE *,
			      DB_TXN *, int32_t, db_seq_t *, u_int32_t));
	int		(*get_cachesize) __P((DB_SEQUENCE *, int32_t *));
	int		(*get_db) __P((DB_SEQUENCE *, DB **));
	int		(*get_flags) __P((DB_SEQUENCE *, u_int32_t *));
	int		(*get_key) __P((DB_SEQUENCE *, DBT *));
	int		(*get_range) __P((DB_SEQUENCE *,
			     db_seq_t *, db_seq_t *));
	int		(*initial_value) __P((DB_SEQUENCE *, db_seq_t));
	int		(*open) __P((DB_SEQUENCE *,
			    DB_TXN *, DBT *, u_int32_t));
	int		(*remove) __P((DB_SEQUENCE *, DB_TXN *, u_int32_t));
	int		(*set_cachesize) __P((DB_SEQUENCE *, int32_t));
	int		(*set_flags) __P((DB_SEQUENCE *, u_int32_t));
	int		(*set_range) __P((DB_SEQUENCE *, db_seq_t, db_seq_t));
	int		(*stat) __P((DB_SEQUENCE *,
			    DB_SEQUENCE_STAT **, u_int32_t));
	int		(*stat_print) __P((DB_SEQUENCE *, u_int32_t));
	/* DB_SEQUENCE PUBLIC HANDLE LIST END */
};

struct __db_seq_stat { /* SHARED */
	uintmax_t st_wait;		/* Sequence lock granted w/o wait. */
	uintmax_t st_nowait;		/* Sequence lock granted after wait. */
	db_seq_t  st_current;		/* Current value in db. */
	db_seq_t  st_value;		/* Current cached value. */
	db_seq_t  st_last_value;	/* Last cached value. */
	db_seq_t  st_min;		/* Minimum value. */
	db_seq_t  st_max;		/* Maximum value. */
	int32_t   st_cache_size;	/* Cache size. */
	u_int32_t st_flags;		/* Flag value. */
};

/*******************************************************
 * Access methods.
 *******************************************************/
/*
 * Any new methods need to retain the original numbering.  The type
 * is written in a log record so must be maintained.
 */
typedef enum {
	DB_BTREE=1,
	DB_HASH=2,
	DB_HEAP=6,
	DB_RECNO=3,
	DB_QUEUE=4,
	DB_UNKNOWN=5			/* Figure it out on open. */
} DBTYPE;

#define	DB_RENAMEMAGIC	0x030800	/* File has been renamed. */

#define	DB_BTREEVERSION	9		/* Current btree version. */
#define	DB_BTREEOLDVER	8		/* Oldest btree version supported. */
#define	DB_BTREEMAGIC	0x053162

#define	DB_HASHVERSION	9		/* Current hash version. */
#define	DB_HASHOLDVER	7		/* Oldest hash version supported. */
#define	DB_HASHMAGIC	0x061561

#define	DB_HEAPVERSION	1		/* Current heap version. */
#define	DB_HEAPOLDVER	1		/* Oldest heap version supported. */
#define	DB_HEAPMAGIC	0x074582

#define	DB_QAMVERSION	4		/* Current queue version. */
#define	DB_QAMOLDVER	3		/* Oldest queue version supported. */
#define	DB_QAMMAGIC	0x042253

#define	DB_SEQUENCE_VERSION 2		/* Current sequence version. */
#define	DB_SEQUENCE_OLDVER  1		/* Oldest sequence version supported. */

/*
 * DB access method and cursor operation values.  Each value is an operation
 * code to which additional bit flags are added.
 */
#define	DB_AFTER		 1	/* Dbc.put */
#define	DB_APPEND		 2	/* Db.put */
#define	DB_BEFORE		 3	/* Dbc.put */
#define	DB_CONSUME		 4	/* Db.get */
#define	DB_CONSUME_WAIT		 5	/* Db.get */
#define	DB_CURRENT		 6	/* Dbc.get, Dbc.put, DbLogc.get */
#define	DB_FIRST		 7	/* Dbc.get, DbLogc->get */
#define	DB_GET_BOTH		 8	/* Db.get, Dbc.get */
#define	DB_GET_BOTHC		 9	/* Dbc.get (internal) */
#define	DB_GET_BOTH_RANGE	10	/* Db.get, Dbc.get */
#define	DB_GET_RECNO		11	/* Dbc.get */
#define	DB_JOIN_ITEM		12	/* Dbc.get; don't do primary lookup */
#define	DB_KEYFIRST		13	/* Dbc.put */
#define	DB_KEYLAST		14	/* Dbc.put */
#define	DB_LAST			15	/* Dbc.get, DbLogc->get */
#define	DB_NEXT			16	/* Dbc.get, DbLogc->get */
#define	DB_NEXT_DUP		17	/* Dbc.get */
#define	DB_NEXT_NODUP		18	/* Dbc.get */
#define	DB_NODUPDATA		19	/* Db.put, Dbc.put */
#define	DB_NOOVERWRITE		20	/* Db.put */
#define	DB_OVERWRITE_DUP	21	/* Dbc.put, Db.put; no DB_KEYEXIST */
#define	DB_POSITION		22	/* Dbc.dup */
#define	DB_PREV			23	/* Dbc.get, DbLogc->get */
#define	DB_PREV_DUP		24	/* Dbc.get */
#define	DB_PREV_NODUP		25	/* Dbc.get */
#define	DB_SET			26	/* Dbc.get, DbLogc->get */
#define	DB_SET_RANGE		27	/* Dbc.get */
#define	DB_SET_RECNO		28	/* Db.get, Dbc.get */
#define	DB_UPDATE_SECONDARY	29	/* Dbc.get, Dbc.del (internal) */
#define	DB_SET_LTE		30	/* Dbc.get (internal) */
#define	DB_GET_BOTH_LTE		31	/* Dbc.get (internal) */

/* This has to change when the max opcode hits 255. */
#define	DB_OPFLAGS_MASK	0x000000ff	/* Mask for operations flags. */

/*
 * DB (user visible) error return codes.
 *
 * !!!
 * We don't want our error returns to conflict with other packages where
 * possible, so pick a base error value that's hopefully not common.  We
 * document that we own the error name space from -30,800 to -30,999.
 */
/* DB (public) error return codes. */
#define	DB_BUFFER_SMALL		(-30999)/* User memory too small for return. */
#define	DB_DONOTINDEX		(-30998)/* "Null" return from 2ndary callbk. */
#define	DB_FOREIGN_CONFLICT	(-30997)/* A foreign db constraint triggered. */
#define	DB_HEAP_FULL		(-30996)/* No free space in a heap file. */
#define	DB_KEYEMPTY		(-30995)/* Key/data deleted or never created. */
#define	DB_KEYEXIST		(-30994)/* The key/data pair already exists. */
#define	DB_LOCK_DEADLOCK	(-30993)/* Deadlock. */
#define	DB_LOCK_NOTGRANTED	(-30992)/* Lock unavailable. */
#define	DB_LOG_BUFFER_FULL	(-30991)/* In-memory log buffer full. */
#define	DB_LOG_VERIFY_BAD	(-30990)/* Log verification failed. */
#define	DB_NOSERVER		(-30989)/* Server panic return. */
#define	DB_NOTFOUND		(-30988)/* Key/data pair not found (EOF). */
#define	DB_OLD_VERSION		(-30987)/* Out-of-date version. */
#define	DB_PAGE_NOTFOUND	(-30986)/* Requested page not found. */
#define	DB_REP_DUPMASTER	(-30985)/* There are two masters. */
#define	DB_REP_HANDLE_DEAD	(-30984)/* Rolled back a commit. */
#define	DB_REP_HOLDELECTION	(-30983)/* Time to hold an election. */
#define	DB_REP_IGNORE		(-30982)/* This msg should be ignored.*/
#define	DB_REP_ISPERM		(-30981)/* Cached not written perm written.*/
#define	DB_REP_JOIN_FAILURE	(-30980)/* Unable to join replication group. */
#define	DB_REP_LEASE_EXPIRED	(-30979)/* Master lease has expired. */
#define	DB_REP_LOCKOUT		(-30978)/* API/Replication lockout now. */
#define	DB_REP_NEWSITE		(-30977)/* New site entered system. */
#define	DB_REP_NOTPERM		(-30976)/* Permanent log record not written. */
#define	DB_REP_UNAVAIL		(-30975)/* Site cannot currently be reached. */
#define	DB_REP_WOULDROLLBACK	(-30974)/* UNDOC: rollback inhibited by app. */
#define	DB_RUNRECOVERY		(-30973)/* Panic return. */
#define	DB_SECONDARY_BAD	(-30972)/* Secondary index corrupt. */
#define	DB_TIMEOUT		(-30971)/* Timed out on read consistency. */
#define	DB_VERIFY_BAD		(-30970)/* Verify failed; bad format. */
#define	DB_VERSION_MISMATCH	(-30969)/* Environment version mismatch. */

/* DB (private) error return codes. */
#define	DB_ALREADY_ABORTED	(-30899)
#define	DB_CHKSUM_FAIL		(-30898)/* Checksum failed. */
#define	DB_DELETED		(-30897)/* Recovery file marked deleted. */
#define	DB_EVENT_NOT_HANDLED	(-30896)/* Forward event to application. */
#define	DB_NEEDSPLIT		(-30895)/* Page needs to be split. */
#define	DB_REP_BULKOVF		(-30894)/* Rep bulk buffer overflow. */
#define	DB_REP_LOGREADY		(-30893)/* Rep log ready for recovery. */
#define	DB_REP_NEWMASTER	(-30892)/* We have learned of a new master. */
#define	DB_REP_PAGEDONE		(-30891)/* This page was already done. */
#define	DB_SURPRISE_KID		(-30890)/* Child commit where parent
					   didn't know it was a parent. */
#define	DB_SWAPBYTES		(-30889)/* Database needs byte swapping. */
#define	DB_TXN_CKP		(-30888)/* Encountered ckp record in log. */
#define	DB_VERIFY_FATAL		(-30887)/* DB->verify cannot proceed. */

/* Database handle. */
struct __db {
	/*******************************************************
	 * Public: owned by the application.
	 *******************************************************/
	u_int32_t pgsize;		/* Database logical page size. */
	DB_CACHE_PRIORITY priority;	/* Database priority in cache. */

					/* Callbacks. */
	int (*db_append_recno) __P((DB *, DBT *, db_recno_t));
	void (*db_feedback) __P((DB *, int, int));
	int (*dup_compare) __P((DB *, const DBT *, const DBT *));

	void	*app_private;		/* Application-private handle. */

	/*******************************************************
	 * Private: owned by DB.
	 *******************************************************/
	DB_ENV	*dbenv;			/* Backing public environment. */
	ENV	*env;			/* Backing private environment. */

	DBTYPE	 type;			/* DB access method type. */

	DB_MPOOLFILE *mpf;		/* Backing buffer pool. */

	db_mutex_t mutex;		/* Synchronization for free threading */

	char *fname, *dname;		/* File/database passed to DB->open. */
	const char *dirname;		/* Directory of DB file. */
	u_int32_t open_flags;		/* Flags passed to DB->open. */

	u_int8_t fileid[DB_FILE_ID_LEN];/* File's unique ID for locking. */

	u_int32_t adj_fileid;		/* File's unique ID for curs. adj. */

#define	DB_LOGFILEID_INVALID	-1
	FNAME *log_filename;		/* File's naming info for logging. */

	db_pgno_t meta_pgno;		/* Meta page number */
	DB_LOCKER *locker;		/* Locker for handle locking. */
	DB_LOCKER *cur_locker;		/* Current handle lock holder. */
	DB_TXN *cur_txn;		/* Opening transaction. */
	DB_LOCKER *associate_locker;	/* Locker for DB->associate call. */
	DB_LOCK	 handle_lock;		/* Lock held on this handle. */

	time_t	 timestamp;		/* Handle timestamp for replication. */
	u_int32_t fid_gen;		/* Rep generation number for fids. */

	/*
	 * Returned data memory for DB->get() and friends.
	 */
	DBT	 my_rskey;		/* Secondary key. */
	DBT	 my_rkey;		/* [Primary] key. */
	DBT	 my_rdata;		/* Data. */

	/*
	 * !!!
	 * Some applications use DB but implement their own locking outside of
	 * DB.  If they're using fcntl(2) locking on the underlying database
	 * file, and we open and close a file descriptor for that file, we will
	 * discard their locks.  The DB_FCNTL_LOCKING flag to DB->open is an
	 * undocumented interface to support this usage which leaves any file
	 * descriptors we open until DB->close.  This will only work with the
	 * DB->open interface and simple caches, e.g., creating a transaction
	 * thread may open/close file descriptors this flag doesn't protect.
	 * Locking with fcntl(2) on a file that you don't own is a very, very
	 * unsafe thing to do.  'Nuff said.
	 */
	DB_FH	*saved_open_fhp;	/* Saved file handle. */

	/*
	 * Linked list of DBP's, linked from the ENV, used to keep track
	 * of all open db handles for cursor adjustment.
	 *
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * TAILQ_ENTRY(__db) dblistlinks;
	 */
	struct {
		struct __db *tqe_next;
		struct __db **tqe_prev;
	} dblistlinks;

	/*
	 * Cursor queues.
	 *
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * TAILQ_HEAD(__cq_fq, __dbc) free_queue;
	 * TAILQ_HEAD(__cq_aq, __dbc) active_queue;
	 * TAILQ_HEAD(__cq_jq, __dbc) join_queue;
	 */
	struct __cq_fq {
		struct __dbc *tqh_first;
		struct __dbc **tqh_last;
	} free_queue;
	struct __cq_aq {
		struct __dbc *tqh_first;
		struct __dbc **tqh_last;
	} active_queue;
	struct __cq_jq {
		struct __dbc *tqh_first;
		struct __dbc **tqh_last;
	} join_queue;

	/*
	 * Secondary index support.
	 *
	 * Linked list of secondary indices -- set in the primary.
	 *
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * LIST_HEAD(s_secondaries, __db);
	 */
	struct {
		struct __db *lh_first;
	} s_secondaries;

	/*
	 * List entries for secondaries, and reference count of how many
	 * threads are updating this secondary (see Dbc.put).
	 *
	 * !!!
	 * Note that these are synchronized by the primary's mutex, but
	 * filled in in the secondaries.
	 *
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * LIST_ENTRY(__db) s_links;
	 */
	struct {
		struct __db *le_next;
		struct __db **le_prev;
	} s_links;
	u_int32_t s_refcnt;

	/* Secondary callback and free functions -- set in the secondary. */
	int	(*s_callback) __P((DB *, const DBT *, const DBT *, DBT *));

	/* Reference to primary -- set in the secondary. */
	DB	*s_primary;

#define	DB_ASSOC_IMMUTABLE_KEY    0x00000001 /* Secondary key is immutable. */
#define	DB_ASSOC_CREATE    0x00000002 /* Secondary db populated on open. */

	/* Flags passed to associate -- set in the secondary. */
	u_int32_t s_assoc_flags;

	/*
	 * Foreign key support.
	 *
	 * Linked list of primary dbs -- set in the foreign db
	 *
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * LIST_HEAD(f_primaries, __db);
	 */
	struct {
		struct __db_foreign_info *lh_first;
	} f_primaries;

	/*
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * TAILQ_ENTRY(__db) felink;
	 *
	 * Links in a list of DBs involved in file extension
	 * during a transaction.  These are to be used only while the
	 * metadata is locked.
	 */
	struct {
		struct __db *tqe_next;
		struct __db **tqe_prev;
	} felink;

	/* Reference to foreign -- set in the secondary. */
	DB      *s_foreign;

	/* API-private structure: used by DB 1.85, C++, Java, Perl and Tcl */
	void	*api_internal;

	/* Subsystem-private structure. */
	void	*bt_internal;		/* Btree/Recno access method. */
	void	*h_internal;		/* Hash access method. */
	void	*heap_internal;		/* Heap access method. */
	void	*p_internal;		/* Partition informaiton. */
	void	*q_internal;		/* Queue access method. */

	/* DB PUBLIC HANDLE LIST BEGIN */
	int  (*associate) __P((DB *, DB_TXN *, DB *,
		int (*)(DB *, const DBT *, const DBT *, DBT *), u_int32_t));
	int  (*associate_foreign) __P((DB *, DB *,
		int (*)(DB *, const DBT *, DBT *, const DBT *, int *),
		u_int32_t));
	int  (*close) __P((DB *, u_int32_t));
	int  (*compact) __P((DB *,
		DB_TXN *, DBT *, DBT *, DB_COMPACT *, u_int32_t, DBT *));
	int  (*cursor) __P((DB *, DB_TXN *, DBC **, u_int32_t));
	int  (*del) __P((DB *, DB_TXN *, DBT *, u_int32_t));
	void (*err) __P((DB *, int, const char *, ...));
	void (*errx) __P((DB *, const char *, ...));
	int  (*exists) __P((DB *, DB_TXN *, DBT *, u_int32_t));
	int  (*fd) __P((DB *, int *));
	int  (*get) __P((DB *, DB_TXN *, DBT *, DBT *, u_int32_t));
	int  (*get_alloc) __P((DB *, void *(**)(size_t),
		void *(**)(void *, size_t), void (**)(void *)));
	int  (*get_append_recno) __P((DB *, int (**)(DB *, DBT *, db_recno_t)));
	int  (*get_assoc_flags) __P((DB *, u_int32_t *));
	int  (*get_bt_compare)
		__P((DB *, int (**)(DB *, const DBT *, const DBT *)));
	int  (*get_bt_compress) __P((DB *,
		int (**)(DB *,
		const DBT *, const DBT *, const DBT *, const DBT *, DBT *),
		int (**)(DB *, const DBT *, const DBT *, DBT *, DBT *, DBT *)));
	int  (*get_bt_minkey) __P((DB *, u_int32_t *));
	int  (*get_bt_prefix)
		__P((DB *, size_t (**)(DB *, const DBT *, const DBT *)));
	int  (*get_byteswapped) __P((DB *, int *));
	int  (*get_cachesize) __P((DB *, u_int32_t *, u_int32_t *, int *));
	int  (*get_create_dir) __P((DB *, const char **));
	int  (*get_dbname) __P((DB *, const char **, const char **));
	int  (*get_dup_compare)
		__P((DB *, int (**)(DB *, const DBT *, const DBT *)));
	int  (*get_encrypt_flags) __P((DB *, u_int32_t *));
	DB_ENV *(*get_env) __P((DB *));
	void (*get_errcall) __P((DB *,
		void (**)(const DB_ENV *, const char *, const char *)));
	void (*get_errfile) __P((DB *, FILE **));
	void (*get_errpfx) __P((DB *, const char **));
	int  (*get_feedback) __P((DB *, void (**)(DB *, int, int)));
	int  (*get_flags) __P((DB *, u_int32_t *));
	int  (*get_h_compare)
		__P((DB *, int (**)(DB *, const DBT *, const DBT *)));
	int  (*get_h_ffactor) __P((DB *, u_int32_t *));
	int  (*get_h_hash)
		__P((DB *, u_int32_t (**)(DB *, const void *, u_int32_t)));
	int  (*get_h_nelem) __P((DB *, u_int32_t *));
	int  (*get_heapsize) __P((DB *, u_int32_t *, u_int32_t *));
	int  (*get_heap_regionsize) __P((DB *, u_int32_t *));
	int  (*get_lk_exclusive) __P((DB *, int *, int *));
	int  (*get_lorder) __P((DB *, int *));
	DB_MPOOLFILE *(*get_mpf) __P((DB *));
	void (*get_msgcall) __P((DB *,
	    void (**)(const DB_ENV *, const char *)));
	void (*get_msgfile) __P((DB *, FILE **));
	int  (*get_multiple) __P((DB *));
	int  (*get_open_flags) __P((DB *, u_int32_t *));
	int  (*get_pagesize) __P((DB *, u_int32_t *));
	int  (*get_partition_callback) __P((DB *,
		u_int32_t *, u_int32_t (**)(DB *, DBT *key)));
	int  (*get_partition_dirs) __P((DB *, const char ***));
	int  (*get_partition_keys) __P((DB *, u_int32_t *, DBT **));
	int  (*get_priority) __P((DB *, DB_CACHE_PRIORITY *));
	int  (*get_q_extentsize) __P((DB *, u_int32_t *));
	int  (*get_re_delim) __P((DB *, int *));
	int  (*get_re_len) __P((DB *, u_int32_t *));
	int  (*get_re_pad) __P((DB *, int *));
	int  (*get_re_source) __P((DB *, const char **));
	int  (*get_transactional) __P((DB *));
	int  (*get_type) __P((DB *, DBTYPE *));
	int  (*join) __P((DB *, DBC **, DBC **, u_int32_t));
	int  (*key_range)
		__P((DB *, DB_TXN *, DBT *, DB_KEY_RANGE *, u_int32_t));
	int  (*open) __P((DB *,
		DB_TXN *, const char *, const char *, DBTYPE, u_int32_t, int));
	int  (*pget) __P((DB *, DB_TXN *, DBT *, DBT *, DBT *, u_int32_t));
	int  (*put) __P((DB *, DB_TXN *, DBT *, DBT *, u_int32_t));
	int  (*remove) __P((DB *, const char *, const char *, u_int32_t));
	int  (*rename) __P((DB *,
		const char *, const char *, const char *, u_int32_t));
	int  (*set_alloc) __P((DB *, void *(*)(size_t),
		void *(*)(void *, size_t), void (*)(void *)));
	int  (*set_append_recno) __P((DB *, int (*)(DB *, DBT *, db_recno_t)));
	int  (*set_bt_compare)
		__P((DB *, int (*)(DB *, const DBT *, const DBT *)));
	int  (*set_bt_compress) __P((DB *,
		int (*)(DB *, const DBT *, const DBT *, const DBT *, const DBT *, DBT *),
		int (*)(DB *, const DBT *, const DBT *, DBT *, DBT *, DBT *)));
	int  (*set_bt_minkey) __P((DB *, u_int32_t));
	int  (*set_bt_prefix)
		__P((DB *, size_t (*)(DB *, const DBT *, const DBT *)));
	int  (*set_cachesize) __P((DB *, u_int32_t, u_int32_t, int));
	int  (*set_create_dir) __P((DB *, const char *));
	int  (*set_dup_compare)
		__P((DB *, int (*)(DB *, const DBT *, const DBT *)));
	int  (*set_encrypt) __P((DB *, const char *, u_int32_t));
	void (*set_errcall) __P((DB *,
		void (*)(const DB_ENV *, const char *, const char *)));
	void (*set_errfile) __P((DB *, FILE *));
	void (*set_errpfx) __P((DB *, const char *));
	int  (*set_feedback) __P((DB *, void (*)(DB *, int, int)));
	int  (*set_flags) __P((DB *, u_int32_t));
	int  (*set_h_compare)
		__P((DB *, int (*)(DB *, const DBT *, const DBT *)));
	int  (*set_h_ffactor) __P((DB *, u_int32_t));
	int  (*set_h_hash)
		__P((DB *, u_int32_t (*)(DB *, const void *, u_int32_t)));
	int  (*set_h_nelem) __P((DB *, u_int32_t));
	int  (*set_heapsize) __P((DB *, u_int32_t, u_int32_t, u_int32_t));
	int  (*set_heap_regionsize) __P((DB *, u_int32_t));
	int  (*set_lk_exclusive) __P((DB *, int));
	int  (*set_lorder) __P((DB *, int));
	void (*set_msgcall) __P((DB *, void (*)(const DB_ENV *, const char *)));
	void (*set_msgfile) __P((DB *, FILE *));
	int  (*set_pagesize) __P((DB *, u_int32_t));
	int  (*set_paniccall) __P((DB *, void (*)(DB_ENV *, int)));
	int  (*set_partition) __P((DB *,
		u_int32_t, DBT *, u_int32_t (*)(DB *, DBT *key)));
	int  (*set_partition_dirs) __P((DB *, const char **));
	int  (*set_priority) __P((DB *, DB_CACHE_PRIORITY));
	int  (*set_q_extentsize) __P((DB *, u_int32_t));
	int  (*set_re_delim) __P((DB *, int));
	int  (*set_re_len) __P((DB *, u_int32_t));
	int  (*set_re_pad) __P((DB *, int));
	int  (*set_re_source) __P((DB *, const char *));
	int  (*sort_multiple) __P((DB *, DBT *, DBT *, u_int32_t));
	int  (*stat) __P((DB *, DB_TXN *, void *, u_int32_t));
	int  (*stat_print) __P((DB *, u_int32_t));
	int  (*sync) __P((DB *, u_int32_t));
	int  (*truncate) __P((DB *, DB_TXN *, u_int32_t *, u_int32_t));
	int  (*upgrade) __P((DB *, const char *, u_int32_t));
	int  (*verify)
		__P((DB *, const char *, const char *, FILE *, u_int32_t));
	/* DB PUBLIC HANDLE LIST END */

	/* DB PRIVATE HANDLE LIST BEGIN */
	int  (*dump) __P((DB *, const char *,
		int (*)(void *, const void *), void *, int, int));
	int  (*db_am_remove) __P((DB *, DB_THREAD_INFO *,
		DB_TXN *, const char *, const char *, u_int32_t));
	int  (*db_am_rename) __P((DB *, DB_THREAD_INFO *,
		DB_TXN *, const char *, const char *, const char *));
	/* DB PRIVATE HANDLE LIST END */

	/*
	 * Never called; these are a place to save function pointers
	 * so that we can undo an associate.
	 */
	int  (*stored_get) __P((DB *, DB_TXN *, DBT *, DBT *, u_int32_t));
	int  (*stored_close) __P((DB *, u_int32_t));

	/* Alternative handle close function, used by C++ API. */
	int  (*alt_close) __P((DB *, u_int32_t));

#define	DB_OK_BTREE	0x01
#define	DB_OK_HASH	0x02
#define	DB_OK_HEAP	0x04
#define	DB_OK_QUEUE	0x08
#define	DB_OK_RECNO	0x10
	u_int32_t	am_ok;		/* Legal AM choices. */

	/*
	 * This field really ought to be an AM_FLAG, but we have
	 * have run out of bits.  If/when we decide to split up
	 * the flags, we can incorporate it.
	 */
	int	 preserve_fid;		/* Do not free fileid on close. */

#define	DB_AM_CHKSUM		0x00000001 /* Checksumming */
#define	DB_AM_COMPENSATE	0x00000002 /* Created by compensating txn */
#define	DB_AM_COMPRESS		0x00000004 /* Compressed BTree */
#define	DB_AM_CREATED		0x00000008 /* Database was created upon open */
#define	DB_AM_CREATED_MSTR	0x00000010 /* Encompassing file was created */
#define	DB_AM_DBM_ERROR		0x00000020 /* Error in DBM/NDBM database */
#define	DB_AM_DELIMITER		0x00000040 /* Variable length delimiter set */
#define	DB_AM_DISCARD		0x00000080 /* Discard any cached pages */
#define	DB_AM_DUP		0x00000100 /* DB_DUP */
#define	DB_AM_DUPSORT		0x00000200 /* DB_DUPSORT */
#define	DB_AM_ENCRYPT		0x00000400 /* Encryption */
#define	DB_AM_FIXEDLEN		0x00000800 /* Fixed-length records */
#define	DB_AM_INMEM		0x00001000 /* In-memory; no sync on close */
#define	DB_AM_INORDER		0x00002000 /* DB_INORDER */
#define	DB_AM_IN_RENAME		0x00004000 /* File is being renamed */
#define	DB_AM_NOT_DURABLE	0x00008000 /* Do not log changes */
#define	DB_AM_OPEN_CALLED	0x00010000 /* DB->open called */
#define	DB_AM_PAD		0x00020000 /* Fixed-length record pad */
#define	DB_AM_PARTDB		0x00040000 /* Handle for a database partition */
#define	DB_AM_PGDEF		0x00080000 /* Page size was defaulted */
#define	DB_AM_RDONLY		0x00100000 /* Database is readonly */
#define	DB_AM_READ_UNCOMMITTED	0x00200000 /* Support degree 1 isolation */
#define	DB_AM_RECNUM		0x00400000 /* DB_RECNUM */
#define	DB_AM_RECOVER		0x00800000 /* DB opened by recovery routine */
#define	DB_AM_RENUMBER		0x01000000 /* DB_RENUMBER */
#define	DB_AM_REVSPLITOFF	0x02000000 /* DB_REVSPLITOFF */
#define	DB_AM_SECONDARY		0x04000000 /* Database is a secondary index */
#define	DB_AM_SNAPSHOT		0x08000000 /* DB_SNAPSHOT */
#define	DB_AM_SUBDB		0x10000000 /* Subdatabases supported */
#define	DB_AM_SWAP		0x20000000 /* Pages need to be byte-swapped */
#define	DB_AM_TXN		0x40000000 /* Opened in a transaction */
#define	DB_AM_VERIFYING		0x80000000 /* DB handle is in the verifier */
	u_int32_t orig_flags;		   /* Flags at  open, for refresh */
	u_int32_t flags;

#define DB2_AM_EXCL		0x00000001 /* Exclusively lock the handle */ 
#define DB2_AM_INTEXCL		0x00000002 /* Internal exclusive lock. */
#define DB2_AM_NOWAIT		0x00000004 /* Do not wait for handle lock */ 
	u_int32_t orig_flags2;		   /* Second flags word; for refresh */ 
	u_int32_t flags2;		   /* Second flags word */
};

/*
 * Macros for bulk operations.  These are only intended for the C API.
 * For C++, use DbMultiple*Iterator or DbMultiple*Builder.
 *
 * Bulk operations store multiple entries into a single DBT structure. The
 * following macros assist with creating and reading these Multiple DBTs.
 *
 * The basic layout for single data items is:
 *
 * -------------------------------------------------------------------------
 * | data1 | ... | dataN | ..... |-1 | dNLen | dNOff | ... | d1Len | d1Off |
 * -------------------------------------------------------------------------
 *
 * For the DB_MULTIPLE_KEY* macros, the items are in key/data pairs, so data1
 * would be a key, and data2 its corresponding value (N is always even).
 *
 * For the DB_MULTIPLE_RECNO* macros, the record number is stored along with
 * the len/off pair in the "header" section, and the list is zero terminated
 * (since -1 is a valid record number):
 *
 * --------------------------------------------------------------------------
 * | d1 |..| dN |..| 0 | dNLen | dNOff | recnoN |..| d1Len | d1Off | recno1 |
 * --------------------------------------------------------------------------
 */
#define	DB_MULTIPLE_INIT(pointer, dbt)					\
	(pointer = (u_int8_t *)(dbt)->data +				\
	    (dbt)->ulen - sizeof(u_int32_t))

#define	DB_MULTIPLE_NEXT(pointer, dbt, retdata, retdlen)		\
	do {								\
		u_int32_t *__p = (u_int32_t *)(pointer);		\
		if (*__p == (u_int32_t)-1) {				\
			retdata = NULL;					\
			pointer = NULL;					\
			break;						\
		}							\
		retdata = (u_int8_t *)(dbt)->data + *__p--;		\
		retdlen = *__p--;					\
		pointer = __p;						\
		if (retdlen == 0 && retdata == (u_int8_t *)(dbt)->data)	\
			retdata = NULL;					\
	} while (0)

#define	DB_MULTIPLE_KEY_NEXT(pointer, dbt, retkey, retklen, retdata, retdlen) \
	do {								\
		u_int32_t *__p = (u_int32_t *)(pointer);		\
		if (*__p == (u_int32_t)-1) {				\
			retdata = NULL;					\
			retkey = NULL;					\
			pointer = NULL;					\
			break;						\
		}							\
		retkey = (u_int8_t *)(dbt)->data + *__p--;		\
		retklen = *__p--;					\
		retdata = (u_int8_t *)(dbt)->data + *__p--;		\
		retdlen = *__p--;					\
		pointer = __p;						\
	} while (0)

#define	DB_MULTIPLE_RECNO_NEXT(pointer, dbt, recno, retdata, retdlen)   \
	do {								\
		u_int32_t *__p = (u_int32_t *)(pointer);		\
		if (*__p == (u_int32_t)0) {				\
			recno = 0;					\
			retdata = NULL;					\
			pointer = NULL;					\
