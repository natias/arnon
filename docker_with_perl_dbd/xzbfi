PERL_CALLCONV void	Perl_opslab_free_nopad(pTHX_ OPSLAB *slab);
#define PERL_ARGS_ASSERT_OPSLAB_FREE_NOPAD	\
	assert(slab)
PERL_CALLCONV void	Perl_parser_free_nexttoke_ops(pTHX_ yy_parser *parser, OPSLAB *slab);
#define PERL_ARGS_ASSERT_PARSER_FREE_NEXTTOKE_OPS	\
	assert(parser); assert(slab)
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE bool	S_should_warn_nl(const char *pv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SHOULD_WARN_NL	\
	assert(pv)
#endif

#  if defined(PERL_DEBUG_READONLY_OPS)
PERL_CALLCONV void	Perl_Slab_to_ro(pTHX_ OPSLAB *slab);
#define PERL_ARGS_ASSERT_SLAB_TO_RO	\
	assert(slab)
PERL_CALLCONV void	Perl_Slab_to_rw(pTHX_ OPSLAB *const slab);
#define PERL_ARGS_ASSERT_SLAB_TO_RW	\
	assert(slab)
#  endif
#endif
#if defined(PERL_CORE) || defined (PERL_EXT)
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE bool	Perl_is_utf8_non_invariant_string(const U8* const s, STRLEN len)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_UTF8_NON_INVARIANT_STRING	\
	assert(s)
#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE STRLEN	S_sv_or_pv_pos_u2b(pTHX_ SV *sv, const char *pv, STRLEN pos, STRLEN *lenp);
#define PERL_ARGS_ASSERT_SV_OR_PV_POS_U2B	\
	assert(sv); assert(pv)
#endif
#endif
#if defined(PERL_CORE) || defined(PERL_EXT)
PERL_CALLCONV bool	Perl_isSCRIPT_RUN(pTHX_ const U8 *s, const U8 *send, const bool utf8_target)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_ISSCRIPT_RUN	\
	assert(s); assert(send)

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE Size_t	S_variant_under_utf8_count(const U8* const s, const U8* const e)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_VARIANT_UNDER_UTF8_COUNT	\
	assert(s); assert(e)
#endif

#endif
#if defined(PERL_CR_FILTER)
#  if defined(PERL_IN_TOKE_C)
STATIC I32	S_cr_textfilter(pTHX_ int idx, SV *sv, int maxlen);
#define PERL_ARGS_ASSERT_CR_TEXTFILTER
STATIC void	S_strip_return(pTHX_ SV *sv);
#define PERL_ARGS_ASSERT_STRIP_RETURN	\
	assert(sv)
#  endif
#endif
#if defined(PERL_DEBUG_READONLY_COW)
PERL_CALLCONV void	Perl_sv_buf_to_ro(pTHX_ SV *sv);
#define PERL_ARGS_ASSERT_SV_BUF_TO_RO	\
	assert(sv)
#  if defined(PERL_IN_SV_C)
STATIC void	S_sv_buf_to_rw(pTHX_ SV *sv);
#define PERL_ARGS_ASSERT_SV_BUF_TO_RW	\
	assert(sv)
#  endif
#endif
#if defined(PERL_DEBUG_READONLY_OPS)
PERL_CALLCONV PADOFFSET	Perl_op_refcnt_dec(pTHX_ OP *o);
#define PERL_ARGS_ASSERT_OP_REFCNT_DEC	\
	assert(o)
PERL_CALLCONV OP *	Perl_op_refcnt_inc(pTHX_ OP *o);
#define PERL_ARGS_ASSERT_OP_REFCNT_INC
#endif
#if defined(PERL_DEFAULT_DO_EXEC3_IMPLEMENTATION)
PERL_CALLCONV bool	Perl_do_exec(pTHX_ const char* cmd);
#define PERL_ARGS_ASSERT_DO_EXEC	\
	assert(cmd)
#endif
#if defined(PERL_DONT_CREATE_GVSV)
#ifndef NO_MATHOMS
PERL_CALLCONV GV*	Perl_gv_SVadd(pTHX_ GV *gv);
#define PERL_ARGS_ASSERT_GV_SVADD
#endif
#endif
#if defined(PERL_IMPLICIT_SYS)
PERL_CALLCONV PerlInterpreter*	perl_alloc_using(struct IPerlMem *ipM, struct IPerlMem *ipMS, struct IPerlMem *ipMP, struct IPerlEnv *ipE, struct IPerlStdIO *ipStd, struct IPerlLIO *ipLIO, struct IPerlDir *ipD, struct IPerlSock *ipS, struct IPerlProc *ipP);
#define PERL_ARGS_ASSERT_PERL_ALLOC_USING	\
	assert(ipM); assert(ipMS); assert(ipMP); assert(ipE); assert(ipStd); assert(ipLIO); assert(ipD); assert(ipS); assert(ipP)
#  if defined(USE_ITHREADS)
PERL_CALLCONV PerlInterpreter*	perl_clone_using(PerlInterpreter *proto_perl, UV flags, struct IPerlMem* ipM, struct IPerlMem* ipMS, struct IPerlMem* ipMP, struct IPerlEnv* ipE, struct IPerlStdIO* ipStd, struct IPerlLIO* ipLIO, struct IPerlDir* ipD, struct IPerlSock* ipS, struct IPerlProc* ipP);
#define PERL_ARGS_ASSERT_PERL_CLONE_USING	\
	assert(proto_perl); assert(ipM); assert(ipMS); assert(ipMP); assert(ipE); assert(ipStd); assert(ipLIO); assert(ipD); assert(ipS); assert(ipP)
#  endif
#endif
#if defined(PERL_IN_AV_C)
STATIC MAGIC*	S_get_aux_mg(pTHX_ AV *av);
#define PERL_ARGS_ASSERT_GET_AUX_MG	\
	assert(av)
#endif
#if defined(PERL_IN_DEB_C)
STATIC void	S_deb_stack_n(pTHX_ SV** stack_base, I32 stack_min, I32 stack_max, I32 mark_min, I32 mark_max);
#define PERL_ARGS_ASSERT_DEB_STACK_N	\
	assert(stack_base)
#endif
#if defined(PERL_IN_DOIO_C)
STATIC bool	S_argvout_final(pTHX_ MAGIC *mg, IO *io, bool not_implicit);
#define PERL_ARGS_ASSERT_ARGVOUT_FINAL	\
	assert(mg); assert(io)
STATIC void	S_exec_failed(pTHX_ const char *cmd, int fd, int do_report);
#define PERL_ARGS_ASSERT_EXEC_FAILED	\
	assert(cmd)
STATIC bool	S_ingroup(pTHX_ Gid_t testgid, bool effective)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_INGROUP

STATIC bool	S_openn_cleanup(pTHX_ GV *gv, IO *io, PerlIO *fp, char *mode, const char *oname, PerlIO *saveifp, PerlIO *saveofp, int savefd, char savetype, int writing, bool was_fdopen, const char *type, Stat_t *statbufp);
#define PERL_ARGS_ASSERT_OPENN_CLEANUP	\
	assert(gv); assert(io); assert(mode); assert(oname)
STATIC IO *	S_openn_setup(pTHX_ GV *gv, char *mode, PerlIO **saveifp, PerlIO **saveofp, int *savefd, char *savetype);
#define PERL_ARGS_ASSERT_OPENN_SETUP	\
	assert(gv); assert(mode); assert(saveifp); assert(saveofp); assert(savefd); assert(savetype)
#endif
#if defined(PERL_IN_DOOP_C)
STATIC Size_t	S_do_trans_complex(pTHX_ SV * const sv, const OPtrans_map * const tbl)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DO_TRANS_COMPLEX	\
	assert(sv); assert(tbl)

STATIC Size_t	S_do_trans_count(pTHX_ SV * const sv, const OPtrans_map * const tbl)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DO_TRANS_COUNT	\
	assert(sv); assert(tbl)

STATIC Size_t	S_do_trans_count_invmap(pTHX_ SV * const sv, AV * const map)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DO_TRANS_COUNT_INVMAP	\
	assert(sv); assert(map)

STATIC Size_t	S_do_trans_invmap(pTHX_ SV * const sv, AV * const map)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DO_TRANS_INVMAP	\
	assert(sv); assert(map)

STATIC Size_t	S_do_trans_simple(pTHX_ SV * const sv, const OPtrans_map * const tbl)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DO_TRANS_SIMPLE	\
	assert(sv); assert(tbl)

#endif
#if defined(PERL_IN_DUMP_C)
STATIC CV*	S_deb_curcv(pTHX_ I32 ix);
#define PERL_ARGS_ASSERT_DEB_CURCV
STATIC void	S_debprof(pTHX_ const OP *o);
#define PERL_ARGS_ASSERT_DEBPROF	\
	assert(o)
STATIC SV*	S_pm_description(pTHX_ const PMOP *pm);
#define PERL_ARGS_ASSERT_PM_DESCRIPTION	\
	assert(pm)
STATIC UV	S_sequence_num(pTHX_ const OP *o);
#define PERL_ARGS_ASSERT_SEQUENCE_NUM
#endif
#if defined(PERL_IN_DUMP_C) || defined(PERL_IN_HV_C) || defined(PERL_IN_SV_C) || defined(PERL_IN_SCOPE_C)
PERL_CALLCONV void	Perl_hv_kill_backrefs(pTHX_ HV *hv);
#define PERL_ARGS_ASSERT_HV_KILL_BACKREFS	\
	assert(hv)
#endif
#if defined(PERL_IN_GV_C)
STATIC bool	S_find_default_stash(pTHX_ HV **stash, const char *name, STRLEN len, const U32 is_utf8, const I32 add, const svtype sv_type);
#define PERL_ARGS_ASSERT_FIND_DEFAULT_STASH	\
	assert(stash); assert(name)
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE GV*	S_gv_fetchmeth_internal(pTHX_ HV* stash, SV* meth, const char* name, STRLEN len, I32 level, U32 flags);
#define PERL_ARGS_ASSERT_GV_FETCHMETH_INTERNAL
#endif
STATIC void	S_gv_init_svtype(pTHX_ GV *gv, const svtype sv_type);
#define PERL_ARGS_ASSERT_GV_INIT_SVTYPE	\
	assert(gv)
STATIC bool	S_gv_is_in_main(pTHX_ const char *name, STRLEN len, const U32 is_utf8);
#define PERL_ARGS_ASSERT_GV_IS_IN_MAIN	\
	assert(name)
STATIC bool	S_gv_magicalize(pTHX_ GV *gv, HV *stash, const char *name, STRLEN len, const svtype sv_type);
#define PERL_ARGS_ASSERT_GV_MAGICALIZE	\
	assert(gv); assert(stash); assert(name)
STATIC void	S_gv_magicalize_isa(pTHX_ GV *gv);
#define PERL_ARGS_ASSERT_GV_MAGICALIZE_ISA	\
	assert(gv)
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE HV*	S_gv_stashpvn_internal(pTHX_ const char* name, U32 namelen, I32 flags);
#define PERL_ARGS_ASSERT_GV_STASHPVN_INTERNAL	\
	assert(name)
#endif
STATIC void	S_maybe_multimagic_gv(pTHX_ GV *gv, const char *name, const svtype sv_type);
#define PERL_ARGS_ASSERT_MAYBE_MULTIMAGIC_GV	\
	assert(gv); assert(name)
STATIC bool	S_parse_gv_stash_name(pTHX_ HV **stash, GV **gv, const char **name, STRLEN *len, const char *nambeg, STRLEN full_len, const U32 is_utf8, const I32 add);
#define PERL_ARGS_ASSERT_PARSE_GV_STASH_NAME	\
	assert(stash); assert(gv); assert(name); assert(len); assert(nambeg)
STATIC void	S_require_tie_mod(pTHX_ GV *gv, const char varname, const char * name, STRLEN len, const U32 flags);
#define PERL_ARGS_ASSERT_REQUIRE_TIE_MOD	\
	assert(gv); assert(varname); assert(name)
#endif
#if defined(PERL_IN_GV_C) || defined(PERL_IN_SV_C) || defined(PERL_IN_PAD_C) || defined(PERL_IN_OP_C)
PERL_CALLCONV void	Perl_sv_add_backref(pTHX_ SV *const tsv, SV *const sv);
#define PERL_ARGS_ASSERT_SV_ADD_BACKREF	\
	assert(tsv); assert(sv)
#endif
#if defined(PERL_IN_GV_C) || defined(PERL_IN_UNIVERSAL_C)
PERL_CALLCONV HV*	Perl_gv_stashsvpvn_cached(pTHX_ SV *namesv, const char* name, U32 namelen, I32 flags);
#endif
#if defined(PERL_IN_HV_C)
STATIC void	S_clear_placeholders(pTHX_ HV *hv, U32 items);
#define PERL_ARGS_ASSERT_CLEAR_PLACEHOLDERS	\
	assert(hv)
STATIC void	S_hsplit(pTHX_ HV *hv, STRLEN const oldsize, STRLEN newsize);
#define PERL_ARGS_ASSERT_HSPLIT	\
	assert(hv)
STATIC struct xpvhv_aux*	S_hv_auxinit(pTHX_ HV *hv);
#define PERL_ARGS_ASSERT_HV_AUXINIT	\
	assert(hv)
STATIC SV*	S_hv_delete_common(pTHX_ HV *hv, SV *keysv, const char *key, STRLEN klen, int k_flags, I32 d_flags, U32 hash);
#define PERL_ARGS_ASSERT_HV_DELETE_COMMON
STATIC SV*	S_hv_free_ent_ret(pTHX_ HE *entry);
#define PERL_ARGS_ASSERT_HV_FREE_ENT_RET	\
	assert(entry)
STATIC void	S_hv_free_entries(pTHX_ HV *hv);
#define PERL_ARGS_ASSERT_HV_FREE_ENTRIES	\
	assert(hv)
STATIC void	S_hv_magic_check(HV *hv, bool *needs_copy, bool *needs_store);
#define PERL_ARGS_ASSERT_HV_MAGIC_CHECK	\
	assert(hv); assert(needs_copy); assert(needs_store)
PERL_STATIC_NO_RET void	S_hv_notallowed(pTHX_ int flags, const char *key, I32 klen, const char *msg)
			__attribute__noreturn__;
#define PERL_ARGS_ASSERT_HV_NOTALLOWED	\
	assert(key); assert(msg)

STATIC SV *	S_refcounted_he_value(pTHX_ const struct refcounted_he *he);
#define PERL_ARGS_ASSERT_REFCOUNTED_HE_VALUE	\
	assert(he)
STATIC HEK*	S_save_hek_flags(const char *str, I32 len, U32 hash, int flags)
			__attribute__malloc__
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SAVE_HEK_FLAGS	\
	assert(str)

STATIC HEK*	S_share_hek_flags(pTHX_ const char *str, STRLEN len, U32 hash, int flags)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SHARE_HEK_FLAGS	\
	assert(str)

STATIC void	S_unshare_hek_or_pvn(pTHX_ const HEK* hek, const char* str, I32 len, U32 hash);
#define PERL_ARGS_ASSERT_UNSHARE_HEK_OR_PVN
#endif
#if defined(PERL_IN_HV_C) || defined(PERL_IN_MG_C) || defined(PERL_IN_SV_C)
PERL_CALLCONV void	Perl_sv_kill_backrefs(pTHX_ SV *const sv, AV *const av);
#define PERL_ARGS_ASSERT_SV_KILL_BACKREFS	\
	assert(sv)
#endif
#if defined(PERL_IN_HV_C) || defined(PERL_IN_SV_C)
PERL_CALLCONV SV*	Perl_hfree_next_entry(pTHX_ HV *hv, STRLEN *indexp);
#define PERL_ARGS_ASSERT_HFREE_NEXT_ENTRY	\
	assert(hv); assert(indexp)
#endif
#if defined(PERL_IN_LOCALE_C)
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE const char *	S_save_to_buffer(const char * string, char **buf, Size_t *buf_size, const Size_t offset)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SAVE_TO_BUFFER	\
	assert(buf_size)
#endif

#  if defined(USE_LOCALE)
STATIC const char*	S_category_name(const int category);
#define PERL_ARGS_ASSERT_CATEGORY_NAME
STATIC void	S_new_collate(pTHX_ const char* newcoll);
#define PERL_ARGS_ASSERT_NEW_COLLATE
STATIC void	S_new_ctype(pTHX_ const char* newctype);
#define PERL_ARGS_ASSERT_NEW_CTYPE	\
	assert(newctype)
STATIC void	S_new_numeric(pTHX_ const char* newnum);
#define PERL_ARGS_ASSERT_NEW_NUMERIC
STATIC void	S_restore_switched_locale(pTHX_ const int category, const char * const original_locale);
#define PERL_ARGS_ASSERT_RESTORE_SWITCHED_LOCALE
STATIC void	S_set_numeric_radix(pTHX_ const bool use_locale);
#define PERL_ARGS_ASSERT_SET_NUMERIC_RADIX
STATIC char*	S_stdize_locale(pTHX_ char* locs);
#define PERL_ARGS_ASSERT_STDIZE_LOCALE	\
	assert(locs)
STATIC const char*	S_switch_category_locale_to_template(pTHX_ const int switch_category, const int template_category, const char * template_locale);
#define PERL_ARGS_ASSERT_SWITCH_CATEGORY_LOCALE_TO_TEMPLATE
#    if defined(USE_POSIX_2008_LOCALE)
STATIC const char*	S_emulate_setlocale(const int category, const char* locale, unsigned int index, const bool is_index_valid);
#define PERL_ARGS_ASSERT_EMULATE_SETLOCALE
#    endif
#    if defined(WIN32)
STATIC char*	S_win32_setlocale(pTHX_ int category, const char* locale);
#define PERL_ARGS_ASSERT_WIN32_SETLOCALE
#    endif
#  endif
#endif
#if defined(PERL_IN_LOCALE_C) || defined(PERL_IN_SV_C) || defined(PERL_IN_MATHOMS_C)
#  if defined(USE_LOCALE_COLLATE)
PERL_CALLCONV char*	Perl__mem_collxfrm(pTHX_ const char* input_string, STRLEN len, STRLEN* xlen, bool utf8);
#define PERL_ARGS_ASSERT__MEM_COLLXFRM	\
	assert(input_string); assert(xlen)
#  endif
#endif
#if defined(PERL_IN_MALLOC_C)
STATIC int	S_adjust_size_and_find_bucket(size_t *nbytes_p);
#define PERL_ARGS_ASSERT_ADJUST_SIZE_AND_FIND_BUCKET	\
	assert(nbytes_p)
#endif
#if defined(PERL_IN_MG_C)
STATIC void	S_fixup_errno_string(pTHX_ SV* sv);
#define PERL_ARGS_ASSERT_FIXUP_ERRNO_STRING	\
	assert(sv)
STATIC SV*	S_magic_methcall1(pTHX_ SV *sv, const MAGIC *mg, SV *meth, U32 flags, int n, SV *val);
#define PERL_ARGS_ASSERT_MAGIC_METHCALL1	\
	assert(sv); assert(mg); assert(meth)
STATIC int	S_magic_methpack(pTHX_ SV *sv, const MAGIC *mg, SV *meth);
#define PERL_ARGS_ASSERT_MAGIC_METHPACK	\
	assert(sv); assert(mg); assert(meth)
STATIC void	S_restore_magic(pTHX_ const void *p);
#define PERL_ARGS_ASSERT_RESTORE_MAGIC
STATIC void	S_save_magic_flags(pTHX_ I32 mgs_ix, SV *sv, U32 flags);
#define PERL_ARGS_ASSERT_SAVE_MAGIC_FLAGS	\
	assert(sv)
STATIC void	S_unwind_handler_stack(pTHX_ const void *p);
#define PERL_ARGS_ASSERT_UNWIND_HANDLER_STACK
#endif
#if defined(PERL_IN_MG_C) || defined(PERL_IN_PP_C)
PERL_CALLCONV bool	Perl_translate_substr_offsets(STRLEN curlen, IV pos1_iv, bool pos1_is_uv, IV len_iv, bool len_is_uv, STRLEN *posp, STRLEN *lenp);
#define PERL_ARGS_ASSERT_TRANSLATE_SUBSTR_OFFSETS	\
	assert(posp); assert(lenp)
#endif
#if defined(PERL_IN_MRO_C)
STATIC void	S_mro_clean_isarev(pTHX_ HV * const isa, const char * const name, const STRLEN len, HV * const exceptions, U32 hash, U32 flags);
#define PERL_ARGS_ASSERT_MRO_CLEAN_ISAREV	\
	assert(isa); assert(name)
STATIC void	S_mro_gather_and_rename(pTHX_ HV * const stashes, HV * const seen_stashes, HV *stash, HV *oldstash, SV *namesv);
#define PERL_ARGS_ASSERT_MRO_GATHER_AND_RENAME	\
	assert(stashes); assert(seen_stashes); assert(namesv)
STATIC AV*	S_mro_get_linear_isa_dfs(pTHX_ HV* stash, U32 level);
#define PERL_ARGS_ASSERT_MRO_GET_LINEAR_ISA_DFS	\
	assert(stash)
#endif
#if defined(PERL_IN_NUMERIC_C)
STATIC void	S_output_non_portable(pTHX_ const U8 shift);
#define PERL_ARGS_ASSERT_OUTPUT_NON_PORTABLE
#endif
#if defined(PERL_IN_OP_C)
STATIC void	S_apply_attrs(pTHX_ HV *stash, SV *target, OP *attrs);
#define PERL_ARGS_ASSERT_APPLY_ATTRS	\
	assert(stash); assert(target)
STATIC void	S_apply_attrs_my(pTHX_ HV *stash, OP *target, OP *attrs, OP **imopsp);
#define PERL_ARGS_ASSERT_APPLY_ATTRS_MY	\
	assert(stash); assert(target); assert(imopsp)
STATIC I32	S_assignment_type(pTHX_ const OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_ASSIGNMENT_TYPE

STATIC void	S_bad_type_gv(pTHX_ I32 n, GV *gv, const OP *kid, const char *t);
#define PERL_ARGS_ASSERT_BAD_TYPE_GV	\
	assert(gv); assert(kid); assert(t)
STATIC void	S_bad_type_pv(pTHX_ I32 n, const char *t, const OP *o, const OP *kid);
#define PERL_ARGS_ASSERT_BAD_TYPE_PV	\
	assert(t); assert(o); assert(kid)
STATIC void	S_clear_special_blocks(pTHX_ const char *const fullname, GV *const gv, CV *const cv);
#define PERL_ARGS_ASSERT_CLEAR_SPECIAL_BLOCKS	\
	assert(fullname); assert(gv); assert(cv)
STATIC void	S_cop_free(pTHX_ COP *cop);
#define PERL_ARGS_ASSERT_COP_FREE	\
	assert(cop)
STATIC OP *	S_dup_attrlist(pTHX_ OP *o);
#define PERL_ARGS_ASSERT_DUP_ATTRLIST	\
	assert(o)
STATIC void	S_finalize_op(pTHX_ OP* o);
#define PERL_ARGS_ASSERT_FINALIZE_OP	\
	assert(o)
STATIC void	S_find_and_forget_pmops(pTHX_ OP *o);
#define PERL_ARGS_ASSERT_FIND_AND_FORGET_PMOPS	\
	assert(o)
STATIC OP*	S_fold_constants(pTHX_ OP * const o);
#define PERL_ARGS_ASSERT_FOLD_CONSTANTS	\
	assert(o)
STATIC OP*	S_force_list(pTHX_ OP* arg, bool nullit);
#define PERL_ARGS_ASSERT_FORCE_LIST
STATIC void	S_forget_pmop(pTHX_ PMOP *const o);
#define PERL_ARGS_ASSERT_FORGET_PMOP	\
	assert(o)
STATIC void	S_gen_constant_list(pTHX_ OP* o);
#define PERL_ARGS_ASSERT_GEN_CONSTANT_LIST
STATIC void	S_inplace_aassign(pTHX_ OP* o);
#define PERL_ARGS_ASSERT_INPLACE_AASSIGN	\
	assert(o)
STATIC bool	S_is_handle_constructor(const OP *o, I32 numargs)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_HANDLE_CONSTRUCTOR	\
	assert(o)

STATIC OP*	S_listkids(pTHX_ OP* o);
#define PERL_ARGS_ASSERT_LISTKIDS
STATIC bool	S_looks_like_bool(pTHX_ const OP* o);
#define PERL_ARGS_ASSERT_LOOKS_LIKE_BOOL	\
	assert(o)
STATIC OP*	S_modkids(pTHX_ OP *o, I32 type);
#define PERL_ARGS_ASSERT_MODKIDS
STATIC void	S_move_proto_attr(pTHX_ OP **proto, OP **attrs, const GV *name, bool curstash);
#define PERL_ARGS_ASSERT_MOVE_PROTO_ATTR	\
	assert(proto); assert(attrs); assert(name)
STATIC OP *	S_my_kid(pTHX_ OP *o, OP *attrs, OP **imopsp);
#define PERL_ARGS_ASSERT_MY_KID	\
	assert(imopsp)
STATIC OP*	S_newGIVWHENOP(pTHX_ OP* cond, OP *block, I32 enter_opcode, I32 leave_opcode, PADOFFSET entertarg);
#define PERL_ARGS_ASSERT_NEWGIVWHENOP	\
	assert(block)
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE OP*	S_newMETHOP_internal(pTHX_ I32 type, I32 flags, OP* dynamic_meth, SV* const_meth);
#define PERL_ARGS_ASSERT_NEWMETHOP_INTERNAL
#endif
STATIC OP*	S_new_logop(pTHX_ I32 type, I32 flags, OP **firstp, OP **otherp)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEW_LOGOP	\
	assert(firstp); assert(otherp)

STATIC void	S_no_bareword_allowed(pTHX_ OP *o);
#define PERL_ARGS_ASSERT_NO_BAREWORD_ALLOWED	\
	assert(o)
STATIC OP*	S_no_fh_allowed(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NO_FH_ALLOWED	\
	assert(o)

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE OP*	S_op_integerize(pTHX_ OP *o);
#define PERL_ARGS_ASSERT_OP_INTEGERIZE	\
	assert(o)
#endif
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE OP*	S_op_std_init(pTHX_ OP *o);
#define PERL_ARGS_ASSERT_OP_STD_INIT	\
	assert(o)
#endif
STATIC void	S_optimize_op(pTHX_ OP* o);
#define PERL_ARGS_ASSERT_OPTIMIZE_OP	\
	assert(o)
STATIC OP*	S_pmtrans(pTHX_ OP* o, OP* expr, OP* repl);
#define PERL_ARGS_ASSERT_PMTRANS	\
	assert(o); assert(expr); assert(repl)
STATIC bool	S_process_special_blocks(pTHX_ I32 floor, const char *const fullname, GV *const gv, CV *const cv);
#define PERL_ARGS_ASSERT_PROCESS_SPECIAL_BLOCKS	\
	assert(fullname); assert(gv); assert(cv)
STATIC OP*	S_ref_array_or_hash(pTHX_ OP* cond);
#define PERL_ARGS_ASSERT_REF_ARRAY_OR_HASH
STATIC OP*	S_refkids(pTHX_ OP* o, I32 type);
#define PERL_ARGS_ASSERT_REFKIDS
STATIC bool	S_scalar_mod_type(const OP *o, I32 type)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SCALAR_MOD_TYPE

STATIC OP*	S_scalarboolean(pTHX_ OP *o);
#define PERL_ARGS_ASSERT_SCALARBOOLEAN	\
	assert(o)
STATIC OP*	S_scalarkids(pTHX_ OP* o);
#define PERL_ARGS_ASSERT_SCALARKIDS
STATIC OP*	S_search_const(pTHX_ OP *o)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SEARCH_CONST	\
	assert(o)

STATIC void	S_simplify_sort(pTHX_ OP *o);
#define PERL_ARGS_ASSERT_SIMPLIFY_SORT	\
	assert(o)
STATIC OP*	S_too_few_arguments_pv(pTHX_ OP *o, const char* name, U32 flags)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_TOO_FEW_ARGUMENTS_PV	\
	assert(o); assert(name)

STATIC OP*	S_too_many_arguments_pv(pTHX_ OP *o, const char* name, U32 flags);
#define PERL_ARGS_ASSERT_TOO_MANY_ARGUMENTS_PV	\
	assert(o); assert(name)
STATIC OP*	S_traverse_op_tree(pTHX_ OP* top, OP* o);
#define PERL_ARGS_ASSERT_TRAVERSE_OP_TREE	\
	assert(top); assert(o)
STATIC OP*	S_voidnonfinal(pTHX_ OP* o);
#define PERL_ARGS_ASSERT_VOIDNONFINAL
#  if defined(USE_ITHREADS)
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE void	S_op_relocate_sv(pTHX_ SV** svp, PADOFFSET* targp);
#define PERL_ARGS_ASSERT_OP_RELOCATE_SV	\
	assert(svp); assert(targp)
#endif
#  endif
#endif
#if defined(PERL_IN_OP_C) || defined(PERL_IN_SV_C)
PERL_CALLCONV void	Perl_report_redefined_cv(pTHX_ const SV *name, const CV *old_cv, SV * const *new_const_svp);
#define PERL_ARGS_ASSERT_REPORT_REDEFINED_CV	\
	assert(name); assert(old_cv)
#endif
#if defined(PERL_IN_PAD_C)
STATIC PADOFFSET	S_pad_alloc_name(pTHX_ PADNAME *name, U32 flags, HV *typestash, HV *ourstash);
#define PERL_ARGS_ASSERT_PAD_ALLOC_NAME	\
	assert(name)
STATIC void	S_pad_check_dup(pTHX_ PADNAME *name, U32 flags, const HV *ourstash);
#define PERL_ARGS_ASSERT_PAD_CHECK_DUP	\
	assert(name)
STATIC PADOFFSET	S_pad_findlex(pTHX_ const char *namepv, STRLEN namelen, U32 flags, const CV* cv, U32 seq, int warn, SV** out_capture, PADNAME** out_name, int *out_flags);
#define PERL_ARGS_ASSERT_PAD_FINDLEX	\
	assert(namepv); assert(cv); assert(out_name); assert(out_flags)
STATIC void	S_pad_reset(pTHX);
#define PERL_ARGS_ASSERT_PAD_RESET
#endif
#if defined(PERL_IN_PAD_C) || defined(PERL_IN_OP_C)
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE bool	S_PadnameIN_SCOPE(const PADNAME * const pn, const U32 seq);
#define PERL_ARGS_ASSERT_PADNAMEIN_SCOPE	\
	assert(pn)
#endif
#endif
#if defined(PERL_IN_PERLY_C) || defined(PERL_IN_OP_C) || defined(PERL_IN_TOKE_C)
#ifndef NO_MATHOMS
PERL_CALLCONV OP*	Perl_ref(pTHX_ OP* o, I32 type);
#define PERL_ARGS_ASSERT_REF
#endif
#endif
#if defined(PERL_IN_PERL_C)
STATIC void	S_find_beginning(pTHX_ SV* linestr_sv, PerlIO *rsfp);
#define PERL_ARGS_ASSERT_FIND_BEGINNING	\
	assert(linestr_sv); assert(rsfp)
STATIC void	S_forbid_setid(pTHX_ const char flag, const bool suidscript);
#define PERL_ARGS_ASSERT_FORBID_SETID
STATIC void	S_incpush(pTHX_ const char *const dir, STRLEN len, U32 flags);
#define PERL_ARGS_ASSERT_INCPUSH	\
	assert(dir)
STATIC void	S_incpush_use_sep(pTHX_ const char *p, STRLEN len, U32 flags);
#define PERL_ARGS_ASSERT_INCPUSH_USE_SEP	\
	assert(p)
STATIC void	S_init_ids(pTHX);
#define PERL_ARGS_ASSERT_INIT_IDS
STATIC void	S_init_interp(pTHX);
#define PERL_ARGS_ASSERT_INIT_INTERP
STATIC void	S_init_main_stash(pTHX);
#define PERL_ARGS_ASSERT_INIT_MAIN_STASH
STATIC void	S_init_perllib(pTHX);
#define PERL_ARGS_ASSERT_INIT_PERLLIB
STATIC void	S_init_postdump_symbols(pTHX_ int argc, char **argv, char **env);
#define PERL_ARGS_ASSERT_INIT_POSTDUMP_SYMBOLS	\
	assert(argv)
STATIC void	S_init_predump_symbols(pTHX);
#define PERL_ARGS_ASSERT_INIT_PREDUMP_SYMBOLS
STATIC SV*	S_mayberelocate(pTHX_ const char *const dir, STRLEN len, U32 flags);
#define PERL_ARGS_ASSERT_MAYBERELOCATE	\
	assert(dir)
PERL_STATIC_NO_RET void	S_minus_v(pTHX)
			__attribute__noreturn__;
#define PERL_ARGS_ASSERT_MINUS_V

PERL_STATIC_NO_RET void	S_my_exit_jump(pTHX)
			__attribute__noreturn__;
#define PERL_ARGS_ASSERT_MY_EXIT_JUMP

STATIC void	S_nuke_stacks(pTHX);
#define PERL_ARGS_ASSERT_NUKE_STACKS
STATIC PerlIO *	S_open_script(pTHX_ const char *scriptname, bool dosearch, bool *suidscript);
#define PERL_ARGS_ASSERT_OPEN_SCRIPT	\
	assert(scriptname); assert(suidscript)
STATIC void*	S_parse_body(pTHX_ char **env, XSINIT_t xsinit);
#define PERL_ARGS_ASSERT_PARSE_BODY
PERL_STATIC_NO_RET void	S_run_body(pTHX_ I32 oldscope)
			__attribute__noreturn__;
#define PERL_ARGS_ASSERT_RUN_BODY

PERL_STATIC_NO_RET void	S_usage(pTHX)
			__attribute__noreturn__;
#define PERL_ARGS_ASSERT_USAGE

#endif
#if defined(PERL_IN_PP_C)
STATIC size_t	S_do_chomp(pTHX_ SV *retval, SV *sv, bool chomping);
#define PERL_ARGS_ASSERT_DO_CHOMP	\
	assert(retval); assert(sv)
STATIC OP*	S_do_delete_local(pTHX);
#define PERL_ARGS_ASSERT_DO_DELETE_LOCAL
STATIC SV*	S_refto(pTHX_ SV* sv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_REFTO	\
	assert(sv)

#endif
#if defined(PERL_IN_PP_C) || defined(PERL_IN_PP_HOT_C)
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE bool	S_lossless_NV_to_IV(const NV nv, IV * ivp)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_LOSSLESS_NV_TO_IV	\
	assert(ivp)
#endif

PERL_CALLCONV GV*	Perl_softref2xv(pTHX_ SV *const sv, const char *const what, const svtype type, SV ***spp)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SOFTREF2XV	\
	assert(sv); assert(what); assert(spp)

#endif
#if defined(PERL_IN_PP_CTL_C)
STATIC PerlIO *	S_check_type_and_open(pTHX_ SV *name)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CHECK_TYPE_AND_OPEN	\
	assert(name)

STATIC void	S_destroy_matcher(pTHX_ PMOP* matcher);
#define PERL_ARGS_ASSERT_DESTROY_MATCHER	\
	assert(matcher)
STATIC OP*	S_do_smartmatch(pTHX_ HV* seen_this, HV* seen_other, const bool copied);
#define PERL_ARGS_ASSERT_DO_SMARTMATCH
STATIC OP*	S_docatch(pTHX_ Perl_ppaddr_t firstpp)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DOCATCH

STATIC bool	S_doeval_compile(pTHX_ U8 gimme, CV* outside, U32 seq, HV* hh);
#define PERL_ARGS_ASSERT_DOEVAL_COMPILE
STATIC OP*	S_dofindlabel(pTHX_ OP *o, const char *label, STRLEN len, U32 flags, OP **opstack, OP **oplimit)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DOFINDLABEL	\
	assert(o); assert(label); assert(opstack); assert(oplimit)

STATIC MAGIC *	S_doparseform(pTHX_ SV *sv);
#define PERL_ARGS_ASSERT_DOPARSEFORM	\
	assert(sv)
STATIC I32	S_dopoptoeval(pTHX_ I32 startingblock)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DOPOPTOEVAL

STATIC I32	S_dopoptogivenfor(pTHX_ I32 startingblock)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DOPOPTOGIVENFOR

STATIC I32	S_dopoptolabel(pTHX_ const char *label, STRLEN len, U32 flags)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DOPOPTOLABEL	\
	assert(label)

STATIC I32	S_dopoptoloop(pTHX_ I32 startingblock)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DOPOPTOLOOP

STATIC I32	S_dopoptosub_at(pTHX_ const PERL_CONTEXT* cxstk, I32 startingblock)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DOPOPTOSUB_AT	\
	assert(cxstk)

STATIC I32	S_dopoptowhen(pTHX_ I32 startingblock)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DOPOPTOWHEN

STATIC PMOP*	S_make_matcher(pTHX_ REGEXP* re)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_MAKE_MATCHER	\
	assert(re)

STATIC bool	S_matcher_matches_sv(pTHX_ PMOP* matcher, SV* sv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_MATCHER_MATCHES_SV	\
	assert(matcher); assert(sv)

STATIC bool	S_num_overflow(NV value, I32 fldsize, I32 frcsize)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NUM_OVERFLOW

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE bool	S_path_is_searchable(const char *name)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_PATH_IS_SEARCHABLE	\
	assert(name)
#endif

STATIC I32	S_run_user_filter(pTHX_ int idx, SV *buf_sv, int maxlen)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_RUN_USER_FILTER	\
	assert(buf_sv)

STATIC void	S_rxres_free(pTHX_ void** rsp);
#define PERL_ARGS_ASSERT_RXRES_FREE	\
	assert(rsp)
STATIC void	S_rxres_restore(pTHX_ void **rsp, REGEXP *rx);
#define PERL_ARGS_ASSERT_RXRES_RESTORE	\
	assert(rsp); assert(rx)
STATIC void	S_save_lines(pTHX_ AV *array, SV *sv);
#define PERL_ARGS_ASSERT_SAVE_LINES	\
	assert(sv)
#endif
#if defined(PERL_IN_PP_HOT_C)
STATIC void	S_do_oddball(pTHX_ SV **oddkey, SV **firstkey);
#define PERL_ARGS_ASSERT_DO_ODDBALL	\
	assert(oddkey); assert(firstkey)
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE HV*	S_opmethod_stash(pTHX_ SV* meth);
#define PERL_ARGS_ASSERT_OPMETHOD_STASH	\
	assert(meth)
#endif
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_FORCE_INLINE bool	S_should_we_output_Debug_r(pTHX_ regexp * prog)
			__attribute__warn_unused_result__
			__attribute__always_inline__;
#define PERL_ARGS_ASSERT_SHOULD_WE_OUTPUT_DEBUG_R	\
	assert(prog)
#endif

#endif
#if defined(PERL_IN_PP_PACK_C)
STATIC int	S_div128(pTHX_ SV *pnum, bool *done);
#define PERL_ARGS_ASSERT_DIV128	\
	assert(pnum); assert(done)
STATIC char	S_first_symbol(const char *pat, const char *patend);
#define PERL_ARGS_ASSERT_FIRST_SYMBOL	\
	assert(pat); assert(patend)
STATIC const char *	S_get_num(pTHX_ const char *patptr, SSize_t *lenptr)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_GET_NUM	\
	assert(patptr); assert(lenptr)

STATIC const char *	S_group_end(pTHX_ const char *patptr, const char *patend, char ender);
#define PERL_ARGS_ASSERT_GROUP_END	\
	assert(patptr); assert(patend)
STATIC SV*	S_is_an_int(pTHX_ const char *s, STRLEN l)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_AN_INT	\
	assert(s)

STATIC SSize_t	S_measure_struct(pTHX_ struct tempsym* symptr);
#define PERL_ARGS_ASSERT_MEASURE_STRUCT	\
	assert(symptr)
STATIC SV*	S_mul128(pTHX_ SV *sv, U8 m);
#define PERL_ARGS_ASSERT_MUL128	\
	assert(sv)
STATIC char *	S_my_bytes_to_utf8(const U8 *start, STRLEN len, char *dest, const bool needs_swap)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_MY_BYTES_TO_UTF8	\
	assert(start); assert(dest)

STATIC bool	S_need_utf8(const char *pat, const char *patend);
#define PERL_ARGS_ASSERT_NEED_UTF8	\
	assert(pat); assert(patend)
STATIC bool	S_next_symbol(pTHX_ struct tempsym* symptr);
#define PERL_ARGS_ASSERT_NEXT_SYMBOL	\
	assert(symptr)
STATIC SV **	S_pack_rec(pTHX_ SV *cat, struct tempsym* symptr, SV **beglist, SV **endlist);
#define PERL_ARGS_ASSERT_PACK_REC	\
	assert(cat); assert(symptr); assert(beglist); assert(endlist)
STATIC char *	S_sv_exp_grow(pTHX_ SV *sv, STRLEN needed)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SV_EXP_GROW	\
	assert(sv)

STATIC SSize_t	S_unpack_rec(pTHX_ struct tempsym* symptr, const char *s, const char *strbeg, const char *strend, const char **new_s);
#define PERL_ARGS_ASSERT_UNPACK_REC	\
	assert(symptr); assert(s); assert(strbeg); assert(strend)
#endif
#if defined(PERL_IN_PP_SORT_C)
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_FORCE_INLINE I32	S_amagic_cmp(pTHX_ SV *const str1, SV *const str2)
			__attribute__always_inline__;
#define PERL_ARGS_ASSERT_AMAGIC_CMP	\
	assert(str1); assert(str2)
#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_FORCE_INLINE I32	S_amagic_cmp_desc(pTHX_ SV *const str1, SV *const str2)
			__attribute__always_inline__;
#define PERL_ARGS_ASSERT_AMAGIC_CMP_DESC	\
	assert(str1); assert(str2)
#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_FORCE_INLINE I32	S_amagic_i_ncmp(pTHX_ SV *const a, SV *const b)
			__attribute__always_inline__;
#define PERL_ARGS_ASSERT_AMAGIC_I_NCMP	\
	assert(a); assert(b)
#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_FORCE_INLINE I32	S_amagic_i_ncmp_desc(pTHX_ SV *const a, SV *const b)
			__attribute__always_inline__;
#define PERL_ARGS_ASSERT_AMAGIC_I_NCMP_DESC	\
	assert(a); assert(b)
#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_FORCE_INLINE I32	S_amagic_ncmp(pTHX_ SV *const a, SV *const b)
			__attribute__always_inline__;
#define PERL_ARGS_ASSERT_AMAGIC_NCMP	\
	assert(a); assert(b)
#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_FORCE_INLINE I32	S_amagic_ncmp_desc(pTHX_ SV *const a, SV *const b)
			__attribute__always_inline__;
#define PERL_ARGS_ASSERT_AMAGIC_NCMP_DESC	\
	assert(a); assert(b)
#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_FORCE_INLINE I32	S_cmp_desc(pTHX_ SV *const str1, SV *const str2)
			__attribute__always_inline__;
#define PERL_ARGS_ASSERT_CMP_DESC	\
	assert(str1); assert(str2)
#endif

STATIC I32	S_sortcv(pTHX_ SV *const a, SV *const b);
#define PERL_ARGS_ASSERT_SORTCV	\
	assert(a); assert(b)
STATIC I32	S_sortcv_stacked(pTHX_ SV *const a, SV *const b);
#define PERL_ARGS_ASSERT_SORTCV_STACKED	\
	assert(a); assert(b)
STATIC I32	S_sortcv_xsub(pTHX_ SV *const a, SV *const b);
#define PERL_ARGS_ASSERT_SORTCV_XSUB	\
	assert(a); assert(b)
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_FORCE_INLINE void	S_sortsv_flags_impl(pTHX_ SV** array, size_t num_elts, SVCOMPARE_t cmp, U32 flags)
			__attribute__always_inline__;
#define PERL_ARGS_ASSERT_SORTSV_FLAGS_IMPL	\
	assert(cmp)
#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_FORCE_INLINE I32	S_sv_i_ncmp(pTHX_ SV *const a, SV *const b)
			__attribute__always_inline__;
#define PERL_ARGS_ASSERT_SV_I_NCMP	\
	assert(a); assert(b)
#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_FORCE_INLINE I32	S_sv_i_ncmp_desc(pTHX_ SV *const a, SV *const b)
			__attribute__always_inline__;
#define PERL_ARGS_ASSERT_SV_I_NCMP_DESC	\
	assert(a); assert(b)
#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_FORCE_INLINE I32	S_sv_ncmp(pTHX_ SV *const a, SV *const b)
			__attribute__always_inline__;
#define PERL_ARGS_ASSERT_SV_NCMP	\
	assert(a); assert(b)
#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_FORCE_INLINE I32	S_sv_ncmp_desc(pTHX_ SV *const a, SV *const b)
			__attribute__always_inline__;
#define PERL_ARGS_ASSERT_SV_NCMP_DESC	\
	assert(a); assert(b)
#endif

#  if defined(USE_LOCALE_COLLATE)
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_FORCE_INLINE I32	S_amagic_cmp_locale(pTHX_ SV *const str1, SV *const str2)
			__attribute__always_inline__;
#define PERL_ARGS_ASSERT_AMAGIC_CMP_LOCALE	\
	assert(str1); assert(str2)
#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_FORCE_INLINE I32	S_amagic_cmp_locale_desc(pTHX_ SV *const str1, SV *const str2)
			__attribute__always_inline__;
#define PERL_ARGS_ASSERT_AMAGIC_CMP_LOCALE_DESC	\
	assert(str1); assert(str2)
#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_FORCE_INLINE I32	S_cmp_locale_desc(pTHX_ SV *const str1, SV *const str2)
			__attribute__always_inline__;
#define PERL_ARGS_ASSERT_CMP_LOCALE_DESC	\
	assert(str1); assert(str2)
#endif

#  endif
#endif
#if defined(PERL_IN_PP_SYS_C)
STATIC OP*	S_doform(pTHX_ CV *cv, GV *gv, OP *retop);
#define PERL_ARGS_ASSERT_DOFORM	\
	assert(cv); assert(gv)
STATIC SV *	S_space_join_names_mortal(pTHX_ char *const *array);
#define PERL_ARGS_ASSERT_SPACE_JOIN_NAMES_MORTAL
#endif
#if defined(PERL_IN_REGCOMP_C)
STATIC void	S_add_above_Latin1_folds(pTHX_ RExC_state_t *pRExC_state, const U8 cp, SV** invlist);
#define PERL_ARGS_ASSERT_ADD_ABOVE_LATIN1_FOLDS	\
	assert(pRExC_state); assert(invlist)
STATIC U32	S_add_data(RExC_state_t* const pRExC_state, const char* const s, const U32 n)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_ADD_DATA	\
	assert(pRExC_state); assert(s)

STATIC AV*	S_add_multi_match(pTHX_ AV* multi_char_matches, SV* multi_string, const STRLEN cp_count);
#define PERL_ARGS_ASSERT_ADD_MULTI_MATCH	\
	assert(multi_string)
STATIC void	S_change_engine_size(pTHX_ RExC_state_t *pRExC_state, const Ptrdiff_t size);
#define PERL_ARGS_ASSERT_CHANGE_ENGINE_SIZE	\
	assert(pRExC_state)
STATIC REGEXP*	S_compile_wildcard(pTHX_ const char * subpattern, const STRLEN len, const bool ignore_case)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_COMPILE_WILDCARD	\
	assert(subpattern)

STATIC U8	S_compute_EXACTish(RExC_state_t *pRExC_state);
#define PERL_ARGS_ASSERT_COMPUTE_EXACTISH	\
	assert(pRExC_state)
STATIC regnode *	S_construct_ahocorasick_from_trie(pTHX_ RExC_state_t *pRExC_state, regnode *source, U32 depth);
#define PERL_ARGS_ASSERT_CONSTRUCT_AHOCORASICK_FROM_TRIE	\
	assert(pRExC_state); assert(source)
STATIC int	S_edit_distance(const UV *src, const UV *tgt, const STRLEN x, const STRLEN y, const SSize_t maxDistance)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_EDIT_DISTANCE	\
	assert(src); assert(tgt)

STATIC I32	S_execute_wildcard(pTHX_ REGEXP * const prog, char* stringarg, char* strend, char* strbeg, SSize_t minend, SV* screamer, U32 nosave);
#define PERL_ARGS_ASSERT_EXECUTE_WILDCARD	\
	assert(prog); assert(stringarg); assert(strend); assert(strbeg); assert(screamer)
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE Size_t	S_find_first_differing_byte_pos(const U8 * s1, const U8 * s2, const Size_t max);
#define PERL_ARGS_ASSERT_FIND_FIRST_DIFFERING_BYTE_POS	\
	assert(s1); assert(s2)
#endif
STATIC SV *	S_get_ANYOFM_contents(pTHX_ const regnode * n)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_GET_ANYOFM_CONTENTS	\
	assert(n)

STATIC SV*	S_get_ANYOF_cp_list_for_ssc(pTHX_ const RExC_state_t *pRExC_state, const regnode_charclass* const node);
#define PERL_ARGS_ASSERT_GET_ANYOF_CP_LIST_FOR_SSC	\
	assert(pRExC_state); assert(node)
STATIC U32	S_get_quantifier_value(pTHX_ RExC_state_t *pRExC_state, const char * start, const char * end);
#define PERL_ARGS_ASSERT_GET_QUANTIFIER_VALUE	\
	assert(pRExC_state); assert(start); assert(end)
STATIC bool	S_grok_bslash_N(pTHX_ RExC_state_t *pRExC_state, regnode_offset* nodep, UV *code_point_p, int* cp_count, I32 *flagp, const bool strict, const U32 depth);
#define PERL_ARGS_ASSERT_GROK_BSLASH_N	\
	assert(pRExC_state); assert(flagp)
STATIC regnode_offset	S_handle_named_backref(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, char * backref_parse_start, char ch);
#define PERL_ARGS_ASSERT_HANDLE_NAMED_BACKREF	\
	assert(pRExC_state); assert(flagp); assert(backref_parse_start)
STATIC bool	S_handle_names_wildcard(pTHX_ const char * wname, const STRLEN wname_len, SV ** prop_definition, AV ** strings);
#define PERL_ARGS_ASSERT_HANDLE_NAMES_WILDCARD	\
	assert(wname); assert(prop_definition); assert(strings)
STATIC int	S_handle_possible_posix(pTHX_ RExC_state_t *pRExC_state, const char* const s, char ** updated_parse_ptr, AV** posix_warnings, const bool check_only);
#define PERL_ARGS_ASSERT_HANDLE_POSSIBLE_POSIX	\
	assert(pRExC_state); assert(s)
STATIC regnode_offset	S_handle_regex_sets(pTHX_ RExC_state_t *pRExC_state, SV ** return_invlist, I32 *flagp, U32 depth);
#define PERL_ARGS_ASSERT_HANDLE_REGEX_SETS	\
	assert(pRExC_state); assert(flagp)
STATIC SV *	S_handle_user_defined_property(pTHX_ const char * name, const STRLEN name_len, const bool is_utf8, const bool to_fold, const bool runtime, const bool deferrable, SV* contents, bool *user_defined_ptr, SV * msg, const STRLEN level);
#define PERL_ARGS_ASSERT_HANDLE_USER_DEFINED_PROPERTY	\
	assert(name); assert(contents); assert(user_defined_ptr); assert(msg)
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE SV*	S_invlist_contents(pTHX_ SV* const invlist, const bool traditional_style)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_INVLIST_CONTENTS	\
	assert(invlist)
#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE bool	S_invlist_is_iterating(const SV* const invlist)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_INVLIST_IS_ITERATING	\
	assert(invlist)
#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE UV	S_invlist_lowest(SV* const invlist)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_INVLIST_LOWEST	\
	assert(invlist)
#endif

STATIC bool	S_is_ssc_worth_it(const RExC_state_t * pRExC_state, const regnode_ssc * ssc);
#define PERL_ARGS_ASSERT_IS_SSC_WORTH_IT	\
	assert(pRExC_state); assert(ssc)
STATIC U32	S_join_exact(pTHX_ RExC_state_t *pRExC_state, regnode *scan, UV *min_subtract, bool *unfolded_multi_char, U32 flags, regnode *val, U32 depth);
#define PERL_ARGS_ASSERT_JOIN_EXACT	\
	assert(pRExC_state); assert(scan); assert(min_subtract); assert(unfolded_multi_char)
STATIC SV*	S_make_exactf_invlist(pTHX_ RExC_state_t *pRExC_state, regnode *node)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_MAKE_EXACTF_INVLIST	\
	assert(pRExC_state); assert(node)

STATIC I32	S_make_trie(pTHX_ RExC_state_t *pRExC_state, regnode *startbranch, regnode *first, regnode *last, regnode *tail, U32 word_count, U32 flags, U32 depth);
#define PERL_ARGS_ASSERT_MAKE_TRIE	\
	assert(pRExC_state); assert(startbranch); assert(first); assert(last); assert(tail)
STATIC void	S_nextchar(pTHX_ RExC_state_t *pRExC_state);
#define PERL_ARGS_ASSERT_NEXTCHAR	\
	assert(pRExC_state)
STATIC U8	S_optimize_regclass(pTHX_ RExC_state_t *pRExC_state, SV* cp_list, SV* only_utf8_locale_list, SV* upper_latin1_only_utf8_matches, const U32 has_runtime_dependency, const U32 posixl, U8 * anyof_flags, bool * invert, regnode_offset * ret, I32 *flagp);
#define PERL_ARGS_ASSERT_OPTIMIZE_REGCLASS	\
	assert(pRExC_state); assert(anyof_flags); assert(invert); assert(ret); assert(flagp)
STATIC void	S_output_posix_warnings(pTHX_ RExC_state_t *pRExC_state, AV* posix_warnings);
#define PERL_ARGS_ASSERT_OUTPUT_POSIX_WARNINGS	\
	assert(pRExC_state); assert(posix_warnings)
STATIC void	S_parse_lparen_question_flags(pTHX_ RExC_state_t *pRExC_state);
#define PERL_ARGS_ASSERT_PARSE_LPAREN_QUESTION_FLAGS	\
	assert(pRExC_state)
STATIC SV *	S_parse_uniprop_string(pTHX_ const char * const name, Size_t name_len, const bool is_utf8, const bool to_fold, const bool runtime, const bool deferrable, AV ** strings, bool * user_defined_ptr, SV * msg, const STRLEN level);
