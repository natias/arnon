                 '   "reversed()".\n'
                 '\n'
                 'The membership test operators ("in" and "not in") are '
                 'normally\n'
                 'implemented as an iteration through a container. However, '
                 'container\n'
                 'objects can supply the following special method with a more '
                 'efficient\n'
                 'implementation, which also does not require the object be '
                 'iterable.\n'
                 '\n'
                 'object.__contains__(self, item)\n'
                 '\n'
                 '   Called to implement membership test operators.  Should '
                 'return true\n'
                 '   if *item* is in *self*, false otherwise.  For mapping '
                 'objects, this\n'
                 '   should consider the keys of the mapping rather than the '
                 'values or\n'
                 '   the key-item pairs.\n'
                 '\n'
                 '   For objects that don’t define "__contains__()", the '
                 'membership test\n'
                 '   first tries iteration via "__iter__()", then the old '
                 'sequence\n'
                 '   iteration protocol via "__getitem__()", see this section '
                 'in the\n'
                 '   language reference.\n'
                 '\n'
                 '\n'
                 'Emulating numeric types\n'
                 '=======================\n'
                 '\n'
                 'The following methods can be defined to emulate numeric '
                 'objects.\n'
                 'Methods corresponding to operations that are not supported '
                 'by the\n'
                 'particular kind of number implemented (e.g., bitwise '
                 'operations for\n'
                 'non-integral numbers) should be left undefined.\n'
                 '\n'
                 'object.__add__(self, other)\n'
                 'object.__sub__(self, other)\n'
                 'object.__mul__(self, other)\n'
                 'object.__matmul__(self, other)\n'
                 'object.__truediv__(self, other)\n'
                 'object.__floordiv__(self, other)\n'
                 'object.__mod__(self, other)\n'
                 'object.__divmod__(self, other)\n'
                 'object.__pow__(self, other[, modulo])\n'
                 'object.__lshift__(self, other)\n'
                 'object.__rshift__(self, other)\n'
                 'object.__and__(self, other)\n'
                 'object.__xor__(self, other)\n'
                 'object.__or__(self, other)\n'
                 '\n'
                 '   These methods are called to implement the binary '
                 'arithmetic\n'
                 '   operations ("+", "-", "*", "@", "/", "//", "%", '
                 '"divmod()",\n'
                 '   "pow()", "**", "<<", ">>", "&", "^", "|").  For instance, '
                 'to\n'
                 '   evaluate the expression "x + y", where *x* is an instance '
                 'of a\n'
                 '   class that has an "__add__()" method, "type(x).__add__(x, '
                 'y)" is\n'
                 '   called.  The "__divmod__()" method should be the '
                 'equivalent to\n'
                 '   using "__floordiv__()" and "__mod__()"; it should not be '
                 'related to\n'
                 '   "__truediv__()".  Note that "__pow__()" should be defined '
                 'to accept\n'
                 '   an optional third argument if the ternary version of the '
                 'built-in\n'
                 '   "pow()" function is to be supported.\n'
                 '\n'
                 '   If one of those methods does not support the operation '
                 'with the\n'
                 '   supplied arguments, it should return "NotImplemented".\n'
                 '\n'
                 'object.__radd__(self, other)\n'
                 'object.__rsub__(self, other)\n'
                 'object.__rmul__(self, other)\n'
                 'object.__rmatmul__(self, other)\n'
                 'object.__rtruediv__(self, other)\n'
                 'object.__rfloordiv__(self, other)\n'
                 'object.__rmod__(self, other)\n'
                 'object.__rdivmod__(self, other)\n'
                 'object.__rpow__(self, other[, modulo])\n'
                 'object.__rlshift__(self, other)\n'
                 'object.__rrshift__(self, other)\n'
                 'object.__rand__(self, other)\n'
                 'object.__rxor__(self, other)\n'
                 'object.__ror__(self, other)\n'
                 '\n'
                 '   These methods are called to implement the binary '
                 'arithmetic\n'
                 '   operations ("+", "-", "*", "@", "/", "//", "%", '
                 '"divmod()",\n'
                 '   "pow()", "**", "<<", ">>", "&", "^", "|") with reflected '
                 '(swapped)\n'
                 '   operands.  These functions are only called if the left '
                 'operand does\n'
                 '   not support the corresponding operation [3] and the '
                 'operands are of\n'
                 '   different types. [4] For instance, to evaluate the '
                 'expression "x -\n'
                 '   y", where *y* is an instance of a class that has an '
                 '"__rsub__()"\n'
                 '   method, "type(y).__rsub__(y, x)" is called if '
                 '"type(x).__sub__(x,\n'
                 '   y)" returns *NotImplemented*.\n'
                 '\n'
                 '   Note that ternary "pow()" will not try calling '
                 '"__rpow__()" (the\n'
                 '   coercion rules would become too complicated).\n'
                 '\n'
                 '   Note:\n'
                 '\n'
                 '     If the right operand’s type is a subclass of the left '
                 'operand’s\n'
                 '     type and that subclass provides a different '
                 'implementation of the\n'
                 '     reflected method for the operation, this method will be '
                 'called\n'
                 '     before the left operand’s non-reflected method. This '
                 'behavior\n'
                 '     allows subclasses to override their ancestors’ '
                 'operations.\n'
                 '\n'
                 'object.__iadd__(self, other)\n'
                 'object.__isub__(self, other)\n'
                 'object.__imul__(self, other)\n'
                 'object.__imatmul__(self, other)\n'
                 'object.__itruediv__(self, other)\n'
                 'object.__ifloordiv__(self, other)\n'
                 'object.__imod__(self, other)\n'
                 'object.__ipow__(self, other[, modulo])\n'
                 'object.__ilshift__(self, other)\n'
                 'object.__irshift__(self, other)\n'
                 'object.__iand__(self, other)\n'
                 'object.__ixor__(self, other)\n'
                 'object.__ior__(self, other)\n'
                 '\n'
                 '   These methods are called to implement the augmented '
                 'arithmetic\n'
                 '   assignments ("+=", "-=", "*=", "@=", "/=", "//=", "%=", '
                 '"**=",\n'
                 '   "<<=", ">>=", "&=", "^=", "|=").  These methods should '
                 'attempt to\n'
                 '   do the operation in-place (modifying *self*) and return '
                 'the result\n'
                 '   (which could be, but does not have to be, *self*).  If a '
                 'specific\n'
                 '   method is not defined, the augmented assignment falls '
                 'back to the\n'
                 '   normal methods.  For instance, if *x* is an instance of a '
                 'class\n'
                 '   with an "__iadd__()" method, "x += y" is equivalent to "x '
                 '=\n'
                 '   x.__iadd__(y)" . Otherwise, "x.__add__(y)" and '
                 '"y.__radd__(x)" are\n'
                 '   considered, as with the evaluation of "x + y". In '
                 'certain\n'
                 '   situations, augmented assignment can result in unexpected '
                 'errors\n'
                 '   (see Why does a_tuple[i] += [‘item’] raise an exception '
                 'when the\n'
                 '   addition works?), but this behavior is in fact part of '
                 'the data\n'
                 '   model.\n'
                 '\n'
                 'object.__neg__(self)\n'
                 'object.__pos__(self)\n'
                 'object.__abs__(self)\n'
                 'object.__invert__(self)\n'
                 '\n'
                 '   Called to implement the unary arithmetic operations ("-", '
                 '"+",\n'
                 '   "abs()" and "~").\n'
                 '\n'
                 'object.__complex__(self)\n'
                 'object.__int__(self)\n'
                 'object.__float__(self)\n'
                 '\n'
                 '   Called to implement the built-in functions "complex()", '
                 '"int()" and\n'
                 '   "float()".  Should return a value of the appropriate '
                 'type.\n'
                 '\n'
                 'object.__index__(self)\n'
                 '\n'
                 '   Called to implement "operator.index()", and whenever '
                 'Python needs\n'
                 '   to losslessly convert the numeric object to an integer '
                 'object (such\n'
                 '   as in slicing, or in the built-in "bin()", "hex()" and '
                 '"oct()"\n'
                 '   functions). Presence of this method indicates that the '
                 'numeric\n'
                 '   object is an integer type.  Must return an integer.\n'
                 '\n'
                 '   If "__int__()", "__float__()" and "__complex__()" are not '
                 'defined\n'
                 '   then corresponding built-in functions "int()", "float()" '
                 'and\n'
                 '   "complex()" fall back to "__index__()".\n'
                 '\n'
                 'object.__round__(self[, ndigits])\n'
                 'object.__trunc__(self)\n'
                 'object.__floor__(self)\n'
                 'object.__ceil__(self)\n'
                 '\n'
                 '   Called to implement the built-in function "round()" and '
                 '"math"\n'
                 '   functions "trunc()", "floor()" and "ceil()". Unless '
                 '*ndigits* is\n'
                 '   passed to "__round__()" all these methods should return '
                 'the value\n'
                 '   of the object truncated to an "Integral" (typically an '
                 '"int").\n'
                 '\n'
                 '   The built-in function "int()" falls back to "__trunc__()" '
                 'if\n'
                 '   neither "__int__()" nor "__index__()" is defined.\n'
                 '\n'
                 '   Changed in version 3.11: The delegation of "int()" to '
                 '"__trunc__()"\n'
                 '   is deprecated.\n'
                 '\n'
                 '\n'
                 'With Statement Context Managers\n'
                 '===============================\n'
                 '\n'
                 'A *context manager* is an object that defines the runtime '
                 'context to\n'
                 'be established when executing a "with" statement. The '
                 'context manager\n'
                 'handles the entry into, and the exit from, the desired '
                 'runtime context\n'
                 'for the execution of the block of code.  Context managers '
                 'are normally\n'
                 'invoked using the "with" statement (described in section The '
                 'with\n'
                 'statement), but can also be used by directly invoking their '
                 'methods.\n'
                 '\n'
                 'Typical uses of context managers include saving and '
                 'restoring various\n'
                 'kinds of global state, locking and unlocking resources, '
                 'closing opened\n'
                 'files, etc.\n'
                 '\n'
                 'For more information on context managers, see Context '
                 'Manager Types.\n'
                 '\n'
                 'object.__enter__(self)\n'
                 '\n'
                 '   Enter the runtime context related to this object. The '
                 '"with"\n'
                 '   statement will bind this method’s return value to the '
                 'target(s)\n'
                 '   specified in the "as" clause of the statement, if any.\n'
                 '\n'
                 'object.__exit__(self, exc_type, exc_value, traceback)\n'
                 '\n'
                 '   Exit the runtime context related to this object. The '
                 'parameters\n'
                 '   describe the exception that caused the context to be '
                 'exited. If the\n'
                 '   context was exited without an exception, all three '
                 'arguments will\n'
                 '   be "None".\n'
                 '\n'
                 '   If an exception is supplied, and the method wishes to '
                 'suppress the\n'
                 '   exception (i.e., prevent it from being propagated), it '
                 'should\n'
                 '   return a true value. Otherwise, the exception will be '
                 'processed\n'
                 '   normally upon exit from this method.\n'
                 '\n'
                 '   Note that "__exit__()" methods should not reraise the '
                 'passed-in\n'
                 '   exception; this is the caller’s responsibility.\n'
                 '\n'
                 'See also:\n'
                 '\n'
                 '  **PEP 343** - The “with” statement\n'
                 '     The specification, background, and examples for the '
                 'Python "with"\n'
                 '     statement.\n'
                 '\n'
                 '\n'
                 'Customizing positional arguments in class pattern matching\n'
                 '==========================================================\n'
                 '\n'
                 'When using a class name in a pattern, positional arguments '
                 'in the\n'
                 'pattern are not allowed by default, i.e. "case MyClass(x, '
                 'y)" is\n'
                 'typically invalid without special support in "MyClass". To '
                 'be able to\n'
                 'use that kind of pattern, the class needs to define a '
                 '*__match_args__*\n'
                 'attribute.\n'
                 '\n'
                 'object.__match_args__\n'
                 '\n'
                 '   This class variable can be assigned a tuple of strings. '
                 'When this\n'
                 '   class is used in a class pattern with positional '
                 'arguments, each\n'
                 '   positional argument will be converted into a keyword '
                 'argument,\n'
                 '   using the corresponding value in *__match_args__* as the '
                 'keyword.\n'
                 '   The absence of this attribute is equivalent to setting it '
                 'to "()".\n'
                 '\n'
                 'For example, if "MyClass.__match_args__" is "("left", '
                 '"center",\n'
                 '"right")" that means that "case MyClass(x, y)" is equivalent '
                 'to "case\n'
                 'MyClass(left=x, center=y)". Note that the number of '
                 'arguments in the\n'
                 'pattern must be smaller than or equal to the number of '
                 'elements in\n'
                 '*__match_args__*; if it is larger, the pattern match attempt '
                 'will\n'
                 'raise a "TypeError".\n'
                 '\n'
                 'New in version 3.10.\n'
                 '\n'
                 'See also:\n'
                 '\n'
                 '  **PEP 634** - Structural Pattern Matching\n'
                 '     The specification for the Python "match" statement.\n'
                 '\n'
                 '\n'
                 'Special method lookup\n'
                 '=====================\n'
                 '\n'
                 'For custom classes, implicit invocations of special methods '
                 'are only\n'
                 'guaranteed to work correctly if defined on an object’s type, '
                 'not in\n'
                 'the object’s instance dictionary.  That behaviour is the '
                 'reason why\n'
                 'the following code raises an exception:\n'
                 '\n'
                 '   >>> class C:\n'
                 '   ...     pass\n'
                 '   ...\n'
                 '   >>> c = C()\n'
                 '   >>> c.__len__ = lambda: 5\n'
                 '   >>> len(c)\n'
                 '   Traceback (most recent call last):\n'
                 '     File "<stdin>", line 1, in <module>\n'
                 "   TypeError: object of type 'C' has no len()\n"
                 '\n'
                 'The rationale behind this behaviour lies with a number of '
                 'special\n'
                 'methods such as "__hash__()" and "__repr__()" that are '
                 'implemented by\n'
                 'all objects, including type objects. If the implicit lookup '
                 'of these\n'
                 'methods used the conventional lookup process, they would '
                 'fail when\n'
                 'invoked on the type object itself:\n'
                 '\n'
                 '   >>> 1 .__hash__() == hash(1)\n'
                 '   True\n'
                 '   >>> int.__hash__() == hash(int)\n'
                 '   Traceback (most recent call last):\n'
                 '     File "<stdin>", line 1, in <module>\n'
                 "   TypeError: descriptor '__hash__' of 'int' object needs an "
                 'argument\n'
                 '\n'
                 'Incorrectly attempting to invoke an unbound method of a '
                 'class in this\n'
                 'way is sometimes referred to as ‘metaclass confusion’, and '
                 'is avoided\n'
                 'by bypassing the instance when looking up special methods:\n'
                 '\n'
                 '   >>> type(1).__hash__(1) == hash(1)\n'
                 '   True\n'
                 '   >>> type(int).__hash__(int) == hash(int)\n'
                 '   True\n'
                 '\n'
                 'In addition to bypassing any instance attributes in the '
                 'interest of\n'
                 'correctness, implicit special method lookup generally also '
                 'bypasses\n'
                 'the "__getattribute__()" method even of the object’s '
                 'metaclass:\n'
                 '\n'
                 '   >>> class Meta(type):\n'
                 '   ...     def __getattribute__(*args):\n'
                 '   ...         print("Metaclass getattribute invoked")\n'
                 '   ...         return type.__getattribute__(*args)\n'
                 '   ...\n'
                 '   >>> class C(object, metaclass=Meta):\n'
                 '   ...     def __len__(self):\n'
                 '   ...         return 10\n'
                 '   ...     def __getattribute__(*args):\n'
                 '   ...         print("Class getattribute invoked")\n'
                 '   ...         return object.__getattribute__(*args)\n'
                 '   ...\n'
                 '   >>> c = C()\n'
                 '   >>> c.__len__()                 # Explicit lookup via '
                 'instance\n'
                 '   Class getattribute invoked\n'
                 '   10\n'
                 '   >>> type(c).__len__(c)          # Explicit lookup via '
                 'type\n'
                 '   Metaclass getattribute invoked\n'
                 '   10\n'
                 '   >>> len(c)                      # Implicit lookup\n'
                 '   10\n'
                 '\n'
                 'Bypassing the "__getattribute__()" machinery in this fashion '
                 'provides\n'
                 'significant scope for speed optimisations within the '
                 'interpreter, at\n'
                 'the cost of some flexibility in the handling of special '
                 'methods (the\n'
                 'special method *must* be set on the class object itself in '
                 'order to be\n'
                 'consistently invoked by the interpreter).\n',
 'string-methods': 'String Methods\n'
                   '**************\n'
                   '\n'
                   'Strings implement all of the common sequence operations, '
                   'along with\n'
                   'the additional methods described below.\n'
                   '\n'
                   'Strings also support two styles of string formatting, one '
                   'providing a\n'
                   'large degree of flexibility and customization (see '
                   '"str.format()",\n'
                   'Format String Syntax and Custom String Formatting) and the '
                   'other based\n'
                   'on C "printf" style formatting that handles a narrower '
                   'range of types\n'
                   'and is slightly harder to use correctly, but is often '
                   'faster for the\n'
                   'cases it can handle (printf-style String Formatting).\n'
                   '\n'
                   'The Text Processing Services section of the standard '
                   'library covers a\n'
                   'number of other modules that provide various text related '
                   'utilities\n'
                   '(including regular expression support in the "re" '
                   'module).\n'
                   '\n'
                   'str.capitalize()\n'
                   '\n'
                   '   Return a copy of the string with its first character '
                   'capitalized\n'
                   '   and the rest lowercased.\n'
                   '\n'
                   '   Changed in version 3.8: The first character is now put '
                   'into\n'
                   '   titlecase rather than uppercase. This means that '
                   'characters like\n'
                   '   digraphs will only have their first letter capitalized, '
                   'instead of\n'
                   '   the full character.\n'
                   '\n'
                   'str.casefold()\n'
                   '\n'
                   '   Return a casefolded copy of the string. Casefolded '
                   'strings may be\n'
                   '   used for caseless matching.\n'
                   '\n'
                   '   Casefolding is similar to lowercasing but more '
                   'aggressive because\n'
                   '   it is intended to remove all case distinctions in a '
                   'string. For\n'
                   '   example, the German lowercase letter "\'ß\'" is '
                   'equivalent to ""ss"".\n'
                   '   Since it is already lowercase, "lower()" would do '
                   'nothing to "\'ß\'";\n'
                   '   "casefold()" converts it to ""ss"".\n'
                   '\n'
                   '   The casefolding algorithm is described in section 3.13 '
                   'of the\n'
                   '   Unicode Standard.\n'
                   '\n'
                   '   New in version 3.3.\n'
                   '\n'
                   'str.center(width[, fillchar])\n'
                   '\n'
                   '   Return centered in a string of length *width*. Padding '
                   'is done\n'
                   '   using the specified *fillchar* (default is an ASCII '
                   'space). The\n'
                   '   original string is returned if *width* is less than or '
                   'equal to\n'
                   '   "len(s)".\n'
                   '\n'
                   'str.count(sub[, start[, end]])\n'
                   '\n'
                   '   Return the number of non-overlapping occurrences of '
                   'substring *sub*\n'
                   '   in the range [*start*, *end*].  Optional arguments '
                   '*start* and\n'
                   '   *end* are interpreted as in slice notation.\n'
                   '\n'
                   '   If *sub* is empty, returns the number of empty strings '
                   'between\n'
                   '   characters which is the length of the string plus one.\n'
                   '\n'
                   "str.encode(encoding='utf-8', errors='strict')\n"
                   '\n'
                   '   Return the string encoded to "bytes".\n'
                   '\n'
                   '   *encoding* defaults to "\'utf-8\'"; see Standard '
                   'Encodings for\n'
                   '   possible values.\n'
                   '\n'
                   '   *errors* controls how encoding errors are handled. If '
                   '"\'strict\'"\n'
                   '   (the default), a "UnicodeError" exception is raised. '
                   'Other possible\n'
                   '   values are "\'ignore\'", "\'replace\'", '
                   '"\'xmlcharrefreplace\'",\n'
                   '   "\'backslashreplace\'" and any other name registered '
                   'via\n'
                   '   "codecs.register_error()". See Error Handlers for '
                   'details.\n'
                   '\n'
                   '   For performance reasons, the value of *errors* is not '
                   'checked for\n'
                   '   validity unless an encoding error actually occurs, '
                   'Python\n'
                   '   Development Mode is enabled or a debug build is used.\n'
                   '\n'
                   '   Changed in version 3.1: Added support for keyword '
                   'arguments.\n'
                   '\n'
                   '   Changed in version 3.9: The value of the *errors* '
                   'argument is now\n'
                   '   checked in Python Development Mode and in debug mode.\n'
                   '\n'
                   'str.endswith(suffix[, start[, end]])\n'
                   '\n'
                   '   Return "True" if the string ends with the specified '
                   '*suffix*,\n'
                   '   otherwise return "False".  *suffix* can also be a tuple '
                   'of suffixes\n'
                   '   to look for.  With optional *start*, test beginning at '
                   'that\n'
                   '   position.  With optional *end*, stop comparing at that '
                   'position.\n'
                   '\n'
                   'str.expandtabs(tabsize=8)\n'
                   '\n'
                   '   Return a copy of the string where all tab characters '
                   'are replaced\n'
                   '   by one or more spaces, depending on the current column '
                   'and the\n'
                   '   given tab size.  Tab positions occur every *tabsize* '
                   'characters\n'
                   '   (default is 8, giving tab positions at columns 0, 8, 16 '
                   'and so on).\n'
                   '   To expand the string, the current column is set to zero '
                   'and the\n'
                   '   string is examined character by character.  If the '
                   'character is a\n'
                   '   tab ("\\t"), one or more space characters are inserted '
                   'in the result\n'
                   '   until the current column is equal to the next tab '
                   'position. (The\n'
                   '   tab character itself is not copied.)  If the character '
                   'is a newline\n'
                   '   ("\\n") or return ("\\r"), it is copied and the current '
                   'column is\n'
                   '   reset to zero.  Any other character is copied unchanged '
                   'and the\n'
                   '   current column is incremented by one regardless of how '
                   'the\n'
                   '   character is represented when printed.\n'
                   '\n'
                   "   >>> '01\\t012\\t0123\\t01234'.expandtabs()\n"
                   "   '01      012     0123    01234'\n"
                   "   >>> '01\\t012\\t0123\\t01234'.expandtabs(4)\n"
                   "   '01  012 0123    01234'\n"
                   '\n'
                   'str.find(sub[, start[, end]])\n'
                   '\n'
                   '   Return the lowest index in the string where substring '
                   '*sub* is\n'
                   '   found within the slice "s[start:end]".  Optional '
                   'arguments *start*\n'
                   '   and *end* are interpreted as in slice notation.  Return '
                   '"-1" if\n'
                   '   *sub* is not found.\n'
                   '\n'
                   '   Note:\n'
                   '\n'
                   '     The "find()" method should be used only if you need '
                   'to know the\n'
                   '     position of *sub*.  To check if *sub* is a substring '
                   'or not, use\n'
                   '     the "in" operator:\n'
                   '\n'
                   "        >>> 'Py' in 'Python'\n"
                   '        True\n'
                   '\n'
                   'str.format(*args, **kwargs)\n'
                   '\n'
                   '   Perform a string formatting operation.  The string on '
                   'which this\n'
                   '   method is called can contain literal text or '
                   'replacement fields\n'
                   '   delimited by braces "{}".  Each replacement field '
                   'contains either\n'
                   '   the numeric index of a positional argument, or the name '
                   'of a\n'
                   '   keyword argument.  Returns a copy of the string where '
                   'each\n'
                   '   replacement field is replaced with the string value of '
                   'the\n'
                   '   corresponding argument.\n'
                   '\n'
                   '   >>> "The sum of 1 + 2 is {0}".format(1+2)\n'
                   "   'The sum of 1 + 2 is 3'\n"
                   '\n'
                   '   See Format String Syntax for a description of the '
                   'various\n'
                   '   formatting options that can be specified in format '
                   'strings.\n'
                   '\n'
                   '   Note:\n'
                   '\n'
                   '     When formatting a number ("int", "float", "complex",\n'
                   '     "decimal.Decimal" and subclasses) with the "n" type '
                   '(ex:\n'
                   '     "\'{:n}\'.format(1234)"), the function temporarily '
                   'sets the\n'
                   '     "LC_CTYPE" locale to the "LC_NUMERIC" locale to '
                   'decode\n'
                   '     "decimal_point" and "thousands_sep" fields of '
                   '"localeconv()" if\n'
                   '     they are non-ASCII or longer than 1 byte, and the '
                   '"LC_NUMERIC"\n'
                   '     locale is different than the "LC_CTYPE" locale.  This '
                   'temporary\n'
                   '     change affects other threads.\n'
                   '\n'
                   '   Changed in version 3.7: When formatting a number with '
                   'the "n" type,\n'
                   '   the function sets temporarily the "LC_CTYPE" locale to '
                   'the\n'
                   '   "LC_NUMERIC" locale in some cases.\n'
                   '\n'
                   'str.format_map(mapping)\n'
                   '\n'
                   '   Similar to "str.format(**mapping)", except that '
                   '"mapping" is used\n'
                   '   directly and not copied to a "dict".  This is useful if '
                   'for example\n'
                   '   "mapping" is a dict subclass:\n'
                   '\n'
                   '   >>> class Default(dict):\n'
                   '   ...     def __missing__(self, key):\n'
                   '   ...         return key\n'
                   '   ...\n'
                   "   >>> '{name} was born in "
                   "{country}'.format_map(Default(name='Guido'))\n"
                   "   'Guido was born in country'\n"
                   '\n'
                   '   New in version 3.2.\n'
                   '\n'
                   'str.index(sub[, start[, end]])\n'
                   '\n'
                   '   Like "find()", but raise "ValueError" when the '
                   'substring is not\n'
                   '   found.\n'
                   '\n'
                   'str.isalnum()\n'
                   '\n'
                   '   Return "True" if all characters in the string are '
                   'alphanumeric and\n'
                   '   there is at least one character, "False" otherwise.  A '
                   'character\n'
                   '   "c" is alphanumeric if one of the following returns '
                   '"True":\n'
                   '   "c.isalpha()", "c.isdecimal()", "c.isdigit()", or '
                   '"c.isnumeric()".\n'
                   '\n'
                   'str.isalpha()\n'
                   '\n'
                   '   Return "True" if all characters in the string are '
                   'alphabetic and\n'
                   '   there is at least one character, "False" otherwise.  '
                   'Alphabetic\n'
                   '   characters are those characters defined in the Unicode '
                   'character\n'
                   '   database as “Letter”, i.e., those with general category '
                   'property\n'
                   '   being one of “Lm”, “Lt”, “Lu”, “Ll”, or “Lo”.  Note '
                   'that this is\n'
                   '   different from the “Alphabetic” property defined in the '
                   'Unicode\n'
                   '   Standard.\n'
                   '\n'
                   'str.isascii()\n'
                   '\n'
                   '   Return "True" if the string is empty or all characters '
                   'in the\n'
                   '   string are ASCII, "False" otherwise. ASCII characters '
                   'have code\n'
                   '   points in the range U+0000-U+007F.\n'
                   '\n'
                   '   New in version 3.7.\n'
                   '\n'
                   'str.isdecimal()\n'
                   '\n'
                   '   Return "True" if all characters in the string are '
                   'decimal\n'
                   '   characters and there is at least one character, "False" '
                   'otherwise.\n'
                   '   Decimal characters are those that can be used to form '
                   'numbers in\n'
                   '   base 10, e.g. U+0660, ARABIC-INDIC DIGIT ZERO.  '
                   'Formally a decimal\n'
                   '   character is a character in the Unicode General '
                   'Category “Nd”.\n'
                   '\n'
                   'str.isdigit()\n'
                   '\n'
                   '   Return "True" if all characters in the string are '
                   'digits and there\n'
                   '   is at least one character, "False" otherwise.  Digits '
                   'include\n'
                   '   decimal characters and digits that need special '
                   'handling, such as\n'
                   '   the compatibility superscript digits. This covers '
                   'digits which\n'
                   '   cannot be used to form numbers in base 10, like the '
                   'Kharosthi\n'
                   '   numbers.  Formally, a digit is a character that has the '
                   'property\n'
                   '   value Numeric_Type=Digit or Numeric_Type=Decimal.\n'
                   '\n'
                   'str.isidentifier()\n'
                   '\n'
                   '   Return "True" if the string is a valid identifier '
                   'according to the\n'
                   '   language definition, section Identifiers and keywords.\n'
                   '\n'
                   '   Call "keyword.iskeyword()" to test whether string "s" '
                   'is a reserved\n'
                   '   identifier, such as "def" and "class".\n'
                   '\n'
                   '   Example:\n'
                   '\n'
                   '      >>> from keyword import iskeyword\n'
                   '\n'
                   "      >>> 'hello'.isidentifier(), iskeyword('hello')\n"
                   '      (True, False)\n'
                   "      >>> 'def'.isidentifier(), iskeyword('def')\n"
                   '      (True, True)\n'
                   '\n'
                   'str.islower()\n'
                   '\n'
                   '   Return "True" if all cased characters [4] in the string '
                   'are\n'
                   '   lowercase and there is at least one cased character, '
                   '"False"\n'
                   '   otherwise.\n'
                   '\n'
                   'str.isnumeric()\n'
                   '\n'
                   '   Return "True" if all characters in the string are '
                   'numeric\n'
                   '   characters, and there is at least one character, '
                   '"False" otherwise.\n'
                   '   Numeric characters include digit characters, and all '
                   'characters\n'
                   '   that have the Unicode numeric value property, e.g. '
                   'U+2155, VULGAR\n'
                   '   FRACTION ONE FIFTH.  Formally, numeric characters are '
                   'those with\n'
                   '   the property value Numeric_Type=Digit, '
                   'Numeric_Type=Decimal or\n'
                   '   Numeric_Type=Numeric.\n'
                   '\n'
                   'str.isprintable()\n'
                   '\n'
                   '   Return "True" if all characters in the string are '
                   'printable or the\n'
                   '   string is empty, "False" otherwise.  Nonprintable '
                   'characters are\n'
                   '   those characters defined in the Unicode character '
                   'database as\n'
                   '   “Other” or “Separator”, excepting the ASCII space '
                   '(0x20) which is\n'
                   '   considered printable.  (Note that printable characters '
                   'in this\n'
                   '   context are those which should not be escaped when '
                   '"repr()" is\n'
                   '   invoked on a string.  It has no bearing on the handling '
                   'of strings\n'
                   '   written to "sys.stdout" or "sys.stderr".)\n'
                   '\n'
                   'str.isspace()\n'
                   '\n'
                   '   Return "True" if there are only whitespace characters '
                   'in the string\n'
                   '   and there is at least one character, "False" '
                   'otherwise.\n'
                   '\n'
                   '   A character is *whitespace* if in the Unicode character '
                   'database\n'
                   '   (see "unicodedata"), either its general category is '
                   '"Zs"\n'
                   '   (“Separator, space”), or its bidirectional class is one '
                   'of "WS",\n'
                   '   "B", or "S".\n'
                   '\n'
                   'str.istitle()\n'
                   '\n'
                   '   Return "True" if the string is a titlecased string and '
                   'there is at\n'
                   '   least one character, for example uppercase characters '
                   'may only\n'
                   '   follow uncased characters and lowercase characters only '
                   'cased ones.\n'
                   '   Return "False" otherwise.\n'
                   '\n'
                   'str.isupper()\n'
                   '\n'
                   '   Return "True" if all cased characters [4] in the string '
                   'are\n'
                   '   uppercase and there is at least one cased character, '
                   '"False"\n'
                   '   otherwise.\n'
                   '\n'
                   "   >>> 'BANANA'.isupper()\n"
                   '   True\n'
                   "   >>> 'banana'.isupper()\n"
                   '   False\n'
                   "   >>> 'baNana'.isupper()\n"
                   '   False\n'
                   "   >>> ' '.isupper()\n"
                   '   False\n'
                   '\n'
                   'str.join(iterable)\n'
                   '\n'
                   '   Return a string which is the concatenation of the '
                   'strings in\n'
                   '   *iterable*. A "TypeError" will be raised if there are '
                   'any non-\n'
                   '   string values in *iterable*, including "bytes" '
                   'objects.  The\n'
                   '   separator between elements is the string providing this '
                   'method.\n'
                   '\n'
                   'str.ljust(width[, fillchar])\n'
                   '\n'
                   '   Return the string left justified in a string of length '
                   '*width*.\n'
                   '   Padding is done using the specified *fillchar* (default '
                   'is an ASCII\n'
                   '   space). The original string is returned if *width* is '
                   'less than or\n'
                   '   equal to "len(s)".\n'
                   '\n'
                   'str.lower()\n'
                   '\n'
                   '   Return a copy of the string with all the cased '
                   'characters [4]\n'
                   '   converted to lowercase.\n'
                   '\n'
                   '   The lowercasing algorithm used is described in section '
                   '3.13 of the\n'
                   '   Unicode Standard.\n'
                   '\n'
                   'str.lstrip([chars])\n'
                   '\n'
                   '   Return a copy of the string with leading characters '
                   'removed.  The\n'
                   '   *chars* argument is a string specifying the set of '
                   'characters to be\n'
                   '   removed.  If omitted or "None", the *chars* argument '
                   'defaults to\n'
                   '   removing whitespace.  The *chars* argument is not a '
                   'prefix; rather,\n'
                   '   all combinations of its values are stripped:\n'
                   '\n'
                   "      >>> '   spacious   '.lstrip()\n"
                   "      'spacious   '\n"
                   "      >>> 'www.example.com'.lstrip('cmowz.')\n"
                   "      'example.com'\n"
                   '\n'
                   '   See "str.removeprefix()" for a method that will remove '
                   'a single\n'
                   '   prefix string rather than all of a set of characters.  '
                   'For example:\n'
                   '\n'
                   "      >>> 'Arthur: three!'.lstrip('Arthur: ')\n"
                   "      'ee!'\n"
                   "      >>> 'Arthur: three!'.removeprefix('Arthur: ')\n"
                   "      'three!'\n"
                   '\n'
                   'static str.maketrans(x[, y[, z]])\n'
                   '\n'
                   '   This static method returns a translation table usable '
                   'for\n'
                   '   "str.translate()".\n'
                   '\n'
                   '   If there is only one argument, it must be a dictionary '
                   'mapping\n'
                   '   Unicode ordinals (integers) or characters (strings of '
                   'length 1) to\n'
                   '   Unicode ordinals, strings (of arbitrary lengths) or '
                   '"None".\n'
                   '   Character keys will then be converted to ordinals.\n'
                   '\n'
                   '   If there are two arguments, they must be strings of '
                   'equal length,\n'
                   '   and in the resulting dictionary, each character in x '
                   'will be mapped\n'
                   '   to the character at the same position in y.  If there '
                   'is a third\n'
                   '   argument, it must be a string, whose characters will be '
                   'mapped to\n'
                   '   "None" in the result.\n'
                   '\n'
                   'str.partition(sep)\n'
                   '\n'
                   '   Split the string at the first occurrence of *sep*, and '
                   'return a\n'
                   '   3-tuple containing the part before the separator, the '
                   'separator\n'
                   '   itself, and the part after the separator.  If the '
                   'separator is not\n'
                   '   found, return a 3-tuple containing the string itself, '
                   'followed by\n'
                   '   two empty strings.\n'
                   '\n'
                   'str.removeprefix(prefix, /)\n'
                   '\n'
                   '   If the string starts with the *prefix* string, return\n'
                   '   "string[len(prefix):]". Otherwise, return a copy of the '
                   'original\n'
                   '   string:\n'
                   '\n'
                   "      >>> 'TestHook'.removeprefix('Test')\n"
                   "      'Hook'\n"
                   "      >>> 'BaseTestCase'.removeprefix('Test')\n"
                   "      'BaseTestCase'\n"
                   '\n'
                   '   New in version 3.9.\n'
                   '\n'
                   'str.removesuffix(suffix, /)\n'
                   '\n'
                   '   If the string ends with the *suffix* string and that '
                   '*suffix* is\n'
                   '   not empty, return "string[:-len(suffix)]". Otherwise, '
                   'return a copy\n'
                   '   of the original string:\n'
                   '\n'
                   "      >>> 'MiscTests'.removesuffix('Tests')\n"
                   "      'Misc'\n"
                   "      >>> 'TmpDirMixin'.removesuffix('Tests')\n"
                   "      'TmpDirMixin'\n"
                   '\n'
                   '   New in version 3.9.\n'
                   '\n'
                   'str.replace(old, new[, count])\n'
                   '\n'
                   '   Return a copy of the string with all occurrences of '
                   'substring *old*\n'
                   '   replaced by *new*.  If the optional argument *count* is '
                   'given, only\n'
                   '   the first *count* occurrences are replaced.\n'
                   '\n'
                   'str.rfind(sub[, start[, end]])\n'
                   '\n'
                   '   Return the highest index in the string where substring '
                   '*sub* is\n'
                   '   found, such that *sub* is contained within '
                   '"s[start:end]".\n'
                   '   Optional arguments *start* and *end* are interpreted as '
                   'in slice\n'
                   '   notation.  Return "-1" on failure.\n'
                   '\n'
                   'str.rindex(sub[, start[, end]])\n'
                   '\n'
                   '   Like "rfind()" but raises "ValueError" when the '
                   'substring *sub* is\n'
                   '   not found.\n'
                   '\n'
                   'str.rjust(width[, fillchar])\n'
                   '\n'
