
<h3>0.13.0: June 26 2001</h3>
<ul>
  <li>lots of cleanups</li>
  <li>fixed a C++ compilation problem</li>
  <li>couple of fixes to xsltSaveTo()</li>
  <li>try to fix Docbook-xslt-1.4 and chunking, updated the regression test
    with them</li>
  <li>fixed pattern compilation and priorities problems</li>
  <li>Patches for Windows and MSC project mostly contributed by Yon Derek</li>
  <li>update to the Tutorial by John Fleck</li>
  <li>William fixed bugs in templates and for-each functions</li>
  <li>added a new interface xsltRunStylesheet() for a more flexible output
    (incomplete), added -o option to xsltproc</li>
</ul>

<h3>0.12.0: June 18 2001</h3>
<ul>
  <li>fixed a dozen of bugs reported</li>
  <li>HTML generation should be quite better (requires libxml-2.3.11 upgrade
    too)</li>
  <li>William fixed some problems with document()</li>
  <li>Fix namespace nodes selection and copy (requires libxml-2.3.11 upgrade
    too)</li>
  <li>John Fleck added a<a href="tutorial/libxslttutorial.html">
  tutorial</a></li>
  <li>Fixes for namespace handling when evaluating variables</li>
  <li>XInclude global flag added to process XInclude on document() if
    requested</li>
  <li>made xsltproc --version more detailed</li>
</ul>

<h3>0.11.0: June 1 2001</h3>

<p>Mostly a bug fix release.</p>
<ul>
  <li>integration of catalogs from xsltproc</li>
  <li>added --version to xsltproc for bug reporting</li>
  <li>fixed errors when handling ID in external parsed entities</li>
  <li>document() should hopefully work correctly but ...</li>
  <li>fixed bug with PI and comments processing</li>
  <li>William fixed the XPath string functions when using unicode</li>
</ul>

<h3>0.10.0: May 19 2001</h3>
<ul>
  <li>cleanups to make stylesheet read-only (not 100% complete)</li>
  <li>fixed URI resolution in document()</li>
  <li>force all XPath expression to be compiled at stylesheet parsing time,
    even if unused ...</li>
  <li>Fixed HTML default output detection</li>
  <li>Fixed double attribute generation #54446</li>
  <li>Fixed {{ handling in attributes #54451</li>
  <li>More tests and speedups for DocBook document transformations</li>
  <li>Fixed a really bad race like bug in xsltCopyTreeList()</li>
  <li>added a documentation on the libxslt internals</li>
  <li>William Brack and Bjorn Reese improved format-number()</li>
  <li>Fixed multiple sort, it should really work now</li>
  <li>added a --docbook option for SGML DocBook input (hackish)</li>
  <li>a number of other bug fixes and regression test added as people were
    submitting them</li>
</ul>

<h3>0.9.0: May 3 2001</h3>
<ul>
  <li>lot of various bugfixes, extended the regression suite</li>
  <li>xsltproc should work with multiple params</li>
  <li>added an option to use xsltproc with HTML input</li>
  <li>improved the stylesheet compilation, processing of complex stylesheets
    should be faster</li>
  <li>using the same stylesheet for concurrent processing on multithreaded
    programs should work now</li>
  <li>fixed another batch of namespace handling problems</li>
  <li>Implemented multiple level of sorting</li>
</ul>

<h3>0.8.0: Apr 22 2001</h3>
<ul>
  <li>fixed ansidecl.h problem</li>
  <li>fixed unparsed-entity-uri() and generate-id()</li>
  <li>sort semantic fixes and priority prob from William M. Brack</li>
  <li>fixed namespace handling problems in XPath expression computations
    (requires libxml-2.3.7)</li>
  <li>fixes to current() and key()</li>
  <li>other, smaller fixes, lots of testing with N Walsh DocBook HTML
    stylesheets</li>
</ul>

<h3>0.7.0: Apr 10 2001</h3>
<ul>
  <li>cleanup using stricter compiler flags</li>
  <li>command line parameter passing</li>
  <li>fix to xsltApplyTemplates from William M. Brack</li>
  <li>added the XSLTMark in the regression tests as well as document()</li>
</ul>

<h3>0.6.0: Mar 22 2001</h3>
<ul>
  <li>another beta</li>
  <li>requires 2.3.5, which provide XPath expression compilation support</li>
  <li>document() extension should function properly</li>
  <li>fixed a number or reported bugs</li>
</ul>

<h3>0.5.0: Mar 10 2001</h3>
<ul>
  <li>fifth beta</li>
  <li>some optimization work, for the moment 2 XSLT transform cannot use the
    same stylesheet at the same time (to be fixed)</li>
  <li>fixed problems with handling of tree results</li>
  <li>fixed a reported strip-spaces problem</li>
  <li>added more reported/fixed bugs to the test suite</li>
  <li>incorporated William M. Brack fix for imports and global variables as
    well as patch for with-param support in apply-templates</li>
  <li>a bug fix on for-each</li>
</ul>

<h3>0.4.0: Mar 1 2001</h3>
<ul>
  <li>fourth beta test, released at the same time of libxml2-2.3.3</li>
  <li>bug fixes</li>
  <li>some optimization</li>
  <li>started implement extension support, not finished</li>
  <li>implemented but not tested multiple file output</li>
</ul>

<h3>0.3.0: Feb 24 2001</h3>
<ul>
  <li>third beta test, released at the same time of libxml2-2.3.2</li>
  <li>lot of bug fixes</li>
  <li>some optimization</li>
  <li>added DocBook XSL based testsuite</li>
</ul>

<h3>0.2.0: Feb 15 2001</h3>
<ul>
  <li>second beta version, released at the same time as libxml2-2.3.1</li>
  <li>getting close to feature completion, lot of bug fixes, some in the HTML
    and XPath support of libxml</li>
  <li>start becoming usable for real work. This version can now regenerate
    the XML 2e HTML from the original XML sources and the associated
    stylesheets (in <a
    href="http://www.w3.org/TR/REC-xml#b4d250b6c21">section I of the XML
    REC</a>)</li>
  <li>Still misses extension element/function/prefixes support. Support of
    key() and document() is not complete</li>
</ul>

<h3>0.1.0: Feb 8 2001</h3>
<ul>
  <li>first beta version, released at the same time as libxml2-2.3.0</li>
  <li>lots of bug fixes, first "testing" version, but incomplete</li>
</ul>

<h3>0.0.1: Jan 25 2001</h3>
<ul>
  <li>first alpha version released at the same time as libxml2-2.2.12</li>
  <li>Framework in place, should work on simple examples, but far from being
    feature complete</li>
</ul>

<h2><a name="xsltproc">The xsltproc tool</a></h2>

<p>This program is the simplest way to use libxslt: from the command line. It
is also used for doing the regression tests of the library.</p>

<p>It takes as first argument the path or URL to an XSLT stylesheet, the next
arguments are filenames or URIs of the inputs to be processed. The output of
the processing is redirected on the standard output. There is actually a few
more options available:</p>
<pre>orchis:~ -&gt; xsltproc
Usage: xsltproc [options] stylesheet file [file ...]
   Options:
      --version or -V: show the version of libxml and libxslt used
      --verbose or -v: show logs of what's happening
      --output file or -o file: save to a given file
      --timing: display the time used
      --repeat: run the transformation 20 times
      --debug: dump the tree of the result instead
      --novalid: skip the DTD loading phase
      --noout: do not dump the result
      --maxdepth val : increase the maximum depth
      --html: the input document is(are) an HTML file(s)
      --docbook: the input document is SGML docbook
      --param name value : pass a (parameter,value) pair
      --nonet refuse to fetch DTDs or entities over network
      --warnnet warn against fetching over the network
      --catalogs : use the catalogs from $SGML_CATALOG_FILES
      --xinclude : do XInclude processing on document input
      --profile or --norman : dump profiling information 
orchis:~ -&gt;</pre>

<h2><a name="DocBook">DocBook</a></h2>

<p><img src="duck.png" align="right" alt="The duck picture"></p>

<p><a href="http://www.oasis-open.org/committees/docbook/">DocBook</a> is an
XML/SGML vocabulary particularly well suited to books and papers about
computer hardware and software.</p>

<p>xsltproc and libxslt are not specifically dependant on DocBook, but since
a lot of people use xsltproc and libxml2 for DocBook formatting, here are a
few pointers and information which may be helpful:</p>
<ul>
  <li>The <a href="http://www.oasis-open.org/committees/docbook/">DocBook
    homepage at Oasis</a> you should find pointers there on all the lastest
    versions of the DTDs and XSLT stylesheets</li>
  <li><a href="http://www.docbook.org/">DocBook: The Definitive Guide</a> is
    the official reference documentation for DocBook.</li>
  <li><a
    href="https://sourceforge.net/docman/index.php?group_id=21935">DocBook
    Open Repository</a> contains a lot of information about DocBook</li>
  <li>Bob Stayton provides a <a href="http://www.sagehill.net/">lot of
    resources</a> and consulting services around DocBook.</li>
  <li>Here is a <a href="/buildDocBookCatalog">shell script</a> to generate
    XML Catalogs for DocBook 4.1.2 . If it can write to the /etc/xml/
    directory, it will set-up /etc/xml/catalog and /etc/xml/docbook based on
    the resources found on the system. Otherwise it will just create
    ~/xmlcatalog and ~/dbkxmlcatalog and doing:
    <p><code>export XMLCATALOG=$HOME/xmlcatalog</code></p>
    <p>should allow to process DocBook documentations without requiring
    network accesses for the DTd or stylesheets</p>
  </li>
  <li>I have uploaded <a href="ftp://xmlsoft.org/libxml2/test/dbk412catalog.tar.gz">a
    small tarball</a> containing XML Catalogs for DocBook 4.1.2 which seems
    to work fine for me too</li>
  <li>Informations on installing a <a
    href="http://wiki.docbook.org/topic/CygwinPackages">Windows
    DocBook processing setup</a> based on Cygwin (using the binaries from the
    official Windows port should be possible too)</li>
  <li>Alexander Kirillov's page on <a
    href="http://www.math.sunysb.edu/~kirillov/dbxml/">Using DocBook XML
    4.1.2</a> (RPM packages)</li>
  <li>Tim Waugh's <a href="http://cyberelk.net/tim/xmlto/">xmlto front-end
    conversion script</a></li>
  <li>Linux Documentation Project <a
    href="http://www.linuxdoc.org/HOWTO/mini/DocBook-Install/">
    DocBook-Install-mini-HOWTO</a></li>
  <li>ScrollKeeper the open documentation cataloging project has a <a
    href="http://scrollkeeper.sourceforge.net/docbook.shtml">DocBook
    section</a></li>
  <li>Dan York presentation on <a
    href="http://www.lodestar2.com/people/dyork/talks/2001/xugo/docbook/index.html">Publishing
    using DocBook XML</a></li>
</ul>

<p>Do not use the --docbook option of xsltproc to process XML DocBook
documents, this option is only intended to provide some (limited) support of
the SGML version of DocBook.</p>

<p>Points which are not DocBook specific but still worth mentionning
again:</p>
<ul>
  <li>if you think DocBook processing time is too slow, make sure you have
    XML Catalogs pointing to a local installation of the DTD of DocBook.
    Check the <a href="http://xmlsoft.org/catalog.html">XML Catalog page</a>
    to understand more on this subject.</li>
  <li>before processing a new document, use the command
    <p><code>xmllint --valid --noout path_to_document</code></p>
    <p>to make sure that your input is valid DocBook. And fixes the errors
    before processing further. Note that XSLT processing may work correctly
    with some forms of validity errors left, but in general it can give
    troubles on output.</p>
  </li>
</ul>

<h2><a name="API">The programming API</a></h2>

<p>Okay this section is clearly incomplete. But integrating libxslt into your
application should be relatively easy. First check the few steps described
below, then for more detailed information, look at the<a
href="html/libxslt-lib.html"> generated pages</a> for the API and the source
of libxslt/xsltproc.c  and the  <a
href="tutorial/libxslttutorial.html">tutorial</a>.</p>

<p>Basically doing an XSLT transformation can be done in a few steps:</p>
<ol>
  <li>configure the parser for XSLT:
    <p>xmlSubstituteEntitiesDefault(1);</p>
    <p>xmlLoadExtDtdDefaultValue = 1;</p>
  </li>
  <li>parse the stylesheet with xsltParseStylesheetFile()</li>
  <li>parse the document with xmlParseFile()</li>
  <li>apply the stylesheet using xsltApplyStylesheet()</li>
  <li>save the result using xsltSaveResultToFile() if needed set
    xmlIndentTreeOutput to 1</li>
</ol>

<p>Steps 2,3, and 5 will probably need to be changed depending on you
processing needs and environment for example if reading/saving from/to
memory, or if you want to apply XInclude processing to the stylesheet or
input documents.</p>

<h2><a name="Python">Python and bindings</a></h2>

<p>There is a number of language bindings and wrappers available for libxml2,
the list below is not exhaustive. Please contact the <a
href="http://mail.gnome.org/mailman/listinfo/xml-bindings">xml-bindings@gnome.org</a>
(<a href="http://mail.gnome.org/archives/xml-bindings/">archives</a>) in
order to get updates to this list or to discuss the specific topic of libxml2
or libxslt wrappers or bindings:</p>
<ul>
  <li><a
    href="http://mail.gnome.org/archives/xml/2001-March/msg00014.html">Matt
    Sergeant</a> developped <a href="http://axkit.org/download/">XML::LibXML
    and XML::LibXSLT</a>, Perl wrappers for libxml2/libxslt as part of the <a
    href="http://axkit.com/">AxKit XML application server</a></li>
  <li><a href="mailto:dkuhlman@cutter.rexx.com">Dave Kuhlman</a> provides and
    earlier version of the libxml/libxslt <a
    href="http://www.rexx.com/~dkuhlman">wrappers for Python</a></li>
  <li>Petr Kozelka provides <a
    href="http://sourceforge.net/projects/libxml2-pas">Pascal units to glue
    libxml2</a> with Kylix, Delphi and other Pascal compilers</li>
  <li>Wai-Sun "Squidster" Chia provides <a
    href="http://www.rubycolor.org/arc/redist/">bindings for Ruby</a>  and
    libxml2 bindings are also available in Ruby through the <a
    href="http://libgdome-ruby.berlios.de/">libgdome-ruby</a> module
    maintained by Tobias Peters.</li>
  <li>Steve Ball and contributors maintains <a
    href="http://tclxml.sourceforge.net/">libxml2 and libxslt bindings for
    Tcl</a></li>
  <li><a href="mailto:xmlwrapp@pmade.org">Peter Jones</a> maintains C++
    bindings for libxslt within <a
    href="http://pmade.org/pjones/software/xmlwrapp/">xmlwrapp</a></li>
  <li><a href="phillim2@comcast.net">Mike Phillips</a> provides a module
    using <a href="http://siasl.dyndns.org/projects/projects.html">libxslt
    for PHP</a>.</li>
  <li><a href="http://savannah.gnu.org/projects/classpathx/">LibxmlJ</a> is
    an effort to create a 100% JAXP-compatible Java wrapper for libxml2 and
    libxslt as part of GNU ClasspathX project.</li>
  <li>Patrick McPhee provides Rexx bindings fof libxml2 and libxslt, look for
    <a href="http://www.interlog.com/~ptjm/software.html">RexxXML</a>.</li>
  <li><a
    href="http://www.satimage.fr/software/en/xml_suite.html">Satimage</a>
    provides <a
    href="http://www.satimage.fr/software/en/downloads_osaxen.html">XMLLib
    osax</a>. This is an osax for Mac OS X with a set of commands to
    implement in AppleScript the XML DOM, XPATH and XSLT.</li>
</ul>

<p>The libxslt Python module depends on the <a
href="http://xmlsoft.org/python.html">libxml2 Python</a> module.</p>

<p>The distribution includes a set of Python bindings, which are guaranteed to
be maintained as part of the library in the future, though the Python
interface have not yet reached the completeness of the C API.</p>

<p><a href="mailto:stephane.bidoul@softwareag.com">Stéphane Bidoul</a>
maintains <a href="http://users.skynet.be/sbi/libxml-python/">a Windows port
of the Python bindings</a>.</p>

<p>Note to people interested in building bindings, the API is formalized as
<a href="libxslt-api.xml">an XML API description file</a> which allows to
automate a large part of the Python bindings, this includes function
descriptions, enums, structures, typedefs, etc... The Python script used to
build the bindings is python/generator.py in the source distribution.</p>

<p>To install the Python bindings there are 2 options:</p>
<ul>
  <li>If you use an RPM based distribution, simply install the <a
    href="http://rpmfind.net/linux/rpm2html/search.php?query=libxml2-python">libxml2-python
    RPM</a> and the <a
    href="http://rpmfind.net/linux/rpm2html/search.php?query=libxslt-python">libxslt-python
    RPM</a>.</li>
  <li>Otherwise use the <a href="ftp://xmlsoft.org/libxml2/python/">libxml2-python
    module distribution</a> corresponding to your installed version of
    libxml2 and libxslt. Note that to install it you will need both libxml2
    and libxslt installed and run "python setup.py build install" in the
    module tree.</li>
</ul>

<p>The distribution includes a set of examples and regression tests for the
python bindings in the <code>python/tests</code> directory. Here are some
excepts from those tests:</p>

<h3>basic.py:</h3>

<p>This is a basic test of XSLT interfaces: loading a stylesheet and a
document, transforming the document and saving the result.</p>
<pre>import libxml2
import libxslt

styledoc = libxml2.parseFile("test.xsl")
style = libxslt.parseStylesheetDoc(styledoc)
doc = libxml2.parseFile("test.xml")
result = style.applyStylesheet(doc, None)
style.saveResultToFilename("foo", result, 0)
style.freeStylesheet()
doc.freeDoc()
result.freeDoc()</pre>

<p>The Python module is called libxslt, you will also need the libxml2 module
for the operations on XML trees. Let's have a look at the objects manipulated
in that example and how is the processing done:</p>
<ul>
  <li><code>styledoc</code> : is a libxml2 document tree. It is obtained by
    parsing the XML file "test.xsl" containing the stylesheet.</li>
  <li><code>style</code> : this is a precompiled stylesheet ready to be used
    by the following transformations (note the plural form, multiple
    transformations can resuse the same stylesheet).</li>
  <li><code>doc</code> : this is the document to apply the transformation to.
    In this case it is simply generated by parsing it from a file but any
    other processing is possible as long as one get a libxml2 Doc. Note that
    HTML tree are suitable for XSLT processing in libxslt. This is actually
    how this page is generated !</li>
  <li><code>result</code> : this is a document generated by applying the
    stylesheet to the document. Note that some of the stylesheet information
    may be related to the serialization of that document and as in this
    example a specific saveResultToFilename() method of the stylesheet should
    be used to save it to a file (in that case to "foo").</li>
</ul>

<p>Also note the need to explicitely deallocate documents with freeDoc()
except for the stylesheet document which is freed when its compiled form is
garbage collected.</p>

<h3>extfunc.py:</h3>

<p>This one is a far more complex test. It shows how to modify the behaviour
of an XSLT transformation by passing parameters and how to extend the XSLT
engine with functions defined in python:</p>
<pre>import libxml2
import libxslt
import string

nodeName = None
def f(ctx, str):
    global nodeName

    #
    # Small check to verify the context is correcly accessed
    #
    try:
        pctxt = libxslt.xpathParserContext(_obj=ctx)
        ctxt = pctxt.context()
        tctxt = ctxt.transformContext()
        nodeName = tctxt.insertNode().name
    except:
        pass

    return string.upper(str)

libxslt.registerExtModuleFunction("foo", "http://example.com/foo", f)</pre>

<p>This code defines and register an extension function. Note that the
function can be bound to any name (foo) and how the binding is also
associated to a namespace name "http://example.com/foo". From an XSLT point
of view the function just returns an upper case version of the string passed
as a parameter. But the first part of the function also read some contextual
information from the current XSLT processing environement, in that case it
looks for the current insertion node in the resulting output (either the
resulting document or the Result Value Tree being generated), and saves it to
a global variable for checking that the access actually worked.</p>

<p>For more information on the xpathParserContext and transformContext
objects check the <a href="internals.html">libray internals description</a>.
The pctxt is actually an object from a class derived from the
libxml2.xpathParserContext() with just a couple more properties including the
possibility to look up the XSLT transformation context from the XPath
context.</p>
<pre>styledoc = libxml2.parseDoc("""
&lt;xsl:stylesheet version='1.0'
  xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
  xmlns:foo='http://example.com/foo'
  xsl:exclude-result-prefixes='foo'&gt;

  &lt;xsl:param name='bar'&gt;failure&lt;/xsl:param&gt;
  &lt;xsl:template match='/'&gt;
    &lt;article&gt;&lt;xsl:value-of select='foo:foo($bar)'/&gt;&lt;/article&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
""")</pre>

<p>Here is a simple example of how to read an XML document from a python
string with libxml2. Note how this stylesheet:</p>
<ul>
  <li>Uses a global parameter <code>bar</code></li>
  <li>Reference the extension function f</li>
  <li>how the Namespace name "http://example.com/foo" has to be bound to a
    prefix</li>
  <li>how that prefix is excluded from the output</li>
  <li>how the function is called from the select</li>
</ul>
<pre>style = libxslt.parseStylesheetDoc(styledoc)
doc = libxml2.parseDoc("&lt;doc/&gt;")
result = style.applyStylesheet(doc, { "bar": "'success'" })
style.freeStylesheet()
doc.freeDoc()</pre>

<p>that part is identical, to the basic example except that the
transformation is passed a dictionary of parameters. Note that the string
passed "success" had to be quoted, otherwise it is interpreted as an XPath
query for the childs of root named "success".</p>
<pre>root = result.children
if root.name != "article":
    print "Unexpected root node name"
    sys.exit(1)
if root.content != "SUCCESS":
    print "Unexpected root node content, extension function failed"
    sys.exit(1)
if nodeName != 'article':
    print "The function callback failed to access its context"
    sys.exit(1)

result.freeDoc()</pre>

<p>That part just verifies that the transformation worked, that the parameter
got properly passed to the engine, that the function f() got called and that
it properly accessed the context to find the name of the insertion node.</p>

<h3>pyxsltproc.py:</h3>

<p>this module is a bit too long to be described there but it is basically a
rewrite of the xsltproc command line interface of libxslt in Python. It
provides nearly all the functionalities of xsltproc and can be used as a base
module to write Python customized XSLT processors. One of the thing to notice
are:</p>
<pre>libxml2.lineNumbersDefault(1)
libxml2.substituteEntitiesDefault(1)</pre>

<p>those two calls in the main() function are needed to force the libxml2
processor to generate DOM trees compliant with the XPath data model.</p>

<h2><a name="Internals">Library internals</a></h2>

<h3>Table  of contents</h3>
<ul>
  <li><a href="internals.html#Introducti">Introduction</a></li>
  <li><a href="internals.html#Basics">Basics</a></li>
  <li><a href="internals.html#Keep">Keep it simple stupid</a></li>
  <li><a href="internals.html#libxml">The libxml nodes</a></li>
  <li><a href="internals.html#XSLT">The XSLT processing steps</a></li>
  <li><a href="internals.html#XSLT1">The XSLT stylesheet compilation</a></li>
  <li><a href="internals.html#XSLT2">The XSLT template compilation</a></li>
  <li><a href="internals.html#processing">The processing itself</a></li>
  <li><a href="internals.html#XPath">XPath expressions compilation</a></li>
  <li><a href="internals.html#XPath1">XPath interpretation</a></li>
  <li><a href="internals.html#Descriptio">Description of XPath
  Objects</a></li>
  <li><a href="internals.html#XPath3">XPath functions</a></li>
  <li><a href="internals.html#stack">The variables stack frame</a></li>
  <li><a href="internals.html#Extension">Extension support</a></li>
  <li><a href="internals.html#Futher">Further reading</a></li>
  <li><a href="internals.html#TODOs">TODOs</a></li>
  <li><a href="internals.html#Thanks">Thanks</a></li>
</ul>

<h3><a name="Introducti2">Introduction</a></h3>

<p>This document describes the processing of <a
href="http://xmlsoft.org/XSLT/">libxslt</a>, the <a
href="http://www.w3.org/TR/xslt">XSLT</a> C library developed for the <a
href="http://www.gnome.org/">GNOME</a> project.</p>

<p>Note: this documentation is by definition incomplete and I am not good at
spelling, grammar, so patches and suggestions are <a
href="mailto:veillard@redhat.com">really welcome</a>.</p>

<h3><a name="Basics1">Basics</a></h3>

<p>XSLT is a transformation language. It takes an input document and a
stylesheet document and generates an output document:</p>

<p align="center"><img src="processing.gif"
alt="the XSLT processing model"></p>

<p>Libxslt is written in C. It relies on <a
href="http://www.xmlsoft.org/">libxml</a>, the XML C library for GNOME, for
the following operations:</p>
<ul>
  <li>parsing files</li>
  <li>building the in-memory DOM structure associated with the documents
    handled</li>
  <li>the XPath implementation</li>
  <li>serializing back the result document to XML and HTML. (Text is handled
    directly.)</li>
</ul>

<h3><a name="Keep1">Keep it simple stupid</a></h3>

<p>Libxslt is not very specialized. It is built under the assumption that all
nodes from the source and output document can fit in the virtual memory of
the system. There is a big trade-off there. It is fine for reasonably sized
documents but may not be suitable for large sets of data. The gain is that it
can be used in a relatively versatile way. The input or output may never be
serialized, but the size of documents it can handle are limited by the size
of the memory available.</p>

<p>More specialized memory handling approaches are possible, like building
the input tree from a serialization progressively as it is consumed,
factoring repetitive patterns, or even on-the-fly generation of the output as
the input is parsed but it is possible only for a limited subset of the
stylesheets. In general the implementation of libxslt follows the following
pattern:</p>
<ul>
  <li>KISS (keep it simple stupid)</li>
  <li>when there is a clear bottleneck optimize on top of this simple
    framework and refine only as much as is needed to reach the expected
    result</li>
</ul>

<p>The result is not that bad, clearly one can do a better job but more
specialized too. Most optimization like building the tree on-demand would
need serious changes to the libxml XPath framework. An easy step would be to
serialize the output directly (or call a set of SAX-like output handler to
keep this a flexible interface) and hence avoid the memory consumption of the
result.</p>

<h3><a name="libxml">The libxml nodes</a></h3>

<p>DOM-like trees, as used and generated by libxml and libxslt, are
relatively complex. Most node types follow the given structure except a few
variations depending on the node type:</p>

<p align="center"><img src="node.gif" alt="description of a libxml node"></p>

<p>Nodes carry a <strong>name</strong> and the node <strong>type</strong>
indicates the kind of node it represents, the most common ones are:</p>
<ul>
  <li>document nodes</li>
  <li>element nodes</li>
  <li>text nodes</li>
</ul>

<p>For the XSLT processing, entity nodes should not be generated (i.e. they
should be replaced by their content). Most nodes also contains the following
"navigation" information:</p>
<ul>
  <li>the containing <strong>doc</strong>ument</li>
  <li>the <strong>parent</strong> node</li>
  <li>the first <strong>children</strong> node</li>
  <li>the <strong>last</strong> children node</li>
  <li>the <strong>prev</strong>ious sibling</li>
  <li>the following sibling (<strong>next</strong>)</li>
</ul>

<p>Elements nodes carries the list of attributes in the properties, an
attribute itself holds the navigation pointers and the children list (the
attribute value is not represented as a simple string to allow usage of
entities references).</p>

<p>The <strong>ns</strong> points to the namespace declaration for the
namespace associated to the node, <strong>nsDef</strong> is the linked list
of namespace declaration present on element nodes.</p>

<p>Most nodes also carry an <strong>_private</strong> pointer which can be
used by the application to hold specific data on this node.</p>

<h3><a name="XSLT">The XSLT processing steps</a></h3>

<p>There are a few steps which are clearly decoupled at the interface
level:</p>
<ol>
  <li>parse the stylesheet and generate a DOM tree</li>
  <li>take the stylesheet tree and build a compiled version of it (the
    compilation phase)</li>
  <li>take the input and generate a DOM tree</li>
  <li>process the stylesheet against the input tree and generate an output
    tree</li>
  <li>serialize the output tree</li>
</ol>

<p>A few things should be noted here:</p>
<ul>
  <li>the steps 1/ 3/ and 5/ are optional:  the DOM representing the
    stylesheet and input can be created by other means, not just by parsing
    serialized XML documents, and similarly the result tree DOM can be
    made available to other processeswithout being serialized.
  <li>the stylesheet obtained at 2/ can be reused by multiple processing 4/
    (and this should also work in threaded programs)</li>
  <li>the tree provided in 2/ should never be freed using xmlFreeDoc, but by
    freeing the stylesheet.</li>
  <li>the input tree created in step 3/ is not modified except the
    _private field which may be used for labelling keys if used by the
    stylesheet. It's not modified at all in step 4/ to allow parallel
    processing using a shared precompiled stylesheet.</li>
</ul>

<h3><a name="XSLT1">The XSLT stylesheet compilation</a></h3>

<p>This is the second step described. It takes a stylesheet tree, and
"compiles" it. This associates to each node a structure stored in the
_private field and containing information computed in the stylesheet:</p>

<p align="center"><img src="stylesheet.gif"
alt="a compiled XSLT stylesheet"></p>

<p>One xsltStylesheet structure is generated per document parsed for the
stylesheet. XSLT documents allow includes and imports of other documents,
imports are stored in the <strong>imports</strong> list (hence keeping the
tree hierarchy of includes which is very important for a proper XSLT
processing model) and includes are stored in the <strong>doclist</strong>
list. An imported stylesheet has a parent link to allow browsing of the
tree.</p>

<p>The DOM tree associated to the document is stored in <strong>doc</strong>.
It is preprocessed to remove ignorable empty nodes and all the nodes in the
XSLT namespace are subject to precomputing. This usually consist of
extracting all the context information from the context tree (attributes,
namespaces, XPath expressions), and storing them in an xsltStylePreComp
structure associated to the <strong>_private</strong> field of the node.</p>

<p>A couple of notable exceptions to this are XSLT template nodes (more on
this later) and attribute value templates. If they are actually templates,
the value cannot be computed at compilation time. (Some preprocessing could
be done like isolation and preparsing of the XPath subexpressions but it's
not done, yet.)</p>

<p>The xsltStylePreComp structure also allows storing of the precompiled form
of an XPath expression that can be associated to an XSLT element (more on
this later).</p>

<h3><a name="XSLT2">The XSLT template compilation</a></h3>

<p>A proper handling of templates lookup is one of the keys of fast XSLT
processing. (Given a node in the source document this is the process of
finding which templates should be applied to this node.) Libxslt follows the
hint suggested in the <a href="http://www.w3.org/TR/xslt#patterns">5.2
Patterns</a> section of the XSLT Recommendation, i.e. it doesn't evaluate it
as an XPath expression but tokenizes it and compiles it as a set of rules to
be evaluated on a candidate node. There usually is an indication of the node
name in the last step of this evaluation and this is used as a key check for
the match. As a result libxslt builds a relatively more complex set of
structures for the templates:</p>

<p align="center"><img src="templates.gif"
alt="The templates related structure"></p>

<p>Let's describe a bit more closely what is built. First the xsltStylesheet
structure holds a pointer to the template hash table. All the XSLT patterns
compiled in this stylesheet are indexed by the value of the the target
element (or attribute, pi ...) name, so when a element or an attribute "foo"
needs to be processed the lookup is done using the name as a key.</p>

<p>Each of the patterns is compiled into an xsltCompMatch
(i.e. an ''XSLT compiled match') structure. It holds
the set of rules based on the tokenization of the pattern stored in reverse
order (matching is easier this way). </p>

<p>The xsltCompMatch are then stored in the hash table, the clash list is
itself sorted by priority of the template to implement "naturally" the XSLT
priority rules.</p>

<p>Associated to the compiled pattern is the xsltTemplate itself containing
the information required for the processing of the pattern including, of
course, a pointer to the list of elements used for building the pattern
result.</p>

<p>Last but not least a number of patterns do not fit in the hash table
because they are not associated to a name, this is the case for patterns
applying to the root, any element, any attributes, text nodes, pi nodes, keys
etc. Those are stored independently in the stylesheet structure as separate
linked lists of xsltCompMatch.</p>

<h3><a name="processing">The processing itself</a></h3>

<p>The processing is defined by the XSLT specification (the basis of the
algorithm is explained in <a
href="http://www.w3.org/TR/xslt#section-Introduction">the Introduction</a>
section). Basically it works by taking the root of the input document
as the cureent node and applying the following algorithm:</p>
<ol>
  <li>Finding the template applying to current node.
    This is a lookup in the template hash table, walking the hash list until
    the node satisfies all the steps of the pattern, then checking the
    appropriate global template(s) (i.e.  templates applying to a node type)
    to see if there isn't a higher priority rule to apply</li>
  <li>If there is no template, apply the default rule (recurse on the
    children as the current node)</li>
  <li>else walk the content list of the selected templates, for each of them:
    <ul>
      <li>if the node is in the XSLT namespace then the node has a _private
        field pointing to the preprocessed values, jump to the specific
      code</li>
      <li>if the node is in an extension namespace, look up the associated
        behavior</li>
      <li>otherwise copy the node.</li>
    </ul>
    <p>The closure is usually done through the XSLT
    <strong>apply-templates</strong>construct, which invokes this process
      recursively starting at step 1, to find the appropriate template
      for the nodes selected by the 'select' attribute of the apply-templates
      instruction (default: the children of the node currently being
      processed)</p>
  </li>
</ol>

<p>Note that large parts of the input tree may not be processed by a given
stylesheet and that conversely some may be processed multiple times.
(This often is the case when a Table of Contents is built).</p>

<p>The module <code>transform.c</code> is the one implementing most of this
logic. <strong>xsltApplyStylesheet()</strong> is the entry point, it
allocates an xsltTransformContext containing the following:</p>
<ul>
  <li>a pointer to the stylesheet being processed</li>
  <li>a stack of templates</li>
  <li>a stack of variables and parameters</li>
  <li>an XPath context</li>
  <li>the template mode</li>
  <li>current document</li>
  <li>current input node</li>
  <li>current selected node list</li>
  <li>the current insertion points in the output document</li>
  <li>a couple of hash tables for extension elements and functions</li>
</ul>

<p>Then a new document gets allocated (HTML or XML depending on the type of
output), the user parameters and global variables and parameters are
evaluated. Then <strong>xsltProcessOneNode()</strong> which implements the
1-2-3 algorithm is called on the docuemnt node of the input. Step 1/ is
implemented by calling <strong>xsltGetTemplate()</strong>, step 2/ is
implemented by <strong>xsltDefaultProcessOneNode()</strong> and step 3/ is
implemented by <strong>xsltApplyOneTemplate()</strong>.</p>

<h3><a name="XPath">XPath expression compilation</a></h3>

<p>The XPath support is actually implemented in the libxml module (where it
is reused by the XPointer implementation). XPath is a relatively classic
expression language. The only uncommon feature is that it is working on XML
trees and hence has specific syntax and types to handle them.</p>

<p>XPath expressions are compiled using <strong>xmlXPathCompile()</strong>.
It will take an expression string in input and generate a structure
containing the parsed expression tree, for example the expression:</p>
<pre>/doc/chapter[title='Introduction']</pre>

<p>will be compiled as</p>
<pre>Compiled Expression : 10 elements
  SORT
    COLLECT  'child' 'name' 'node' chapter
      COLLECT  'child' 'name' 'node' doc
        ROOT
      PREDICATE
        SORT
          EQUAL =
            COLLECT  'child' 'name' 'node' title
              NODE
            ELEM Object is a string : Introduction
              COLLECT  'child' 'name' 'node' title
                NODE</pre>

<p>This can be tested using the  <code>testXPath</code>  command (in the
libxml codebase) using the <code>--tree</code> option.</p>

<p>Again, the KISS approach is used. No optimization is done. This could be
an interesting thing to add. <a
href="http://www-106.ibm.com/developerworks/library/x-xslt2/?dwzone=x?open&amp;l=132%2ct=gr%2c+p=saxon">Michael
Kay describes</a> a lot of possible and interesting optimizations done in
Saxon which would be possible at this level. I'm unsure they would provide
much gain since the expressions tends to be relatively simple in general and
stylesheets are still hand generated. Optimizations at the interpretation
sounds likely to be more efficient.</p>

<h3><a name="XPath1">XPath interpretation</a></h3>

<p>The interpreter is implemented by <strong>xmlXPathCompiledEval()</strong>
which is the front-end to <strong>xmlXPathCompOpEval()</strong> the function
implementing the evaluation of the expression tree. This evaluation follows
the KISS approach again. It's recursive and calls
<strong>xmlXPathNodeCollectAndTest()</strong> to collect a set of nodes when
evaluating a <code>COLLECT</code> node.</p>

<p>An evaluation is done within the framework of an XPath context stored in
an <strong>xmlXPathContext</strong> structure, in the framework of a
transformation the context is maintained within the XSLT context. Its content
follows the requirements from the XPath specification:</p>
<ul>
  <li>the current document</li>
  <li>the current node</li>
  <li>a hash table of defined variables (but not used by XSLT,
      which uses its own stack frame for variables, described below)</li>
  <li>a hash table of defined functions</li>
  <li>the proximity position (the place of the node in the current node
  list)</li>
  <li>the context size (the size of the current node list)</li>
  <li>the array of namespace declarations in scope (there also is a namespace
    hash table but it is not used in the XSLT transformation).</li>
</ul>

<p>For the purpose of XSLT an <strong>extra</strong> pointer has been added
allowing to retrieve the XSLT transformation context. When an XPath
evaluation is about to be performed, an XPath parser context is allocated
containing an XPath object stack (this is actually an XPath evaluation
context, this is a relic of the time where there was no separate parsing and
evaluation phase in the XPath implementation). Here is an overview of the set
of contexts associated to an XPath evaluation within an XSLT
transformation:</p>

<p align="center"><img src="contexts.gif"
alt="The set of contexts associated "></p>

<p>Clearly this is a bit too complex and confusing and should be refactored
at the next set of binary incompatible releases of libxml. For example the
xmlXPathCtxt has a lot of unused parts and should probably be merged with
xmlXPathParserCtxt.</p>

<h3><a name="Descriptio">Description of XPath Objects</a></h3>

<p>An XPath expression manipulates XPath objects. XPath defines the default
types boolean, numbers, strings and node sets. XSLT adds the result tree
fragment type which is basically an unmodifiable node set.</p>

<p>Implementation-wise, libxml follows again a KISS approach, the
xmlXPathObject is a structure containing a type description and the various
possibilities. (Using an enum could have gained some bytes.) In the case of
node sets (or result tree fragments), it points to a separate xmlNodeSet
object which contains the list of pointers to the document nodes:</p>

<p align="center"><img src="object.gif"
alt="An Node set object pointing to "></p>

<p>The <a href="http://xmlsoft.org/html/libxml-xpath.html">XPath API</a> (and
its <a href="http://xmlsoft.org/html/libxml-xpathinternals.html">'internal'
part</a>) includes a number of functions to create, copy, compare, convert or
free XPath objects.</p>

<h3><a name="XPath3">XPath functions</a></h3>

<p>All the XPath functions available to the interpreter are registered in the
function hash table linked from the XPath context. They all share the same
signature:</p>
<pre>void xmlXPathFunc (xmlXPathParserContextPtr ctxt, int nargs);</pre>

<p>The first argument is the XPath interpretation context, holding the
interpretation stack. The second argument defines the number of objects
passed on the stack for the function to consume (last argument is on top of
the stack).</p>

<p>Basically an XPath function does the following:</p>
<ul>
  <li>check <code>nargs</code> for proper handling of errors or functions
    with variable numbers of parameters</li>
  <li>pop the parameters from the stack using <code>obj =
    valuePop(ctxt);</code></li>
  <li>do the function specific computation</li>
  <li>push the result parameter on the stack using <code>valuePush(ctxt,
    res);</code></li>
  <li>free up the input parameters with
  <code>xmlXPathFreeObject(obj);</code></li>
  <li>return</li>
</ul>

<p>Sometime the work can be done directly by modifying in-situ the top object
on the stack <code>ctxt-&gt;value</code>.</p>

<h3><a name="stack">The XSLT variables stack frame</a></h3>

<p>Not to be confused with XPath object stack, this stack holds the XSLT
variables and parameters as they are defined through the recursive calls of
call-template, apply-templates and default templates. This is used to define
the scope of variables being called.</p>

<p>This part seems to be one needing most work , first it is
done in a very inefficient way since the location of the variables and
parameters within the stylesheet tree is still done at run time (it really
should be done statically at compile time), and I am still unsure that my
understanding of the template variables and parameter scope is actually
right.</p>

<p>This part of the documentation is still to be written once this part of
the code will be stable. <span
style="background-color: #FF0000">TODO</span></p>

<h3><a name="Extension">Extension support</a></h3>

<p>There is a separate document explaining <a href="extensions.html">how the
extension support works</a>.</p>

<h3><a name="Futher">Further reading</a></h3>

<p>Michael Kay wrote <a
href="http://www-106.ibm.com/developerworks/library/x-xslt2/?dwzone=x?open&amp;l=132%2ct=gr%2c+p=saxon">a
really interesting article on Saxon internals</a> and the work he did on
performance issues. I wish I had read it before starting libxslt design (I
would probably have avoided a few mistakes and progressed faster). A lot of
the ideas in his papers should be implemented or at least tried in
libxslt.</p>

<p>The <a href="http://xmlsoft.org/">libxml documentation</a>, especially <a
href="http://xmlsoft.org/xmlio.html">the I/O interfaces</a> and the <a
href="http://xmlsoft.org/xmlmem.html">memory management</a>.</p>

<h3><a name="TODOs">TODOs</a></h3>

<p>redesign the XSLT stack frame handling. Far too much work is done at
execution time. Similarly for the attribute value templates handling, at
least the embedded subexpressions ought to be precompiled.</p>

<p>Allow output to be saved to a SAX like output (this notion of SAX like API
for output should be added directly to libxml).</p>

<p>Implement and test some of the optimization explained by Michael Kay
especially:</p>
<ul>
  <li>static slot allocation on the stack frame</li>
  <li>specific boolean interpretation of an XPath expression</li>
  <li>some of the sorting optimization</li>
  <li>Lazy evaluation of location path. (this may require more changes but
    sounds really interesting. XT does this too.)</li>
