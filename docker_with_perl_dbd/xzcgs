
                # Here, it wasn't one of the gc or script single-form
                # extensions.  It could be a block property single-form
                # extension.  An 'in' prefix definitely means that, and should
                # be looked up without the prefix.  However, starting in
                # Unicode 6.1, we have to special case 'indic...', as there
                # is a property that begins with that name.   We shouldn't
                # strip the 'in' from that.   I'm (khw) generalizing this to
                # 'indic' instead of the single property, because I suspect
                # that others of this class may come along in the future.
                # However, this could backfire and a block created whose name
                # begins with 'dic...', and we would want to strip the 'in'.
                # At which point this would have to be tweaked.
                my $began_with_in = $loose =~ s/^in(?!dic)//;
                @list = prop_value_aliases("block", $loose);
                if (@list) {
                    map { $_ =~ s/^/In_/ } @list;
                    return @list;
                }

                # Here still haven't found it.  The last opportunity for it
                # being valid is only if it began with 'is'.  We retry without
                # the 'is', setting a flag to that effect so that we don't
                # accept things that begin with 'isis...'
                if (! $retrying && ! $began_with_in && $loose =~ s/^is//) {
                    $retrying = 1;
                    goto RETRY;
                }

                # Here, didn't find it.  Since it was in %loose_to_file_of, we
                # should have been able to find it.
                carp __PACKAGE__, "::prop_aliases: Unexpectedly could not find '$prop'.  Send bug report to perlbug\@perl.org";
                return;
            }
        }
    }

    if (! $list_ref) {
        # Here, we have set $prop to a standard form name of the input.  Look
        # it up in the structure created by mktables for this purpose, which
        # contains both strict and loosely matched properties.  Avoid
        # autovivifying.
        $list_ref = $prop_aliases{$prop} if exists $prop_aliases{$prop};
        return unless $list_ref;
    }

    # The full name is in element 1.
    return $list_ref->[1] unless wantarray;

    return @{_dclone $list_ref};
}

=pod

=head2 B<prop_values()>

    use Unicode::UCD 'prop_values';

    print "AHex values are: ", join(", ", prop_values("AHex")),
                               "\n";
  prints:
    AHex values are: N, Y

Some Unicode properties have a restricted set of legal values.  For example,
all binary properties are restricted to just C<true> or C<false>; and there
are only a few dozen possible General Categories.  Use C<prop_values>
to find out if a given property is one such, and if so, to get a list of the
values:

    print join ", ", prop_values("NFC_Quick_Check");
  prints:
    M, N, Y

If the property doesn't have such a restricted set, C<undef> is returned.

There are usually several synonyms for each possible value.  Use
L</prop_value_aliases()> to access those.

Case, white space, hyphens, and underscores are ignored in the input property
name (except for the trailing underscore in the old-form grandfathered-in
general category property value C<"L_">, which is better written as C<"LC">).

If the property name is unknown, C<undef> is returned.  Note that Perl typically
recognizes property names in regular expressions with an optional C<"Is_>"
(with or without the underscore) prefixed to them, such as C<\p{isgc=punct}>.
This function does not recognize those in the property parameter, returning
C<undef>.

For the block property, new-style block names are returned (see
L</Old-style versus new-style block names>).

C<prop_values> does not know about any user-defined properties, and
will return C<undef> if called with one of those.

=cut

# These are created by mktables for this module and stored in unicore/UCD.pl
# where their structures are described.
our %loose_to_standard_value;
our %prop_value_aliases;

sub prop_values ($) {
    my $prop = shift;
    return undef unless defined $prop;

    require "unicore/UCD.pl";

    # Find the property name synonym that's used as the key in other hashes,
    # which is element 0 in the returned list.
    ($prop) = prop_aliases($prop);
    return undef if ! $prop;
    $prop = loose_name(lc $prop);

    # Here is a legal property.
    return undef unless exists $prop_value_aliases{$prop};
    my @return;
    foreach my $value_key (sort { lc $a cmp lc $b }
                            keys %{$prop_value_aliases{$prop}})
    {
        push @return, $prop_value_aliases{$prop}{$value_key}[0];
    }
    return @return;
}

=pod

=head2 B<prop_value_aliases()>

    use Unicode::UCD 'prop_value_aliases';

    my ($short_name, $full_name, @other_names)
                                   = prop_value_aliases("Gc", "Punct");
    my $same_full_name = prop_value_aliases("Gc", "P");   # Scalar cntxt
    my ($same_short_name) = prop_value_aliases("Gc", "P"); # gets 0th
                                                           # element
    print "The full name is $full_name\n";
    print "The short name is $short_name\n";
    print "The other aliases are: ", join(", ", @other_names), "\n";

  prints:
    The full name is Punctuation
    The short name is P
    The other aliases are: Punct

Some Unicode properties have a restricted set of legal values.  For example,
all binary properties are restricted to just C<true> or C<false>; and there
are only a few dozen possible General Categories.

You can use L</prop_values()> to find out if a given property is one which has
a restricted set of values, and if so, what those values are.  But usually
each value actually has several synonyms.  For example, in Unicode binary
properties, I<truth> can be represented by any of the strings "Y", "Yes", "T",
or "True"; and the General Category "Punctuation" by that string, or "Punct",
or simply "P".

Like property names, there is typically at least a short name for each such
property-value, and a long name.  If you know any name of the property-value
(which you can get by L</prop_values()>, you can use C<prop_value_aliases>()
to get the long name (when called in scalar context), or a list of all the
names, with the short name in the 0th element, the long name in the next
element, and any other synonyms in the remaining elements, in no particular
order, except that any all-numeric synonyms will be last.

The long name is returned in a form nicely capitalized, suitable for printing.

Case, white space, hyphens, and underscores are ignored in the input parameters
(except for the trailing underscore in the old-form grandfathered-in general
category property value C<"L_">, which is better written as C<"LC">).

If either name is unknown, C<undef> is returned.  Note that Perl typically
recognizes property names in regular expressions with an optional C<"Is_>"
(with or without the underscore) prefixed to them, such as C<\p{isgc=punct}>.
This function does not recognize those in the property parameter, returning
C<undef>.

If called with a property that doesn't have synonyms for its values, it
returns the input value, possibly normalized with capitalization and
underscores, but not necessarily checking that the input value is valid.

For the block property, new-style block names are returned (see
L</Old-style versus new-style block names>).

To find the synonyms for single-forms, such as C<\p{Any}>, use
L</prop_aliases()> instead.

C<prop_value_aliases> does not know about any user-defined properties, and
will return C<undef> if called with one of those.

=cut

sub prop_value_aliases ($$) {
    my ($prop, $value) = @_;
    return unless defined $prop && defined $value;

    require "unicore/UCD.pl";

    # Find the property name synonym that's used as the key in other hashes,
    # which is element 0 in the returned list.
    ($prop) = prop_aliases($prop);
    return if ! $prop;
    $prop = loose_name(lc $prop);

    # Here is a legal property, but the hash below (created by mktables for
    # this purpose) only knows about the properties that have a very finite
    # number of potential values, that is not ones whose value could be
    # anything, like most (if not all) string properties.  These don't have
    # synonyms anyway.  Simply return the input.  For example, there is no
    # synonym for ('Uppercase_Mapping', A').
    if (! exists $prop_value_aliases{$prop}) {

        # Here, we have a legal property, but an unknown value.  Since the
        # property is legal, if it isn't in the prop_aliases hash, it must be
        # a Perl-extension All perl extensions are binary, hence are
        # enumerateds, which means that we know that the input unknown value
        # is illegal.
        return if ! exists $prop_aliases{$prop};

        # Otherwise, we assume it's valid, as documented.
        return $value;
    }

    # The value name may be loosely or strictly matched; we don't know yet.
    # But both types use lower-case.
    $value = lc $value;

    # If the name isn't found under loose matching, it certainly won't be
    # found under strict
    my $loose_value = loose_name($value);
    return unless exists $loose_to_standard_value{"$prop=$loose_value"};

    # Similarly if the combination under loose matching doesn't exist, it
    # won't exist under strict.
    my $standard_value = $loose_to_standard_value{"$prop=$loose_value"};
    return unless exists $prop_value_aliases{$prop}{$standard_value};

    # Here we did find a combination under loose matching rules.  But it could
    # be that is a strict property match that shouldn't have matched.
    # %prop_value_aliases is set up so that the strict matches will appear as
    # if they were in loose form.  Thus, if the non-loose version is legal,
    # we're ok, can skip the further check.
    if (! exists $stricter_to_file_of{"$prop=$value"}

        # We're also ok and skip the further check if value loosely matches.
        # mktables has verified that no strict name under loose rules maps to
        # an existing loose name.  This code relies on the very limited
        # circumstances that strict names can be here.  Strict name matching
        # happens under two conditions:
        # 1) when the name begins with an underscore.  But this function
        #    doesn't accept those, and %prop_value_aliases doesn't have
        #    them.
        # 2) When the values are numeric, in which case we need to look
        #    further, but their squeezed-out loose values will be in
        #    %stricter_to_file_of
        && exists $stricter_to_file_of{"$prop=$loose_value"})
    {
        # The only thing that's legal loosely under strict is that can have an
        # underscore between digit pairs XXX
        while ($value =~ s/(\d)_(\d)/$1$2/g) {}
        return unless exists $stricter_to_file_of{"$prop=$value"};
    }

    # Here, we know that the combination exists.  Return it.
    my $list_ref = $prop_value_aliases{$prop}{$standard_value};
    if (@$list_ref > 1) {
        # The full name is in element 1.
        return $list_ref->[1] unless wantarray;

        return @{_dclone $list_ref};
    }

    return $list_ref->[0] unless wantarray;

    # Only 1 element means that it repeats
    return ( $list_ref->[0], $list_ref->[0] );
}

# All 1 bits but the top one is the largest possible IV.
$MAX_CP = (~0) >> 1;

=pod

=head2 B<prop_invlist()>

C<prop_invlist> returns an inversion list (described below) that defines all the
code points for the binary Unicode property (or "property=value" pair) given
by the input parameter string:

 use feature 'say';
 use Unicode::UCD 'prop_invlist';
 say join ", ", prop_invlist("Any");

 prints:
 0, 1114112

If the input is unknown C<undef> is returned in scalar context; an empty-list
in list context.  If the input is known, the number of elements in
the list is returned if called in scalar context.

L<perluniprops|perluniprops/Properties accessible through \p{} and \P{}> gives
the list of properties that this function accepts, as well as all the possible
forms for them (including with the optional "Is_" prefixes).  (Except this
function doesn't accept any Perl-internal properties, some of which are listed
there.) This function uses the same loose or tighter matching rules for
resolving the input property's name as is done for regular expressions.  These
are also specified in L<perluniprops|perluniprops/Properties accessible
through \p{} and \P{}>.  Examples of using the "property=value" form are:

 say join ", ", prop_invlist("Script_Extensions=Shavian");

 prints:
 66640, 66688

 say join ", ", prop_invlist("ASCII_Hex_Digit=No");

 prints:
 0, 48, 58, 65, 71, 97, 103

 say join ", ", prop_invlist("ASCII_Hex_Digit=Yes");

 prints:
 48, 58, 65, 71, 97, 103

Inversion lists are a compact way of specifying Unicode property-value
definitions.  The 0th item in the list is the lowest code point that has the
property-value.  The next item (item [1]) is the lowest code point beyond that
one that does NOT have the property-value.  And the next item beyond that
([2]) is the lowest code point beyond that one that does have the
property-value, and so on.  Put another way, each element in the list gives
the beginning of a range that has the property-value (for even numbered
elements), or doesn't have the property-value (for odd numbered elements).
The name for this data structure stems from the fact that each element in the
list toggles (or inverts) whether the corresponding range is or isn't on the
list.

In the final example above, the first ASCII Hex digit is code point 48, the
character "0", and all code points from it through 57 (a "9") are ASCII hex
digits.  Code points 58 through 64 aren't, but 65 (an "A") through 70 (an "F")
are, as are 97 ("a") through 102 ("f").  103 starts a range of code points
that aren't ASCII hex digits.  That range extends to infinity, which on your
computer can be found in the variable C<$Unicode::UCD::MAX_CP>.  (This
variable is as close to infinity as Perl can get on your platform, and may be
too high for some operations to work; you may wish to use a smaller number for
your purposes.)

Note that the inversion lists returned by this function can possibly include
non-Unicode code points, that is anything above 0x10FFFF.  Unicode properties
are not defined on such code points.  You might wish to change the output to
not include these.  Simply add 0x110000 at the end of the non-empty returned
list if it isn't already that value; and pop that value if it is; like:

 my @list = prop_invlist("foo");
 if (@list) {
     if ($list[-1] == 0x110000) {
         pop @list;  # Defeat the turning on for above Unicode
     }
     else {
         push @list, 0x110000; # Turn off for above Unicode
     }
 }

It is a simple matter to expand out an inversion list to a full list of all
code points that have the property-value:

 my @invlist = prop_invlist($property_name);
 die "empty" unless @invlist;
 my @full_list;
 for (my $i = 0; $i < @invlist; $i += 2) {
    my $upper = ($i + 1) < @invlist
                ? $invlist[$i+1] - 1      # In range
                : $Unicode::UCD::MAX_CP;  # To infinity.
    for my $j ($invlist[$i] .. $upper) {
        push @full_list, $j;
    }
 }

C<prop_invlist> does not know about any user-defined nor Perl internal-only
properties, and will return C<undef> if called with one of those.

The L</search_invlist()> function is provided for finding a code point within
an inversion list.

=cut

# User-defined properties could be handled with some changes to SWASHNEW;
# and implementing here of dealing with EXTRAS.  If done, consideration should
# be given to the fact that the user subroutine could return different results
# with each call; security issues need to be thought about.

# These are created by mktables for this routine and stored in unicore/UCD.pl
# where their structures are described.
our %loose_defaults;
our $MAX_UNICODE_CODEPOINT;

sub prop_invlist ($;$) {
    my $prop = $_[0];

    # Undocumented way to get at Perl internal properties; it may be changed
    # or removed without notice at any time.
    my $internal_ok = defined $_[1] && $_[1] eq '_perl_core_internal_ok';

    return if ! defined $prop;

    # Warnings for these are only for regexes, so not applicable to us
    no warnings 'deprecated';

    # Get the swash definition of the property-value.
    my $swash = SWASHNEW(__PACKAGE__, $prop, undef, 1, 0);

    # Fail if not found, or isn't a boolean property-value, or is a
    # user-defined property, or is internal-only.
    return if ! $swash
              || ref $swash eq ""
              || $swash->{'BITS'} != 1
              || $swash->{'USER_DEFINED'}
              || (! $internal_ok && $prop =~ /^\s*_/);

    if ($swash->{'EXTRAS'}) {
        carp __PACKAGE__, "::prop_invlist: swash returned for $prop unexpectedly has EXTRAS magic";
        return;
    }
    if ($swash->{'SPECIALS'}) {
        carp __PACKAGE__, "::prop_invlist: swash returned for $prop unexpectedly has SPECIALS magic";
        return;
    }

    my @invlist;

    if ($swash->{'LIST'} =~ /^V/) {

        # A 'V' as the first character marks the input as already an inversion
        # list, in which case, all we need to do is put the remaining lines
        # into our array.
        @invlist = split "\n", $swash->{'LIST'} =~ s/ \s* (?: \# .* )? $ //xmgr;
        shift @invlist;
    }
    else {
        # The input lines look like:
        # 0041\t005A   # [26]
        # 005F

        # Split into lines, stripped of trailing comments
        foreach my $range (split "\n",
                              $swash->{'LIST'} =~ s/ \s* (?: \# .* )? $ //xmgr)
        {
            # And find the beginning and end of the range on the line
            my ($hex_begin, $hex_end) = split "\t", $range;
            my $begin = hex $hex_begin;

            # If the new range merely extends the old, we remove the marker
            # created the last time through the loop for the old's end, which
            # causes the new one's end to be used instead.
            if (@invlist && $begin == $invlist[-1]) {
                pop @invlist;
            }
            else {
                # Add the beginning of the range
                push @invlist, $begin;
            }

            if (defined $hex_end) { # The next item starts with the code point 1
                                    # beyond the end of the range.
                no warnings 'portable';
                my $end = hex $hex_end;
                last if $end == $MAX_CP;
                push @invlist, $end + 1;
            }
            else {  # No end of range, is a single code point.
                push @invlist, $begin + 1;
            }
        }
    }

    # Could need to be inverted: add or subtract a 0 at the beginning of the
    # list.
    if ($swash->{'INVERT_IT'}) {
        if (@invlist && $invlist[0] == 0) {
            shift @invlist;
        }
        else {
            unshift @invlist, 0;
        }
    }

    return @invlist;
}

=pod

=head2 B<prop_invmap()>

 use Unicode::UCD 'prop_invmap';
 my ($list_ref, $map_ref, $format, $default)
                                      = prop_invmap("General Category");

C<prop_invmap> is used to get the complete mapping definition for a property,
in the form of an inversion map.  An inversion map consists of two parallel
arrays.  One is an ordered list of code points that mark range beginnings, and
the other gives the value (or mapping) that all code points in the
corresponding range have.

C<prop_invmap> is called with the name of the desired property.  The name is
loosely matched, meaning that differences in case, white-space, hyphens, and
underscores are not meaningful (except for the trailing underscore in the
old-form grandfathered-in property C<"L_">, which is better written as C<"LC">,
or even better, C<"Gc=LC">).

Many Unicode properties have more than one name (or alias).  C<prop_invmap>
understands all of these, including Perl extensions to them.  Ambiguities are
resolved as described above for L</prop_aliases()> (except if a property has
both a complete mapping, and a binary C<Y>/C<N> mapping, then specifying the
property name prefixed by C<"is"> causes the binary one to be returned).  The
Perl internal property "Perl_Decimal_Digit, described below, is also accepted.
An empty list is returned if the property name is unknown.
See L<perluniprops/Properties accessible through Unicode::UCD> for the
properties acceptable as inputs to this function.

It is a fatal error to call this function except in list context.

In addition to the two arrays that form the inversion map, C<prop_invmap>
returns two other values; one is a scalar that gives some details as to the
format of the entries of the map array; the other is a default value, useful
in maps whose format name begins with the letter C<"a">, as described
L<below in its subsection|/a>; and for specialized purposes, such as
converting to another data structure, described at the end of this main
section.

This means that C<prop_invmap> returns a 4 element list.  For example,

 my ($blocks_ranges_ref, $blocks_maps_ref, $format, $default)
                                                 = prop_invmap("Block");

In this call, the two arrays will be populated as shown below (for Unicode
6.0):

 Index  @blocks_ranges  @blocks_maps
   0        0x0000      Basic Latin
   1        0x0080      Latin-1 Supplement
   2        0x0100      Latin Extended-A
   3        0x0180      Latin Extended-B
   4        0x0250      IPA Extensions
   5        0x02B0      Spacing Modifier Letters
   6        0x0300      Combining Diacritical Marks
   7        0x0370      Greek and Coptic
   8        0x0400      Cyrillic
  ...
 233        0x2B820     No_Block
 234        0x2F800     CJK Compatibility Ideographs Supplement
 235        0x2FA20     No_Block
 236        0xE0000     Tags
 237        0xE0080     No_Block
 238        0xE0100     Variation Selectors Supplement
 239        0xE01F0     No_Block
 240        0xF0000     Supplementary Private Use Area-A
 241        0x100000    Supplementary Private Use Area-B
 242        0x110000    No_Block

The first line (with Index [0]) means that the value for code point 0 is "Basic
Latin".  The entry "0x0080" in the @blocks_ranges column in the second line
means that the value from the first line, "Basic Latin", extends to all code
points in the range from 0 up to but not including 0x0080, that is, through
127.  In other words, the code points from 0 to 127 are all in the "Basic
Latin" block.  Similarly, all code points in the range from 0x0080 up to (but
not including) 0x0100 are in the block named "Latin-1 Supplement", etc.
(Notice that the return is the old-style block names; see L</Old-style versus
new-style block names>).

The final line (with Index [242]) means that the value for all code points above
the legal Unicode maximum code point have the value "No_Block", which is the
term Unicode uses for a non-existing block.

The arrays completely specify the mappings for all possible code points.
The final element in an inversion map returned by this function will always be
for the range that consists of all the code points that aren't legal Unicode,
but that are expressible on the platform.  (That is, it starts with code point
0x110000, the first code point above the legal Unicode maximum, and extends to
infinity.) The value for that range will be the same that any typical
unassigned code point has for the specified property.  (Certain unassigned
code points are not "typical"; for example the non-character code points, or
those in blocks that are to be written right-to-left.  The above-Unicode
range's value is not based on these atypical code points.)  It could be argued
that, instead of treating these as unassigned Unicode code points, the value
for this range should be C<undef>.  If you wish, you can change the returned
arrays accordingly.

The maps for almost all properties are simple scalars that should be
interpreted as-is.
These values are those given in the Unicode-supplied data files, which may be
inconsistent as to capitalization and as to which synonym for a property-value
is given.  The results may be normalized by using the L</prop_value_aliases()>
function.

There are exceptions to the simple scalar maps.  Some properties have some
elements in their map list that are themselves lists of scalars; and some
special strings are returned that are not to be interpreted as-is.  Element
[2] (placed into C<$format> in the example above) of the returned four element
list tells you if the map has any of these special elements or not, as follows:

=over

=item B<C<s>>

means all the elements of the map array are simple scalars, with no special
elements.  Almost all properties are like this, like the C<block> example
above.

=item B<C<sl>>

means that some of the map array elements have the form given by C<"s">, and
the rest are lists of scalars.  For example, here is a portion of the output
of calling C<prop_invmap>() with the "Script Extensions" property:

 @scripts_ranges  @scripts_maps
      ...
      0x0953      Devanagari
      0x0964      [ Bengali, Devanagari, Gurumukhi, Oriya ]
      0x0966      Devanagari
      0x0970      Common

Here, the code points 0x964 and 0x965 are both used in Bengali,
Devanagari, Gurmukhi, and Oriya, but no other scripts.

The Name_Alias property is also of this form.  But each scalar consists of two
components:  1) the name, and 2) the type of alias this is.  They are
separated by a colon and a space.  In Unicode 6.1, there are several alias types:

=over

=item C<correction>

indicates that the name is a corrected form for the
original name (which remains valid) for the same code point.

=item C<control>

adds a new name for a control character.

=item C<alternate>

is an alternate name for a character

=item C<figment>

is a name for a character that has been documented but was never in any
actual standard.

=item C<abbreviation>

is a common abbreviation for a character

=back

The lists are ordered (roughly) so the most preferred names come before less
preferred ones.

For example,

 @aliases_ranges        @alias_maps
    ...
    0x009E        [ 'PRIVACY MESSAGE: control', 'PM: abbreviation' ]
    0x009F        [ 'APPLICATION PROGRAM COMMAND: control',
                    'APC: abbreviation'
                  ]
    0x00A0        'NBSP: abbreviation'
    0x00A1        ""
    0x00AD        'SHY: abbreviation'
    0x00AE        ""
    0x01A2        'LATIN CAPITAL LETTER GHA: correction'
    0x01A3        'LATIN SMALL LETTER GHA: correction'
    0x01A4        ""
    ...

A map to the empty string means that there is no alias defined for the code
point.

=item B<C<a>>

is like C<"s"> in that all the map array elements are scalars, but here they are
restricted to all being integers, and some have to be adjusted (hence the name
C<"a">) to get the correct result.  For example, in:

 my ($uppers_ranges_ref, $uppers_maps_ref, $format, $default)
                          = prop_invmap("Simple_Uppercase_Mapping");

the returned arrays look like this:

 @$uppers_ranges_ref    @$uppers_maps_ref   Note
       0                      0
      97                     65          'a' maps to 'A', b => B ...
     123                      0
     181                    924          MICRO SIGN => Greek Cap MU
     182                      0
     ...

and C<$default> is 0.

Let's start with the second line.  It says that the uppercase of code point 97
is 65; or C<uc("a")> == "A".  But the line is for the entire range of code
points 97 through 122.  To get the mapping for any code point in this range,
you take the offset it has from the beginning code point of the range, and add
that to the mapping for that first code point.  So, the mapping for 122 ("z")
is derived by taking the offset of 122 from 97 (=25) and adding that to 65,
yielding 90 ("Z").  Likewise for everything in between.

Requiring this simple adjustment allows the returned arrays to be
significantly smaller than otherwise, up to a factor of 10, speeding up
searching through them.

Ranges that map to C<$default>, C<"0">, behave somewhat differently.  For
these, each code point maps to itself.  So, in the first line in the example,
S<C<ord(uc(chr(0)))>> is 0, S<C<ord(uc(chr(1)))>> is 1, ..
S<C<ord(uc(chr(96)))>> is 96.

=item B<C<al>>

means that some of the map array elements have the form given by C<"a">, and
the rest are ordered lists of code points.
For example, in:

 my ($uppers_ranges_ref, $uppers_maps_ref, $format, $default)
                                 = prop_invmap("Uppercase_Mapping");

the returned arrays look like this:

 @$uppers_ranges_ref    @$uppers_maps_ref
       0                      0
      97                     65
     123                      0
     181                    924
     182                      0
     ...
    0x0149              [ 0x02BC 0x004E ]
    0x014A                    0
    0x014B                  330
     ...

This is the full Uppercase_Mapping property (as opposed to the
Simple_Uppercase_Mapping given in the example for format C<"a">).  The only
difference between the two in the ranges shown is that the code point at
0x0149 (LATIN SMALL LETTER N PRECEDED BY APOSTROPHE) maps to a string of two
characters, 0x02BC (MODIFIER LETTER APOSTROPHE) followed by 0x004E (LATIN
CAPITAL LETTER N).

No adjustments are needed to entries that are references to arrays; each such
entry will have exactly one element in its range, so the offset is always 0.

The fourth (index [3]) element (C<$default>) in the list returned for this
format is 0.

=item B<C<ae>>

This is like C<"a">, but some elements are the empty string, and should not be
adjusted.
The one internal Perl property accessible by C<prop_invmap> is of this type:
"Perl_Decimal_Digit" returns an inversion map which gives the numeric values
that are represented by the Unicode decimal digit characters.  Characters that
don't represent decimal digits map to the empty string, like so:

 @digits    @values
 0x0000       ""
 0x0030        0
 0x003A:      ""
 0x0660:       0
 0x066A:      ""
 0x06F0:       0
 0x06FA:      ""
 0x07C0:       0
 0x07CA:      ""
 0x0966:       0
 ...

This means that the code points from 0 to 0x2F do not represent decimal digits;
the code point 0x30 (DIGIT ZERO) represents 0;  code point 0x31, (DIGIT ONE),
represents 0+1-0 = 1; ... code point 0x39, (DIGIT NINE), represents 0+9-0 = 9;
... code points 0x3A through 0x65F do not represent decimal digits; 0x660
(ARABIC-INDIC DIGIT ZERO), represents 0; ... 0x07C1 (NKO DIGIT ONE),
represents 0+1-0 = 1 ...

The fourth (index [3]) element (C<$default>) in the list returned for this
format is the empty string.

=item B<C<ale>>

is a combination of the C<"al"> type and the C<"ae"> type.  Some of
the map array elements have the forms given by C<"al">, and
the rest are the empty string.  The property C<NFKC_Casefold> has this form.
An example slice is:

 @$ranges_ref  @$maps_ref         Note
    ...
   0x00AA       97                FEMININE ORDINAL INDICATOR => 'a'
   0x00AB        0
   0x00AD                         SOFT HYPHEN => ""
   0x00AE        0
   0x00AF     [ 0x0020, 0x0304 ]  MACRON => SPACE . COMBINING MACRON
   0x00B0        0
   ...

The fourth (index [3]) element (C<$default>) in the list returned for this
format is 0.

=item B<C<ar>>

means that all the elements of the map array are either rational numbers or
the string C<"NaN">, meaning "Not a Number".  A rational number is either an
integer, or two integers separated by a solidus (C<"/">).  The second integer
represents the denominator of the division implied by the solidus, and is
actually always positive, so it is guaranteed not to be 0 and to not be
signed.  When the element is a plain integer (without the
solidus), it may need to be adjusted to get the correct value by adding the
offset, just as other C<"a"> properties.  No adjustment is needed for
fractions, as the range is guaranteed to have just a single element, and so
the offset is always 0.

If you want to convert the returned map to entirely scalar numbers, you
can use something like this:

 my ($invlist_ref, $invmap_ref, $format) = prop_invmap($property);
 if ($format && $format eq "ar") {
     map { $_ = eval $_ if $_ ne 'NaN' } @$map_ref;
 }

Here's some entries from the output of the property "Nv", which has format
C<"ar">.

 @numerics_ranges  @numerics_maps       Note
        0x00           "NaN"
        0x30             0           DIGIT 0 .. DIGIT 9
        0x3A           "NaN"
        0xB2             2           SUPERSCRIPTs 2 and 3
        0xB4           "NaN"
        0xB9             1           SUPERSCRIPT 1
        0xBA           "NaN"
        0xBC            1/4          VULGAR FRACTION 1/4
        0xBD            1/2          VULGAR FRACTION 1/2
        0xBE            3/4          VULGAR FRACTION 3/4
        0xBF           "NaN"
        0x660            0           ARABIC-INDIC DIGIT ZERO .. NINE
        0x66A          "NaN"

The fourth (index [3]) element (C<$default>) in the list returned for this
format is C<"NaN">.

=item B<C<n>>

means the Name property.  All the elements of the map array are simple
scalars, but some of them contain special strings that require more work to
get the actual name.

Entries such as:

 CJK UNIFIED IDEOGRAPH-<code point>

mean that the name for the code point is "CJK UNIFIED IDEOGRAPH-"
with the code point (expressed in hexadecimal) appended to it, like "CJK
UNIFIED IDEOGRAPH-3403" (similarly for S<C<CJK COMPATIBILITY IDEOGRAPH-E<lt>code
pointE<gt>>>).

Also, entries like

 <hangul syllable>

means that the name is algorithmically calculated.  This is easily done by
the function L<charnames/charnames::viacode(code)>.

Note that for control characters (C<Gc=cc>), Unicode's data files have the
string "C<E<lt>controlE<gt>>", but the real name of each of these characters is the empty
string.  This function returns that real name, the empty string.  (There are
names for these characters, but they are considered aliases, not the Name
property name, and are contained in the C<Name_Alias> property.)

=item B<C<ad>>

means the Decomposition_Mapping property.  This property is like C<"al">
properties, except that one of the scalar elements is of the form:

 <hangul syllable>

This signifies that this entry should be replaced by the decompositions for
all the code points whose decomposition is algorithmically calculated.  (All
of them are currently in one range and no others outside the range are likely
to ever be added to Unicode; the C<"n"> format
has this same entry.)  These can be generated via the function
L<Unicode::Normalize::NFD()|Unicode::Normalize>.

Note that the mapping is the one that is specified in the Unicode data files,
and to get the final decomposition, it may need to be applied recursively.
Unicode in fact discourages use of this property except internally in
implementations of the Unicode Normalization Algorithm.

The fourth (index [3]) element (C<$default>) in the list returned for this
format is 0.

=back

Note that a format begins with the letter "a" if and only the property it is
for requires adjustments by adding the offsets in multi-element ranges.  For
all these properties, an entry should be adjusted only if the map is a scalar
which is an integer.  That is, it must match the regular expression:

    / ^ -? \d+ $ /xa

Further, the first element in a range never needs adjustment, as the
adjustment would be just adding 0.

A binary search such as that provided by L</search_invlist()>, can be used to
quickly find a code point in the inversion list, and hence its corresponding
mapping.

The final, fourth element (index [3], assigned to C<$default> in the "block"
example) in the four element list returned by this function is used with the
C<"a"> format types; it may also be useful for applications
that wish to convert the returned inversion map data structure into some
other, such as a hash.  It gives the mapping that most code points map to
under the property.  If you establish the convention that any code point not
explicitly listed in your data structure maps to this value, you can
potentially make your data structure much smaller.  As you construct your data
structure from the one returned by this function, simply ignore those ranges
that map to this value.  For example, to
convert to the data structure searchable by L</charinrange()>, you can follow
this recipe for properties that don't require adjustments:

 my ($list_ref, $map_ref, $format, $default) = prop_invmap($property);
 my @range_list;

 # Look at each element in the list, but the -2 is needed because we
 # look at $i+1 in the loop, and the final element is guaranteed to map
 # to $default by prop_invmap(), so we would skip it anyway.
 for my $i (0 .. @$list_ref - 2) {
    next if $map_ref->[$i] eq $default;
    push @range_list, [ $list_ref->[$i],
                        $list_ref->[$i+1],
                        $map_ref->[$i]
                      ];
 }

 print charinrange(\@range_list, $code_point), "\n";

With this, C<charinrange()> will return C<undef> if its input code point maps
to C<$default>.  You can avoid this by omitting the C<next> statement, and adding
a line after the loop to handle the final element of the inversion map.

Similarly, this recipe can be used for properties that do require adjustments:

 for my $i (0 .. @$list_ref - 2) {
    next if $map_ref->[$i] eq $default;

    # prop_invmap() guarantees that if the mapping is to an array, the
    # range has just one element, so no need to worry about adjustments.
    if (ref $map_ref->[$i]) {
        push @range_list,
                   [ $list_ref->[$i], $list_ref->[$i], $map_ref->[$i] ];
    }
    else {  # Otherwise each element is actually mapped to a separate
            # value, so the range has to be split into single code point
            # ranges.

        my $adjustment = 0;

        # For each code point that gets mapped to something...
        for my $j ($list_ref->[$i] .. $list_ref->[$i+1] -1 ) {

            # ... add a range consisting of just it mapping to the
            # original plus the adjustment, which is incremented for the
            # next time through the loop, as the offset increases by 1
            # for each element in the range
            push @range_list,
                             [ $j, $j, $map_ref->[$i] + $adjustment++ ];
        }
    }
 }

Note that the inversion maps returned for the C<Case_Folding> and
C<Simple_Case_Folding> properties do not include the Turkic-locale mappings.
Use L</casefold()> for these.

C<prop_invmap> does not know about any user-defined properties, and will
return C<undef> if called with one of those.

The returned values for the Perl extension properties, such as C<Any> and
C<Greek> are somewhat misleading.  The values are either C<"Y"> or C<"N>".
All Unicode properties are bipartite, so you can actually use the C<"Y"> or
C<"N>" in a Perl regular expression for these, like C<qr/\p{ID_Start=Y/}> or
C<qr/\p{Upper=N/}>.  But the Perl extensions aren't specified this way, only
like C</qr/\p{Any}>, I<etc>.  You can't actually use the C<"Y"> and C<"N>" in
them.

=head3 Getting every available name

Instead of reading the Unicode Database directly from files, as you were able
to do for a long time, you are encouraged to use the supplied functions. So,
instead of reading C<Name.pl> directly, which changed formats in 5.32, and may
do so again without notice in the future or even disappear, you ought to use
L</prop_invmap()> like this:

  my (%name, %cp, %cps, $n);
  # All codepoints
  foreach my $cat (qw( Name Name_Alias )) {
      my ($codepoints, $names, $format, $default) = prop_invmap($cat);
      # $format => "n", $default => ""
      foreach my $i (0 .. @$codepoints - 2) {
