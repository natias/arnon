Perl uses "full" Unicode case mappings.  This means that converting a single
character to another case may result in a sequence of more than one character.
For example, the uppercase of C<E<223>> (LATIN SMALL LETTER SHARP S) is the two
character sequence C<SS>.  This presents some complications   The lowercase of
all characters in the range 0..255 is a single character, and thus
C<L</toLOWER_L1>> is furnished.  But, C<toUPPER_L1> can't exist, as it couldn't
return a valid result for all legal inputs.  Instead C<L</toUPPER_uvchr>> has
an API that does allow every possible legal result to be returned.)  Likewise
no other function that is crippled by not being able to give the correct
results for the full range of possible inputs has been implemented here.

=for apidoc Am|UV|toUPPER|UV cp
=for apidoc_item |UV|toUPPER_A|UV cp
=for apidoc_item |UV|toUPPER_utf8|U8* p|U8* e|U8* s|STRLEN* lenp
=for apidoc_item |UV|toUPPER_utf8_safe|U8* p|U8* e|U8* s|STRLEN* lenp
=for apidoc_item |UV|toUPPER_uvchr|UV cp|U8* s|STRLEN* lenp

These all return the uppercase of a character.  The differences are what domain
they operate on, and whether the input is specified as a code point (those
forms with a C<cp> parameter) or as a UTF-8 string (the others).  In the latter
case, the code point to use is the first one in the buffer of UTF-8 encoded
code points, delineated by the arguments S<C<p .. e - 1>>.

C<toUPPER> and C<toUPPER_A> are synonyms of each other.  They return the
uppercase of any lowercase ASCII-range code point.  All other inputs are
returned unchanged.  Since these are macros, the input type may be any integral
one, and the output will occupy the same number of bits as the input.

There is no C<toUPPER_L1> nor C<toUPPER_LATIN1> as the uppercase of some code
points in the 0..255 range is above that range or consists of multiple
characters.  Instead use C<toUPPER_uvchr>.

C<toUPPER_uvchr> returns the uppercase of any Unicode code point.  The return
value is identical to that of C<toUPPER_A> for input code points in the ASCII
range.  The uppercase of the vast majority of Unicode code points is the same
as the code point itself.  For these, and for code points above the legal
Unicode maximum, this returns the input code point unchanged.  It additionally
stores the UTF-8 of the result into the buffer beginning at C<s>, and its
length in bytes into C<*lenp>.  The caller must have made C<s> large enough to
contain at least C<UTF8_MAXBYTES_CASE+1> bytes to avoid possible overflow.

NOTE: the uppercase of a code point may be more than one code point.  The
return value of this function is only the first of these.  The entire uppercase
is returned in C<s>.  To determine if the result is more than a single code
point, you can do something like this:

 uc = toUPPER_uvchr(cp, s, &len);
 if (len > UTF8SKIP(s)) { is multiple code points }
 else { is a single code point }

C<toUPPER_utf8> and C<toUPPER_utf8_safe> are synonyms of each other.  The only
difference between these and C<toUPPER_uvchr> is that the source for these is
encoded in UTF-8, instead of being a code point.  It is passed as a buffer
starting at C<p>, with C<e> pointing to one byte beyond its end.  The C<p>
buffer may certainly contain more than one code point; but only the first one
(up through S<C<e - 1>>) is examined.  If the UTF-8 for the input character is
malformed in some way, the program may croak, or the function may return the
REPLACEMENT CHARACTER, at the discretion of the implementation, and subject to
change in future releases.

=for apidoc Am|UV|toFOLD|UV cp
=for apidoc_item |UV|toFOLD_A|UV cp
=for apidoc_item |UV|toFOLD_utf8|U8* p|U8* e|U8* s|STRLEN* lenp
=for apidoc_item |UV|toFOLD_utf8_safe|U8* p|U8* e|U8* s|STRLEN* lenp
=for apidoc_item |UV|toFOLD_uvchr|UV cp|U8* s|STRLEN* lenp

These all return the foldcase of a character.  "foldcase" is an internal case
for C</i> pattern matching. If the foldcase of character A and the foldcase of
character B are the same, they match caselessly; otherwise they don't.

The differences in the forms are what domain they operate on, and whether the
input is specified as a code point (those forms with a C<cp> parameter) or as a
UTF-8 string (the others).  In the latter case, the code point to use is the
first one in the buffer of UTF-8 encoded code points, delineated by the
arguments S<C<p .. e - 1>>.

C<toFOLD> and C<toFOLD_A> are synonyms of each other.  They return the
foldcase of any ASCII-range code point.  In this range, the foldcase is
identical to the lowercase.  All other inputs are returned unchanged.  Since
these are macros, the input type may be any integral one, and the output will
occupy the same number of bits as the input.

There is no C<toFOLD_L1> nor C<toFOLD_LATIN1> as the foldcase of some code
points in the 0..255 range is above that range or consists of multiple
characters.  Instead use C<toFOLD_uvchr>.

C<toFOLD_uvchr> returns the foldcase of any Unicode code point.  The return
value is identical to that of C<toFOLD_A> for input code points in the ASCII
range.  The foldcase of the vast majority of Unicode code points is the same
as the code point itself.  For these, and for code points above the legal
Unicode maximum, this returns the input code point unchanged.  It additionally
stores the UTF-8 of the result into the buffer beginning at C<s>, and its
length in bytes into C<*lenp>.  The caller must have made C<s> large enough to
contain at least C<UTF8_MAXBYTES_CASE+1> bytes to avoid possible overflow.

NOTE: the foldcase of a code point may be more than one code point.  The
return value of this function is only the first of these.  The entire foldcase
is returned in C<s>.  To determine if the result is more than a single code
point, you can do something like this:

 uc = toFOLD_uvchr(cp, s, &len);
 if (len > UTF8SKIP(s)) { is multiple code points }
 else { is a single code point }

C<toFOLD_utf8> and C<toFOLD_utf8_safe> are synonyms of each other.  The only
difference between these and C<toFOLD_uvchr> is that the source for these is
encoded in UTF-8, instead of being a code point.  It is passed as a buffer
starting at C<p>, with C<e> pointing to one byte beyond its end.  The C<p>
buffer may certainly contain more than one code point; but only the first one
(up through S<C<e - 1>>) is examined.  If the UTF-8 for the input character is
malformed in some way, the program may croak, or the function may return the
REPLACEMENT CHARACTER, at the discretion of the implementation, and subject to
change in future releases.

=for apidoc Am|UV|toLOWER|UV cp
=for apidoc_item |UV|toLOWER_A|UV cp
=for apidoc_item |UV|toLOWER_LATIN1|UV cp
=for apidoc_item |UV|toLOWER_LC|UV cp
=for apidoc_item |UV|toLOWER_L1|UV cp
=for apidoc_item |UV|toLOWER_utf8|U8* p|U8* e|U8* s|STRLEN* lenp
=for apidoc_item |UV|toLOWER_utf8_safe|U8* p|U8* e|U8* s|STRLEN* lenp
=for apidoc_item |UV|toLOWER_uvchr|UV cp|U8* s|STRLEN* lenp

These all return the lowercase of a character.  The differences are what domain
they operate on, and whether the input is specified as a code point (those
forms with a C<cp> parameter) or as a UTF-8 string (the others).  In the latter
case, the code point to use is the first one in the buffer of UTF-8 encoded
code points, delineated by the arguments S<C<p .. e - 1>>.

C<toLOWER> and C<toLOWER_A> are synonyms of each other.  They return the
lowercase of any uppercase ASCII-range code point.  All other inputs are
returned unchanged.  Since these are macros, the input type may be any integral
one, and the output will occupy the same number of bits as the input.

C<toLOWER_L1> and C<toLOWER_LATIN1> are synonyms of each other.  They behave
identically as C<toLOWER> for ASCII-range input.  But additionally will return
the lowercase of any uppercase code point in the entire 0..255 range, assuming
a Latin-1 encoding (or the EBCDIC equivalent on such platforms).

C<toLOWER_LC> returns the lowercase of the input code point according to the
rules of the current POSIX locale.  Input code points outside the range 0..255
are returned unchanged.

C<toLOWER_uvchr> returns the lowercase of any Unicode code point.  The return
value is identical to that of C<toLOWER_L1> for input code points in the 0..255
range.  The lowercase of the vast majority of Unicode code points is the same
as the code point itself.  For these, and for code points above the legal
Unicode maximum, this returns the input code point unchanged.  It additionally
stores the UTF-8 of the result into the buffer beginning at C<s>, and its
length in bytes into C<*lenp>.  The caller must have made C<s> large enough to
contain at least C<UTF8_MAXBYTES_CASE+1> bytes to avoid possible overflow.

NOTE: the lowercase of a code point may be more than one code point.  The
return value of this function is only the first of these.  The entire lowercase
is returned in C<s>.  To determine if the result is more than a single code
point, you can do something like this:

 uc = toLOWER_uvchr(cp, s, &len);
 if (len > UTF8SKIP(s)) { is multiple code points }
 else { is a single code point }

C<toLOWER_utf8> and C<toLOWER_utf8_safe> are synonyms of each other.  The only
difference between these and C<toLOWER_uvchr> is that the source for these is
encoded in UTF-8, instead of being a code point.  It is passed as a buffer
starting at C<p>, with C<e> pointing to one byte beyond its end.  The C<p>
buffer may certainly contain more than one code point; but only the first one
(up through S<C<e - 1>>) is examined.  If the UTF-8 for the input character is
malformed in some way, the program may croak, or the function may return the
REPLACEMENT CHARACTER, at the discretion of the implementation, and subject to
change in future releases.

=for apidoc Am|UV|toTITLE|UV cp
=for apidoc_item |UV|toTITLE_A|UV cp
=for apidoc_item |UV|toTITLE_utf8|U8* p|U8* e|U8* s|STRLEN* lenp
=for apidoc_item |UV|toTITLE_utf8_safe|U8* p|U8* e|U8* s|STRLEN* lenp
=for apidoc_item |UV|toTITLE_uvchr|UV cp|U8* s|STRLEN* lenp

These all return the titlecase of a character.  The differences are what domain
they operate on, and whether the input is specified as a code point (those
forms with a C<cp> parameter) or as a UTF-8 string (the others).  In the latter
case, the code point to use is the first one in the buffer of UTF-8 encoded
code points, delineated by the arguments S<C<p .. e - 1>>.

C<toTITLE> and C<toTITLE_A> are synonyms of each other.  They return the
titlecase of any lowercase ASCII-range code point.  In this range, the
titlecase is identical to the uppercase.  All other inputs are returned
unchanged.  Since these are macros, the input type may be any integral one, and
the output will occupy the same number of bits as the input.

There is no C<toTITLE_L1> nor C<toTITLE_LATIN1> as the titlecase of some code
points in the 0..255 range is above that range or consists of multiple
characters.  Instead use C<toTITLE_uvchr>.

C<toTITLE_uvchr> returns the titlecase of any Unicode code point.  The return
value is identical to that of C<toTITLE_A> for input code points in the ASCII
range.  The titlecase of the vast majority of Unicode code points is the same
as the code point itself.  For these, and for code points above the legal
Unicode maximum, this returns the input code point unchanged.  It additionally
stores the UTF-8 of the result into the buffer beginning at C<s>, and its
length in bytes into C<*lenp>.  The caller must have made C<s> large enough to
contain at least C<UTF8_MAXBYTES_CASE+1> bytes to avoid possible overflow.

NOTE: the titlecase of a code point may be more than one code point.  The
return value of this function is only the first of these.  The entire titlecase
is returned in C<s>.  To determine if the result is more than a single code
point, you can do something like this:

 uc = toTITLE_uvchr(cp, s, &len);
 if (len > UTF8SKIP(s)) { is multiple code points }
 else { is a single code point }

C<toTITLE_utf8> and C<toTITLE_utf8_safe> are synonyms of each other.  The only
difference between these and C<toTITLE_uvchr> is that the source for these is
encoded in UTF-8, instead of being a code point.  It is passed as a buffer
starting at C<p>, with C<e> pointing to one byte beyond its end.  The C<p>
buffer may certainly contain more than one code point; but only the first one
(up through S<C<e - 1>>) is examined.  If the UTF-8 for the input character is
malformed in some way, the program may croak, or the function may return the
REPLACEMENT CHARACTER, at the discretion of the implementation, and subject to
change in future releases.

=cut

XXX Still undocumented isVERTWS_uvchr and _utf8; it's unclear what their names
really should be.  Also toUPPER_LC and toFOLD_LC, which are subject to change,
and aren't general purpose as they don't work on U+DF, and assert against that.
and isCASED_LC, as it really is more of an internal thing.

Note that these macros are repeated in Devel::PPPort, so should also be
patched there.  The file as of this writing is cpan/Devel-PPPort/parts/inc/misc

*/

/*
   void below because that's the best fit, and works for Devel::PPPort
=for apidoc_section $integer
=for apidoc AyT||WIDEST_UTYPE

Yields the widest unsigned integer type on the platform, currently either
C<U32> or C<U64>.  This can be used in declarations such as

 WIDEST_UTYPE my_uv;

or casts

 my_uv = (WIDEST_UTYPE) val;

=cut

*/
#define WIDEST_UTYPE PERL_UINTMAX_T

/* Where there could be some confusion, use this as a static assert in macros
 * to make sure that a parameter isn't a pointer.  But some compilers can't
 * handle this.  The only one known so far that doesn't is gcc 3.3.6; the check
 * below isn't thorough for such an old compiler, so may have to be revised if
 * experience so dictates. */
#if  ! PERL_IS_GCC || PERL_GCC_VERSION_GT(3,3,6)
#  define ASSERT_NOT_PTR(x) ((x) | 0)
#else
#  define ASSERT_NOT_PTR(x) (x)
#endif

/* Likewise, this is effectively a static assert to be used to guarantee the
 * parameter is a pointer
 *
 * NOT suitable for void* 
 */
#define ASSERT_IS_PTR(x) (__ASSERT_(sizeof(*(x))) (x))

/* FITS_IN_8_BITS(c) returns true if c doesn't have  a bit set other than in
 * the lower 8.  It is designed to be hopefully bomb-proof, making sure that no
 * bits of information are lost even on a 64-bit machine, but to get the
 * compiler to optimize it out if possible.  This is because Configure makes
 * sure that the machine has an 8-bit byte, so if c is stored in a byte, the
 * sizeof() guarantees that this evaluates to a constant true at compile time.
 *
 * For Coverity, be always true, because otherwise Coverity thinks
 * it finds several expressions that are always true, independent
 * of operands.  Well, they are, but that is kind of the point.
 */
#ifndef __COVERITY__
  /* The '| 0' part in ASSERT_NOT_PTR ensures a compiler error if c is not
   * integer (like e.g., a pointer) */
#  define FITS_IN_8_BITS(c) (   (sizeof(c) == 1)                            \
                             || (((WIDEST_UTYPE) ASSERT_NOT_PTR(c)) >> 8) == 0)
#else
#  define FITS_IN_8_BITS(c) (1)
#endif

/* Returns true if l <= c <= (l + n), where 'l' and 'n' are non-negative
 * Written this way so that after optimization, only one conditional test is
 * needed.  (The NV casts stop any warnings about comparison always being true
 * if called with an unsigned.  The cast preserves the sign, which is all we
 * care about.) */
#define withinCOUNT(c, l, n)  (__ASSERT_((NV) (l) >= 0)                 \
                               __ASSERT_((NV) (n) >= 0)                 \
                               withinCOUNT_KNOWN_VALID_((c), (l), (n)))

/* For internal use only, this can be used in places where it is known that the
 * parameters to withinCOUNT() are valid, to avoid the asserts.  For example,
 * inRANGE() below, calls this several times, but does all the necessary
 * asserts itself, once.  The reason that this is necessary is that the
 * duplicate asserts were exceeding the internal limits of some compilers */
#define withinCOUNT_KNOWN_VALID_(c, l, n)                                   \
    ((((WIDEST_UTYPE) (c)) - ASSERT_NOT_PTR(l))                             \
                                   <= ((WIDEST_UTYPE) ASSERT_NOT_PTR(n)))

/* Returns true if c is in the range l..u, where 'l' is non-negative
 * Written this way so that after optimization, only one conditional test is
 * needed. */
#define inRANGE(c, l, u) (__ASSERT_((NV) (l) >= 0) __ASSERT_((u) >= (l))    \
   (  (sizeof(c) == sizeof(U8))  ? inRANGE_helper_(U8, (c), (l), ((u)))     \
    : (sizeof(c) == sizeof(U16)) ? inRANGE_helper_(U16,(c), (l), ((u)))     \
    : (sizeof(c) == sizeof(U32)) ? inRANGE_helper_(U32,(c), (l), ((u)))     \
             : (__ASSERT_(sizeof(c) == sizeof(WIDEST_UTYPE))                \
                          inRANGE_helper_(WIDEST_UTYPE,(c), (l), ((u))))))

/* For internal use, this is used by machine-generated code which generates
 * known valid calls, with a known sizeof().  This avoids the extra code and
 * asserts that were exceeding internal limits of some compilers. */
#define inRANGE_helper_(cast, c, l, u)                                      \
                    withinCOUNT_KNOWN_VALID_(((cast) (c)), (l), ((u) - (l)))

#ifdef EBCDIC
#   ifndef _ALL_SOURCE
        /* The native libc isascii() et.al. functions return the wrong results
         * on at least z/OS unless this is defined. */
#       error   _ALL_SOURCE should probably be defined
#   endif
#else
    /* There is a simple definition of ASCII for ASCII platforms.  But the
     * EBCDIC one isn't so simple, so is defined using table look-up like the
     * other macros below.
     *
     * The cast here is used instead of '(c) >= 0', because some compilers emit
     * a warning that that test is always true when the parameter is an
     * unsigned type.  khw supposes that it could be written as
     *      && ((c) == '\0' || (c) > 0)
     * to avoid the message, but the cast will likely avoid extra branches even
     * with stupid compilers. */
#   define isASCII(c)    (((WIDEST_UTYPE) ASSERT_NOT_PTR(c)) < 128)
#endif

/* Take the eight possible bit patterns of the lower 3 bits and you get the
 * lower 3 bits of the 8 octal digits, in both ASCII and EBCDIC, so those bits
 * can be ignored.  If the rest match '0', we have an octal */
#define isOCTAL_A(c)  ((((WIDEST_UTYPE) ASSERT_NOT_PTR(c)) & ~7) == '0')

#ifdef H_PERL       /* If have access to perl.h, lookup in its table */

/* Character class numbers.  For internal core Perl use only.  The ones less
 * than 32 are used in PL_charclass[] and the ones up through the one that
 * corresponds to <HIGHEST_REGCOMP_DOT_H_SYNC_> are used by regcomp.h and
 * related files.  PL_charclass ones use names used in l1_char_class_tab.h but
 * their actual definitions are here.  If that file has a name not used here,
 * it won't compile.
 *
 * The first group of these is ordered in what I (khw) estimate to be the
 * frequency of their use.  This gives a slight edge to exiting a loop earlier
 * (in reginclass() in regexec.c).  Except \v should be last, as it isn't a
 * real Posix character class, and some (small) inefficiencies in regular
 * expression handling would be introduced by putting it in the middle of those
 * that are.  Also, cntrl and ascii come after the others as it may be useful
 * to group these which have no members that match above Latin1, (or above
 * ASCII in the latter case) */

#  define CC_WORDCHAR_           0      /* \w and [:word:] */
#  define CC_DIGIT_              1      /* \d and [:digit:] */
#  define CC_ALPHA_              2      /* [:alpha:] */
#  define CC_LOWER_              3      /* [:lower:] */
#  define CC_UPPER_              4      /* [:upper:] */
#  define CC_PUNCT_              5      /* [:punct:] */
#  define CC_PRINT_              6      /* [:print:] */
#  define CC_ALPHANUMERIC_       7      /* [:alnum:] */
#  define CC_GRAPH_              8      /* [:graph:] */
#  define CC_CASED_              9      /* [:lower:] or [:upper:] under /i */
#  define CC_SPACE_             10      /* \s, [:space:] */
#  define CC_BLANK_             11      /* [:blank:] */
#  define CC_XDIGIT_            12      /* [:xdigit:] */
#  define CC_CNTRL_             13      /* [:cntrl:] */
#  define CC_ASCII_             14      /* [:ascii:] */
#  define CC_VERTSPACE_         15      /* \v */

#  define HIGHEST_REGCOMP_DOT_H_SYNC_ CC_VERTSPACE_

/* The members of the third group below do not need to be coordinated with data
 * structures in regcomp.[ch] and regexec.c. */
#  define CC_IDFIRST_                  16
#  define CC_CHARNAME_CONT_            17
#  define CC_NONLATIN1_FOLD_           18
#  define CC_NONLATIN1_SIMPLE_FOLD_    19
#  define CC_QUOTEMETA_                20
#  define CC_NON_FINAL_FOLD_           21
#  define CC_IS_IN_SOME_FOLD_          22
#  define CC_BINDIGIT_                 23
#  define CC_OCTDIGIT_                 24
#  define CC_MNEMONIC_CNTRL_           25

/* Unused: 26-31
 * If more bits are needed, one could add a second word for non-64bit
 * QUAD_IS_INT systems, using some #ifdefs to distinguish between having a 2nd
 * word or not.  The IS_IN_SOME_FOLD bit is the most easily expendable, as it
 * is used only for optimization (as of this writing), and differs in the
 * Latin1 range from the ALPHA bit only in two relatively unimportant
 * characters: the masculine and feminine ordinal indicators, so removing it
 * would just cause /i regexes which match them to run less efficiently.
 * Similarly the EBCDIC-only bits are used just for speed, and could be
 * replaced by other means */

#if defined(PERL_CORE) || defined(PERL_EXT)
/* An enum version of the character class numbers, to help compilers
 * optimize */
typedef enum {
    CC_ENUM_ALPHA_          = CC_ALPHA_,
    CC_ENUM_ALPHANUMERIC_   = CC_ALPHANUMERIC_,
    CC_ENUM_ASCII_          = CC_ASCII_,
    CC_ENUM_BLANK_          = CC_BLANK_,
    CC_ENUM_CASED_          = CC_CASED_,
    CC_ENUM_CNTRL_          = CC_CNTRL_,
    CC_ENUM_DIGIT_          = CC_DIGIT_,
    CC_ENUM_GRAPH_          = CC_GRAPH_,
    CC_ENUM_LOWER_          = CC_LOWER_,
    CC_ENUM_PRINT_          = CC_PRINT_,
    CC_ENUM_PUNCT_          = CC_PUNCT_,
    CC_ENUM_SPACE_          = CC_SPACE_,
    CC_ENUM_UPPER_          = CC_UPPER_,
    CC_ENUM_VERTSPACE_      = CC_VERTSPACE_,
    CC_ENUM_WORDCHAR_       = CC_WORDCHAR_,
    CC_ENUM_XDIGIT_         = CC_XDIGIT_
} char_class_number_;
#endif

#define POSIX_CC_COUNT    (HIGHEST_REGCOMP_DOT_H_SYNC_ + 1)

START_EXTERN_C
#  ifdef DOINIT
EXTCONST  U32 PL_charclass[] = {
#    include "l1_char_class_tab.h"
};

#  else /* ! DOINIT */
EXTCONST U32 PL_charclass[];
#  endif
END_EXTERN_C

    /* The 1U keeps Solaris from griping when shifting sets the uppermost bit */
#   define CC_mask_(classnum) (1U << (classnum))

    /* For internal core Perl use only: the base macro for defining macros like
     * isALPHA */
#   define generic_isCC_(c, classnum) cBOOL(FITS_IN_8_BITS(c)    \
                && (PL_charclass[(U8) (c)] & CC_mask_(classnum)))

    /* The mask for the _A versions of the macros; it just adds in the bit for
     * ASCII. */
#   define CC_mask_A_(classnum) (CC_mask_(classnum) | CC_mask_(CC_ASCII_))

    /* For internal core Perl use only: the base macro for defining macros like
     * isALPHA_A.  The foo_A version makes sure that both the desired bit and
     * the ASCII bit are present */
#   define generic_isCC_A_(c, classnum) (FITS_IN_8_BITS(c)      \
        && ((PL_charclass[(U8) (c)] & CC_mask_A_(classnum))     \
                                   == CC_mask_A_(classnum)))

/* On ASCII platforms certain classes form a single range.  It's faster to
 * special case these.  isDIGIT is a single range on all platforms */
#   ifdef EBCDIC
#     define isALPHA_A(c)  generic_isCC_A_(c, CC_ALPHA_)
#     define isGRAPH_A(c)  generic_isCC_A_(c, CC_GRAPH_)
#     define isLOWER_A(c)  generic_isCC_A_(c, CC_LOWER_)
#     define isPRINT_A(c)  generic_isCC_A_(c, CC_PRINT_)
#     define isUPPER_A(c)  generic_isCC_A_(c, CC_UPPER_)
#   else
      /* By folding the upper and lowercase, we can use a single range */
#     define isALPHA_A(c)  inRANGE((~('A' ^ 'a') & (c)), 'A', 'Z')
#     define isGRAPH_A(c)  inRANGE(c, ' ' + 1, 0x7e)
#     define isLOWER_A(c)  inRANGE(c, 'a', 'z')
#     define isPRINT_A(c)  inRANGE(c, ' ', 0x7e)
#     define isUPPER_A(c)  inRANGE(c, 'A', 'Z')
#   endif
#   define isALPHANUMERIC_A(c) generic_isCC_A_(c, CC_ALPHANUMERIC_)
#   define isBLANK_A(c)  generic_isCC_A_(c, CC_BLANK_)
#   define isCNTRL_A(c)  generic_isCC_A_(c, CC_CNTRL_)
#   define isDIGIT_A(c)  inRANGE(c, '0', '9')
#   define isPUNCT_A(c)  generic_isCC_A_(c, CC_PUNCT_)
#   define isSPACE_A(c)  generic_isCC_A_(c, CC_SPACE_)
#   define isWORDCHAR_A(c) generic_isCC_A_(c, CC_WORDCHAR_)
#   define isXDIGIT_A(c)  generic_isCC_(c, CC_XDIGIT_) /* No non-ASCII xdigits */
#   define isIDFIRST_A(c) generic_isCC_A_(c, CC_IDFIRST_)
#   define isALPHA_L1(c)  generic_isCC_(c, CC_ALPHA_)
#   define isALPHANUMERIC_L1(c) generic_isCC_(c, CC_ALPHANUMERIC_)
#   define isBLANK_L1(c)  generic_isCC_(c, CC_BLANK_)

    /* continuation character for legal NAME in \N{NAME} */
#   define isCHARNAME_CONT(c) generic_isCC_(c, CC_CHARNAME_CONT_)

#   define isCNTRL_L1(c)  generic_isCC_(c, CC_CNTRL_)
#   define isGRAPH_L1(c)  generic_isCC_(c, CC_GRAPH_)
#   define isLOWER_L1(c)  generic_isCC_(c, CC_LOWER_)
#   define isPRINT_L1(c)  generic_isCC_(c, CC_PRINT_)
#   define isPSXSPC_L1(c)  isSPACE_L1(c)
#   define isPUNCT_L1(c)  generic_isCC_(c, CC_PUNCT_)
#   define isSPACE_L1(c)  generic_isCC_(c, CC_SPACE_)
#   define isUPPER_L1(c)  generic_isCC_(c, CC_UPPER_)
#   define isWORDCHAR_L1(c) generic_isCC_(c, CC_WORDCHAR_)
#   define isIDFIRST_L1(c) generic_isCC_(c, CC_IDFIRST_)

#   ifdef EBCDIC
#       define isASCII(c) generic_isCC_(c, CC_ASCII_)
#   endif

    /* Participates in a single-character fold with a character above 255 */
#   if defined(PERL_IN_REGCOMP_ANY) || defined(PERL_IN_REGEXEC_C)
#     define HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(c)                           \
        ((   ! cBOOL(FITS_IN_8_BITS(c)))                                    \
          || (PL_charclass[(U8) (c)] & CC_mask_(CC_NONLATIN1_SIMPLE_FOLD_)))

#   define IS_NON_FINAL_FOLD(c)   generic_isCC_(c, CC_NON_FINAL_FOLD_)
#   define IS_IN_SOME_FOLD_L1(c)  generic_isCC_(c, CC_IS_IN_SOME_FOLD_)
#  endif

    /* Like the above, but also can be part of a multi-char fold */
#   define HAS_NONLATIN1_FOLD_CLOSURE(c)                                    \
      (   (! cBOOL(FITS_IN_8_BITS(c)))                                      \
       || (PL_charclass[(U8) (c)] & CC_mask_(CC_NONLATIN1_FOLD_)))

#   define _isQUOTEMETA(c) generic_isCC_(c, CC_QUOTEMETA_)

/* is c a control character for which we have a mnemonic? */
#  if defined(PERL_CORE) || defined(PERL_EXT)
#     define isMNEMONIC_CNTRL(c) generic_isCC_(c, CC_MNEMONIC_CNTRL_)
#  endif
#else   /* else we don't have perl.h H_PERL */

    /* If we don't have perl.h, we are compiling a utility program.  Below we
     * hard-code various macro definitions that wouldn't otherwise be available
     * to it. Most are coded based on first principles.  These are written to
     * avoid EBCDIC vs. ASCII #ifdef's as much as possible. */
#   define isDIGIT_A(c)  inRANGE(c, '0', '9')
#   define isBLANK_A(c)  ((c) == ' ' || (c) == '\t')
#   define isSPACE_A(c)  (isBLANK_A(c)                                   \
                          || (c) == '\n'                                 \
                          || (c) == '\r'                                 \
                          || (c) == '\v'                                 \
                          || (c) == '\f')
    /* On EBCDIC, there are gaps between 'i' and 'j'; 'r' and 's'.  Same for
     * uppercase.  The tests for those aren't necessary on ASCII, but hurt only
     * performance (if optimization isn't on), and allow the same code to be
     * used for both platform types */
#   define isLOWER_A(c)  inRANGE((c), 'a', 'i')                         \
                      || inRANGE((c), 'j', 'r')                         \
                      || inRANGE((c), 's', 'z')
#   define isUPPER_A(c)  inRANGE((c), 'A', 'I')                         \
                      || inRANGE((c), 'J', 'R')                         \
                      || inRANGE((c), 'S', 'Z')
#   define isALPHA_A(c)  (isUPPER_A(c) || isLOWER_A(c))
#   define isALPHANUMERIC_A(c) (isALPHA_A(c) || isDIGIT_A(c))
#   define isWORDCHAR_A(c)   (isALPHANUMERIC_A(c) || (c) == '_')
#   define isIDFIRST_A(c)    (isALPHA_A(c) || (c) == '_')
#   define isXDIGIT_A(c) (   isDIGIT_A(c)                               \
                          || inRANGE((c), 'a', 'f')                     \
                          || inRANGE((c), 'A', 'F')
#   define isPUNCT_A(c)  ((c) == '-' || (c) == '!' || (c) == '"'        \
                       || (c) == '#' || (c) == '$' || (c) == '%'        \
                       || (c) == '&' || (c) == '\'' || (c) == '('       \
                       || (c) == ')' || (c) == '*' || (c) == '+'        \
                       || (c) == ',' || (c) == '.' || (c) == '/'        \
                       || (c) == ':' || (c) == ';' || (c) == '<'        \
                       || (c) == '=' || (c) == '>' || (c) == '?'        \
                       || (c) == '@' || (c) == '[' || (c) == '\\'       \
                       || (c) == ']' || (c) == '^' || (c) == '_'        \
                       || (c) == '`' || (c) == '{' || (c) == '|'        \
                       || (c) == '}' || (c) == '~')
#   define isGRAPH_A(c)  (isALPHANUMERIC_A(c) || isPUNCT_A(c))
#   define isPRINT_A(c)  (isGRAPH_A(c) || (c) == ' ')

#   ifdef EBCDIC
        /* The below is accurate for the 3 EBCDIC code pages traditionally
         * supported by perl.  The only difference between them in the controls
         * is the position of \n, and that is represented symbolically below */
#       define isCNTRL_A(c)  ((c) == '\0' || (c) == '\a' || (c) == '\b'     \
                          ||  (c) == '\f' || (c) == '\n' || (c) == '\r'     \
                          ||  (c) == '\t' || (c) == '\v'                    \
                          || inRANGE((c), 1, 3)     /* SOH, STX, ETX */     \
                          ||  (c) == 7F   /* U+7F DEL */                    \
                          || inRANGE((c), 0x0E, 0x13) /* SO SI DLE          \
                                                         DC[1-3] */         \
                          ||  (c) == 0x18 /* U+18 CAN */                    \
                          ||  (c) == 0x19 /* U+19 EOM */                    \
                          || inRANGE((c), 0x1C, 0x1F) /* [FGRU]S */         \
                          ||  (c) == 0x26 /* U+17 ETB */                    \
                          ||  (c) == 0x27 /* U+1B ESC */                    \
                          ||  (c) == 0x2D /* U+05 ENQ */                    \
                          ||  (c) == 0x2E /* U+06 ACK */                    \
                          ||  (c) == 0x32 /* U+16 SYN */                    \
                          ||  (c) == 0x37 /* U+04 EOT */                    \
                          ||  (c) == 0x3C /* U+14 DC4 */                    \
                          ||  (c) == 0x3D /* U+15 NAK */                    \
                          ||  (c) == 0x3F)/* U+1A SUB */
#       define isASCII(c)    (isCNTRL_A(c) || isPRINT_A(c))
#   else /* isASCII is already defined for ASCII platforms, so can use that to
            define isCNTRL */
#       define isCNTRL_A(c)  (isASCII(c) && ! isPRINT_A(c))
#   endif

    /* The _L1 macros may be unnecessary for the utilities; I (khw) added them
     * during debugging, and it seems best to keep them.  We may be called
     * without NATIVE_TO_LATIN1 being defined.  On ASCII platforms, it doesn't
     * do anything anyway, so make it not a problem */
#   if ! defined(EBCDIC) && ! defined(NATIVE_TO_LATIN1)
#       define NATIVE_TO_LATIN1(ch) (ch)
#   endif
#   define isALPHA_L1(c)     (isUPPER_L1(c) || isLOWER_L1(c))
#   define isALPHANUMERIC_L1(c) (isALPHA_L1(c) || isDIGIT_A(c))
#   define isBLANK_L1(c)     (isBLANK_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && NATIVE_TO_LATIN1((U8) c) == 0xA0))
#   define isCNTRL_L1(c)     (FITS_IN_8_BITS(c) && (! isPRINT_L1(c)))
#   define isGRAPH_L1(c)     (isPRINT_L1(c) && (! isBLANK_L1(c)))
#   define isLOWER_L1(c)     (isLOWER_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && ((   NATIVE_TO_LATIN1((U8) c) >= 0xDF   \
                                       && NATIVE_TO_LATIN1((U8) c) != 0xF7)  \
                                       || NATIVE_TO_LATIN1((U8) c) == 0xAA   \
                                       || NATIVE_TO_LATIN1((U8) c) == 0xBA   \
                                       || NATIVE_TO_LATIN1((U8) c) == 0xB5)))
#   define isPRINT_L1(c)     (isPRINT_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && NATIVE_TO_LATIN1((U8) c) >= 0xA0))
#   define isPUNCT_L1(c)     (isPUNCT_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && (   NATIVE_TO_LATIN1((U8) c) == 0xA1    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xA7    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xAB    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xB6    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xB7    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xBB    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xBF)))
#   define isSPACE_L1(c)     (isSPACE_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && (   NATIVE_TO_LATIN1((U8) c) == 0x85    \
                                      || NATIVE_TO_LATIN1((U8) c) == 0xA0)))
#   define isUPPER_L1(c)     (isUPPER_A(c)                                   \
                              || (FITS_IN_8_BITS(c)                          \
                                  && (   IN_RANGE(NATIVE_TO_LATIN1((U8) c),  \
                                                  0xC0, 0xDE)                \
                                      && NATIVE_TO_LATIN1((U8) c) != 0xD7)))
#   define isWORDCHAR_L1(c)  (isIDFIRST_L1(c) || isDIGIT_A(c))
#   define isIDFIRST_L1(c)   (isALPHA_L1(c) || NATIVE_TO_LATIN1(c) == '_')
#   define isCHARNAME_CONT(c) (isWORDCHAR_L1(c)                              \
                               || isBLANK_L1(c)                              \
                               || (c) == '-'                                 \
                               || (c) == '('                                 \
                               || (c) == ')')
    /* The following are not fully accurate in the above-ASCII range.  I (khw)
     * don't think it's necessary to be so for the purposes where this gets
     * compiled */
#   define isQUOTEMETA_(c)      (FITS_IN_8_BITS(c) && ! isWORDCHAR_L1(c))

    /* Many of the macros later in this file are defined in terms of these.  By
     * implementing them with a function, which converts the class number into
     * a call to the desired macro, all of the later ones work.  However, that
     * function won't be actually defined when building a utility program (no
     * perl.h), and so a compiler error will be generated if one is attempted
     * to be used.  And the above-Latin1 code points require Unicode tables to
     * be present, something unlikely to be the case when bootstrapping */
#   define generic_isCC_(c, classnum)                                        \
         (FITS_IN_8_BITS(c) && S_bootstrap_ctype((U8) (c), (classnum), TRUE))
#   define generic_isCC_A_(c, classnum)                                      \
         (FITS_IN_8_BITS(c) && S_bootstrap_ctype((U8) (c), (classnum), FALSE))
#endif  /* End of no perl.h H_PERL */

#define isALPHANUMERIC(c)  isALPHANUMERIC_A(c)
#define isALPHA(c)   isALPHA_A(c)
#define isASCII_A(c)  isASCII(c)
#define isASCII_L1(c)  isASCII(c)
#define isBLANK(c)   isBLANK_A(c)
#define isCNTRL(c)   isCNTRL_A(c)
#define isDIGIT(c)   isDIGIT_A(c)
#define isGRAPH(c)   isGRAPH_A(c)
#define isIDFIRST(c) isIDFIRST_A(c)
#define isLOWER(c)   isLOWER_A(c)
#define isPRINT(c)   isPRINT_A(c)
#define isPSXSPC_A(c) isSPACE_A(c)
#define isPSXSPC(c)  isPSXSPC_A(c)
#define isPSXSPC_L1(c) isSPACE_L1(c)
#define isPUNCT(c)   isPUNCT_A(c)
#define isSPACE(c)   isSPACE_A(c)
#define isUPPER(c)   isUPPER_A(c)
#define isWORDCHAR(c) isWORDCHAR_A(c)
#define isXDIGIT(c)  isXDIGIT_A(c)

/* ASCII casing.  These could also be written as
    #define toLOWER(c) (isASCII(c) ? toLOWER_LATIN1(c) : (c))
    #define toUPPER(c) (isASCII(c) ? toUPPER_LATIN1_MOD(c) : (c))
   which uses table lookup and mask instead of subtraction.  (This would
   work because the _MOD does not apply in the ASCII range).

   These actually are UTF-8 invariant casing, not just ASCII, as any non-ASCII
   UTF-8 invariants are neither upper nor lower.  (Only on EBCDIC platforms are
   there non-ASCII invariants, and all of them are controls.) */
#define toLOWER(c)  (isUPPER(c) ? (U8)((c) + ('a' - 'A')) : (c))
#define toUPPER(c)  (isLOWER(c) ? (U8)((c) - ('a' - 'A')) : (c))

/* In the ASCII range, these are equivalent to what they're here defined to be.
 * But by creating these definitions, other code doesn't have to be aware of
 * this detail.  Actually this works for all UTF-8 invariants, not just the
 * ASCII range. (EBCDIC platforms can have non-ASCII invariants.) */
#define toFOLD(c)    toLOWER(c)
#define toTITLE(c)   toUPPER(c)

#define toLOWER_A(c) toLOWER(c)
#define toUPPER_A(c) toUPPER(c)
#define toFOLD_A(c)  toFOLD(c)
#define toTITLE_A(c) toTITLE(c)

/* Use table lookup for speed; returns the input itself if is out-of-range */
#define toLOWER_LATIN1(c)    ((! FITS_IN_8_BITS(c))                        \
                             ? (c)                                         \
                             : PL_latin1_lc[ (U8) (c) ])
#define toLOWER_L1(c)    toLOWER_LATIN1(c)  /* Synonym for consistency */

/* Modified uc.  Is correct uc except for three non-ascii chars which are
 * all mapped to one of them, and these need special handling; returns the
 * input itself if is out-of-range */
#define toUPPER_LATIN1_MOD(c) ((! FITS_IN_8_BITS(c))                       \
                               ? (c)                                       \
                               : PL_mod_latin1_uc[ (U8) (c) ])
#ifdef USE_LOCALE_CTYPE
#  define IN_UTF8_CTYPE_LOCALE   PL_in_utf8_CTYPE_locale
#  define IN_UTF8_TURKIC_LOCALE  PL_in_utf8_turkic_locale
#else
#  define IN_UTF8_CTYPE_LOCALE   false
#  define IN_UTF8_TURKIC_LOCALE  false
#endif

/* Use foo_LC_uvchr() instead  of these for beyond the Latin1 range */

/* For internal core Perl use only: the base macro for defining macros like
 * isALPHA_LC, which uses the current LC_CTYPE locale.  'c' is the code point
 * (0-255) to check.  In a UTF-8 locale, the result is the same as calling
 * isFOO_L1(); 'classnum' is something like CC_UPPER_, which gives the class
 * number for doing this.  For non-UTF-8 locales, the code to actually do the
 * test this is passed in 'non_utf8'.  If 'c' is above 255, 0 is returned.  For
 * accessing the full range of possible code points under locale rules, use the
 * macros based on generic_LC_uvchr_ instead of this. */
#define generic_LC_base_(c, classnum, non_utf8_func)                        \
       (! FITS_IN_8_BITS(c)                                                 \
       ? 0                                                                  \
       : IN_UTF8_CTYPE_LOCALE                                               \
         ? cBOOL(PL_charclass[(U8) (c)] & CC_mask_(classnum))               \
         : cBOOL(non_utf8_func(c)))

/* A helper macro for defining macros like isALPHA_LC.  On systems without
 * proper locales, these reduce to, e.g., isALPHA_A */
#ifdef CTYPE256
#  define generic_LC_(c, classnum, non_utf8_func)   \
     generic_LC_base_(c, classnum, non_utf8_func)
#else
# define generic_LC_(c, classnum, non_utf8_func)    \
     generic_isCC_A_(c, classnum)
#endif

/* Below are the definitions for the locale-sensitive character classification
 * macros whose input domain is a byte, and the locale isn't UTF-8.  These are
 * as close as possible to the bare versions on the platform and still yield
 * POSIX Standard-compliant results.
 *
 * There is currently only one place these definitions should be used, in
 * certain function calls like Perl_iswordchar_() in inline.h.
 *
 * Most likely you want to use the macros a ways below with names like
 * isALPHA_LC().  Rarely, you may want isU8_ALPHA_LC(), somewhat below.
 *
 * The first two aren't in C89, so the fallback is to use the non-locale
 * sensitive versions; these are the same for all platforms */
#if defined(HAS_ISASCII)
#   define is_posix_ASCII(c) isascii((U8) (c))
#else
#   define is_posix_ASCII(c) isASCII(c)
#endif

#if defined(HAS_ISBLANK)
#   define is_posix_BLANK(c) isblank((U8) (c))
#else
#   define is_posix_BLANK(c) isBLANK(c)
#endif

/* The next few are the same in all platforms. */
#define is_posix_CNTRL(c)     iscntrl((U8) (c))
#define is_posix_IDFIRST(c)  (UNLIKELY((c) == '_') || is_posix_ALPHA(c))
#define is_posix_SPACE(c)     isspace((U8) (c))
#define is_posix_WORDCHAR(c) (UNLIKELY((c) == '_') || is_posix_ALPHANUMERIC(c))

/* The base-level case changing macros are also the same in all platforms */
#define to_posix_LOWER(c)     tolower((U8) (c))
#define to_posix_UPPER(c)     toupper((U8) (c))
#define to_posix_FOLD(c)      to_posix_LOWER(c)

#ifdef WIN32

/* The Windows functions don't bother to follow the POSIX standard, which for
 * example says that something can't both be a printable and a control.  But
 * Windows treats \t as both a control and a printable, and does such things as
 * making superscripts into both digits and punctuation.  These #defines tame
 * these flaws by assuming that the definitions of controls (and the other few
 * ones defined above) are correct, and then making sure that other definitions
 * don't have weirdnesses, by adding a check that \w and its subsets aren't
 * ispunct(), and things that are \W, like ispunct(), arent't controls.  Not
 * all possible weirdnesses are checked for, just ones that were detected on
 * actual Microsoft code pages */
#  define is_posix_ALPHA(c)                                          \
                          (isalpha((U8) (c)) && ! is_posix_PUNCT(c))
#  define is_posix_ALPHANUMERIC(c)                                   \
                          (isalnum((U8) (c)) && ! is_posix_PUNCT(c))
#  define is_posix_CASED(c)                                          \
   ((isupper((U8) (c)) || islower((U8) (c))) && ! is_posix_PUNCT(c))
#  define is_posix_DIGIT(c)                                          \
                          (isdigit((U8) (c)) && ! is_posix_PUNCT(c))
#  define is_posix_GRAPH(c)                                          \
                          (isgraph((U8) (c)) && ! is_posix_CNTRL(c))
#  define is_posix_LOWER(c)                                          \
                          (islower((U8) (c)) && ! is_posix_PUNCT(c))
#  define is_posix_PRINT(c)                                          \
                          (isprint((U8) (c)) && ! is_posix_CNTRL(c))
#  define is_posix_PUNCT(c)                                          \
                          (ispunct((U8) (c)) && ! is_posix_CNTRL(c))
#  define is_posix_UPPER(c)                                          \
                          (isupper((U8) (c)) && ! is_posix_PUNCT(c))
#  define is_posix_XDIGIT(c)                                         \
                         (isxdigit((U8) (c)) && ! is_posix_PUNCT(c))
#else

/* For all other platforms, as far as we know, isdigit(), etc. work sanely
 * enough */
#  define is_posix_ALPHA(c)         isalpha((U8) (c))
#  define is_posix_ALPHANUMERIC(c)  isalnum((U8) (c))
#  define is_posix_CASED(c)        (islower((U8) (c)) || isupper((U8) (c)))
#  define is_posix_DIGIT(c)         isdigit((U8) (c))

     /* ... But it seems that IBM products treat NBSP as both a space and a
      * graphic; these are the two platforms that we have active test beds for.
      */
#  if defined(OS390) || defined(_AIX)
#    define is_posix_GRAPH(c)      (isgraph((U8) (c)) && ! isspace((U8) (c)))
#  else
#    define is_posix_GRAPH(c)       isgraph((U8) (c))
#  endif
#  define is_posix_LOWER(c)         islower((U8) (c))
#  define is_posix_PRINT(c)         isprint((U8) (c))
#  define is_posix_PUNCT(c)         ispunct((U8) (c))
#  define is_posix_UPPER(c)         isupper((U8) (c))
#  define is_posix_XDIGIT(c)        isxdigit((U8) (c))
#endif

/* Below is the next level up, which currently expands to nothing more
 * than the previous layer.  These are the macros to use if you really need
 * something whose input domain is a byte, and the locale isn't UTF-8; that is,
 * where you normally would have to use things like bare isalnum().
 *
 * But most likely you should instead use the layer defined further below which
 * has names like isALPHA_LC.  They deal with larger-than-byte inputs, and
 * UTF-8 locales.
 *
 * (Note, proper general operation of the bare libc functions requires you to
 * cast to U8.  These do that for you automatically.) */

#  define WRAP_U8_LC_(c, classnum, posix)  posix(c)

#define isU8_ALPHANUMERIC_LC(c)                                                \
              WRAP_U8_LC_((c), CC_ALPHANUMERIC_, is_posix_ALPHANUMERIC)
#define isU8_ALPHA_LC(c)    WRAP_U8_LC_((c), CC_ALPHA_, is_posix_ALPHA)
#define isU8_ASCII_LC(c)    WRAP_U8_LC_((c), CC_ASCII_, is_posix_ASCII)
#define isU8_BLANK_LC(c)    WRAP_U8_LC_((c), CC_BLANK_, is_posix_BLANK)
#define isU8_CASED_LC(c)    WRAP_U8_LC_((c), CC_CASED_, is_posix_CASED)
#define isU8_CNTRL_LC(c)    WRAP_U8_LC_((c), CC_CNTRL_, is_posix_CNTRL)
#define isU8_DIGIT_LC(c)    WRAP_U8_LC_((c), CC_DIGIT_, is_posix_DIGIT)
#define isU8_GRAPH_LC(c)    WRAP_U8_LC_((c), CC_GRAPH_, is_posix_GRAPH)
#define isU8_IDFIRST_LC(c)  WRAP_U8_LC_((c), CC_IDFIRST_, is_posix_IDFIRST)
#define isU8_LOWER_LC(c)    WRAP_U8_LC_((c), CC_LOWER_, is_posix_LOWER)
#define isU8_PRINT_LC(c)    WRAP_U8_LC_((c), CC_PRINT_, is_posix_PRINT)
#define isU8_PUNCT_LC(c)    WRAP_U8_LC_((c), CC_PUNCT_, is_posix_PUNCT)
#define isU8_SPACE_LC(c)    WRAP_U8_LC_((c), CC_SPACE_, is_posix_SPACE)
#define isU8_UPPER_LC(c)    WRAP_U8_LC_((c), CC_UPPER_, is_posix_UPPER)
#define isU8_WORDCHAR_LC(c) WRAP_U8_LC_((c), CC_WORDCHAR_, is_posix_WORDCHAR)
#define isU8_XDIGIT_LC(c)   WRAP_U8_LC_((c), CC_XDIGIT_, is_posix_XDIGIT)

#define toU8_LOWER_LC(c)    WRAP_U8_LC_((c), CC_TOLOWER_, to_posix_LOWER)
#define toU8_UPPER_LC(c)    WRAP_U8_LC_((c), CC_TOUPPER_, to_posix_UPPER)
#define toU8_FOLD_LC(c)     toU8_LOWER_LC(c)

/* The definitions below use the ones above to create versions in which the
 * input domain isn't restricted to bytes (though always returning false if the
 * input doesn't fit in a byte), and to behave properly should the locale be
 * UTF-8.  These are the documented ones, suitable for general use (though
 * toUPPER_LC and toFOLD_LC aren't documented because they need special
 * handling to deal with SHARP S expanding to two characters). */

#define isASCII_LC(c)               (FITS_IN_8_BITS(c) && isU8_ASCII_LC(c))
#define isALPHA_LC(c)               generic_LC_(c, CC_ALPHA_, isU8_ALPHA_LC)
#define isALPHANUMERIC_LC(c)                                                \
                      generic_LC_(c, CC_ALPHANUMERIC_, isU8_ALPHANUMERIC_LC)
#define isBLANK_LC(c)               generic_LC_(c, CC_BLANK_, isU8_BLANK_LC)
#define isCASED_LC(c)               generic_LC_(c, CC_CASED_, isU8_CASED_LC)
#define isCNTRL_LC(c)               generic_LC_(c, CC_CNTRL_, isU8_CNTRL_LC)
#define isDIGIT_LC(c)               generic_LC_(c, CC_DIGIT_, isU8_DIGIT_LC)
#define isGRAPH_LC(c)               generic_LC_(c, CC_GRAPH_, isU8_GRAPH_LC)
#define isIDFIRST_LC(c)         generic_LC_(c, CC_IDFIRST_, isU8_IDFIRST_LC)
#define isLOWER_LC(c)               generic_LC_(c, CC_LOWER_, isU8_LOWER_LC)
#define isPRINT_LC(c)               generic_LC_(c, CC_PRINT_, isU8_PRINT_LC)
#define isPUNCT_LC(c)               generic_LC_(c, CC_PUNCT_, isU8_PUNCT_LC)
#define isSPACE_LC(c)               generic_LC_(c, CC_SPACE_, isU8_SPACE_LC)
#define isUPPER_LC(c)               generic_LC_(c, CC_UPPER_, isU8_UPPER_LC)
#define isWORDCHAR_LC(c)      generic_LC_(c, CC_WORDCHAR_, isU8_WORDCHAR_LC)
#define isXDIGIT_LC(c)            generic_LC_(c, CC_XDIGIT_, isU8_XDIGIT_LC)

#ifndef CTYPE256
#  define toLOWER_LC(c)             toLOWER_A(c)
#  define toUPPER_LC(c)             toUPPER_A(c)
#  define toFOLD_LC(c)              toFOLD_A(c)
#else

/* In the next three macros, the reason for using the PL_latin arrays is in
 * case the system function is defective; it ensures uniform results that
 * conform to the Unicode standard. */

/* This does not handle the anomalies in UTF-8 Turkic locales. */
#  define toLOWER_LC(c)  ((! FITS_IN_8_BITS(c))                             \
                          ? (c)                                             \
                          : ((IN_UTF8_CTYPE_LOCALE)                         \
                             ? PL_latin1_lc[ (U8) (c) ]                     \
                             : ((U8) toU8_LOWER_LC(c))))

/* In this macro, note that the result can be larger than a byte in a UTF-8
 * locale.  It returns a single value, so can't adequately return the upper
 * case of LATIN SMALL LETTER SHARP S in a UTF-8 locale (which should be a
 * string of two values "SS");  instead it asserts against that under
 * DEBUGGING, and otherwise returns its input.  It does not handle the
 * anomalies in UTF-8 Turkic locales. */
#  define toUPPER_LC(c)                                                     \
    ((! FITS_IN_8_BITS(c))                                                  \
     ? (c)                                                                  \
     : ((! IN_UTF8_CTYPE_LOCALE)                                            \
        ? ((U8) toU8_UPPER_LC(c))                                           \
        : (UNLIKELY(((U8)(c)) == MICRO_SIGN)                                \
           ? GREEK_CAPITAL_LETTER_MU                                        \
           : ((UNLIKELY(((U8) (c)) == LATIN_SMALL_LETTER_Y_WITH_DIAERESIS)  \
              ? LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS                       \
              : (UNLIKELY(((U8)(c)) == LATIN_SMALL_LETTER_SHARP_S)          \
                ? (__ASSERT_(0) (c)) /* Fail on Sharp S in DEBUGGING */     \
                : PL_mod_latin1_uc[ (U8) (c) ]))))))

/* In this macro, note that the result can be larger than a byte in a UTF-8
 * locale.  It returns a single value, so can't adequately return the fold case
 * of LATIN SMALL LETTER SHARP S in a UTF-8 locale (which should be a string of
 * two values "ss"); instead it asserts against that under DEBUGGING, and
 * otherwise returns its input.  It does not handle the anomalies in UTF-8
 * Turkic locales */
#  define toFOLD_LC(c)                                                      \
                ((UNLIKELY((c) == MICRO_SIGN) && IN_UTF8_CTYPE_LOCALE)      \
                 ? GREEK_SMALL_LETTER_MU                                    \
                 : (__ASSERT_(   ! IN_UTF8_CTYPE_LOCALE                     \
                              || LIKELY((c) != LATIN_SMALL_LETTER_SHARP_S)) \
                    toLOWER_LC(c)))
#endif

#define isIDCONT(c)             isWORDCHAR(c)
#define isIDCONT_A(c)           isWORDCHAR_A(c)
#define isIDCONT_L1(c)	        isWORDCHAR_L1(c)
#define isIDCONT_LC(c)	        isWORDCHAR_LC(c)
#define isPSXSPC_LC(c)		isSPACE_LC(c)

/* For internal core Perl use only: the base macros for defining macros like
 * isALPHA_uvchr.  'c' is the code point to check.  'classnum' is the POSIX class
 * number defined earlier in this file.  generic_uvchr_() is used for POSIX
 * classes where there is a macro or function 'above_latin1' that takes the
 * single argument 'c' and returns the desired value.  These exist for those
 * classes which have simple definitions, avoiding the overhead of an inversion
 * list binary search.  generic_invlist_uvchr_() can be used
 * for classes where that overhead is faster than a direct lookup.
 * generic_uvchr_() won't compile if 'c' isn't unsigned, as it won't match the
 * 'above_latin1' prototype. generic_isCC_() macro does bounds checking, so
 * have duplicate checks here, so could create versions of the macros that
 * don't, but experiments show that gcc optimizes them out anyway. */

/* Note that all ignore 'use bytes' */
#define generic_uvchr_(classnum, above_latin1, c) ((c) < 256                \
                                             ? generic_isCC_(c, classnum)   \
                                             : above_latin1(c))
#define generic_invlist_uvchr_(classnum, c) ((c) < 256                      \
                                             ? generic_isCC_(c, classnum)   \
                                             : _is_uni_FOO(classnum, c))
#define isALPHA_uvchr(c)      generic_invlist_uvchr_(CC_ALPHA_, c)
#define isALPHANUMERIC_uvchr(c) generic_invlist_uvchr_(CC_ALPHANUMERIC_, c)
#define isASCII_uvchr(c)      isASCII(c)
#define isBLANK_uvchr(c)      generic_uvchr_(CC_BLANK_, is_HORIZWS_cp_high, c)
#define isCNTRL_uvchr(c)      isCNTRL_L1(c) /* All controls are in Latin1 */
#define isDIGIT_uvchr(c)      generic_invlist_uvchr_(CC_DIGIT_, c)
#define isGRAPH_uvchr(c)      generic_invlist_uvchr_(CC_GRAPH_, c)
