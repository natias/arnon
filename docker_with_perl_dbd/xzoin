
  G_APPLICATION_CAN_OVERRIDE_APP_ID =  (1 << 6),
  G_APPLICATION_ALLOW_REPLACEMENT   =  (1 << 7),
  G_APPLICATION_REPLACE             =  (1 << 8)
} GApplicationFlags;

/**
 * GTlsError:
 * @G_TLS_ERROR_UNAVAILABLE: No TLS provider is available
 * @G_TLS_ERROR_MISC: Miscellaneous TLS error
 * @G_TLS_ERROR_BAD_CERTIFICATE: The certificate presented could not
 *   be parsed or failed validation.
 * @G_TLS_ERROR_NOT_TLS: The TLS handshake failed because the
 *   peer does not seem to be a TLS server.
 * @G_TLS_ERROR_HANDSHAKE: The TLS handshake failed because the
 *   peer's certificate was not acceptable.
 * @G_TLS_ERROR_CERTIFICATE_REQUIRED: The TLS handshake failed because
 *   the server requested a client-side certificate, but none was
 *   provided. See g_tls_connection_set_certificate().
 * @G_TLS_ERROR_EOF: The TLS connection was closed without proper
 *   notice, which may indicate an attack. See
 *   g_tls_connection_set_require_close_notify().
 * @G_TLS_ERROR_INAPPROPRIATE_FALLBACK: The TLS handshake failed
 *   because the client sent the fallback SCSV, indicating a protocol
 *   downgrade attack. Since: 2.60
 * @G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD: The certificate failed
 *   to load because a password was incorrect. Since: 2.72
 *
 * An error code used with %G_TLS_ERROR in a #GError returned from a
 * TLS-related routine.
 *
 * Since: 2.28
 */
typedef enum {
  G_TLS_ERROR_UNAVAILABLE,
  G_TLS_ERROR_MISC,
  G_TLS_ERROR_BAD_CERTIFICATE,
  G_TLS_ERROR_NOT_TLS,
  G_TLS_ERROR_HANDSHAKE,
  G_TLS_ERROR_CERTIFICATE_REQUIRED,
  G_TLS_ERROR_EOF,
  G_TLS_ERROR_INAPPROPRIATE_FALLBACK,
  G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD
} GTlsError;

/**
 * GTlsCertificateFlags:
 * @G_TLS_CERTIFICATE_NO_FLAGS: No flags set. Since: 2.74
 * @G_TLS_CERTIFICATE_UNKNOWN_CA: The signing certificate authority is
 *   not known.
 * @G_TLS_CERTIFICATE_BAD_IDENTITY: The certificate does not match the
 *   expected identity of the site that it was retrieved from.
 * @G_TLS_CERTIFICATE_NOT_ACTIVATED: The certificate's activation time
 *   is still in the future
 * @G_TLS_CERTIFICATE_EXPIRED: The certificate has expired
 * @G_TLS_CERTIFICATE_REVOKED: The certificate has been revoked
 *   according to the #GTlsConnection's certificate revocation list.
 * @G_TLS_CERTIFICATE_INSECURE: The certificate's algorithm is
 *   considered insecure.
 * @G_TLS_CERTIFICATE_GENERIC_ERROR: Some other error occurred validating
 *   the certificate
 * @G_TLS_CERTIFICATE_VALIDATE_ALL: the combination of all of the above
 *   flags
 *
 * A set of flags describing TLS certification validation. This can be
 * used to describe why a particular certificate was rejected (for
 * example, in #GTlsConnection::accept-certificate).
 *
 * GLib guarantees that if certificate verification fails, at least one
 * flag will be set, but it does not guarantee that all possible flags
 * will be set. Accordingly, you may not safely decide to ignore any
 * particular type of error. For example, it would be incorrect to mask
 * %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
 * because this could potentially be the only error flag set even if
 * other problems exist with the certificate.
 *
 * Since: 2.28
 */
typedef enum {
  G_TLS_CERTIFICATE_NO_FLAGS GLIB_AVAILABLE_ENUMERATOR_IN_2_74 = 0,
  G_TLS_CERTIFICATE_UNKNOWN_CA    = (1 << 0),
  G_TLS_CERTIFICATE_BAD_IDENTITY  = (1 << 1),
  G_TLS_CERTIFICATE_NOT_ACTIVATED = (1 << 2),
  G_TLS_CERTIFICATE_EXPIRED       = (1 << 3),
  G_TLS_CERTIFICATE_REVOKED       = (1 << 4),
  G_TLS_CERTIFICATE_INSECURE      = (1 << 5),
  G_TLS_CERTIFICATE_GENERIC_ERROR = (1 << 6),

  G_TLS_CERTIFICATE_VALIDATE_ALL  = 0x007f
} GTlsCertificateFlags;

/**
 * GTlsAuthenticationMode:
 * @G_TLS_AUTHENTICATION_NONE: client authentication not required
 * @G_TLS_AUTHENTICATION_REQUESTED: client authentication is requested
 * @G_TLS_AUTHENTICATION_REQUIRED: client authentication is required
 *
 * The client authentication mode for a #GTlsServerConnection.
 *
 * Since: 2.28
 */
typedef enum {
  G_TLS_AUTHENTICATION_NONE,
  G_TLS_AUTHENTICATION_REQUESTED,
  G_TLS_AUTHENTICATION_REQUIRED
} GTlsAuthenticationMode;

/**
 * GTlsChannelBindingType:
 * @G_TLS_CHANNEL_BINDING_TLS_UNIQUE:
 *    [`tls-unique`](https://tools.ietf.org/html/rfc5929#section-3) binding
 *    type
 * @G_TLS_CHANNEL_BINDING_TLS_SERVER_END_POINT:
 *    [`tls-server-end-point`](https://tools.ietf.org/html/rfc5929#section-4)
 *    binding type
 * @G_TLS_CHANNEL_BINDING_TLS_EXPORTER:
 *    [`tls-exporter`](https://www.rfc-editor.org/rfc/rfc9266.html) binding
 *    type. Since: 2.74
 *
 * The type of TLS channel binding data to retrieve from #GTlsConnection
 * or #GDtlsConnection, as documented by RFC 5929 or RFC 9266. The
 * [`tls-unique-for-telnet`](https://tools.ietf.org/html/rfc5929#section-5)
 * binding type is not currently implemented.
 *
 * Since: 2.66
 */
GLIB_AVAILABLE_TYPE_IN_2_66
typedef enum {
  G_TLS_CHANNEL_BINDING_TLS_UNIQUE,
  G_TLS_CHANNEL_BINDING_TLS_SERVER_END_POINT,
  G_TLS_CHANNEL_BINDING_TLS_EXPORTER GLIB_AVAILABLE_ENUMERATOR_IN_2_74,
} GTlsChannelBindingType;

/**
 * GTlsChannelBindingError:
 * @G_TLS_CHANNEL_BINDING_ERROR_NOT_IMPLEMENTED: Either entire binding
 *    retrieval facility or specific binding type is not implemented in the
 *    TLS backend.
 * @G_TLS_CHANNEL_BINDING_ERROR_INVALID_STATE: The handshake is not yet
 *    complete on the connection which is a strong requirement for any existing
 *    binding type.
 * @G_TLS_CHANNEL_BINDING_ERROR_NOT_AVAILABLE: Handshake is complete but
 *    binding data is not available. That normally indicates the TLS
 *    implementation failed to provide the binding data. For example, some
 *    implementations do not provide a peer certificate for resumed connections.
 * @G_TLS_CHANNEL_BINDING_ERROR_NOT_SUPPORTED: Binding type is not supported
 *    on the current connection. This error could be triggered when requesting
 *    `tls-server-end-point` binding data for a certificate which has no hash
 *    function or uses multiple hash functions.
 * @G_TLS_CHANNEL_BINDING_ERROR_GENERAL_ERROR: Any other backend error
 *    preventing binding data retrieval.
 *
 * An error code used with %G_TLS_CHANNEL_BINDING_ERROR in a #GError to
 * indicate a TLS channel binding retrieval error.
 *
 * Since: 2.66
 */
GLIB_AVAILABLE_TYPE_IN_2_66
typedef enum {
  G_TLS_CHANNEL_BINDING_ERROR_NOT_IMPLEMENTED,
  G_TLS_CHANNEL_BINDING_ERROR_INVALID_STATE,
  G_TLS_CHANNEL_BINDING_ERROR_NOT_AVAILABLE,
  G_TLS_CHANNEL_BINDING_ERROR_NOT_SUPPORTED,
  G_TLS_CHANNEL_BINDING_ERROR_GENERAL_ERROR
} GTlsChannelBindingError;

/**
 * GTlsRehandshakeMode:
 * @G_TLS_REHANDSHAKE_NEVER: Never allow rehandshaking
 * @G_TLS_REHANDSHAKE_SAFELY: Allow safe rehandshaking only
 * @G_TLS_REHANDSHAKE_UNSAFELY: Allow unsafe rehandshaking
 *
 * When to allow rehandshaking. See
 * g_tls_connection_set_rehandshake_mode().
 *
 * Since: 2.28
 *
 * Deprecated: 2.60. Changing the rehandshake mode is no longer
 *   required for compatibility. Also, rehandshaking has been removed
 *   from the TLS protocol in TLS 1.3.
 */
typedef enum {
  G_TLS_REHANDSHAKE_NEVER,
  G_TLS_REHANDSHAKE_SAFELY,
  G_TLS_REHANDSHAKE_UNSAFELY
} GTlsRehandshakeMode GLIB_DEPRECATED_TYPE_IN_2_60;

/**
 * GTlsPasswordFlags:
 * @G_TLS_PASSWORD_NONE: No flags
 * @G_TLS_PASSWORD_RETRY: The password was wrong, and the user should retry.
 * @G_TLS_PASSWORD_MANY_TRIES: Hint to the user that the password has been
 *    wrong many times, and the user may not have many chances left.
 * @G_TLS_PASSWORD_FINAL_TRY: Hint to the user that this is the last try to get
 *    this password right.
 * @G_TLS_PASSWORD_PKCS11_USER: For PKCS #11, the user PIN is required.
 *    Since: 2.70.
 * @G_TLS_PASSWORD_PKCS11_SECURITY_OFFICER: For PKCS #11, the security officer
 *    PIN is required. Since: 2.70.
 * @G_TLS_PASSWORD_PKCS11_CONTEXT_SPECIFIC: For PKCS #11, the context-specific
 *    PIN is required. Since: 2.70.
 *
 * Various flags for the password.
 *
 * Since: 2.30
 */

typedef enum _GTlsPasswordFlags
{
  G_TLS_PASSWORD_NONE = 0,
  G_TLS_PASSWORD_RETRY = 1 << 1,
  G_TLS_PASSWORD_MANY_TRIES = 1 << 2,
  G_TLS_PASSWORD_FINAL_TRY = 1 << 3,
  G_TLS_PASSWORD_PKCS11_USER = 1 << 4,
  G_TLS_PASSWORD_PKCS11_SECURITY_OFFICER = 1 << 5,
  G_TLS_PASSWORD_PKCS11_CONTEXT_SPECIFIC = 1 << 6
} GTlsPasswordFlags;

/**
 * GTlsInteractionResult:
 * @G_TLS_INTERACTION_UNHANDLED: The interaction was unhandled (i.e. not
 *     implemented).
 * @G_TLS_INTERACTION_HANDLED: The interaction completed, and resulting data
 *     is available.
 * @G_TLS_INTERACTION_FAILED: The interaction has failed, or was cancelled.
 *     and the operation should be aborted.
 *
 * #GTlsInteractionResult is returned by various functions in #GTlsInteraction
 * when finishing an interaction request.
 *
 * Since: 2.30
 */
typedef enum {
  G_TLS_INTERACTION_UNHANDLED,
  G_TLS_INTERACTION_HANDLED,
  G_TLS_INTERACTION_FAILED
} GTlsInteractionResult;

/**
 * GDBusInterfaceSkeletonFlags:
 * @G_DBUS_INTERFACE_SKELETON_FLAGS_NONE: No flags set.
 * @G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD: Each method invocation is handled in
 *   a thread dedicated to the invocation. This means that the method implementation can use blocking IO
 *   without blocking any other part of the process. It also means that the method implementation must
 *   use locking to access data structures used by other threads.
 *
 * Flags describing the behavior of a #GDBusInterfaceSkeleton instance.
 *
 * Since: 2.30
 */
typedef enum
{
  G_DBUS_INTERFACE_SKELETON_FLAGS_NONE = 0,
  G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD = (1<<0)
} GDBusInterfaceSkeletonFlags;

/**
 * GDBusObjectManagerClientFlags:
 * @G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE: No flags set.
 * @G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START: If not set and the
 *   manager is for a well-known name, then request the bus to launch
 *   an owner for the name if no-one owns the name. This flag can only
 *   be used in managers for well-known names.
 *
 * Flags used when constructing a #GDBusObjectManagerClient.
 *
 * Since: 2.30
 */
typedef enum
{
  G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE = 0,
  G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START = (1<<0)
} GDBusObjectManagerClientFlags;

/**
 * GTlsDatabaseVerifyFlags:
 * @G_TLS_DATABASE_VERIFY_NONE: No verification flags
 *
 * Flags for g_tls_database_verify_chain().
 *
 * Since: 2.30
 */
typedef enum /*< flags >*/ {
  G_TLS_DATABASE_VERIFY_NONE = 0
} GTlsDatabaseVerifyFlags;

/**
 * GTlsDatabaseLookupFlags:
 * @G_TLS_DATABASE_LOOKUP_NONE: No lookup flags
 * @G_TLS_DATABASE_LOOKUP_KEYPAIR: Restrict lookup to certificates that have
 *     a private key.
 *
 * Flags for g_tls_database_lookup_certificate_for_handle(),
 * g_tls_database_lookup_certificate_issuer(),
 * and g_tls_database_lookup_certificates_issued_by().
 *
 * Since: 2.30
 */
typedef enum {
  G_TLS_DATABASE_LOOKUP_NONE = 0,
  G_TLS_DATABASE_LOOKUP_KEYPAIR = 1
} GTlsDatabaseLookupFlags;

/**
 * GTlsCertificateRequestFlags:
 * @G_TLS_CERTIFICATE_REQUEST_NONE: No flags
 *
 * Flags for g_tls_interaction_request_certificate(),
 * g_tls_interaction_request_certificate_async(), and
 * g_tls_interaction_invoke_request_certificate().
 *
 * Since: 2.40
 */
typedef enum {
  G_TLS_CERTIFICATE_REQUEST_NONE = 0
} GTlsCertificateRequestFlags;

/**
 * GTlsProtocolVersion:
 * @G_TLS_PROTOCOL_VERSION_UNKNOWN: No protocol version or unknown protocol version
 * @G_TLS_PROTOCOL_VERSION_SSL_3_0: SSL 3.0, which is insecure and should not be used
 * @G_TLS_PROTOCOL_VERSION_TLS_1_0: TLS 1.0, which is insecure and should not be used
 * @G_TLS_PROTOCOL_VERSION_TLS_1_1: TLS 1.1, which is insecure and should not be used
 * @G_TLS_PROTOCOL_VERSION_TLS_1_2: TLS 1.2, defined by [RFC 5246](https://datatracker.ietf.org/doc/html/rfc5246)
 * @G_TLS_PROTOCOL_VERSION_TLS_1_3: TLS 1.3, defined by [RFC 8446](https://datatracker.ietf.org/doc/html/rfc8446)
 * @G_TLS_PROTOCOL_VERSION_DTLS_1_0: DTLS 1.0, which is insecure and should not be used
 * @G_TLS_PROTOCOL_VERSION_DTLS_1_2: DTLS 1.2, defined by [RFC 6347](https://datatracker.ietf.org/doc/html/rfc6347)
 *
 * The TLS or DTLS protocol version used by a #GTlsConnection or
 * #GDtlsConnection. The integer values of these versions are sequential
 * to ensure newer known protocol versions compare greater than older
 * known versions. Any known DTLS protocol version will compare greater
 * than any SSL or TLS protocol version. The protocol version may be
 * %G_TLS_PROTOCOL_VERSION_UNKNOWN if the TLS backend supports a newer
 * protocol version that GLib does not yet know about. This means that
 * it's possible for an unknown DTLS protocol version to compare less
 * than the TLS protocol versions.
 *
 * Since: 2.70
 */
typedef enum {
  G_TLS_PROTOCOL_VERSION_UNKNOWN = 0,
  G_TLS_PROTOCOL_VERSION_SSL_3_0 = 1,
  G_TLS_PROTOCOL_VERSION_TLS_1_0 = 2,
  G_TLS_PROTOCOL_VERSION_TLS_1_1 = 3,
  G_TLS_PROTOCOL_VERSION_TLS_1_2 = 4,
  G_TLS_PROTOCOL_VERSION_TLS_1_3 = 5,
  G_TLS_PROTOCOL_VERSION_DTLS_1_0 = 201,
  G_TLS_PROTOCOL_VERSION_DTLS_1_2 = 202,
} GTlsProtocolVersion;

/**
 * GIOModuleScopeFlags:
 * @G_IO_MODULE_SCOPE_NONE: No module scan flags
 * @G_IO_MODULE_SCOPE_BLOCK_DUPLICATES: When using this scope to load or
 *     scan modules, automatically block a modules which has the same base
 *     basename as previously loaded module.
 *
 * Flags for use with g_io_module_scope_new().
 *
 * Since: 2.30
 */
typedef enum {
  G_IO_MODULE_SCOPE_NONE,
  G_IO_MODULE_SCOPE_BLOCK_DUPLICATES
} GIOModuleScopeFlags;

/**
 * GSocketClientEvent:
 * @G_SOCKET_CLIENT_RESOLVING: The client is doing a DNS lookup.
 * @G_SOCKET_CLIENT_RESOLVED: The client has completed a DNS lookup.
 * @G_SOCKET_CLIENT_CONNECTING: The client is connecting to a remote
 *   host (either a proxy or the destination server).
 * @G_SOCKET_CLIENT_CONNECTED: The client has connected to a remote
 *   host.
 * @G_SOCKET_CLIENT_PROXY_NEGOTIATING: The client is negotiating
 *   with a proxy to connect to the destination server.
 * @G_SOCKET_CLIENT_PROXY_NEGOTIATED: The client has negotiated
 *   with the proxy server.
 * @G_SOCKET_CLIENT_TLS_HANDSHAKING: The client is performing a
 *   TLS handshake.
 * @G_SOCKET_CLIENT_TLS_HANDSHAKED: The client has performed a
 *   TLS handshake.
 * @G_SOCKET_CLIENT_COMPLETE: The client is done with a particular
 *   #GSocketConnectable.
 *
 * Describes an event occurring on a #GSocketClient. See the
 * #GSocketClient::event signal for more details.
 *
 * Additional values may be added to this type in the future.
 *
 * Since: 2.32
 */
typedef enum {
  G_SOCKET_CLIENT_RESOLVING,
  G_SOCKET_CLIENT_RESOLVED,
  G_SOCKET_CLIENT_CONNECTING,
  G_SOCKET_CLIENT_CONNECTED,
  G_SOCKET_CLIENT_PROXY_NEGOTIATING,
  G_SOCKET_CLIENT_PROXY_NEGOTIATED,
  G_SOCKET_CLIENT_TLS_HANDSHAKING,
  G_SOCKET_CLIENT_TLS_HANDSHAKED,
  G_SOCKET_CLIENT_COMPLETE
} GSocketClientEvent;

/**
 * GSocketListenerEvent:
 * @G_SOCKET_LISTENER_BINDING: The listener is about to bind a socket.
 * @G_SOCKET_LISTENER_BOUND: The listener has bound a socket.
 * @G_SOCKET_LISTENER_LISTENING: The listener is about to start
 *    listening on this socket.
 * @G_SOCKET_LISTENER_LISTENED: The listener is now listening on
 *   this socket.
 *
 * Describes an event occurring on a #GSocketListener. See the
 * #GSocketListener::event signal for more details.
 *
 * Additional values may be added to this type in the future.
 *
 * Since: 2.46
 */
typedef enum {
  G_SOCKET_LISTENER_BINDING,
  G_SOCKET_LISTENER_BOUND,
  G_SOCKET_LISTENER_LISTENING,
  G_SOCKET_LISTENER_LISTENED
} GSocketListenerEvent;

/**
 * GTestDBusFlags:
 * @G_TEST_DBUS_NONE: No flags.
 *
 * Flags to define future #GTestDBus behaviour.
 *
 * Since: 2.34
 */
typedef enum /*< flags >*/ {
  G_TEST_DBUS_NONE = 0
} GTestDBusFlags;

/**
 * GSubprocessFlags:
 * @G_SUBPROCESS_FLAGS_NONE: No flags.
 * @G_SUBPROCESS_FLAGS_STDIN_PIPE: create a pipe for the stdin of the
 *   spawned process that can be accessed with
 *   g_subprocess_get_stdin_pipe().
 * @G_SUBPROCESS_FLAGS_STDIN_INHERIT: stdin is inherited from the
 *   calling process.
 * @G_SUBPROCESS_FLAGS_STDOUT_PIPE: create a pipe for the stdout of the
 *   spawned process that can be accessed with
 *   g_subprocess_get_stdout_pipe().
 * @G_SUBPROCESS_FLAGS_STDOUT_SILENCE: silence the stdout of the spawned
 *   process (ie: redirect to `/dev/null`).
 * @G_SUBPROCESS_FLAGS_STDERR_PIPE: create a pipe for the stderr of the
 *   spawned process that can be accessed with
 *   g_subprocess_get_stderr_pipe().
 * @G_SUBPROCESS_FLAGS_STDERR_SILENCE: silence the stderr of the spawned
 *   process (ie: redirect to `/dev/null`).
 * @G_SUBPROCESS_FLAGS_STDERR_MERGE: merge the stderr of the spawned
 *   process with whatever the stdout happens to be.  This is a good way
 *   of directing both streams to a common log file, for example.
 * @G_SUBPROCESS_FLAGS_INHERIT_FDS: spawned processes will inherit the
 *   file descriptors of their parent, unless those descriptors have
 *   been explicitly marked as close-on-exec.  This flag has no effect
 *   over the "standard" file descriptors (stdin, stdout, stderr).
 * @G_SUBPROCESS_FLAGS_SEARCH_PATH_FROM_ENVP: if path searching is
 *   needed when spawning the subprocess, use the `PATH` in the launcher
 *   environment. (Since: 2.72)
 *
 * Flags to define the behaviour of a #GSubprocess.
 *
 * Note that the default for stdin is to redirect from `/dev/null`.  For
 * stdout and stderr the default are for them to inherit the
 * corresponding descriptor from the calling process.
 *
 * Note that it is a programmer error to mix 'incompatible' flags.  For
 * example, you may not request both %G_SUBPROCESS_FLAGS_STDOUT_PIPE and
 * %G_SUBPROCESS_FLAGS_STDOUT_SILENCE.
 *
 * Since: 2.40
 **/
typedef enum {
  G_SUBPROCESS_FLAGS_NONE                  = 0,
  G_SUBPROCESS_FLAGS_STDIN_PIPE            = (1u << 0),
  G_SUBPROCESS_FLAGS_STDIN_INHERIT         = (1u << 1),
  G_SUBPROCESS_FLAGS_STDOUT_PIPE           = (1u << 2),
  G_SUBPROCESS_FLAGS_STDOUT_SILENCE        = (1u << 3),
  G_SUBPROCESS_FLAGS_STDERR_PIPE           = (1u << 4),
  G_SUBPROCESS_FLAGS_STDERR_SILENCE        = (1u << 5),
  G_SUBPROCESS_FLAGS_STDERR_MERGE          = (1u << 6),
  G_SUBPROCESS_FLAGS_INHERIT_FDS           = (1u << 7),
  G_SUBPROCESS_FLAGS_SEARCH_PATH_FROM_ENVP = (1u << 8)
} GSubprocessFlags;

/**
 * GNotificationPriority:
 * @G_NOTIFICATION_PRIORITY_LOW: for notifications that do not require
 *   immediate attention - typically used for contextual background
 *   information, such as contact birthdays or local weather
 * @G_NOTIFICATION_PRIORITY_NORMAL: the default priority, to be used for the
 *   majority of notifications (for example email messages, software updates,
 *   completed download/sync operations)
 * @G_NOTIFICATION_PRIORITY_HIGH: for events that require more attention,
 *   usually because responses are time-sensitive (for example chat and SMS
 *   messages or alarms)
 * @G_NOTIFICATION_PRIORITY_URGENT: for urgent notifications, or notifications
 *   that require a response in a short space of time (for example phone calls
 *   or emergency warnings)
 *
 * Priority levels for #GNotifications.
 *
 * Since: 2.42
 */
typedef enum {
  G_NOTIFICATION_PRIORITY_NORMAL,
  G_NOTIFICATION_PRIORITY_LOW,
  G_NOTIFICATION_PRIORITY_HIGH,
  G_NOTIFICATION_PRIORITY_URGENT
} GNotificationPriority;

/**
 * GNetworkConnectivity:
 * @G_NETWORK_CONNECTIVITY_LOCAL: The host is not configured with a
 *   route to the Internet; it may or may not be connected to a local
 *   network.
 * @G_NETWORK_CONNECTIVITY_LIMITED: The host is connected to a network, but
 *   does not appear to be able to reach the full Internet, perhaps
 *   due to upstream network problems.
 * @G_NETWORK_CONNECTIVITY_PORTAL: The host is behind a captive portal and
 *   cannot reach the full Internet.
 * @G_NETWORK_CONNECTIVITY_FULL: The host is connected to a network, and
 *   appears to be able to reach the full Internet.
 *
 * The host's network connectivity state, as reported by #GNetworkMonitor.
 *
 * Since: 2.44
 */
typedef enum {
  G_NETWORK_CONNECTIVITY_LOCAL       = 1,
  G_NETWORK_CONNECTIVITY_LIMITED     = 2,
  G_NETWORK_CONNECTIVITY_PORTAL      = 3,
  G_NETWORK_CONNECTIVITY_FULL        = 4
} GNetworkConnectivity;

/**
 * GPollableReturn:
 * @G_POLLABLE_RETURN_FAILED: Generic error condition for when an operation fails.
 * @G_POLLABLE_RETURN_OK: The operation was successfully finished.
 * @G_POLLABLE_RETURN_WOULD_BLOCK: The operation would block.
 *
 * Return value for various IO operations that signal errors via the
 * return value and not necessarily via a #GError.
 *
 * This enum exists to be able to return errors to callers without having to
 * allocate a #GError. Allocating #GErrors can be quite expensive for
 * regularly happening errors like %G_IO_ERROR_WOULD_BLOCK.
 *
 * In case of %G_POLLABLE_RETURN_FAILED a #GError should be set for the
 * operation to give details about the error that happened.
 *
 * Since: 2.60
 */
typedef enum {
  G_POLLABLE_RETURN_FAILED       = 0,
  G_POLLABLE_RETURN_OK           = 1,
  G_POLLABLE_RETURN_WOULD_BLOCK  = -G_IO_ERROR_WOULD_BLOCK
} GPollableReturn;

/**
 * GMemoryMonitorWarningLevel:
 * @G_MEMORY_MONITOR_WARNING_LEVEL_LOW: Memory on the device is low, processes
 *   should free up unneeded resources (for example, in-memory caches) so they can
 *   be used elsewhere.
 * @G_MEMORY_MONITOR_WARNING_LEVEL_MEDIUM: Same as @G_MEMORY_MONITOR_WARNING_LEVEL_LOW
 *   but the device has even less free memory, so processes should try harder to free
 *   up unneeded resources. If your process does not need to stay running, it is a
 *   good time for it to quit.
 * @G_MEMORY_MONITOR_WARNING_LEVEL_CRITICAL: The system will soon start terminating
 *   processes to reclaim memory, including background processes.
 *
 * Memory availability warning levels.
 *
 * Note that because new values might be added, it is recommended that applications check
 * #GMemoryMonitorWarningLevel as ranges, for example:
 * |[<!-- language="C" -->
 * if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
 *   drop_caches ();
 * ]|
 *
 * Since: 2.64
 */
typedef enum {
  G_MEMORY_MONITOR_WARNING_LEVEL_LOW      = 50,
  G_MEMORY_MONITOR_WARNING_LEVEL_MEDIUM   = 100,
  G_MEMORY_MONITOR_WARNING_LEVEL_CRITICAL = 255
} GMemoryMonitorWarningLevel;

G_END_DECLS

#endif /* __GIO_ENUMS_H__ */
                                                                                                            usr/include/glib-2.0/gio/gioenumtypes.h                                                             0000644 0000000 0000000 00000032753 14707647037 016422  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
/* This file is generated by glib-mkenums, do not modify it. This code is licensed under the same license as the containing project. Note that it links to GLib, so must comply with the LGPL linking clauses. */

/*
 * Copyright © 2007 Red Hat, Inc.
 *
 * SPDX-License-Identifier: LGPL-2.1-or-later
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General
 * Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
 *
 * Authors: Matthias Clasen <mclasen@redhat.com>
 */

#ifndef __GIO_ENUM_TYPES_H__
#define __GIO_ENUM_TYPES_H__

#include <glib-object.h>

G_BEGIN_DECLS

/* enumerations from "../../../gio/gioenums.h" */
GLIB_AVAILABLE_IN_ALL GType g_app_info_create_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_APP_INFO_CREATE_FLAGS (g_app_info_create_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_converter_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_CONVERTER_FLAGS (g_converter_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_converter_result_get_type (void) G_GNUC_CONST;
#define G_TYPE_CONVERTER_RESULT (g_converter_result_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_data_stream_byte_order_get_type (void) G_GNUC_CONST;
#define G_TYPE_DATA_STREAM_BYTE_ORDER (g_data_stream_byte_order_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_data_stream_newline_type_get_type (void) G_GNUC_CONST;
#define G_TYPE_DATA_STREAM_NEWLINE_TYPE (g_data_stream_newline_type_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_file_attribute_type_get_type (void) G_GNUC_CONST;
#define G_TYPE_FILE_ATTRIBUTE_TYPE (g_file_attribute_type_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_file_attribute_info_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_FILE_ATTRIBUTE_INFO_FLAGS (g_file_attribute_info_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_file_attribute_status_get_type (void) G_GNUC_CONST;
#define G_TYPE_FILE_ATTRIBUTE_STATUS (g_file_attribute_status_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_file_query_info_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_FILE_QUERY_INFO_FLAGS (g_file_query_info_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_file_create_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_FILE_CREATE_FLAGS (g_file_create_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_file_measure_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_FILE_MEASURE_FLAGS (g_file_measure_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_mount_mount_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_MOUNT_MOUNT_FLAGS (g_mount_mount_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_mount_unmount_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_MOUNT_UNMOUNT_FLAGS (g_mount_unmount_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_drive_start_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_DRIVE_START_FLAGS (g_drive_start_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_drive_start_stop_type_get_type (void) G_GNUC_CONST;
#define G_TYPE_DRIVE_START_STOP_TYPE (g_drive_start_stop_type_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_file_copy_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_FILE_COPY_FLAGS (g_file_copy_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_file_monitor_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_FILE_MONITOR_FLAGS (g_file_monitor_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_file_type_get_type (void) G_GNUC_CONST;
#define G_TYPE_FILE_TYPE (g_file_type_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_filesystem_preview_type_get_type (void) G_GNUC_CONST;
#define G_TYPE_FILESYSTEM_PREVIEW_TYPE (g_filesystem_preview_type_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_file_monitor_event_get_type (void) G_GNUC_CONST;
#define G_TYPE_FILE_MONITOR_EVENT (g_file_monitor_event_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_io_error_enum_get_type (void) G_GNUC_CONST;
#define G_TYPE_IO_ERROR_ENUM (g_io_error_enum_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_ask_password_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_ASK_PASSWORD_FLAGS (g_ask_password_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_password_save_get_type (void) G_GNUC_CONST;
#define G_TYPE_PASSWORD_SAVE (g_password_save_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_mount_operation_result_get_type (void) G_GNUC_CONST;
#define G_TYPE_MOUNT_OPERATION_RESULT (g_mount_operation_result_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_output_stream_splice_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_OUTPUT_STREAM_SPLICE_FLAGS (g_output_stream_splice_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_io_stream_splice_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_IO_STREAM_SPLICE_FLAGS (g_io_stream_splice_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_emblem_origin_get_type (void) G_GNUC_CONST;
#define G_TYPE_EMBLEM_ORIGIN (g_emblem_origin_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_resolver_error_get_type (void) G_GNUC_CONST;
#define G_TYPE_RESOLVER_ERROR (g_resolver_error_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_resolver_record_type_get_type (void) G_GNUC_CONST;
#define G_TYPE_RESOLVER_RECORD_TYPE (g_resolver_record_type_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_resource_error_get_type (void) G_GNUC_CONST;
#define G_TYPE_RESOURCE_ERROR (g_resource_error_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_resource_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_RESOURCE_FLAGS (g_resource_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_resource_lookup_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_RESOURCE_LOOKUP_FLAGS (g_resource_lookup_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_socket_family_get_type (void) G_GNUC_CONST;
#define G_TYPE_SOCKET_FAMILY (g_socket_family_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_socket_type_get_type (void) G_GNUC_CONST;
#define G_TYPE_SOCKET_TYPE (g_socket_type_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_socket_msg_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_SOCKET_MSG_FLAGS (g_socket_msg_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_socket_protocol_get_type (void) G_GNUC_CONST;
#define G_TYPE_SOCKET_PROTOCOL (g_socket_protocol_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_zlib_compressor_format_get_type (void) G_GNUC_CONST;
#define G_TYPE_ZLIB_COMPRESSOR_FORMAT (g_zlib_compressor_format_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_unix_socket_address_type_get_type (void) G_GNUC_CONST;
#define G_TYPE_UNIX_SOCKET_ADDRESS_TYPE (g_unix_socket_address_type_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_bus_type_get_type (void) G_GNUC_CONST;
#define G_TYPE_BUS_TYPE (g_bus_type_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_bus_name_owner_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_BUS_NAME_OWNER_FLAGS (g_bus_name_owner_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_bus_name_watcher_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_BUS_NAME_WATCHER_FLAGS (g_bus_name_watcher_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_dbus_proxy_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_DBUS_PROXY_FLAGS (g_dbus_proxy_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_dbus_error_get_type (void) G_GNUC_CONST;
#define G_TYPE_DBUS_ERROR (g_dbus_error_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_dbus_connection_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_DBUS_CONNECTION_FLAGS (g_dbus_connection_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_dbus_capability_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_DBUS_CAPABILITY_FLAGS (g_dbus_capability_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_dbus_call_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_DBUS_CALL_FLAGS (g_dbus_call_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_dbus_message_type_get_type (void) G_GNUC_CONST;
#define G_TYPE_DBUS_MESSAGE_TYPE (g_dbus_message_type_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_dbus_message_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_DBUS_MESSAGE_FLAGS (g_dbus_message_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_dbus_message_header_field_get_type (void) G_GNUC_CONST;
#define G_TYPE_DBUS_MESSAGE_HEADER_FIELD (g_dbus_message_header_field_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_dbus_property_info_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_DBUS_PROPERTY_INFO_FLAGS (g_dbus_property_info_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_dbus_subtree_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_DBUS_SUBTREE_FLAGS (g_dbus_subtree_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_dbus_server_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_DBUS_SERVER_FLAGS (g_dbus_server_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_dbus_signal_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_DBUS_SIGNAL_FLAGS (g_dbus_signal_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_dbus_send_message_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_DBUS_SEND_MESSAGE_FLAGS (g_dbus_send_message_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_credentials_type_get_type (void) G_GNUC_CONST;
#define G_TYPE_CREDENTIALS_TYPE (g_credentials_type_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_dbus_message_byte_order_get_type (void) G_GNUC_CONST;
#define G_TYPE_DBUS_MESSAGE_BYTE_ORDER (g_dbus_message_byte_order_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_application_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_APPLICATION_FLAGS (g_application_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_tls_error_get_type (void) G_GNUC_CONST;
#define G_TYPE_TLS_ERROR (g_tls_error_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_tls_certificate_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_TLS_CERTIFICATE_FLAGS (g_tls_certificate_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_tls_authentication_mode_get_type (void) G_GNUC_CONST;
#define G_TYPE_TLS_AUTHENTICATION_MODE (g_tls_authentication_mode_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_tls_channel_binding_type_get_type (void) G_GNUC_CONST;
#define G_TYPE_TLS_CHANNEL_BINDING_TYPE (g_tls_channel_binding_type_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_tls_channel_binding_error_get_type (void) G_GNUC_CONST;
#define G_TYPE_TLS_CHANNEL_BINDING_ERROR (g_tls_channel_binding_error_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_tls_rehandshake_mode_get_type (void) G_GNUC_CONST;
#define G_TYPE_TLS_REHANDSHAKE_MODE (g_tls_rehandshake_mode_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_tls_password_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_TLS_PASSWORD_FLAGS (g_tls_password_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_tls_interaction_result_get_type (void) G_GNUC_CONST;
#define G_TYPE_TLS_INTERACTION_RESULT (g_tls_interaction_result_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_dbus_interface_skeleton_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_DBUS_INTERFACE_SKELETON_FLAGS (g_dbus_interface_skeleton_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_dbus_object_manager_client_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_DBUS_OBJECT_MANAGER_CLIENT_FLAGS (g_dbus_object_manager_client_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_tls_database_verify_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_TLS_DATABASE_VERIFY_FLAGS (g_tls_database_verify_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_tls_database_lookup_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_TLS_DATABASE_LOOKUP_FLAGS (g_tls_database_lookup_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_tls_certificate_request_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_TLS_CERTIFICATE_REQUEST_FLAGS (g_tls_certificate_request_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_tls_protocol_version_get_type (void) G_GNUC_CONST;
#define G_TYPE_TLS_PROTOCOL_VERSION (g_tls_protocol_version_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_io_module_scope_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_IO_MODULE_SCOPE_FLAGS (g_io_module_scope_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_socket_client_event_get_type (void) G_GNUC_CONST;
#define G_TYPE_SOCKET_CLIENT_EVENT (g_socket_client_event_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_socket_listener_event_get_type (void) G_GNUC_CONST;
#define G_TYPE_SOCKET_LISTENER_EVENT (g_socket_listener_event_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_test_dbus_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_TEST_DBUS_FLAGS (g_test_dbus_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_subprocess_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_SUBPROCESS_FLAGS (g_subprocess_flags_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_notification_priority_get_type (void) G_GNUC_CONST;
#define G_TYPE_NOTIFICATION_PRIORITY (g_notification_priority_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_network_connectivity_get_type (void) G_GNUC_CONST;
#define G_TYPE_NETWORK_CONNECTIVITY (g_network_connectivity_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_pollable_return_get_type (void) G_GNUC_CONST;
#define G_TYPE_POLLABLE_RETURN (g_pollable_return_get_type ())
GLIB_AVAILABLE_IN_ALL GType g_memory_monitor_warning_level_get_type (void) G_GNUC_CONST;
#define G_TYPE_MEMORY_MONITOR_WARNING_LEVEL (g_memory_monitor_warning_level_get_type ())

/* enumerations from "../../../gio/gresolver.h" */
GLIB_AVAILABLE_IN_ALL GType g_resolver_name_lookup_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_RESOLVER_NAME_LOOKUP_FLAGS (g_resolver_name_lookup_flags_get_type ())

/* enumerations from "../../../gio/gsettings.h" */
GLIB_AVAILABLE_IN_ALL GType g_settings_bind_flags_get_type (void) G_GNUC_CONST;
#define G_TYPE_SETTINGS_BIND_FLAGS (g_settings_bind_flags_get_type ())
G_END_DECLS

#endif /* __GIO_ENUM_TYPES_H__ */

/* Generated data ends here */

                     usr/include/glib-2.0/gio/gioerror.h                                                                 0000644 0000000 0000000 00000003274 14375670023 015506  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* GIO - GLib Input, Output and Streaming Library
 *
 * Copyright (C) 2006-2007 Red Hat, Inc.
 *
 * SPDX-License-Identifier: LGPL-2.1-or-later
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General
 * Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Alexander Larsson <alexl@redhat.com>
 */

#ifndef __G_IO_ERROR_H__
#define __G_IO_ERROR_H__

#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
#error "Only <gio/gio.h> can be included directly."
#endif

#include <glib.h>
#include <gio/gioenums.h>
#include <glib/gfileutils.h>

G_BEGIN_DECLS

/**
 * G_IO_ERROR:
 *
 * Error domain for GIO. Errors in this domain will be from the #GIOErrorEnum enumeration.
 * See #GError for more information on error domains.
 **/
#define G_IO_ERROR g_io_error_quark()

GLIB_AVAILABLE_IN_ALL
GQuark       g_io_error_quark      (void);
GLIB_AVAILABLE_IN_ALL
GIOErrorEnum g_io_error_from_errno (gint err_no);
GLIB_AVAILABLE_IN_2_74
GIOErrorEnum g_io_error_from_file_error (GFileError file_error);

#ifdef G_OS_WIN32
GLIB_AVAILABLE_IN_ALL
GIOErrorEnum g_io_error_from_win32_error (gint error_code);
#endif

G_END_DECLS

#endif /* __G_IO_ERROR_H__ */
                                                                                                                                                                                                                                                                                                                                    usr/include/glib-2.0/gio/giomodule.h                                                                0000644 0000000 0000000 00000017677 14375670023 015656  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* GIO - GLib Input, Output and Streaming Library
 *
 * Copyright (C) 2006-2007 Red Hat, Inc.
 *
 * SPDX-License-Identifier: LGPL-2.1-or-later
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General
 * Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Alexander Larsson <alexl@redhat.com>
 */

#ifndef __G_IO_MODULE_H__
#define __G_IO_MODULE_H__

#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
#error "Only <gio/gio.h> can be included directly."
#endif

#include <gio/giotypes.h>
#include <gmodule.h>

G_BEGIN_DECLS

typedef struct _GIOModuleScope GIOModuleScope;

GLIB_AVAILABLE_IN_2_30
GIOModuleScope *   g_io_module_scope_new     (GIOModuleScopeFlags  flags);
GLIB_AVAILABLE_IN_2_30
void               g_io_module_scope_free    (GIOModuleScope      *scope);
GLIB_AVAILABLE_IN_2_30
void               g_io_module_scope_block   (GIOModuleScope      *scope,
                                              const gchar         *basename);

#define G_IO_TYPE_MODULE         (g_io_module_get_type ())
#define G_IO_MODULE(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_IO_TYPE_MODULE, GIOModule))
#define G_IO_MODULE_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_IO_TYPE_MODULE, GIOModuleClass))
#define G_IO_IS_MODULE(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_IO_TYPE_MODULE))
#define G_IO_IS_MODULE_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_IO_TYPE_MODULE))
#define G_IO_MODULE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_IO_TYPE_MODULE, GIOModuleClass))

/**
 * GIOModule:
 *
 * Opaque module base class for extending GIO.
 **/
typedef struct _GIOModuleClass GIOModuleClass;

GLIB_AVAILABLE_IN_ALL
GType              g_io_module_get_type                       (void) G_GNUC_CONST;
GLIB_AVAILABLE_IN_ALL
GIOModule         *g_io_module_new                            (const gchar       *filename);

GLIB_AVAILABLE_IN_ALL
void               g_io_modules_scan_all_in_directory         (const char        *dirname);
GLIB_AVAILABLE_IN_ALL
GList             *g_io_modules_load_all_in_directory         (const gchar       *dirname);

GLIB_AVAILABLE_IN_2_30
void               g_io_modules_scan_all_in_directory_with_scope   (const gchar       *dirname,
                                                                    GIOModuleScope    *scope);
GLIB_AVAILABLE_IN_2_30
GList             *g_io_modules_load_all_in_directory_with_scope   (const gchar       *dirname,
                                                                    GIOModuleScope    *scope);

GLIB_AVAILABLE_IN_ALL
GIOExtensionPoint *g_io_extension_point_register              (const char        *name);
GLIB_AVAILABLE_IN_ALL
GIOExtensionPoint *g_io_extension_point_lookup                (const char        *name);
GLIB_AVAILABLE_IN_ALL
void               g_io_extension_point_set_required_type     (GIOExtensionPoint *extension_point,
							       GType              type);
GLIB_AVAILABLE_IN_ALL
GType              g_io_extension_point_get_required_type     (GIOExtensionPoint *extension_point);
GLIB_AVAILABLE_IN_ALL
GList             *g_io_extension_point_get_extensions        (GIOExtensionPoint *extension_point);
GLIB_AVAILABLE_IN_ALL
GIOExtension *     g_io_extension_point_get_extension_by_name (GIOExtensionPoint *extension_point,
							       const char        *name);
GLIB_AVAILABLE_IN_ALL
GIOExtension *     g_io_extension_point_implement             (const char        *extension_point_name,
							       GType              type,
							       const char        *extension_name,
							       gint               priority);

GLIB_AVAILABLE_IN_ALL
GType              g_io_extension_get_type                    (GIOExtension      *extension);
GLIB_AVAILABLE_IN_ALL
const char *       g_io_extension_get_name                    (GIOExtension      *extension);
GLIB_AVAILABLE_IN_ALL
gint               g_io_extension_get_priority                (GIOExtension      *extension);
GLIB_AVAILABLE_IN_ALL
GTypeClass*        g_io_extension_ref_class                   (GIOExtension      *extension);


/* API for the modules to implement */

/**
 * g_io_module_load: (skip)
 * @module: a #GIOModule.
 *
 * Required API for GIO modules to implement.
 *
 * This function is run after the module has been loaded into GIO,
 * to initialize the module. Typically, this function will call
 * g_io_extension_point_implement().
 *
 * Since 2.56, this function should be named `g_io_<modulename>_load`, where
 * `modulename` is the plugin’s filename with the `lib` or `libgio` prefix and
 * everything after the first dot removed, and with `-` replaced with `_`
 * throughout. For example, `libgiognutls-helper.so` becomes `gnutls_helper`.
 * Using the new symbol names avoids name clashes when building modules
 * statically. The old symbol names continue to be supported, but cannot be used
 * for static builds.
 **/
GLIB_AVAILABLE_IN_ALL
void   g_io_module_load   (GIOModule *module);

/**
 * g_io_module_unload: (skip)
 * @module: a #GIOModule.
 *
 * Required API for GIO modules to implement.
 *
 * This function is run when the module is being unloaded from GIO,
 * to finalize the module.
