if a correct password is given.  The digest of the password is stored,
not the password itself.  The user types in a password that is
L<C<crypt>|/crypt PLAINTEXT,SALT>'d with the same salt as the stored
digest.  If the two digests match, the password is correct.

When verifying an existing digest string you should use the digest as
the salt (like C<crypt($plain, $digest) eq $digest>).  The SALT used
to create the digest is visible as part of the digest.  This ensures
L<C<crypt>|/crypt PLAINTEXT,SALT> will hash the new string with the same
salt as the digest.  This allows your code to work with the standard
L<C<crypt>|/crypt PLAINTEXT,SALT> and with more exotic implementations.
In other words, assume nothing about the returned string itself nor
about how many bytes of SALT may matter.

Traditionally the result is a string of 13 bytes: two first bytes of
the salt, followed by 11 bytes from the set C<[./0-9A-Za-z]>, and only
the first eight bytes of PLAINTEXT mattered.  But alternative
hashing schemes (like MD5), higher level security schemes (like C2),
and implementations on non-Unix platforms may produce different
strings.

When choosing a new salt create a random two character string whose
characters come from the set C<[./0-9A-Za-z]> (like C<join '', ('.',
'/', 0..9, 'A'..'Z', 'a'..'z')[rand 64, rand 64]>).  This set of
characters is just a recommendation; the characters allowed in
the salt depend solely on your system's crypt library, and Perl can't
restrict what salts L<C<crypt>|/crypt PLAINTEXT,SALT> accepts.

Here's an example that makes sure that whoever runs this program knows
their password:

    my $pwd = (getpwuid($<))[1];

    system "stty -echo";
    print "Password: ";
    chomp(my $word = <STDIN>);
    print "\n";
    system "stty echo";

    if (crypt($word, $pwd) ne $pwd) {
        die "Sorry...\n";
    } else {
        print "ok\n";
    }

Of course, typing in your own password to whoever asks you
for it is unwise.

The L<C<crypt>|/crypt PLAINTEXT,SALT> function is unsuitable for hashing
large quantities of data, not least of all because you can't get the
information back.  Look at the L<Digest> module for more robust
algorithms.

If using L<C<crypt>|/crypt PLAINTEXT,SALT> on a Unicode string (which
I<potentially> has characters with codepoints above 255), Perl tries to
make sense of the situation by trying to downgrade (a copy of) the
string back to an eight-bit byte string before calling
L<C<crypt>|/crypt PLAINTEXT,SALT> (on that copy).  If that works, good.
If not, L<C<crypt>|/crypt PLAINTEXT,SALT> dies with
L<C<Wide character in crypt>|perldiag/Wide character in %s>.

Portability issues: L<perlport/crypt>.

=item dbmclose HASH
X<dbmclose>

=for Pod::Functions breaks binding on a tied dbm file

[This function has been largely superseded by the
L<C<untie>|/untie VARIABLE> function.]

Breaks the binding between a DBM file and a hash.

Portability issues: L<perlport/dbmclose>.

=item dbmopen HASH,DBNAME,MASK
X<dbmopen> X<dbm> X<ndbm> X<sdbm> X<gdbm>

=for Pod::Functions create binding on a tied dbm file

[This function has been largely superseded by the
L<C<tie>|/tie VARIABLE,CLASSNAME,LIST> function.]

This binds a L<dbm(3)>, L<ndbm(3)>, L<sdbm(3)>, L<gdbm(3)>, or Berkeley
DB file to a hash.  HASH is the name of the hash.  (Unlike normal
L<C<open>|/open FILEHANDLE,MODE,EXPR>, the first argument is I<not> a
filehandle, even though it looks like one).  DBNAME is the name of the
database (without the F<.dir> or F<.pag> extension if any).  If the
database does not exist, it is created with protection specified by MASK
(as modified by the L<C<umask>|/umask EXPR>).  To prevent creation of
the database if it doesn't exist, you may specify a MASK of 0, and the
function will return a false value if it can't find an existing
database.  If your system supports only the older DBM functions, you may
make only one L<C<dbmopen>|/dbmopen HASH,DBNAME,MASK> call in your
program.  In older versions of Perl, if your system had neither DBM nor
ndbm, calling L<C<dbmopen>|/dbmopen HASH,DBNAME,MASK> produced a fatal
error; it now falls back to L<sdbm(3)>.

If you don't have write access to the DBM file, you can only read hash
variables, not set them.  If you want to test whether you can write,
either use file tests or try setting a dummy hash entry inside an
L<C<eval>|/eval EXPR> to trap the error.

Note that functions such as L<C<keys>|/keys HASH> and
L<C<values>|/values HASH> may return huge lists when used on large DBM
files.  You may prefer to use the L<C<each>|/each HASH> function to
iterate over large DBM files.  Example:

    # print out history file offsets
    dbmopen(%HIST,'/usr/lib/news/history',0666);
    while (($key,$val) = each %HIST) {
        print $key, ' = ', unpack('L',$val), "\n";
    }
    dbmclose(%HIST);

See also L<AnyDBM_File> for a more general description of the pros and
cons of the various dbm approaches, as well as L<DB_File> for a particularly
rich implementation.

You can control which DBM library you use by loading that library
before you call L<C<dbmopen>|/dbmopen HASH,DBNAME,MASK>:

    use DB_File;
    dbmopen(%NS_Hist, "$ENV{HOME}/.netscape/history.db")
        or die "Can't open netscape history file: $!";

Portability issues: L<perlport/dbmopen>.

=item defined EXPR
X<defined> X<undef> X<undefined>

=item defined

=for Pod::Functions test whether a value, variable, or function is defined

Returns a Boolean value telling whether EXPR has a value other than the
undefined value L<C<undef>|/undef EXPR>.  If EXPR is not present,
L<C<$_>|perlvar/$_> is checked.

Many operations return L<C<undef>|/undef EXPR> to indicate failure, end
of file, system error, uninitialized variable, and other exceptional
conditions.  This function allows you to distinguish
L<C<undef>|/undef EXPR> from other values.  (A simple Boolean test will
not distinguish among L<C<undef>|/undef EXPR>, zero, the empty string,
and C<"0">, which are all equally false.)  Note that since
L<C<undef>|/undef EXPR> is a valid scalar, its presence doesn't
I<necessarily> indicate an exceptional condition: L<C<pop>|/pop ARRAY>
returns L<C<undef>|/undef EXPR> when its argument is an empty array,
I<or> when the element to return happens to be L<C<undef>|/undef EXPR>.

You may also use C<defined(&func)> to check whether subroutine C<func>
has ever been defined.  The return value is unaffected by any forward
declarations of C<func>.  A subroutine that is not defined
may still be callable: its package may have an C<AUTOLOAD> method that
makes it spring into existence the first time that it is called; see
L<perlsub>.

Use of L<C<defined>|/defined EXPR> on aggregates (hashes and arrays) is
no longer supported. It used to report whether memory for that
aggregate had ever been allocated.  You should instead use a simple
test for size:

    if (@an_array) { print "has array elements\n" }
    if (%a_hash)   { print "has hash members\n"   }

When used on a hash element, it tells you whether the value is defined,
not whether the key exists in the hash.  Use L<C<exists>|/exists EXPR>
for the latter purpose.

Examples:

    print if defined $switch{D};
    print "$val\n" while defined($val = pop(@ary));
    die "Can't readlink $sym: $!"
        unless defined($value = readlink $sym);
    sub foo { defined &$bar ? $bar->(@_) : die "No bar"; }
    $debugging = 0 unless defined $debugging;

Note:  Many folks tend to overuse L<C<defined>|/defined EXPR> and are
then surprised to discover that the number C<0> and C<""> (the
zero-length string) are, in fact, defined values.  For example, if you
say

    "ab" =~ /a(.*)b/;

The pattern match succeeds and C<$1> is defined, although it
matched "nothing".  It didn't really fail to match anything.  Rather, it
matched something that happened to be zero characters long.  This is all
very above-board and honest.  When a function returns an undefined value,
it's an admission that it couldn't give you an honest answer.  So you
should use L<C<defined>|/defined EXPR> only when questioning the
integrity of what you're trying to do.  At other times, a simple
comparison to C<0> or C<""> is what you want.

See also L<C<undef>|/undef EXPR>, L<C<exists>|/exists EXPR>,
L<C<ref>|/ref EXPR>.

=item delete EXPR
X<delete>

=for Pod::Functions deletes a value from a hash

Given an expression that specifies an element or slice of a hash,
L<C<delete>|/delete EXPR> deletes the specified elements from that hash
so that L<C<exists>|/exists EXPR> on that element no longer returns
true.  Setting a hash element to the undefined value does not remove its
key, but deleting it does; see L<C<exists>|/exists EXPR>.

In list context, usually returns the value or values deleted, or the last such
element in scalar context.  The return list's length corresponds to that of
the argument list: deleting non-existent elements returns the undefined value
in their corresponding positions. Since Perl 5.28, a
L<keyE<sol>value hash slice|perldata/KeyE<sol>Value Hash Slices> can be passed
to C<delete>, and the return value is a list of key/value pairs (two elements
for each item deleted from the hash).

L<C<delete>|/delete EXPR> may also be used on arrays and array slices,
but its behavior is less straightforward.  Although
L<C<exists>|/exists EXPR> will return false for deleted entries,
deleting array elements never changes indices of existing values; use
L<C<shift>|/shift ARRAY> or L<C<splice>|/splice
ARRAY,OFFSET,LENGTH,LIST> for that.  However, if any deleted elements
fall at the end of an array, the array's size shrinks to the position of
the highest element that still tests true for L<C<exists>|/exists EXPR>,
or to 0 if none do.  In other words, an array won't have trailing
nonexistent elements after a delete.

B<WARNING:> Calling L<C<delete>|/delete EXPR> on array values is
strongly discouraged.  The
notion of deleting or checking the existence of Perl array elements is not
conceptually coherent, and can lead to surprising behavior.

Deleting from L<C<%ENV>|perlvar/%ENV> modifies the environment.
Deleting from a hash tied to a DBM file deletes the entry from the DBM
file.  Deleting from a L<C<tied>|/tied VARIABLE> hash or array may not
necessarily return anything; it depends on the implementation of the
L<C<tied>|/tied VARIABLE> package's DELETE method, which may do whatever
it pleases.

The C<delete local EXPR> construct localizes the deletion to the current
block at run time.  Until the block exits, elements locally deleted
temporarily no longer exist.  See L<perlsub/"Localized deletion of elements
of composite types">.

    my %hash = (foo => 11, bar => 22, baz => 33);
    my $scalar = delete $hash{foo};         # $scalar is 11
    $scalar = delete @hash{qw(foo bar)}; # $scalar is 22
    my @array  = delete @hash{qw(foo baz)}; # @array  is (undef,33)

The following (inefficiently) deletes all the values of %HASH and @ARRAY:

    foreach my $key (keys %HASH) {
        delete $HASH{$key};
    }

    foreach my $index (0 .. $#ARRAY) {
        delete $ARRAY[$index];
    }

And so do these:

    delete @HASH{keys %HASH};

    delete @ARRAY[0 .. $#ARRAY];

But both are slower than assigning the empty list
or undefining %HASH or @ARRAY, which is the customary
way to empty out an aggregate:

    %HASH = ();     # completely empty %HASH
    undef %HASH;    # forget %HASH ever existed

    @ARRAY = ();    # completely empty @ARRAY
    undef @ARRAY;   # forget @ARRAY ever existed

The EXPR can be arbitrarily complicated provided its
final operation is an element or slice of an aggregate:

    delete $ref->[$x][$y]{$key};
    delete $ref->[$x][$y]->@{$key1, $key2, @morekeys};

    delete $ref->[$x][$y][$index];
    delete $ref->[$x][$y]->@[$index1, $index2, @moreindices];

=item die LIST
X<die> X<throw> X<exception> X<raise> X<$@> X<abort>

=for Pod::Functions raise an exception or bail out

L<C<die>|/die LIST> raises an exception.  Inside an L<C<eval>|/eval EXPR>
the exception is stuffed into L<C<$@>|perlvar/$@> and the L<C<eval>|/eval
EXPR> is terminated with the undefined value.  If the exception is
outside of all enclosing L<C<eval>|/eval EXPR>s, then the uncaught
exception is printed to C<STDERR> and perl exits with an exit code
indicating failure.  If you need to exit the process with a specific
exit code, see L<C<exit>|/exit EXPR>.

Equivalent examples:

    die "Can't cd to spool: $!\n" unless chdir '/usr/spool/news';
    chdir '/usr/spool/news' or die "Can't cd to spool: $!\n"

Most of the time, C<die> is called with a string to use as the exception.
You may either give a single non-reference operand to serve as the
exception, or a list of two or more items, which will be stringified
and concatenated to make the exception.

If the string exception does not end in a newline, the current
script line number and input line number (if any) and a newline
are appended to it.  Note that the "input line number" (also
known as "chunk") is subject to whatever notion of "line" happens to
be currently in effect, and is also available as the special variable
L<C<$.>|perlvar/$.>.  See L<perlvar/"$/"> and L<perlvar/"$.">.

Hint: sometimes appending C<", stopped"> to your message will cause it
to make better sense when the string C<"at foo line 123"> is appended.
Suppose you are running script "canasta".

    die "/etc/games is no good";
    die "/etc/games is no good, stopped";

produce, respectively

    /etc/games is no good at canasta line 123.
    /etc/games is no good, stopped at canasta line 123.

If LIST was empty or made an empty string, and L<C<$@>|perlvar/$@>
already contains an exception value (typically from a previous
L<C<eval>|/eval EXPR>), then that value is reused after
appending C<"\t...propagated">.  This is useful for propagating exceptions:

    eval { ... };
    die unless $@ =~ /Expected exception/;

If LIST was empty or made an empty string,
and L<C<$@>|perlvar/$@> contains an object
reference that has a C<PROPAGATE> method, that method will be called
with additional file and line number parameters.  The return value
replaces the value in L<C<$@>|perlvar/$@>;  i.e., as if
C<< $@ = eval { $@->PROPAGATE(__FILE__, __LINE__) }; >> were called.

If LIST was empty or made an empty string, and L<C<$@>|perlvar/$@>
is also empty, then the string C<"Died"> is used.

You can also call L<C<die>|/die LIST> with a reference argument, and if
this is trapped within an L<C<eval>|/eval EXPR>, L<C<$@>|perlvar/$@>
contains that reference.  This permits more elaborate exception handling
using objects that maintain arbitrary state about the exception.  Such a
scheme is sometimes preferable to matching particular string values of
L<C<$@>|perlvar/$@> with regular expressions.

Because Perl stringifies uncaught exception messages before display,
you'll probably want to overload stringification operations on
exception objects.  See L<overload> for details about that.
The stringified message should be non-empty, and should end in a newline,
in order to fit in with the treatment of string exceptions.
Also, because an exception object reference cannot be stringified
without destroying it, Perl doesn't attempt to append location or other
information to a reference exception.  If you want location information
with a complex exception object, you'll have to arrange to put the
location information into the object yourself.

Because L<C<$@>|perlvar/$@> is a global variable, be careful that
analyzing an exception caught by C<eval> doesn't replace the reference
in the global variable.  It's
easiest to make a local copy of the reference before any manipulations.
Here's an example:

    use Scalar::Util "blessed";

    eval { ... ; die Some::Module::Exception->new( FOO => "bar" ) };
    if (my $ev_err = $@) {
        if (blessed($ev_err)
            && $ev_err->isa("Some::Module::Exception")) {
            # handle Some::Module::Exception
        }
        else {
            # handle all other possible exceptions
        }
    }

If an uncaught exception results in interpreter exit, the exit code is
determined from the values of L<C<$!>|perlvar/$!> and
L<C<$?>|perlvar/$?> with this pseudocode:

    exit $! if $!;              # errno
    exit $? >> 8 if $? >> 8;    # child exit status
    exit 255;                   # last resort

As with L<C<exit>|/exit EXPR>, L<C<$?>|perlvar/$?> is set prior to
unwinding the call stack; any C<DESTROY> or C<END> handlers can then
alter this value, and thus Perl's exit code.

The intent is to squeeze as much possible information about the likely cause
into the limited space of the system exit code.  However, as
L<C<$!>|perlvar/$!> is the value of C's C<errno>, which can be set by
any system call, this means that the value of the exit code used by
L<C<die>|/die LIST> can be non-predictable, so should not be relied
upon, other than to be non-zero.

You can arrange for a callback to be run just before the
L<C<die>|/die LIST> does its deed, by setting the
L<C<$SIG{__DIE__}>|perlvar/%SIG> hook.  The associated handler is called
with the exception as an argument, and can change the exception,
if it sees fit, by
calling L<C<die>|/die LIST> again.  See L<perlvar/%SIG> for details on
setting L<C<%SIG>|perlvar/%SIG> entries, and L<C<eval>|/eval EXPR> for some
examples.  Although this feature was to be run only right before your
program was to exit, this is not currently so: the
L<C<$SIG{__DIE__}>|perlvar/%SIG> hook is currently called even inside
L<C<eval>|/eval EXPR>ed blocks/strings!  If one wants the hook to do
nothing in such situations, put

    die @_ if $^S;

as the first line of the handler (see L<perlvar/$^S>).  Because
this promotes strange action at a distance, this counterintuitive
behavior may be fixed in a future release.

See also L<C<exit>|/exit EXPR>, L<C<warn>|/warn LIST>, and the L<Carp>
module.

=item do BLOCK
X<do> X<block>

=for Pod::Functions turn a BLOCK into a TERM

Not really a function.  Returns the value of the last command in the
sequence of commands indicated by BLOCK.  When modified by the C<while> or
C<until> loop modifier, executes the BLOCK once before testing the loop
condition.  (On other statements the loop modifiers test the conditional
first.)

C<do BLOCK> does I<not> count as a loop, so the loop control statements
L<C<next>|/next LABEL>, L<C<last>|/last LABEL>, or
L<C<redo>|/redo LABEL> cannot be used to leave or restart the block.
See L<perlsyn> for alternative strategies.

=item do EXPR
X<do>

Uses the value of EXPR as a filename and executes the contents of the
file as a Perl script:

    # load the exact specified file (./ and ../ special-cased)
    do '/foo/stat.pl';
    do './stat.pl';
    do '../foo/stat.pl';

    # search for the named file within @INC
    do 'stat.pl';
    do 'foo/stat.pl';

C<do './stat.pl'> is largely like

    eval `cat stat.pl`;

except that it's more concise, runs no external processes, and keeps
track of the current filename for error messages. It also differs in that
code evaluated with C<do FILE> cannot see lexicals in the enclosing
scope; C<eval STRING> does.  It's the same, however, in that it does
reparse the file every time you call it, so you probably don't want
to do this inside a loop.

Using C<do> with a relative path (except for F<./> and F<../>), like

    do 'foo/stat.pl';

will search the L<C<@INC>|perlvar/@INC> directories, and update
L<C<%INC>|perlvar/%INC> if the file is found.  See L<perlvar/@INC>
and L<perlvar/%INC> for these variables. In particular, note that
whilst historically L<C<@INC>|perlvar/@INC> contained '.' (the
current directory) making these two cases equivalent, that is no
longer necessarily the case, as '.' is not included in C<@INC> by default
in perl versions 5.26.0 onwards. Instead, perl will now warn:

    do "stat.pl" failed, '.' is no longer in @INC;
    did you mean do "./stat.pl"?

If L<C<do>|/do EXPR> can read the file but cannot compile it, it
returns L<C<undef>|/undef EXPR> and sets an error message in
L<C<$@>|perlvar/$@>.  If L<C<do>|/do EXPR> cannot read the file, it
returns undef and sets L<C<$!>|perlvar/$!> to the error.  Always check
L<C<$@>|perlvar/$@> first, as compilation could fail in a way that also
sets L<C<$!>|perlvar/$!>.  If the file is successfully compiled,
L<C<do>|/do EXPR> returns the value of the last expression evaluated.

Inclusion of library modules is better done with the
L<C<use>|/use Module VERSION LIST> and L<C<require>|/require VERSION>
operators, which also do automatic error checking and raise an exception
if there's a problem.

You might like to use L<C<do>|/do EXPR> to read in a program
configuration file.  Manual error checking can be done this way:

    # Read in config files: system first, then user.
    # Beware of using relative pathnames here.
    for $file ("/share/prog/defaults.rc",
               "$ENV{HOME}/.someprogrc")
    {
        unless ($return = do $file) {
            warn "couldn't parse $file: $@" if $@;
            warn "couldn't do $file: $!"    unless defined $return;
            warn "couldn't run $file"       unless $return;
        }
    }

=item dump LABEL
X<dump> X<core> X<undump>

=item dump EXPR

=item dump

=for Pod::Functions create an immediate core dump

This function causes an immediate core dump.  See also the B<-u>
command-line switch in L<perlrun|perlrun/-u>, which does the same thing.
Primarily this is so that you can use the B<undump> program (not
supplied) to turn your core dump into an executable binary after
having initialized all your variables at the beginning of the
program.  When the new binary is executed it will begin by executing
a C<goto LABEL> (with all the restrictions that L<C<goto>|/goto LABEL>
suffers).
Think of it as a goto with an intervening core dump and reincarnation.
If C<LABEL> is omitted, restarts the program from the top.  The
C<dump EXPR> form, available starting in Perl 5.18.0, allows a name to be
computed at run time, being otherwise identical to C<dump LABEL>.

B<WARNING>: Any files opened at the time of the dump will I<not>
be open any more when the program is reincarnated, with possible
resulting confusion by Perl.

This function is now largely obsolete, mostly because it's very hard to
convert a core file into an executable.  As of Perl 5.30, it must be invoked
as C<CORE::dump()>.

Unlike most named operators, this has the same precedence as assignment.
It is also exempt from the looks-like-a-function rule, so
C<dump ("foo")."bar"> will cause "bar" to be part of the argument to
L<C<dump>|/dump LABEL>.

Portability issues: L<perlport/dump>.

=item each HASH
X<each> X<hash, iterator>

=item each ARRAY
X<array, iterator>

=for Pod::Functions retrieve the next key/value pair from a hash

When called on a hash in list context, returns a 2-element list
consisting of the key and value for the next element of a hash.  In Perl
5.12 and later only, it will also return the index and value for the next
element of an array so that you can iterate over it; older Perls consider
this a syntax error.  When called in scalar context, returns only the key
(not the value) in a hash, or the index in an array.

Hash entries are returned in an apparently random order.  The actual random
order is specific to a given hash; the exact same series of operations
on two hashes may result in a different order for each hash.  Any insertion
into the hash may change the order, as will any deletion, with the exception
that the most recent key returned by L<C<each>|/each HASH> or
L<C<keys>|/keys HASH> may be deleted without changing the order.  So
long as a given hash is unmodified you may rely on
L<C<keys>|/keys HASH>, L<C<values>|/values HASH> and
L<C<each>|/each HASH> to repeatedly return the same order
as each other.  See L<perlsec/"Algorithmic Complexity Attacks"> for
details on why hash order is randomized.  Aside from the guarantees
provided here the exact details of Perl's hash algorithm and the hash
traversal order are subject to change in any release of Perl.

After L<C<each>|/each HASH> has returned all entries from the hash or
array, the next call to L<C<each>|/each HASH> returns the empty list in
list context and L<C<undef>|/undef EXPR> in scalar context; the next
call following I<that> one restarts iteration.  Each hash or array has
its own internal iterator, accessed by L<C<each>|/each HASH>,
L<C<keys>|/keys HASH>, and L<C<values>|/values HASH>.  The iterator is
implicitly reset when L<C<each>|/each HASH> has reached the end as just
described; it can be explicitly reset by calling L<C<keys>|/keys HASH>
or L<C<values>|/values HASH> on the hash or array, or by referencing
the hash (but not array) in list context.  If you add or delete
a hash's elements while iterating over it, the effect on the iterator is
unspecified; for example, entries may be skipped or duplicated--so don't
do that.  Exception: It is always safe to delete the item most recently
returned by L<C<each>|/each HASH>, so the following code works properly:

    while (my ($key, $value) = each %hash) {
        print $key, "\n";
        delete $hash{$key};   # This is safe
    }

Tied hashes may have a different ordering behaviour to perl's hash
implementation.

The iterator used by C<each> is attached to the hash or array, and is
shared between all iteration operations applied to the same hash or array.
Thus all uses of C<each> on a single hash or array advance the same
iterator location.  All uses of C<each> are also subject to having the
iterator reset by any use of C<keys> or C<values> on the same hash or
array, or by the hash (but not array) being referenced in list context.
This makes C<each>-based loops quite fragile: it is easy to arrive at
such a loop with the iterator already part way through the object, or to
accidentally clobber the iterator state during execution of the loop body.
It's easy enough to explicitly reset the iterator before starting a loop,
but there is no way to insulate the iterator state used by a loop from
the iterator state used by anything else that might execute during the
loop body.  To avoid these problems, use a C<foreach> loop rather than
C<while>-C<each>.

This extends to using C<each> on the result of an anonymous hash or
array constructor.  A new underlying array or hash is created each
time so each will always start iterating from scratch, eg:

  # loops forever
  while (my ($key, $value) = each @{ +{ a => 1 } }) {
      print "$key=$value\n";
  }

This prints out your environment like the L<printenv(1)> program,
but in a different order:

    while (my ($key,$value) = each %ENV) {
        print "$key=$value\n";
    }

Starting with Perl 5.14, an experimental feature allowed
L<C<each>|/each HASH> to take a scalar expression. This experiment has
been deemed unsuccessful, and was removed as of Perl 5.24.

As of Perl 5.18 you can use a bare L<C<each>|/each HASH> in a C<while>
loop, which will set L<C<$_>|perlvar/$_> on every iteration.
If either an C<each> expression or an explicit assignment of an C<each>
expression to a scalar is used as a C<while>/C<for> condition, then
the condition actually tests for definedness of the expression's value,
not for its regular truth value.

    while (each %ENV) {
	print "$_=$ENV{$_}\n";
    }

To avoid confusing would-be users of your code who are running earlier
versions of Perl with mysterious syntax errors, put this sort of thing at
the top of your file to signal that your code will work I<only> on Perls of
a recent vintage:

    use v5.12;	# so keys/values/each work on arrays
    use v5.18;	# so each assigns to $_ in a lone while test

See also L<C<keys>|/keys HASH>, L<C<values>|/values HASH>, and
L<C<sort>|/sort SUBNAME LIST>.

=item eof FILEHANDLE
X<eof>
X<end of file>
X<end-of-file>

=item eof ()

=item eof

=for Pod::Functions test a filehandle for its end

Returns 1 if the next read on FILEHANDLE will return end of file I<or> if
FILEHANDLE is not open.  FILEHANDLE may be an expression whose value
gives the real filehandle.  (Note that this function actually
reads a character and then C<ungetc>s it, so isn't useful in an
interactive context.)  Do not read from a terminal file (or call
C<eof(FILEHANDLE)> on it) after end-of-file is reached.  File types such
as terminals may lose the end-of-file condition if you do.

An L<C<eof>|/eof FILEHANDLE> without an argument uses the last file
read.  Using L<C<eof()>|/eof FILEHANDLE> with empty parentheses is
different.  It refers to the pseudo file formed from the files listed on
the command line and accessed via the C<< <> >> operator.  Since
C<< <> >> isn't explicitly opened, as a normal filehandle is, an
L<C<eof()>|/eof FILEHANDLE> before C<< <> >> has been used will cause
L<C<@ARGV>|perlvar/@ARGV> to be examined to determine if input is
available.   Similarly, an L<C<eof()>|/eof FILEHANDLE> after C<< <> >>
has returned end-of-file will assume you are processing another
L<C<@ARGV>|perlvar/@ARGV> list, and if you haven't set
L<C<@ARGV>|perlvar/@ARGV>, will read input from C<STDIN>; see
L<perlop/"I/O Operators">.

In a C<< while (<>) >> loop, L<C<eof>|/eof FILEHANDLE> or C<eof(ARGV)>
can be used to detect the end of each file, whereas
L<C<eof()>|/eof FILEHANDLE> will detect the end of the very last file
only.  Examples:

    # reset line numbering on each input file
    while (<>) {
        next if /^\s*#/;  # skip comments
        print "$.\t$_";
    } continue {
        close ARGV if eof;  # Not eof()!
    }

    # insert dashes just before last line of last file
    while (<>) {
        if (eof()) {  # check for end of last file
            print "--------------\n";
        }
        print;
        last if eof();     # needed if we're reading from a terminal
    }

Practical hint: you almost never need to use L<C<eof>|/eof FILEHANDLE>
in Perl, because the input operators typically return L<C<undef>|/undef
EXPR> when they run out of data or encounter an error.

=item eval EXPR
X<eval> X<try> X<catch> X<evaluate> X<parse> X<execute>
X<error, handling> X<exception, handling>

=item eval BLOCK

=item eval

=for Pod::Functions catch exceptions or compile and run code

C<eval> in all its forms is used to execute a little Perl program,
trapping any errors encountered so they don't crash the calling program.

Plain C<eval> with no argument is just C<eval EXPR>, where the
expression is understood to be contained in L<C<$_>|perlvar/$_>.  Thus
there are only two real C<eval> forms; the one with an EXPR is often
called "string eval".  In a string eval, the value of the expression
(which is itself determined within scalar context) is first parsed, and
if there were no errors, executed as a block within the lexical context
of the current Perl program.  This form is typically used to delay
parsing and subsequent execution of the text of EXPR until run time.
Note that the value is parsed every time the C<eval> executes.

The other form is called "block eval".  It is less general than string
eval, but the code within the BLOCK is parsed only once (at the same
time the code surrounding the C<eval> itself was parsed) and executed
within the context of the current Perl program.  This form is typically
used to trap exceptions more efficiently than the first, while also
providing the benefit of checking the code within BLOCK at compile time.
BLOCK is parsed and compiled just once.  Since errors are trapped, it
often is used to check if a given feature is available.

In both forms, the value returned is the value of the last expression
evaluated inside the mini-program; a return statement may also be used, just
as with subroutines.  The expression providing the return value is evaluated
in void, scalar, or list context, depending on the context of the
C<eval> itself.  See L<C<wantarray>|/wantarray> for more
on how the evaluation context can be determined.

If there is a syntax error or runtime error, or a L<C<die>|/die LIST>
statement is executed, C<eval> returns
L<C<undef>|/undef EXPR> in scalar context, or an empty list in list
context, and L<C<$@>|perlvar/$@> is set to the error message.  (Prior to
5.16, a bug caused L<C<undef>|/undef EXPR> to be returned in list
context for syntax errors, but not for runtime errors.) If there was no
error, L<C<$@>|perlvar/$@> is set to the empty string.  A control flow
operator like L<C<last>|/last LABEL> or L<C<goto>|/goto LABEL> can
bypass the setting of L<C<$@>|perlvar/$@>.  Beware that using
C<eval> neither silences Perl from printing warnings to
STDERR, nor does it stuff the text of warning messages into
L<C<$@>|perlvar/$@>.  To do either of those, you have to use the
L<C<$SIG{__WARN__}>|perlvar/%SIG> facility, or turn off warnings inside
the BLOCK or EXPR using S<C<no warnings 'all'>>.  See
L<C<warn>|/warn LIST>, L<perlvar>, and L<warnings>.

Note that, because C<eval> traps otherwise-fatal errors,
it is useful for determining whether a particular feature (such as
L<C<socket>|/socket SOCKET,DOMAIN,TYPE,PROTOCOL> or
L<C<symlink>|/symlink OLDFILE,NEWFILE>) is implemented.  It is also
Perl's exception-trapping mechanism, where the L<C<die>|/die LIST>
operator is used to raise exceptions.

Before Perl 5.14, the assignment to L<C<$@>|perlvar/$@> occurred before
restoration
of localized variables, which means that for your code to run on older
versions, a temporary is required if you want to mask some, but not all
errors:

 # alter $@ on nefarious repugnancy only
 {
    my $e;
    {
      local $@; # protect existing $@
      eval { test_repugnancy() };
      # $@ =~ /nefarious/ and die $@; # Perl 5.14 and higher only
      $@ =~ /nefarious/ and $e = $@;
    }
    die $e if defined $e
 }

There are some different considerations for each form:

=over 4

=item String eval

Since the return value of EXPR is executed as a block within the lexical
context of the current Perl program, any outer lexical variables are
visible to it, and any package variable settings or subroutine and
format definitions remain afterwards.

Note that when C<BEGIN {}> blocks are embedded inside of an eval block
the contents of the block will be executed immediately and before the rest
of the eval code is executed. You can disable this entirely by

   local ${^MAX_NESTED_EVAL_BEGIN_BLOCKS} = 0;
   eval $string;

which will cause any embedded C<BEGIN> blocks in C<$string> to throw an
exception.

=over 4

=item Under the L<C<"unicode_eval"> feature|feature/The 'unicode_eval' and 'evalbytes' features>

If this feature is enabled (which is the default under a C<use 5.16> or
higher declaration), Perl assumes that EXPR is a character string.
Any S<C<use utf8>> or S<C<no utf8>> declarations within
the string thus have no effect. Source filters are forbidden as well.
(C<unicode_strings>, however, can appear within the string.)

See also the L<C<evalbytes>|/evalbytes EXPR> operator, which works properly
with source filters.

=item Outside the C<"unicode_eval"> feature

In this case, the behavior is problematic and is not so easily
described.  Here are two bugs that cannot easily be fixed without
breaking existing programs:

=over 4

=item *

Perl's internal storage of EXPR affects the behavior of the executed code.
For example:

    my $v = eval "use utf8; '$expr'";

If $expr is C<"\xc4\x80"> (U+0100 in UTF-8), then the value stored in C<$v>
will depend on whether Perl stores $expr "upgraded" (cf. L<utf8>) or
not:

=over

=item * If upgraded, C<$v> will be C<"\xc4\x80"> (i.e., the
C<use utf8> has no effect.)

=item * If non-upgraded, C<$v> will be C<"\x{100}">.

=back

This is undesirable since being
upgraded or not should not affect a string's behavior.

=item *

Source filters activated within C<eval> leak out into whichever file
scope is currently being compiled.  To give an example with the CPAN module
L<Semi::Semicolons>:

 BEGIN { eval "use Semi::Semicolons; # not filtered" }
 # filtered here!

L<C<evalbytes>|/evalbytes EXPR> fixes that to work the way one would
expect:

 use feature "evalbytes";
 BEGIN { evalbytes "use Semi::Semicolons; # filtered" }
 # not filtered

=back

=back

Problems can arise if the string expands a scalar containing a floating
point number.  That scalar can expand to letters, such as C<"NaN"> or
C<"Infinity">; or, within the scope of a L<C<use locale>|locale>, the
decimal point character may be something other than a dot (such as a
comma).  None of these are likely to parse as you are likely expecting.

You should be especially careful to remember what's being looked at
when:

    eval $x;        # CASE 1
    eval "$x";      # CASE 2

    eval '$x';      # CASE 3
    eval { $x };    # CASE 4

    eval "\$$x++";  # CASE 5
    $$x++;          # CASE 6

Cases 1 and 2 above behave identically: they run the code contained in
the variable $x.  (Although case 2 has misleading double quotes making
the reader wonder what else might be happening (nothing is).)  Cases 3
and 4 likewise behave in the same way: they run the code C<'$x'>, which
does nothing but return the value of $x.  (Case 4 is preferred for
purely visual reasons, but it also has the advantage of compiling at
compile-time instead of at run-time.)  Case 5 is a place where
normally you I<would> like to use double quotes, except that in this
particular situation, you can just use symbolic references instead, as
in case 6.

An C<eval ''> executed within a subroutine defined
in the C<DB> package doesn't see the usual
surrounding lexical scope, but rather the scope of the first non-DB piece
of code that called it.  You don't normally need to worry about this unless
you are writing a Perl debugger.

The final semicolon, if any, may be omitted from the value of EXPR.

=item Block eval

If the code to be executed doesn't vary, you may use the eval-BLOCK
form to trap run-time errors without incurring the penalty of
recompiling each time.  The error, if any, is still returned in
L<C<$@>|perlvar/$@>.
Examples:

    # make divide-by-zero nonfatal
    eval { $answer = $x / $y; }; warn $@ if $@;

    # same thing, but less efficient
    eval '$answer = $x / $y'; warn $@ if $@;

    # a compile-time error
    eval { $answer = }; # WRONG

    # a run-time error
    eval '$answer =';   # sets $@

If you want to trap errors when loading an XS module, some problems with
the binary interface (such as Perl version skew) may be fatal even with
C<eval> unless C<$ENV{PERL_DL_NONLAZY}> is set.  See
L<perlrun|perlrun/PERL_DL_NONLAZY>.

Using the C<eval {}> form as an exception trap in libraries does have some
issues.  Due to the current arguably broken state of C<__DIE__> hooks, you
may wish not to trigger any C<__DIE__> hooks that user code may have installed.
You can use the C<local $SIG{__DIE__}> construct for this purpose,
as this example shows:

    # a private exception trap for divide-by-zero
    eval { local $SIG{'__DIE__'}; $answer = $x / $y; };
    warn $@ if $@;

This is especially significant, given that C<__DIE__> hooks can call
L<C<die>|/die LIST> again, which has the effect of changing their error
messages:

    # __DIE__ hooks may modify error messages
    {
       local $SIG{'__DIE__'} =
              sub { (my $x = $_[0]) =~ s/foo/bar/g; die $x };
       eval { die "foo lives here" };
       print $@ if $@;                # prints "bar lives here"
    }

Because this promotes action at a distance, this counterintuitive behavior
may be fixed in a future release.

C<eval BLOCK> does I<not> count as a loop, so the loop control statements
L<C<next>|/next LABEL>, L<C<last>|/last LABEL>, or
L<C<redo>|/redo LABEL> cannot be used to leave or restart the block.

The final semicolon, if any, may be omitted from within the BLOCK.

=back

=item evalbytes EXPR
X<evalbytes>

=item evalbytes

=for Pod::Functions +evalbytes similar to string eval, but intend to parse a bytestream

This function is similar to a L<string eval|/eval EXPR>, except it
always parses its argument (or L<C<$_>|perlvar/$_> if EXPR is omitted)
as a byte string. If the string contains any code points above 255, then
it cannot be a byte string, and the C<evalbytes> will fail with the error
stored in C<$@>.

C<use utf8> and C<no utf8> within the string have their usual effect.

Source filters activated within the evaluated code apply to the code
itself.

L<C<evalbytes>|/evalbytes EXPR> is available starting in Perl v5.16.  To
access it, you must say C<CORE::evalbytes>, but you can omit the
C<CORE::> if the
L<C<"evalbytes"> feature|feature/The 'unicode_eval' and 'evalbytes' features>
is enabled.  This is enabled automatically with a C<use v5.16> (or
higher) declaration in the current scope.

=item exec LIST
X<exec> X<execute>

=item exec PROGRAM LIST
