                 'is said to be a descriptor.\n'
                 '\n'
                 'The default behavior for attribute access is to get, set, or '
                 'delete\n'
                 'the attribute from an object’s dictionary. For instance, '
                 '"a.x" has a\n'
                 'lookup chain starting with "a.__dict__[\'x\']", then\n'
                 '"type(a).__dict__[\'x\']", and continuing through the base '
                 'classes of\n'
                 '"type(a)" excluding metaclasses.\n'
                 '\n'
                 'However, if the looked-up value is an object defining one of '
                 'the\n'
                 'descriptor methods, then Python may override the default '
                 'behavior and\n'
                 'invoke the descriptor method instead.  Where this occurs in '
                 'the\n'
                 'precedence chain depends on which descriptor methods were '
                 'defined and\n'
                 'how they were called.\n'
                 '\n'
                 'The starting point for descriptor invocation is a binding, '
                 '"a.x". How\n'
                 'the arguments are assembled depends on "a":\n'
                 '\n'
                 'Direct Call\n'
                 '   The simplest and least common call is when user code '
                 'directly\n'
                 '   invokes a descriptor method:    "x.__get__(a)".\n'
                 '\n'
                 'Instance Binding\n'
                 '   If binding to an object instance, "a.x" is transformed '
                 'into the\n'
                 '   call: "type(a).__dict__[\'x\'].__get__(a, type(a))".\n'
                 '\n'
                 'Class Binding\n'
                 '   If binding to a class, "A.x" is transformed into the '
                 'call:\n'
                 '   "A.__dict__[\'x\'].__get__(None, A)".\n'
                 '\n'
                 'Super Binding\n'
                 '   A dotted lookup such as "super(A, a).x" searches\n'
                 '   "a.__class__.__mro__" for a base class "B" following "A" '
                 'and then\n'
                 '   returns "B.__dict__[\'x\'].__get__(a, A)".  If not a '
                 'descriptor, "x"\n'
                 '   is returned unchanged.\n'
                 '\n'
                 'For instance bindings, the precedence of descriptor '
                 'invocation depends\n'
                 'on which descriptor methods are defined.  A descriptor can '
                 'define any\n'
                 'combination of "__get__()", "__set__()" and "__delete__()".  '
                 'If it\n'
                 'does not define "__get__()", then accessing the attribute '
                 'will return\n'
                 'the descriptor object itself unless there is a value in the '
                 'object’s\n'
                 'instance dictionary.  If the descriptor defines "__set__()" '
                 'and/or\n'
                 '"__delete__()", it is a data descriptor; if it defines '
                 'neither, it is\n'
                 'a non-data descriptor.  Normally, data descriptors define '
                 'both\n'
                 '"__get__()" and "__set__()", while non-data descriptors have '
                 'just the\n'
                 '"__get__()" method.  Data descriptors with "__get__()" and '
                 '"__set__()"\n'
                 '(and/or "__delete__()") defined always override a '
                 'redefinition in an\n'
                 'instance dictionary.  In contrast, non-data descriptors can '
                 'be\n'
                 'overridden by instances.\n'
                 '\n'
                 'Python methods (including those decorated with '
                 '"@staticmethod" and\n'
                 '"@classmethod") are implemented as non-data descriptors.  '
                 'Accordingly,\n'
                 'instances can redefine and override methods.  This allows '
                 'individual\n'
                 'instances to acquire behaviors that differ from other '
                 'instances of the\n'
                 'same class.\n'
                 '\n'
                 'The "property()" function is implemented as a data '
                 'descriptor.\n'
                 'Accordingly, instances cannot override the behavior of a '
                 'property.\n'
                 '\n'
                 '\n'
                 '__slots__\n'
                 '---------\n'
                 '\n'
                 '*__slots__* allow us to explicitly declare data members '
                 '(like\n'
                 'properties) and deny the creation of "__dict__" and '
                 '*__weakref__*\n'
                 '(unless explicitly declared in *__slots__* or available in a '
                 'parent.)\n'
                 '\n'
                 'The space saved over using "__dict__" can be significant. '
                 'Attribute\n'
                 'lookup speed can be significantly improved as well.\n'
                 '\n'
                 'object.__slots__\n'
                 '\n'
                 '   This class variable can be assigned a string, iterable, '
                 'or sequence\n'
                 '   of strings with variable names used by instances.  '
                 '*__slots__*\n'
                 '   reserves space for the declared variables and prevents '
                 'the\n'
                 '   automatic creation of "__dict__" and *__weakref__* for '
                 'each\n'
                 '   instance.\n'
                 '\n'
                 '\n'
                 'Notes on using *__slots__*\n'
                 '~~~~~~~~~~~~~~~~~~~~~~~~~~\n'
                 '\n'
                 '* When inheriting from a class without *__slots__*, the '
                 '"__dict__" and\n'
                 '  *__weakref__* attribute of the instances will always be '
                 'accessible.\n'
                 '\n'
                 '* Without a "__dict__" variable, instances cannot be '
                 'assigned new\n'
                 '  variables not listed in the *__slots__* definition.  '
                 'Attempts to\n'
                 '  assign to an unlisted variable name raises '
                 '"AttributeError". If\n'
                 '  dynamic assignment of new variables is desired, then add\n'
                 '  "\'__dict__\'" to the sequence of strings in the '
                 '*__slots__*\n'
                 '  declaration.\n'
                 '\n'
                 '* Without a *__weakref__* variable for each instance, '
                 'classes defining\n'
                 '  *__slots__* do not support "weak references" to its '
                 'instances. If\n'
                 '  weak reference support is needed, then add '
                 '"\'__weakref__\'" to the\n'
                 '  sequence of strings in the *__slots__* declaration.\n'
                 '\n'
                 '* *__slots__* are implemented at the class level by '
                 'creating\n'
                 '  descriptors for each variable name.  As a result, class '
                 'attributes\n'
                 '  cannot be used to set default values for instance '
                 'variables defined\n'
                 '  by *__slots__*; otherwise, the class attribute would '
                 'overwrite the\n'
                 '  descriptor assignment.\n'
                 '\n'
                 '* The action of a *__slots__* declaration is not limited to '
                 'the class\n'
                 '  where it is defined.  *__slots__* declared in parents are '
                 'available\n'
                 '  in child classes. However, child subclasses will get a '
                 '"__dict__"\n'
                 '  and *__weakref__* unless they also define *__slots__* '
                 '(which should\n'
                 '  only contain names of any *additional* slots).\n'
                 '\n'
                 '* If a class defines a slot also defined in a base class, '
                 'the instance\n'
                 '  variable defined by the base class slot is inaccessible '
                 '(except by\n'
                 '  retrieving its descriptor directly from the base class). '
                 'This\n'
                 '  renders the meaning of the program undefined.  In the '
                 'future, a\n'
                 '  check may be added to prevent this.\n'
                 '\n'
                 '* Nonempty *__slots__* does not work for classes derived '
                 'from\n'
                 '  “variable-length” built-in types such as "int", "bytes" '
                 'and "tuple".\n'
                 '\n'
                 '* Any non-string *iterable* may be assigned to *__slots__*.\n'
                 '\n'
                 '* If a "dictionary" is used to assign *__slots__*, the '
                 'dictionary keys\n'
                 '  will be used as the slot names. The values of the '
                 'dictionary can be\n'
                 '  used to provide per-attribute docstrings that will be '
                 'recognised by\n'
                 '  "inspect.getdoc()" and displayed in the output of '
                 '"help()".\n'
                 '\n'
                 '* "__class__" assignment works only if both classes have the '
                 'same\n'
                 '  *__slots__*.\n'
                 '\n'
                 '* Multiple inheritance with multiple slotted parent classes '
                 'can be\n'
                 '  used, but only one parent is allowed to have attributes '
                 'created by\n'
                 '  slots (the other bases must have empty slot layouts) - '
                 'violations\n'
                 '  raise "TypeError".\n'
                 '\n'
                 '* If an *iterator* is used for *__slots__* then a '
                 '*descriptor* is\n'
                 '  created for each of the iterator’s values. However, the '
                 '*__slots__*\n'
                 '  attribute will be an empty iterator.\n'
                 '\n'
                 '\n'
                 'Customizing class creation\n'
                 '==========================\n'
                 '\n'
                 'Whenever a class inherits from another class, '
                 '"__init_subclass__()" is\n'
                 'called on the parent class. This way, it is possible to '
                 'write classes\n'
                 'which change the behavior of subclasses. This is closely '
                 'related to\n'
                 'class decorators, but where class decorators only affect the '
                 'specific\n'
                 'class they’re applied to, "__init_subclass__" solely applies '
                 'to future\n'
                 'subclasses of the class defining the method.\n'
                 '\n'
                 'classmethod object.__init_subclass__(cls)\n'
                 '\n'
                 '   This method is called whenever the containing class is '
                 'subclassed.\n'
                 '   *cls* is then the new subclass. If defined as a normal '
                 'instance\n'
                 '   method, this method is implicitly converted to a class '
                 'method.\n'
                 '\n'
                 '   Keyword arguments which are given to a new class are '
                 'passed to the\n'
                 '   parent’s class "__init_subclass__". For compatibility '
                 'with other\n'
                 '   classes using "__init_subclass__", one should take out '
                 'the needed\n'
                 '   keyword arguments and pass the others over to the base '
                 'class, as\n'
                 '   in:\n'
                 '\n'
                 '      class Philosopher:\n'
                 '          def __init_subclass__(cls, /, default_name, '
                 '**kwargs):\n'
                 '              super().__init_subclass__(**kwargs)\n'
                 '              cls.default_name = default_name\n'
                 '\n'
                 '      class AustralianPhilosopher(Philosopher, '
                 'default_name="Bruce"):\n'
                 '          pass\n'
                 '\n'
                 '   The default implementation "object.__init_subclass__" '
                 'does nothing,\n'
                 '   but raises an error if it is called with any arguments.\n'
                 '\n'
                 '   Note:\n'
                 '\n'
                 '     The metaclass hint "metaclass" is consumed by the rest '
                 'of the\n'
                 '     type machinery, and is never passed to '
                 '"__init_subclass__"\n'
                 '     implementations. The actual metaclass (rather than the '
                 'explicit\n'
                 '     hint) can be accessed as "type(cls)".\n'
                 '\n'
                 '   New in version 3.6.\n'
                 '\n'
                 'When a class is created, "type.__new__()" scans the class '
                 'variables\n'
                 'and makes callbacks to those with a "__set_name__()" hook.\n'
                 '\n'
                 'object.__set_name__(self, owner, name)\n'
                 '\n'
                 '   Automatically called at the time the owning class *owner* '
                 'is\n'
                 '   created. The object has been assigned to *name* in that '
                 'class:\n'
                 '\n'
                 '      class A:\n'
                 '          x = C()  # Automatically calls: x.__set_name__(A, '
                 "'x')\n"
                 '\n'
                 '   If the class variable is assigned after the class is '
                 'created,\n'
                 '   "__set_name__()" will not be called automatically. If '
                 'needed,\n'
                 '   "__set_name__()" can be called directly:\n'
                 '\n'
                 '      class A:\n'
                 '         pass\n'
                 '\n'
                 '      c = C()\n'
                 '      A.x = c                  # The hook is not called\n'
                 "      c.__set_name__(A, 'x')   # Manually invoke the hook\n"
                 '\n'
                 '   See Creating the class object for more details.\n'
                 '\n'
                 '   New in version 3.6.\n'
                 '\n'
                 '\n'
                 'Metaclasses\n'
                 '-----------\n'
                 '\n'
                 'By default, classes are constructed using "type()". The '
                 'class body is\n'
                 'executed in a new namespace and the class name is bound '
                 'locally to the\n'
                 'result of "type(name, bases, namespace)".\n'
                 '\n'
                 'The class creation process can be customized by passing the\n'
                 '"metaclass" keyword argument in the class definition line, '
                 'or by\n'
                 'inheriting from an existing class that included such an '
                 'argument. In\n'
                 'the following example, both "MyClass" and "MySubclass" are '
                 'instances\n'
                 'of "Meta":\n'
                 '\n'
                 '   class Meta(type):\n'
                 '       pass\n'
                 '\n'
                 '   class MyClass(metaclass=Meta):\n'
                 '       pass\n'
                 '\n'
                 '   class MySubclass(MyClass):\n'
                 '       pass\n'
                 '\n'
                 'Any other keyword arguments that are specified in the class '
                 'definition\n'
                 'are passed through to all metaclass operations described '
                 'below.\n'
                 '\n'
                 'When a class definition is executed, the following steps '
                 'occur:\n'
                 '\n'
                 '* MRO entries are resolved;\n'
                 '\n'
                 '* the appropriate metaclass is determined;\n'
                 '\n'
                 '* the class namespace is prepared;\n'
                 '\n'
                 '* the class body is executed;\n'
                 '\n'
                 '* the class object is created.\n'
                 '\n'
                 '\n'
                 'Resolving MRO entries\n'
                 '---------------------\n'
                 '\n'
                 'If a base that appears in class definition is not an '
                 'instance of\n'
                 '"type", then an "__mro_entries__" method is searched on it. '
                 'If found,\n'
                 'it is called with the original bases tuple. This method must '
                 'return a\n'
                 'tuple of classes that will be used instead of this base. The '
                 'tuple may\n'
                 'be empty, in such case the original base is ignored.\n'
                 '\n'
                 'See also:\n'
                 '\n'
                 '  **PEP 560** - Core support for typing module and generic '
                 'types\n'
                 '\n'
                 '\n'
                 'Determining the appropriate metaclass\n'
                 '-------------------------------------\n'
                 '\n'
                 'The appropriate metaclass for a class definition is '
                 'determined as\n'
                 'follows:\n'
                 '\n'
                 '* if no bases and no explicit metaclass are given, then '
                 '"type()" is\n'
                 '  used;\n'
                 '\n'
                 '* if an explicit metaclass is given and it is *not* an '
                 'instance of\n'
                 '  "type()", then it is used directly as the metaclass;\n'
                 '\n'
                 '* if an instance of "type()" is given as the explicit '
                 'metaclass, or\n'
                 '  bases are defined, then the most derived metaclass is '
                 'used.\n'
                 '\n'
                 'The most derived metaclass is selected from the explicitly '
                 'specified\n'
                 'metaclass (if any) and the metaclasses (i.e. "type(cls)") of '
                 'all\n'
                 'specified base classes. The most derived metaclass is one '
                 'which is a\n'
                 'subtype of *all* of these candidate metaclasses. If none of '
                 'the\n'
                 'candidate metaclasses meets that criterion, then the class '
                 'definition\n'
                 'will fail with "TypeError".\n'
                 '\n'
                 '\n'
                 'Preparing the class namespace\n'
                 '-----------------------------\n'
                 '\n'
                 'Once the appropriate metaclass has been identified, then the '
                 'class\n'
                 'namespace is prepared. If the metaclass has a "__prepare__" '
                 'attribute,\n'
                 'it is called as "namespace = metaclass.__prepare__(name, '
                 'bases,\n'
                 '**kwds)" (where the additional keyword arguments, if any, '
                 'come from\n'
                 'the class definition). The "__prepare__" method should be '
                 'implemented\n'
                 'as a "classmethod". The namespace returned by "__prepare__" '
                 'is passed\n'
                 'in to "__new__", but when the final class object is created '
                 'the\n'
                 'namespace is copied into a new "dict".\n'
                 '\n'
                 'If the metaclass has no "__prepare__" attribute, then the '
                 'class\n'
                 'namespace is initialised as an empty ordered mapping.\n'
                 '\n'
                 'See also:\n'
                 '\n'
                 '  **PEP 3115** - Metaclasses in Python 3000\n'
                 '     Introduced the "__prepare__" namespace hook\n'
                 '\n'
                 '\n'
                 'Executing the class body\n'
                 '------------------------\n'
                 '\n'
                 'The class body is executed (approximately) as "exec(body, '
                 'globals(),\n'
                 'namespace)". The key difference from a normal call to '
                 '"exec()" is that\n'
                 'lexical scoping allows the class body (including any '
                 'methods) to\n'
                 'reference names from the current and outer scopes when the '
                 'class\n'
                 'definition occurs inside a function.\n'
                 '\n'
                 'However, even when the class definition occurs inside the '
                 'function,\n'
                 'methods defined inside the class still cannot see names '
                 'defined at the\n'
                 'class scope. Class variables must be accessed through the '
                 'first\n'
                 'parameter of instance or class methods, or through the '
                 'implicit\n'
                 'lexically scoped "__class__" reference described in the next '
                 'section.\n'
                 '\n'
                 '\n'
                 'Creating the class object\n'
                 '-------------------------\n'
                 '\n'
                 'Once the class namespace has been populated by executing the '
                 'class\n'
                 'body, the class object is created by calling '
                 '"metaclass(name, bases,\n'
                 'namespace, **kwds)" (the additional keywords passed here are '
                 'the same\n'
                 'as those passed to "__prepare__").\n'
                 '\n'
                 'This class object is the one that will be referenced by the '
                 'zero-\n'
                 'argument form of "super()". "__class__" is an implicit '
                 'closure\n'
                 'reference created by the compiler if any methods in a class '
                 'body refer\n'
                 'to either "__class__" or "super". This allows the zero '
                 'argument form\n'
                 'of "super()" to correctly identify the class being defined '
                 'based on\n'
                 'lexical scoping, while the class or instance that was used '
                 'to make the\n'
                 'current call is identified based on the first argument '
                 'passed to the\n'
                 'method.\n'
                 '\n'
                 '**CPython implementation detail:** In CPython 3.6 and later, '
                 'the\n'
                 '"__class__" cell is passed to the metaclass as a '
                 '"__classcell__" entry\n'
                 'in the class namespace. If present, this must be propagated '
                 'up to the\n'
                 '"type.__new__" call in order for the class to be '
                 'initialised\n'
                 'correctly. Failing to do so will result in a "RuntimeError" '
                 'in Python\n'
                 '3.8.\n'
                 '\n'
                 'When using the default metaclass "type", or any metaclass '
                 'that\n'
                 'ultimately calls "type.__new__", the following additional\n'
                 'customization steps are invoked after creating the class '
                 'object:\n'
                 '\n'
                 '1. The "type.__new__" method collects all of the attributes '
                 'in the\n'
                 '   class namespace that define a "__set_name__()" method;\n'
                 '\n'
                 '2. Those "__set_name__" methods are called with the class '
                 'being\n'
                 '   defined and the assigned name of that particular '
                 'attribute;\n'
                 '\n'
                 '3. The "__init_subclass__()" hook is called on the immediate '
                 'parent of\n'
                 '   the new class in its method resolution order.\n'
                 '\n'
                 'After the class object is created, it is passed to the '
                 'class\n'
                 'decorators included in the class definition (if any) and the '
                 'resulting\n'
                 'object is bound in the local namespace as the defined '
                 'class.\n'
                 '\n'
                 'When a new class is created by "type.__new__", the object '
                 'provided as\n'
                 'the namespace parameter is copied to a new ordered mapping '
                 'and the\n'
                 'original object is discarded. The new copy is wrapped in a '
                 'read-only\n'
                 'proxy, which becomes the "__dict__" attribute of the class '
                 'object.\n'
                 '\n'
                 'See also:\n'
                 '\n'
                 '  **PEP 3135** - New super\n'
                 '     Describes the implicit "__class__" closure reference\n'
                 '\n'
                 '\n'
                 'Uses for metaclasses\n'
                 '--------------------\n'
                 '\n'
                 'The potential uses for metaclasses are boundless. Some ideas '
                 'that have\n'
                 'been explored include enum, logging, interface checking, '
                 'automatic\n'
                 'delegation, automatic property creation, proxies, '
                 'frameworks, and\n'
                 'automatic resource locking/synchronization.\n'
                 '\n'
                 '\n'
                 'Customizing instance and subclass checks\n'
                 '========================================\n'
                 '\n'
                 'The following methods are used to override the default '
                 'behavior of the\n'
                 '"isinstance()" and "issubclass()" built-in functions.\n'
                 '\n'
                 'In particular, the metaclass "abc.ABCMeta" implements these '
                 'methods in\n'
                 'order to allow the addition of Abstract Base Classes (ABCs) '
                 'as\n'
                 '“virtual base classes” to any class or type (including '
                 'built-in\n'
                 'types), including other ABCs.\n'
                 '\n'
                 'class.__instancecheck__(self, instance)\n'
                 '\n'
                 '   Return true if *instance* should be considered a (direct '
                 'or\n'
                 '   indirect) instance of *class*. If defined, called to '
                 'implement\n'
                 '   "isinstance(instance, class)".\n'
                 '\n'
                 'class.__subclasscheck__(self, subclass)\n'
                 '\n'
                 '   Return true if *subclass* should be considered a (direct '
                 'or\n'
                 '   indirect) subclass of *class*.  If defined, called to '
                 'implement\n'
                 '   "issubclass(subclass, class)".\n'
                 '\n'
                 'Note that these methods are looked up on the type '
                 '(metaclass) of a\n'
                 'class.  They cannot be defined as class methods in the '
                 'actual class.\n'
                 'This is consistent with the lookup of special methods that '
                 'are called\n'
                 'on instances, only in this case the instance is itself a '
                 'class.\n'
                 '\n'
                 'See also:\n'
                 '\n'
                 '  **PEP 3119** - Introducing Abstract Base Classes\n'
                 '     Includes the specification for customizing '
                 '"isinstance()" and\n'
                 '     "issubclass()" behavior through "__instancecheck__()" '
                 'and\n'
                 '     "__subclasscheck__()", with motivation for this '
                 'functionality in\n'
                 '     the context of adding Abstract Base Classes (see the '
                 '"abc"\n'
                 '     module) to the language.\n'
                 '\n'
                 '\n'
                 'Emulating generic types\n'
                 '=======================\n'
                 '\n'
                 'When using *type annotations*, it is often useful to '
                 '*parameterize* a\n'
                 '*generic type* using Python’s square-brackets notation. For '
                 'example,\n'
                 'the annotation "list[int]" might be used to signify a "list" '
                 'in which\n'
                 'all the elements are of type "int".\n'
                 '\n'
                 'See also:\n'
                 '\n'
                 '  **PEP 484** - Type Hints\n'
                 '     Introducing Python’s framework for type annotations\n'
                 '\n'
                 '  Generic Alias Types\n'
                 '     Documentation for objects representing parameterized '
                 'generic\n'
                 '     classes\n'
                 '\n'
                 '  Generics, user-defined generics and "typing.Generic"\n'
                 '     Documentation on how to implement generic classes that '
                 'can be\n'
                 '     parameterized at runtime and understood by static '
                 'type-checkers.\n'
                 '\n'
                 'A class can *generally* only be parameterized if it defines '
                 'the\n'
                 'special class method "__class_getitem__()".\n'
                 '\n'
                 'classmethod object.__class_getitem__(cls, key)\n'
                 '\n'
                 '   Return an object representing the specialization of a '
                 'generic class\n'
                 '   by type arguments found in *key*.\n'
                 '\n'
                 '   When defined on a class, "__class_getitem__()" is '
                 'automatically a\n'
                 '   class method. As such, there is no need for it to be '
                 'decorated with\n'
                 '   "@classmethod" when it is defined.\n'
                 '\n'
                 '\n'
                 'The purpose of *__class_getitem__*\n'
                 '----------------------------------\n'
                 '\n'
                 'The purpose of "__class_getitem__()" is to allow runtime\n'
                 'parameterization of standard-library generic classes in '
                 'order to more\n'
                 'easily apply *type hints* to these classes.\n'
                 '\n'
                 'To implement custom generic classes that can be '
                 'parameterized at\n'
                 'runtime and understood by static type-checkers, users should '
                 'either\n'
                 'inherit from a standard library class that already '
                 'implements\n'
                 '"__class_getitem__()", or inherit from "typing.Generic", '
                 'which has its\n'
                 'own implementation of "__class_getitem__()".\n'
                 '\n'
                 'Custom implementations of "__class_getitem__()" on classes '
                 'defined\n'
                 'outside of the standard library may not be understood by '
                 'third-party\n'
                 'type-checkers such as mypy. Using "__class_getitem__()" on '
                 'any class\n'
                 'for purposes other than type hinting is discouraged.\n'
                 '\n'
                 '\n'
                 '*__class_getitem__* versus *__getitem__*\n'
                 '----------------------------------------\n'
                 '\n'
                 'Usually, the subscription of an object using square brackets '
                 'will call\n'
                 'the "__getitem__()" instance method defined on the object’s '
                 'class.\n'
                 'However, if the object being subscribed is itself a class, '
                 'the class\n'
                 'method "__class_getitem__()" may be called instead.\n'
                 '"__class_getitem__()" should return a GenericAlias object if '
                 'it is\n'
                 'properly defined.\n'
                 '\n'
                 'Presented with the *expression* "obj[x]", the Python '
                 'interpreter\n'
                 'follows something like the following process to decide '
                 'whether\n'
                 '"__getitem__()" or "__class_getitem__()" should be called:\n'
                 '\n'
                 '   from inspect import isclass\n'
                 '\n'
                 '   def subscribe(obj, x):\n'
                 '       """Return the result of the expression \'obj[x]\'"""\n'
                 '\n'
                 '       class_of_obj = type(obj)\n'
                 '\n'
                 '       # If the class of obj defines __getitem__,\n'
                 '       # call class_of_obj.__getitem__(obj, x)\n'
                 "       if hasattr(class_of_obj, '__getitem__'):\n"
                 '           return class_of_obj.__getitem__(obj, x)\n'
                 '\n'
                 '       # Else, if obj is a class and defines '
                 '__class_getitem__,\n'
                 '       # call obj.__class_getitem__(x)\n'
                 '       elif isclass(obj) and hasattr(obj, '
                 "'__class_getitem__'):\n"
                 '           return obj.__class_getitem__(x)\n'
                 '\n'
                 '       # Else, raise an exception\n'
                 '       else:\n'
                 '           raise TypeError(\n'
                 '               f"\'{class_of_obj.__name__}\' object is not '
                 'subscriptable"\n'
                 '           )\n'
                 '\n'
                 'In Python, all classes are themselves instances of other '
                 'classes. The\n'
                 'class of a class is known as that class’s *metaclass*, and '
                 'most\n'
                 'classes have the "type" class as their metaclass. "type" '
                 'does not\n'
                 'define "__getitem__()", meaning that expressions such as '
                 '"list[int]",\n'
                 '"dict[str, float]" and "tuple[str, bytes]" all result in\n'
                 '"__class_getitem__()" being called:\n'
                 '\n'
                 '   >>> # list has class "type" as its metaclass, like most '
                 'classes:\n'
                 '   >>> type(list)\n'
                 "   <class 'type'>\n"
                 '   >>> type(dict) == type(list) == type(tuple) == type(str) '
                 '== type(bytes)\n'
                 '   True\n'
                 '   >>> # "list[int]" calls "list.__class_getitem__(int)"\n'
                 '   >>> list[int]\n'
                 '   list[int]\n'
                 '   >>> # list.__class_getitem__ returns a GenericAlias '
                 'object:\n'
                 '   >>> type(list[int])\n'
                 "   <class 'types.GenericAlias'>\n"
                 '\n'
                 'However, if a class has a custom metaclass that defines\n'
                 '"__getitem__()", subscribing the class may result in '
                 'different\n'
                 'behaviour. An example of this can be found in the "enum" '
                 'module:\n'
                 '\n'
                 '   >>> from enum import Enum\n'
                 '   >>> class Menu(Enum):\n'
                 '   ...     """A breakfast menu"""\n'
                 "   ...     SPAM = 'spam'\n"
                 "   ...     BACON = 'bacon'\n"
                 '   ...\n'
                 '   >>> # Enum classes have a custom metaclass:\n'
                 '   >>> type(Menu)\n'
                 "   <class 'enum.EnumMeta'>\n"
                 '   >>> # EnumMeta defines __getitem__,\n'
                 '   >>> # so __class_getitem__ is not called,\n'
                 '   >>> # and the result is not a GenericAlias object:\n'
                 "   >>> Menu['SPAM']\n"
                 "   <Menu.SPAM: 'spam'>\n"
                 "   >>> type(Menu['SPAM'])\n"
                 "   <enum 'Menu'>\n"
                 '\n'
                 'See also:\n'
                 '\n'
                 '  **PEP 560** - Core Support for typing module and generic '
                 'types\n'
                 '     Introducing "__class_getitem__()", and outlining when '
                 'a\n'
                 '     subscription results in "__class_getitem__()" being '
                 'called\n'
                 '     instead of "__getitem__()"\n'
                 '\n'
                 '\n'
                 'Emulating callable objects\n'
                 '==========================\n'
                 '\n'
                 'object.__call__(self[, args...])\n'
                 '\n'
                 '   Called when the instance is “called” as a function; if '
                 'this method\n'
                 '   is defined, "x(arg1, arg2, ...)" roughly translates to\n'
                 '   "type(x).__call__(x, arg1, ...)".\n'
                 '\n'
                 '\n'
                 'Emulating container types\n'
                 '=========================\n'
                 '\n'
                 'The following methods can be defined to implement container '
                 'objects.\n'
                 'Containers usually are *sequences* (such as "lists" or '
                 '"tuples") or\n'
                 '*mappings* (like "dictionaries"), but can represent other '
                 'containers\n'
                 'as well.  The first set of methods is used either to emulate '
                 'a\n'
                 'sequence or to emulate a mapping; the difference is that for '
                 'a\n'
                 'sequence, the allowable keys should be the integers *k* for '
                 'which "0\n'
                 '<= k < N" where *N* is the length of the sequence, or '
                 '"slice" objects,\n'
                 'which define a range of items.  It is also recommended that '
                 'mappings\n'
                 'provide the methods "keys()", "values()", "items()", '
                 '"get()",\n'
                 '"clear()", "setdefault()", "pop()", "popitem()", "copy()", '
                 'and\n'
                 '"update()" behaving similar to those for Python’s standard\n'
                 '"dictionary" objects.  The "collections.abc" module provides '
                 'a\n'
                 '"MutableMapping" *abstract base class* to help create those '
                 'methods\n'
                 'from a base set of "__getitem__()", "__setitem__()", '
                 '"__delitem__()",\n'
                 'and "keys()". Mutable sequences should provide methods '
                 '"append()",\n'
                 '"count()", "index()", "extend()", "insert()", "pop()", '
                 '"remove()",\n'
                 '"reverse()" and "sort()", like Python standard "list" '
                 'objects.\n'
                 'Finally, sequence types should implement addition (meaning\n'
                 'concatenation) and multiplication (meaning repetition) by '
                 'defining the\n'
                 'methods "__add__()", "__radd__()", "__iadd__()", '
                 '"__mul__()",\n'
                 '"__rmul__()" and "__imul__()" described below; they should '
                 'not define\n'
                 'other numerical operators.  It is recommended that both '
                 'mappings and\n'
                 'sequences implement the "__contains__()" method to allow '
                 'efficient use\n'
                 'of the "in" operator; for mappings, "in" should search the '
                 'mapping’s\n'
                 'keys; for sequences, it should search through the values.  '
                 'It is\n'
                 'further recommended that both mappings and sequences '
                 'implement the\n'
                 '"__iter__()" method to allow efficient iteration through '
                 'the\n'
                 'container; for mappings, "__iter__()" should iterate through '
                 'the\n'
                 'object’s keys; for sequences, it should iterate through the '
                 'values.\n'
                 '\n'
                 'object.__len__(self)\n'
                 '\n'
                 '   Called to implement the built-in function "len()".  '
                 'Should return\n'
                 '   the length of the object, an integer ">=" 0.  Also, an '
                 'object that\n'
                 '   doesn’t define a "__bool__()" method and whose '
                 '"__len__()" method\n'
                 '   returns zero is considered to be false in a Boolean '
                 'context.\n'
                 '\n'
                 '   **CPython implementation detail:** In CPython, the length '
                 'is\n'
                 '   required to be at most "sys.maxsize". If the length is '
                 'larger than\n'
                 '   "sys.maxsize" some features (such as "len()") may raise\n'
                 '   "OverflowError".  To prevent raising "OverflowError" by '
                 'truth value\n'
                 '   testing, an object must define a "__bool__()" method.\n'
                 '\n'
                 'object.__length_hint__(self)\n'
                 '\n'
                 '   Called to implement "operator.length_hint()". Should '
                 'return an\n'
                 '   estimated length for the object (which may be greater or '
                 'less than\n'
                 '   the actual length). The length must be an integer ">=" 0. '
                 'The\n'
                 '   return value may also be "NotImplemented", which is '
                 'treated the\n'
                 '   same as if the "__length_hint__" method didn’t exist at '
                 'all. This\n'
                 '   method is purely an optimization and is never required '
                 'for\n'
                 '   correctness.\n'
                 '\n'
                 '   New in version 3.4.\n'
                 '\n'
                 'Note:\n'
                 '\n'
                 '  Slicing is done exclusively with the following three '
                 'methods.  A\n'
                 '  call like\n'
                 '\n'
                 '     a[1:2] = b\n'
                 '\n'
                 '  is translated to\n'
                 '\n'
                 '     a[slice(1, 2, None)] = b\n'
                 '\n'
                 '  and so forth.  Missing slice items are always filled in '
                 'with "None".\n'
                 '\n'
                 'object.__getitem__(self, key)\n'
                 '\n'
                 '   Called to implement evaluation of "self[key]". For '
                 '*sequence*\n'
                 '   types, the accepted keys should be integers and slice '
                 'objects.\n'
                 '   Note that the special interpretation of negative indexes '
                 '(if the\n'
                 '   class wishes to emulate a *sequence* type) is up to the\n'
                 '   "__getitem__()" method. If *key* is of an inappropriate '
                 'type,\n'
                 '   "TypeError" may be raised; if of a value outside the set '
                 'of indexes\n'
                 '   for the sequence (after any special interpretation of '
                 'negative\n'
                 '   values), "IndexError" should be raised. For *mapping* '
                 'types, if\n'
                 '   *key* is missing (not in the container), "KeyError" '
                 'should be\n'
                 '   raised.\n'
                 '\n'
                 '   Note:\n'
                 '\n'
                 '     "for" loops expect that an "IndexError" will be raised '
                 'for\n'
                 '     illegal indexes to allow proper detection of the end of '
                 'the\n'
                 '     sequence.\n'
                 '\n'
                 '   Note:\n'
                 '\n'
                 '     When subscripting a *class*, the special class method\n'
                 '     "__class_getitem__()" may be called instead of '
                 '"__getitem__()".\n'
                 '     See __class_getitem__ versus __getitem__ for more '
                 'details.\n'
                 '\n'
                 'object.__setitem__(self, key, value)\n'
                 '\n'
                 '   Called to implement assignment to "self[key]".  Same note '
                 'as for\n'
                 '   "__getitem__()".  This should only be implemented for '
                 'mappings if\n'
                 '   the objects support changes to the values for keys, or if '
                 'new keys\n'
                 '   can be added, or for sequences if elements can be '
                 'replaced.  The\n'
                 '   same exceptions should be raised for improper *key* '
                 'values as for\n'
                 '   the "__getitem__()" method.\n'
                 '\n'
                 'object.__delitem__(self, key)\n'
                 '\n'
                 '   Called to implement deletion of "self[key]".  Same note '
                 'as for\n'
                 '   "__getitem__()".  This should only be implemented for '
                 'mappings if\n'
                 '   the objects support removal of keys, or for sequences if '
                 'elements\n'
                 '   can be removed from the sequence.  The same exceptions '
                 'should be\n'
                 '   raised for improper *key* values as for the '
                 '"__getitem__()" method.\n'
                 '\n'
                 'object.__missing__(self, key)\n'
                 '\n'
                 '   Called by "dict"."__getitem__()" to implement "self[key]" '
                 'for dict\n'
                 '   subclasses when key is not in the dictionary.\n'
                 '\n'
                 'object.__iter__(self)\n'
                 '\n'
                 '   This method is called when an *iterator* is required for '
                 'a\n'
                 '   container. This method should return a new iterator '
                 'object that can\n'
                 '   iterate over all the objects in the container.  For '
                 'mappings, it\n'
                 '   should iterate over the keys of the container.\n'
                 '\n'
                 'object.__reversed__(self)\n'
                 '\n'
                 '   Called (if present) by the "reversed()" built-in to '
                 'implement\n'
                 '   reverse iteration.  It should return a new iterator '
                 'object that\n'
                 '   iterates over all the objects in the container in reverse '
                 'order.\n'
                 '\n'
                 '   If the "__reversed__()" method is not provided, the '
                 '"reversed()"\n'
                 '   built-in will fall back to using the sequence protocol '
                 '("__len__()"\n'
                 '   and "__getitem__()").  Objects that support the sequence '
                 'protocol\n'
                 '   should only provide "__reversed__()" if they can provide '
                 'an\n'
                 '   implementation that is more efficient than the one '
                 'provided by\n'
