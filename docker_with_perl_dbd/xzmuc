        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_GLOB               \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_grep(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_GREP               \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_helemexistsor(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_HELEMEXISTSOR      \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_index(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_INDEX              \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_isa(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_ISA                \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_join(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_JOIN               \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_length(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_LENGTH             \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_lfun(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_LFUN               \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_listiob(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_LISTIOB            \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_match(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_MATCH              \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_method(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_METHOD             \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_null(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_NULL               \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_open(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_OPEN               \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_prototype(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_PROTOTYPE          \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_readline(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_READLINE           \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_refassign(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_REFASSIGN          \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_repeat(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_REPEAT             \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_require(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_REQUIRE            \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_return(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_RETURN             \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_rfun(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_RFUN               \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_rvconst(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_RVCONST            \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_sassign(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_SASSIGN            \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_select(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_SELECT             \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_shift(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_SHIFT              \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_smartmatch(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_SMARTMATCH         \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_sort(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_SORT               \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_spair(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_SPAIR              \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_split(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_SPLIT              \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_stringify(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_STRINGIFY          \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_subr(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_SUBR               \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_substr(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_SUBSTR             \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_svconst(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_SVCONST            \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_tell(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_TELL               \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_trunc(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_TRUNC              \
        assert(o)

PERL_CALLCONV OP *
Perl_ck_trycatch(pTHX_ OP *o)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_CK_TRYCATCH           \
        assert(o)

#endif /* defined(PERL_IN_CLASS_C) || defined(PERL_IN_GLOBALS_C) ||
          defined(PERL_IN_OP_C)    || defined(PERL_IN_PEEP_C) */
#if defined(PERL_IN_CLASS_C) || defined(PERL_IN_OP_C)    || \
    defined(PERL_IN_PAD_C)   || defined(PERL_IN_PERLY_C) || \
    defined(PERL_IN_TOKE_C)
PERL_CALLCONV void
Perl_class_add_ADJUST(pTHX_ HV *stash, CV *cv);
# define PERL_ARGS_ASSERT_CLASS_ADD_ADJUST      \
        assert(stash); assert(cv)

PERL_CALLCONV void
Perl_class_add_field(pTHX_ HV *stash, PADNAME *pn);
# define PERL_ARGS_ASSERT_CLASS_ADD_FIELD       \
        assert(stash); assert(pn)

PERL_CALLCONV void
Perl_class_apply_attributes(pTHX_ HV *stash, OP *attrlist);
# define PERL_ARGS_ASSERT_CLASS_APPLY_ATTRIBUTES \
        assert(stash)

PERL_CALLCONV void
Perl_class_apply_field_attributes(pTHX_ PADNAME *pn, OP *attrlist);
# define PERL_ARGS_ASSERT_CLASS_APPLY_FIELD_ATTRIBUTES \
        assert(pn)

PERL_CALLCONV void
Perl_class_prepare_initfield_parse(pTHX);
# define PERL_ARGS_ASSERT_CLASS_PREPARE_INITFIELD_PARSE

PERL_CALLCONV void
Perl_class_prepare_method_parse(pTHX_ CV *cv);
# define PERL_ARGS_ASSERT_CLASS_PREPARE_METHOD_PARSE \
        assert(cv)

PERL_CALLCONV void
Perl_class_seal_stash(pTHX_ HV *stash);
# define PERL_ARGS_ASSERT_CLASS_SEAL_STASH      \
        assert(stash)

PERL_CALLCONV void
Perl_class_set_field_defop(pTHX_ PADNAME *pn, OPCODE defmode, OP *defop);
# define PERL_ARGS_ASSERT_CLASS_SET_FIELD_DEFOP \
        assert(pn); assert(defop)

PERL_CALLCONV void
Perl_class_setup_stash(pTHX_ HV *stash);
# define PERL_ARGS_ASSERT_CLASS_SETUP_STASH     \
        assert(stash)

PERL_CALLCONV OP *
Perl_class_wrap_method_body(pTHX_ OP *o);
# define PERL_ARGS_ASSERT_CLASS_WRAP_METHOD_BODY

PERL_CALLCONV void
Perl_croak_kw_unless_class(pTHX_ const char *kw);
# define PERL_ARGS_ASSERT_CROAK_KW_UNLESS_CLASS \
        assert(kw)

#endif /* defined(PERL_IN_CLASS_C) || defined(PERL_IN_OP_C)    ||
          defined(PERL_IN_PAD_C)   || defined(PERL_IN_PERLY_C) ||
          defined(PERL_IN_TOKE_C) */
#if defined(PERL_IN_DEB_C)
STATIC void
S_deb_stack_n(pTHX_ SV **stack_base, SSize_t stack_min, SSize_t stack_max, SSize_t mark_min, SSize_t mark_max, SSize_t nonrc_base);
# define PERL_ARGS_ASSERT_DEB_STACK_N           \
        assert(stack_base)

#endif
#if defined(PERL_IN_DOIO_C)
STATIC bool
S_argvout_final(pTHX_ MAGIC *mg, IO *io, bool is_explicit);
# define PERL_ARGS_ASSERT_ARGVOUT_FINAL         \
        assert(mg); assert(io)

STATIC void
S_exec_failed(pTHX_ const char *cmd, int fd, int do_report);
# define PERL_ARGS_ASSERT_EXEC_FAILED           \
        assert(cmd)

STATIC bool
S_is_fork_open(const char *name);
# define PERL_ARGS_ASSERT_IS_FORK_OPEN          \
        assert(name)

STATIC bool
S_openn_cleanup(pTHX_ GV *gv, IO *io, PerlIO *fp, char *mode, const char *oname, PerlIO *saveifp, PerlIO *saveofp, int savefd, char savetype, int writing, bool was_fdopen, const char *type, Stat_t *statbufp);
# define PERL_ARGS_ASSERT_OPENN_CLEANUP         \
        assert(gv); assert(io); assert(mode); assert(oname)

STATIC IO *
S_openn_setup(pTHX_ GV *gv, char *mode, PerlIO **saveifp, PerlIO **saveofp, int *savefd, char *savetype);
# define PERL_ARGS_ASSERT_OPENN_SETUP           \
        assert(gv); assert(mode); assert(saveifp); assert(saveofp); assert(savefd); \
        assert(savetype)

# if !defined(DOSISH)
STATIC bool
S_ingroup(pTHX_ Gid_t testgid, bool effective)
        __attribute__warn_unused_result__;
#   define PERL_ARGS_ASSERT_INGROUP

# endif
#endif /* defined(PERL_IN_DOIO_C) */
#if defined(PERL_IN_DOOP_C)
STATIC Size_t
S_do_trans_complex(pTHX_ SV * const sv, const OPtrans_map * const tbl)
        __attribute__warn_unused_result__;
# define PERL_ARGS_ASSERT_DO_TRANS_COMPLEX      \
        assert(sv); assert(tbl)

STATIC Size_t
S_do_trans_count(pTHX_ SV * const sv, const OPtrans_map * const tbl)
        __attribute__warn_unused_result__;
# define PERL_ARGS_ASSERT_DO_TRANS_COUNT        \
        assert(sv); assert(tbl)

STATIC Size_t
S_do_trans_count_invmap(pTHX_ SV * const sv, AV * const map)
        __attribute__warn_unused_result__;
# define PERL_ARGS_ASSERT_DO_TRANS_COUNT_INVMAP \
        assert(sv); assert(map)

STATIC Size_t
S_do_trans_invmap(pTHX_ SV * const sv, AV * const map)
        __attribute__warn_unused_result__;
# define PERL_ARGS_ASSERT_DO_TRANS_INVMAP       \
        assert(sv); assert(map)

STATIC Size_t
S_do_trans_simple(pTHX_ SV * const sv, const OPtrans_map * const tbl)
        __attribute__warn_unused_result__;
# define PERL_ARGS_ASSERT_DO_TRANS_SIMPLE       \
        assert(sv); assert(tbl)

#endif /* defined(PERL_IN_DOOP_C) */
#if defined(PERL_IN_DOOP_C)    || defined(PERL_IN_OP_C)        || \
    defined(PERL_IN_PP_C)      || defined(PERL_IN_REGCOMP_ANY) || \
    defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_TOKE_C)      || \
    defined(PERL_IN_UTF8_C)

PERL_CALLCONV SSize_t
Perl__invlist_search(SV * const invlist, const UV cp)
        __attribute__warn_unused_result__;
# define PERL_ARGS_ASSERT__INVLIST_SEARCH       \
        assert(invlist)

#endif /* defined(PERL_IN_DOOP_C)    || defined(PERL_IN_OP_C)        ||
          defined(PERL_IN_PP_C)      || defined(PERL_IN_REGCOMP_ANY) ||
          defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_TOKE_C)      ||
          defined(PERL_IN_UTF8_C) */
#if defined(PERL_IN_DOOP_C) || defined(PERL_IN_OP_C) || \
    defined(PERL_IN_REGCOMP_ANY)

#endif
#if defined(PERL_IN_DOOP_C)      || defined(PERL_IN_OP_C) || \
    defined(PERL_IN_REGCOMP_ANY) || defined(PERL_IN_UTF8_C)
PERL_CALLCONV SV *
Perl__add_range_to_invlist(pTHX_ SV *invlist, UV start, UV end)
        __attribute__warn_unused_result__;
# define PERL_ARGS_ASSERT__ADD_RANGE_TO_INVLIST

/* PERL_CALLCONV void
_invlist_intersection(pTHX_ SV * const a, SV * const b, SV **i); */

PERL_CALLCONV void
Perl__invlist_intersection_maybe_complement_2nd(pTHX_ SV * const a, SV * const b, const bool complement_b, SV **i);
# define PERL_ARGS_ASSERT__INVLIST_INTERSECTION_MAYBE_COMPLEMENT_2ND \
        assert(b); assert(i)

PERL_CALLCONV void
Perl__invlist_invert(pTHX_ SV * const invlist);
# define PERL_ARGS_ASSERT__INVLIST_INVERT       \
        assert(invlist)

/* PERL_CALLCONV void
_invlist_subtract(pTHX_ SV * const a, SV * const b, SV **result); */

/* PERL_CALLCONV void
_invlist_union(pTHX_ SV * const a, SV * const b, SV **output); */

PERL_CALLCONV void
Perl__invlist_union_maybe_complement_2nd(pTHX_ SV * const a, SV * const b, const bool complement_b, SV **output);
# define PERL_ARGS_ASSERT__INVLIST_UNION_MAYBE_COMPLEMENT_2ND \
        assert(b); assert(output)

PERL_CALLCONV SV *
Perl__new_invlist(pTHX_ IV initial_size)
        __attribute__warn_unused_result__;
# define PERL_ARGS_ASSERT__NEW_INVLIST

PERL_CALLCONV SV *
Perl__setup_canned_invlist(pTHX_ const STRLEN size, const UV element0, UV **other_elements_ptr)
        __attribute__warn_unused_result__;
# define PERL_ARGS_ASSERT__SETUP_CANNED_INVLIST \
        assert(other_elements_ptr)

#endif /* defined(PERL_IN_DOOP_C)      || defined(PERL_IN_OP_C) ||
          defined(PERL_IN_REGCOMP_ANY) || defined(PERL_IN_UTF8_C) */
#if defined(PERL_IN_DQUOTE_C) || defined(PERL_IN_REGCOMP_C) || \
    defined(PERL_IN_TOKE_C)
PERL_CALLCONV const char *
Perl_form_alien_digit_msg(pTHX_ const U8 which, const STRLEN valids_len, const char * const first_bad, const char * const send, const bool UTF, const bool braced)
        __attribute__warn_unused_result__;
# define PERL_ARGS_ASSERT_FORM_ALIEN_DIGIT_MSG  \
        assert(first_bad); assert(send)

PERL_CALLCONV bool
Perl_grok_bslash_c(pTHX_ const char source, U8 *result, const char **message, U32 *packed_warn)
        __attribute__warn_unused_result__;
# define PERL_ARGS_ASSERT_GROK_BSLASH_C         \
        assert(result); assert(message)

PERL_CALLCONV bool
Perl_grok_bslash_o(pTHX_ char **s, const char * const send, UV *uv, const char **message, U32 *packed_warn, const bool strict, const bool allow_UV_MAX, const bool utf8)
        __attribute__warn_unused_result__;
# define PERL_ARGS_ASSERT_GROK_BSLASH_O         \
        assert(s); assert(send); assert(uv); assert(message)

PERL_CALLCONV bool
Perl_grok_bslash_x(pTHX_ char **s, const char * const send, UV *uv, const char **message, U32 *packed_warn, const bool strict, const bool allow_UV_MAX, const bool utf8)
        __attribute__warn_unused_result__;
# define PERL_ARGS_ASSERT_GROK_BSLASH_X         \
        assert(s); assert(send); assert(uv); assert(message)

#endif /* defined(PERL_IN_DQUOTE_C) || defined(PERL_IN_REGCOMP_C) ||
          defined(PERL_IN_TOKE_C) */
#if defined(PERL_IN_DQUOTE_C) || defined(PERL_IN_REGCOMP_C) || \
    defined(PERL_IN_TOKE_C)   || defined(PERL_IN_UTF8_C)
PERL_CALLCONV const char *
Perl_form_cp_too_large_msg(pTHX_ const U8 which, const char *string, const Size_t len, const UV cp)
        __attribute__warn_unused_result__;
# define PERL_ARGS_ASSERT_FORM_CP_TOO_LARGE_MSG

#endif
#if defined(PERL_IN_DUMP_C)
STATIC CV *
S_deb_curcv(pTHX_ I32 ix);
# define PERL_ARGS_ASSERT_DEB_CURCV

STATIC void
S_debprof(pTHX_ const OP *o);
# define PERL_ARGS_ASSERT_DEBPROF               \
        assert(o)

STATIC SV *
S_pm_description(pTHX_ const PMOP *pm);
# define PERL_ARGS_ASSERT_PM_DESCRIPTION        \
        assert(pm)

STATIC UV
S_sequence_num(pTHX_ const OP *o);
# define PERL_ARGS_ASSERT_SEQUENCE_NUM

#endif /* defined(PERL_IN_DUMP_C) */
#if defined(PERL_IN_DUMP_C)  || defined(PERL_IN_HV_C) || \
    defined(PERL_IN_SCOPE_C) || defined(PERL_IN_SV_C)
PERL_CALLCONV void
Perl_hv_kill_backrefs(pTHX_ HV *hv)
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_HV_KILL_BACKREFS      \
        assert(hv)

#endif
#if defined(PERL_IN_DUMP_C) || defined(PERL_IN_OP_C) || \
    defined(PERL_IN_REGCOMP_ANY)
PERL_CALLCONV void
Perl__invlist_dump(pTHX_ PerlIO *file, I32 level, const char * const indent, SV * const invlist);
# define PERL_ARGS_ASSERT__INVLIST_DUMP         \
        assert(file); assert(indent); assert(invlist)

#endif
#if defined(PERL_IN_GV_C)
STATIC bool
S_find_default_stash(pTHX_ HV **stash, const char *name, STRLEN len, const U32 is_utf8, const I32 add, const svtype sv_type);
# define PERL_ARGS_ASSERT_FIND_DEFAULT_STASH    \
        assert(stash); assert(name)

STATIC void
S_gv_init_svtype(pTHX_ GV *gv, const svtype sv_type);
# define PERL_ARGS_ASSERT_GV_INIT_SVTYPE        \
        assert(gv)

STATIC bool
S_gv_is_in_main(pTHX_ const char *name, STRLEN len, const U32 is_utf8);
# define PERL_ARGS_ASSERT_GV_IS_IN_MAIN         \
        assert(name)

STATIC bool
S_gv_magicalize(pTHX_ GV *gv, HV *stash, const char *name, STRLEN len, const svtype sv_type);
# define PERL_ARGS_ASSERT_GV_MAGICALIZE         \
        assert(gv); assert(stash); assert(name)

STATIC void
S_gv_magicalize_isa(pTHX_ GV *gv);
# define PERL_ARGS_ASSERT_GV_MAGICALIZE_ISA     \
        assert(gv)

STATIC void
S_maybe_multimagic_gv(pTHX_ GV *gv, const char *name, const svtype sv_type);
# define PERL_ARGS_ASSERT_MAYBE_MULTIMAGIC_GV   \
        assert(gv); assert(name)

STATIC bool
S_parse_gv_stash_name(pTHX_ HV **stash, GV **gv, const char **name, STRLEN *len, const char *nambeg, STRLEN full_len, const U32 is_utf8, const I32 add);
# define PERL_ARGS_ASSERT_PARSE_GV_STASH_NAME   \
        assert(stash); assert(gv); assert(name); assert(len); assert(nambeg)

STATIC void
S_require_tie_mod(pTHX_ GV *gv, const char varname, const char *name, STRLEN len, const U32 flags);
# define PERL_ARGS_ASSERT_REQUIRE_TIE_MOD       \
        assert(gv); assert(varname); assert(name)

# if !defined(PERL_NO_INLINE_FUNCTIONS)
PERL_STATIC_INLINE GV *
S_gv_fetchmeth_internal(pTHX_ HV *stash, SV *meth, const char *name, STRLEN len, I32 level, U32 flags);
#   define PERL_ARGS_ASSERT_GV_FETCHMETH_INTERNAL

PERL_STATIC_INLINE HV *
S_gv_stashpvn_internal(pTHX_ const char *name, U32 namelen, I32 flags);
#   define PERL_ARGS_ASSERT_GV_STASHPVN_INTERNAL \
        assert(name)

# endif /* !defined(PERL_NO_INLINE_FUNCTIONS) */
#endif /* defined(PERL_IN_GV_C) */
#if defined(PERL_IN_GV_C)  || defined(PERL_IN_OP_C) || \
    defined(PERL_IN_PAD_C) || defined(PERL_IN_SV_C)
PERL_CALLCONV void
Perl_sv_add_backref(pTHX_ SV * const tsv, SV * const sv)
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_SV_ADD_BACKREF        \
        assert(tsv); assert(sv)

#endif
#if defined(PERL_IN_GV_C) || defined(PERL_IN_UNIVERSAL_C)
PERL_CALLCONV HV *
Perl_gv_stashsvpvn_cached(pTHX_ SV *namesv, const char *name, U32 namelen, I32 flags)
        __attribute__visibility__("hidden");

#endif
#if defined(PERL_IN_HV_C)
STATIC void
S_clear_placeholders(pTHX_ HV *hv, U32 items);
# define PERL_ARGS_ASSERT_CLEAR_PLACEHOLDERS    \
        assert(hv)

STATIC void
S_hsplit(pTHX_ HV *hv, STRLEN const oldsize, STRLEN newsize);
# define PERL_ARGS_ASSERT_HSPLIT                \
        assert(hv)

STATIC struct xpvhv_aux *
S_hv_auxinit(pTHX_ HV *hv);
# define PERL_ARGS_ASSERT_HV_AUXINIT            \
        assert(hv)

STATIC SV *
S_hv_delete_common(pTHX_ HV *hv, SV *keysv, const char *key, STRLEN klen, int k_flags, I32 d_flags, U32 hash);
# define PERL_ARGS_ASSERT_HV_DELETE_COMMON

STATIC SV *
S_hv_free_ent_ret(pTHX_ HE *entry);
# define PERL_ARGS_ASSERT_HV_FREE_ENT_RET       \
        assert(entry)

STATIC void
S_hv_free_entries(pTHX_ HV *hv);
# define PERL_ARGS_ASSERT_HV_FREE_ENTRIES       \
        assert(hv)

STATIC void
S_hv_magic_check(HV *hv, bool *needs_copy, bool *needs_store);
# define PERL_ARGS_ASSERT_HV_MAGIC_CHECK        \
        assert(hv); assert(needs_copy); assert(needs_store)

PERL_STATIC_NO_RET void
S_hv_notallowed(pTHX_ int flags, const char *key, I32 klen, const char *msg)
        __attribute__noreturn__;
# define PERL_ARGS_ASSERT_HV_NOTALLOWED         \
        assert(key); assert(msg)

STATIC SV *
S_refcounted_he_value(pTHX_ const struct refcounted_he *he);
# define PERL_ARGS_ASSERT_REFCOUNTED_HE_VALUE   \
        assert(he)

STATIC HEK *
S_save_hek_flags(const char *str, I32 len, U32 hash, int flags)
        __attribute__malloc__
        __attribute__warn_unused_result__;
# define PERL_ARGS_ASSERT_SAVE_HEK_FLAGS        \
        assert(str)

STATIC HEK *
S_share_hek_flags(pTHX_ const char *str, STRLEN len, U32 hash, int flags)
        __attribute__warn_unused_result__;
# define PERL_ARGS_ASSERT_SHARE_HEK_FLAGS       \
        assert(str)

STATIC void
S_unshare_hek_or_pvn(pTHX_ const HEK *hek, const char *str, I32 len, U32 hash);
# define PERL_ARGS_ASSERT_UNSHARE_HEK_OR_PVN

# if !defined(PURIFY)
STATIC HE *
S_new_he(pTHX)
        __attribute__warn_unused_result__;
#   define PERL_ARGS_ASSERT_NEW_HE

# endif
#endif /* defined(PERL_IN_HV_C) */
#if defined(PERL_IN_HV_C) || defined(PERL_IN_MG_C) || defined(PERL_IN_SV_C)
PERL_CALLCONV void
Perl_sv_kill_backrefs(pTHX_ SV * const sv, AV * const av)
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_SV_KILL_BACKREFS      \
        assert(sv)

#endif
#if defined(PERL_IN_HV_C) || defined(PERL_IN_SV_C)
PERL_CALLCONV SV *
Perl_hfree_next_entry(pTHX_ HV *hv, STRLEN *indexp)
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_HFREE_NEXT_ENTRY      \
        assert(hv); assert(indexp)

#endif
#if defined(PERL_IN_LOCALE_C)
STATIC utf8ness_t
S_get_locale_string_utf8ness_i(pTHX_ const char *string, const locale_utf8ness_t known_utf8, const char *locale, const locale_category_index cat_index);
# define PERL_ARGS_ASSERT_GET_LOCALE_STRING_UTF8NESS_I

STATIC void
S_ints_to_tm(pTHX_ struct tm *my_tm, const char *locale, int sec, int min, int hour, int mday, int mon, int year, int wday, int yday, int isdst);
# define PERL_ARGS_ASSERT_INTS_TO_TM            \
        assert(my_tm); assert(locale)

STATIC bool
S_is_locale_utf8(pTHX_ const char *locale);
# define PERL_ARGS_ASSERT_IS_LOCALE_UTF8        \
        assert(locale)

STATIC HV *
S_my_localeconv(pTHX_ const int item);
# define PERL_ARGS_ASSERT_MY_LOCALECONV

STATIC void
S_populate_hash_from_C_localeconv(pTHX_ HV *hv, const char *locale, const U32 which_mask, const lconv_offset_t *strings[2], const lconv_offset_t *integers[2]);
# define PERL_ARGS_ASSERT_POPULATE_HASH_FROM_C_LOCALECONV \
        assert(hv); assert(locale); assert(strings); assert(integers)

STATIC bool
S_strftime8(pTHX_ const char *fmt, SV *sv, const char *locale, const struct tm *mytm, const utf8ness_t fmt_utf8ness, utf8ness_t *result_utf8ness, const bool called_externally);
# define PERL_ARGS_ASSERT_STRFTIME8             \
        assert(fmt); assert(sv); assert(locale); assert(mytm); assert(result_utf8ness)

STATIC bool
S_strftime_tm(pTHX_ const char *fmt, SV *sv, const char *locale, const struct tm *mytm)
        __attribute__format__(__strftime__,pTHX_1,0);
# define PERL_ARGS_ASSERT_STRFTIME_TM           \
        assert(fmt); assert(sv); assert(locale); assert(mytm)

STATIC SV *
S_sv_strftime_common(pTHX_ SV *fmt, const char *locale, const struct tm *mytm);
# define PERL_ARGS_ASSERT_SV_STRFTIME_COMMON    \
        assert(fmt); assert(locale); assert(mytm)

# if defined(HAS_MISSING_LANGINFO_ITEM_) || !defined(HAS_NL_LANGINFO)
STATIC const char *
S_emulate_langinfo(pTHX_ const PERL_INTMAX_T item, const char *locale, SV *sv, utf8ness_t *utf8ness);
#   define PERL_ARGS_ASSERT_EMULATE_LANGINFO    \
        assert(locale); assert(sv)

# endif
# if defined(USE_LOCALE)
STATIC const char *
S_calculate_LC_ALL_string(pTHX_ const char **category_locales_list, const calc_LC_ALL_format format, const calc_LC_ALL_return returning, const line_t caller_line);
#   define PERL_ARGS_ASSERT_CALCULATE_LC_ALL_STRING

STATIC const char *
S_external_call_langinfo(pTHX_ const nl_item item, SV *sv, utf8ness_t *utf8ness);
#   define PERL_ARGS_ASSERT_EXTERNAL_CALL_LANGINFO \
        assert(sv)

STATIC locale_category_index
S_get_category_index_helper(pTHX_ const int category, bool *success, const line_t caller_line)
        __attribute__warn_unused_result__;
#   define PERL_ARGS_ASSERT_GET_CATEGORY_INDEX_HELPER

STATIC const char *
S_native_querylocale_i(pTHX_ const locale_category_index cat_index);
#   define PERL_ARGS_ASSERT_NATIVE_QUERYLOCALE_I

STATIC void
S_new_LC_ALL(pTHX_ const char *lc_all, bool force);
#   define PERL_ARGS_ASSERT_NEW_LC_ALL          \
        assert(lc_all)

STATIC void
S_output_check_environment_warning(pTHX_ const char * const language, const char * const lc_all, const char * const lang);
#   define PERL_ARGS_ASSERT_OUTPUT_CHECK_ENVIRONMENT_WARNING

STATIC parse_LC_ALL_string_return
S_parse_LC_ALL_string(pTHX_ const char *string, const char **output, const parse_LC_ALL_STRING_action, bool always_use_full_array, const bool panic_on_error, const line_t caller_line);
#   define PERL_ARGS_ASSERT_PARSE_LC_ALL_STRING \
        assert(string); assert(output)

STATIC void
S_restore_toggled_locale_i(pTHX_ const locale_category_index cat_index, const char *original_locale, const line_t caller_line);
#   define PERL_ARGS_ASSERT_RESTORE_TOGGLED_LOCALE_I

STATIC const char *
S_save_to_buffer(pTHX_ const char *string, char **buf, Size_t *buf_size);
#   define PERL_ARGS_ASSERT_SAVE_TO_BUFFER

STATIC void
S_set_save_buffer_min_size(pTHX_ const Size_t min_len, char **buf, Size_t *buf_size);
#   define PERL_ARGS_ASSERT_SET_SAVE_BUFFER_MIN_SIZE

PERL_STATIC_NO_RET void
S_setlocale_failure_panic_via_i(pTHX_ const locale_category_index cat_index, const char *current, const char *failed, const line_t proxy_caller_line, const line_t immediate_caller_line, const char *higher_caller_file, const line_t higher_caller_line)
        __attribute__noreturn__;
#   define PERL_ARGS_ASSERT_SETLOCALE_FAILURE_PANIC_VIA_I \
        assert(failed); assert(higher_caller_file)

STATIC const char *
S_toggle_locale_i(pTHX_ const locale_category_index cat_index, const char *new_locale, const line_t caller_line);
#   define PERL_ARGS_ASSERT_TOGGLE_LOCALE_I     \
        assert(new_locale)

#   if defined(DEBUGGING)
STATIC char *
S_my_setlocale_debug_string_i(pTHX_ const locale_category_index cat_index, const char *locale, const char *retval, const line_t line)
        __attribute__warn_unused_result__;
#     define PERL_ARGS_ASSERT_MY_SETLOCALE_DEBUG_STRING_I

#   endif
#   if   defined(HAS_LOCALECONV) && \
       ( defined(USE_LOCALE_MONETARY) || defined(USE_LOCALE_NUMERIC) )
STATIC void
S_populate_hash_from_localeconv(pTHX_ HV *hv, const char *locale, const U32 which_mask, const lconv_offset_t *strings[2], const lconv_offset_t *integers[2]);
#     define PERL_ARGS_ASSERT_POPULATE_HASH_FROM_LOCALECONV \
        assert(hv); assert(locale); assert(strings); assert(integers)

#   endif
#   if defined(HAS_NL_LANGINFO)
STATIC const char *
S_langinfo_sv_i(pTHX_ const nl_item item, locale_category_index cat_index, const char *locale, SV *sv, utf8ness_t *utf8ness);
#     define PERL_ARGS_ASSERT_LANGINFO_SV_I     \
        assert(locale); assert(sv)

#   endif
#   if defined(LC_ALL)
STATIC void
S_give_perl_locale_control(pTHX_ const char *lc_all_string, const line_t caller_line);
#     define PERL_ARGS_ASSERT_GIVE_PERL_LOCALE_CONTROL \
        assert(lc_all_string)

#   else
STATIC void
S_give_perl_locale_control(pTHX_ const char **curlocales, const line_t caller_line);
#     define PERL_ARGS_ASSERT_GIVE_PERL_LOCALE_CONTROL \
        assert(curlocales)

#   endif
#   if !defined(PERL_NO_INLINE_FUNCTIONS)
PERL_STATIC_INLINE const char *
S_mortalized_pv_copy(pTHX_ const char * const pv)
        __attribute__warn_unused_result__;
#     define PERL_ARGS_ASSERT_MORTALIZED_PV_COPY

#   endif
#   if defined(USE_LOCALE_COLLATE)
STATIC void
S_new_collate(pTHX_ const char *newcoll, bool force);
#     define PERL_ARGS_ASSERT_NEW_COLLATE       \
        assert(newcoll)

#     if defined(DEBUGGING)
STATIC void
S_print_collxfrm_input_and_return(pTHX_ const char *s, const char *e, const char *xbuf, const STRLEN xlen, const bool is_utf8);
#       define PERL_ARGS_ASSERT_PRINT_COLLXFRM_INPUT_AND_RETURN \
        assert(s); assert(e)

#     endif
#   endif /* defined(USE_LOCALE_COLLATE) */
#   if defined(USE_LOCALE_CTYPE)
STATIC bool
S_is_codeset_name_UTF8(const char *name);
#     define PERL_ARGS_ASSERT_IS_CODESET_NAME_UTF8 \
        assert(name)

STATIC void
S_new_ctype(pTHX_ const char *newctype, bool force);
#     define PERL_ARGS_ASSERT_NEW_CTYPE         \
        assert(newctype)

#   endif /* defined(USE_LOCALE_CTYPE) */
#   if defined(USE_LOCALE_NUMERIC)
STATIC void
S_new_numeric(pTHX_ const char *newnum, bool force);
#     define PERL_ARGS_ASSERT_NEW_NUMERIC       \
        assert(newnum)

#   endif
#   if defined(USE_PERL_SWITCH_LOCALE_CONTEXT) || defined(DEBUGGING)
STATIC const char *
S_get_LC_ALL_display(pTHX);
#     define PERL_ARGS_ASSERT_GET_LC_ALL_DISPLAY

#   endif
#   if defined(USE_POSIX_2008_LOCALE)
STATIC bool
S_bool_setlocale_2008_i(pTHX_ const locale_category_index index, const char *new_locale, const line_t caller_line);
#     define PERL_ARGS_ASSERT_BOOL_SETLOCALE_2008_I \
        assert(new_locale)

STATIC const char *
S_querylocale_2008_i(pTHX_ const locale_category_index index, const line_t line);
#     define PERL_ARGS_ASSERT_QUERYLOCALE_2008_I

STATIC locale_t
S_use_curlocale_scratch(pTHX);
#     define PERL_ARGS_ASSERT_USE_CURLOCALE_SCRATCH

#     if !defined(USE_QUERYLOCALE)
STATIC void
S_update_PL_curlocales_i(pTHX_ const locale_category_index index, const char *new_locale, const line_t caller_line);
#       define PERL_ARGS_ASSERT_UPDATE_PL_CURLOCALES_I \
        assert(new_locale)

#     endif
#   elif  defined(USE_LOCALE_THREADS) &&                  \
         !defined(USE_THREAD_SAFE_LOCALE) &&              \
         !defined(USE_THREAD_SAFE_LOCALE_EMULATION) /* &&
         !defined(USE_POSIX_2008_LOCALE) */
STATIC bool
S_less_dicey_bool_setlocale_r(pTHX_ const int cat, const char *locale);
#     define PERL_ARGS_ASSERT_LESS_DICEY_BOOL_SETLOCALE_R \
        assert(locale)

STATIC const char *
S_less_dicey_setlocale_r(pTHX_ const int category, const char *locale);
#     define PERL_ARGS_ASSERT_LESS_DICEY_SETLOCALE_R

#   endif /*  defined(USE_LOCALE_THREADS) &&
             !defined(USE_POSIX_2008_LOCALE) &&
             !defined(USE_THREAD_SAFE_LOCALE) &&
             !defined(USE_THREAD_SAFE_LOCALE_EMULATION) */
#   if defined(WIN32) || defined(WIN32_USE_FAKE_OLD_MINGW_LOCALES)
STATIC wchar_t *
S_Win_byte_string_to_wstring(const UINT code_page, const char *byte_string);
#     define PERL_ARGS_ASSERT_WIN_BYTE_STRING_TO_WSTRING

STATIC char *
S_Win_wstring_to_byte_string(const UINT code_page, const wchar_t *wstring);
#     define PERL_ARGS_ASSERT_WIN_WSTRING_TO_BYTE_STRING

STATIC const char *
S_win32_setlocale(pTHX_ int category, const char *locale);
#     define PERL_ARGS_ASSERT_WIN32_SETLOCALE

STATIC const char *
S_wrap_wsetlocale(pTHX_ const int category, const char *locale);
#     define PERL_ARGS_ASSERT_WRAP_WSETLOCALE

#   endif /* defined(WIN32) || defined(WIN32_USE_FAKE_OLD_MINGW_LOCALES) */
#   if   defined(WIN32) || defined(WIN32_USE_FAKE_OLD_MINGW_LOCALES) || \
       ( defined(USE_POSIX_2008_LOCALE) && !defined(USE_QUERYLOCALE) )
STATIC const char *
S_find_locale_from_environment(pTHX_ const locale_category_index index);
#     define PERL_ARGS_ASSERT_FIND_LOCALE_FROM_ENVIRONMENT

#   endif
# endif /* defined(USE_LOCALE) */
# if defined(USE_LOCALE) || defined(DEBUGGING)
STATIC const char *
S_get_displayable_string(pTHX_ const char * const s, const char * const e, const bool is_utf8);
#   define PERL_ARGS_ASSERT_GET_DISPLAYABLE_STRING \
        assert(s); assert(e)

# endif
#endif /* defined(PERL_IN_LOCALE_C) */
#if defined(PERL_IN_MALLOC_C)
STATIC int
S_adjust_size_and_find_bucket(size_t *nbytes_p);
# define PERL_ARGS_ASSERT_ADJUST_SIZE_AND_FIND_BUCKET \
        assert(nbytes_p)

#endif
#if defined(PERL_IN_MG_C)
STATIC void
S_fixup_errno_string(pTHX_ SV *sv);
# define PERL_ARGS_ASSERT_FIXUP_ERRNO_STRING    \
        assert(sv)

STATIC SV *
S_magic_methcall1(pTHX_ SV *sv, const MAGIC *mg, SV *meth, U32 flags, int n, SV *val);
# define PERL_ARGS_ASSERT_MAGIC_METHCALL1       \
        assert(sv); assert(mg); assert(meth)

STATIC int
S_magic_methpack(pTHX_ SV *sv, const MAGIC *mg, SV *meth);
# define PERL_ARGS_ASSERT_MAGIC_METHPACK        \
        assert(sv); assert(mg); assert(meth)

STATIC void
S_restore_magic(pTHX_ const void *p);
# define PERL_ARGS_ASSERT_RESTORE_MAGIC

STATIC void
S_save_magic_flags(pTHX_ SSize_t mgs_ix, SV *sv, U32 flags);
# define PERL_ARGS_ASSERT_SAVE_MAGIC_FLAGS      \
        assert(sv)

STATIC void
S_unwind_handler_stack(pTHX_ const void *p);
# define PERL_ARGS_ASSERT_UNWIND_HANDLER_STACK

#endif /* defined(PERL_IN_MG_C) */
#if defined(PERL_IN_MG_C) || defined(PERL_IN_PP_C)
PERL_CALLCONV bool
Perl_translate_substr_offsets(STRLEN curlen, IV pos1_iv, bool pos1_is_uv, IV len_iv, bool len_is_uv, STRLEN *posp, STRLEN *lenp)
        __attribute__visibility__("hidden");
# define PERL_ARGS_ASSERT_TRANSLATE_SUBSTR_OFFSETS \
        assert(posp); assert(lenp)

#endif
#if defined(PERL_IN_MRO_C)
STATIC void
S_mro_clean_isarev(pTHX_ HV * const isa, const char * const name, const STRLEN len, HV * const exceptions, U32 hash, U32 flags);
# define PERL_ARGS_ASSERT_MRO_CLEAN_ISAREV      \
        assert(isa); assert(name)

STATIC void
S_mro_gather_and_rename(pTHX_ HV * const stashes, HV * const seen_stashes, HV *stash, HV *oldstash, SV *namesv);
# define PERL_ARGS_ASSERT_MRO_GATHER_AND_RENAME \
        assert(stashes); assert(seen_stashes); assert(namesv)

STATIC AV *
S_mro_get_linear_isa_dfs(pTHX_ HV *stash, U32 level);
# define PERL_ARGS_ASSERT_MRO_GET_LINEAR_ISA_DFS \
        assert(stash)

#endif /* defined(PERL_IN_MRO_C) */
#if defined(PERL_IN_NUMERIC_C)
STATIC void
S_output_non_portable(pTHX_ const U8 shift);
# define PERL_ARGS_ASSERT_OUTPUT_NON_PORTABLE

#endif
#if defined(PERL_IN_OP_C)
STATIC void
S_apply_attrs(pTHX_ HV *stash, SV *target, OP *attrs);
# define PERL_ARGS_ASSERT_APPLY_ATTRS           \
        assert(stash); assert(target)

STATIC void
