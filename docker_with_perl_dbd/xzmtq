 * class.  And that the classes for those bytes which are start bytes have been
 * carefully chosen so they serve as well to be used as a shift value to mask
 * off the leading 1 bits of the start byte.  Unfortunately the addition of
 * being able to distinguish non-characters makes this not fully work.  This is
 * because, now, the start bytes E1-EF have to be broken into 3 classes instead
 * of 2:
 *  1) ED because it could be a surrogate
 *  2) EF because it could be a non-character
 *  3) the rest, which can never evaluate to a problematic code point.
 *
 * Each of E1-EF has three leading 1 bits, then a 0.  That means we could use a
 * shift (and hence class number) of either 3 or 4 to get a mask that works.
 * But that only allows two categories, and we need three.  khw made the
 * decision to therefore treat the ED start byte as an error, so that the dfa
 * drops out immediately for that.  In the dfa, classes 3 and 4 are used to
 * distinguish EF vs the rest.  Then special code is used to deal with ED,
 * that's executed only when the dfa drops out.  The code points started by ED
 * are half surrogates, and half hangul syllables.  This means that 2048 of
 * the hangul syllables (about 18%) take longer than all other non-problematic
 * code points to handle.
 *
 * The changes to handle non-characters requires the addition of states and
 * classes to the dfa.  (See the section on "Mapping bytes to character
 * classes" in the linked-to document for further explanation of the original
 * dfa.)
 *
 * The classes are
 *      00-7F           0
 *      80-8E           9
 *      8F             10
 *      90-9E          11
 *      9F             12
 *      A0-AE          13
 *      AF             14
 *      B0-B6          15
 *      B7             16
 *      B8-BD          15
 *      BE             17
 *      BF             18
 *      C0,C1           1
 *      C2-DF           2
 *      E0              7
 *      E1-EC           3
 *      ED              1
 *      EE              3
 *      EF              4
 *      F0              8
 *      F1-F3           6  (6 bits can be stripped)
 *      F4              5  (only 5 can be stripped)
 *      F5-FF           1
 */

EXTCONST U8 PL_strict_utf8_dfa_tab[] = {
    /* The first part of the table maps bytes to character classes to reduce
     * the size of the transition table and create bitmasks. */
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /*00-0F*/
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /*10-1F*/
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /*20-2F*/
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /*30-3F*/
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /*40-4F*/
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /*50-5F*/
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /*60-6F*/
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /*70-7F*/
   9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10, /*80-8F*/
  11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12, /*90-9F*/
  13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14, /*A0-AF*/
  15,15,15,15,15,15,15,16,15,15,15,15,15,15,17,18, /*B0-BF*/
   1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, /*C0-CF*/
   2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, /*D0-DF*/
   7, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 4, /*E0-EF*/
   8, 6, 6, 6, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /*F0-FF*/

/* The second part is a transition table that maps a combination
 * of a state of the automaton and a character class to a new state, called a
 * node.  The nodes are:
 * N0     The initial state, and final accepting one.
 * N1     Any one continuation byte (80-BF) left.  This is transitioned to
 *        immediately when the start byte indicates a two-byte sequence
 * N2     Any two continuation bytes left.
 * N3     Start byte is E0.  Continuation bytes 80-9F are illegal (overlong);
 *        the other continuations transition to state N1
 * N4     Start byte is EF.  Continuation byte B7 transitions to N8; BF to N9;
 *        the other continuations transitions to N1
 * N5     Start byte is F0.  Continuation bytes 80-8F are illegal (overlong);
 *        [9AB]F transition to N10; the other continuations to N2.
 * N6     Start byte is F[123].  Continuation bytes [89AB]F transition
 *        to N10; the other continuations to N2.
 * N7     Start byte is F4.  Continuation bytes 90-BF are illegal
 *        (non-unicode); 8F transitions to N10; the other continuations to N2
 * N8     Initial sequence is EF B7.  Continuation bytes 90-AF are illegal
 *        (non-characters); the other continuations transition to N0.
 * N9     Initial sequence is EF BF.  Continuation bytes BE and BF are illegal
 *        (non-characters); the other continuations transition to N0.
 * N10    Initial sequence is one of: F0 [9-B]F; F[123] [8-B]F; or F4 8F.
 *        Continuation byte BF transitions to N11; the other continuations to
 *        N1
 * N11    Initial sequence is the two bytes given in N10 followed by BF.
 *        Continuation bytes BE and BF are illegal (non-characters); the other
 *        continuations transition to N0.
 * 1      Reject.  All transitions not mentioned above (except the single
 *        byte ones (as they are always legal) are to this state.
 */

#      undef N0
#      undef N1
#      undef N2
#      undef N3
#      undef N4
#      undef N5
#      undef N6
#      undef N7
#      undef N8
#      undef N9
#      undef NUM_CLASSES
#      define NUM_CLASSES 19
#      define N0 0
#      define N1  ((N0)  + NUM_CLASSES)
#      define N2  ((N1)  + NUM_CLASSES)
#      define N3  ((N2)  + NUM_CLASSES)
#      define N4  ((N3)  + NUM_CLASSES)
#      define N5  ((N4)  + NUM_CLASSES)
#      define N6  ((N5)  + NUM_CLASSES)
#      define N7  ((N6)  + NUM_CLASSES)
#      define N8  ((N7)  + NUM_CLASSES)
#      define N9  ((N8)  + NUM_CLASSES)
#      define N10 ((N9)  + NUM_CLASSES)
#      define N11 ((N10) + NUM_CLASSES)

/*Class: 0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18 */
/*N0*/   0,  1, N1, N2, N4, N7, N6, N3, N5,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
/*N1*/   1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
/*N2*/   1,  1,  1,  1,  1,  1,  1,  1,  1, N1, N1, N1, N1, N1, N1, N1, N1, N1, N1,

/*N3*/   1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, N1, N1, N1, N1, N1, N1,
/*N4*/   1,  1,  1,  1,  1,  1,  1,  1,  1, N1, N1, N1, N1, N1, N1, N1, N8, N1, N9,
/*N5*/   1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, N2,N10, N2,N10, N2, N2, N2,N10,
/*N6*/   1,  1,  1,  1,  1,  1,  1,  1,  1, N2,N10, N2,N10, N2,N10, N2, N2, N2,N10,
/*N7*/   1,  1,  1,  1,  1,  1,  1,  1,  1, N2,N10,  1,  1,  1,  1,  1,  1,  1,  1,
/*N8*/   1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  1,  1,  0,  0,  0,  0,
/*N9*/   1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,
/*N10*/  1,  1,  1,  1,  1,  1,  1,  1,  1, N1, N1, N1, N1, N1, N1, N1, N1, N1,N11,
/*N11*/  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,
};

/* And below is yet another version of the above tables that accepts only UTF-8
 * as defined by Corregidum #9.  Hence no surrogates nor non-Unicode, but
 * it allows non-characters.  This is isomorphic to the original table
 * in https://bjoern.hoehrmann.de/utf-8/decoder/dfa/
 *
 * The classes are
 *      00-7F           0
 *      80-8F           9
 *      90-9F          10
 *      A0-BF          11
 *      C0,C1           1
 *      C2-DF           2
 *      E0              7
 *      E1-EC           3
 *      ED              4
 *      EE-EF           3
 *      F0              8
 *      F1-F3           6  (6 bits can be stripped)
 *      F4              5  (only 5 can be stripped)
 *      F5-FF           1
 */

EXTCONST U8 PL_c9_utf8_dfa_tab[] = {
    /* The first part of the table maps bytes to character classes to reduce
     * the size of the transition table and create bitmasks. */
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /*00-0F*/
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /*10-1F*/
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /*20-2F*/
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /*30-3F*/
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /*40-4F*/
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /*50-5F*/
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /*60-6F*/
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /*70-7F*/
   9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, /*80-8F*/
  10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10, /*90-9F*/
  11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11, /*A0-AF*/
  11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11, /*B0-BF*/
   1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, /*C0-CF*/
   2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, /*D0-DF*/
   7, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 3, /*E0-EF*/
   8, 6, 6, 6, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /*F0-FF*/

/* The second part is a transition table that maps a combination
 * of a state of the automaton and a character class to a new state, called a
 * node.  The nodes are:
 * N0     The initial state, and final accepting one.
 * N1     Any one continuation byte (80-BF) left.  This is transitioned to
 *        immediately when the start byte indicates a two-byte sequence
 * N2     Any two continuation bytes left.
 * N3     Any three continuation bytes left.
 * N4     Start byte is E0.  Continuation bytes 80-9F are illegal (overlong);
 *        the other continuations transition to state N1
 * N5     Start byte is ED.  Continuation bytes A0-BF all lead to surrogates,
 *        so are illegal.  The other continuations transition to state N1.
 * N6     Start byte is F0.  Continuation bytes 80-8F are illegal (overlong);
 *        the other continuations transition to N2
 * N7     Start byte is F4.  Continuation bytes 90-BF are illegal
 *        (non-unicode); the other continuations transition to N2
 * 1      Reject.  All transitions not mentioned above (except the single
 *        byte ones (as they are always legal) are to this state.
 */

#      undef N0
#      undef N1
#      undef N2
#      undef N3
#      undef N4
#      undef N5
#      undef N6
#      undef N7
#      undef NUM_CLASSES
#      define NUM_CLASSES 12
#      define N0 0
#      define N1  ((N0)  + NUM_CLASSES)
#      define N2  ((N1)  + NUM_CLASSES)
#      define N3  ((N2)  + NUM_CLASSES)
#      define N4  ((N3)  + NUM_CLASSES)
#      define N5  ((N4)  + NUM_CLASSES)
#      define N6  ((N5)  + NUM_CLASSES)
#      define N7  ((N6)  + NUM_CLASSES)

/*Class: 0   1   2   3   4   5   6   7   8   9  10  11 */
/*N0*/   0,  1, N1, N2, N5, N7, N3, N4, N6,  1,  1,  1,
/*N1*/   1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,
/*N2*/   1,  1,  1,  1,  1,  1,  1,  1,  1, N1, N1, N1,
/*N3*/   1,  1,  1,  1,  1,  1,  1,  1,  1, N2, N2, N2,

/*N4*/   1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, N1,
/*N5*/   1,  1,  1,  1,  1,  1,  1,  1,  1, N1, N1,  1,
/*N6*/   1,  1,  1,  1,  1,  1,  1,  1,  1,  1, N2, N2,
/*N7*/   1,  1,  1,  1,  1,  1,  1,  1,  1, N2,  1,  1,
};

#    endif /* defined(PERL_CORE) */
#  else     /* End of is DOINIT */

EXTCONST U8 PL_extended_utf8_dfa_tab[];
EXTCONST U8 PL_strict_utf8_dfa_tab[];
EXTCONST U8 PL_c9_utf8_dfa_tab[];

#  endif
#endif    /* end of isn't EBCDIC */

#include "overload.h"

END_EXTERN_C

struct am_table {
  U8 flags;
  U8 fallback;
  U16 spare;
  U32 was_ok_sub;
  CV* table[NofAMmeth];
};
struct am_table_short {
  U8 flags;
  U8 fallback;
  U16 spare;
  U32 was_ok_sub;
};
typedef struct am_table AMT;
typedef struct am_table_short AMTS;

#define AMGfallNEVER	1
#define AMGfallNO	2
#define AMGfallYES	3

#define AMTf_AMAGIC		1
#define AMT_AMAGIC(amt)		((amt)->flags & AMTf_AMAGIC)
#define AMT_AMAGIC_on(amt)	((amt)->flags |= AMTf_AMAGIC)
#define AMT_AMAGIC_off(amt)	((amt)->flags &= ~AMTf_AMAGIC)

#define StashHANDLER(stash,meth)	gv_handler((stash),CAT2(meth,_amg))

/*
 * some compilers like to redefine cos et alia as faster
 * (and less accurate?) versions called F_cos et cetera (Quidquid
 * latine dictum sit, altum viditur.)  This trick collides with
 * the Perl overloading (amg).  The following #defines fool both.
 */

#ifdef _FASTMATH
#   ifdef atan2
#       define F_atan2_amg  atan2_amg
#   endif
#   ifdef cos
#       define F_cos_amg    cos_amg
#   endif
#   ifdef exp
#       define F_exp_amg    exp_amg
#   endif
#   ifdef log
#       define F_log_amg    log_amg
#   endif
#   ifdef pow
#       define F_pow_amg    pow_amg
#   endif
#   ifdef sin
#       define F_sin_amg    sin_amg
#   endif
#   ifdef sqrt
#       define F_sqrt_amg   sqrt_amg
#   endif
#endif /* _FASTMATH */

#define PERLDB_ALL		(PERLDBf_SUB	| PERLDBf_LINE	|	\
                                 PERLDBf_NOOPT	| PERLDBf_INTER	|	\
                                 PERLDBf_SUBLINE| PERLDBf_SINGLE|	\
                                 PERLDBf_NAMEEVAL| PERLDBf_NAMEANON |   \
                                 PERLDBf_SAVESRC)
                                        /* No _NONAME, _GOTO */
#define PERLDBf_SUB		0x01	/* Debug sub enter/exit */
#define PERLDBf_LINE		0x02	/* Keep line # */
#define PERLDBf_NOOPT		0x04	/* Switch off optimizations */
#define PERLDBf_INTER		0x08	/* Preserve more data for
                                           later inspections  */
#define PERLDBf_SUBLINE		0x10	/* Keep subr source lines */
#define PERLDBf_SINGLE		0x20	/* Start with single-step on */
#define PERLDBf_NONAME		0x40	/* For _SUB: no name of the subr */
#define PERLDBf_GOTO		0x80	/* Report goto: call DB::goto */
#define PERLDBf_NAMEEVAL	0x100	/* Informative names for evals */
#define PERLDBf_NAMEANON	0x200	/* Informative names for anon subs */
#define PERLDBf_SAVESRC  	0x400	/* Save source lines into @{"_<$filename"} */
#define PERLDBf_SAVESRC_NOSUBS	0x800	/* Including evals that generate no subroutines */
#define PERLDBf_SAVESRC_INVALID	0x1000	/* Save source that did not compile */

#define PERLDB_SUB		(PL_perldb & PERLDBf_SUB)
#define PERLDB_LINE		(PL_perldb & PERLDBf_LINE)
#define PERLDB_NOOPT		(PL_perldb & PERLDBf_NOOPT)
#define PERLDB_INTER		(PL_perldb & PERLDBf_INTER)
#define PERLDB_SUBLINE		(PL_perldb & PERLDBf_SUBLINE)
#define PERLDB_SINGLE		(PL_perldb & PERLDBf_SINGLE)
#define PERLDB_SUB_NN		(PL_perldb & PERLDBf_NONAME)
#define PERLDB_GOTO		(PL_perldb & PERLDBf_GOTO)
#define PERLDB_NAMEEVAL 	(PL_perldb & PERLDBf_NAMEEVAL)
#define PERLDB_NAMEANON 	(PL_perldb & PERLDBf_NAMEANON)
#define PERLDB_SAVESRC  	(PL_perldb & PERLDBf_SAVESRC)
#define PERLDB_SAVESRC_NOSUBS	(PL_perldb & PERLDBf_SAVESRC_NOSUBS)
#define PERLDB_SAVESRC_INVALID	(PL_perldb & PERLDBf_SAVESRC_INVALID)

#define PERLDB_LINE_OR_SAVESRC (PL_perldb & (PERLDBf_LINE | PERLDBf_SAVESRC))

#ifdef USE_THREADS
#  define KEYWORD_PLUGIN_MUTEX_INIT    MUTEX_INIT(&PL_keyword_plugin_mutex)
#  define KEYWORD_PLUGIN_MUTEX_LOCK    MUTEX_LOCK(&PL_keyword_plugin_mutex)
#  define KEYWORD_PLUGIN_MUTEX_UNLOCK  MUTEX_UNLOCK(&PL_keyword_plugin_mutex)
#  define KEYWORD_PLUGIN_MUTEX_TERM    MUTEX_DESTROY(&PL_keyword_plugin_mutex)
#  define USER_PROP_MUTEX_INIT    MUTEX_INIT(&PL_user_prop_mutex)
#  define USER_PROP_MUTEX_LOCK    MUTEX_LOCK(&PL_user_prop_mutex)
#  define USER_PROP_MUTEX_UNLOCK  MUTEX_UNLOCK(&PL_user_prop_mutex)
#  define USER_PROP_MUTEX_TERM    MUTEX_DESTROY(&PL_user_prop_mutex)
#else
#  define KEYWORD_PLUGIN_MUTEX_INIT    NOOP
#  define KEYWORD_PLUGIN_MUTEX_LOCK    NOOP
#  define KEYWORD_PLUGIN_MUTEX_UNLOCK  NOOP
#  define KEYWORD_PLUGIN_MUTEX_TERM    NOOP
#  define USER_PROP_MUTEX_INIT    NOOP
#  define USER_PROP_MUTEX_LOCK    NOOP
#  define USER_PROP_MUTEX_UNLOCK  NOOP
#  define USER_PROP_MUTEX_TERM    NOOP
#endif

#ifdef USE_THREADS
#  define ENV_LOCK            PERL_WRITE_LOCK(&PL_env_mutex)
#  define ENV_UNLOCK          PERL_WRITE_UNLOCK(&PL_env_mutex)
#  define ENV_READ_LOCK       PERL_READ_LOCK(&PL_env_mutex)
#  define ENV_READ_UNLOCK     PERL_READ_UNLOCK(&PL_env_mutex)
#  define ENV_INIT            PERL_RW_MUTEX_INIT(&PL_env_mutex)
#  define ENV_TERM            PERL_RW_MUTEX_DESTROY(&PL_env_mutex)

   /* On platforms where the static buffer contained in getenv() is per-thread
    * rather than process-wide, another thread executing a getenv() at the same
    * time won't destroy ours before we have copied the result safely away and
    * unlocked the mutex.  On such platforms (which is most), we can have many
    * readers of the environment at the same time. */
#  ifdef GETENV_PRESERVES_OTHER_THREAD
#    define GETENV_LOCK    ENV_READ_LOCK
#    define GETENV_UNLOCK  ENV_READ_UNLOCK
#  else
     /* If, on the other hand, another thread could zap our getenv() return, we
      * need to keep them from executing until we are done */
#    define GETENV_LOCK    ENV_LOCK
#    define GETENV_UNLOCK  ENV_UNLOCK
#  endif
#else
#  define ENV_LOCK        NOOP
#  define ENV_UNLOCK      NOOP
#  define ENV_READ_LOCK   NOOP
#  define ENV_READ_UNLOCK NOOP
#  define ENV_INIT        NOOP
#  define ENV_TERM        NOOP
#  define GETENV_LOCK     NOOP
#  define GETENV_UNLOCK   NOOP
#endif

/* Locale/thread synchronization macros. */
#if ! defined(USE_LOCALE_THREADS)   /* No threads, or no locales */
#  define LOCALE_LOCK_(cond)  NOOP
#  define LOCALE_UNLOCK_      NOOP
#  define LOCALE_LOCK         NOOP
#  define LOCALE_UNLOCK       NOOP
#else   /* Below: Threaded, and locales are supported */

    /* A locale mutex is required on all such threaded builds for at least
     * situations where there is a global static buffer.  This base lock that
     * handles these has a trailing underscore in the name */
#  define LOCALE_LOCK_(cond_to_panic_if_already_locked)                     \
       PERL_REENTRANT_LOCK("locale",                                        \
                           &PL_locale_mutex, PL_locale_mutex_depth,         \
                           cond_to_panic_if_already_locked)
#  define LOCALE_UNLOCK_                                                    \
       PERL_REENTRANT_UNLOCK("locale",                                      \
                             &PL_locale_mutex, PL_locale_mutex_depth)
#  ifdef USE_THREAD_SAFE_LOCALE
    /* But for most situations, we use the macro name without a trailing
     * underscore.
     *
     * In locale thread-safe Configurations, typical operations don't need
     * locking */
#    define LOCALE_LOCK         NOOP
#    define LOCALE_UNLOCK       NOOP
#  else
     /* Whereas, thread-unsafe Configurations always requires locking */
#    define LOCALE_LOCK_DOES_SOMETHING_
#    define LOCALE_LOCK         LOCALE_LOCK_(0)
#    define LOCALE_UNLOCK       LOCALE_UNLOCK_
#    ifdef USE_LOCALE_NUMERIC
#      define LC_NUMERIC_LOCK(cond_to_panic_if_already_locked)              \
                 LOCALE_LOCK_(cond_to_panic_if_already_locked)
#      define LC_NUMERIC_UNLOCK  LOCALE_UNLOCK_
#    endif
#  endif
#endif

/* There are some locale-related functions which may need locking only because
 * they share some common memory across threads, and hence there is the
 * potential for a race in accessing that space.  Most are because their return
 * points to a global static buffer, but some just use some common space
 * internally.  All functions accessing a given space need to have a critical
 * section to prevent any other thread from accessing it at the same time.
 * Ideally, there would be a separate mutex for each such space, so that
 * another thread isn't unnecessarily blocked.  But, most of them need to be
 * locked against the locale changing while accessing that space, and it is not
 * expected that any will be called frequently, and the locked interval should
 * be short, and modern platforms will have reentrant versions (which don't
 * lock) for almost all of them, so khw thinks a single mutex should suffice.
 * Having a single mutex facilitates that, avoiding potential deadlock
 * situations.
 *
 * This will be a no-op iff the perl is unthreaded. 'gw' stands for 'global
 * write', to indicate the caller wants to be able to access memory that isn't
 * thread specific, either to write to itself, or to prevent anyone else from
 * writing. */
#define gwLOCALE_LOCK    LOCALE_LOCK_(0)
#define gwLOCALE_UNLOCK  LOCALE_UNLOCK_

/* Similar to gwLOCALE_LOCK, there are functions that require both the locale
 * and environment to be constant during their execution, and don't change
 * either of those things, but do write to some sort of shared global space.
 * They require some sort of exclusive lock against similar functions, and a
 * read lock on both the locale and environment.  However, on systems which
 * have per-thread locales, the locale is constant during the execution of
 * these functions, and so no locale lock is necssary.  For such systems, an
 * exclusive ENV lock is necessary and sufficient.  On systems where the locale
 * could change out from under us, we use an exclusive LOCALE lock to prevent
 * that, and a read ENV lock to prevent other threads that have nothing to do
 * with locales here from changing the environment. */
#ifdef LOCALE_LOCK_DOES_SOMETHING
#  define gwENVr_LOCALEr_LOCK                                               \
                    STMT_START { LOCALE_LOCK; ENV_READ_LOCK; } STMT_END
#  define gwENVr_LOCALEr_UNLOCK                                             \
                STMT_START { ENV_READ_UNLOCK; LOCALE_UNLOCK; } STMT_END
#else
#  define gwENVr_LOCALEr_LOCK           ENV_LOCK
#  define gwENVr_LOCALEr_UNLOCK         ENV_UNLOCK
#endif

      /* On systems that don't have per-thread locales, even though we don't
       * think we are changing the locale ourselves, behind the scenes it does
       * get changed to whatever the thread's should be, so it has to be an
       * exclusive lock.  By defining it here with this name, we can, for the
       * most part, hide this detail from the rest of the code */
/* Currently, the read lock is an exclusive lock */
#define LOCALE_READ_LOCK                LOCALE_LOCK
#define LOCALE_READ_UNLOCK              LOCALE_UNLOCK

/* setlocale() generally returns in a global static buffer, but not on Windows
 * when operating in thread-safe mode */
#if defined(WIN32) && defined(USE_THREAD_SAFE_LOCALE)
#  define POSIX_SETLOCALE_LOCK                                              \
            STMT_START {                                                    \
                if (_configthreadlocale(0) == _DISABLE_PER_THREAD_LOCALE)   \
                    gwLOCALE_LOCK;                                          \
            } STMT_END
#  define POSIX_SETLOCALE_UNLOCK                                            \
            STMT_START {                                                    \
                if (_configthreadlocale(0) == _DISABLE_PER_THREAD_LOCALE)   \
                    gwLOCALE_UNLOCK;                                        \
            } STMT_END
#else
#  define POSIX_SETLOCALE_LOCK      gwLOCALE_LOCK
#  define POSIX_SETLOCALE_UNLOCK    gwLOCALE_UNLOCK
#endif

/* It handles _wsetlocale() as well */
#define WSETLOCALE_LOCK      POSIX_SETLOCALE_LOCK
#define WSETLOCALE_UNLOCK    POSIX_SETLOCALE_UNLOCK


#ifndef LC_NUMERIC_LOCK
#  define LC_NUMERIC_LOCK(cond)   NOOP
#  define LC_NUMERIC_UNLOCK       NOOP
#endif

   /* These non-reentrant versions use global space */
#  define MBLEN_LOCK_                gwLOCALE_LOCK
#  define MBLEN_UNLOCK_              gwLOCALE_UNLOCK

#  define MBTOWC_LOCK_               gwLOCALE_LOCK
#  define MBTOWC_UNLOCK_             gwLOCALE_UNLOCK

#  define WCTOMB_LOCK_               gwLOCALE_LOCK
#  define WCTOMB_UNLOCK_             gwLOCALE_UNLOCK

   /* Whereas the reentrant versions don't (assuming they are called with a
    * per-thread buffer; some have the capability of being called with a NULL
    * parameter, which defeats the reentrancy) */
#  define MBRLEN_LOCK_                  NOOP
#  define MBRLEN_UNLOCK_                NOOP
#  define MBRTOWC_LOCK_                 NOOP
#  define MBRTOWC_UNLOCK_               NOOP
#  define WCRTOMB_LOCK_                 NOOP
#  define WCRTOMB_UNLOCK_               NOOP

#  define LC_COLLATE_LOCK               LOCALE_LOCK
#  define LC_COLLATE_UNLOCK             LOCALE_UNLOCK

/* Some critical sections need to lock both the locale and the environment from
 * changing, while allowing for any number of readers.  To avoid deadlock, this
 * is always done in the same order.  These should always be invoked, like all
 * locks really, at such a low level that its just a libc call that is wrapped,
 * so as to prevent recursive calls which could deadlock. */
#define ENVr_LOCALEr_LOCK                                               \
            STMT_START { LOCALE_READ_LOCK; ENV_READ_LOCK; } STMT_END
#define ENVr_LOCALEr_UNLOCK                                             \
        STMT_START { ENV_READ_UNLOCK; LOCALE_READ_UNLOCK; } STMT_END

#define STRFTIME_LOCK                   ENVr_LOCALEr_LOCK
#define STRFTIME_UNLOCK                 ENVr_LOCALEr_UNLOCK

/* These time-related functions all requre that the environment and locale
 * don't change while they are executing (at least in glibc; this appears to be
 * contrary to the POSIX standard).  tzset() writes global variables, so
 * always needs to have write locking.  ctime, localtime, mktime, and strftime
 * effectively call it, so they too need exclusive access.  The rest need to
 * have exclusive locking as well so that they can copy the contents of the
 * returned static buffer before releasing the lock.  That leaves asctime and
 * gmtime.  There may be reentrant versions of these available on the platform
 * which don't require write locking.
 */
#ifdef PERL_REENTR_USING_ASCTIME_R
#  define ASCTIME_LOCK     ENVr_LOCALEr_LOCK
#  define ASCTIME_UNLOCK   ENVr_LOCALEr_UNLOCK
#else
#  define ASCTIME_LOCK     gwENVr_LOCALEr_LOCK
#  define ASCTIME_UNLOCK   gwENVr_LOCALEr_UNLOCK
#endif

#define CTIME_LOCK         gwENVr_LOCALEr_LOCK
#define CTIME_UNLOCK       gwENVr_LOCALEr_UNLOCK

#ifdef PERL_REENTR_USING_GMTIME_R
#  define GMTIME_LOCK      ENVr_LOCALEr_LOCK
#  define GMTIME_UNLOCK    ENVr_LOCALEr_UNLOCK
#else
#  define GMTIME_LOCK      gwENVr_LOCALEr_LOCK
#  define GMTIME_UNLOCK    gwENVr_LOCALEr_UNLOCK
#endif

#define LOCALTIME_LOCK     gwENVr_LOCALEr_LOCK
#define LOCALTIME_UNLOCK   gwENVr_LOCALEr_UNLOCK
#define MKTIME_LOCK        gwENVr_LOCALEr_LOCK
#define MKTIME_UNLOCK      gwENVr_LOCALEr_UNLOCK
#define TZSET_LOCK         gwENVr_LOCALEr_LOCK
#define TZSET_UNLOCK       gwENVr_LOCALEr_UNLOCK

/* Similiarly, these functions need a constant environment and/or locale.  And
 * some have a buffer that is shared with another thread executing the same or
 * a related call.  A mutex could be created for each class, but for now, share
 * the ENV mutex with everything, as none probably gets called so much that
 * performance would suffer by a thread being locked out by another thread that
 * could have used a different mutex.
 *
 * But, create a different macro name just to indicate the ones that don't
 * actually depend on the environment, but are using its mutex for want of a
 * better one */
#define gwLOCALEr_LOCK              gwENVr_LOCALEr_LOCK
#define gwLOCALEr_UNLOCK            gwENVr_LOCALEr_UNLOCK

#ifdef PERL_REENTR_USING_GETHOSTBYADDR_R
#  define GETHOSTBYADDR_LOCK        ENVr_LOCALEr_LOCK
#  define GETHOSTBYADDR_UNLOCK      ENVr_LOCALEr_UNLOCK
#else
#  define GETHOSTBYADDR_LOCK        gwENVr_LOCALEr_LOCK
#  define GETHOSTBYADDR_UNLOCK      gwENVr_LOCALEr_UNLOCK
#endif
#ifdef PERL_REENTR_USING_GETHOSTBYNAME_R
#  define GETHOSTBYNAME_LOCK        ENVr_LOCALEr_LOCK
#  define GETHOSTBYNAME_UNLOCK      ENVr_LOCALEr_UNLOCK
#else
#  define GETHOSTBYNAME_LOCK        gwENVr_LOCALEr_LOCK
#  define GETHOSTBYNAME_UNLOCK      gwENVr_LOCALEr_UNLOCK
#endif
#ifdef PERL_REENTR_USING_GETNETBYADDR_R
#  define GETNETBYADDR_LOCK         LOCALE_READ_LOCK
#  define GETNETBYADDR_UNLOCK       LOCALE_READ_UNLOCK
#else
#  define GETNETBYADDR_LOCK         gwLOCALEr_LOCK
#  define GETNETBYADDR_UNLOCK       gwLOCALEr_UNLOCK
#endif
#ifdef PERL_REENTR_USING_GETNETBYNAME_R
#  define GETNETBYNAME_LOCK         LOCALE_READ_LOCK
#  define GETNETBYNAME_UNLOCK       LOCALE_READ_UNLOCK
#else
#  define GETNETBYNAME_LOCK         gwLOCALEr_LOCK
#  define GETNETBYNAME_UNLOCK       gwLOCALEr_UNLOCK
#endif
#ifdef PERL_REENTR_USING_GETPROTOBYNAME_R
#  define GETPROTOBYNAME_LOCK       LOCALE_READ_LOCK
#  define GETPROTOBYNAME_UNLOCK     LOCALE_READ_UNLOCK
#else
#  define GETPROTOBYNAME_LOCK       gwLOCALEr_LOCK
#  define GETPROTOBYNAME_UNLOCK     gwLOCALEr_UNLOCK
#endif
#ifdef PERL_REENTR_USING_GETPROTOBYNUMBER_R
#  define GETPROTOBYNUMBER_LOCK     LOCALE_READ_LOCK
#  define GETPROTOBYNUMBER_UNLOCK   LOCALE_READ_UNLOCK
#else
#  define GETPROTOBYNUMBER_LOCK     gwLOCALEr_LOCK
#  define GETPROTOBYNUMBER_UNLOCK   gwLOCALEr_UNLOCK
#endif
#ifdef PERL_REENTR_USING_GETPROTOENT_R
#  define GETPROTOENT_LOCK          LOCALE_READ_LOCK
#  define GETPROTOENT_UNLOCK        LOCALE_READ_UNLOCK
#else
#  define GETPROTOENT_LOCK          gwLOCALEr_LOCK
#  define GETPROTOENT_UNLOCK        gwLOCALEr_UNLOCK
#endif
#ifdef PERL_REENTR_USING_GETPWNAM_R
#  define GETPWNAM_LOCK             LOCALE_READ_LOCK
#  define GETPWNAM_UNLOCK           LOCALE_READ_UNLOCK
#else
#  define GETPWNAM_LOCK             gwLOCALEr_LOCK
#  define GETPWNAM_UNLOCK           gwLOCALEr_UNLOCK
#endif
#ifdef PERL_REENTR_USING_GETPWUID_R
#  define GETPWUID_LOCK             LOCALE_READ_LOCK
#  define GETPWUID_UNLOCK           LOCALE_READ_UNLOCK
#else
#  define GETPWUID_LOCK             gwLOCALEr_LOCK
#  define GETPWUID_UNLOCK           gwLOCALEr_UNLOCK
#endif
#ifdef PERL_REENTR_USING_GETSERVBYNAME_R
#  define GETSERVBYNAME_LOCK        LOCALE_READ_LOCK
#  define GETSERVBYNAME_UNLOCK      LOCALE_READ_UNLOCK
#else
#  define GETSERVBYNAME_LOCK        gwLOCALEr_LOCK
#  define GETSERVBYNAME_UNLOCK      gwLOCALEr_UNLOCK
#endif
#ifdef PERL_REENTR_USING_GETSERVBYPORT_R
#  define GETSERVBYPORT_LOCK        LOCALE_READ_LOCK
#  define GETSERVBYPORT_UNLOCK      LOCALE_READ_UNLOCK
#else
#  define GETSERVBYPORT_LOCK        gwLOCALEr_LOCK
#  define GETSERVBYPORT_UNLOCK      gwLOCALEr_UNLOCK
#endif
#ifdef PERL_REENTR_USING_GETSERVENT_R
#  define GETSERVENT_LOCK           LOCALE_READ_LOCK
#  define GETSERVENT_UNLOCK         LOCALE_READ_UNLOCK
#else
#  define GETSERVENT_LOCK           gwLOCALEr_LOCK
#  define GETSERVENT_UNLOCK         gwLOCALEr_UNLOCK
#endif
#ifdef PERL_REENTR_USING_GETSPNAM_R
#  define GETSPNAM_LOCK             LOCALE_READ_LOCK
#  define GETSPNAM_UNLOCK           LOCALE_READ_UNLOCK
#else
#  define GETSPNAM_LOCK             gwLOCALEr_LOCK
#  define GETSPNAM_UNLOCK           gwLOCALEr_UNLOCK
#endif

#define STRFMON_LOCK        LC_MONETARY_LOCK
#define STRFMON_UNLOCK      LC_MONETARY_UNLOCK

/* End of locale/env synchronization */

#if ! defined(USE_LOCALE_THREADS)
#  define LOCALE_INIT
#  define LOCALE_TERM
#else
#  ifdef WIN32_USE_FAKE_OLD_MINGW_LOCALES
    /* This function is coerced by this Configure option into cleaning up
     * memory that is static to locale.c.  So we call it at termination.  Doing
     * it this way is kludgy but confines having to deal with this
     * Configuration to a bare minimum number of places. */
#      define LOCALE_TERM_POSIX_2008_  Perl_thread_locale_term(NULL)
#  elif ! defined(USE_POSIX_2008_LOCALE)
#      define LOCALE_TERM_POSIX_2008_  NOOP
#  else
     /* We have a locale object holding the 'C' locale for Posix 2008 */
#    define LOCALE_TERM_POSIX_2008_                                         \
                    STMT_START {                                            \
                        if (PL_C_locale_obj) {                              \
                            /* Make sure we aren't using the locale         \
                             * space we are about to free */                \
                            uselocale(LC_GLOBAL_LOCALE);                    \
                            freelocale(PL_C_locale_obj);                    \
                            PL_C_locale_obj = (locale_t) NULL;              \
                        }                                                   \
                    } STMT_END
#  endif

#  define LOCALE_INIT           MUTEX_INIT(&PL_locale_mutex)
#  define LOCALE_TERM           STMT_START {                                \
                                    LOCALE_TERM_POSIX_2008_;                \
                                    MUTEX_DESTROY(&PL_locale_mutex);        \
                                } STMT_END
#endif

#ifdef USE_LOCALE /* These locale things are all subject to change */

   /* Returns TRUE if the plain locale pragma without a parameter is in effect.
    * */
#  define IN_LOCALE_RUNTIME	(PL_curcop                                  \
                              && CopHINTS_get(PL_curcop) & HINT_LOCALE)

   /* Returns TRUE if either form of the locale pragma is in effect */
#  define IN_SOME_LOCALE_FORM_RUNTIME                                       \
        cBOOL(CopHINTS_get(PL_curcop) & (HINT_LOCALE|HINT_LOCALE_PARTIAL))

#  define IN_LOCALE_COMPILETIME	cBOOL(PL_hints & HINT_LOCALE)
#  define IN_SOME_LOCALE_FORM_COMPILETIME                                   \
                        cBOOL(PL_hints & (HINT_LOCALE|HINT_LOCALE_PARTIAL))

/*
=for apidoc_section $locale

=for apidoc Amn|bool|IN_LOCALE

Evaluates to TRUE if the plain locale pragma without a parameter (S<C<use
locale>>) is in effect.

=for apidoc Amn|bool|IN_LOCALE_COMPILETIME

Evaluates to TRUE if, when compiling a perl program (including an C<eval>) if
the plain locale pragma without a parameter (S<C<use locale>>) is in effect.

=for apidoc Amn|bool|IN_LOCALE_RUNTIME

Evaluates to TRUE if, when executing a perl program (including an C<eval>) if
the plain locale pragma without a parameter (S<C<use locale>>) is in effect.

=cut
*/

#  define IN_LOCALE                                                         \
        (IN_PERL_COMPILETIME ? IN_LOCALE_COMPILETIME : IN_LOCALE_RUNTIME)
#  define IN_SOME_LOCALE_FORM                                               \
                    (IN_PERL_COMPILETIME ? IN_SOME_LOCALE_FORM_COMPILETIME  \
                                         : IN_SOME_LOCALE_FORM_RUNTIME)

#  define IN_LC_ALL_COMPILETIME   IN_LOCALE_COMPILETIME
#  define IN_LC_ALL_RUNTIME       IN_LOCALE_RUNTIME

#  define IN_LC_PARTIAL_COMPILETIME   cBOOL(PL_hints & HINT_LOCALE_PARTIAL)
#  define IN_LC_PARTIAL_RUNTIME                                             \
              (PL_curcop && CopHINTS_get(PL_curcop) & HINT_LOCALE_PARTIAL)

#  define IN_LC_COMPILETIME(category)                                       \
       (       IN_LC_ALL_COMPILETIME                                        \
        || (   IN_LC_PARTIAL_COMPILETIME                                    \
            && Perl__is_in_locale_category(aTHX_ TRUE, (category))))
#  define IN_LC_RUNTIME(category)                                           \
      (IN_LC_ALL_RUNTIME || (IN_LC_PARTIAL_RUNTIME                          \
                 && Perl__is_in_locale_category(aTHX_ FALSE, (category))))
#  define IN_LC(category)  \
                    (IN_LC_COMPILETIME(category) || IN_LC_RUNTIME(category))

#  if defined (PERL_CORE) || defined (PERL_IN_XSUB_RE) || defined(PERL_EXT_POSIX)

     /* This internal macro should be called from places that operate under
      * locale rules.  If there is a problem with the current locale that
      * hasn't been raised yet, it will output a warning this time.  Because
      * this will so rarely  be true, there is no point to optimize for time;
      * instead it makes sense to minimize space used and do all the work in
      * the rarely called function */
#    ifdef USE_LOCALE_CTYPE
#      define CHECK_AND_WARN_PROBLEMATIC_LOCALE_                              \
                STMT_START {                                                  \
                    if (UNLIKELY(PL_warn_locale)) {                           \
                        Perl_warn_problematic_locale();                       \
                    }                                                         \
                }  STMT_END
#    else
#      define CHECK_AND_WARN_PROBLEMATIC_LOCALE_
#    endif


     /* These two internal macros are called when a warning should be raised,
      * and will do so if enabled.  The first takes a single code point
      * argument; the 2nd, is a pointer to the first byte of the UTF-8 encoded
      * string, and an end position which it won't try to read past */
#    define _CHECK_AND_OUTPUT_WIDE_LOCALE_CP_MSG(cp)                        \
        STMT_START {                                                        \
            if (! IN_UTF8_CTYPE_LOCALE && ckWARN(WARN_LOCALE)) {            \
                Perl_warner(aTHX_ packWARN(WARN_LOCALE),                    \
                                       "Wide character (U+%" UVXf ") in %s",\
                                       (UV) cp, OP_DESC(PL_op));            \
            }                                                               \
        }  STMT_END

#    define _CHECK_AND_OUTPUT_WIDE_LOCALE_UTF8_MSG(s, send)                 \
        STMT_START { /* Check if to warn before doing the conversion work */\
            if (! IN_UTF8_CTYPE_LOCALE && ckWARN(WARN_LOCALE)) {            \
                UV cp = utf8_to_uvchr_buf((U8 *) (s), (U8 *) (send), NULL); \
                Perl_warner(aTHX_ packWARN(WARN_LOCALE),                    \
                    "Wide character (U+%" UVXf ") in %s",                   \
                    (cp == 0)                                               \
                     ? UNICODE_REPLACEMENT                                  \
                     : (UV) cp,                                             \
                    OP_DESC(PL_op));                                        \
            }                                                               \
        }  STMT_END

#  endif   /* PERL_CORE or PERL_IN_XSUB_RE */
#else   /* No locale usage */
#  define IN_LOCALE_RUNTIME                0
#  define IN_SOME_LOCALE_FORM_RUNTIME      0
#  define IN_LOCALE_COMPILETIME            0
#  define IN_SOME_LOCALE_FORM_COMPILETIME  0
#  define IN_LOCALE                        0
#  define IN_SOME_LOCALE_FORM              0
#  define IN_LC_ALL_COMPILETIME            0
#  define IN_LC_ALL_RUNTIME                0
#  define IN_LC_PARTIAL_COMPILETIME        0
#  define IN_LC_PARTIAL_RUNTIME            0
#  define IN_LC_COMPILETIME(category)      0
#  define IN_LC_RUNTIME(category)          0
#  define IN_LC(category)                  0
#  define CHECK_AND_WARN_PROBLEMATIC_LOCALE_
#  define _CHECK_AND_OUTPUT_WIDE_LOCALE_UTF8_MSG(s, send)
#  define _CHECK_AND_OUTPUT_WIDE_LOCALE_CP_MSG(c)
#endif

#define locale_panic_via_(m, f, l)  Perl_locale_panic((m), __LINE__, f, l)
#define locale_panic_(m)  locale_panic_via_((m), __FILE__, __LINE__)

#ifdef USE_LOCALE_NUMERIC

/* These macros are for toggling between the underlying locale (UNDERLYING or
 * LOCAL) and the C locale (STANDARD).  (Actually we don't have to use the C
 * locale if the underlying locale is indistinguishable from it in the numeric
 * operations used by Perl, namely the decimal point, and even the thousands
 * separator.)

=for apidoc_section $locale

=for apidoc Amn|void|DECLARATION_FOR_LC_NUMERIC_MANIPULATION

This macro should be used as a statement.  It declares a private variable
(whose name begins with an underscore) that is needed by the other macros in
this section.  Failing to include this correctly should lead to a syntax error.
For compatibility with C89 C compilers it should be placed in a block before
any executable statements.

=for apidoc Am|void|STORE_LC_NUMERIC_FORCE_TO_UNDERLYING

This is used by XS code that is C<LC_NUMERIC> locale-aware to force the
locale for category C<LC_NUMERIC> to be what perl thinks is the current
underlying locale.  (The perl interpreter could be wrong about what the
underlying locale actually is if some C or XS code has called the C library
function L<setlocale(3)> behind its back; calling L</sync_locale> before calling
this macro will update perl's records.)

A call to L</DECLARATION_FOR_LC_NUMERIC_MANIPULATION> must have been made to
declare at compile time a private variable used by this macro.  This macro
should be called as a single statement, not an expression, but with an empty
argument list, like this:

 {
    DECLARATION_FOR_LC_NUMERIC_MANIPULATION;
     ...
    STORE_LC_NUMERIC_FORCE_TO_UNDERLYING();
     ...
    RESTORE_LC_NUMERIC();
     ...
 }

The private variable is used to save the current locale state, so
that the requisite matching call to L</RESTORE_LC_NUMERIC> can restore it.

On threaded perls not operating with thread-safe functionality, this macro uses
a mutex to force a critical section.  Therefore the matching RESTORE should be
close by, and guaranteed to be called.

=for apidoc Am|void|STORE_LC_NUMERIC_SET_TO_NEEDED

This is used to help wrap XS or C code that is C<LC_NUMERIC> locale-aware.
This locale category is generally kept set to a locale where the decimal radix
character is a dot, and the separator between groups of digits is empty.  This
is because most XS code that reads floating point numbers is expecting them to
have this syntax.

This macro makes sure the current C<LC_NUMERIC> state is set properly, to be
aware of locale if the call to the XS or C code from the Perl program is
from within the scope of a S<C<use locale>>; or to ignore locale if the call is
instead from outside such scope.

This macro is the start of wrapping the C or XS code; the wrap ending is done
by calling the L</RESTORE_LC_NUMERIC> macro after the operation.  Otherwise
the state can be changed that will adversely affect other XS code.

A call to L</DECLARATION_FOR_LC_NUMERIC_MANIPULATION> must have been made to
declare at compile time a private variable used by this macro.  This macro
should be called as a single statement, not an expression, but with an empty
argument list, like this:

 {
    DECLARATION_FOR_LC_NUMERIC_MANIPULATION;
     ...
    STORE_LC_NUMERIC_SET_TO_NEEDED();
     ...
    RESTORE_LC_NUMERIC();
     ...
 }

On threaded perls not operating with thread-safe functionality, this macro uses
a mutex to force a critical section.  Therefore the matching RESTORE should be
close by, and guaranteed to be called; see L</WITH_LC_NUMERIC_SET_TO_NEEDED>
for a more contained way to ensure that.

=for apidoc Am|void|STORE_LC_NUMERIC_SET_TO_NEEDED_IN|bool in_lc_numeric

Same as L</STORE_LC_NUMERIC_SET_TO_NEEDED> with in_lc_numeric provided
as the precalculated value of C<IN_LC(LC_NUMERIC)>. It is the caller's
responsibility to ensure that the status of C<PL_compiling> and C<PL_hints>
cannot have changed since the precalculation.

=for apidoc Am|void|RESTORE_LC_NUMERIC

This is used in conjunction with one of the macros
L</STORE_LC_NUMERIC_SET_TO_NEEDED>
and L</STORE_LC_NUMERIC_FORCE_TO_UNDERLYING> to properly restore the
C<LC_NUMERIC> state.

A call to L</DECLARATION_FOR_LC_NUMERIC_MANIPULATION> must have been made to
declare at compile time a private variable used by this macro and the two
C<STORE> ones.  This macro should be called as a single statement, not an
expression, but with an empty argument list, like this:

 {
    DECLARATION_FOR_LC_NUMERIC_MANIPULATION;
     ...
    RESTORE_LC_NUMERIC();
     ...
 }

=for apidoc Am|void|WITH_LC_NUMERIC_SET_TO_NEEDED|block

This macro invokes the supplied statement or block within the context
of a L</STORE_LC_NUMERIC_SET_TO_NEEDED> .. L</RESTORE_LC_NUMERIC> pair
if required, so eg:

  WITH_LC_NUMERIC_SET_TO_NEEDED(
    SNPRINTF_G(fv, ebuf, sizeof(ebuf), precis)
  );

is equivalent to:

  {
#ifdef USE_LOCALE_NUMERIC
    DECLARATION_FOR_LC_NUMERIC_MANIPULATION;
    STORE_LC_NUMERIC_SET_TO_NEEDED();
#endif
    SNPRINTF_G(fv, ebuf, sizeof(ebuf), precis);
#ifdef USE_LOCALE_NUMERIC
    RESTORE_LC_NUMERIC();
#endif
  }

=for apidoc Am|void|WITH_LC_NUMERIC_SET_TO_NEEDED_IN|bool in_lc_numeric|block

Same as L</WITH_LC_NUMERIC_SET_TO_NEEDED> with in_lc_numeric provided
as the precalculated value of C<IN_LC(LC_NUMERIC)>. It is the caller's
responsibility to ensure that the status of C<PL_compiling> and C<PL_hints>
cannot have changed since the precalculation.
