First a xBlock starts at the { in the first line.  In the second line another
{ is found.  Since we are inside a xBlock item, and it contains itself, a
nested xBlock item will start here.  Thus the "b = c" line is inside the
second level xBlock region.  Then a } is found in the next line, which matches
with the end pattern of the region.  This ends the nested xBlock.  Because the
} is included in the nested region, it is hidden from the first xBlock region.
Then at the last } the first xBlock region ends.


KEEPING THE END

Consider the following two syntax items: >

	:syntax region xComment start=/%/ end=/$/ contained
	:syntax region xPreProc start=/#/ end=/$/ contains=xComment

You define a comment as anything from % to the end of the line.  A
preprocessor directive is anything from # to the end of the line.  Because you
can have a comment on a preprocessor line, the preprocessor definition
includes a "contains=xComment" argument.  Now look what happens with this
text:

	#define X = Y  % Comment text ~
	int foo = 1; ~

What you see is that the second line is also highlighted as xPreProc.  The
preprocessor directive should end at the end of the line.  That is why
you have used "end=/$/".  So what is going wrong?
   The problem is the contained comment.  The comment starts with % and ends
at the end of the line.  After the comment ends, the preprocessor syntax
continues.  This is after the end of the line has been seen, so the next
line is included as well.
   To avoid this problem and to avoid a contained syntax item eating a needed
end of line, use the "keepend" argument.  This takes care of
the double end-of-line matching: >

	:syntax region xComment start=/%/ end=/$/ contained
	:syntax region xPreProc start=/#/ end=/$/ contains=xComment keepend


CONTAINING MANY ITEMS

You can use the contains argument to specify that everything can be contained.
For example: >

	:syntax region xList start=/\[/ end=/\]/ contains=ALL

All syntax items will be contained in this one.  It also contains itself, but
not at the same position (that would cause an endless loop).
   You can specify that some groups are not contained.  Thus contain all
groups but the ones that are listed:
>
	:syntax region xList start=/\[/ end=/\]/ contains=ALLBUT,xString

With the "TOP" item you can include all items that don't have a "contained"
argument.  "CONTAINED" is used to only include items with a "contained"
argument.  See |:syn-contains| for the details.

==============================================================================
*44.6*	Following groups

The x language has statements in this form:

	if (condition) then ~

You want to highlight the three items differently.  But "(condition)" and
"then" might also appear in other places, where they get different
highlighting.  This is how you can do this: >

	:syntax match xIf /if/ nextgroup=xIfCondition skipwhite
	:syntax match xIfCondition /([^)]*)/ contained nextgroup=xThen skipwhite
	:syntax match xThen /then/ contained

The "nextgroup" argument specifies which item can come next.  This is not
required.  If none of the items that are specified are found, nothing happens.
For example, in this text:

	if not (condition) then ~

The "if" is matched by xIf.  "not" doesn't match the specified nextgroup
xIfCondition, thus only the "if" is highlighted.

The "skipwhite" argument tells Vim that white space (spaces and tabs) may
appear in between the items.  Similar arguments are "skipnl", which allows a
line break in between the items, and "skipempty", which allows empty lines.
Notice that "skipnl" doesn't skip an empty line, something must match after
the line break.

==============================================================================
*44.7*	Other arguments

MATCHGROUP

When you define a region, the entire region is highlighted according to the
group name specified.  To highlight the text enclosed in parentheses () with
the group xInside, for example, use the following command: >

	:syntax region xInside start=/(/ end=/)/

Suppose, that you want to highlight the parentheses differently.  You can do
this with a lot of convoluted region statements, or you can use the
"matchgroup" argument.  This tells Vim to highlight the start and end of a
region with a different highlight group (in this case, the xParen group): >

	:syntax region xInside matchgroup=xParen start=/(/ end=/)/

The "matchgroup" argument applies to the start or end match that comes after
it.  In the previous example both start and end are highlighted with xParen.
To highlight the end with xParenEnd: >

	:syntax region xInside matchgroup=xParen start=/(/
		\ matchgroup=xParenEnd end=/)/

A side effect of using "matchgroup" is that contained items will not match in
the start or end of the region.  The example for "transparent" uses this.


TRANSPARENT

In a C language file you would like to highlight the () text after a "while"
differently from the () text after a "for".  In both of these there can be
nested () items, which should be highlighted in the same way.  You must make
sure the () highlighting stops at the matching ).  This is one way to do this:
>
	:syntax region cWhile matchgroup=cWhile start=/while\s*(/ end=/)/
		\ contains=cCondNest
	:syntax region cFor matchgroup=cFor start=/for\s*(/ end=/)/
		\ contains=cCondNest
	:syntax region cCondNest start=/(/ end=/)/ contained transparent

Now you can give cWhile and cFor different highlighting.  The cCondNest item
can appear in either of them, but take over the highlighting of the item it is
contained in.  The "transparent" argument causes this.
   Notice that the "matchgroup" argument has the same group as the item
itself.  Why define it then?  Well, the side effect of using a matchgroup is
that contained items are not found in the match with the start item then.
This avoids that the cCondNest group matches the ( just after the "while" or
"for".  If this would happen, it would span the whole text until the matching
) and the region would continue after it.  Now cCondNest only matches after
the match with the start pattern, thus after the first (.


OFFSETS

Suppose you want to define a region for the text between ( and ) after an
"if".  But you don't want to include the "if" or the ( and ).  You can do this
by specifying offsets for the patterns.  Example: >

	:syntax region xCond start=/if\s*(/ms=e+1 end=/)/me=s-1

The offset for the start pattern is "ms=e+1".  "ms" stands for Match Start.
This defines an offset for the start of the match.  Normally the match starts
where the pattern matches.  "e+1" means that the match now starts at the end
of the pattern match, and then one character further.
   The offset for the end pattern is "me=s-1".  "me" stands for Match End.
"s-1" means the start of the pattern match and then one character back.  The
result is that in this text:

	if (foo == bar) ~

Only the text "foo == bar" will be highlighted as xCond.

More about offsets here: |:syn-pattern-offset|.


ONELINE

The "oneline" argument indicates that the region does not cross a line
boundary.  For example: >

	:syntax region xIfThen start=/if/ end=/then/ oneline

This defines a region that starts at "if" and ends at "then".  But if there is
no "then" after the "if", the region doesn't match.

	Note:
	When using "oneline" the region doesn't start if the end pattern
	doesn't match in the same line.  Without "oneline" Vim does _not_
	check if there is a match for the end pattern.  The region starts even
	when the end pattern doesn't match in the rest of the file.


CONTINUATION LINES AND AVOIDING THEM

Things now become a little more complex.  Let's define a preprocessor line.
This starts with a # in the first column and continues until the end of the
line.  A line that ends with \ makes the next line a continuation line.  The
way you handle this is to allow the syntax item to contain a continuation
pattern: >

	:syntax region xPreProc start=/^#/ end=/$/ contains=xLineContinue
	:syntax match xLineContinue "\\$" contained

In this case, although xPreProc normally matches a single line, the group
contained in it (namely xLineContinue) lets it go on for more than one line.
For example, it would match both of these lines:

	#define SPAM  spam spam spam \ ~
			bacon and spam ~

In this case, this is what you want.  If it is not what you want, you can call
for the region to be on a single line by adding "excludenl" to the contained
pattern.  For example, you want to highlight "end" in xPreProc, but only at
the end of the line.  To avoid making the xPreProc continue on the next line,
like xLineContinue does, use "excludenl" like this: >

	:syntax region xPreProc start=/^#/ end=/$/
		\ contains=xLineContinue,xPreProcEnd
	:syntax match xPreProcEnd excludenl /end$/ contained
	:syntax match xLineContinue "\\$" contained

"excludenl" must be placed before the pattern.  Since "xLineContinue" doesn't
have "excludenl", a match with it will extend xPreProc to the next line as
before.

==============================================================================
*44.8*	Clusters

One of the things you will notice as you start to write a syntax file is that
you wind up generating a lot of syntax groups.  Vim enables you to define a
collection of syntax groups called a cluster.
   Suppose you have a language that contains for loops, if statements, while
loops, and functions.  Each of them contains the same syntax elements: numbers
and identifiers.  You define them like this: >

	:syntax match xFor /^for.*/ contains=xNumber,xIdent
	:syntax match xIf /^if.*/ contains=xNumber,xIdent
	:syntax match xWhile /^while.*/ contains=xNumber,xIdent

You have to repeat the same "contains=" every time.  If you want to add
another contained item, you have to add it three times.  Syntax clusters
simplify these definitions by enabling you to have one cluster stand for
several syntax groups.
   To define a cluster for the two items that the three groups contain, use
the following command: >

	:syntax cluster xState contains=xNumber,xIdent

Clusters are used inside other syntax items just like any syntax group.
Their names start with @.  Thus, you can define the three groups like this: >

	:syntax match xFor /^for.*/ contains=@xState
	:syntax match xIf /^if.*/ contains=@xState
	:syntax match xWhile /^while.*/ contains=@xState

You can add new group names to this cluster with the "add" argument: >

	:syntax cluster xState add=xString

You can remove syntax groups from this list as well: >

	:syntax cluster xState remove=xNumber

==============================================================================
*44.9*	Including another syntax file

The C++ language syntax is a superset of the C language.  Because you do not
want to write two syntax files, you can have the C++ syntax file read in the
one for C by using the following command: >

	:runtime! syntax/c.vim

The ":runtime!" command searches 'runtimepath' for all "syntax/c.vim" files.
This makes the C parts of the C++ syntax be defined like for C files.  If you
have replaced the c.vim syntax file, or added items with an extra file, these
will be loaded as well.
   After loading the C syntax items the specific C++ items can be defined.
For example, add keywords that are not used in C: >

	:syntax keyword cppStatement	new delete this friend using

This works just like in any other syntax file.

Now consider the Perl language.  A Perl script consists of two distinct parts:
a documentation section in POD format, and a program written in Perl itself.
The POD section starts with "=head" and ends with "=cut".
   You want to define the POD syntax in one file, and use it from the Perl
syntax file.  The ":syntax include" command reads in a syntax file and stores
the elements it defined in a syntax cluster.  For Perl, the statements are as
follows: >

	:syntax include @Pod <sfile>:p:h/pod.vim
	:syntax region perlPOD start=/^=head/ end=/^=cut/ contains=@Pod

When "=head" is found in a Perl file, the perlPOD region starts.  In this
region the @Pod cluster is contained.  All the items defined as top-level
items in the pod.vim syntax files will match here.  When "=cut" is found, the
region ends and we go back to the items defined in the Perl file.
   The ":syntax include" command is clever enough to ignore a ":syntax clear"
command in the included file.  And an argument such as "contains=ALL" will
only contain items defined in the included file, not in the file that includes
it.
   The "<sfile>:p:h/" part uses the name of the current file (<sfile>),
expands it to a full path (:p) and then takes the head (:h).  This results in
the directory name of the file.  This causes the pod.vim file in the same
directory to be included.

==============================================================================
*44.10*	Synchronizing

Compilers have it easy.  They start at the beginning of a file and parse it
straight through.  Vim does not have it so easy.  It must start in the middle,
where the editing is being done.  So how does it tell where it is?
   The secret is the ":syntax sync" command.  This tells Vim how to figure out
where it is.  For example, the following command tells Vim to scan backward
for the beginning or end of a C-style comment and begin syntax coloring from
there: >

	:syntax sync ccomment

You can tune this processing with some arguments.  The "minlines" argument
tells Vim the minimum number of lines to look backward, and "maxlines" tells
the editor the maximum number of lines to scan.
   For example, the following command tells Vim to look at least 10 lines
before the top of the screen: >

	:syntax sync ccomment minlines=10 maxlines=500

If it cannot figure out where it is in that space, it starts looking farther
and farther back until it figures out what to do.  But it looks no farther
back than 500 lines.  (A large "maxlines" slows down processing.  A small one
might cause synchronization to fail.)
   To make synchronizing go a bit faster, tell Vim which syntax items can be
skipped.  Every match and region that only needs to be used when actually
displaying text can be given the "display" argument.
   By default, the comment to be found will be colored as part of the Comment
syntax group.  If you want to color things another way, you can specify a
different syntax group: >

	:syntax sync ccomment xAltComment

If your programming language does not have C-style comments in it, you can try
another method of synchronization.  The simplest way is to tell Vim to space
back a number of lines and try to figure out things from there.  The following
command tells Vim to go back 150 lines and start parsing from there: >

	:syntax sync minlines=150

A large "minlines" value can make Vim slower, especially when scrolling
backwards in the file.
   Finally, you can specify a syntax group to look for by using this command:
>
	:syntax sync match {sync-group-name}
		\ grouphere {group-name} {pattern}

This tells Vim that when it sees {pattern} the syntax group named {group-name}
begins just after the pattern given.  The {sync-group-name} is used to give a
name to this synchronization specification.  For example, the sh scripting
language begins an if statement with "if" and ends it with "fi":

	if [ --f file.txt ] ; then ~
		echo "File exists" ~
	fi ~

To define a "grouphere" directive for this syntax, you use the following
command: >

	:syntax sync match shIfSync grouphere shIf "\<if\>"

The "groupthere" argument tells Vim that the pattern ends a group.  For
example, the end of the if/fi group is as follows: >

	:syntax sync match shIfSync groupthere NONE "\<fi\>"

In this example, the NONE tells Vim that you are not in any special syntax
region.  In particular, you are not inside an if block.

You also can define matches and regions that are with no "grouphere" or
"groupthere" arguments.  These groups are for syntax groups skipped during
synchronization.  For example, the following skips over anything inside {},
even if it would normally match another synchronization method: >

	:syntax sync match xSpecial /{.*}/

More about synchronizing in the reference manual: |:syn-sync|.

==============================================================================
*44.11*	Installing a syntax file

When your new syntax file is ready to be used, drop it in a "syntax" directory
in 'runtimepath'.  For Unix that would be "~/.vim/syntax".
  The name of the syntax file must be equal to the file type, with ".vim"
added.  Thus for the x language, the full path of the file would be:

	~/.vim/syntax/x.vim ~

You must also make the file type be recognized.  See |43.2|.

If your file works well, you might want to make it available to other Vim
users.  First read the next section to make sure your file works well for
others.  Then e-mail it to the Vim maintainer: <maintainer@vim.org>.  Also
explain how the filetype can be detected.  With a bit of luck your file will
be included in the next Vim version!


ADDING TO AN EXISTING SYNTAX FILE

We were assuming you were adding a completely new syntax file.  When an existing
syntax file works, but is missing some items, you can add items in a separate
file.  That avoids changing the distributed syntax file, which will be lost
when installing a new version of Vim.
   Write syntax commands in your file, possibly using group names from the
existing syntax.  For example, to add new variable types to the C syntax file:
>
	:syntax keyword cType off_t uint

Write the file with the same name as the original syntax file.  In this case
"c.vim".  Place it in a directory near the end of 'runtimepath'.  This makes
it loaded after the original syntax file.  For Unix this would be:

	~/.vim/after/syntax/c.vim ~

==============================================================================
*44.12*	Portable syntax file layout

Wouldn't it be nice if all Vim users exchange syntax files?  To make this
possible, the syntax file must follow a few guidelines.

Start with a header that explains what the syntax file is for, who maintains
it and when it was last updated.  Don't include too much information about
changes history, not many people will read it.  Example: >

	" Vim syntax file
	" Language:	C
	" Maintainer:	Bram Moolenaar <Bram@vim.org>
	" Last Change:	2001 Jun 18
	" Remark:	Included by the C++ syntax.

Use the same layout as the other syntax files.  Using an existing syntax file
as an example will save you a lot of time.

Choose a good, descriptive name for your syntax file.  Use lowercase letters
and digits.  Don't make it too long, it is used in many places: The name of
the syntax file "name.vim", 'filetype', b:current_syntax and the start of each
syntax group (nameType, nameStatement, nameString, etc).

Start with a check for "b:current_syntax".  If it is defined, some other
syntax file, earlier in 'runtimepath' was already loaded: >

	if exists("b:current_syntax")
	  finish
	endif

Set "b:current_syntax" to the name of the syntax at the end.  Don't forget
that included files do this too, you might have to reset "b:current_syntax" if
you include two files.

Do not include anything that is a user preference.  Don't set 'tabstop',
'expandtab', etc.  These belong in a filetype plugin.

Do not include mappings or abbreviations.  Only include setting 'iskeyword' if
it is really necessary for recognizing keywords.

To allow users select their own preferred colors, make a different group name
for every kind of highlighted item.  Then link each of them to one of the
standard highlight groups.  That will make it work with every color scheme.
If you select specific colors it will look bad with some color schemes.  And
don't forget that some people use a different background color, or have only
eight colors available.

For the linking use "hi def link", so that the user can select different
highlighting before your syntax file is loaded.  Example: >

	  hi def link nameString	String
	  hi def link nameNumber	Number
	  hi def link nameCommand	Statement
	  ... etc ...

Add the "display" argument to items that are not used when syncing, to speed
up scrolling backwards and CTRL-L.

==============================================================================

Next chapter: |usr_45.txt|  Select your language

Copyright: see |manual-copyright|  vim:tw=78:ts=8:noet:ft=help:norl:
                                                                                                                                                                                                                                            usr/share/vim/vim90/doc/usr_45.txt                                                                  0000644 0000000 0000000 00000042420 14424703754 015361  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        *usr_45.txt*	For Vim version 9.0.  Last change: 2022 May 13

		     VIM USER MANUAL - by Bram Moolenaar

			Select your language (locale)


The messages in Vim can be given in several languages.  This chapter explains
how to change which one is used.  Also, the different ways to work with files
in various languages is explained.

|45.1|	Language for Messages
|45.2|	Language for Menus
|45.3|	Using another encoding
|45.4|	Editing files with a different encoding
|45.5|	Entering language text

     Next chapter: |usr_50.txt|  Advanced Vim script writing
 Previous chapter: |usr_44.txt|  Your own syntax highlighted
Table of contents: |usr_toc.txt|

==============================================================================
*45.1*	Language for Messages

When you start Vim, it checks the environment to find out what language you
are using.  Mostly this should work fine, and you get the messages in your
language (if they are available).  To see what the current language is, use
this command: >

	:language

If it replies with "C", this means the default is being used, which is
English.

	Note:
	Using different languages only works when Vim was compiled to handle
	it.  To find out if it works, use the ":version" command and check the
	output for "+gettext" and "+multi_lang".  If they are there, you are
	OK.  If you see "-gettext" or "-multi_lang" you will have to find
	another Vim.

What if you would like your messages in a different language?  There are
several ways.  Which one you should use depends on the capabilities of your
system.
   The first way is to set the environment to the desired language before
starting Vim.  Example for Unix: >

	env LANG=de_DE.ISO_8859-1  vim

This only works if the language is available on your system.  The advantage is
that all the GUI messages and things in libraries will use the right language
as well.  A disadvantage is that you must do this before starting Vim.  If you
want to change language while Vim is running, you can use the second method: >

	:language fr_FR.ISO_8859-1

This way you can try out several names for your language.  You will get an
error message when it's not supported on your system.  You don't get an error
when translated messages are not available.  Vim will silently fall back to
using English.
   To find out which languages are supported on your system, find the
directory where they are listed.  On my system it is "/usr/share/locale".  On
some systems it's in "/usr/lib/locale".  The manual page for "setlocale"
should give you a hint where it is found on your system.
   Be careful to type the name exactly as it should be.  Upper and lowercase
matter, and the '-' and '_' characters are easily confused.

You can also set the language separately for messages, edited text and the
time format.  See |:language|.


DO-IT-YOURSELF MESSAGE TRANSLATION

If translated messages are not available for your language, you could write
them yourself.  To do this, get the source code for Vim and the GNU gettext
package.  After unpacking the sources, instructions can be found in the
directory src/po/README.txt.
   It's not too difficult to do the translation.  You don't need to be a
programmer.  You must know both English and the language you are translating
to, of course.
   When you are satisfied with the translation, consider making it available
to others.  Upload it at vim-online (http://vim.sf.net) or e-mail it to
the Vim maintainer <maintainer@vim.org>.  Or both.

==============================================================================
*45.2*	Language for Menus

The default menus are in English.  To be able to use your local language, they
must be translated.  Normally this is automatically done for you if the
environment is set for your language, just like with messages.  You don't need
to do anything extra for this.  But it only works if translations for the
language are available.
   Suppose you are in Germany, with the language set to German, but prefer to
use "File" instead of "Datei".  You can switch back to using the English menus
this way: >

	:set langmenu=none

It is also possible to specify a language: >

	:set langmenu=nl_NL.ISO_8859-1

Like above, differences between "-" and "_" matter.  However, upper/lowercase
differences are ignored here.
   The 'langmenu' option must be set before the menus are loaded.  Once the
menus have been defined changing 'langmenu' has no direct effect.  Therefore,
put the command to set 'langmenu' in your vimrc file.
   If you really want to switch menu language while running Vim, you can do it
this way: >

	:source $VIMRUNTIME/delmenu.vim
	:set langmenu=de_DE.ISO_8859-1
	:source $VIMRUNTIME/menu.vim

There is one drawback: All menus that you defined yourself will be gone.  You
will need to redefine them as well.


DO-IT-YOURSELF MENU TRANSLATION

To see which menu translations are available, look in this directory:

	$VIMRUNTIME/lang ~

The files are called menu_{language}.vim.  If you don't see the language you
want to use, you can do your own translations.  The simplest way to do this is
by copying one of the existing language files, and change it.
   First find out the name of your language with the ":language" command.  Use
this name, but with all letters made lowercase.  Then copy the file to your
own runtime directory, as found early in 'runtimepath'.  For example, for Unix
you would do: >

	:!cp $VIMRUNTIME/lang/menu_ko_kr.euckr.vim ~/.vim/lang/menu_nl_be.iso_8859-1.vim

You will find hints for the translation in "$VIMRUNTIME/lang/README.txt".

==============================================================================
*45.3*	Using another encoding

Vim guesses that the files you are going to edit are encoded for your
language.  For many European languages this is "latin1".  Then each byte is
one character.  That means there are 256 different characters possible.  For
Asian languages this is not sufficient.  These mostly use a double-byte
encoding, providing for over ten thousand possible characters.  This still
isn't enough when a text is to contain several different languages.  This is
where Unicode comes in.  It was designed to include all characters used in
commonly used languages.  This is the "Super encoding that replaces all
others".  But it isn't used that much yet.
   Fortunately, Vim supports these three kinds of encodings.  And, with some
restrictions, you can use them even when your environment uses another
language than the text.
   Nevertheless, when you only edit files that are in the encoding of your
language, the default should work fine and you don't need to do anything.  The
following is only relevant when you want to edit different languages.


USING UNICODE IN THE GUI

The nice thing about Unicode is that other encodings can be converted to it
and back without losing information.  When you make Vim use Unicode
internally, you will be able to edit files in any encoding.
   Unfortunately, the number of systems supporting Unicode is still limited.
Thus it's unlikely that your language uses it.  You need to tell Vim you want
to use Unicode, and how to handle interfacing with the rest of the system.
   Let's start with the GUI version of Vim, which is able to display Unicode
characters.  This should work: >

	:set encoding=utf-8
	:set guifont=-misc-fixed-medium-r-normal--18-120-100-100-c-90-iso10646-1

The 'encoding' option tells Vim the encoding of the characters that you use.
This applies to the text in buffers (files you are editing), registers, Vim
script files, etc.  You can regard 'encoding' as the setting for the internals
of Vim.
   This example assumes you have this font on your system.  The name in the
example is for the X Window System.  This font is in a package that is used to
enhance xterm with Unicode support.  If you don't have this font, you might
find it here:

	http://www.cl.cam.ac.uk/~mgk25/download/ucs-fonts.tar.gz ~

For MS-Windows, some fonts have a limited number of Unicode characters.  Try
using the "Courier New" font.  You can use the Edit/Select Font... menu to
select and try out the fonts available.  Only fixed-width fonts can be used
though.  Example: >

	:set guifont=courier_new:h12

If it doesn't work well, try getting a fontpack.  If Microsoft didn't move it,
you can find it here:

	http://www.microsoft.com/typography/fonts/default.aspx ~

Now you have told Vim to use Unicode internally and display text with a
Unicode font.  Typed characters still arrive in the encoding of your original
language.  This requires converting them to Unicode.  Tell Vim the language
from which to convert with the 'termencoding' option.  You can do it like
this: >

	:let &termencoding = &encoding
	:set encoding=utf-8

This assigns the old value of 'encoding' to 'termencoding' before setting
'encoding' to utf-8.  You will have to try out if this really works for your
setup.  It should work especially well when using an input method for an Asian
language, and you want to edit Unicode text.


USING UNICODE IN A UNICODE TERMINAL

There are terminals that support Unicode directly.  The standard xterm that
comes with XFree86 is one of them.  Let's use that as an example.
   First of all, the xterm must have been compiled with Unicode support.  See
|UTF8-xterm| how to check that and how to compile it when needed.
   Start the xterm with the "-u8" argument.  You might also need so specify a
font.  Example: >

   xterm -u8 -fn -misc-fixed-medium-r-normal--18-120-100-100-c-90-iso10646-1

Now you can run Vim inside this terminal.  Set 'encoding' to "utf-8" as
before.  That's all.


USING UNICODE IN AN ORDINARY TERMINAL

Suppose you want to work with Unicode files, but don't have a terminal with
Unicode support.  You can do this with Vim, although characters that are not
supported by the terminal will not be displayed.  The layout of the text
will be preserved.  >

	:let &termencoding = &encoding
	:set encoding=utf-8

This is the same as what was used for the GUI.  But it works differently: Vim
will convert the displayed text before sending it to the terminal.  That
avoids that the display is messed up with strange characters.
   For this to work the conversion between 'termencoding' and 'encoding' must
be possible.  Vim will convert from latin1 to Unicode, thus that always works.
For other conversions the |+iconv| feature is required.
   Try editing a file with Unicode characters in it.  You will notice that Vim
will put a question mark (or underscore or some other character) in places
where a character should be that the terminal can't display.  Move the cursor
to a question mark and use this command: >

	ga

Vim will display a line with the code of the character.  This gives you a hint
about what character it is.  You can look it up in a Unicode table.  You could
actually view a file that way, if you have lots of time at hand.

	Note:
	Since 'encoding' is used for all text inside Vim, changing it makes
	all non-ASCII text invalid.  You will notice this when using registers
	and the 'viminfo' file (e.g., a remembered search pattern).  It's
	recommended to set 'encoding' in your vimrc file, and leave it alone.

==============================================================================
*45.4*	Editing files with a different encoding

Suppose you have setup Vim to use Unicode, and you want to edit a file that is
in 16-bit Unicode.  Sounds simple, right?  Well, Vim actually uses utf-8
encoding internally, thus the 16-bit encoding must be converted, since there
is a difference between the character set (Unicode) and the encoding (utf-8 or
16-bit).
   Vim will try to detect what kind of file you are editing.  It uses the
encoding names in the 'fileencodings' option.  When using Unicode, the default
value is: "ucs-bom,utf-8,latin1".  This means that Vim checks the file to see
if it's one of these encodings:

	ucs-bom		File must start with a Byte Order Mark (BOM).  This
			allows detection of 16-bit, 32-bit and utf-8 Unicode
			encodings.
	utf-8		utf-8 Unicode.  This is rejected when a sequence of
			bytes is illegal in utf-8.
	latin1		The good old 8-bit encoding.  Always works.

When you start editing that 16-bit Unicode file, and it has a BOM, Vim will
detect this and convert the file to utf-8 when reading it.  The 'fileencoding'
option (without s at the end) is set to the detected value.  In this case it
is "utf-16le".  That means it's Unicode, 16-bit and little-endian.  This
file format is common on MS-Windows (e.g., for registry files).
   When writing the file, Vim will compare 'fileencoding' with 'encoding'.  If
they are different, the text will be converted.
   An empty value for 'fileencoding' means that no conversion is to be done.
Thus the text is assumed to be encoded with 'encoding'.

If the default 'fileencodings' value is not good for you, set it to the
encodings you want Vim to try.  Only when a value is found to be invalid will
the next one be used.  Putting "latin1" first doesn't work, because it is
never illegal.  An example, to fall back to Japanese when the file doesn't
have a BOM and isn't utf-8: >

	:set fileencodings=ucs-bom,utf-8,sjis

See |encoding-values| for suggested values.  Other values may work as well.
This depends on the conversion available.


FORCING AN ENCODING

If the automatic detection doesn't work you must tell Vim what encoding the
file is.  Example: >

	:edit ++enc=koi8-r russian.txt

The "++enc" part specifies the name of the encoding to be used for this file
only.  Vim will convert the file from the specified encoding, Russian in this
example, to 'encoding'.  'fileencoding' will also be set to the specified
encoding, so that the reverse conversion can be done when writing the file.
   The same argument can be used when writing the file.  This way you can
actually use Vim to convert a file.  Example: >

	:write ++enc=utf-8 russian.txt
<
	Note:
	Conversion may result in lost characters.  Conversion from an encoding
	to Unicode and back is mostly free of this problem, unless there are
	illegal characters.  Conversion from Unicode to other encodings often
	loses information when there was more than one language in the file.

==============================================================================
*45.5*	Entering language text

Computer keyboards don't have much more than a hundred keys.  Some languages
have thousands of characters, Unicode has over hundred thousand.  So how do
you type these characters?
   First of all, when you don't use too many of the special characters, you
can use digraphs.  This was already explained in |24.9|.
   When you use a language that uses many more characters than keys on your
keyboard, you will want to use an Input Method (IM).  This requires learning
the translation from typed keys to resulting character.  When you need an IM
you probably already have one on your system.  It should work with Vim like
with other programs.  For details see |mbyte-XIM| for the X Window system and
|mbyte-IME| for MS-Windows.


KEYMAPS

For some languages the character set is different from latin, but uses a
similar number of characters.  It's possible to map keys to characters.  Vim
uses keymaps for this.
   Suppose you want to type Hebrew.  You can load the keymap like this: >

	:set keymap=hebrew

Vim will try to find a keymap file for you.  This depends on the value of
'encoding'.  If no matching file was found, you will get an error message.

Now you can type Hebrew in Insert mode.  In Normal mode, and when typing a ":"
command, Vim automatically switches to English.  You can use this command to
switch between Hebrew and English: >

	CTRL-^

This only works in Insert mode and Command-line mode.  In Normal mode it does
something completely different (jumps to alternate file).
   The usage of the keymap is indicated in the mode message, if you have the
'showmode' option set.  In the GUI Vim will indicate the usage of keymaps with
a different cursor color.
   You can also change the usage of the keymap with the 'iminsert' and
'imsearch' options.

To see the list of mappings, use this command: >

	:lmap

To find out which keymap files are available, in the GUI you can use the
Edit/Keymap menu.  Otherwise you can use this command: >

	:echo globpath(&rtp, "keymap/*.vim")


DO-IT-YOURSELF KEYMAPS

You can create your own keymap file.  It's not very difficult.  Start with
a keymap file that is similar to the language you want to use.  Copy it to the
"keymap" directory in your runtime directory.  For example, for Unix, you
would use the directory "~/.vim/keymap".
   The name of the keymap file must look like this:

	keymap/{name}.vim ~
or
	keymap/{name}_{encoding}.vim ~

{name} is the name of the keymap.  Chose a name that is obvious, but different
from existing keymaps (unless you want to replace an existing keymap file).
{name} cannot contain an underscore.  Optionally, add the encoding used after
an underscore.  Examples:

	keymap/hebrew.vim ~
	keymap/hebrew_utf-8.vim ~

The contents of the file should be self-explanatory.  Look at a few of the
keymaps that are distributed with Vim.  For the details, see |mbyte-keymap|.


LAST RESORT

If all other methods fail, you can enter any character with CTRL-V:

	encoding   type			range ~
	8-bit	   CTRL-V 123		decimal 0-255
	8-bit	   CTRL-V x a1		hexadecimal 00-ff
	16-bit     CTRL-V u 013b	hexadecimal 0000-ffff
	31-bit	   CTRL-V U 001303a4	hexadecimal 00000000-7fffffff

Don't type the spaces.  See |i_CTRL-V_digit| for the details.

==============================================================================

Next chapter: |usr_50.txt|  Advanced Vim script writing

Copyright: see |manual-copyright|  vim:tw=78:ts=8:noet:ft=help:norl:
                                                                                                                                                                                                                                                usr/share/vim/vim90/doc/usr_50.txt                                                                  0000644 0000000 0000000 00000010712 14424703754 015354  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        *usr_50.txt*	For Vim version 9.0.  Last change: 2022 Jun 20

		     VIM USER MANUAL - by Bram Moolenaar

			 Advanced Vim script writing


|50.1|	Exceptions
|50.2|	Function with variable number of arguments
|50.3|	Restoring the view

     Next chapter: |usr_51.txt|  Create a plugin
 Previous chapter: |usr_45.txt|  Select your language (local)
Table of contents: |usr_toc.txt|

==============================================================================
*50.1*	Exceptions

Let's start with an example: >

	try
	   read ~/templates/pascal.tmpl
	catch /E484:/
	   echo "Sorry, the Pascal template file cannot be found."
	endtry

The `read` command will fail if the file does not exist.  Instead of
generating an error message, this code catches the error and gives the user a
message with more information.

For the commands in between `try` and `endtry` errors are turned into
exceptions.  An exception is a string.  In the case of an error the string
contains the error message.  And every error message has a number.  In this
case, the error we catch contains "E484:".  This number is guaranteed to stay
the same (the text may change, e.g., it may be translated).

Besides being able to give a nice error message, Vim will also continue
executing commands after the `:endtry`.  Otherwise, once an uncaught error is
encountered, execution of the script/function/mapping will be aborted.

When the `read` command causes another error, the pattern "E484:" will not
match in it.  Thus this exception will not be caught and result in the usual
error message and execution is aborted.

You might be tempted to do this: >

	try
	   read ~/templates/pascal.tmpl
	catch
	   echo "Sorry, the Pascal template file cannot be found."
	endtry

This means all errors are caught.  But then you will not see an error that
would indicate a completely different problem, such as "E21: Cannot make
changes, 'modifiable' is off".  Think twice before you catch any error!

Another useful mechanism is the `finally` command: >

	var tmp = tempname()
	try
	   exe ":.,$write " .. tmp
	   exe "!filter " .. tmp
	   :.,$delete
	   exe ":$read " .. tmp
	finally
	   delete(tmp)
	endtry

This filters the lines from the cursor until the end of the file through the
"filter" command, which takes a file name argument.  No matter if the
filtering works, if something goes wrong in between `try` and `finally` or the
user cancels the filtering by pressing CTRL-C, the `delete(tmp)` call is
always executed.  This makes sure you don't leave the temporary file behind.

The `finally` does not catch the exception, the error will still abort
further execution.

More information about exception handling can be found in the reference
manual: |exception-handling|.

==============================================================================
*50.2*	Function with variable number of arguments

Vim enables you to define functions that have a variable number of arguments.
The following command, for instance, defines a function that must have 1
argument (start) and can have up to 20 additional arguments: >

	def Show(start: string, ...items: list<string>)

The variable "items" will be a list in the function containing the extra
arguments.  You can use it like any list, for example: >

	def Show(start: string, ...items: list<string>)
	  echohl Title
	  echo "start is " .. start
	  echohl None
	  for index in range(len(items))
	    echon $"  Arg {index} is {items[index]}"
	  endfor
	  echo
	enddef

You can call it like this: >

	Show('Title', 'one', 'two', 'three')
<	start is Title  Arg 0 is one  Arg 1 is two  Arg 2 is three ~

This uses the `echohl` command to specify the highlighting used for the
following `echo` command.  `echohl None` stops it again.  The `echon` command
works like `echo`, but doesn't output a line break.

