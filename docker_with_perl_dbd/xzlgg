=head2 Compile-time Output

The debugging output at compile time looks like this:

  Compiling REx '[bc]d(ef*g)+h[ij]k$'
  size 45 Got 364 bytes for offset annotations.
  first at 1
  rarest char g at 0
  rarest char d at 0
     1: ANYOF[bc](12)
    12: EXACT <d>(14)
    14: CURLYX[0] {1,32767}(28)
    16:   OPEN1(18)
    18:     EXACT <e>(20)
    20:     STAR(23)
    21:       EXACT <f>(0)
    23:     EXACT <g>(25)
    25:   CLOSE1(27)
    27:   WHILEM[1/1](0)
    28: NOTHING(29)
    29: EXACT <h>(31)
    31: ANYOF[ij](42)
    42: EXACT <k>(44)
    44: EOL(45)
    45: END(0)
  anchored 'de' at 1 floating 'gh' at 3..2147483647 (checking floating) 
        stclass 'ANYOF[bc]' minlen 7 
  Offsets: [45]
  	1[4] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 5[1]
  	0[0] 12[1] 0[0] 6[1] 0[0] 7[1] 0[0] 9[1] 8[1] 0[0] 10[1] 0[0]
  	11[1] 0[0] 12[0] 12[0] 13[1] 0[0] 14[4] 0[0] 0[0] 0[0] 0[0]
  	0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 18[1] 0[0] 19[1] 20[0]  
  Omitting $` $& $' support.

The first line shows the pre-compiled form of the regex.  The second
shows the size of the compiled form (in arbitrary units, usually
4-byte words) and the total number of bytes allocated for the
offset/length table, usually 4+C<size>*8.  The next line shows the
label I<id> of the first node that does a match.

The 

  anchored 'de' at 1 floating 'gh' at 3..2147483647 (checking floating) 
        stclass 'ANYOF[bc]' minlen 7 

line (split into two lines above) contains optimizer
information.  In the example shown, the optimizer found that the match 
should contain a substring C<de> at offset 1, plus substring C<gh>
at some offset between 3 and infinity.  Moreover, when checking for
these substrings (to abandon impossible matches quickly), Perl will check
for the substring C<gh> before checking for the substring C<de>.  The
optimizer may also use the knowledge that the match starts (at the
C<first> I<id>) with a character class, and no string 
shorter than 7 characters can possibly match.

The fields of interest which may appear in this line are

=over 4

=item C<anchored> I<STRING> C<at> I<POS>

=item C<floating> I<STRING> C<at> I<POS1..POS2>

See above.

=item C<matching floating/anchored>

Which substring to check first.

=item C<minlen>

The minimal length of the match.

=item C<stclass> I<TYPE>

Type of first matching node.

=item C<noscan>

Don't scan for the found substrings.

=item C<isall>

Means that the optimizer information is all that the regular
expression contains, and thus one does not need to enter the regex engine at
all.

=item C<GPOS>

Set if the pattern contains C<\G>.

=item C<plus> 

Set if the pattern starts with a repeated char (as in C<x+y>).

=item C<implicit>

Set if the pattern starts with C<.*>.

=item C<with eval> 

Set if the pattern contain eval-groups, such as C<(?{ code })> and
C<(??{ code })>.

=item C<anchored(TYPE)>

If the pattern may match only at a handful of places, with C<TYPE>
being C<SBOL>, C<MBOL>, or C<GPOS>.  See the table below.

=back

If a substring is known to match at end-of-line only, it may be
followed by C<$>, as in C<floating 'k'$>.

The optimizer-specific information is used to avoid entering (a slow) regex
engine on strings that will not definitely match.  If the C<isall> flag
is set, a call to the regex engine may be avoided even when the optimizer
found an appropriate place for the match.

Above the optimizer section is the list of I<nodes> of the compiled
form of the regex.  Each line has format 

C<   >I<id>: I<TYPE> I<OPTIONAL-INFO> (I<next-id>)

=head2 Types of Nodes

Here are the current possible types, with short descriptions:

=for comment
This table is generated by regen/regcomp.pl.  Any changes made here
will be lost.

=for regcomp.pl begin

 # TYPE arg-description [regnode-struct-suffix] [longjump-len] DESCRIPTION

 # Exit points

 END              no         End of program.
 SUCCEED          no         Return from a subroutine, basically.

 # Line Start Anchors:
 SBOL             no         Match "" at beginning of line: /^/, /\A/
 MBOL             no         Same, assuming multiline: /^/m

 # Line End Anchors:
 SEOL             no         Match "" at end of line: /$/
 MEOL             no         Same, assuming multiline: /$/m
 EOS              no         Match "" at end of string: /\z/

 # Match Start Anchors:
 GPOS             no         Matches where last m//g left off.

 # Word Boundary Opcodes:
 BOUND            no         Like BOUNDA for non-utf8, otherwise like
                             BOUNDU
 BOUNDL           no         Like BOUND/BOUNDU, but \w and \W are
                             defined by current locale
 BOUNDU           no         Match "" at any boundary of a given type
                             using /u rules.
 BOUNDA           no         Match "" at any boundary between \w\W or
                             \W\w, where \w is [_a-zA-Z0-9]
 NBOUND           no         Like NBOUNDA for non-utf8, otherwise like
                             BOUNDU
 NBOUNDL          no         Like NBOUND/NBOUNDU, but \w and \W are
                             defined by current locale
 NBOUNDU          no         Match "" at any non-boundary of a given
                             type using using /u rules.
 NBOUNDA          no         Match "" betweeen any \w\w or \W\W, where
                             \w is [_a-zA-Z0-9]

 # [Special] alternatives:
 REG_ANY          no         Match any one character (except newline).
 SANY             no         Match any one character.
 ANYOF            sv         Match character in (or not in) this class,
                  charclass  single char match only
 ANYOFD           sv         Like ANYOF, but /d is in effect
                  charclass
 ANYOFL           sv         Like ANYOF, but /l is in effect
                  charclass
 ANYOFPOSIXL      sv         Like ANYOFL, but matches [[:posix:]]
                  charclass_ classes
                  posixl

 ANYOFH           sv 1       Like ANYOF, but only has "High" matches,
                             none in the bitmap; the flags field
                             contains the lowest matchable UTF-8 start
                             byte
 ANYOFHb          sv 1       Like ANYOFH, but all matches share the same
                             UTF-8 start byte, given in the flags field
 ANYOFHr          sv 1       Like ANYOFH, but the flags field contains
                             packed bounds for all matchable UTF-8 start
                             bytes.
 ANYOFHs          sv:str 1   Like ANYOFHb, but has a string field that
                             gives the leading matchable UTF-8 bytes;
                             flags field is len
 ANYOFR           packed 1   Matches any character in the range given by
                             its packed args: upper 12 bits is the max
                             delta from the base lower 20; the flags
                             field contains the lowest matchable UTF-8
                             start byte
 ANYOFRb          packed 1   Like ANYOFR, but all matches share the same
                             UTF-8 start byte, given in the flags field

 ANYOFHbbm        none bbm   Like ANYOFHb, but only for 2-byte UTF-8
                             characters; uses a bitmap to match the
                             continuation byte

 ANYOFM           byte 1     Like ANYOF, but matches an invariant byte
                             as determined by the mask and arg
 NANYOFM          byte 1     complement of ANYOFM

 # POSIX Character Classes:
 POSIXD           none       Some [[:class:]] under /d; the FLAGS field
                             gives which one
 POSIXL           none       Some [[:class:]] under /l; the FLAGS field
                             gives which one
 POSIXU           none       Some [[:class:]] under /u; the FLAGS field
                             gives which one
 POSIXA           none       Some [[:class:]] under /a; the FLAGS field
                             gives which one
 NPOSIXD          none       complement of POSIXD, [[:^class:]]
 NPOSIXL          none       complement of POSIXL, [[:^class:]]
 NPOSIXU          none       complement of POSIXU, [[:^class:]]
 NPOSIXA          none       complement of POSIXA, [[:^class:]]

 CLUMP            no         Match any extended grapheme cluster
                             sequence

 # Alternation

 # BRANCH        The set of branches constituting a single choice are
 #               hooked together with their "next" pointers, since
 #               precedence prevents anything being concatenated to
 #               any individual branch.  The "next" pointer of the last
 #               BRANCH in a choice points to the thing following the
 #               whole choice.  This is also where the final "next"
 #               pointer of each individual branch points; each branch
 #               starts with the operand node of a BRANCH node.
 #
 BRANCH           node 1     Match this alternative, or the next...

 # Literals

 EXACT            str        Match this string (flags field is the
                             length).

 # In a long string node, the U32 argument is the length, and is
 # immediately followed by the string.
 LEXACT           len:str 1  Match this long string (preceded by length;
                             flags unused).
 EXACTL           str        Like EXACT, but /l is in effect (used so
                             locale-related warnings can be checked for)
 EXACTF           str        Like EXACT, but match using /id rules;
                             (string not UTF-8, ASCII folded; non-ASCII
                             not)
 EXACTFL          str        Like EXACT, but match using /il rules;
                             (string not likely to be folded)
 EXACTFU          str        Like EXACT, but match using /iu rules;
                             (string folded)

 EXACTFAA         str        Like EXACT, but match using /iaa rules;
                             (string folded except MICRO in non-UTF8
                             patterns; doesn't contain SHARP S unless
                             UTF-8; folded length <= unfolded)
 EXACTFAA_NO_TRIE str        Like EXACTFAA, (string not UTF-8, folded
                             except: MICRO, SHARP S; folded length <=
                             unfolded, not currently trie-able)

 EXACTFUP         str        Like EXACT, but match using /iu rules;
                             (string not UTF-8, folded except MICRO:
                             hence Problematic)

 EXACTFLU8        str        Like EXACTFU, but use /il, UTF-8, (string
                             is folded, and everything in it is above
                             255
 EXACT_REQ8       str        Like EXACT, but only UTF-8 encoded targets
                             can match
 LEXACT_REQ8      len:str 1  Like LEXACT, but only UTF-8 encoded targets
                             can match
 EXACTFU_REQ8     str        Like EXACTFU, but only UTF-8 encoded
                             targets can match

 EXACTFU_S_EDGE   str        /di rules, but nothing in it precludes /ui,
                             except begins and/or ends with [Ss];
                             (string not UTF-8; compile-time only)

 # New charclass like patterns
 LNBREAK          none       generic newline pattern

 # Trie Related

 # Behave the same as A|LIST|OF|WORDS would. The '..C' variants
 # have inline charclass data (ascii only), the 'C' store it in the
 # structure.

 TRIE             trie 1     Match many EXACT(F[ALU]?)? at once.
                             flags==type
 TRIEC            trie       Same as TRIE, but with embedded charclass
                  charclass  data

 AHOCORASICK      trie 1     Aho Corasick stclass. flags==type
 AHOCORASICKC     trie       Same as AHOCORASICK, but with embedded
                  charclass  charclass data

 # Do nothing types

 NOTHING          no         Match empty string.
 # A variant of above which delimits a group, thus stops optimizations
 TAIL             no         Match empty string. Can jump here from
                             outside.

 # Loops

 # STAR,PLUS    '?', and complex '*' and '+', are implemented as
 #               circular BRANCH structures.  Simple cases
 #               (one character per match) are implemented with STAR
 #               and PLUS for speed and to minimize recursive plunges.
 #
 STAR             node       Match this (simple) thing 0 or more times:
                             /A{0,}B/ where A is width 1 char
 PLUS             node       Match this (simple) thing 1 or more times:
                             /A{1,}B/ where A is width 1 char

 CURLY            sv 3       Match this (simple) thing {n,m} times:
                             /A{m,n}B/ where A is width 1 char
 CURLYN           no 3       Capture next-after-this simple thing:
                             /(A){m,n}B/ where A is width 1 char
 CURLYM           no 3       Capture this medium-complex thing {n,m}
                             times: /(A){m,n}B/ where A is fixed-length
 CURLYX           sv 3       Match/Capture this complex thing {n,m}
                             times.

 # This terminator creates a loop structure for CURLYX
 WHILEM           no         Do curly processing and see if rest
                             matches.

 # Buffer related

 # OPEN,CLOSE,GROUPP     ...are numbered at compile time.
 OPEN             num 1      Mark this point in input as start of #n.
 CLOSE            num 1      Close corresponding OPEN of #n.
 SROPEN           none       Same as OPEN, but for script run
 SRCLOSE          none       Close preceding SROPEN

 REF              num 2      Match some already matched string
 REFF             num 2      Match already matched string, using /di
                             rules.
 REFFL            num 2      Match already matched string, using /li
                             rules.
 REFFU            num 2      Match already matched string, usng /ui.
 REFFA            num 2      Match already matched string, using /aai
                             rules.

 # Named references.  Code in regcomp.c assumes that these all are after
 # the numbered references
 REFN             no-sv 2    Match some already matched string
 REFFN            no-sv 2    Match already matched string, using /di
                             rules.
 REFFLN           no-sv 2    Match already matched string, using /li
                             rules.
 REFFUN           num 2      Match already matched string, using /ui
                             rules.
 REFFAN           num 2      Match already matched string, using /aai
                             rules.

 # Support for long RE
 LONGJMP          off 1 1    Jump far away.
 BRANCHJ          off 2 1    BRANCH with long offset.

 # Special Case Regops
 IFMATCH          off 1 1    Succeeds if the following matches; non-zero
                             flags "f", next_off "o" means lookbehind
                             assertion starting "f..(f-o)" characters
                             before current
 UNLESSM          off 1 1    Fails if the following matches; non-zero
                             flags "f", next_off "o" means lookbehind
                             assertion starting "f..(f-o)" characters
                             before current
 SUSPEND          off 1 1    "Independent" sub-RE.
 IFTHEN           off 1 1    Switch, should be preceded by switcher.
 GROUPP           num 1      Whether the group matched.

 # The heavy worker

 EVAL             evl/flags  Execute some Perl code.
                  2

 # Modifiers

 MINMOD           no         Next operator is not greedy.
 LOGICAL          no         Next opcode should set the flag only.

 # This is not used yet
 RENUM            off 1 1    Group with independently numbered parens.

 # Regex Subroutines
 GOSUB            num/ofs 2  recurse to paren arg1 at (signed) ofs arg2

 # Special conditionals
 GROUPPN          no-sv 1    Whether the group matched.
 INSUBP           num 1      Whether we are in a specific recurse.
 DEFINEP          none 1     Never execute directly.

 # Backtracking Verbs
 ENDLIKE          none       Used only for the type field of verbs
 OPFAIL           no-sv 1    Same as (?!), but with verb arg
 ACCEPT           no-sv/num  Accepts the current matched string, with
                  2          verbar

 # Verbs With Arguments
 VERB             no-sv 1    Used only for the type field of verbs
 PRUNE            no-sv 1    Pattern fails at this startpoint if no-
                             backtracking through this
 MARKPOINT        no-sv 1    Push the current location for rollback by
                             cut.
 SKIP             no-sv 1    On failure skip forward (to the mark)
                             before retrying
 COMMIT           no-sv 1    Pattern fails outright if backtracking
                             through this
 CUTGROUP         no-sv 1    On failure go to the next alternation in
                             the group

 # Control what to keep in $&.
 KEEPS            no         $& begins here.

 # Validate that lookbehind IFMATCH and UNLESSM end at the right place
 LOOKBEHIND_END   no         Return from lookbehind (IFMATCH/UNLESSM)
                             and validate position

 # SPECIAL  REGOPS

 # This is not really a node, but an optimized away piece of a "long"
 # node.  To simplify debugging output, we mark it as if it were a node
 OPTIMIZED        off        Placeholder for dump.

 # Special opcode with the property that no opcode in a compiled program
 # will ever be of this type. Thus it can be used as a flag value that
 # no other opcode has been seen. END is used similarly, in that an END
 # node cant be optimized. So END implies "unoptimizable" and PSEUDO
 # mean "not seen anything to optimize yet".
 PSEUDO           off        Pseudo opcode for internal use.

 REGEX_SET        depth p    Regex set, temporary node used in pre-
                             optimization compilation

=for regcomp.pl end

=for unprinted-credits
Next section M-J. Dominus (mjd-perl-patch+@plover.com) 20010421

Following the optimizer information is a dump of the offset/length
table, here split across several lines:

  Offsets: [45]
  	1[4] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 5[1]
  	0[0] 12[1] 0[0] 6[1] 0[0] 7[1] 0[0] 9[1] 8[1] 0[0] 10[1] 0[0]
  	11[1] 0[0] 12[0] 12[0] 13[1] 0[0] 14[4] 0[0] 0[0] 0[0] 0[0]
  	0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 18[1] 0[0] 19[1] 20[0]  

The first line here indicates that the offset/length table contains 45
entries.  Each entry is a pair of integers, denoted by C<offset[length]>.
Entries are numbered starting with 1, so entry #1 here is C<1[4]> and
entry #12 is C<5[1]>.  C<1[4]> indicates that the node labeled C<1:>
(the C<1: ANYOF[bc]>) begins at character position 1 in the
pre-compiled form of the regex, and has a length of 4 characters.
C<5[1]> in position 12 
indicates that the node labeled C<12:>
(the C<< 12: EXACT <d> >>) begins at character position 5 in the
pre-compiled form of the regex, and has a length of 1 character.
C<12[1]> in position 14 
indicates that the node labeled C<14:>
(the C<< 14: CURLYX[0] {1,32767} >>) begins at character position 12 in the
pre-compiled form of the regex, and has a length of 1 character---that
is, it corresponds to the C<+> symbol in the precompiled regex.

C<0[0]> items indicate that there is no corresponding node.

=head2 Run-time Output

First of all, when doing a match, one may get no run-time output even
if debugging is enabled.  This means that the regex engine was never
entered and that all of the job was therefore done by the optimizer.

If the regex engine was entered, the output may look like this:

  Matching '[bc]d(ef*g)+h[ij]k$' against 'abcdefg__gh__'
    Setting an EVAL scope, savestack=3
     2 <ab> <cdefg__gh_>    |  1: ANYOF
     3 <abc> <defg__gh_>    | 11: EXACT <d>
     4 <abcd> <efg__gh_>    | 13: CURLYX {1,32767}
     4 <abcd> <efg__gh_>    | 26:   WHILEM
				0 out of 1..32767  cc=effff31c
     4 <abcd> <efg__gh_>    | 15:     OPEN1
     4 <abcd> <efg__gh_>    | 17:     EXACT <e>
     5 <abcde> <fg__gh_>    | 19:     STAR
			     EXACT <f> can match 1 times out of 32767...
    Setting an EVAL scope, savestack=3
     6 <bcdef> <g__gh__>    | 22:       EXACT <g>
     7 <bcdefg> <__gh__>    | 24:       CLOSE1
     7 <bcdefg> <__gh__>    | 26:       WHILEM
				    1 out of 1..32767  cc=effff31c
    Setting an EVAL scope, savestack=12
     7 <bcdefg> <__gh__>    | 15:         OPEN1
     7 <bcdefg> <__gh__>    | 17:         EXACT <e>
       restoring \1 to 4(4)..7
				    failed, try continuation...
     7 <bcdefg> <__gh__>    | 27:         NOTHING
     7 <bcdefg> <__gh__>    | 28:         EXACT <h>
				    failed...
				failed...

The most significant information in the output is about the particular I<node>
of the compiled regex that is currently being tested against the target string.
The format of these lines is

C<    >I<STRING-OFFSET> <I<PRE-STRING>> <I<POST-STRING>>   |I<ID>:  I<TYPE>

The I<TYPE> info is indented with respect to the backtracking level.
Other incidental information appears interspersed within.

=head1 Debugging Perl Memory Usage

Perl is a profligate wastrel when it comes to memory use.  There
is a saying that to estimate memory usage of Perl, assume a reasonable
algorithm for memory allocation, multiply that estimate by 10, and
while you still may miss the mark, at least you won't be quite so
astonished.  This is not absolutely true, but may provide a good
grasp of what happens.

Assume that an integer cannot take less than 20 bytes of memory, a
float cannot take less than 24 bytes, a string cannot take less
than 32 bytes (all these examples assume 32-bit architectures, the
result are quite a bit worse on 64-bit architectures).  If a variable
is accessed in two of three different ways (which require an integer,
a float, or a string), the memory footprint may increase yet another
20 bytes.  A sloppy malloc(3) implementation can inflate these
numbers dramatically.

On the opposite end of the scale, a declaration like

  sub foo;

may take up to 500 bytes of memory, depending on which release of Perl
you're running.

Anecdotal estimates of source-to-compiled code bloat suggest an
eightfold increase.  This means that the compiled form of reasonable
(normally commented, properly indented etc.) code will take
about eight times more space in memory than the code took
on disk.

The B<-DL> command-line switch is obsolete since circa Perl 5.6.0
(it was available only if Perl was built with C<-DDEBUGGING>).
The switch was used to track Perl's memory allocations and possible
memory leaks.  These days the use of malloc debugging tools like
F<Purify> or F<valgrind> is suggested instead.  See also
L<perlhacktips/PERL_MEM_LOG>.

One way to find out how much memory is being used by Perl data
structures is to install the Devel::Size module from CPAN: it gives
you the minimum number of bytes required to store a particular data
structure.  Please be mindful of the difference between the size()
and total_size().

If Perl has been compiled using Perl's malloc you can analyze Perl
memory usage by setting $ENV{PERL_DEBUG_MSTATS}.

=head2 Using C<$ENV{PERL_DEBUG_MSTATS}>

If your perl is using Perl's malloc() and was compiled with the
necessary switches (this is the default), then it will print memory
usage statistics after compiling your code when C<< $ENV{PERL_DEBUG_MSTATS}
> 1 >>, and before termination of the program when C<<
$ENV{PERL_DEBUG_MSTATS} >= 1 >>.  The report format is similar to
the following example:

 $ PERL_DEBUG_MSTATS=2 perl -e "require Carp"
 Memory allocation statistics after compilation: (buckets 4(4)..8188(8192)
    14216 free:   130   117    28     7     9   0   2     2   1 0 0
		437    61    36     0     5
    60924 used:   125   137   161    55     7   8   6    16   2 0 1
		 74   109   304    84    20
 Total sbrk(): 77824/21:119. Odd ends: pad+heads+chain+tail: 0+636+0+2048.
 Memory allocation statistics after execution:   (buckets 4(4)..8188(8192)
    30888 free:   245    78    85    13     6   2   1     3   2 0 1
		315   162    39    42    11
   175816 used:   265   176  1112   111    26  22  11    27   2 1 1
		196   178  1066   798    39
 Total sbrk(): 215040/47:145. Odd ends: pad+heads+chain+tail: 0+2192+0+6144.

It is possible to ask for such a statistic at arbitrary points in
your execution using the mstat() function out of the standard
Devel::Peek module.

Here is some explanation of that format:

=over 4

=item C<buckets SMALLEST(APPROX)..GREATEST(APPROX)>

Perl's malloc() uses bucketed allocations.  Every request is rounded
up to the closest bucket size available, and a bucket is taken from
the pool of buckets of that size.

The line above describes the limits of buckets currently in use.
Each bucket has two sizes: memory footprint and the maximal size
of user data that can fit into this bucket.  Suppose in the above
example that the smallest bucket were size 4.  The biggest bucket
would have usable size 8188, and the memory footprint would be 8192.

In a Perl built for debugging, some buckets may have negative usable
size.  This means that these buckets cannot (and will not) be used.
For larger buckets, the memory footprint may be one page greater
than a power of 2.  If so, the corresponding power of two is
printed in the C<APPROX> field above.

=item Free/Used

The 1 or 2 rows of numbers following that correspond to the number
of buckets of each size between C<SMALLEST> and C<GREATEST>.  In
the first row, the sizes (memory footprints) of buckets are powers
of two--or possibly one page greater.  In the second row, if present,
the memory footprints of the buckets are between the memory footprints
of two buckets "above".

For example, suppose under the previous example, the memory footprints
were

   free:    8     16    32    64    128  256 512 1024 2048 4096 8192
	   4     12    24    48    80

With a non-C<DEBUGGING> perl, the buckets starting from C<128> have
a 4-byte overhead, and thus an 8192-long bucket may take up to
8188-byte allocations.

=item C<Total sbrk(): SBRKed/SBRKs:CONTINUOUS>

The first two fields give the total amount of memory perl sbrk(2)ed
(ess-broken? :-) and number of sbrk(2)s used.  The third number is
what perl thinks about continuity of returned chunks.  So long as
this number is positive, malloc() will assume that it is probable
that sbrk(2) will provide continuous memory.

Memory allocated by external libraries is not counted.

=item C<pad: 0>

The amount of sbrk(2)ed memory needed to keep buckets aligned.

=item C<heads: 2192>

Although memory overhead of bigger buckets is kept inside the bucket, for
smaller buckets, it is kept in separate areas.  This field gives the
total size of these areas.

=item C<chain: 0>

malloc() may want to subdivide a bigger bucket into smaller buckets.
If only a part of the deceased bucket is left unsubdivided, the rest
is kept as an element of a linked list.  This field gives the total
size of these chunks.

=item C<tail: 6144>

To minimize the number of sbrk(2)s, malloc() asks for more memory.  This
field gives the size of the yet unused part, which is sbrk(2)ed, but
never touched.

=back

=head1 SEE ALSO

L<perldebug>,
L<perl5db.pl>,
L<perlguts>,
L<perlrun>,
L<re>,
and
L<Devel::DProf>.
                                                                                                                                                                                                                                                                                                                                                                                                                                    usr/local/lib/perl5/5.40.0/pod/perldebtut.pod                                                       0000644 0000000 0000000 00000053223 14714567415 017153  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =head1 NAME

perldebtut - Perl debugging tutorial

=head1 DESCRIPTION

A (very) lightweight introduction in the use of the perl debugger, and a
pointer to existing, deeper sources of information on the subject of debugging
perl programs.  

There's an extraordinary number of people out there who don't appear to know
anything about using the perl debugger, though they use the language every
day.  
This is for them.  


=head1 use strict

First of all, there's a few things you can do to make your life a lot more
straightforward when it comes to debugging perl programs, without using the
debugger at all.  To demonstrate, here's a simple script, named "hello", with
a problem:

	#!/usr/bin/perl

	$var1 = 'Hello World'; # always wanted to do that :-)
	$var2 = "$varl\n";

	print $var2; 
	exit;

While this compiles and runs happily, it probably won't do what's expected,
namely it doesn't print "Hello World\n" at all;  It will on the other hand do
exactly what it was told to do, computers being a bit that way inclined.  That
is, it will print out a newline character, and you'll get what looks like a
blank line.  It looks like there's 2 variables when (because of the typo)
there's really 3:

	$var1 = 'Hello World';
	$varl = undef;
	$var2 = "\n";

To catch this kind of problem, we can force each variable to be declared
before use by pulling in the strict module, by putting 'use strict;' after the
first line of the script.

Now when you run it, perl complains about the 3 undeclared variables and we
get four error messages because one variable is referenced twice:

 Global symbol "$var1" requires explicit package name at ./t1 line 4.
 Global symbol "$var2" requires explicit package name at ./t1 line 5.
 Global symbol "$varl" requires explicit package name at ./t1 line 5.
 Global symbol "$var2" requires explicit package name at ./t1 line 7.
 Execution of ./hello aborted due to compilation errors.     

Luvverly! and to fix this we declare all variables explicitly and now our
script looks like this:	

	#!/usr/bin/perl
	use strict;

	my $var1 = 'Hello World';
	my $varl = undef;
	my $var2 = "$varl\n";

	print $var2; 
	exit;

We then do (always a good idea) a syntax check before we try to run it again:

	> perl -c hello
	hello syntax OK 

And now when we run it, we get "\n" still, but at least we know why.  Just
getting this script to compile has exposed the '$varl' (with the letter 'l')
variable, and simply changing $varl to $var1 solves the problem.


=head1 Looking at data and -w and v

Ok, but how about when you want to really see your data, what's in that
dynamic variable, just before using it?

	#!/usr/bin/perl 
	use strict;

	my $key = 'welcome';
	my %data = (
		'this' => qw(that), 
		'tom' => qw(and jerry),
		'welcome' => q(Hello World),
		'zip' => q(welcome),
	);
	my @data = keys %data;

	print "$data{$key}\n";
	exit;                               

Looks OK, after it's been through the syntax check (perl -c scriptname), we
run it and all we get is a blank line again!  Hmmmm.

One common debugging approach here, would be to liberally sprinkle a few print
statements, to add a check just before we print out our data, and another just
after:

	print "All OK\n" if grep($key, keys %data);
	print "$data{$key}\n";
	print "done: '$data{$key}'\n";

And try again:

	> perl data
	All OK     

	done: ''

After much staring at the same piece of code and not seeing the wood for the
trees for some time, we get a cup of coffee and try another approach.  That
is, we bring in the cavalry by giving perl the 'B<-d>' switch on the command
line:

	> perl -d data 
	Default die handler restored.

	Loading DB routines from perl5db.pl version 1.07
	Editor support available.

	Enter h or `h h' for help, or `man perldebug' for more help.

	main::(./data:4):     my $key = 'welcome';   

Now, what we've done here is to launch the built-in perl debugger on our
script.  It's stopped at the first line of executable code and is waiting for
input.

Before we go any further, you'll want to know how to quit the debugger: use
just the letter 'B<q>', not the words 'quit' or 'exit':

	DB<1> q
	>

That's it, you're back on home turf again.


=head1 help

Fire the debugger up again on your script and we'll look at the help menu. 
There's a couple of ways of calling help: a simple 'B<h>' will get the summary 
help list, 'B<|h>' (pipe-h) will pipe the help through your pager (which is 
(probably 'more' or 'less'), and finally, 'B<h h>' (h-space-h) will give you 
the entire help screen.  Here is the summary page:

DB<1>h

 List/search source lines:               Control script execution:
  l [ln|sub]  List source code            T           Stack trace
  - or .      List previous/current line  s [expr]    Single step
                                                               [in expr]
  v [line]    View around line            n [expr]    Next, steps over
                                                                    subs
  f filename  View source in file         <CR/Enter>  Repeat last n or s
  /pattern/ ?patt?   Search forw/backw    r           Return from
                                                              subroutine
  M           Show module versions        c [ln|sub]  Continue until
                                                                position
 Debugger controls:                       L           List break/watch/
                                                                 actions
  o [...]     Set debugger options        t [expr]    Toggle trace
                                                            [trace expr]
  <[<]|{[{]|>[>] [cmd] Do pre/post-prompt b [ln|event|sub] [cnd] Set
                                                              breakpoint
  ! [N|pat]   Redo a previous command     B ln|*      Delete a/all
                                                             breakpoints
  H [-num]    Display last num commands   a [ln] cmd  Do cmd before line
  = [a val]   Define/list an alias        A ln|*      Delete a/all
                                                                 actions
  h [db_cmd]  Get help on command         w expr      Add a watch
                                                              expression
  h h         Complete help page          W expr|*    Delete a/all watch
                                                                   exprs
  |[|]db_cmd  Send output to pager        ![!] syscmd Run cmd in a
                                                              subprocess
  q or ^D     Quit                        R           Attempt a restart
 Data Examination:     expr     Execute perl code, also see: s,n,t expr
  x|m expr       Evals expr in list context, dumps the result or lists
                                                                methods.
  p expr         Print expression (uses script's current package).
  S [[!]pat]     List subroutine names [not] matching pattern
  V [Pk [Vars]]  List Variables in Package.  Vars can be ~pattern or
                                                               !pattern.
  X [Vars]       Same as "V current_package [Vars]".
  y [n [Vars]]   List lexicals in higher scope <n>.  Vars same as V.
 For more help, type h cmd_letter, or run man perldebug for all docs. 

More confusing options than you can shake a big stick at!  It's not as bad as
it looks and it's very useful to know more about all of it, and fun too!

There's a couple of useful ones to know about straight away.  You wouldn't
think we're using any libraries at all at the moment, but 'B<M>' will show
which modules are currently loaded, and their version number, while 'B<m>' 
will show the methods, and 'B<S>' shows all subroutines (by pattern) as 
shown below.  'B<V>' and 'B<X>' show variables in the program by package 
scope and can be constrained by pattern. 

	DB<2>S str 
	dumpvar::stringify
	strict::bits
	strict::import
	strict::unimport  

Using 'X' and cousins requires you not to use the type identifiers ($@%), just
the 'name':

	DM<3>X ~err
	FileHandle(stderr) => fileno(2)    

Remember we're in our tiny program with a problem, we should have a look at
where we are, and what our data looks like. First of all let's view some code 
at our present position (the first line of code in this case), via 'B<v>':

	DB<4> v
	1       #!/usr/bin/perl
	2:      use strict;
	3
	4==>    my $key = 'welcome';
	5:      my %data = (
	6               'this' => qw(that),
	7               'tom' => qw(and jerry),
	8               'welcome' => q(Hello World),
	9               'zip' => q(welcome),
	10      );                                 

At line number 4 is a helpful pointer, that tells you where you are now.  To
see more code, type 'v' again:

	DB<4> v
	8               'welcome' => q(Hello World),
	9               'zip' => q(welcome),
	10      );
	11:     my @data = keys %data;
	12:     print "All OK\n" if grep($key, keys %data);
	13:     print "$data{$key}\n";
	14:     print "done: '$data{$key}'\n";
	15:     exit;      

And if you wanted to list line 5 again, type 'l 5', (note the space):

	DB<4> l 5
	5:      my %data = (

In this case, there's not much to see, but of course normally there's pages of
stuff to wade through, and 'l' can be very useful.  To reset your view to the
line we're about to execute, type a lone period '.':

	DB<5> .
	main::(./data_a:4):     my $key = 'welcome';  

The line shown is the one that is about to be executed B<next>, it hasn't
happened yet.  So while we can print a variable with the letter 'B<p>', at
this point all we'd get is an empty (undefined) value back.  What we need to
do is to step through the next executable statement with an 'B<s>':

	DB<6> s
	main::(./data_a:5):     my %data = (
	main::(./data_a:6):             'this' => qw(that),
	main::(./data_a:7):             'tom' => qw(and jerry),
	main::(./data_a:8):             'welcome' => q(Hello World),
	main::(./data_a:9):             'zip' => q(welcome),
	main::(./data_a:10):    );   

Now we can have a look at that first ($key) variable:

	DB<7> p $key 
	welcome 

line 13 is where the action is, so let's continue down to there via the letter
'B<c>', which by the way, inserts a 'one-time-only' breakpoint at the given
line or sub routine:

	DB<8> c 13
	All OK
	main::(./data_a:13):    print "$data{$key}\n";

We've gone past our check (where 'All OK' was printed) and have stopped just
before the meat of our task.  We could try to print out a couple of variables
to see what is happening:

	DB<9> p $data{$key}

Not much in there, lets have a look at our hash:

	DB<10> p %data
	Hello Worldziptomandwelcomejerrywelcomethisthat 

	DB<11> p keys %data
	Hello Worldtomwelcomejerrythis  

Well, this isn't very easy to read, and using the helpful manual (B<h h>), the
'B<x>' command looks promising:

	DB<12> x %data
	0  'Hello World'
	1  'zip'
	2  'tom'
	3  'and'
	4  'welcome'
	5  undef
	6  'jerry'
	7  'welcome'
	8  'this'
	9  'that'     

That's not much help, a couple of welcomes in there, but no indication of
which are keys, and which are values, it's just a listed array dump and, in
this case, not particularly helpful.  The trick here, is to use a B<reference>
to the data structure:

	DB<13> x \%data
	0  HASH(0x8194bc4)
	   'Hello World' => 'zip'
