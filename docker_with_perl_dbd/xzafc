        To pass exception information, use the keyword argument exc_info with
        a true value, e.g.

        logger.critical("Houston, we have a %s", "major disaster", exc_info=1)
        """
        if self.isEnabledFor(CRITICAL):
            self._log(CRITICAL, msg, args, **kwargs)

    def fatal(self, msg, *args, **kwargs):
        """
        Don't use this method, use critical() instead.
        """
        self.critical(msg, *args, **kwargs)

    def log(self, level, msg, *args, **kwargs):
        """
        Log 'msg % args' with the integer severity 'level'.

        To pass exception information, use the keyword argument exc_info with
        a true value, e.g.

        logger.log(level, "We have a %s", "mysterious problem", exc_info=1)
        """
        if not isinstance(level, int):
            if raiseExceptions:
                raise TypeError("level must be an integer")
            else:
                return
        if self.isEnabledFor(level):
            self._log(level, msg, args, **kwargs)

    def findCaller(self, stack_info=False, stacklevel=1):
        """
        Find the stack frame of the caller so that we can note the source
        file name, line number and function name.
        """
        f = currentframe()
        #On some versions of IronPython, currentframe() returns None if
        #IronPython isn't run with -X:Frames.
        if f is None:
            return "(unknown file)", 0, "(unknown function)", None
        while stacklevel > 0:
            next_f = f.f_back
            if next_f is None:
                ## We've got options here.
                ## If we want to use the last (deepest) frame:
                break
                ## If we want to mimic the warnings module:
                #return ("sys", 1, "(unknown function)", None)
                ## If we want to be pedantic:
                #raise ValueError("call stack is not deep enough")
            f = next_f
            if not _is_internal_frame(f):
                stacklevel -= 1
        co = f.f_code
        sinfo = None
        if stack_info:
            with io.StringIO() as sio:
                sio.write("Stack (most recent call last):\n")
                traceback.print_stack(f, file=sio)
                sinfo = sio.getvalue()
                if sinfo[-1] == '\n':
                    sinfo = sinfo[:-1]
        return co.co_filename, f.f_lineno, co.co_name, sinfo

    def makeRecord(self, name, level, fn, lno, msg, args, exc_info,
                   func=None, extra=None, sinfo=None):
        """
        A factory method which can be overridden in subclasses to create
        specialized LogRecords.
        """
        rv = _logRecordFactory(name, level, fn, lno, msg, args, exc_info, func,
                             sinfo)
        if extra is not None:
            for key in extra:
                if (key in ["message", "asctime"]) or (key in rv.__dict__):
                    raise KeyError("Attempt to overwrite %r in LogRecord" % key)
                rv.__dict__[key] = extra[key]
        return rv

    def _log(self, level, msg, args, exc_info=None, extra=None, stack_info=False,
             stacklevel=1):
        """
        Low-level logging routine which creates a LogRecord and then calls
        all the handlers of this logger to handle the record.
        """
        sinfo = None
        if _srcfile:
            #IronPython doesn't track Python frames, so findCaller raises an
            #exception on some versions of IronPython. We trap it here so that
            #IronPython can use logging.
            try:
                fn, lno, func, sinfo = self.findCaller(stack_info, stacklevel)
            except ValueError: # pragma: no cover
                fn, lno, func = "(unknown file)", 0, "(unknown function)"
        else: # pragma: no cover
            fn, lno, func = "(unknown file)", 0, "(unknown function)"
        if exc_info:
            if isinstance(exc_info, BaseException):
                exc_info = (type(exc_info), exc_info, exc_info.__traceback__)
            elif not isinstance(exc_info, tuple):
                exc_info = sys.exc_info()
        record = self.makeRecord(self.name, level, fn, lno, msg, args,
                                 exc_info, func, extra, sinfo)
        self.handle(record)

    def handle(self, record):
        """
        Call the handlers for the specified record.

        This method is used for unpickled records received from a socket, as
        well as those created locally. Logger-level filtering is applied.
        """
        if (not self.disabled) and self.filter(record):
            self.callHandlers(record)

    def addHandler(self, hdlr):
        """
        Add the specified handler to this logger.
        """
        _acquireLock()
        try:
            if not (hdlr in self.handlers):
                self.handlers.append(hdlr)
        finally:
            _releaseLock()

    def removeHandler(self, hdlr):
        """
        Remove the specified handler from this logger.
        """
        _acquireLock()
        try:
            if hdlr in self.handlers:
                self.handlers.remove(hdlr)
        finally:
            _releaseLock()

    def hasHandlers(self):
        """
        See if this logger has any handlers configured.

        Loop through all handlers for this logger and its parents in the
        logger hierarchy. Return True if a handler was found, else False.
        Stop searching up the hierarchy whenever a logger with the "propagate"
        attribute set to zero is found - that will be the last logger which
        is checked for the existence of handlers.
        """
        c = self
        rv = False
        while c:
            if c.handlers:
                rv = True
                break
            if not c.propagate:
                break
            else:
                c = c.parent
        return rv

    def callHandlers(self, record):
        """
        Pass a record to all relevant handlers.

        Loop through all handlers for this logger and its parents in the
        logger hierarchy. If no handler was found, output a one-off error
        message to sys.stderr. Stop searching up the hierarchy whenever a
        logger with the "propagate" attribute set to zero is found - that
        will be the last logger whose handlers are called.
        """
        c = self
        found = 0
        while c:
            for hdlr in c.handlers:
                found = found + 1
                if record.levelno >= hdlr.level:
                    hdlr.handle(record)
            if not c.propagate:
                c = None    #break out
            else:
                c = c.parent
        if (found == 0):
            if lastResort:
                if record.levelno >= lastResort.level:
                    lastResort.handle(record)
            elif raiseExceptions and not self.manager.emittedNoHandlerWarning:
                sys.stderr.write("No handlers could be found for logger"
                                 " \"%s\"\n" % self.name)
                self.manager.emittedNoHandlerWarning = True

    def getEffectiveLevel(self):
        """
        Get the effective level for this logger.

        Loop through this logger and its parents in the logger hierarchy,
        looking for a non-zero logging level. Return the first one found.
        """
        logger = self
        while logger:
            if logger.level:
                return logger.level
            logger = logger.parent
        return NOTSET

    def isEnabledFor(self, level):
        """
        Is this logger enabled for level 'level'?
        """
        if self.disabled:
            return False

        try:
            return self._cache[level]
        except KeyError:
            _acquireLock()
            try:
                if self.manager.disable >= level:
                    is_enabled = self._cache[level] = False
                else:
                    is_enabled = self._cache[level] = (
                        level >= self.getEffectiveLevel()
                    )
            finally:
                _releaseLock()
            return is_enabled

    def getChild(self, suffix):
        """
        Get a logger which is a descendant to this one.

        This is a convenience method, such that

        logging.getLogger('abc').getChild('def.ghi')

        is the same as

        logging.getLogger('abc.def.ghi')

        It's useful, for example, when the parent logger is named using
        __name__ rather than a literal string.
        """
        if self.root is not self:
            suffix = '.'.join((self.name, suffix))
        return self.manager.getLogger(suffix)

    def __repr__(self):
        level = getLevelName(self.getEffectiveLevel())
        return '<%s %s (%s)>' % (self.__class__.__name__, self.name, level)

    def __reduce__(self):
        if getLogger(self.name) is not self:
            import pickle
            raise pickle.PicklingError('logger cannot be pickled')
        return getLogger, (self.name,)


class RootLogger(Logger):
    """
    A root logger is not that different to any other logger, except that
    it must have a logging level and there is only one instance of it in
    the hierarchy.
    """
    def __init__(self, level):
        """
        Initialize the logger with the name "root".
        """
        Logger.__init__(self, "root", level)

    def __reduce__(self):
        return getLogger, ()

_loggerClass = Logger

class LoggerAdapter(object):
    """
    An adapter for loggers which makes it easier to specify contextual
    information in logging output.
    """

    def __init__(self, logger, extra=None):
        """
        Initialize the adapter with a logger and a dict-like object which
        provides contextual information. This constructor signature allows
        easy stacking of LoggerAdapters, if so desired.

        You can effectively pass keyword arguments as shown in the
        following example:

        adapter = LoggerAdapter(someLogger, dict(p1=v1, p2="v2"))
        """
        self.logger = logger
        self.extra = extra

    def process(self, msg, kwargs):
        """
        Process the logging message and keyword arguments passed in to
        a logging call to insert contextual information. You can either
        manipulate the message itself, the keyword args or both. Return
        the message and kwargs modified (or not) to suit your needs.

        Normally, you'll only need to override this one method in a
        LoggerAdapter subclass for your specific needs.
        """
        kwargs["extra"] = self.extra
        return msg, kwargs

    #
    # Boilerplate convenience methods
    #
    def debug(self, msg, *args, **kwargs):
        """
        Delegate a debug call to the underlying logger.
        """
        self.log(DEBUG, msg, *args, **kwargs)

    def info(self, msg, *args, **kwargs):
        """
        Delegate an info call to the underlying logger.
        """
        self.log(INFO, msg, *args, **kwargs)

    def warning(self, msg, *args, **kwargs):
        """
        Delegate a warning call to the underlying logger.
        """
        self.log(WARNING, msg, *args, **kwargs)

    def warn(self, msg, *args, **kwargs):
        warnings.warn("The 'warn' method is deprecated, "
            "use 'warning' instead", DeprecationWarning, 2)
        self.warning(msg, *args, **kwargs)

    def error(self, msg, *args, **kwargs):
        """
        Delegate an error call to the underlying logger.
        """
        self.log(ERROR, msg, *args, **kwargs)

    def exception(self, msg, *args, exc_info=True, **kwargs):
        """
        Delegate an exception call to the underlying logger.
        """
        self.log(ERROR, msg, *args, exc_info=exc_info, **kwargs)

    def critical(self, msg, *args, **kwargs):
        """
        Delegate a critical call to the underlying logger.
        """
        self.log(CRITICAL, msg, *args, **kwargs)

    def log(self, level, msg, *args, **kwargs):
        """
        Delegate a log call to the underlying logger, after adding
        contextual information from this adapter instance.
        """
        if self.isEnabledFor(level):
            msg, kwargs = self.process(msg, kwargs)
            self.logger.log(level, msg, *args, **kwargs)

    def isEnabledFor(self, level):
        """
        Is this logger enabled for level 'level'?
        """
        return self.logger.isEnabledFor(level)

    def setLevel(self, level):
        """
        Set the specified level on the underlying logger.
        """
        self.logger.setLevel(level)

    def getEffectiveLevel(self):
        """
        Get the effective level for the underlying logger.
        """
        return self.logger.getEffectiveLevel()

    def hasHandlers(self):
        """
        See if the underlying logger has any handlers.
        """
        return self.logger.hasHandlers()

    def _log(self, level, msg, args, exc_info=None, extra=None, stack_info=False):
        """
        Low-level log implementation, proxied to allow nested logger adapters.
        """
        return self.logger._log(
            level,
            msg,
            args,
            exc_info=exc_info,
            extra=extra,
            stack_info=stack_info,
        )

    @property
    def manager(self):
        return self.logger.manager

    @manager.setter
    def manager(self, value):
        self.logger.manager = value

    @property
    def name(self):
        return self.logger.name

    def __repr__(self):
        logger = self.logger
        level = getLevelName(logger.getEffectiveLevel())
        return '<%s %s (%s)>' % (self.__class__.__name__, logger.name, level)

    __class_getitem__ = classmethod(GenericAlias)

root = RootLogger(WARNING)
Logger.root = root
Logger.manager = Manager(Logger.root)

#---------------------------------------------------------------------------
# Configuration classes and functions
#---------------------------------------------------------------------------

def basicConfig(**kwargs):
    """
    Do basic configuration for the logging system.

    This function does nothing if the root logger already has handlers
    configured, unless the keyword argument *force* is set to ``True``.
    It is a convenience method intended for use by simple scripts
    to do one-shot configuration of the logging package.

    The default behaviour is to create a StreamHandler which writes to
    sys.stderr, set a formatter using the BASIC_FORMAT format string, and
    add the handler to the root logger.

    A number of optional keyword arguments may be specified, which can alter
    the default behaviour.

    filename  Specifies that a FileHandler be created, using the specified
              filename, rather than a StreamHandler.
    filemode  Specifies the mode to open the file, if filename is specified
              (if filemode is unspecified, it defaults to 'a').
    format    Use the specified format string for the handler.
    datefmt   Use the specified date/time format.
    style     If a format string is specified, use this to specify the
              type of format string (possible values '%', '{', '$', for
              %-formatting, :meth:`str.format` and :class:`string.Template`
              - defaults to '%').
    level     Set the root logger level to the specified level.
    stream    Use the specified stream to initialize the StreamHandler. Note
              that this argument is incompatible with 'filename' - if both
              are present, 'stream' is ignored.
    handlers  If specified, this should be an iterable of already created
              handlers, which will be added to the root handler. Any handler
              in the list which does not have a formatter assigned will be
              assigned the formatter created in this function.
    force     If this keyword  is specified as true, any existing handlers
              attached to the root logger are removed and closed, before
              carrying out the configuration as specified by the other
              arguments.
    encoding  If specified together with a filename, this encoding is passed to
              the created FileHandler, causing it to be used when the file is
              opened.
    errors    If specified together with a filename, this value is passed to the
              created FileHandler, causing it to be used when the file is
              opened in text mode. If not specified, the default value is
              `backslashreplace`.

    Note that you could specify a stream created using open(filename, mode)
    rather than passing the filename and mode in. However, it should be
    remembered that StreamHandler does not close its stream (since it may be
    using sys.stdout or sys.stderr), whereas FileHandler closes its stream
    when the handler is closed.

    .. versionchanged:: 3.2
       Added the ``style`` parameter.

    .. versionchanged:: 3.3
       Added the ``handlers`` parameter. A ``ValueError`` is now thrown for
       incompatible arguments (e.g. ``handlers`` specified together with
       ``filename``/``filemode``, or ``filename``/``filemode`` specified
       together with ``stream``, or ``handlers`` specified together with
       ``stream``.

    .. versionchanged:: 3.8
       Added the ``force`` parameter.

    .. versionchanged:: 3.9
       Added the ``encoding`` and ``errors`` parameters.
    """
    # Add thread safety in case someone mistakenly calls
    # basicConfig() from multiple threads
    _acquireLock()
    try:
        force = kwargs.pop('force', False)
        encoding = kwargs.pop('encoding', None)
        errors = kwargs.pop('errors', 'backslashreplace')
        if force:
            for h in root.handlers[:]:
                root.removeHandler(h)
                h.close()
        if len(root.handlers) == 0:
            handlers = kwargs.pop("handlers", None)
            if handlers is None:
                if "stream" in kwargs and "filename" in kwargs:
                    raise ValueError("'stream' and 'filename' should not be "
                                     "specified together")
            else:
                if "stream" in kwargs or "filename" in kwargs:
                    raise ValueError("'stream' or 'filename' should not be "
                                     "specified together with 'handlers'")
            if handlers is None:
                filename = kwargs.pop("filename", None)
                mode = kwargs.pop("filemode", 'a')
                if filename:
                    if 'b' in mode:
                        errors = None
                    else:
                        encoding = io.text_encoding(encoding)
                    h = FileHandler(filename, mode,
                                    encoding=encoding, errors=errors)
                else:
                    stream = kwargs.pop("stream", None)
                    h = StreamHandler(stream)
                handlers = [h]
            dfs = kwargs.pop("datefmt", None)
            style = kwargs.pop("style", '%')
            if style not in _STYLES:
                raise ValueError('Style must be one of: %s' % ','.join(
                                 _STYLES.keys()))
            fs = kwargs.pop("format", _STYLES[style][1])
            fmt = Formatter(fs, dfs, style)
            for h in handlers:
                if h.formatter is None:
                    h.setFormatter(fmt)
                root.addHandler(h)
            level = kwargs.pop("level", None)
            if level is not None:
                root.setLevel(level)
            if kwargs:
                keys = ', '.join(kwargs.keys())
                raise ValueError('Unrecognised argument(s): %s' % keys)
    finally:
        _releaseLock()

#---------------------------------------------------------------------------
# Utility functions at module level.
# Basically delegate everything to the root logger.
#---------------------------------------------------------------------------

def getLogger(name=None):
    """
    Return a logger with the specified name, creating it if necessary.

    If no name is specified, return the root logger.
    """
    if not name or isinstance(name, str) and name == root.name:
        return root
    return Logger.manager.getLogger(name)

def critical(msg, *args, **kwargs):
    """
    Log a message with severity 'CRITICAL' on the root logger. If the logger
    has no handlers, call basicConfig() to add a console handler with a
    pre-defined format.
    """
    if len(root.handlers) == 0:
        basicConfig()
    root.critical(msg, *args, **kwargs)

def fatal(msg, *args, **kwargs):
    """
    Don't use this function, use critical() instead.
    """
    critical(msg, *args, **kwargs)

def error(msg, *args, **kwargs):
    """
    Log a message with severity 'ERROR' on the root logger. If the logger has
    no handlers, call basicConfig() to add a console handler with a pre-defined
    format.
    """
    if len(root.handlers) == 0:
        basicConfig()
    root.error(msg, *args, **kwargs)

def exception(msg, *args, exc_info=True, **kwargs):
    """
    Log a message with severity 'ERROR' on the root logger, with exception
    information. If the logger has no handlers, basicConfig() is called to add
    a console handler with a pre-defined format.
    """
    error(msg, *args, exc_info=exc_info, **kwargs)

def warning(msg, *args, **kwargs):
    """
    Log a message with severity 'WARNING' on the root logger. If the logger has
    no handlers, call basicConfig() to add a console handler with a pre-defined
    format.
    """
    if len(root.handlers) == 0:
        basicConfig()
    root.warning(msg, *args, **kwargs)

def warn(msg, *args, **kwargs):
    warnings.warn("The 'warn' function is deprecated, "
        "use 'warning' instead", DeprecationWarning, 2)
    warning(msg, *args, **kwargs)

def info(msg, *args, **kwargs):
    """
    Log a message with severity 'INFO' on the root logger. If the logger has
    no handlers, call basicConfig() to add a console handler with a pre-defined
    format.
    """
    if len(root.handlers) == 0:
        basicConfig()
    root.info(msg, *args, **kwargs)

def debug(msg, *args, **kwargs):
    """
    Log a message with severity 'DEBUG' on the root logger. If the logger has
    no handlers, call basicConfig() to add a console handler with a pre-defined
    format.
    """
    if len(root.handlers) == 0:
        basicConfig()
    root.debug(msg, *args, **kwargs)

def log(level, msg, *args, **kwargs):
    """
    Log 'msg % args' with the integer severity 'level' on the root logger. If
    the logger has no handlers, call basicConfig() to add a console handler
    with a pre-defined format.
    """
    if len(root.handlers) == 0:
        basicConfig()
    root.log(level, msg, *args, **kwargs)

def disable(level=CRITICAL):
    """
    Disable all logging calls of severity 'level' and below.
    """
    root.manager.disable = level
    root.manager._clear_cache()

def shutdown(handlerList=_handlerList):
    """
    Perform any cleanup actions in the logging system (e.g. flushing
    buffers).

    Should be called at application exit.
    """
    for wr in reversed(handlerList[:]):
        #errors might occur, for example, if files are locked
        #we just ignore them if raiseExceptions is not set
        try:
            h = wr()
            if h:
                try:
                    h.acquire()
                    h.flush()
                    h.close()
                except (OSError, ValueError):
                    # Ignore errors which might be caused
                    # because handlers have been closed but
                    # references to them are still around at
                    # application exit.
                    pass
                finally:
                    h.release()
        except: # ignore everything, as we're shutting down
            if raiseExceptions:
                raise
            #else, swallow

#Let's try and shutdown automatically on application exit...
import atexit
atexit.register(shutdown)

# Null handler

class NullHandler(Handler):
    """
    This handler does nothing. It's intended to be used to avoid the
    "No handlers could be found for logger XXX" one-off warning. This is
    important for library code, which may contain code to log events. If a user
    of the library does not configure logging, the one-off warning might be
    produced; to avoid this, the library developer simply needs to instantiate
    a NullHandler and add it to the top-level logger of the library module or
    package.
    """
    def handle(self, record):
        """Stub."""

    def emit(self, record):
        """Stub."""

    def createLock(self):
        self.lock = None

    def _at_fork_reinit(self):
        pass

# Warnings integration

_warnings_showwarning = None

def _showwarning(message, category, filename, lineno, file=None, line=None):
    """
    Implementation of showwarnings which redirects to logging, which will first
    check to see if the file parameter is None. If a file is specified, it will
    delegate to the original warnings implementation of showwarning. Otherwise,
    it will call warnings.formatwarning and will log the resulting string to a
    warnings logger named "py.warnings" with level logging.WARNING.
    """
    if file is not None:
        if _warnings_showwarning is not None:
            _warnings_showwarning(message, category, filename, lineno, file, line)
    else:
        s = warnings.formatwarning(message, category, filename, lineno, line)
        logger = getLogger("py.warnings")
        if not logger.handlers:
            logger.addHandler(NullHandler())
        # bpo-46557: Log str(s) as msg instead of logger.warning("%s", s)
        # since some log aggregation tools group logs by the msg arg
        logger.warning(str(s))

def captureWarnings(capture):
    """
    If capture is true, redirect all warnings to the logging package.
    If capture is False, ensure that warnings are not redirected to logging
    but to their original destinations.
    """
    global _warnings_showwarning
    if capture:
        if _warnings_showwarning is None:
            _warnings_showwarning = warnings.showwarning
            warnings.showwarning = _showwarning
    else:
        if _warnings_showwarning is not None:
            warnings.showwarning = _warnings_showwarning
            _warnings_showwarning = None
                                                                         usr/lib/python3.11/logging/__pycache__/                                                             0000755 0000000 0000000 00000000000 14714551116 016312  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python3.11/logging/__pycache__/__init__.cpython-311.pyc                                     0000644 0000000 0000000 00000301072 14714551116 022556  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ß
    N¸‰f∑; „                   ÛŒ  ó d Z ddlZddlZddlZddlZddlZddlZddlZddlZddl	Z
ddlmZ ddlmZ ddlmZ g d¢ZddlZdZdZd	Zd
Z ej        ¶   ´         ZdZdZdZdZdZeZdZdZeZ dZ!dZ"dZ#ededede!de"de#diZ$eeeeee!e"e#dúZ%dÑ Z&dÑ Z'dÑ Z( e)ed¶  ´        rdÑ Z*ndÑ Z*ej+        †,                    e(j-        j.        ¶  ´        Z/dÑ Z0dÑ Z1 ej2        ¶   ´         Z3d Ñ Z4d!Ñ Z5 e)ed"¶  ´        sd#Ñ Z6n( ej7        ¶   ´         Z8d$Ñ Z6d%Ñ Z9 ej:        e4e9e5¨&¶  ´          G d'Ñ d(e;¶  ´        Z<e<a=d)Ñ Z>d*Ñ Z?d+Ñ Z@ e¶   ´         ZA[ G d,Ñ d-e;¶  ´        ZB G d.Ñ d/eB¶  ´        ZC G d0Ñ d1eB¶  ´        ZDd2ZEeBeEfeCd3feDd4fd5úZF G d6Ñ d7e;¶  ´        Z e¶   ´         ZG G d8Ñ d9e;¶  ´        ZH G d:Ñ d;e;¶  ´        ZI G d<Ñ d=e;¶  ´        ZJ ejK        ¶   ´         ZLg ZMd>Ñ ZNd?Ñ ZO G d@Ñ dAeJ¶  ´        ZP G dBÑ dCeP¶  ´        ZQ G dDÑ dEeQ¶  ´        ZR G dFÑ dGeQ¶  ´        ZS eSe¶  ´        ZTeTZU G dHÑ dIe;¶  ´        ZVdJÑ ZWdKÑ ZX G dLÑ dMe;¶  ´        ZY G dNÑ dOeJ¶  ´        ZZ G dPÑ dQeZ¶  ´        Z[eZa\ G dRÑ dSe;¶  ´        Z] e[e¶  ´        Z^e^eZ_^         eYeZj^        ¶  ´        eZ__        dTÑ Z`dfdUÑZadVÑ ZbdWÑ ZcdXÑ ZdddYúdZÑZed[Ñ Zfd\Ñ Zgd]Ñ Zhd^Ñ Zid_Ñ Zjefd`ÑZkeMfdaÑZlddlmZm emjn        el¶  ´          G dbÑ dceP¶  ´        ZodapdgddÑZqdeÑ ZrdS )hz¬
Logging package for Python. Based on PEP 282 and comments thereto in
comp.lang.python.

Copyright (C) 2001-2019 Vinay Sajip. All Rights Reserved.

To use, simply 'import logging' and log away!
È    N)⁄GenericAlias)⁄Template)⁄	Formatter)+⁄BASIC_FORMAT⁄BufferingFormatter⁄CRITICAL⁄DEBUG⁄ERROR⁄FATAL⁄FileHandler⁄Filterr   ⁄Handler⁄INFO⁄	LogRecord⁄Logger⁄LoggerAdapter⁄NOTSET⁄NullHandler⁄StreamHandler⁄WARN⁄WARNING⁄addLevelName⁄basicConfig⁄captureWarnings⁄critical⁄debug⁄disable⁄error⁄	exception⁄fatal⁄getLevelName⁄	getLogger⁄getLoggerClass⁄info⁄log⁄makeLogRecord⁄setLoggerClass⁄shutdown⁄warn⁄warning⁄getLogRecordFactory⁄setLogRecordFactory⁄
lastResort⁄raiseExceptions⁄getLevelNamesMappingz&Vinay Sajip <vinay_sajip@red-dove.com>⁄
productionz0.5.1.2z07 February 2010TÈ2   È(   È   È   È
   r   r
   r   r   r	   r   )r   r   r
   r   r   r   r	   r   c                  Û4   ó t           †                    ¶   ´         S ©N)⁄_nameToLevel⁄copy© Û    ˙'/usr/lib/python3.11/logging/__init__.pyr/   r/   x   s   Ä ›◊“—‘–r;   c                 ÛÑ   ó t           †                    | ¶  ´        }|Å|S t          †                    | ¶  ´        }|Å|S d| z  S )a¥  
    Return the textual or numeric representation of logging level 'level'.

    If the level is one of the predefined levels (CRITICAL, ERROR, WARNING,
    INFO, DEBUG) then you get the corresponding string. If you have
    associated levels with names using addLevelName then the name you have
    associated with 'level' is returned.

    If a numeric value corresponding to one of the defined levels is passed
    in, the corresponding string representation is returned.

    If a string representation of the level is passed in, the corresponding
    numeric value is returned.

    If no matching numeric or string value is passed in, the string
    'Level %s' % level is returned.
    NzLevel %s)⁄_levelToName⁄getr8   )⁄level⁄results     r<   r!   r!   {   sK   Ä ı& ◊“òe—$‘$ÄFÿ–ÿà›◊“òe—$‘$ÄFÿ–ÿàÿò—–r;   c                 Ûé   ó t          ¶   ´          	 |t          | <   | t          |<   t          ¶   ´          dS # t          ¶   ´          w xY w)zy
    Associate 'levelName' with 'level'.

    This is used when converting levels to text during message formatting.
    N)⁄_acquireLockr>   r8   ⁄_releaseLock)r@   ⁄	levelNames     r<   r   r   ñ   sA   Ä ı ÅNÑNÄNÿ'çêU—ÿ"'çêY—Ââåààà¯çâåàà¯¯¯s	   ê4 ¥A⁄	_getframec                  Û*   ó t          j        d¶  ´        S )NÈ   )⁄sysrF   r:   r;   r<   ˙<lambda>rJ   §   s   Ä ù3ú=®—+‘+Ä r;   c                  Ûx   ó 	 t           Ç# t           $ r& t          j        ¶   ´         d         j        j        cY S w xY w)z5Return the frame object for the caller's stack frame.È   )⁄	ExceptionrI   ⁄exc_info⁄tb_frame⁄f_backr:   r;   r<   ⁄currentframerQ   ¶   sD   Ä 	5›àO¯› 	5 	5 	5›î<ë>î>†!‘$‘-‘4–4–4–4	5¯¯¯s   Ç	 â-9∏9c                 Ûz   ó t           j        †                    | j        j        ¶  ´        }|t
          k    pd|v od|v S )zASignal whether the frame is a CPython or logging module internal.⁄	importlib⁄
_bootstrap)⁄os⁄path⁄normcase⁄f_code⁄co_filename⁄_srcfile)⁄frame⁄filenames     r<   ⁄_is_internal_framer]   ¬   s@   Ä Âåw◊“†§‘ 8—9‘9ÄHÿïx“ ÿêx––<†L∞H–$<r;   c                 Û“   ó t          | t          ¶  ´        r| }nNt          | ¶  ´        | k    r)| t          vrt	          d| z  ¶  ´        Çt          |          }nt          d| õù¶  ´        Ç|S )NzUnknown level: %rz(Level not an integer or a valid string: )⁄
isinstance⁄int⁄strr8   ⁄
ValueError⁄	TypeError)r@   ⁄rvs     r<   ⁄_checkLevelre       sz   Ä ›ê%ù—‘ $ÿàà›	àUâåêu“	–	ÿù–$–$›–0∞5—8—9‘9–9›ò%‘ ààÂàiÿ ò5#Ò $Ù $ 	$‡ÄIr;   c                  ÛJ   ó t           rt           †                    ¶   ´          dS dS )zÄ
    Acquire the module-level lock for serializing access to shared data.

    This should be released with _releaseLock().
    N)⁄_lock⁄acquirer:   r;   r<   rC   rC   ‰   s'   Ä ı  ›èäâåààà r;   c                  ÛJ   ó t           rt           †                    ¶   ´          dS dS )zK
    Release the module-level lock acquired by calling _acquireLock().
    N)rg   ⁄releaser:   r;   r<   rD   rD   Ì   s'   Ä ı  ›èäâåààà r;   ⁄register_at_forkc                 Û   ó d S r7   r:   ©⁄instances    r<   ⁄_register_at_fork_reinit_lockro   ¯   Û   Ä ÿàr;   c                 Ûö   ó t          ¶   ´          	 t          †                    | ¶  ´         t          ¶   ´          d S # t          ¶   ´          w xY wr7   )rC   ⁄_at_fork_reinit_lock_weakset⁄addrD   rm   s    r<   ro   ro      s?   Ä ›âåà	›(◊,“,®X—6‘6–6ÂâNåNàNàNàN¯çLâNåNàNàN¯¯¯s	   ê: ∫A
c                  Ût   ó t           D ]} | †                    ¶   ´          åt          †                    ¶   ´          d S r7   )rr   ⁄_at_fork_reinitrg   ©⁄handlers    r<   ⁄!_after_at_fork_child_reinit_locksrx     s@   Ä ›3 	& 	&àGÿ◊#“#—%‘%–%–%ı 	◊“—‘–––r;   )⁄before⁄after_in_child⁄after_in_parentc                   Û(   ó e Zd ZdZ	 ddÑZdÑ ZdÑ ZdS )r   a  
    A LogRecord instance represents an event being logged.

    LogRecord instances are created every time something is logged. They
    contain all the information pertinent to the event being logged. The
    main information passed in is in msg and args, which are combined
    using str(msg) % args to create the message field of the record. The
    record also includes information such as when the record was created,
    the source line where the logging call was made, and any exception
    information to be logged.
    Nc
                 Û‚  ó t          j         ¶   ´         }|| _        || _        |rHt          |¶  ´        dk    r5t	          |d         t
          j        j        ¶  ´        r|d         r|d         }|| _        t          |¶  ´        | _
        || _        || _        	 t          j        †                    |¶  ´        | _        t          j        †                    | j        ¶  ´        d         | _        n+# t&          t(          t*          f$ r || _        d| _        Y nw xY w|| _        d| _        |	| _        || _        || _        || _        t9          |t9          |¶  ´        z
  dz  ¶  ´        dz   | _        | j        t<          z
  dz  | _        t@          r6tC          j"        ¶   ´         | _#        tC          j$        ¶   ´         j        | _%        nd| _#        d| _%        tL          sd| _'        nXd| _'        tP          j)        †*                    d¶  ´        }|Å0	 |†+                    ¶   ´         j        | _'        n# tX          $ r Y nw xY wtZ          r/t]          t          d	¶  ´        rt          j/        ¶   ´         | _0        dS d| _0        dS )
zK
        Initialize a logging record with interesting information.
        rH   r   zUnknown moduleNiË  g        ⁄MainProcess⁄multiprocessing⁄getpid)1⁄time⁄name⁄msg⁄lenr_   ⁄collections⁄abc⁄Mapping⁄argsr!   ⁄	levelname⁄levelno⁄pathnamerU   rV   ⁄basenamer\   ⁄splitext⁄modulerc   rb   ⁄AttributeErrorrN   ⁄exc_text⁄
stack_info⁄lineno⁄funcName⁄createdr`   ⁄msecs⁄
_startTime⁄relativeCreated⁄
logThreads⁄	threading⁄	get_ident⁄thread⁄current_thread⁄
threadName⁄logMultiprocessing⁄processNamerI   ⁄modulesr?   ⁄current_processrM   ⁄logProcesses⁄hasattrrÄ   ⁄process)⁄selfrÇ   r@   rã   rí   rÉ   rà   rN   ⁄func⁄sinfo⁄kwargs⁄ct⁄mps                r<   ⁄__init__zLogRecord.__init__$  s;  Ä ı
 åYâ[å[àÿàå	ÿàå&  	ïSòëYîY†!í^ê^≠
∞4∏¥7ΩKºO‘<S—(T‘(Tê^ÿêQî $‡òî7àDÿàå	›%†e—,‘,àåÿàåÿ àå	+›úG◊,“,®X—6‘6àDåM›ú'◊*“*®4¨=—9‘9∏!‘<àDåKàK¯›ù:•~–6 	+ 	+ 	+ÿ$àDåMÿ*àDåKàKàK	+¯¯¯ !àåÿàåÿàåÿàåÿàåÿàå›ò"ùs†2ôwúwô,®$—.—/‘/∞#—5àå
ÿ $§≠z— 9∏T—Aà‘› 	#›#‘-—/‘/àDåK›'‘6—8‘8‘=àDåOàO‡àDåKÿ"àDåO›! 	ÿ#àD‘–‡,àD‘›îóí–!2—3‘3àBÿà~
ÿ')◊'9“'9—';‘';‘'@êD‘$–$¯›    ÿêD¯¯¯Â 	 ùG•B®—1‘1 	 ›ú9ô;ú;àDåLàLàL‡àDåLàLàLs%   ¬AC* √*%DƒD»H" »"
H/».H/c                 ÛX   ó d| j         õd| j        õd| j        õd| j        õd| j        õdùS )Nz<LogRecord: ˙, z, "z">)rÇ   rä   rã   rí   rÉ   ©r•   s    r<   ⁄__repr__zLogRecord.__repr__l  s8   Ä Ä ÿ48¥I∞I∞I∏tº|∏|∏|ÿåMàMàMò4ú;ò;ò;®¨®®2 	2r;   c                 ÛP   ó t          | j        ¶  ´        }| j        r
|| j        z  }|S )z´
        Return the message for this LogRecord.

        Return the message for this LogRecord after merging any user-supplied
        arguments with the message.
        )ra   rÉ   rà   )r•   rÉ   s     r<   ⁄
getMessagezLogRecord.getMessagep  s+   Ä ı ê$î(âmåmàÿå9 	"ÿòú	ë/àCÿà
r;   ©NN)⁄__name__⁄
__module__⁄__qualname__⁄__doc__r´   rØ   r±   r:   r;   r<   r   r     sZ   Ä Ä Ä Ä Ä 
 
 8<F  F  F  F P2 2 2
 
 
 
 
r;   r   c                 Û
   ó | a dS )zõ
    Set the factory to be used when instantiating a log record.

    :param factory: A callable which will be called to instantiate
    a log record.
    N©⁄_logRecordFactory)⁄factorys    r<   r,   r,   Å  s   Ä   –––r;   c                  Û   ó t           S )zH
    Return the factory to be used when instantiating a log record.
    r∏   r:   r;   r<   r+   r+   ã  s
   Ä ı
 –r;   c           
      Ûf   ó t          dddddddd¶  ´        }|j        †                    | ¶  ´         |S )zÙ
    Make a LogRecord whose attributes are defined by the specified dictionary,
    This function is useful for converting a logging event received over
    a socket connection (which is sent as a dictionary) into a LogRecord
    instance.
    N⁄ r   r:   )rπ   ⁄__dict__⁄update)⁄dictrd   s     r<   r&   r&   í  s:   Ä ı 
ò4††r®1®b∞"∞d∏D—	A‘	AÄBÿÑK◊“êt—‘–ÿÄIr;   c                   Ûj   ó e Zd ZdZdZdZ ej        dej        ¶  ´        Z	ddúdÑZ
dÑ Zd	Ñ Zd
Ñ ZdÑ ZdS )⁄PercentStylez%(message)sz%(asctime)sz
%(asctime)z5%\(\w+\)[#0+ -]*(\*|\d+)?(\.(\*|\d+))?[diouxefgcrsa%]N©⁄defaultsc                Û0   ó |p| j         | _        || _        d S r7   )⁄default_format⁄_fmt⁄	_defaults)r•   ⁄fmtrƒ   s      r<   r´   zPercentStyle.__init__¨  s   Ä ÿ–.ò4‘.àå	ÿ!àåààr;   c                 ÛH   ó | j         †                    | j        ¶  ´        dk    S )Nr   ©r«   ⁄find⁄asctime_searchrÆ   s    r<   ⁄usesTimezPercentStyle.usesTime∞  s   Ä ÿåyè~ä~òd‘1—2‘2∞a“7–7r;   c                 Ûê   ó | j         †                    | j        ¶  ´        s&t          d| j        õd| j        d         õdù¶  ´        ÇdS )z>Validate the input format, ensure it matches the correct stylezInvalid format 'z' for 'r   z' styleN)⁄validation_pattern⁄searchr«   rb   r∆   rÆ   s    r<   ⁄validatezPercentStyle.validate≥  sU   Ä ‡‘&◊-“-®d¨i—8‘8 	i›ê*¿TƒY¿Y¿Y–PT‘Pc–de‘Pf–Pf–Pf–g—h‘h–h	i 	ir;   c                 ÛL   ó | j         x}r||j        z  }n|j        }| j        |z  S r7   )r»   ræ   r«   ©r•   ⁄recordrƒ   ⁄valuess       r<   ⁄_formatzPercentStyle._format∏  s3   Ä ÿî~–%à8 	%ÿ†§—/àFàF‡î_àFÿåyò6—!–!r;   c                 Ûv   ó 	 | †                     |¶  ´        S # t          $ r}t          d|z  ¶  ´        Çd }~ww xY w)Nz(Formatting field not found in record: %s)r◊   ⁄KeyErrorrb   )r•   r’   ⁄es      r<   ⁄formatzPercentStyle.formatø  sQ   Ä 	Mÿó<í<†—'‘'–'¯› 	M 	M 	M›–G»!—K—L‘L–L¯¯¯¯	M¯¯¯s   Ç ó
8°3≥8)r≥   r¥   rµ   r∆   ⁄asctime_formatrÕ   ⁄re⁄compile⁄Ir–   r´   rŒ   r“   r◊   r€   r:   r;   r<   r¬   r¬   •  sú   Ä Ä Ä Ä Ä ‡"ÄNÿ"ÄNÿ!ÄNÿ#òú–$\–^`‘^b—c‘c–‡(, " " " " "8 8 8i i i
" " "M M M M Mr;   r¬   c                   Ûr   ó e Zd ZdZdZdZ ej        dej        ¶  ´        Z	 ej        d¶  ´        Z
dÑ ZdÑ ZdS )	⁄StrFormatStylez	{message}z	{asctime}z{asctimezF^(.?[<>=^])?[+ -]?#?0?(\d+|{\w+})?[,_]?(\.(\d+|{\w+}))?[bcdefgnosx%]?$z^(\d+|\w+)(\.\w+|\[[^]]+\])*$c                 Û\   ó | j         x}r||j        z  }n|j        } | j        j        di |§éS ©Nr:   )r»   ræ   r«   r€   r‘   s       r<   r◊   zStrFormatStyle._formatŒ  sA   Ä ÿî~–%à8 	%ÿ†§—/àFàF‡î_àFÿàtåy‘–)–)†&–)–)–)r;   c                 Û  ó t          ¶   ´         }	 t          †                    | j        ¶  ´        D ]ê\  }}}}|rA| j        †                    |¶  ´        st          d|z  ¶  ´        Ç|†                    |¶  ´         |r|dvrt          d|z  ¶  ´        Ç|r,| j        †                    |¶  ´        st          d|z  ¶  ´        Çåën$# t          $ r}t          d|z  ¶  ´        Çd}~ww xY w|st          d¶  ´        ÇdS )zKValidate the input format, ensure it is the correct string formatting stylez!invalid field name/expression: %r⁄rsazinvalid conversion: %rzbad specifier: %rzinvalid format: %sN˙invalid format: no fields)	⁄set⁄_str_formatter⁄parser«   ⁄
field_spec⁄matchrb   rs   ⁄fmt_spec)r•   ⁄fields⁄_⁄	fieldname⁄spec⁄
conversionr⁄   s          r<   r“   zStrFormatStyle.validate’  s:  Ä Âëîà	7›2@◊2F“2F¿tƒy—2Q‘2Q A A—.êê9òd†Jÿ *ÿú?◊0“0∞—;‘; Z›(–)L»y—)X—Y‘Y–YÿóJíJòy—)‘)–)ÿ L†*∞E–"9–"9›$–%=¿
—%J—K‘K–Kÿ A†§◊ 3“ 3∞D— 9‘ 9 A›$–%8∏4—%?—@‘@–@¯A¯ı  	7 	7 	7›–1∞A—5—6‘6–6¯¯¯¯	7¯¯¯‡ 	:›–8—9‘9–9	: 	:s   êB0C √
C"√C√C"N)r≥   r¥   rµ   r∆   r‹   rÕ   r›   rﬁ   rﬂ   rÏ   rÍ   r◊   r“   r:   r;   r<   r·   r·   ∆  sk   Ä Ä Ä Ä Ä ÿ ÄNÿ ÄNÿÄN‡àråz–c–eg‘ei—j‘jÄHÿêî–<—=‘=ÄJ* * *: : : : :r;   r·   c                   Û<   á ó e Zd ZdZdZdZà fdÑZdÑ ZdÑ ZdÑ Z	à xZ
S )⁄StringTemplateStylez
${message}z
${asctime}c                 Ûl   ïó  t          ¶   ´         j        |i |§é t          | j        ¶  ´        | _        d S r7   )⁄superr´   r   r«   ⁄_tpl)r•   rà   r®   ⁄	__class__s      Är<   r´   zStringTemplateStyle.__init__Ì  s4   ¯Ä ÿçâå‘ò$–)†&–)–)–)›òTúY—'‘'àå	à	à	r;   c                 Û~   ó | j         }|†                    d¶  ´        dk    p|†                    | j        ¶  ´        dk    S )Nz$asctimer   rÀ   ©r•   r…   s     r<   rŒ   zStringTemplateStyle.usesTimeÒ  s9   Ä ÿåiàÿèxäxò
—#‘#†q“(–N®CØH™H∞T‘5H—,I‘,I»Q“,N–Nr;   c                 Ûû  ó t           j        }t          ¶   ´         }|†                    | j        ¶  ´        D ]Ü}|†                    ¶   ´         }|d         r|†                    |d         ¶  ´         å:|d         r|†                    |d         ¶  ´         å^|†                    d¶  ´        dk    rt          d¶  ´        Çåá|st          d¶  ´        Çd S )N⁄named⁄bracedr   ˙$z$invalid format: bare '$' not allowedrÊ   )	r   ⁄patternrÁ   ⁄finditerr«   ⁄	groupdictrs   ⁄grouprb   )r•   r˛   rÌ   ⁄m⁄ds        r<   r“   zStringTemplateStyle.validateı  s◊   Ä ›‘"à›ëîàÿ◊!“!†$§)—,‘, 	K 	KàAÿóíëîàAÿêåz Kÿó
í
ò1òWú:—&‘&–&–&ÿê8î Kÿó
í
ò1òXú;—'‘'–'–'ÿóíòëîòs“"–"› –!I—J‘J–J #‡ 	:›–8—9‘9–9	: 	:r;   c                 Û\   ó | j         x}r||j        z  }n|j        } | j        j        di |§éS r„   )r»   ræ   rˆ   ⁄
substituter‘   s       r<   r◊   zStringTemplateStyle._format  sA   Ä ÿî~–%à8 	%ÿ†§—/àFàF‡î_àFÿ#àtåy‘#–-–-†f–-–-–-r;   )r≥   r¥   rµ   r∆   r‹   rÕ   r´   rŒ   r“   r◊   ⁄__classcell__)r˜   s   @r<   rÛ   rÛ   Ë  sw   ¯Ä Ä Ä Ä Ä ÿ!ÄNÿ!ÄNÿ!ÄN( ( ( ( (O O O: : :. . . . . . .r;   rÛ   z"%(levelname)s:%(name)s:%(message)sz{levelname}:{name}:{message}z${levelname}:${name}:${message})˙%˙{r˝   c                   Û\   ó e Zd ZdZej        ZdddúdÑZdZdZ	dd	ÑZ
d
Ñ ZdÑ ZdÑ ZdÑ ZdÑ ZdS )r   aÿ  
    Formatter instances are used to convert a LogRecord to text.

    Formatters need to know how a LogRecord is constructed. They are
    responsible for converting a LogRecord to (usually) a string which can
    be interpreted by either a human or an external system. The base Formatter
    allows a formatting string to be specified. If none is supplied, the
    style-dependent default value, "%(message)s", "{message}", or
    "${message}", is used.

    The Formatter can be initialized with a format string which makes use of
    knowledge of the LogRecord attributes - e.g. the default value mentioned
    above makes use of the fact that the user's message and arguments are pre-
    formatted into a LogRecord's message attribute. Currently, the useful
    attributes in a LogRecord are described by:

    %(name)s            Name of the logger (logging channel)
    %(levelno)s         Numeric logging level for the message (DEBUG, INFO,
                        WARNING, ERROR, CRITICAL)
    %(levelname)s       Text logging level for the message ("DEBUG", "INFO",
                        "WARNING", "ERROR", "CRITICAL")
    %(pathname)s        Full pathname of the source file where the logging
                        call was issued (if available)
    %(filename)s        Filename portion of pathname
    %(module)s          Module (name portion of filename)
    %(lineno)d          Source line number where the logging call was issued
                        (if available)
    %(funcName)s        Function name
    %(created)f         Time when the LogRecord was created (time.time()
                        return value)
    %(asctime)s         Textual time when the LogRecord was created
    %(msecs)d           Millisecond portion of the creation time
    %(relativeCreated)d Time in milliseconds when the LogRecord was created,
                        relative to the time the logging module was loaded
                        (typically at application startup time)
    %(thread)d          Thread ID (if available)
    %(threadName)s      Thread name (if available)
    %(process)d         Process ID (if available)
    %(message)s         The result of record.getMessage(), computed just as
                        the record is emitted
    Nr  Tr√   c                Û:  ó |t           vr<t          dd†                    t           †                    ¶   ´         ¶  ´        z  ¶  ´        Çt          |         d         ||¨¶  ´        | _        |r| j        †                    ¶   ´          | j        j        | _        || _        dS )aà  
        Initialize the formatter with specified format strings.

        Initialize the formatter either with the specified format string, or a
        default as described above. Allow for specialized date formatting with
        the optional datefmt argument. If datefmt is omitted, you get an
        ISO8601-like (or RFC 3339-like) format.

        Use a style parameter of '%', '{' or '$' to specify that you want to
        use one of %-formatting, :meth:`str.format` (``{}``) formatting or
        :class:`string.Template` formatting in your format string.

        .. versionchanged:: 3.2
           Added the ``style`` parameter.
        ˙Style must be one of: %s˙,r   r√   N)⁄_STYLESrb   ⁄join⁄keys⁄_styler“   r«   ⁄datefmt)r•   r…   r  ⁄styler“   rƒ   s         r<   r´   zFormatter.__init__@  sî   Ä " ù––›–7∏#ø(∫(›$ü\ö\ô^ú^Ò;-Ù ;-Ò -Ò .Ù . .Âòeîn†Q‘'®∞h–?—?‘?àåÿ 	#ÿåK◊ “ —"‘"–"‡îK‘$àå	ÿàåààr;   z%Y-%m-%d %H:%M:%Sz%s,%03dc                 ÛŒ   ó | †                     |j        ¶  ´        }|rt          j        ||¶  ´        }n2t          j        | j        |¶  ´        }| j        r| j        ||j        fz  }|S )a%  
        Return the creation time of the specified LogRecord as formatted text.

        This method should be called from format() by a formatter which
        wants to make use of a formatted time. This method can be overridden
        in formatters to provide for any specific requirement, but the
        basic behaviour is as follows: if datefmt (a string) is specified,
        it is used with time.strftime() to format the creation time of the
        record. Otherwise, an ISO8601-like (or RFC 3339-like) format is used.
        The resulting string is returned. This function uses a user-configurable
        function to convert the creation time to a tuple. By default,
        time.localtime() is used; to change this for a particular formatter
        instance, set the 'converter' attribute to a function with the same
        signature as time.localtime() or time.gmtime(). To change it for all
        formatters, for example if you want all logging times to be shown in GMT,
        set the 'converter' attribute in the Formatter class.
        )⁄	converterrî   rÅ   ⁄strftime⁄default_time_format⁄default_msec_formatrï   )r•   r’   r  r©   ⁄ss        r<   ⁄
formatTimezFormatter.formatTime^  sl   Ä $ è^ä^òFúN—+‘+àÿ 	A›îòg†r—*‘*àAàAÂîòd‘6∏—;‘;àAÿ‘' Aÿ‘,∞∞6¥<–/@—@êÿàr;   c                 Û  ó t          j        ¶   ´         }|d         }t          j        |d         |d         |d|¶  ´         |†                    ¶   ´         }|†                    ¶   ´          |ddÖ         dk    r
|ddÖ         }|S )zß
        Format and return the specified exception information as a string.

        This default implementation just uses
        traceback.print_exception()
        rL   r   rH   NÈˇˇˇˇ˙
)⁄io⁄StringIO⁄	traceback⁄print_exception⁄getvalue⁄close)r•   ⁄ei⁄sio⁄tbr  s        r<   ⁄formatExceptionzFormatter.formatExceptiony  sx   Ä ı åkâmåmàÿêåUàı 	‘!†"†Q§%®®A¨∞∞D∏#—>‘>–>ÿèLäLâNåNàÿè	ä	âåàÿàRàSàSå6êTä>à>ÿê#ê2ê#îàAÿàr;   c                 Û4   ó | j         †                    ¶   ´         S )zK
        Check if the format uses the creation time of the record.
        )r  rŒ   rÆ   s    r<   rŒ   zFormatter.usesTimeå  s   Ä  å{◊#“#—%‘%–%r;   c                 Û6   ó | j         †                    |¶  ´        S r7   )r  r€   ©r•   r’   s     r<   ⁄formatMessagezFormatter.formatMessageí  s   Ä ÿå{◊!“!†&—)‘)–)r;   c                 Û   ó |S )aU  
        This method is provided as an extension point for specialized
        formatting of stack information.

        The input data is a string as returned from a call to
        :func:`traceback.print_stack`, but with the last trailing newline
        removed.

        The base implementation just returns the value passed in.
        r:   )r•   rë   s     r<   ⁄formatStackzFormatter.formatStackï  s
   Ä  –r;   c                 Û⁄  ó |†                     ¶   ´         |_        | †                    ¶   ´         r | †                    || j        ¶  ´        |_        | †                    |¶  ´        }|j        r&|j        s| †	                    |j        ¶  ´        |_        |j        r|ddÖ         dk    r|dz   }||j        z   }|j
        r0|ddÖ         dk    r|dz   }|| †                    |j
        ¶  ´        z   }|S )az  
        Format the specified record as text.

        The record's attribute dictionary is used as the operand to a
        string formatting operation which yields the returned string.
        Before formatting the dictionary, a couple of preparatory steps
        are carried out. The message attribute of the record is computed
        using LogRecord.getMessage(). If the formatting string uses the
        time (as determined by a call to usesTime(), formatTime() is
        called to format the event time. If there is exception information,
        it is formatted using formatException() and appended to the message.
        r  Nr  )r±   ⁄messagerŒ   r  r  ⁄asctimer*  rN   rê   r&  rë   r,  )r•   r’   r  s      r<   r€   zFormatter.format¢  sˆ   Ä   ◊*“*—,‘,àåÿè=ä=â?å? 	Cÿ!ü_ö_®V∞T¥\—B‘BàFåNÿ◊“òv—&‘&àÿå? 	H î? Hÿ"&◊"6“"6∞v¥—"G‘"Gêîÿå? 	$ÿêêêåvòä~à~ÿòëHêÿêFîO—#àAÿ‘ 	8ÿêêêåvòä~à~ÿòëHêÿêD◊$“$†V‘%6—7‘7—7àAÿàr;   )NNr  Tr7   )r≥   r¥   rµ   r∂   rÅ   ⁄	localtimer  r´   r  r  r  r&  rŒ   r*  r,  r€   r:   r;   r<   r   r     s∂   Ä Ä Ä Ä Ä ( (T îÄIÿ    6 .–ÿ#–   6  && & &* * *      r;   r   c                   Û,   ó e Zd ZdZddÑZdÑ ZdÑ ZdÑ ZdS )r   zB
    A formatter suitable for formatting a number of records.
    Nc                 Û4   ó |r	|| _         dS t          | _         dS )zm
        Optionally specify a formatter which will be used to format each
        individual record.
        N)⁄linefmt⁄_defaultFormatter)r•   r3  s     r<   r´   zBufferingFormatter.__init__À  s"   Ä 
  	-ÿ"àDåLàLàLÂ,àDåLàLàLr;   c                 Û   ó dS )zE
        Return the header string for the specified records.
        rΩ   r:   ©r•   ⁄recordss     r<   ⁄formatHeaderzBufferingFormatter.formatHeader’  Û	   Ä  àrr;   c                 Û   ó dS )zE
        Return the footer string for the specified records.
        rΩ   r:   r6  s     r<   ⁄formatFooterzBufferingFormatter.formatFooter€  r9  r;   c                 Û‘   ó d}t          |¶  ´        dk    rR|| †                    |¶  ´        z   }|D ]}|| j        †                    |¶  ´        z   }å || †                    |¶  ´        z   }|S )zQ
        Format the specified records and return the result as a string.
        rΩ   r   )rÑ   r8  r3  r€   r;  )r•   r7  rd   r’   s       r<   r€   zBufferingFormatter.format·  sz   Ä  à›àwâ<å<ò!“–ÿêd◊'“'®—0‘0—0àBÿ! 6 6êÿò$ú,◊-“-®f—5‘5—5êêÿêd◊'“'®—0‘0—0àBÿà	r;   r7   )r≥   r¥   rµ   r∂   r´   r8  r;  r€   r:   r;   r<   r   r   «  s_   Ä Ä Ä Ä Ä  - - - -    
 
 
 
 
r;   r   c                   Û    ó e Zd ZdZddÑZdÑ ZdS )r   aˆ  
    Filter instances are used to perform arbitrary filtering of LogRecords.

    Loggers and Handlers can optionally use Filter instances to filter
    records as desired. The base filter class only allows events which are
    below a certain point in the logger hierarchy. For example, a filter
    initialized with "A.B" will allow events logged by loggers "A.B",
    "A.B.C", "A.B.C.D", "A.B.D" etc. but not "A.BB", "B.A.B" etc. If
    initialized with the empty string, all events are passed.
