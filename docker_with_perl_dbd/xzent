UTF8_DISALLOW_SURROGATE|5.013009|5.013009|
utf8_distance|5.006000|5.006000|
UTF8_EIGHT_BIT_HI|5.007001||Viu
UTF8_EIGHT_BIT_LO|5.007001||Viu
UTF8f|5.019001|5.003007|p
UTF8fARG|5.019002|5.003007|p
UTF8_GOT_ABOVE_31_BIT|5.025006||Viu
UTF8_GOT_CONTINUATION|5.025006|5.025006|
UTF8_GOT_EMPTY|5.025006|5.025006|
UTF8_GOT_LONG|5.025006|5.025006|
UTF8_GOT_NONCHAR|5.025006|5.025006|
UTF8_GOT_NON_CONTINUATION|5.025006|5.025006|
UTF8_GOT_OVERFLOW|5.025006|5.025006|
UTF8_GOT_PERL_EXTENDED|5.027002|5.027002|
UTF8_GOT_SHORT|5.025006|5.025006|
UTF8_GOT_SUPER|5.025006|5.025006|
UTF8_GOT_SURROGATE|5.025006|5.025006|
utf8_hop|5.006000|5.006000|n
utf8_hop_back|5.025007|5.025007|n
utf8_hop_forward|5.025007|5.025007|n
utf8_hop_safe|5.025007|5.025007|n
UTF8_IS_ABOVE_LATIN1|5.017004||Viu
UTF8_IS_ABOVE_LATIN1_START|5.023003||Viu
UTF8_IS_CONTINUATION|5.007001||Viu
UTF8_IS_CONTINUED|5.007001||Viu
UTF8_IS_DOWNGRADEABLE_START|5.007001||Viu
UTF8_IS_INVARIANT|5.007001|5.003007|p
UTF8_IS_NEXT_CHAR_DOWNGRADEABLE|5.017006||Viu
UTF8_IS_NONCHAR|5.023002|5.023002|
UTF8_IS_NONCHAR_GIVEN_THAT_NON_SUPER_AND_GE_PROBLEMATIC|5.013009||Viu
UTF8_IS_PERL_EXTENDED|5.035004||Viu
UTF8_IS_REPLACEMENT|||
UTF8_IS_START|5.007001||Viu
UTF8_IS_START_base|5.031007||Viu
UTF8_IS_SUPER|5.023002|5.023002|
UTF8_IS_SURROGATE|5.023002|5.023002|
utf8_length|5.007001|5.007001|
UTF8_MAXBYTES|5.009002|5.006000|p
UTF8_MAXBYTES_CASE|5.009002|5.003007|p
UTF8_MAX_FOLD_CHAR_EXPAND|5.013009||Viu
UTF8_MAXLEN|5.006000||Viu
utf8_mg_len_cache_update|5.013003||Viu
utf8_mg_pos_cache_update|5.009004||Viu
utf8n_to_uvchr|5.007001|5.007001|n
utf8n_to_uvchr_error|5.025006|5.025006|n
utf8n_to_uvchr_msgs|5.027009|5.027009|n
_utf8n_to_uvchr_msgs_helper|5.029001||cVnu
utf8n_to_uvuni|5.007001||dcV
UTF8_SAFE_SKIP|5.029009|5.006000|p
UTF8SKIP|5.006000|5.006000|
UTF8_SKIP|5.023002|5.006000|p
utf8_to_bytes|5.006001|5.006001|x
utf8_to_utf16|5.035004||Viu
utf8_to_utf16_base|5.035004||xcViu
utf8_to_utf16_reversed|5.035004||Viu
utf8_to_uvchr|5.007001|5.006001|pd
utf8_to_uvchr_buf|5.015009|5.006001|p
utf8_to_uvchr_buf_helper|5.031004||cVu
utf8_to_uvuni|5.007001||dcV
utf8_to_uvuni_buf|5.015009||dcV
UTF8_TWO_BYTE_HI|5.011002||Viu
UTF8_TWO_BYTE_HI_nocast|5.011002||Viu
UTF8_TWO_BYTE_LO|5.011002||Viu
UTF8_TWO_BYTE_LO_nocast|5.011002||Viu
UTF8_WARN_ABOVE_31_BIT|5.023006||Viu
UTF8_WARN_FE_FF|5.013009||Viu
UTF8_WARN_ILLEGAL_C9_INTERCHANGE|5.025005|5.025005|
UTF8_WARN_ILLEGAL_INTERCHANGE|5.013009|5.013009|
UTF8_WARN_NONCHAR|5.013009|5.013009|
UTF8_WARN_PERL_EXTENDED|5.027002|5.027002|
UTF8_WARN_SUPER|5.013009|5.013009|
UTF8_WARN_SURROGATE|5.013009|5.013009|
UTF_ACCUMULATION_SHIFT|5.007001||Viu
UTF_CONTINUATION_BYTE_INFO_BITS|5.035004||Viu
UTF_CONTINUATION_MARK|5.007001||Viu
UTF_CONTINUATION_MASK|5.007001||Viu
UTF_EBCDIC_CONTINUATION_BYTE_INFO_BITS|5.035004||Viu
UTF_FIRST_CONT_BYTE_110000|5.035004||Viu
UTF_FIRST_CONT_BYTE|5.035004||Viu
UTF_IS_CONTINUATION_MASK|5.023006||Viu
UTF_MIN_ABOVE_LATIN1_BYTE|5.031006||Viu
UTF_MIN_CONTINUATION_BYTE|5.035004||Viu
UTF_MIN_START_BYTE|5.031006||Viu
UTF_START_BYTE_110000|5.035004||Viu
UTF_START_BYTE|5.035004||Viu
UTF_START_MARK|5.007001||Viu
UTF_START_MASK|5.007001||Viu
UTF_TO_NATIVE|5.007001||Viu
utilize|5.003007||Viu
utime|5.005000||Viu
U_V|5.006000|5.003007|
UVCHR_IS_INVARIANT|5.019004|5.003007|p
UVCHR_SKIP|5.022000|5.003007|p
uvchr_to_utf8|5.007001|5.007001|
uvchr_to_utf8_flags|5.007003|5.007003|
uvchr_to_utf8_flags_msgs|5.027009|5.027009|
UV_DIG|5.006000||Viu
UVf|5.010000|5.010000|d
UV_IS_QUAD|5.006000||Viu
UV_MAX|5.003007|5.003007|
UV_MAX_P1|5.007002||Viu
UV_MAX_P1_HALF|5.007002||Viu
UV_MIN|5.003007|5.003007|
UVof|5.006000|5.003007|poVn
uvoffuni_to_utf8_flags|5.027009||cV
uvoffuni_to_utf8_flags_msgs|5.027009||cVu
UVSIZE|5.006000|5.003007|poVn
UVTYPE|5.006000|5.003007|poVn
UVuf|5.006000|5.003007|poVn
uvuni_to_utf8|5.019004||cVu
uvuni_to_utf8_flags|5.007003||dcV
UVxf|5.006000|5.003007|poVn
UVXf|5.007001|5.007001|poVn
VAL_EAGAIN|5.003007|5.003007|Vn
validate_proto|5.019002||xcVi
validate_suid|||iu
valid_utf8_to_uvchr|5.015009||cVn
valid_utf8_to_uvuni|5.015009||dcVu
VAL_O_NONBLOCK|5.003007|5.003007|Vn
variant_byte_number|5.031004||cVnu
variant_under_utf8_count|5.027007||Vni
varname|5.009003||Viu
vcmp|5.009000|5.009000|
VCMP|5.019008||Viu
vcroak|5.006000|5.006000|
vdeb|5.007003|5.007003|u
VERB|5.009005||Viu
VERB_t8|5.035004||Viu
VERB_t8_p8|5.033003||Viu
VERB_t8_pb|5.033003||Viu
VERB_tb|5.035004||Viu
VERB_tb_p8|5.033003||Viu
VERB_tb_pb|5.033003||Viu
vform|5.006000|5.006000|
vfprintf|5.003007||Viu
visit|5.005000||Viu
vivify_defelem|5.004000||cViu
vivify_ref|5.004000||Viu
vload_module|5.006000|5.003007|p
vmess|5.006000|5.004000|p
vnewSVpvf|5.006000|5.004000|p
vnormal|5.009002|5.009002|
VNORMAL|5.019008||Viu
vnumify|5.009000|5.009000|
VNUMIFY|5.019008||Viu
voidnonfinal|5.035002||Viu
VOL|5.003007||Viu
vstringify|5.009000|5.009000|
VSTRINGIFY|5.019008||Viu
VTBL_amagic|5.005003||Viu
VTBL_amagicelem|5.005003||Viu
VTBL_arylen|5.005003||Viu
VTBL_bm|5.005003||Viu
VTBL_collxfrm|5.005003||Viu
VTBL_dbline|5.005003||Viu
VTBL_defelem|5.005003||Viu
VTBL_env|5.005003||Viu
VTBL_envelem|5.005003||Viu
VTBL_fm|5.005003||Viu
VTBL_glob|5.005003||Viu
VTBL_isa|5.005003||Viu
VTBL_isaelem|5.005003||Viu
VTBL_mglob|5.005003||Viu
VTBL_nkeys|5.005003||Viu
VTBL_pack|5.005003||Viu
VTBL_packelem|5.005003||Viu
VTBL_pos|5.005003||Viu
VTBL_regdata|5.006000||Viu
VTBL_regdatum|5.006000||Viu
VTBL_regexp|5.005003||Viu
VTBL_sigelem|5.005003||Viu
VTBL_substr|5.005003||Viu
VTBL_sv|5.005003||Viu
VTBL_taint|5.005003||Viu
VTBL_uvar|5.005003||Viu
VTBL_vec|5.005003||Viu
vTHX|5.006000||Viu
VT_NATIVE|5.021004||Viu
vtohl|5.003007||Viu
vtohs|5.003007||Viu
VUTIL_REPLACE_CORE|5.019008||Viu
vverify|5.009003|5.009003|
VVERIFY|5.019008||Viu
vwarn|5.006000|5.003007|
vwarner|5.006000|5.004000|p
wait4pid|5.003007||Viu
wait|5.005000||Viu
want_vtbl_bm|5.015000||Viu
want_vtbl_fm|5.015000||Viu
warn|5.003007||vV
WARN_ALL|5.006000|5.003007|p
WARN_ALLstring|5.006000||Viu
WARN_AMBIGUOUS|5.006000|5.003007|p
WARN_ASSERTIONS||5.003007|ponu
WARN_BAREWORD|5.006000|5.003007|p
WARN_CLOSED|5.006000|5.003007|p
WARN_CLOSURE|5.006000|5.003007|p
WARN_DEBUGGING|5.006000|5.003007|p
WARN_DEPRECATED|5.006000|5.003007|p
WARN_DIGIT|5.006000|5.003007|p
warner|5.006000||pvV
warner_nocontext|5.006000||vVn
WARN_EXEC|5.006000|5.003007|p
WARN_EXITING|5.006000|5.003007|p
WARN_EXPERIMENTAL|5.017004|5.017004|
WARN_EXPERIMENTAL__ALPHA_ASSERTIONS|5.027009|5.027009|
WARN_EXPERIMENTAL__ARGS_ARRAY_WITH_SIGNATURES|5.035009|5.035009|
WARN_EXPERIMENTAL__BITWISE|5.021009|5.021009|
WARN_EXPERIMENTAL__BUILTIN|5.035009|5.035009|
WARN_EXPERIMENTAL__CONST_ATTR|5.021008|5.021008|
WARN_EXPERIMENTAL__DECLARED_REFS|5.025003|5.025003|
WARN_EXPERIMENTAL__DEFER|5.035004|5.035004|
WARN_EXPERIMENTAL__FOR_LIST|5.035005|5.035005|
WARN_EXPERIMENTAL__ISA|5.031007|5.031007|
WARN_EXPERIMENTAL__LEXICAL_SUBS|5.017005|5.017005|
WARN_EXPERIMENTAL__POSTDEREF|5.019005|5.019005|
WARN_EXPERIMENTAL__PRIVATE_USE|5.029009|5.029009|
WARN_EXPERIMENTAL__REFALIASING|5.021005|5.021005|
WARN_EXPERIMENTAL__REGEX_SETS|5.017008|5.017008|
WARN_EXPERIMENTAL__RE_STRICT|5.021008|5.021008|
WARN_EXPERIMENTAL__SCRIPT_RUN|5.027008|5.027008|
WARN_EXPERIMENTAL__SIGNATURES|5.019009|5.019009|
WARN_EXPERIMENTAL__SMARTMATCH|5.017011|5.017011|
WARN_EXPERIMENTAL__TRY|5.033007|5.033007|
WARN_EXPERIMENTAL__UNIPROP_WILDCARDS|5.029009|5.029009|
WARN_EXPERIMENTAL__VLB|5.029009|5.029009|
WARN_GLOB|5.006000|5.003007|p
WARN_ILLEGALPROTO|5.011004|5.011004|
WARN_IMPRECISION|5.011000|5.011000|
WARN_INPLACE|5.006000|5.003007|p
WARN_INTERNAL|5.006000|5.003007|p
WARN_IO|5.006000|5.003007|p
WARN_LAYER|5.008000|5.003007|p
WARN_LOCALE|5.021006|5.021006|
WARN_MALLOC|5.006000|5.003007|p
WARN_MISC|5.006000|5.003007|p
WARN_MISSING|5.021002|5.021002|
WARN_NEWLINE|5.006000|5.003007|p
warn_nocontext|5.006000||pvVn
WARN_NONCHAR|5.013010|5.013010|
WARN_NONEstring|5.006000||Viu
WARN_NON_UNICODE|5.013010|5.013010|
WARN_NUMERIC|5.006000|5.003007|p
WARN_ONCE|5.006000|5.003007|p
warn_on_first_deprecated_use|5.025009||Viu
WARN_OVERFLOW|5.006000|5.003007|p
WARN_PACK|5.006000|5.003007|p
WARN_PARENTHESIS|5.006000|5.003007|p
WARN_PIPE|5.006000|5.003007|p
WARN_PORTABLE|5.006000|5.003007|p
WARN_PRECEDENCE|5.006000|5.003007|p
WARN_PRINTF|5.006000|5.003007|p
_warn_problematic_locale|5.021008||cVniu
WARN_PROTOTYPE|5.006000|5.003007|p
WARN_QW|5.006000|5.003007|p
WARN_RECURSION|5.006000|5.003007|p
WARN_REDEFINE|5.006000|5.003007|p
WARN_REDUNDANT|5.021002|5.021002|
WARN_REGEXP|5.006000|5.003007|p
WARN_RESERVED|5.006000|5.003007|p
WARN_SEMICOLON|5.006000|5.003007|p
WARN_SEVERE|5.006000|5.003007|p
WARN_SHADOW|5.027007|5.027007|
WARNshift|5.011001||Viu
WARN_SIGNAL|5.006000|5.003007|p
WARNsize|5.006000||Viu
WARN_SUBSTR|5.006000|5.003007|p
WARN_SURROGATE|5.013010|5.013010|
warn_sv|5.013001|5.003007|p
WARN_SYNTAX|5.006000|5.003007|p
WARN_SYSCALLS|5.019004|5.019004|
WARN_TAINT|5.006000|5.003007|p
WARN_THREADS|5.008000|5.003007|p
WARN_UNINITIALIZED|5.006000|5.003007|p
WARN_UNOPENED|5.006000|5.003007|p
WARN_UNPACK|5.006000|5.003007|p
WARN_UNTIE|5.006000|5.003007|p
WARN_UTF8|5.006000|5.003007|p
WARN_VOID|5.006000|5.003007|p
was_lvalue_sub|||ciu
watch|5.003007||Viu
WB_BREAKABLE|5.023008||Viu
WB_DQ_then_HL|5.023008||Viu
WB_Ex_or_FO_or_ZWJ_then_foo|5.025003||Viu
WB_HL_then_DQ|5.023008||Viu
WB_hs_then_hs|5.023008||Viu
WB_LE_or_HL_then_MB_or_ML_or_SQ|5.023008||Viu
WB_MB_or_ML_or_SQ_then_LE_or_HL|5.023008||Viu
WB_MB_or_MN_or_SQ_then_NU|5.023008||Viu
WB_NOBREAK|5.023008||Viu
WB_NU_then_MB_or_MN_or_SQ|5.023008||Viu
WB_RI_then_RI|5.025003||Viu
WCTOMB_LOCK|5.033005||Viu
WCTOMB_UNLOCK|5.033005||Viu
what_MULTI_CHAR_FOLD_latin1_safe|5.033005||Viu
what_MULTI_CHAR_FOLD_utf8_safe|5.033005||Viu
what_MULTI_CHAR_FOLD_utf8_safe_part0|5.033005||Viu
what_MULTI_CHAR_FOLD_utf8_safe_part1|5.033005||Viu
what_MULTI_CHAR_FOLD_utf8_safe_part2|5.033005||Viu
what_MULTI_CHAR_FOLD_utf8_safe_part3|5.033005||Viu
what_MULTI_CHAR_FOLD_utf8_safe_part4|5.033005||Viu
what_MULTI_CHAR_FOLD_utf8_safe_part5|5.033005||Viu
what_MULTI_CHAR_FOLD_utf8_safe_part6|5.033005||Viu
what_MULTI_CHAR_FOLD_utf8_safe_part7|5.033005||Viu
whichsig|5.003007|5.003007|
whichsig_pv|5.015004|5.015004|
whichsig_pvn|5.015004|5.015004|
whichsig_sv|5.015004|5.015004|
WHILEM|5.003007||Viu
WHILEM_A_max|5.009005||Viu
WHILEM_A_max_fail|5.009005||Viu
WHILEM_A_max_fail_t8|5.035004||Viu
WHILEM_A_max_fail_t8_p8|5.033003||Viu
WHILEM_A_max_fail_t8_pb|5.033003||Viu
WHILEM_A_max_fail_tb|5.035004||Viu
WHILEM_A_max_fail_tb_p8|5.033003||Viu
WHILEM_A_max_fail_tb_pb|5.033003||Viu
WHILEM_A_max_t8|5.035004||Viu
WHILEM_A_max_t8_p8|5.033003||Viu
WHILEM_A_max_t8_pb|5.033003||Viu
WHILEM_A_max_tb|5.035004||Viu
WHILEM_A_max_tb_p8|5.033003||Viu
WHILEM_A_max_tb_pb|5.033003||Viu
WHILEM_A_min|5.009005||Viu
WHILEM_A_min_fail|5.009005||Viu
WHILEM_A_min_fail_t8|5.035004||Viu
WHILEM_A_min_fail_t8_p8|5.033003||Viu
WHILEM_A_min_fail_t8_pb|5.033003||Viu
WHILEM_A_min_fail_tb|5.035004||Viu
WHILEM_A_min_fail_tb_p8|5.033003||Viu
WHILEM_A_min_fail_tb_pb|5.033003||Viu
WHILEM_A_min_t8|5.035004||Viu
WHILEM_A_min_t8_p8|5.033003||Viu
WHILEM_A_min_t8_pb|5.033003||Viu
WHILEM_A_min_tb|5.035004||Viu
WHILEM_A_min_tb_p8|5.033003||Viu
WHILEM_A_min_tb_pb|5.033003||Viu
WHILEM_A_pre|5.009005||Viu
WHILEM_A_pre_fail|5.009005||Viu
WHILEM_A_pre_fail_t8|5.035004||Viu
WHILEM_A_pre_fail_t8_p8|5.033003||Viu
WHILEM_A_pre_fail_t8_pb|5.033003||Viu
WHILEM_A_pre_fail_tb|5.035004||Viu
WHILEM_A_pre_fail_tb_p8|5.033003||Viu
WHILEM_A_pre_fail_tb_pb|5.033003||Viu
WHILEM_A_pre_t8|5.035004||Viu
WHILEM_A_pre_t8_p8|5.033003||Viu
WHILEM_A_pre_t8_pb|5.033003||Viu
WHILEM_A_pre_tb|5.035004||Viu
WHILEM_A_pre_tb_p8|5.033003||Viu
WHILEM_A_pre_tb_pb|5.033003||Viu
WHILEM_B_max|5.009005||Viu
WHILEM_B_max_fail|5.009005||Viu
WHILEM_B_max_fail_t8|5.035004||Viu
WHILEM_B_max_fail_t8_p8|5.033003||Viu
WHILEM_B_max_fail_t8_pb|5.033003||Viu
WHILEM_B_max_fail_tb|5.035004||Viu
WHILEM_B_max_fail_tb_p8|5.033003||Viu
WHILEM_B_max_fail_tb_pb|5.033003||Viu
WHILEM_B_max_t8|5.035004||Viu
WHILEM_B_max_t8_p8|5.033003||Viu
WHILEM_B_max_t8_pb|5.033003||Viu
WHILEM_B_max_tb|5.035004||Viu
WHILEM_B_max_tb_p8|5.033003||Viu
WHILEM_B_max_tb_pb|5.033003||Viu
WHILEM_B_min|5.009005||Viu
WHILEM_B_min_fail|5.009005||Viu
WHILEM_B_min_fail_t8|5.035004||Viu
WHILEM_B_min_fail_t8_p8|5.033003||Viu
WHILEM_B_min_fail_t8_pb|5.033003||Viu
WHILEM_B_min_fail_tb|5.035004||Viu
WHILEM_B_min_fail_tb_p8|5.033003||Viu
WHILEM_B_min_fail_tb_pb|5.033003||Viu
WHILEM_B_min_t8|5.035004||Viu
WHILEM_B_min_t8_p8|5.033003||Viu
WHILEM_B_min_t8_pb|5.033003||Viu
WHILEM_B_min_tb|5.035004||Viu
WHILEM_B_min_tb_p8|5.033003||Viu
WHILEM_B_min_tb_pb|5.033003||Viu
WHILEM_t8|5.035004||Viu
WHILEM_t8_p8|5.033003||Viu
WHILEM_t8_pb|5.033003||Viu
WHILEM_tb|5.035004||Viu
WHILEM_tb_p8|5.033003||Viu
WHILEM_tb_pb|5.033003||Viu
WIDEST_UTYPE|5.015004|5.003007|poVnu
win32_croak_not_implemented|5.017006||Vniu
WIN32SCK_IS_STDSCK|5.007001||Viu
win32_setlocale|5.027006||Viu
withinCOUNT|5.031004||Viu
withinCOUNT_KNOWN_VALID|5.033005||Viu
WITH_LC_NUMERIC_SET_TO_NEEDED|5.031003|5.031003|
WITH_LC_NUMERIC_SET_TO_NEEDED_IN|5.031003|5.031003|
with_queued_errors|5.013001||Viu
with_tp_UTF8ness|5.033003||Viu
with_t_UTF8ness|5.035004||Viu
wrap_keyword_plugin|5.027006|5.027006|x
wrap_op_checker|5.015008|5.015008|
write|5.005000||Viu
write_to_stderr|5.008001||Viu
XCPT_CATCH|5.009002|5.003007|p
XCPT_RETHROW|5.009002|5.003007|p
XCPT_TRY_END|5.009002|5.003007|p
XCPT_TRY_START|5.009002|5.003007|p
XDIGIT_VALUE|5.019008||Viu
xio_any|5.006001||Viu
xio_dirp|5.006001||Viu
xiv_iv|5.009003||Viu
xlv_targoff|5.019004||Viu
XopDISABLE|5.013007|5.013007|V
XOPd_xop_class|5.013007||Viu
XOPd_xop_desc|5.013007||Viu
XOPd_xop_name|5.013007||Viu
XOPd_xop_peep|5.013007||Viu
XopENABLE|5.013007|5.013007|V
XopENTRY|5.013007|5.013007|V
XopENTRYCUSTOM|5.019006|5.013007|V
XopENTRY_set|5.013007|5.013007|V
XopFLAGS|5.013007|5.013007|
XOPf_xop_class|5.013007||Viu
XOPf_xop_desc|5.013007||Viu
XOPf_xop_name|5.013007||Viu
XOPf_xop_peep|5.013007||Viu
XORSHIFT128_set|5.027001||Viu
XORSHIFT96_set|5.027001||Viu
XPUSHi|5.003007|5.003007|
XPUSHmortal|5.009002|5.003007|p
XPUSHn|5.006000|5.003007|
XPUSHp|5.003007|5.003007|
XPUSHs|5.003007|5.003007|
XPUSHTARG|5.003007||Viu
XPUSHu|5.004000|5.003007|p
XPUSHundef|5.006000||Viu
xpv_len|5.017006||Viu
XS|5.003007|5.003007|Vu
XSANY|5.003007||Viu
XS_APIVERSION_BOOTCHECK|5.013004|5.013004|
XS_APIVERSION_POPMARK_BOOTCHECK|5.021006||Viu
XS_APIVERSION_SETXSUBFN_POPMARK_BOOTCHECK|5.021006||Viu
xs_boot_epilog|5.021006||cViu
XS_BOTHVERSION_BOOTCHECK|5.021006||Viu
XS_BOTHVERSION_POPMARK_BOOTCHECK|5.021006||Viu
XS_BOTHVERSION_SETXSUBFN_POPMARK_BOOTCHECK|5.021006||Viu
XS_DYNAMIC_FILENAME|5.009004||Viu
XS_EXTERNAL|5.015002|5.015002|Vu
xs_handshake|||vcniu
XSINTERFACE_CVT|5.005000||Viu
XSINTERFACE_CVT_ANON|5.010000||Viu
XSINTERFACE_FUNC|5.005000||Viu
XSINTERFACE_FUNC_SET|5.005000||Viu
XS_INTERNAL|5.015002|5.015002|Vu
XSprePUSH|5.006000|5.003007|poVnu
XSPROTO|5.010000|5.003007|pVu
XSRETURN|5.003007|5.003007|p
XSRETURN_EMPTY|5.003007|5.003007|
XSRETURN_IV|5.003007|5.003007|
XSRETURN_NO|5.003007|5.003007|
XSRETURN_NV|5.006000|5.003007|
XSRETURN_PV|5.003007|5.003007|
XSRETURN_PVN|5.006000||Viu
XSRETURN_UNDEF|5.003007|5.003007|
XSRETURN_UV|5.008001|5.003007|p
XSRETURN_YES|5.003007|5.003007|
XS_SETXSUBFN_POPMARK|5.021006||Viu
XST_mIV|5.003007|5.003007|
XST_mNO|5.003007|5.003007|
XST_mNV|5.006000|5.003007|
XST_mPV|5.003007|5.003007|
XST_mPVN|5.006000||Viu
XST_mUNDEF|5.003007|5.003007|
XST_mUV|5.008001|5.003007|p
XST_mYES|5.003007|5.003007|
XS_VERSION|5.003007|5.003007|
XS_VERSION_BOOTCHECK|5.003007|5.003007|
xs_version_bootcheck|||iu
XTENDED_PAT_MOD|5.009005||Viu
xuv_uv|5.009003||Viu
YESEXPR|5.027010||Viu
YESSTR|5.027010||Viu
YIELD|5.005000||Viu
YYDEBUG|5.025006||Viu
YYEMPTY|5.009005||Viu
yyerror|5.003007||Viu
yyerror_pv|5.016000||Viu
yyerror_pvn|5.016000||Viu
yylex|5.003007||cViu
yyparse|5.003007||Viu
yyquit|5.025010||Viu
YYSTYPE_IS_DECLARED|5.009001||Viu
YYSTYPE_IS_TRIVIAL|5.009001||Viu
YYTOKENTYPE|5.009001||Viu
yyunlex|5.013005||Viu
yywarn|5.003007||Viu
ZAPHOD32_FINALIZE|5.027001||Viu
ZAPHOD32_MIX|5.027001||Viu
ZAPHOD32_SCRAMBLE32|5.027001||Viu
ZAPHOD32_STATIC_INLINE|5.027001||Viu
ZAPHOD32_WARN2|5.027001||Viu
ZAPHOD32_WARN3|5.027001||Viu
ZAPHOD32_WARN4|5.027001||Viu
ZAPHOD32_WARN5|5.027001||Viu
ZAPHOD32_WARN6|5.027001||Viu
Zero|5.003007|5.003007|
ZeroD|5.009002|5.003007|p
);

if (exists $opt{'list-unsupported'}) {
  my $f;
  for $f (sort dictionary_order keys %API) {
    next if $API{$f}{core_only};
    next if $API{$f}{beyond_depr};
    next if $API{$f}{inaccessible};
    next if $API{$f}{experimental};
    next unless $API{$f}{todo};
    next if int_parse_version($API{$f}{todo}) <= $int_min_perl;
    my $repeat = 40 - length($f);
    $repeat = 0 if $repeat < 0;
    print "$f ", '.'x $repeat, " ", format_version($API{$f}{todo}), "\n";
  }
  exit 0;
}

# Scan for hints, possible replacement candidates, etc.

my(%replace, %need, %hints, %warnings, %depends);
my $replace = 0;
my($hint, $define, $function);

sub find_api
{
  BEGIN { 'warnings'->unimport('uninitialized') if "$]" > '5.006' }
  my $code = shift;
  $code =~ s{
    / (?: \*[^*]*\*+(?:[^$ccs][^*]*\*+)* / | /[^\r\n]*)
  | "[^"\\]*(?:\\.[^"\\]*)*"
  | '[^'\\]*(?:\\.[^'\\]*)*' }{}egsx;
  grep { exists $API{$_} } $code =~ /(\w+)/mg;
}

while (<DATA>) {
  if ($hint) {

    # Here, we are in the middle of accumulating a hint or warning.
    my $end_of_hint = 0;

    # A line containing a comment end marker closes the hint.  Remove that
    # marker for processing below.
    if (s/\s*$rcce(.*?)\s*$//) {
        die "Nothing can follow the end of comment in '$_'\n" if length $1 > 0;
        $end_of_hint = 1;
    }

    # Set $h to the hash of which type.
    my $h = $hint->[0] eq 'Hint' ? \%hints : \%warnings;

    # Ignore any leading and trailing white space, and an optional star comment
    # continuation marker, then place the meat of the line into $1
    m/^\s*(?:\*\s*)?(.*?)\s*$/;

    # Add the meat of this line to the hash value of each API element it
    # applies to
    for (@{$hint->[1]}) {
      $h->{$_} ||= '';  # avoid the warning older perls generate
      $h->{$_} .= "$1\n";
    }

    # If the line had a comment close, we are through with this hint
    undef $hint if $end_of_hint;

    next;
  }

  # Set up $hint if this is the beginning of a Hint: or Warning:
  # These are from a multi-line C comment in the file, with the first line
  # looking like (a space has been inserted because this file can't have C
  # comment markers in it):
  #   / * Warning: PL_expect, PL_copline, PL_rsfp
  #
  # $hint becomes
  #     [
  #      'Warning',
  #                [
  #                  'PL_expect',
  #                  'PL_copline',
  #                  'PL_rsfp',
  #                ],
  #     ]
  if (m{^\s*$rccs\s+(Hint|Warning):\s+(\w+(?:,?\s+\w+)*)\s*$}) {
      $hint = [$1, [split /,?\s+/, $2]];
      next;
  }

  if ($define) { # If in the middle of a definition...

    # append a continuation line ending with backslash.
    if ($define->[1] =~ /\\$/) {
      $define->[1] .= $_;
    }
    else {  # Otherwise this line ends the definition, make foo depend on bar
            # (and what bar depends on) if its not one of ppp's own constructs
      if (exists $API{$define->[0]} && $define->[1] !~ /^DPPP_\(/) {
        my @n = find_api($define->[1]);
        push @{$depends{$define->[0]}}, @n if @n
      }
      undef $define;
    }
  }

  # For '#define foo bar' or '#define foo(a,b,c) bar', $define becomes a
  # reference to [ foo, bar ]
  $define = [$1, $2] if m{^\s*#\s*define\s+(\w+)(?:\([^)]*\))?\s+(.*)};

  if ($function) {
    if (/^}/) {
      if (exists $API{$function->[0]}) {
        my @n = find_api($function->[1]);
        push @{$depends{$function->[0]}}, @n if @n
      }
      undef $function;
    }
    else {
      $function->[1] .= $_;
    }
  }

  $function = [$1, ''] if m{^DPPP_\(my_(\w+)\)};

  # Set $replace to the number given for lines that look like
  # / * Replace: \d+ * /
  # Thus setting it to 1 starts a region where replacements are automatically
  # done, and setting it to 0 ends that region.
  $replace     = $1 if m{^\s*$rccs\s+Replace:\s+(\d+)\s+$rcce\s*$};

  # Add bar => foo to %replace  for lines like '#define foo bar in a region
  # where $replace is non-zero
  $replace{$2} = $1 if $replace and m{^\s*#\s*define\s+(\w+)(?:\([^)]*\))?\s+(\w+)};

  # Add bar => foo to %replace for lines like '#define foo bar  / * Replace * /
  $replace{$2} = $1 if m{^\s*#\s*define\s+(\w+)(?:\([^)]*\))?\s+(\w+).*$rccs\s+Replace\s+$rcce};

  # Add foo => bar to %replace for lines like / * Replace foo with bar * /
  $replace{$1} = $2 if m{^\s*$rccs\s+Replace (\w+) with (\w+.*?)\s+$rcce\s*$};

  # For lines like / * foo, bar depends on baz, bat * /
  # create a list of the elements on the rhs, and make that list apply to each
  # element in the lhs, which becomes a key in \%depends.
  if (m{^\s*$rccs\s+(\w+(\s*,\s*\w+)*)\s+depends\s+on\s+(\w+(\s*,\s*\w+)*)\s+$rcce\s*$}) {
    my @deps = map { s/\s+//g; $_ } split /,/, $3;
    my $d;
    for $d (map { s/\s+//g; $_ } split /,/, $1) {
      push @{$depends{$d}}, @deps;
    }
  }

  $need{$1} = 1 if m{^#if\s+defined\(NEED_(\w+)(?:_GLOBAL)?\)};
}

for (values %depends) {
  my %seen;
  $_ = [sort dictionary_order grep !$seen{$_}++, @$_];
}

if (exists $opt{'api-info'}) {
  my $f;
  my $count = 0;
  my $match = $opt{'api-info'} =~ m!^/(.*)/$! ? $1 : "^\Q$opt{'api-info'}\E\$";

  # Sort the names, and split into two classes; one for things that are part of
  # the API; a second for things that aren't.
  my @ok_to_use;
  my @shouldnt_use;
  for $f (sort dictionary_order keys %API) {
    next unless $f =~ /$match/;
    my $base = int_parse_version($API{$f}{base}) if $API{$f}{base};
    if ($base && ! $API{$f}{inaccessible} && ! $API{$f}{core_only}) {
        push @ok_to_use, $f;
    }
    else {
        push @shouldnt_use, $f;
    }
  }

  # We normally suppress non-API items.  But if the search matched no API
  # items, output the non-ones.  This allows someone to get the info for an
  # item if they ask for it specifically enough, but doesn't normally clutter
  # the output with irrelevant results.
  @ok_to_use = @shouldnt_use unless @ok_to_use;

  for $f (@ok_to_use) {
    print "\n=== $f ===\n";
    my $info = 0;
    my $base;
    $base = int_parse_version($API{$f}{base}) if $API{$f}{base};
    my $todo;
    $todo = int_parse_version($API{$f}{todo}) if $API{$f}{todo};

    # Output information
    if ($base) {
        my $with_or= "";
        if (    $base <= $int_min_perl
            || (   (! $API{$f}{provided} && ! $todo)
                || ($todo && $todo >= $base)))
        {
            $with_or= " with or";
        }

        my $Supported = ($API{$f}{undocumented}) ? 'Available' : 'Supported';
        print "\n$Supported at least since perl-",
              format_version($base), ",$with_or without $ppport.";
        if ($API{$f}{unverified}) {
            print "\nThis information is based on inspection of the source code",
                  " and has not been\n",
                  "verified by successful compilation.";
        }
        print "\n";
        $info++;
     }
     if ($API{$f}{provided} || $todo) {
        print "\nThis is only supported by $ppport, and NOT by perl versions going forward.\n" unless $base;
        if ($todo) {
            if (! $base || $todo < $base) {
                my $additionally = "";
                $additionally .= " additionally" if $base;
                print "$ppport$additionally provides support at least back to perl-",
                    format_version($todo),
                    ".\n";
            }
        }
        elsif (! $base || $base > $int_min_perl) {
            if (exists $depends{$f}) {
                my $max = 0;
                for (@{$depends{$f}}) {
                    $max = int_parse_version($API{$_}{todo}) if $API{$_}{todo} && $API{$_}{todo} > $max;
                    # XXX What to assume unspecified values are?  This effectively makes them MIN_PERL
                }
                $todo = $max if $max;
            }
            print "\n$ppport provides support for this, but ironically, does not",
                  " currently know,\n",
                  "for this report, the minimum version it supports for this";
            if ($API{$f}{undocumented}) {
                print " and many things\n",
                      "it provides that are implemented as macros and aren't",
                      " documented.  You can\n",
                      "help by submitting a documentation patch";
            }
            print ".\n";
            if ($todo) {
                if ($todo <= $int_min_perl) {
                    print "It may very well be supported all the way back to ",
                          format_version(5.003_07), ".\n";
                }
                else {
                    print "But given the things $f depends on, it's a good",
                          " guess that it isn't\n",
                          "supported prior to ", format_version($todo), ".\n";
                }
            }
        }
    }
    if ($API{$f}{provided}) {
      print "Support needs to be explicitly requested by #define NEED_$f\n",
            "(or #define NEED_${f}_GLOBAL).\n"              if exists $need{$f};
      $info++;
    }

    if ($base || ! $API{$f}{ppport_fnc}) {
      my $email = "Send email to perl5-porters\@perl.org if you need to have this functionality.\n";
      if ($API{$f}{inaccessible}) {
        print "\nThis is not part of the public API, and may not even be accessible to XS code.\n";
        $info++;
      }
      elsif ($API{$f}{core_only}) {
        print "\nThis is not part of the public API, and should not be used by XS code.\n";
        $info++;
      }
      elsif ($API{$f}{deprecated}) {
        print "\nThis is deprecated and should not be used.  Convert existing uses.\n";
        $info++;
      }
      elsif ($API{$f}{experimental}) {
        print "\nThe API for this is unstable and should not be used by XS code.\n", $email;
        $info++;
      }
      elsif ($API{$f}{undocumented}) {
        print "\nSince this is undocumented, the API should be considered unstable.\n";
        if ($API{$f}{provided}) {
            print "Consider bringing this up on the list: perl5-porters\@perl.org.\n";
        }
        else {
            print "It may be that this is not intended for XS use, or it may just be\n",
                  "that no one has gotten around to documenting it.\n", $email;
        }
        $info++;
      }
      unless ($info) {
        print "No portability information available.  Check your spelling; or",
              " this could be\na bug in Devel::PPPort.  To report an issue:\n",
              "https://github.com/Dual-Life/Devel-PPPort/issues/new\n";
      }
    }

    print "\nDepends on: ", join(', ', @{$depends{$f}}), ".\n"
                                                         if exists $depends{$f};
    if (exists $hints{$f} || exists $warnings{$f}) {
      print "\n$hints{$f}" if exists $hints{$f};
      print "\nWARNING:\n$warnings{$f}" if exists $warnings{$f};
      $info++;
    }
    $count++;
  }

  $count or print "\nFound no API matching '$opt{'api-info'}'.";
  print "\n";
  exit 0;
}

if (exists $opt{'list-provided'}) {
  my $f;
  for $f (sort dictionary_order keys %API) {
    next unless $API{$f}{provided};
    my @flags;
    push @flags, 'explicit' if exists $need{$f};
    push @flags, 'depend'   if exists $depends{$f};
    push @flags, 'hint'     if exists $hints{$f};
    push @flags, 'warning'  if exists $warnings{$f};
    my $flags = @flags ? '  ['.join(', ', @flags).']' : '';
    print "$f$flags\n";
  }
  exit 0;
}

my @files;
my @srcext = qw( .xs .c .h .cc .cpp -c.inc -xs.inc );
my $srcext = join '|', map { quotemeta $_ } @srcext;

if (@ARGV) {
  my %seen;
  for (@ARGV) {
    if (-e) {
      if (-f) {
        push @files, $_ unless $seen{$_}++;
      }
      else { warn "'$_' is not a file.\n" }
    }
    else {
      my @new = grep { -f } glob $_
          or warn "'$_' does not exist.\n";
      push @files, grep { !$seen{$_}++ } @new;
    }
  }
}
else {
  eval {
    require File::Find;
    File::Find::find(sub {
      $File::Find::name =~ /($srcext)$/i
          and push @files, $File::Find::name;
    }, '.');
  };
  if ($@) {
    @files = map { glob "*$_" } @srcext;
  }
}

if (!@ARGV || $opt{filter}) {
  my(@in, @out);
  my %xsc = map { /(.*)\.xs$/ ? ("$1.c" => 1, "$1.cc" => 1) : () } @files;
  for (@files) {
    my $out = exists $xsc{$_} || /\b\Q$ppport\E$/i || !/($srcext)$/i;
    push @{ $out ? \@out : \@in }, $_;
  }
  if (@ARGV && @out) {
    warning("Skipping the following files (use --nofilter to avoid this):\n| ", join "\n| ", @out);
  }
  @files = @in;
}

die "No input files given!\n" unless @files;

my(%files, %global, %revreplace);
%revreplace = reverse %replace;
my $filename;
my $patch_opened = 0;

for $filename (@files) {
  unless (open IN, "<$filename") {
    warn "Unable to read from $filename: $!\n";
    next;
  }

  info("Scanning $filename ...");

  my $c = do { local $/; <IN> };
  close IN;

  my %file = (orig => $c, changes => 0);

  # Temporarily remove C/XS comments and strings from the code
  my @ccom;

  $c =~ s{
    ( ^$HS*\#$HS*include\b[^\r\n]+\b(?:\Q$ppport\E|XSUB\.h)\b[^\r\n]*
    | ^$HS*\#$HS*(?:define|elif|if(?:def)?)\b[^\r\n]* )
  | ( ^$HS*\#[^\r\n]*
    | "[^"\\]*(?:\\.[^"\\]*)*"
    | '[^'\\]*(?:\\.[^'\\]*)*'
    | / (?: \*[^*]*\*+(?:[^$ccs][^*]*\*+)* / | /[^\r\n]* ) )
  }{ defined $2 and push @ccom, $2;
     defined $1 ? $1 : "$ccs$#ccom$cce" }mgsex;

  $file{ccom} = \@ccom;
  $file{code} = $c;
  $file{has_inc_ppport} = $c =~ /^$HS*#$HS*include[^\r\n]+\b\Q$ppport\E\b/m;

  my $func;

  for $func (keys %API) {
    my $match = $func;
    $match .= "|$revreplace{$func}" if exists $revreplace{$func};
    if ($c =~ /\b(?:Perl_)?($match)\b/) {
      $file{uses_replace}{$1}++ if exists $revreplace{$func} && $1 eq $revreplace{$func};
      $file{uses_Perl}{$func}++ if $c =~ /\bPerl_$func\b/;
      if (exists $API{$func}{provided}) {
        $file{uses_provided}{$func}++;
        if ( ! exists $API{$func}{base}
            || int_parse_version($API{$func}{base}) > $opt{'compat-version'})
        {
          $file{uses}{$func}++;
          my @deps = rec_depend($func);
          if (@deps) {
            $file{uses_deps}{$func} = \@deps;
            for (@deps) {
              $file{uses}{$_} = 0 unless exists $file{uses}{$_};
            }
          }
          for ($func, @deps) {
            $file{needs}{$_} = 'static' if exists $need{$_};
          }
        }
      }
      if (   exists $API{$func}{todo}
          && int_parse_version($API{$func}{todo}) > $opt{'compat-version'})
      {
        if ($c =~ /\b$func\b/) {
          $file{uses_todo}{$func}++;
        }
      }
    }
  }

  while ($c =~ /^$HS*#$HS*define$HS+(NEED_(\w+?)(_GLOBAL)?)\b/mg) {
    if (exists $need{$2}) {
      $file{defined $3 ? 'needed_global' : 'needed_static'}{$2}++;
    }
    else { warning("Possibly wrong #define $1 in $filename") }
  }

  for (qw(uses needs uses_todo needed_global needed_static)) {
    for $func (keys %{$file{$_}}) {
      push @{$global{$_}{$func}}, $filename;
    }
  }

  $files{$filename} = \%file;
}

# Globally resolve NEED_'s
my $need;
for $need (keys %{$global{needs}}) {
  if (@{$global{needs}{$need}} > 1) {
    my @targets = @{$global{needs}{$need}};
    my @t = grep $files{$_}{needed_global}{$need}, @targets;
    @targets = @t if @t;
    @t = grep /\.xs$/i, @targets;
    @targets = @t if @t;
    my $target = shift @targets;
    $files{$target}{needs}{$need} = 'global';
    for (@{$global{needs}{$need}}) {
      $files{$_}{needs}{$need} = 'extern' if $_ ne $target;
    }
  }
}

for $filename (@files) {
  exists $files{$filename} or next;

  info("=== Analyzing $filename ===");

  my %file = %{$files{$filename}};
  my $func;
  my $c = $file{code};
  my $warnings = 0;

  for $func (sort dictionary_order keys %{$file{uses_Perl}}) {
    if ($API{$func}{varargs}) {
      unless ($API{$func}{noTHXarg}) {
        my $changes = ($c =~ s{\b(Perl_$func\s*\(\s*)(?!aTHX_?)(\)|[^\s)]*\))}
                              { $1 . ($2 eq ')' ? 'aTHX' : 'aTHX_ ') . $2 }ge);
        if ($changes) {
