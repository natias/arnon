
/* Shared bit:
 *      Under /d it means the ANYOFD node matches all non-ASCII Latin1
 *          characters when the target string is not in utf8.
 *      When not under /d, it means the ANYOF node should raise a warning if
 *          matching against an above-Unicode code point.
 * (These uses are mutually exclusive because the warning requires a \p{}, and
 * \p{} implies /u which deselects /d).  An SSC node only has this bit set if
 * what is meant is the warning.  The names are to make sure that you are
 * cautioned about its shared nature */
#define ANYOFD_NON_UTF8_MATCHES_ALL_NON_ASCII__shared 0x80
#define ANYOF_WARN_SUPER__shared                      0x80

#define ANYOF_FLAGS_ALL		((U8) ~(0x10|0x20))

#define ANYOF_LOCALE_FLAGS (  ANYOFL_FOLD               \
                            | ANYOF_MATCHES_POSIXL      \
                            | ANYOFL_UTF8_LOCALE_REQD)

/* These are the flags that apply to both regular ANYOF nodes and synthetic
 * start class nodes during construction of the SSC.  During finalization of
 * the SSC, other of the flags may get added to it */
#define ANYOF_COMMON_FLAGS      0

/* Character classes for node->classflags of ANYOF */
/* Should be synchronized with a table in regprop() */
/* 2n should be the normal one, paired with its complement at 2n+1 */

#define ANYOF_ALPHA    ((CC_ALPHA_) * 2)
#define ANYOF_NALPHA   ((ANYOF_ALPHA) + 1)
#define ANYOF_ALPHANUMERIC   ((CC_ALPHANUMERIC_) * 2)    /* [[:alnum:]] isalnum(3), utf8::IsAlnum */
#define ANYOF_NALPHANUMERIC  ((ANYOF_ALPHANUMERIC) + 1)
#define ANYOF_ASCII    ((CC_ASCII_) * 2)
#define ANYOF_NASCII   ((ANYOF_ASCII) + 1)
#define ANYOF_BLANK    ((CC_BLANK_) * 2)     /* GNU extension: space and tab: non-vertical space */
#define ANYOF_NBLANK   ((ANYOF_BLANK) + 1)
#define ANYOF_CASED    ((CC_CASED_) * 2)    /* Pseudo class for [:lower:] or
                                               [:upper:] under /i */
#define ANYOF_NCASED   ((ANYOF_CASED) + 1)
#define ANYOF_CNTRL    ((CC_CNTRL_) * 2)
#define ANYOF_NCNTRL   ((ANYOF_CNTRL) + 1)
#define ANYOF_DIGIT    ((CC_DIGIT_) * 2)     /* \d */
#define ANYOF_NDIGIT   ((ANYOF_DIGIT) + 1)
#define ANYOF_GRAPH    ((CC_GRAPH_) * 2)
#define ANYOF_NGRAPH   ((ANYOF_GRAPH) + 1)
#define ANYOF_LOWER    ((CC_LOWER_) * 2)
#define ANYOF_NLOWER   ((ANYOF_LOWER) + 1)
#define ANYOF_PRINT    ((CC_PRINT_) * 2)
#define ANYOF_NPRINT   ((ANYOF_PRINT) + 1)
#define ANYOF_PUNCT    ((CC_PUNCT_) * 2)
#define ANYOF_NPUNCT   ((ANYOF_PUNCT) + 1)
#define ANYOF_SPACE    ((CC_SPACE_) * 2)     /* \s */
#define ANYOF_NSPACE   ((ANYOF_SPACE) + 1)
#define ANYOF_UPPER    ((CC_UPPER_) * 2)
#define ANYOF_NUPPER   ((ANYOF_UPPER) + 1)
#define ANYOF_WORDCHAR ((CC_WORDCHAR_) * 2)  /* \w, PL_utf8_alnum, utf8::IsWord, ALNUM */
#define ANYOF_NWORDCHAR   ((ANYOF_WORDCHAR) + 1)
#define ANYOF_XDIGIT   ((CC_XDIGIT_) * 2)
#define ANYOF_NXDIGIT  ((ANYOF_XDIGIT) + 1)

/* pseudo classes below this, not stored in the class bitmap, but used as flags
   during compilation of char classes */

#define ANYOF_VERTWS    ((CC_VERTSPACE_) * 2)
#define ANYOF_NVERTWS   ((ANYOF_VERTWS)+1)

/* It is best if this is the last one, as all above it are stored as bits in a
 * bitmap, and it isn't part of that bitmap */
#if CC_VERTSPACE_ != HIGHEST_REGCOMP_DOT_H_SYNC_
#   error Problem with handy.h HIGHEST_REGCOMP_DOT_H_SYNC_ #define
#endif

#define ANYOF_POSIXL_MAX (ANYOF_VERTWS) /* So upper loop limit is written:
                                         *       '< ANYOF_MAX'
                                         * Hence doesn't include VERTWS, as that
                                         * is a pseudo class */
#define ANYOF_MAX      ANYOF_POSIXL_MAX

#if (ANYOF_POSIXL_MAX > 32)   /* Must fit in 32-bit word */
#   error Problem with handy.h CC_foo_ #defines
#endif

#define ANYOF_HORIZWS	((ANYOF_POSIXL_MAX)+2) /* = (ANYOF_NVERTWS + 1) */
#define ANYOF_NHORIZWS	((ANYOF_POSIXL_MAX)+3)

#define ANYOF_UNIPROP   ((ANYOF_POSIXL_MAX)+4)  /* Used to indicate a Unicode
                                                   property: \p{} or \P{} */

/* Backward source code compatibility. */

#define ANYOF_ALNUML	 ANYOF_ALNUM
#define ANYOF_NALNUML	 ANYOF_NALNUM
#define ANYOF_SPACEL	 ANYOF_SPACE
#define ANYOF_NSPACEL	 ANYOF_NSPACE
#define ANYOF_ALNUM ANYOF_WORDCHAR
#define ANYOF_NALNUM ANYOF_NWORDCHAR

/* Utility macros for the bitmap and classes of ANYOF */

#define BITMAP_BYTE(p, c)	(( (U8*) (p)) [ ( ( (UV) (c)) >> 3) ] )
#define BITMAP_BIT(c)	        (1U << ((c) & 7))
#define BITMAP_TEST(p, c)	(BITMAP_BYTE(p, c) & BITMAP_BIT((U8)(c)))

#define ANYOF_FLAGS(p)          (FLAGS(p))

#define ANYOF_BIT(c)		BITMAP_BIT(c)

#define ANYOF_POSIXL_BITMAP(p)  (((regnode_charclass_posixl*) (p))->classflags)

#define POSIXL_SET(field, c)	((field) |= (1U << (c)))
#define ANYOF_POSIXL_SET(p, c)	POSIXL_SET(ANYOF_POSIXL_BITMAP(p), (c))

#define POSIXL_CLEAR(field, c) ((field) &= ~ (1U <<(c)))
#define ANYOF_POSIXL_CLEAR(p, c) POSIXL_CLEAR(ANYOF_POSIXL_BITMAP(p), (c))

#define POSIXL_TEST(field, c)	((field) & (1U << (c)))
#define ANYOF_POSIXL_TEST(p, c)	POSIXL_TEST(ANYOF_POSIXL_BITMAP(p), (c))

#define POSIXL_ZERO(field)	STMT_START { (field) = 0; } STMT_END
#define ANYOF_POSIXL_ZERO(ret)	POSIXL_ZERO(ANYOF_POSIXL_BITMAP(ret))

#define ANYOF_POSIXL_SET_TO_BITMAP(p, bits)                                 \
                STMT_START { ANYOF_POSIXL_BITMAP(p) = (bits); } STMT_END

/* Shifts a bit to get, eg. 0x4000_0000, then subtracts 1 to get 0x3FFF_FFFF */
#define ANYOF_POSIXL_SETALL(ret)                                            \
                STMT_START {                                                \
                    ANYOF_POSIXL_BITMAP(ret) = nBIT_MASK(ANYOF_POSIXL_MAX); \
                } STMT_END
#define ANYOF_CLASS_SETALL(ret) ANYOF_POSIXL_SETALL(ret)

#define ANYOF_POSIXL_TEST_ANY_SET(p)                               \
        ((ANYOF_FLAGS(p) & ANYOF_MATCHES_POSIXL) && ANYOF_POSIXL_BITMAP(p))
#define ANYOF_CLASS_TEST_ANY_SET(p) ANYOF_POSIXL_TEST_ANY_SET(p)

/* Since an SSC always has this field, we don't have to test for that; nor do
 * we want to because the bit isn't set for SSC during its construction */
#define ANYOF_POSIXL_SSC_TEST_ANY_SET(p)                               \
                            cBOOL(((regnode_ssc*)(p))->classflags)
#define ANYOF_POSIXL_SSC_TEST_ALL_SET(p) /* Are all bits set? */       \
        (((regnode_ssc*) (p))->classflags                              \
                                        == nBIT_MASK(ANYOF_POSIXL_MAX))

#define ANYOF_POSIXL_TEST_ALL_SET(p)                                   \
        ((ANYOF_FLAGS(p) & ANYOF_MATCHES_POSIXL)                       \
         && ANYOF_POSIXL_BITMAP(p) == nBIT_MASK(ANYOF_POSIXL_MAX))

#define ANYOF_POSIXL_OR(source, dest) STMT_START { (dest)->classflags |= (source)->classflags ; } STMT_END
#define ANYOF_CLASS_OR(source, dest) ANYOF_POSIXL_OR((source), (dest))

#define ANYOF_POSIXL_AND(source, dest) STMT_START { (dest)->classflags &= (source)->classflags ; } STMT_END

#define ANYOF_BITMAP_ZERO(ret)	Zero(((regnode_charclass*)(ret))->bitmap, ANYOF_BITMAP_SIZE, char)
#define ANYOF_BITMAP(p)		((regnode_charclass*)(p))->bitmap
#define ANYOF_BITMAP_BYTE(p, c)	BITMAP_BYTE(ANYOF_BITMAP(p), c)
#define ANYOF_BITMAP_SET(p, c)	(ANYOF_BITMAP_BYTE(p, c) |=  ANYOF_BIT(c))
#define ANYOF_BITMAP_CLEAR(p,c)	(ANYOF_BITMAP_BYTE(p, c) &= ~ANYOF_BIT(c))
#define ANYOF_BITMAP_TEST(p, c)	cBOOL(ANYOF_BITMAP_BYTE(p, c) & ANYOF_BIT(c))

#define ANYOF_BITMAP_SETALL(p)		\
        memset (ANYOF_BITMAP(p), 255, ANYOF_BITMAP_SIZE)
#define ANYOF_BITMAP_CLEARALL(p)	\
        Zero (ANYOF_BITMAP(p), ANYOF_BITMAP_SIZE)

/*
 * Utility definitions.
 */
#ifndef CHARMASK
#  define UCHARAT(p)	((int)*(const U8*)(p))
#else
#  define UCHARAT(p)	((int)*(p)&CHARMASK)
#endif

/* Number of regnode equivalents that 'guy' occupies beyond the size of the
 * smallest regnode. */
#define EXTRA_SIZE(guy) ((sizeof(guy)-1)/sizeof(struct regnode))

#define REG_ZERO_LEN_SEEN                   0x00000001
#define REG_LOOKBEHIND_SEEN                 0x00000002
/* add a short form alias to keep the line length police happy */
#define REG_LB_SEEN                         REG_LOOKBEHIND_SEEN
#define REG_GPOS_SEEN                       0x00000004
/* spare */
#define REG_RECURSE_SEEN                    0x00000020
#define REG_TOP_LEVEL_BRANCHES_SEEN         0x00000040
#define REG_VERBARG_SEEN                    0x00000080
#define REG_CUTGROUP_SEEN                   0x00000100
#define REG_RUN_ON_COMMENT_SEEN             0x00000200
#define REG_UNFOLDED_MULTI_SEEN             0x00000400
/* spare */
#define REG_UNBOUNDED_QUANTIFIER_SEEN       0x00001000
#define REG_PESSIMIZE_SEEN                  0x00002000


START_EXTERN_C

#ifdef PLUGGABLE_RE_EXTENSION
#include "re_nodes.h"
#else
#include "regnodes.h"
#endif

#ifndef PLUGGABLE_RE_EXTENSION
#ifndef DOINIT
EXTCONST regexp_engine PL_core_reg_engine;
#else /* DOINIT */
EXTCONST regexp_engine PL_core_reg_engine = { 
        Perl_re_compile,
        Perl_regexec_flags,
        Perl_re_intuit_start,
        Perl_re_intuit_string, 
        Perl_regfree_internal,
        Perl_reg_numbered_buff_fetch,
        Perl_reg_numbered_buff_store,
        Perl_reg_numbered_buff_length,
        Perl_reg_named_buff,
        Perl_reg_named_buff_iter,
        Perl_reg_qr_package,
#if defined(USE_ITHREADS)        
        Perl_regdupe_internal,
#endif        
        Perl_re_op_compile
};
#endif /* DOINIT */
#endif /* PLUGGABLE_RE_EXTENSION */


END_EXTERN_C


/* .what is a character array with one character for each member of .data
 * The character describes the function of the corresponding .data item:
 *   a - AV for paren_name_list under DEBUGGING
 *   f - start-class data for regstclass optimization
 *   l - start op for literal (?{EVAL}) item
 *   L - start op for literal (?{EVAL}) item, with separate CV (qr//)
 *   r - pointer to an embedded code-containing qr, e.g. /ab$qr/
 *   s - inversion list for Unicode-style character class, and the
 *       multicharacter strings resulting from casefolding the single-character
 *       entries in the character class
 *   t - trie struct
 *   u - trie struct's widecharmap (a HV, so can't share, must dup)
 *       also used for revcharmap and words under DEBUGGING
 *   T - aho-trie struct
 *   S - sv for named capture lookup
 * 20010712 mjd@plover.com
 * (Remember to update re_dup() and pregfree() if you add any items.)
 */
struct reg_data {
    U32 count;
    U8 *what;
    void* data[1];
};

/* Code in S_to_utf8_substr() and S_to_byte_substr() in regexec.c accesses
   anchored* and float* via array indexes 0 and 1.  */
#define anchored_substr substrs->data[0].substr
#define anchored_utf8 substrs->data[0].utf8_substr
#define anchored_offset substrs->data[0].min_offset
#define anchored_end_shift substrs->data[0].end_shift

#define float_substr substrs->data[1].substr
#define float_utf8 substrs->data[1].utf8_substr
#define float_min_offset substrs->data[1].min_offset
#define float_max_offset substrs->data[1].max_offset
#define float_end_shift substrs->data[1].end_shift

#define check_substr substrs->data[2].substr
#define check_utf8 substrs->data[2].utf8_substr
#define check_offset_min substrs->data[2].min_offset
#define check_offset_max substrs->data[2].max_offset
#define check_end_shift substrs->data[2].end_shift

#define RX_ANCHORED_SUBSTR(rx)	(ReANY(rx)->anchored_substr)
#define RX_ANCHORED_UTF8(rx)	(ReANY(rx)->anchored_utf8)
#define RX_FLOAT_SUBSTR(rx)	(ReANY(rx)->float_substr)
#define RX_FLOAT_UTF8(rx)	(ReANY(rx)->float_utf8)

/* trie related stuff */

/* a transition record for the state machine. the
   check field determines which state "owns" the
   transition. the char the transition is for is
   determined by offset from the owning states base
   field.  the next field determines which state
   is to be transitioned to if any.
*/
struct _reg_trie_trans {
  U32 next;
  U32 check;
};

/* a transition list element for the list based representation */
struct _reg_trie_trans_list_elem {
    U16 forid;
    U32 newstate;
};
typedef struct _reg_trie_trans_list_elem reg_trie_trans_le;

/* a state for compressed nodes. base is an offset
  into an array of reg_trie_trans array. If wordnum is
  nonzero the state is accepting. if base is zero then
  the state has no children (and will be accepting)
*/
struct _reg_trie_state {
  U16 wordnum;
  union {
    U32                base;
    reg_trie_trans_le* list;
  } trans;
};

/* info per word; indexed by wordnum */
typedef struct {
    U16  prev;	/* previous word in acceptance chain; eg in
                 * zzz|abc|ab/ after matching the chars abc, the
                 * accepted word is #2, and the previous accepted
                 * word is #3 */
    U32 len;	/* how many chars long is this word? */
    U32 accept;	/* accept state for this word */
} reg_trie_wordinfo;


typedef struct _reg_trie_state    reg_trie_state;
typedef struct _reg_trie_trans    reg_trie_trans;


/* anything in here that needs to be freed later
   should be dealt with in pregfree.
   refcount is first in both this and _reg_ac_data to allow a space
   optimisation in Perl_regdupe.  */
struct _reg_trie_data {
    U32             refcount;        /* number of times this trie is referenced */
    U32             lasttrans;       /* last valid transition element */
    U16             *charmap;        /* byte to charid lookup array */
    reg_trie_state  *states;         /* state data */
    reg_trie_trans  *trans;          /* array of transition elements */
    char            *bitmap;         /* stclass bitmap */
    U16 	    *jump;           /* optional 1 indexed array of offsets before tail 
                                        for the node following a given word. */
    U16             *j_before_paren; /* optional 1 indexed array of parno reset data
                                        for the given jump. */
    U16             *j_after_paren;  /* optional 1 indexed array of parno reset data
                                        for the given jump. */

    reg_trie_wordinfo *wordinfo;     /* array of info per word */
    U16             uniquecharcount; /* unique chars in trie (width of trans table) */
    U32             startstate;      /* initial state - used for common prefix optimisation */
    STRLEN          minlen;          /* minimum length of words in trie - build/opt only? */
    STRLEN          maxlen;          /* maximum length of words in trie - build/opt only? */
    U32             prefixlen;       /* #chars in common prefix */
    U32             statecount;      /* Build only - number of states in the states array 
                                        (including the unused zero state) */
    U32             wordcount;       /* Build only */
    U16             before_paren;
    U16             after_paren;
#ifdef DEBUGGING
    STRLEN          charcount;       /* Build only */
#endif
};
/* There is one (3 under DEBUGGING) pointers that logically belong in this
   structure, but are held outside as they need duplication on thread cloning,
   whereas the rest of the structure can be read only:
    HV              *widecharmap;    code points > 255 to charid
#ifdef DEBUGGING
    AV              *words;          Array of words contained in trie, for dumping
    AV              *revcharmap;     Map of each charid back to its character representation
#endif
*/

#define TRIE_WORDS_OFFSET 2

typedef struct _reg_trie_data reg_trie_data;

/* refcount is first in both this and _reg_trie_data to allow a space
   optimisation in Perl_regdupe.  */
struct _reg_ac_data {
    U32              refcount;
    U32              trie;
    U32              *fail;
    reg_trie_state   *states;
};
typedef struct _reg_ac_data reg_ac_data;

/* ANY_BIT doesn't use the structure, so we can borrow it here.
   This is simpler than refactoring all of it as wed end up with
   three different sets... */

#define TRIE_BITMAP(p)		(((reg_trie_data *)(p))->bitmap)
#define TRIE_BITMAP_BYTE(p, c)	BITMAP_BYTE(TRIE_BITMAP(p), c)
#define TRIE_BITMAP_SET(p, c)	(TRIE_BITMAP_BYTE(p, c) |=  ANYOF_BIT((U8)c))
#define TRIE_BITMAP_CLEAR(p,c)	(TRIE_BITMAP_BYTE(p, c) &= ~ANYOF_BIT((U8)c))
#define TRIE_BITMAP_TEST(p, c)	(TRIE_BITMAP_BYTE(p, c) &   ANYOF_BIT((U8)c))

#define IS_ANYOF_TRIE(op) ((op)==TRIEC || (op)==AHOCORASICKC)
#define IS_TRIE_AC(op) ((op)>=AHOCORASICK)

/* these defines assume uniquecharcount is the correct variable, and state may be evaluated twice */
#define TRIE_NODENUM(state) (((state)-1)/(trie->uniquecharcount)+1)
#define SAFE_TRIE_NODENUM(state) ((state) ? (((state)-1)/(trie->uniquecharcount)+1) : (state))
#define TRIE_NODEIDX(state) ((state) ? (((state)-1)*(trie->uniquecharcount)+1) : (state))

#ifdef DEBUGGING
#define TRIE_CHARCOUNT(trie) ((trie)->charcount)
#else
#define TRIE_CHARCOUNT(trie) (trie_charcount)
#endif

#define RE_TRIE_MAXBUF_INIT 65536
#define RE_TRIE_MAXBUF_NAME "\022E_TRIE_MAXBUF"
#define RE_DEBUG_FLAGS "\022E_DEBUG_FLAGS"

#define RE_COMPILE_RECURSION_INIT 1000
#define RE_COMPILE_RECURSION_LIMIT "\022E_COMPILE_RECURSION_LIMIT"

/*

RE_DEBUG_FLAGS is used to control what debug output is emitted
its divided into three groups of options, some of which interact.
The three groups are: Compile, Execute, Extra. There is room for a
further group, as currently only the low three bytes are used.

    Compile Options:
    
    PARSE
    PEEP
    TRIE
    PROGRAM

    Execute Options:

    INTUIT
    MATCH
    TRIE

    Extra Options

    TRIE

If you modify any of these make sure you make corresponding changes to
re.pm, especially to the documentation.

*/


/* Compile */
#define RE_DEBUG_COMPILE_MASK      0x0000FF
#define RE_DEBUG_COMPILE_PARSE     0x000001
#define RE_DEBUG_COMPILE_OPTIMISE  0x000002
#define RE_DEBUG_COMPILE_TRIE      0x000004
#define RE_DEBUG_COMPILE_DUMP      0x000008
#define RE_DEBUG_COMPILE_FLAGS     0x000010
#define RE_DEBUG_COMPILE_TEST      0x000020

/* Execute */
#define RE_DEBUG_EXECUTE_MASK      0x00FF00
#define RE_DEBUG_EXECUTE_INTUIT    0x000100
#define RE_DEBUG_EXECUTE_MATCH     0x000200
#define RE_DEBUG_EXECUTE_TRIE      0x000400

/* Extra */
#define RE_DEBUG_EXTRA_MASK              0x3FF0000
#define RE_DEBUG_EXTRA_TRIE              0x0010000
#define RE_DEBUG_EXTRA_STATE             0x0080000
#define RE_DEBUG_EXTRA_OPTIMISE          0x0100000
#define RE_DEBUG_EXTRA_BUFFERS           0x0400000
#define RE_DEBUG_EXTRA_GPOS              0x0800000
#define RE_DEBUG_EXTRA_DUMP_PRE_OPTIMIZE 0x1000000
#define RE_DEBUG_EXTRA_WILDCARD          0x2000000
/* combined */
#define RE_DEBUG_EXTRA_STACK             0x0280000

#define RE_DEBUG_FLAG(x) (re_debug_flags & (x))
/* Compile */
#define DEBUG_COMPILE_r(x) DEBUG_r( \
    if (DEBUG_v_TEST || RE_DEBUG_FLAG(RE_DEBUG_COMPILE_MASK)) x  )
#define DEBUG_PARSE_r(x) DEBUG_r( \
    if (DEBUG_v_TEST || RE_DEBUG_FLAG(RE_DEBUG_COMPILE_PARSE)) x  )
#define DEBUG_OPTIMISE_r(x) DEBUG_r( \
    if (DEBUG_v_TEST || RE_DEBUG_FLAG(RE_DEBUG_COMPILE_OPTIMISE)) x  )
#define DEBUG_DUMP_r(x) DEBUG_r( \
    if (DEBUG_v_TEST || RE_DEBUG_FLAG(RE_DEBUG_COMPILE_DUMP)) x  )
#define DEBUG_TRIE_COMPILE_r(x) DEBUG_r( \
    if (DEBUG_v_TEST || RE_DEBUG_FLAG(RE_DEBUG_COMPILE_TRIE)) x )
#define DEBUG_FLAGS_r(x) DEBUG_r( \
    if (DEBUG_v_TEST || RE_DEBUG_FLAG(RE_DEBUG_COMPILE_FLAGS)) x )
#define DEBUG_TEST_r(x) DEBUG_r( \
    if (DEBUG_v_TEST || RE_DEBUG_FLAG(RE_DEBUG_COMPILE_TEST)) x )
/* Execute */
#define DEBUG_EXECUTE_r(x) DEBUG_r( \
    if (DEBUG_v_TEST || RE_DEBUG_FLAG(RE_DEBUG_EXECUTE_MASK)) x  )
#define DEBUG_INTUIT_r(x) DEBUG_r( \
    if (DEBUG_v_TEST || RE_DEBUG_FLAG(RE_DEBUG_EXECUTE_INTUIT)) x  )
#define DEBUG_MATCH_r(x) DEBUG_r( \
    if (DEBUG_v_TEST || RE_DEBUG_FLAG(RE_DEBUG_EXECUTE_MATCH)) x  )
#define DEBUG_TRIE_EXECUTE_r(x) DEBUG_r( \
    if (DEBUG_v_TEST || RE_DEBUG_FLAG(RE_DEBUG_EXECUTE_TRIE)) x )

/* Extra */
#define DEBUG_EXTRA_r(x) DEBUG_r( \
    if (DEBUG_v_TEST || RE_DEBUG_FLAG(RE_DEBUG_EXTRA_MASK)) x  )
#define DEBUG_STATE_r(x) DEBUG_r( \
    if (DEBUG_v_TEST || RE_DEBUG_FLAG(RE_DEBUG_EXTRA_STATE)) x )
#define DEBUG_STACK_r(x) DEBUG_r( \
    if (DEBUG_v_TEST || RE_DEBUG_FLAG(RE_DEBUG_EXTRA_STACK)) x )
#define DEBUG_BUFFERS_r(x) DEBUG_r( \
    if (DEBUG_v_TEST || RE_DEBUG_FLAG(RE_DEBUG_EXTRA_BUFFERS)) x )

#define DEBUG_OPTIMISE_MORE_r(x) DEBUG_r( \
    if (DEBUG_v_TEST || ((RE_DEBUG_EXTRA_OPTIMISE|RE_DEBUG_COMPILE_OPTIMISE) == \
         RE_DEBUG_FLAG(RE_DEBUG_EXTRA_OPTIMISE|RE_DEBUG_COMPILE_OPTIMISE))) x )
#define DEBUG_TRIE_COMPILE_MORE_r(x) DEBUG_TRIE_COMPILE_r( \
    if (DEBUG_v_TEST || RE_DEBUG_FLAG(RE_DEBUG_EXTRA_TRIE)) x )
#define DEBUG_TRIE_EXECUTE_MORE_r(x) DEBUG_TRIE_EXECUTE_r( \
    if (DEBUG_v_TEST || RE_DEBUG_FLAG(RE_DEBUG_EXTRA_TRIE)) x )

#define DEBUG_TRIE_r(x) DEBUG_r( \
    if (DEBUG_v_TEST || RE_DEBUG_FLAG(RE_DEBUG_COMPILE_TRIE \
        | RE_DEBUG_EXECUTE_TRIE )) x )
#define DEBUG_GPOS_r(x) DEBUG_r( \
    if (DEBUG_v_TEST || RE_DEBUG_FLAG(RE_DEBUG_EXTRA_GPOS)) x )

#define DEBUG_DUMP_PRE_OPTIMIZE_r(x) DEBUG_r( \
    if (DEBUG_v_TEST || RE_DEBUG_FLAG(RE_DEBUG_EXTRA_DUMP_PRE_OPTIMIZE)) x )

/* initialization */
/* Get the debug flags for code not in regcomp.c nor regexec.c.  This doesn't
 * initialize the variable if it isn't already there, instead it just assumes
 * the flags are 0 */
#define DECLARE_AND_GET_RE_DEBUG_FLAGS_NON_REGEX                               \
    volatile IV re_debug_flags = 0;  PERL_UNUSED_VAR(re_debug_flags);          \
    STMT_START {                                                               \
        SV * re_debug_flags_sv = NULL;                                         \
                     /* get_sv() can return NULL during global destruction. */ \
        re_debug_flags_sv = PL_curcop ? get_sv(RE_DEBUG_FLAGS, GV_ADD) : NULL; \
        if (re_debug_flags_sv && SvIOK(re_debug_flags_sv))                     \
            re_debug_flags=SvIV(re_debug_flags_sv);                            \
    } STMT_END


#ifdef DEBUGGING

/* For use in regcomp.c and regexec.c,  Get the debug flags, and initialize to
 * the defaults if not done already */
#define DECLARE_AND_GET_RE_DEBUG_FLAGS                                         \
    volatile IV re_debug_flags = 0;  PERL_UNUSED_VAR(re_debug_flags);          \
    DEBUG_r({                              \
        SV * re_debug_flags_sv = NULL;                                         \
                     /* get_sv() can return NULL during global destruction. */ \
        re_debug_flags_sv = PL_curcop ? get_sv(RE_DEBUG_FLAGS, GV_ADD) : NULL; \
        if (re_debug_flags_sv) {                                               \
            if (!SvIOK(re_debug_flags_sv)) /* If doesn't exist set to default */\
                sv_setuv(re_debug_flags_sv,                                    \
                        /* These defaults should be kept in sync with re.pm */ \
                            RE_DEBUG_COMPILE_DUMP | RE_DEBUG_EXECUTE_MASK );   \
            re_debug_flags=SvIV(re_debug_flags_sv);                            \
        }                                                                      \
    })

#define isDEBUG_WILDCARD (DEBUG_v_TEST || RE_DEBUG_FLAG(RE_DEBUG_EXTRA_WILDCARD))

#define RE_PV_COLOR_DECL(rpv,rlen,isuni,dsv,pv,l,m,c1,c2)   \
    const char * const rpv =                                \
        pv_pretty((dsv), (pv), (l), (m),                    \
            PL_colors[(c1)],PL_colors[(c2)],                \
            PERL_PV_ESCAPE_RE|PERL_PV_ESCAPE_NONASCII |((isuni) ? PERL_PV_ESCAPE_UNI : 0) );         \
    const int rlen = SvCUR(dsv)

/* This is currently unsed in the core */
#define RE_SV_ESCAPE(rpv,isuni,dsv,sv,m)                            \
    const char * const rpv =                                        \
        pv_pretty((dsv), (SvPV_nolen_const(sv)), (SvCUR(sv)), (m),  \
            PL_colors[(c1)],PL_colors[(c2)],                        \
            PERL_PV_ESCAPE_RE|PERL_PV_ESCAPE_NONASCII |((isuni) ? PERL_PV_ESCAPE_UNI : 0) )

#define RE_PV_QUOTED_DECL(rpv,isuni,dsv,pv,l,m)                     \
    const char * const rpv =                                        \
        pv_pretty((dsv), (pv), (l), (m),                            \
            PL_colors[0], PL_colors[1],                             \
            ( PERL_PV_PRETTY_QUOTE | PERL_PV_ESCAPE_RE | PERL_PV_ESCAPE_NONASCII | PERL_PV_PRETTY_ELLIPSES | \
              ((isuni) ? PERL_PV_ESCAPE_UNI : 0))                  \
        )

#define RE_SV_DUMPLEN(ItEm) (SvCUR(ItEm) - (SvTAIL(ItEm)!=0))
#define RE_SV_TAIL(ItEm) (SvTAIL(ItEm) ? "$" : "")
    
#else /* if not DEBUGGING */

#define DECLARE_AND_GET_RE_DEBUG_FLAGS  dNOOP
#define RE_PV_COLOR_DECL(rpv,rlen,isuni,dsv,pv,l,m,c1,c2)  dNOOP
#define RE_SV_ESCAPE(rpv,isuni,dsv,sv,m)
#define RE_PV_QUOTED_DECL(rpv,isuni,dsv,pv,l,m)  dNOOP
#define RE_SV_DUMPLEN(ItEm)
#define RE_SV_TAIL(ItEm)
#define isDEBUG_WILDCARD 0

#endif /* DEBUG RELATED DEFINES */

#define FIRST_NON_ASCII_DECIMAL_DIGIT 0x660  /* ARABIC_INDIC_DIGIT_ZERO */

typedef enum {
        TRADITIONAL_BOUND = CC_WORDCHAR_,
        GCB_BOUND,
        LB_BOUND,
        SB_BOUND,
        WB_BOUND
} bound_type;

/* This unpacks the FLAGS field of ANYOF[HR]x nodes.  The value it contains
 * gives the strict lower bound for the UTF-8 start byte of any code point
 * matchable by the node, and a loose upper bound as well.
 *
 * The low bound is stored as 0xC0 + ((the upper 6 bits) >> 2)
 * The loose upper bound is determined from the lowest 2 bits and the low bound
 * (called x) as follows:
 *
 * 11  The upper limit of the range can be as much as (EF - x) / 8
 * 10  The upper limit of the range can be as much as (EF - x) / 4
 * 01  The upper limit of the range can be as much as (EF - x) / 2
 * 00  The upper limit of the range can be as much as  EF
 *
 * For motivation of this design, see commit message in
 * 3146c00a633e9cbed741e10146662fbcedfdb8d3 */
#ifdef EBCDIC
#  define MAX_ANYOF_HRx_BYTE  0xF4
#else
#  define MAX_ANYOF_HRx_BYTE  0xEF
#endif
#define LOWEST_ANYOF_HRx_BYTE(b) (((b) >> 2) + 0xC0)
#define HIGHEST_ANYOF_HRx_BYTE(b)                                           \
                                  (LOWEST_ANYOF_HRx_BYTE(b)                 \
          + ((MAX_ANYOF_HRx_BYTE - LOWEST_ANYOF_HRx_BYTE(b)) >> ((b) & 3)))

#if !defined(PERL_IN_XSUB_RE) || defined(PLUGGABLE_RE_EXTENSION)
#  define GET_REGCLASS_AUX_DATA(a,b,c,d,e,f)  get_regclass_aux_data(a,b,c,d,e,f)
#else
#  define GET_REGCLASS_AUX_DATA(a,b,c,d,e,f)  get_re_gclass_aux_data(a,b,c,d,e,f)
#endif

#define REGNODE_TYPE(node)              (PL_regnode_info[(node)].type)
#define REGNODE_OFF_BY_ARG(node)        (PL_regnode_info[(node)].off_by_arg)
#define REGNODE_ARG_LEN(node)           (PL_regnode_info[(node)].arg_len)
#define REGNODE_ARG_LEN_VARIES(node)    (PL_regnode_info[(node)].arg_len_varies)
#define REGNODE_NAME(node)              (PL_regnode_name[(node)])

#if defined(PERL_IN_REGEX_ENGINE)
#include "reginline.h"
#endif

#define EVAL_OPTIMISTIC_FLAG    128
#define EVAL_FLAGS_MASK         (EVAL_OPTIMISTIC_FLAG-1)

/* We define PERL_RE_BUILD_DEBUG if we are NOT compiling the re extension and
 * we are under DEBUGGING, or if we are ARE compiling the re extension
 * and this is not a DEBUGGING enabled build (identified by
 * DEBUGGING_RE_ONLY being defined)
 */
#if ( !defined(PERL_EXT_RE_STATIC) && defined(DEBUGGING)) ||       \
    ( defined(PERL_EXT_RE_BUILD) && defined(DEBUGGING_RE_ONLY)) || \
    (!defined(PERL_EXT_RE_BUILD) && defined(DEBUGGING))
#define PERL_RE_BUILD_DEBUG
#endif
#if !defined(PERL_EXT_RE_STATIC)
#define PERL_RE_BUILD_AUX
#endif

#endif /* PERL_REGCOMP_H_ */

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     usr/local/lib/perl5/5.40.0/x86_64-linux-gnu/CORE/regcomp_internal.h                                 0000444 0000000 0000000 00000172147 14714567415 022633  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef REGCOMP_INTERNAL_H
#define REGCOMP_INTERNAL_H
#ifndef STATIC
#define STATIC  static
#endif
#ifndef RE_OPTIMIZE_CURLYX_TO_CURLYM
#define RE_OPTIMIZE_CURLYX_TO_CURLYM 1
#endif
#ifndef RE_OPTIMIZE_CURLYX_TO_CURLYN
#define RE_OPTIMIZE_CURLYX_TO_CURLYN 1
#endif

/* this is a chain of data about sub patterns we are processing that
   need to be handled separately/specially in study_chunk. Its so
   we can simulate recursion without losing state.  */
struct scan_frame;
typedef struct scan_frame {
    regnode *last_regnode;      /* last node to process in this frame */
    regnode *next_regnode;      /* next node to process when last is reached */
    U32 prev_recursed_depth;
    I32 stopparen;              /* what stopparen do we use */
    bool in_gosub;              /* this or an outer frame is for GOSUB */

    struct scan_frame *this_prev_frame; /* this previous frame */
    struct scan_frame *prev_frame;      /* previous frame */
    struct scan_frame *next_frame;      /* next frame */
} scan_frame;

/* Certain characters are output as a sequence with the first being a
 * backslash. */
#define isBACKSLASHED_PUNCT(c)  memCHRs("-[]\\^", c)


struct RExC_state_t {
    U32         flags;                  /* RXf_* are we folding, multilining? */
    U32         pm_flags;               /* PMf_* stuff from the calling PMOP */
    char        *precomp;               /* uncompiled string. */
    char        *precomp_end;           /* pointer to end of uncompiled string. */
    REGEXP      *rx_sv;                 /* The SV that is the regexp. */
    regexp      *rx;                    /* perl core regexp structure */
    regexp_internal     *rxi;           /* internal data for regexp object
                                           pprivate field */
    char        *start;                 /* Start of input for compile */
    char        *end;                   /* End of input for compile */
    char        *parse;                 /* Input-scan pointer. */
    char        *copy_start;            /* start of copy of input within
                                           constructed parse string */
    char        *save_copy_start;       /* Provides one level of saving
                                           and restoring 'copy_start' */
    char        *copy_start_in_input;   /* Position in input string
                                           corresponding to copy_start */
    SSize_t     whilem_seen;            /* number of WHILEM in this expr */
    regnode     *emit_start;            /* Start of emitted-code area */
    regnode_offset emit;                /* Code-emit pointer */
    I32         naughty;                /* How bad is this pattern? */
    I32         sawback;                /* Did we see \1, ...? */
    SSize_t     size;                   /* Number of regnode equivalents in
                                           pattern */
    Size_t      sets_depth;              /* Counts recursion depth of already-
                                           compiled regex set patterns */
    U32         seen;

    I32      parens_buf_size;           /* #slots malloced open/close_parens */
    regnode_offset *open_parens;        /* offsets to open parens */
    regnode_offset *close_parens;       /* offsets to close parens */
    HV          *paren_names;           /* Paren names */

    /* position beyond 'precomp' of the warning message furthest away from
     * 'precomp'.  During the parse, no warnings are raised for any problems
     * earlier in the parse than this position.  This works if warnings are
     * raised the first time a given spot is parsed, and if only one
     * independent warning is raised for any given spot */
    Size_t      latest_warn_offset;

    /* Branch reset /(?|...|...)/ gives us two concepts of capture buffer id.
     * "Logical Parno" is the user visible view with branch reset taken into
     * account. "Parno" (or physical parno) is the actual capture buffers in
     * the pattern *NOT* taking into account branch reset. We also maintain
     * a map of "next" pointers which allow us to skip to the next physical
     * capture buffer with the same logical id, with 0 representing "none".
     *
     * As we compile we keep track of the two different counts using the
     * 'logical_npar' and 'npar' members, and we keep track of the upper bound
     * of both in 'total_par' and 'logical_total_par', we also populate
     * the 'logical_to_parno' map, which gives us the first physical parno
     * for a given logical parno, and the `parno_to_logical` array which gives
     * us the logical id for each physical parno. When compilation is
     * completed we construct the 'parno_to_logical_next' array from the
     * 'parno_to_logical' array. (We do not bother constructing it during
     * compilation as we do not need it, and we can construct it in O(N) time
     * once we are done, but would need more complicated logic during the
     * compile, because we want the next pointers to go from smallest to
     * largest, eg, left to right.)
     *
     * Logical: $1      $2  $3  $4    $2  $3    $2    $5
     * Physical: 1       2   3   4     5   6     7     8
     * Next:     0       5   6   0     7   0     0     0
     * Pattern /(a) (?| (b) (c) (d) | (e) (f) | (g) ) (h)/
     *
     * As much as possible the internals use and store the physical id of
     * of capture buffers. We decode the physical to the logical only when
     * we need to, for instance when someone use $2.
     *
     * Note that when branch reset is not used logical and physical are the
     * same and the next data would be all zero. So when branch reset is not
     * used we do not need to populate this data into the final regexp.
     *
     */
    I32         *logical_to_parno;        /* logical_parno to parno */
    I32         *parno_to_logical;        /* parno to logical_parno */
    I32         *parno_to_logical_next;   /* parno to next (greater value)
                                             parno with the same
                                             logical_parno as parno.*/

    I32         npar;                   /* Capture buffer count so far in the
                                           parse, (OPEN) plus one. ("par" 0 is
                                           the whole pattern)*/
    I32         logical_npar;           /* Logical version of npar */
    I32         total_par;              /* During initial parse, is either 0,
                                           or -1; the latter indicating a
                                           reparse is needed.  After that pass,
                                           it is what 'npar' became after the
                                           pass.  Hence, it being > 0 indicates
                                           we are in a reparse situation */
    I32         logical_total_par;      /* Logical version to total par */
    I32         nestroot;               /* root parens we are in - used by
                                           accept */
    I32         seen_zerolen;
    regnode     *end_op;                /* END node in program */
    I32         utf8;           /* whether the pattern is utf8 or not */
    I32         orig_utf8;      /* whether the pattern was originally in utf8 */
                                /* XXX use this for future optimisation of case
                                 * where pattern must be upgraded to utf8. */
    I32         uni_semantics;  /* If a d charset modifier should use unicode
                                   rules, even if the pattern is not in
                                   utf8 */

    I32         recurse_count;          /* Number of recurse regops we have generated */
    regnode     **recurse;              /* Recurse regops */
    U8          *study_chunk_recursed;  /* bitmap of which subs we have moved
                                           through */
    U32         study_chunk_recursed_bytes;  /* bytes in bitmap */
    I32         in_lookaround;
    I32         contains_locale;
    I32         override_recoding;
    I32         recode_x_to_native;
    I32         in_multi_char_class;
    int         code_index;             /* next code_blocks[] slot */
    struct reg_code_blocks *code_blocks;/* positions of literal (?{})
                                            within pattern */
    SSize_t     maxlen;                        /* mininum possible number of chars in string to match */
    scan_frame *frame_head;
    scan_frame *frame_last;
    U32         frame_count;
    AV         *warn_text;
    HV         *unlexed_names;
    SV          *runtime_code_qr;       /* qr with the runtime code blocks */
    bool        seen_d_op;
    bool        strict;
    bool        study_started;
    bool        in_script_run;
    bool        use_BRANCHJ;
    bool        sWARN_EXPERIMENTAL__VLB;
    bool        sWARN_EXPERIMENTAL__REGEX_SETS;
    /* DEBUGGING only fields, keep these LAST so that we do not
     * have any weirdness with static builds.
     *
     * We include these if we are building a DEBUGGING perl OR if we
     * are not using dynamic linking (USE_DYNAMIC_LOADING).
     *
     * See GH Issue #21558 and also ba6e2c38aafc23cf114f3ba0d0ff3baead34328b
     */
#if defined(DEBUGGING) || !defined(USE_DYNAMIC_LOADING)
    const char  *lastparse;
    I32         lastnum;
    U32         study_chunk_recursed_count;
    AV          *paren_name_list;       /* idx -> name */
    SV          *mysv1;
    SV          *mysv2;
#endif
};

#ifdef DEBUGGING
#define RExC_lastparse  (pRExC_state->lastparse)
#define RExC_lastnum    (pRExC_state->lastnum)
#define RExC_paren_name_list    (pRExC_state->paren_name_list)
#define RExC_study_chunk_recursed_count    (pRExC_state->study_chunk_recursed_count)
#define RExC_mysv       (pRExC_state->mysv1)
#define RExC_mysv1      (pRExC_state->mysv1)
#define RExC_mysv2      (pRExC_state->mysv2)
#endif

#define RExC_flags      (pRExC_state->flags)
#define RExC_pm_flags   (pRExC_state->pm_flags)
#define RExC_precomp    (pRExC_state->precomp)
#define RExC_copy_start_in_input (pRExC_state->copy_start_in_input)
#define RExC_copy_start_in_constructed  (pRExC_state->copy_start)
#define RExC_save_copy_start_in_constructed  (pRExC_state->save_copy_start)
#define RExC_precomp_end (pRExC_state->precomp_end)
#define RExC_rx_sv      (pRExC_state->rx_sv)
#define RExC_rx         (pRExC_state->rx)
#define RExC_rxi        (pRExC_state->rxi)
#define RExC_start      (pRExC_state->start)
#define RExC_end        (pRExC_state->end)
#define RExC_parse      (pRExC_state->parse)
#define RExC_latest_warn_offset (pRExC_state->latest_warn_offset )
#define RExC_whilem_seen        (pRExC_state->whilem_seen)
#define RExC_seen_d_op (pRExC_state->seen_d_op) /* Seen something that differs
                                                   under /d from /u ? */

#define RExC_emit       (pRExC_state->emit)
#define RExC_emit_start (pRExC_state->emit_start)
#define RExC_sawback    (pRExC_state->sawback)
#define RExC_seen       (pRExC_state->seen)
#define RExC_size       (pRExC_state->size)
#define RExC_maxlen        (pRExC_state->maxlen)
#define RExC_logical_npar           (pRExC_state->logical_npar)
#define RExC_logical_total_parens   (pRExC_state->logical_total_par)
#define RExC_logical_to_parno       (pRExC_state->logical_to_parno)
#define RExC_parno_to_logical       (pRExC_state->parno_to_logical)
#define RExC_parno_to_logical_next  (pRExC_state->parno_to_logical_next)
#define RExC_npar       (pRExC_state->npar)
#define RExC_total_parens       (pRExC_state->total_par)
#define RExC_parens_buf_size    (pRExC_state->parens_buf_size)
#define RExC_nestroot   (pRExC_state->nestroot)
#define RExC_seen_zerolen       (pRExC_state->seen_zerolen)
#define RExC_utf8       (pRExC_state->utf8)
#define RExC_uni_semantics      (pRExC_state->uni_semantics)
#define RExC_orig_utf8  (pRExC_state->orig_utf8)
#define RExC_open_parens        (pRExC_state->open_parens)
#define RExC_close_parens       (pRExC_state->close_parens)
#define RExC_end_op     (pRExC_state->end_op)
#define RExC_paren_names        (pRExC_state->paren_names)
#define RExC_recurse    (pRExC_state->recurse)
#define RExC_recurse_count      (pRExC_state->recurse_count)
#define RExC_sets_depth         (pRExC_state->sets_depth)
#define RExC_study_chunk_recursed        (pRExC_state->study_chunk_recursed)
#define RExC_study_chunk_recursed_bytes  \
                                   (pRExC_state->study_chunk_recursed_bytes)
#define RExC_in_lookaround      (pRExC_state->in_lookaround)
#define RExC_contains_locale    (pRExC_state->contains_locale)
#define RExC_recode_x_to_native (pRExC_state->recode_x_to_native)

#ifdef EBCDIC
#  define SET_recode_x_to_native(x)                                         \
                    STMT_START { RExC_recode_x_to_native = (x); } STMT_END
#else
#  define SET_recode_x_to_native(x) NOOP
#endif

#define RExC_in_multi_char_class (pRExC_state->in_multi_char_class)
#define RExC_frame_head (pRExC_state->frame_head)
#define RExC_frame_last (pRExC_state->frame_last)
#define RExC_frame_count (pRExC_state->frame_count)
#define RExC_strict (pRExC_state->strict)
#define RExC_study_started      (pRExC_state->study_started)
#define RExC_warn_text (pRExC_state->warn_text)
#define RExC_in_script_run      (pRExC_state->in_script_run)
#define RExC_use_BRANCHJ        (pRExC_state->use_BRANCHJ)
#define RExC_warned_WARN_EXPERIMENTAL__VLB (pRExC_state->sWARN_EXPERIMENTAL__VLB)
#define RExC_warned_WARN_EXPERIMENTAL__REGEX_SETS (pRExC_state->sWARN_EXPERIMENTAL__REGEX_SETS)
#define RExC_unlexed_names (pRExC_state->unlexed_names)


/***********************************************************************/
/* UTILITY MACROS FOR ADVANCING OR SETTING THE PARSE "CURSOR" RExC_parse
 *
 * All of these macros depend on the above RExC_ accessor macros, which
 * in turns depend on a variable pRExC_state being in scope where they
 * are used. This is the standard regexp parser context variable which is
 * passed into every non-trivial parse function in this file.
 *
 * Note that the UTF macro is itself a wrapper around RExC_utf8, so all
 * of the macros which do not take an argument will operate on the
 * pRExC_state structure *only*.
 *
 * Please do NOT modify RExC_parse without using these macros. In the
 * future these macros will be extended for enhanced debugging and trace
 * output during the parse process.
 */

/* RExC_parse_incf(flag)
 *
 * Increment RExC_parse to point at the next codepoint, while doing
 * the right thing depending on whether we are parsing UTF-8 strings
 * or not. The 'flag' argument determines if content is UTF-8 or not,
 * intended for cases where this is NOT governed by the UTF macro.
 *
 * Use RExC_parse_inc() if UTF-8ness is controlled by the UTF macro.
 *
 * WARNING: Does NOT take into account RExC_end; it is the callers
 * responsibility to make sure there are enough octets left in
 * RExC_parse to ensure that when processing UTF-8 we would not read
 * past the end of the string.
 */
#define RExC_parse_incf(flag) STMT_START {              \
    RExC_parse += (flag) ? UTF8SKIP(RExC_parse) : 1;    \
} STMT_END

/* RExC_parse_inc_safef(flag)
 *
 * Safely increment RExC_parse to point at the next codepoint,
 * doing the right thing depending on whether we are parsing
 * UTF-8 strings or not and NOT reading past the end of the buffer.
 * The 'flag' argument determines if content is UTF-8 or not,
 * intended for cases where this is NOT governed by the UTF macro.
 *
 * Use RExC_parse_safe() if UTF-8ness is controlled by the UTF macro.
 *
 * NOTE: Will NOT read past RExC_end when content is UTF-8.
 */
#define RExC_parse_inc_safef(flag) STMT_START {                     \
    RExC_parse += (flag) ? UTF8_SAFE_SKIP(RExC_parse,RExC_end) : 1; \
} STMT_END

/* RExC_parse_inc()
 *
 * Increment RExC_parse to point at the next codepoint,
 * doing the right thing depending on whether we are parsing
 * UTF-8 strings or not.
 *
 * WARNING: Does NOT take into account RExC_end, it is the callers
 * responsibility to make sure there are enough octets left in
 * RExC_parse to ensure that when processing UTF-8 we would not read
 * past the end of the string.
 *
 * NOTE: whether we are parsing UTF-8 or not is determined by the
 * UTF macro which is defined as cBOOL(RExC_parse_utf8), thus this
 * macro operates on the pRExC_state structure only.
