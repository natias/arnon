all; in general, the top-level operator in an expression has control of
operand evaluation.

Some comparison operators, as their associativity, I<chain> with some
operators of the same precedence (but never with operators of different
precedence).  This chaining means that each comparison is performed
on the two arguments surrounding it, with each interior argument taking
part in two comparisons, and the comparison results are implicitly ANDed.
Thus S<C<"$x E<lt> $y E<lt>= $z">> behaves exactly like S<C<"$x E<lt>
$y && $y E<lt>= $z">>, assuming that C<"$y"> is as simple a scalar as
it looks.  The ANDing short-circuits just like C<"&&"> does, stopping
the sequence of comparisons as soon as one yields false.

In a chained comparison, each argument expression is evaluated at most
once, even if it takes part in two comparisons, but the result of the
evaluation is fetched for each comparison.  (It is not evaluated
at all if the short-circuiting means that it's not required for any
comparisons.)  This matters if the computation of an interior argument
is expensive or non-deterministic.  For example,

    if($x < expensive_sub() <= $z) { ...

is not entirely like

    if($x < expensive_sub() && expensive_sub() <= $z) { ...

but instead closer to

    my $tmp = expensive_sub();
    if($x < $tmp && $tmp <= $z) { ...

in that the subroutine is only called once.  However, it's not exactly
like this latter code either, because the chained comparison doesn't
actually involve any temporary variable (named or otherwise): there is
no assignment.  This doesn't make much difference where the expression
is a call to an ordinary subroutine, but matters more with an lvalue
subroutine, or if the argument expression yields some unusual kind of
scalar by other means.  For example, if the argument expression yields
a tied scalar, then the expression is evaluated to produce that scalar
at most once, but the value of that scalar may be fetched up to twice,
once for each comparison in which it is actually used.

In this example, the expression is evaluated only once, and the tied
scalar (the result of the expression) is fetched for each comparison that
uses it.

    if ($x < $tied_scalar < $z) { ...

In the next example, the expression is evaluated only once, and the tied
scalar is fetched once as part of the operation within the expression.
The result of that operation is fetched for each comparison, which
normally doesn't matter unless that expression result is also magical due
to operator overloading.

    if ($x < $tied_scalar + 42 < $z) { ...

Some operators are instead non-associative, meaning that it is a syntax
error to use a sequence of those operators of the same precedence.
For example, S<C<"$x .. $y .. $z">> is an error.

Perl operators have the following associativity and precedence,
listed from highest precedence to lowest.  Operators borrowed from
C keep the same precedence relationship with each other, even where
C's precedence is slightly screwy.  (This makes learning Perl easier
for C folks.)  With very few exceptions, these all operate on scalar
values only, not array values.

    left	terms and list operators (leftward)
    left	->
    nonassoc	++ --
    right	**
    right	! ~ ~. \ and unary + and -
    left	=~ !~
    left	* / % x
    left	+ - .
    left	<< >>
    nonassoc	named unary operators
    nonassoc    isa
    chained 	< > <= >= lt gt le ge
    chain/na	== != eq ne <=> cmp ~~
    left	& &.
    left	| |. ^ ^.
    left	&&
    left	|| ^^ //
    nonassoc	..  ...
    right	?:
    right	= += -= *= etc. goto last next redo dump
    left	, =>
    nonassoc	list operators (rightward)
    right	not
    left	and
    left	or xor

In the following sections, these operators are covered in detail, in the
same order in which they appear in the table above.

Many operators can be overloaded for objects.  See L<overload>.

=head2 Terms and List Operators (Leftward)
X<list operator> X<operator, list> X<term>

A TERM has the highest precedence in Perl.  They include variables,
quote and quote-like operators, any expression in parentheses,
and any function whose arguments are parenthesized.  Actually, there
aren't really functions in this sense, just list operators and unary
operators behaving as functions because you put parentheses around
the arguments.  These are all documented in L<perlfunc>.

If any list operator (C<print()>, etc.) or any unary operator (C<chdir()>, etc.)
is followed by a left parenthesis as the next token, the operator and
arguments within parentheses are taken to be of highest precedence,
just like a normal function call.

In the absence of parentheses, the precedence of list operators such as
C<print>, C<sort>, or C<chmod> is either very high or very low depending on
whether you are looking at the left side or the right side of the operator.
For example, in

    @ary = (1, 3, sort 4, 2);
    print @ary;		# prints 1324

the commas on the right of the C<sort> are evaluated before the C<sort>,
but the commas on the left are evaluated after.  In other words,
list operators tend to gobble up all arguments that follow, and
then act like a simple TERM with regard to the preceding expression.
Be careful with parentheses:

    # These evaluate exit before doing the print:
    print($foo, exit);	# Obviously not what you want.
    print $foo, exit;	# Nor is this.

    # These do the print before evaluating exit:
    (print $foo), exit;	# This is what you want.
    print($foo), exit;	# Or this.
    print ($foo), exit;	# Or even this.

Also note that

    print ($foo & 255) + 1, "\n";

probably doesn't do what you expect at first glance.  The parentheses
enclose the argument list for C<print> which is evaluated (printing
the result of S<C<$foo & 255>>).  Then one is added to the return value
of C<print> (usually 1).  The result is something like this:

    1 + 1, "\n";    # Obviously not what you meant.

To do what you meant properly, you must write:

    print(($foo & 255) + 1, "\n");

See L</Named Unary Operators> for more discussion of this.

Also parsed as terms are the S<C<do {}>> and S<C<eval {}>> constructs, as
well as subroutine and method calls, and the anonymous
constructors C<[]> and C<{}>.

See also L</Quote and Quote-like Operators> toward the end of this section,
as well as L</"I/O Operators">.

=head2 The Arrow Operator
X<arrow> X<dereference> X<< -> >>

"C<< -> >>" is an infix dereference operator, just as it is in C
and C++.  If the right side is either a C<[...]>, C<{...}>, or a
C<(...)> subscript, then the left side must be either a hard or
symbolic reference to an array, a hash, or a subroutine respectively.
(Or technically speaking, a location capable of holding a hard
reference, if it's an array or hash reference being used for
assignment.)  See L<perlreftut> and L<perlref>.

Otherwise, the right side is a method name or a simple scalar
variable containing either the method name or a subroutine reference,
and (if it is a method name) the left side must be either an object (a
blessed reference) or a class name (that is, a package name).  See
L<perlobj>.

The dereferencing cases (as opposed to method-calling cases) are
somewhat extended by the C<postderef> feature.  For the
details of that feature, consult L<perlref/Postfix Dereference Syntax>.

=head2 Auto-increment and Auto-decrement
X<increment> X<auto-increment> X<++> X<decrement> X<auto-decrement> X<-->

C<"++"> and C<"--"> work as in C.  That is, if placed before a variable,
they increment or decrement the variable by one before returning the
value, and if placed after, increment or decrement after returning the
value.

    $i = 0;  $j = 0;
    print $i++;  # prints 0
    print ++$j;  # prints 1

Note that just as in C, Perl doesn't define B<when> the variable is
incremented or decremented.  You just know it will be done sometime
before or after the value is returned.  This also means that modifying
a variable twice in the same statement will lead to undefined behavior.
Avoid statements like:

    $i = $i ++;
    print ++ $i + $i ++;

Perl will not guarantee what the result of the above statements is.

The auto-increment operator has a little extra builtin magic to it.  If
you increment a variable that is numeric, or that has ever been used in
a numeric context, you get a normal increment.  If, however, the
variable has been used in only string contexts since it was set, and
has a value that is not the empty string and matches the pattern
C</^[a-zA-Z]*[0-9]*\z/>, the increment is done as a string, preserving each
character within its range, with carry:

    print ++($foo = "99");	# prints "100"
    print ++($foo = "a0");	# prints "a1"
    print ++($foo = "Az");	# prints "Ba"
    print ++($foo = "zz");	# prints "aaa"

C<undef> is always treated as numeric, and in particular is changed
to C<0> before incrementing (so that a post-increment of an undef value
will return C<0> rather than C<undef>).

The auto-decrement operator is not magical.

=head2 Exponentiation
X<**> X<exponentiation> X<power>

Binary C<"**"> is the exponentiation operator.  It binds even more
tightly than unary minus, so C<-2**4> is C<-(2**4)>, not C<(-2)**4>.
(This is
implemented using C's C<pow(3)> function, which actually works on doubles
internally.)

Note that certain exponentiation expressions are ill-defined:
these include C<0**0>, C<1**Inf>, and C<Inf**0>.  Do not expect
any particular results from these special cases, the results
are platform-dependent.

=head2 Symbolic Unary Operators
X<unary operator> X<operator, unary>

Unary C<"!"> performs logical negation, that is, "not".  See also
L<C<not>|/Logical Not> for a lower precedence version of this.
X<!>

Unary C<"-"> performs arithmetic negation if the operand is numeric,
including any string that looks like a number.  If the operand is
an identifier, a string consisting of a minus sign concatenated
with the identifier is returned.  Otherwise, if the string starts
with a plus or minus, a string starting with the opposite sign is
returned.  One effect of these rules is that C<-bareword> is equivalent
to the string C<"-bareword">.  If, however, the string begins with a
non-alphabetic character (excluding C<"+"> or C<"-">), Perl will attempt
to convert
the string to a numeric, and the arithmetic negation is performed.  If the
string cannot be cleanly converted to a numeric, Perl will give the warning
B<Argument "the string" isn't numeric in negation (-) at ...>.
X<-> X<negation, arithmetic>

Unary C<"~"> performs bitwise negation, that is, 1's complement.  For
example, S<C<0666 & ~027>> is 0640.  (See also L</Integer Arithmetic> and
L</Bitwise String Operators>.)  Note that the width of the result is
platform-dependent: C<~0> is 32 bits wide on a 32-bit platform, but 64
bits wide on a 64-bit platform, so if you are expecting a certain bit
width, remember to use the C<"&"> operator to mask off the excess bits.
X<~> X<negation, binary>

Starting in Perl 5.28, it is a fatal error to try to complement a string
containing a character with an ordinal value above 255.

If the "bitwise" feature is enabled via S<C<use
feature 'bitwise'>> or C<use v5.28>, then unary
C<"~"> always treats its argument as a number, and an
alternate form of the operator, C<"~.">, always treats its argument as a
string.  So C<~0> and C<~"0"> will both give 2**32-1 on 32-bit platforms,
whereas C<~.0> and C<~."0"> will both yield C<"\xff">.  Until Perl 5.28,
this feature produced a warning in the C<"experimental::bitwise"> category.

Unary C<"+"> has no effect whatsoever, even on strings.  It is useful
syntactically for separating a function name from a parenthesized expression
that would otherwise be interpreted as the complete list of function
arguments.  (See examples above under L</Terms and List Operators (Leftward)>.)
X<+>

Unary C<"\"> creates references.  If its operand is a single sigilled
thing, it creates a reference to that object.  If its operand is a
parenthesised list, then it creates references to the things mentioned
in the list.  Otherwise it puts its operand in list context, and creates
a list of references to the scalars in the list provided by the operand.
See L<perlreftut>
and L<perlref>.  Do not confuse this behavior with the behavior of
backslash within a string, although both forms do convey the notion
of protecting the next thing from interpolation.
X<\> X<reference> X<backslash>

=head2 Binding Operators
X<binding> X<operator, binding> X<=~> X<!~>

Binary C<"=~"> binds a scalar expression to a pattern match.  Certain operations
search or modify the string C<$_> by default.  This operator makes that kind
of operation work on some other string.  The right argument is a search
pattern, substitution, or transliteration.  The left argument is what is
supposed to be searched, substituted, or transliterated instead of the default
C<$_>.  When used in scalar context, the return value generally indicates the
success of the operation.  The exceptions are substitution (C<s///>)
and transliteration (C<y///>) with the C</r> (non-destructive) option,
which cause the B<r>eturn value to be the result of the substitution.
Behavior in list context depends on the particular operator.
See L</"Regexp Quote-Like Operators"> for details and L<perlretut> for
examples using these operators.

If the right argument is an expression rather than a search pattern,
substitution, or transliteration, it is interpreted as a search pattern at run
time.  Note that this means that its
contents will be interpolated twice, so

    '\\' =~ q'\\';

is not ok, as the regex engine will end up trying to compile the
pattern C<\>, which it will consider a syntax error.

Binary C<"!~"> is just like C<"=~"> except the return value is negated in
the logical sense.

Binary C<"!~"> with a non-destructive substitution (C<s///r>) or transliteration
(C<y///r>) is a syntax error.

=head2 Multiplicative Operators
X<operator, multiplicative>

Binary C<"*"> multiplies two numbers.
X<*>

Binary C<"/"> divides two numbers.
X</> X<slash>

Binary C<"%"> is the modulo operator, which computes the division
remainder of its first argument with respect to its second argument.
Given integer
operands C<$m> and C<$n>: If C<$n> is positive, then S<C<$m % $n>> is
C<$m> minus the largest multiple of C<$n> less than or equal to
C<$m>.  If C<$n> is negative, then S<C<$m % $n>> is C<$m> minus the
smallest multiple of C<$n> that is not less than C<$m> (that is, the
result will be less than or equal to zero).  If the operands
C<$m> and C<$n> are floating point values and the absolute value of
C<$n> (that is C<abs($n)>) is less than S<C<(UV_MAX + 1)>>, only
the integer portion of C<$m> and C<$n> will be used in the operation
(Note: here C<UV_MAX> means the maximum of the unsigned integer type).
If the absolute value of the right operand (C<abs($n)>) is greater than
or equal to S<C<(UV_MAX + 1)>>, C<"%"> computes the floating-point remainder
C<$r> in the equation S<C<($r = $m - $i*$n)>> where C<$i> is a certain
integer that makes C<$r> have the same sign as the right operand
C<$n> (B<not> as the left operand C<$m> like C function C<fmod()>)
and the absolute value less than that of C<$n>.
Note that when S<C<use integer>> is in scope, C<"%"> gives you direct access
to the modulo operator as implemented by your C compiler.  This
operator is not as well defined for negative operands, but it will
execute faster.
X<%> X<remainder> X<modulo> X<mod>

Binary C<x> is the repetition operator.  In scalar context, or if the
left operand is neither enclosed in parentheses nor a C<qw//> list,
it performs a string repetition.  In that case it supplies scalar
context to the left operand, and returns a string consisting of the
left operand string repeated the number of times specified by the right
operand.  If the C<x> is in list context, and the left operand is either
enclosed in parentheses or a C<qw//> list, it performs a list repetition.
In that case it supplies list context to the left operand, and returns
a list consisting of the left operand list repeated the number of times
specified by the right operand.
If the right operand is zero or negative (raising a warning on
negative), it returns an empty string
or an empty list, depending on the context.
X<x>

    print '-' x 80;		# print row of dashes

    print "\t" x ($tab/8), ' ' x ($tab%8);	# tab over

    @ones = (1) x 80;		# a list of 80 1's
    @ones = (5) x @ones;	# set all elements to 5


=head2 Additive Operators
X<operator, additive>

Binary C<"+"> returns the sum of two numbers.
X<+>

Binary C<"-"> returns the difference of two numbers.
X<->

Binary C<"."> concatenates two strings.
X<string, concatenation> X<concatenation>
X<cat> X<concat> X<concatenate> X<.>

=head2 Shift Operators
X<shift operator> X<operator, shift> X<<< << >>>
X<<< >> >>> X<right shift> X<left shift> X<bitwise shift>
X<shl> X<shr> X<shift, right> X<shift, left>

Binary C<<< "<<" >>> returns the value of its left argument shifted left by the
number of bits specified by the right argument.  Arguments should be
integers.  (See also L</Integer Arithmetic>.)

Binary C<<< ">>" >>> returns the value of its left argument shifted right by
the number of bits specified by the right argument.  Arguments should
be integers.  (See also L</Integer Arithmetic>.)

If S<C<use integer>> (see L</Integer Arithmetic>) is in force then
signed C integers are used (I<arithmetic shift>), otherwise unsigned C
integers are used (I<logical shift>), even for negative shiftees.
In arithmetic right shift the sign bit is replicated on the left,
in logical shift zero bits come in from the left.

Either way, the implementation isn't going to generate results larger
than the size of the integer type Perl was built with (32 bits or 64 bits).

Shifting by negative number of bits means the reverse shift: left
shift becomes right shift, right shift becomes left shift.  This is
unlike in C, where negative shift is undefined.

Shifting by more bits than the size of the integers means most of the
time zero (all bits fall off), except that under S<C<use integer>>
right overshifting a negative shiftee results in -1.  This is unlike
in C, where shifting by too many bits is undefined.  A common C
behavior is "shift by modulo wordbits", so that for example

    1 >> 64 == 1 >> (64 % 64) == 1 >> 0 == 1  # Common C behavior.

but that is completely accidental.

If you get tired of being subject to your platform's native integers,
the S<C<use bigint>> pragma neatly sidesteps the issue altogether:

    print 20 << 20;  # 20971520
    print 20 << 40;  # 5120 on 32-bit machines,
                     # 21990232555520 on 64-bit machines
    use bigint;
    print 20 << 100; # 25353012004564588029934064107520

=head2 Named Unary Operators
X<operator, named unary>

The various named unary operators are treated as functions with one
argument, with optional parentheses.

If any list operator (C<print()>, etc.) or any unary operator (C<chdir()>, etc.)
is followed by a left parenthesis as the next token, the operator and
arguments within parentheses are taken to be of highest precedence,
just like a normal function call.  For example,
because named unary operators are higher precedence than C<||>:

    chdir $foo    || die;	# (chdir $foo) || die
    chdir($foo)   || die;	# (chdir $foo) || die
    chdir ($foo)  || die;	# (chdir $foo) || die
    chdir +($foo) || die;	# (chdir $foo) || die

but, because C<"*"> is higher precedence than named operators:

    chdir $foo * 20;	# chdir ($foo * 20)
    chdir($foo) * 20;	# (chdir $foo) * 20
    chdir ($foo) * 20;	# (chdir $foo) * 20
    chdir +($foo) * 20;	# chdir ($foo * 20)

    rand 10 * 20;	# rand (10 * 20)
    rand(10) * 20;	# (rand 10) * 20
    rand (10) * 20;	# (rand 10) * 20
    rand +(10) * 20;	# rand (10 * 20)

Regarding precedence, the filetest operators, like C<-f>, C<-M>, etc. are
treated like named unary operators, but they don't follow this functional
parenthesis rule.  That means, for example, that C<-f($file).".bak"> is
equivalent to S<C<-f "$file.bak">>.
X<-X> X<filetest> X<operator, filetest>

See also L</"Terms and List Operators (Leftward)">.

=head2 Relational Operators
X<relational operator> X<operator, relational>

Perl operators that return true or false generally return values
that can be safely used as numbers.  For example, the relational
operators in this section and the equality operators in the next
one return C<1> for true and a special version of the defined empty
string, C<"">, which counts as a zero but is exempt from warnings
about improper numeric conversions, just as S<C<"0 but true">> is.

Binary C<< "<" >> returns true if the left argument is numerically less than
the right argument.
X<< < >>

Binary C<< ">" >> returns true if the left argument is numerically greater
than the right argument.
X<< > >>

Binary C<< "<=" >> returns true if the left argument is numerically less than
or equal to the right argument.
X<< <= >>

Binary C<< ">=" >> returns true if the left argument is numerically greater
than or equal to the right argument.
X<< >= >>

Binary C<"lt"> returns true if the left argument is stringwise less than
the right argument.
X<< lt >>

Binary C<"gt"> returns true if the left argument is stringwise greater
than the right argument.
X<< gt >>

Binary C<"le"> returns true if the left argument is stringwise less than
or equal to the right argument.
X<< le >>

Binary C<"ge"> returns true if the left argument is stringwise greater
than or equal to the right argument.
X<< ge >>

A sequence of relational operators, such as S<C<"$x E<lt> $y E<lt>=
$z">>, performs chained comparisons, in the manner described above in
the section L</"Operator Precedence and Associativity">.
Beware that they do not chain with equality operators, which have lower
precedence.

=head2 Equality Operators
X<equality> X<equal> X<equals> X<operator, equality>

Binary C<< "==" >> returns true if the left argument is numerically equal to
the right argument.
X<==>

Binary C<< "!=" >> returns true if the left argument is numerically not equal
to the right argument.
X<!=>

Binary C<"eq"> returns true if the left argument is stringwise equal to
the right argument.
X<eq>

Binary C<"ne"> returns true if the left argument is stringwise not equal
to the right argument.
X<ne>

A sequence of the above equality operators, such as S<C<"$x == $y ==
$z">>, performs chained comparisons, in the manner described above in
the section L</"Operator Precedence and Associativity">.
Beware that they do not chain with relational operators, which have
higher precedence.

Binary C<< "<=>" >> returns -1, 0, or 1 depending on whether the left
argument is numerically less than, equal to, or greater than the right
argument.  If your platform supports C<NaN>'s (not-a-numbers) as numeric
values, using them with C<< "<=>" >> returns undef.  C<NaN> is not
C<< "<" >>, C<< "==" >>, C<< ">" >>, C<< "<=" >> or C<< ">=" >> anything
(even C<NaN>), so those 5 return false.  S<C<< NaN != NaN >>> returns
true, as does S<C<NaN !=> I<anything else>>.  If your platform doesn't
support C<NaN>'s then C<NaN> is just a string with numeric value 0.
X<< <=> >>
X<spaceship>

    $ perl -le '$x = "NaN"; print "No NaN support here" if $x == $x'
    $ perl -le '$x = "NaN"; print "NaN support here" if $x != $x'

(Note that the L<bigint>, L<bigrat>, and L<bignum> pragmas all
support C<"NaN">.)

Binary C<"cmp"> returns -1, 0, or 1 depending on whether the left
argument is stringwise less than, equal to, or greater than the right
argument.

Here we can see the difference between <=> and cmp,

    print 10 <=> 2 #prints 1
    print 10 cmp 2 #prints -1

(likewise between gt and >, lt and <, etc.)
X<cmp>

Binary C<"~~"> does a smartmatch between its arguments.  Smart matching
is described in the next section.
X<~~>

The two-sided ordering operators C<"E<lt>=E<gt>"> and C<"cmp">, and the
smartmatch operator C<"~~">, are non-associative with respect to each
other and with respect to the equality operators of the same precedence.

C<"lt">, C<"le">, C<"ge">, C<"gt"> and C<"cmp"> use the collation (sort)
order specified by the current C<LC_COLLATE> locale if a S<C<use
locale>> form that includes collation is in effect.  See L<perllocale>.
Do not mix these with Unicode,
only use them with legacy 8-bit locale encodings.
The standard C<L<Unicode::Collate>> and
C<L<Unicode::Collate::Locale>> modules offer much more powerful
solutions to collation issues.

For case-insensitive comparisons, look at the L<perlfunc/fc> case-folding
function, available in Perl v5.16 or later:

    if ( fc($x) eq fc($y) ) { ... }

=head2 Class Instance Operator
X<isa operator>

Binary C<isa> evaluates to true when the left argument is an object instance of
the class (or a subclass derived from that class) given by the right argument.
If the left argument is not defined, not a blessed object instance, nor does
not derive from the class given by the right argument, the operator evaluates
as false. The right argument may give the class either as a bareword or a
scalar expression that yields a string class name:

    if( $obj isa Some::Class ) { ... }

    if( $obj isa "Different::Class" ) { ... }
    if( $obj isa $name_of_class ) { ... }

This feature is available from Perl 5.31.6 onwards when enabled by
C<use feature 'isa'>. This feature is enabled automatically by a
C<use v5.36> (or higher) declaration in the current scope.

=head2 Smartmatch Operator

First available in Perl 5.10.1 (the 5.10.0 version behaved differently),
binary C<~~> does a "smartmatch" between its arguments.  This is mostly
used implicitly in the C<when> construct described in L<perlsyn>, although
not all C<when> clauses call the smartmatch operator.  Unique among all of
Perl's operators, the smartmatch operator can recurse.  The smartmatch
operator is L<experimental|perlpolicy/experimental> and its behavior is
subject to change.

It is also unique in that all other Perl operators impose a context
(usually string or numeric context) on their operands, autoconverting
those operands to those imposed contexts.  In contrast, smartmatch
I<infers> contexts from the actual types of its operands and uses that
type information to select a suitable comparison mechanism.

The C<~~> operator compares its operands "polymorphically", determining how
to compare them according to their actual types (numeric, string, array,
hash, etc.).  Like the equality operators with which it shares the same
precedence, C<~~> returns 1 for true and C<""> for false.  It is often best
read aloud as "in", "inside of", or "is contained in", because the left
operand is often looked for I<inside> the right operand.  That makes the
order of the operands to the smartmatch operand often opposite that of
the regular match operator.  In other words, the "smaller" thing is usually
placed in the left operand and the larger one in the right.

The behavior of a smartmatch depends on what type of things its arguments
are, as determined by the following table.  The first row of the table
whose types apply determines the smartmatch behavior.  Because what
actually happens is mostly determined by the type of the second operand,
the table is sorted on the right operand instead of on the left.

 Left      Right      Description and pseudocode
 ===============================================================
 Any       undef      check whether Any is undefined
                like: !defined Any

 Any       Object     invoke ~~ overloading on Object, or die

 Right operand is an ARRAY:

 Left      Right      Description and pseudocode
 ===============================================================
 ARRAY1    ARRAY2     recurse on paired elements of ARRAY1 and ARRAY2[2]
                like: (ARRAY1[0] ~~ ARRAY2[0])
                        && (ARRAY1[1] ~~ ARRAY2[1]) && ...
 HASH      ARRAY      any ARRAY elements exist as HASH keys
                like: grep { exists HASH->{$_} } ARRAY
 Regexp    ARRAY      any ARRAY elements pattern match Regexp
                like: grep { /Regexp/ } ARRAY
 undef     ARRAY      undef in ARRAY
                like: grep { !defined } ARRAY
 Any       ARRAY      smartmatch each ARRAY element[3]
                like: grep { Any ~~ $_ } ARRAY

 Right operand is a HASH:

 Left      Right      Description and pseudocode
 ===============================================================
 HASH1     HASH2      all same keys in both HASHes
                like: keys HASH1 ==
                         grep { exists HASH2->{$_} } keys HASH1
 ARRAY     HASH       any ARRAY elements exist as HASH keys
                like: grep { exists HASH->{$_} } ARRAY
 Regexp    HASH       any HASH keys pattern match Regexp
                like: grep { /Regexp/ } keys HASH
 undef     HASH       always false (undef cannot be a key)
                like: 0 == 1
 Any       HASH       HASH key existence
                like: exists HASH->{Any}

 Right operand is CODE:

 Left      Right      Description and pseudocode
 ===============================================================
 ARRAY     CODE       sub returns true on all ARRAY elements[1]
                like: !grep { !CODE->($_) } ARRAY
 HASH      CODE       sub returns true on all HASH keys[1]
                like: !grep { !CODE->($_) } keys HASH
 Any       CODE       sub passed Any returns true
                like: CODE->(Any)

 Right operand is a Regexp:

 Left      Right      Description and pseudocode
 ===============================================================
 ARRAY     Regexp     any ARRAY elements match Regexp
                like: grep { /Regexp/ } ARRAY
 HASH      Regexp     any HASH keys match Regexp
                like: grep { /Regexp/ } keys HASH
 Any       Regexp     pattern match
                like: Any =~ /Regexp/

 Other:

 Left      Right      Description and pseudocode
 ===============================================================
 Object    Any        invoke ~~ overloading on Object,
                      or fall back to...

 Any       Num        numeric equality
                 like: Any == Num
 Num       nummy[4]    numeric equality
                 like: Num == nummy
 undef     Any        check whether undefined
                 like: !defined(Any)
 Any       Any        string equality
                 like: Any eq Any


Notes:

=over

=item 1.
Empty hashes or arrays match.

=item 2.
That is, each element smartmatches the element of the same index in the other array.[3]

=item 3.
If a circular reference is found, fall back to referential equality.

=item 4.
Either an actual number, or a string that looks like one.

=back

The smartmatch implicitly dereferences any non-blessed hash or array
reference, so the C<I<HASH>> and C<I<ARRAY>> entries apply in those cases.
For blessed references, the C<I<Object>> entries apply.  Smartmatches
involving hashes only consider hash keys, never hash values.

The "like" code entry is not always an exact rendition.  For example, the
smartmatch operator short-circuits whenever possible, but C<grep> does
not.  Also, C<grep> in scalar context returns the number of matches, but
C<~~> returns only true or false.

Unlike most operators, the smartmatch operator knows to treat C<undef>
specially:

    use v5.10.1;
    @array = (1, 2, 3, undef, 4, 5);
    say "some elements undefined" if undef ~~ @array;

Each operand is considered in a modified scalar context, the modification
being that array and hash variables are passed by reference to the
operator, which implicitly dereferences them.  Both elements
of each pair are the same:

    use v5.10.1;

    my %hash = (red    => 1, blue   => 2, green  => 3,
                orange => 4, yellow => 5, purple => 6,
                black  => 7, grey   => 8, white  => 9);

    my @array = qw(red blue green);

    say "some array elements in hash keys" if  @array ~~  %hash;
    say "some array elements in hash keys" if \@array ~~ \%hash;

    say "red in array" if "red" ~~  @array;
    say "red in array" if "red" ~~ \@array;

    say "some keys end in e" if /e$/ ~~  %hash;
    say "some keys end in e" if /e$/ ~~ \%hash;

Two arrays smartmatch if each element in the first array smartmatches
(that is, is "in") the corresponding element in the second array,
recursively.

    use v5.10.1;
    my @little = qw(red blue green);
    my @bigger = ("red", "blue", [ "orange", "green" ] );
    if (@little ~~ @bigger) {  # true!
        say "little is contained in bigger";
    }

Because the smartmatch operator recurses on nested arrays, this
will still report that "red" is in the array.

    use v5.10.1;
    my @array = qw(red blue green);
    my $nested_array = [[[[[[[ @array ]]]]]]];
    say "red in array" if "red" ~~ $nested_array;

If two arrays smartmatch each other, then they are deep
copies of each others' values, as this example reports:

    use v5.12.0;
    my @a = (0, 1, 2, [3, [4, 5], 6], 7);
    my @b = (0, 1, 2, [3, [4, 5], 6], 7);

    if (@a ~~ @b && @b ~~ @a) {
        say "a and b are deep copies of each other";
    }
    elsif (@a ~~ @b) {
        say "a smartmatches in b";
    }
    elsif (@b ~~ @a) {
        say "b smartmatches in a";
    }
    else {
        say "a and b don't smartmatch each other at all";
    }


If you were to set S<C<$b[3] = 4>>, then instead of reporting that "a and b
are deep copies of each other", it now reports that C<"b smartmatches in a">.
That's because the corresponding position in C<@a> contains an array that
(eventually) has a 4 in it.

Smartmatching one hash against another reports whether both contain the
same keys, no more and no less.  This could be used to see whether two
records have the same field names, without caring what values those fields
might have.  For example:

    use v5.10.1;
    sub make_dogtag {
        state $REQUIRED_FIELDS = { name=>1, rank=>1, serial_num=>1 };

        my ($class, $init_fields) = @_;

        die "Must supply (only) name, rank, and serial number"
            unless $init_fields ~~ $REQUIRED_FIELDS;

        ...
    }

However, this only does what you mean if C<$init_fields> is indeed a hash
reference. The condition C<$init_fields ~~ $REQUIRED_FIELDS> also allows the
strings C<"name">, C<"rank">, C<"serial_num"> as well as any array reference
that contains C<"name"> or C<"rank"> or C<"serial_num"> anywhere to pass
through.

The smartmatch operator is most often used as the implicit operator of a
C<when> clause.  See the section on "Switch Statements" in L<perlsyn>.

=head3 Smartmatching of Objects

To avoid relying on an object's underlying representation, if the
smartmatch's right operand is an object that doesn't overload C<~~>,
it raises the exception "C<Smartmatching a non-overloaded object
breaks encapsulation>".  That's because one has no business digging
around to see whether something is "in" an object.  These are all
illegal on objects without a C<~~> overload:

    %hash ~~ $object
       42 ~~ $object
   "fred" ~~ $object

However, you can change the way an object is smartmatched by overloading
the C<~~> operator.  This is allowed to
extend the usual smartmatch semantics.
For objects that do have an C<~~> overload, see L<overload>.

Using an object as the left operand is allowed, although not very useful.
Smartmatching rules take precedence over overloading, so even if the
object in the left operand has smartmatch overloading, this will be
ignored.  A left operand that is a non-overloaded object falls back on a
string or numeric comparison of whatever the C<ref> operator returns.  That
means that

    $object ~~ X

does I<not> invoke the overload method with C<I<X>> as an argument.
Instead the above table is consulted as normal, and based on the type of
C<I<X>>, overloading may or may not be invoked.  For simple strings or
numbers, "in" becomes equivalent to this:

    $object ~~ $number          ref($object) == $number
    $object ~~ $string          ref($object) eq $string

For example, this reports that the handle smells IOish
(but please don't really do this!):

    use IO::Handle;
    my $fh = IO::Handle->new();
    if ($fh ~~ /\bIO\b/) {
        say "handle smells IOish";
    }

That's because it treats C<$fh> as a string like
C<"IO::Handle=GLOB(0x8039e0)">, then pattern matches against that.

=head2 Bitwise And
X<operator, bitwise, and> X<bitwise and> X<&>

Binary C<"&"> returns its operands ANDed together bit by bit.  Although no
warning is currently raised, the result is not well defined when this operation
is performed on operands that aren't either numbers (see
L</Integer Arithmetic>) nor bitstrings (see L</Bitwise String Operators>).

Note that C<"&"> has lower priority than relational operators, so for example
the parentheses are essential in a test like

    print "Even\n" if ($x & 1) == 0;

If the "bitwise" feature is enabled via S<C<use feature 'bitwise'>> or
C<use v5.28>, then this operator always treats its operands as numbers.
Before Perl 5.28 this feature produced a warning in the
C<"experimental::bitwise"> category.

=head2 Bitwise Or and Exclusive Or
X<operator, bitwise, or> X<bitwise or> X<|> X<operator, bitwise, xor>
X<bitwise xor> X<^>

Binary C<"|"> returns its operands ORed together bit by bit.

Binary C<"^"> returns its operands XORed together bit by bit.

Although no warning is currently raised, the results are not well
defined when these operations are performed on operands that aren't either
numbers (see L</Integer Arithmetic>) nor bitstrings (see L</Bitwise String
Operators>).

Note that C<"|"> and C<"^"> have lower priority than relational operators, so
for example the parentheses are essential in a test like

    print "false\n" if (8 | 2) != 10;

If the "bitwise" feature is enabled via S<C<use feature 'bitwise'>> or
C<use v5.28>, then this operator always treats its operands as numbers.
Before Perl 5.28. this feature produced a warning in the
C<"experimental::bitwise"> category.

=head2 C-style Logical And
X<&&> X<logical and> X<operator, logical, and>

Binary C<"&&"> performs a short-circuit logical AND operation.  That is,
if the left operand is false, the right operand is not even evaluated.
Scalar or list context propagates down to the right operand if it
is evaluated.

=head2 C-style Logical Or
X<||> X<operator, logical, or>

Binary C<"||"> performs a short-circuit logical OR operation.  That is,
if the left operand is true, the right operand is not even evaluated.
Scalar or list context propagates down to the right operand if it
is evaluated.

=head2 C-style Logical Xor
X<^^> X<operator, logical, xor>

Binary C<"^^"> performs a logical XOR operation.  Both operands are
evaluated and the result is true only if exactly one of the operands is true.
Scalar or list context propagates down to the right operand.

=head2 Logical Defined-Or
X<//> X<operator, logical, defined-or>

Although it has no direct equivalent in C, Perl's C<//> operator is related
to its C-style "or".  In fact, it's exactly the same as C<||>, except that it
tests the left hand side's definedness instead of its truth.  Thus,
S<C<< EXPR1 // EXPR2 >>> returns the value of C<< EXPR1 >> if it's defined,
otherwise, the value of C<< EXPR2 >> is returned.
(C<< EXPR1 >> is evaluated in scalar context, C<< EXPR2 >>
in the context of C<< // >> itself).  Usually,
this is the same result as S<C<< defined(EXPR1) ? EXPR1 : EXPR2 >>> (except that
the ternary-operator form can be used as a lvalue, while S<C<< EXPR1 // EXPR2 >>>
cannot).  This is very useful for
providing default values for variables.  If you actually want to test if
at least one of C<$x> and C<$y> is defined, use S<C<defined($x // $y)>>.

The C<||>, C<//> and C<&&> operators return the last value evaluated
(unlike C's C<||> and C<&&>, which return 0 or 1).  Thus, a reasonably
portable way to find out the home directory might be:

    $home =  $ENV{HOME}
	  // $ENV{LOGDIR}
	  // (getpwuid($<))[7]
	  // die "You're homeless!\n";

In particular, this means that you shouldn't use this
for selecting between two aggregates for assignment:

    @a = @b || @c;            # This doesn't do the right thing
    @a = scalar(@b) || @c;    # because it really means this.
    @a = @b ? @b : @c;        # This works fine, though.
