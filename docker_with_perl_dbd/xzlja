
=over 4

=item B<Not within the scope of C<"use locale">>

Only certain operations (all originating outside Perl) should be
affected, as follows:

=over 4

=item *

The current locale is used when going outside of Perl with
operations like L<system()|perlfunc/system LIST> or
L<qxE<sol>E<sol>|perlop/qxE<sol>STRINGE<sol>>, if those operations are
locale-sensitive.

=item *

Also Perl gives access to various C library functions through the
L<POSIX> module.  Some of those functions are always affected by the
current locale.  For example, C<POSIX::strftime()> uses C<LC_TIME>;
C<POSIX::strtod()> uses C<LC_NUMERIC>; C<POSIX::strcoll()> and
C<POSIX::strxfrm()> use C<LC_COLLATE>.  All such functions
will behave according to the current underlying locale, even if that
locale isn't exposed to Perl space.

This applies as well to L<I18N::Langinfo>.

=item *

XS modules for all categories but C<LC_NUMERIC> get the underlying
locale, and hence any C library functions they call will use that
underlying locale.  For more discussion, see
L<perlclib/Dealing with locales>.

=back

Note that all C programs (including the perl interpreter, which is
written in C) always have an underlying locale.  That locale is the "C"
locale unless changed by a call to L<setlocale()|/The setlocale
function>.  When Perl starts up, it changes the underlying locale to the
one which is indicated by the L</ENVIRONMENT>.  When using the L<POSIX>
module or writing XS code, it is important to keep in mind that the
underlying locale may be something other than "C", even if the program
hasn't explicitly changed it.

Z<>

=item B<Lingering effects of C<S<use locale>>>

Certain Perl operations that are set-up within the scope of a
C<use locale> retain that effect even outside the scope.
These include:

=over 4

=item *

The output format of a L<write()|perlfunc/write> is determined by an
earlier format declaration (L<perlfunc/format>), so whether or not the
output is affected by locale is determined by if the C<format()> is
within the scope of a C<use locale>, not whether the C<write()>
is.

=item *

Regular expression patterns can be compiled using
L<qrE<sol>E<sol>|perlop/qrE<sol>STRINGE<sol>msixpodualn> with actual
matching deferred to later.  Again, it is whether or not the compilation
was done within the scope of C<use locale> that determines the match
behavior, not if the matches are done within such a scope or not.

=back

Z<>

=item B<Under C<"use locale";>>

=over 4

=item *

All the above operations

=item *

B<Format declarations> (L<perlfunc/format>) and hence any subsequent
C<write()>s use C<LC_NUMERIC>.

=item *

B<stringification and output> use C<LC_NUMERIC>.
These include the results of
C<print()>,
C<printf()>,
C<say()>,
and
C<sprintf()>.

=item *

B<The comparison operators> (C<lt>, C<le>, C<cmp>, C<ge>, and C<gt>) use
C<LC_COLLATE>.  C<sort()> is also affected if used without an
explicit comparison function, because it uses C<cmp> by default.

B<Note:> C<eq> and C<ne> are unaffected by locale: they always
perform a char-by-char comparison of their scalar operands.  What's
more, if C<cmp> finds that its operands are equal according to the
collation sequence specified by the current locale, it goes on to
perform a char-by-char comparison, and only returns I<0> (equal) if the
operands are char-for-char identical.  If you really want to know whether
two strings--which C<eq> and C<cmp> may consider different--are equal
as far as collation in the locale is concerned, see the discussion in
L</Category C<LC_COLLATE>: Collation>.

=item *

B<Regular expressions and case-modification functions> (C<uc()>, C<lc()>,
C<ucfirst()>, and C<lcfirst()>) use C<LC_CTYPE>

=item *

B<The variables L<C<$!>|perlvar/$ERRNO>> (and its synonyms C<$ERRNO> and
C<$OS_ERROR>) B<and> L<C<$^E>|perlvar/$EXTENDED_OS_ERROR>> (and its synonym
C<$EXTENDED_OS_ERROR>) when used as strings use C<LC_MESSAGES>  On
platforms that lack this category C<LC_CTYPE> is used instead.

=back

=back

The default behavior is restored with the S<C<no locale>> pragma, or
upon reaching the end of the block enclosing C<use locale>.
Note that C<use locale> calls may be
nested, and that what is in effect within an inner scope will revert to
the outer scope's rules at the end of the inner scope.

The string result of any operation that uses locale
information is tainted (if your perl supports taint checking),
as it is possible for a locale to be untrustworthy.
See L</"SECURITY">.

Starting in Perl v5.16 in a very limited way, and more generally in
v5.22, you can restrict which category or categories are enabled by this
particular instance of the pragma by adding parameters to it.  (This
capability was to enable you to write code to work around deficiencies in
perl's locale handling, which have since been corrected, so it is
unlikely that new code will need to use it.)

For example,

 use locale qw(:ctype :numeric);

enables locale awareness within its scope of only those operations
(listed above) that are affected by C<LC_CTYPE> and C<LC_NUMERIC>.

The possible categories are: C<:collate>, C<:ctype>, C<:messages>,
C<:monetary>, C<:numeric>, C<:time>, and the pseudo category
C<:characters> (described below).

Thus you can say

 use locale ':messages';

and only L<C<"$!">|perlvar/$ERRNO> and L<C<"$^E">|perlvar/$EXTENDED_OS_ERROR>
will be locale aware.  Everything else is unaffected.

Since Perl doesn't currently do anything with the C<LC_MONETARY>
category, specifying C<:monetary> does effectively nothing.  Some
systems have other categories, such as C<LC_PAPER>, but the perl core
doesn't do anything with them, and there is no way to specify
them in this pragma's arguments.

You can also easily say to use all categories but one, by either, for
example,

 use locale ':!ctype';
 use locale ':not_ctype';

both of which mean to enable locale awareness of all categories but
C<LC_CTYPE>.  Only one category argument may be specified in a
S<C<use locale>> if it is of the negated form.

Prior to v5.22 only one form of the pragma with arguments is available:

 use locale ':not_characters';

(and you have to say C<not_>; you can't use the bang C<!> form).  This
pseudo category is a shorthand for specifying both C<:collate> and
C<:ctype>.  Hence, in the negated form, it is nearly the same thing as
saying

 use locale qw(:messages :monetary :numeric :time);

We use the term "nearly", because C<:not_characters> also turns on
S<C<use feature 'unicode_strings'>> within its scope.  This form is
less useful in v5.20 and later, and is described fully in
L</Unicode and UTF-8>, but briefly, it tells Perl to not use the
character portions of the locale definition, that is the C<LC_CTYPE> and
C<LC_COLLATE> categories.  Instead it will use the native character set
(extended by Unicode).  When using this parameter, you are responsible
for getting the external character set translated into the
native/Unicode one (which it already will be if it is one of the
increasingly popular UTF-8 locales).  There are convenient ways of doing
this, as described in L</Unicode and UTF-8>.

=head2 The setlocale function

WARNING!  Prior to Perl 5.28 or on a system that does not support
thread-safe locale operations, do NOT use this function in a
L<thread|threads>.  The locale will change in all other threads at the
same time, and should your thread get paused by the operating system,
and another started, that thread will not have the locale it is
expecting.  On some platforms, there can be a race leading to segfaults
if two threads call this function nearly simultaneously.  This warning
does not apply on unthreaded builds, or on perls where
C<${^SAFE_LOCALES}> exists and is non-zero; namely Perl 5.28 and later
unthreaded or compiled to be locale-thread-safe.  On z/OS systems, this
function becomes a no-op once any thread is started.  Thus, on that
system, you can set up the locale before creating any threads, and that
locale will be the one in effect for the entire program.

Otherwise, you can switch locales as often as you wish at run time with
the C<POSIX::setlocale()> function:

        # Import locale-handling tool set from POSIX module.
        # This example uses: setlocale -- the function call
        #                    LC_CTYPE -- explained below
        # (Showing the testing for success/failure of operations is
        # omitted in these examples to avoid distracting from the main
        # point)

        use POSIX qw(locale_h);
        use locale;
        my $old_locale;

        # query and save the old locale
        $old_locale = setlocale(LC_CTYPE);

        setlocale(LC_CTYPE, "fr_CA.ISO8859-1");
        # LC_CTYPE now in locale "French, Canada, codeset ISO 8859-1"

        setlocale(LC_CTYPE, "");
        # LC_CTYPE now reset to the default defined by the
        # LC_ALL/LC_CTYPE/LANG environment variables, or to the system
        # default.  See below for documentation.

        # restore the old locale
        setlocale(LC_CTYPE, $old_locale);

The first argument of C<setlocale()> gives the B<category>, the second the
B<locale>.  The category tells in what aspect of data processing you
want to apply locale-specific rules.  Category names are discussed in
L</LOCALE CATEGORIES> and L</"ENVIRONMENT">.  The locale is the name of a
collection of customization information corresponding to a particular
combination of language, country or territory, and codeset.  Read on for
hints on the naming of locales: not all systems name locales as in the
example.

If no second argument is provided and the category is something other
than C<LC_ALL>, the function returns a string naming the current locale
for the category.  You can use this value as the second argument in a
subsequent call to C<setlocale()>, B<but> on some platforms the string
is opaque, not something that most people would be able to decipher as
to what locale it means.

If no second argument is provided and the category is C<LC_ALL>, the
result is implementation-dependent.  It may be a string of
concatenated locale names (separator also implementation-dependent)
or a single locale name.  Please consult your L<setlocale(3)> man page for
details.

If a second argument is given and it corresponds to a valid locale,
the locale for the category is set to that value, and the function
returns the now-current locale value.  You can then use this in yet
another call to C<setlocale()>.  (In some implementations, the return
value may sometimes differ from the value you gave as the second
argument--think of it as an alias for the value you gave.)

As the example shows, if the second argument is an empty string, the
category's locale is returned to the default specified by the
corresponding environment variables.  Generally, this results in a
return to the default that was in force when Perl started up: changes
to the environment made by the application after startup may or may not
be noticed, depending on your system's C library.

Note that when a form of C<use locale> that doesn't include all
categories is specified, Perl ignores the excluded categories.

If C<setlocale()> fails for some reason (for example, an attempt to set
to a locale unknown to the system), the locale for the category is not
changed, and the function returns C<undef>.

Starting in Perl 5.28, on multi-threaded perls compiled on systems that
implement POSIX 2008 thread-safe locale operations, this function
doesn't actually call the system C<setlocale>.  Instead those
thread-safe operations are used to emulate the C<setlocale> function,
but in a thread-safe manner.

You can force the thread-safe locale operations to always be used (if
available) by recompiling perl with

 -Accflags='-DUSE_THREAD_SAFE_LOCALE'

added to your call to F<Configure>.

For further information about the categories, consult L<setlocale(3)>.

=head2 Multi-threaded operation

Beginning in Perl 5.28, multi-threaded locale operation is supported on
systems that implement either the POSIX 2008 or Windows-specific
thread-safe locale operations.  Many modern systems, such as various
Unix variants do have this.  Others, such as most *BSD-derived variants,
including Darwin, claim to have it, but are buggy as of May 2024, so
Perl avoids their use.

You can tell if using locales is safe on your system by looking at the
read-only variable C<${^SAFE_LOCALES}>.  The value is 1 if the
perl is not threaded, or if it is using thread-safe locale operations.

Thread-safe operations are supported in Windows starting in Visual Studio
2005, in cygwin, in MingW compiled to use UCRT (the Universal C Run Time
library), and in systems compatible with POSIX 2008.
C<${^SAFE_LOCALES}> will be 0 on threaded builds on platforms that Perl
knows to have buggy implementations.

Be aware that writing a multi-threaded application will not be portable
to a platform which lacks the native thread-safe locale support.  On
systems that do have it, you automatically get this behavior for
threaded perls, without having to do anything.  If for some reason, you
don't want to use this capability (perhaps the POSIX 2008 support turns
out to be buggy on your system), you can manually compile Perl to use
the old non-thread-safe implementation by passing the argument
C<-Accflags='-DNO_THREAD_SAFE_LOCALE'> to F<Configure>.  Except on
Windows, this will continue to use certain of the POSIX 2008 functions
in some situations.  If these are buggy, you can pass the following to
F<Configure> instead or additionally:
C<-Accflags='-DNO_POSIX_2008_LOCALE'>.  This will also keep the code
from using thread-safe locales.
C<${^SAFE_LOCALES}> will be 0 on systems that turn off the thread-safe
operations.

Normally on unthreaded builds, Perl uses the traditional C<setlocale()> 
to change the locale, and not the alternate POSIX 2008 thread-safe
locale-changing functions.  You can force the use of these on systems
that have them by adding the C<-Accflags='-DUSE_THREAD_SAFE_LOCALE'> to
F<Configure>.

The initial program is started up using the locale specified from the
environment, as currently, described in L</ENVIRONMENT>.   All newly
created threads start with C<LC_ALL> set to C<"C">.  Each thread may
use C<POSIX::setlocale()> to query or switch its locale at any time,
without affecting any other thread.  All locale-dependent operations
automatically use their thread's locale.

This should be completely transparent to any applications written
entirely in Perl (minus a few rarely encountered caveats given in the
L</Multi-threaded> section).  Information for XS module writers is given
in L<perlclib/Dealing with locales>.

=head2 Finding locales

For locales available in your system, consult also L<setlocale(3)> to
see whether it leads to the list of available locales (search for the
I<SEE ALSO> section).  If that fails, try the following command lines:

        locale -a

        nlsinfo

        ls /usr/lib/nls/loc

        ls /usr/lib/locale

        ls /usr/lib/nls

	ls /usr/share/locale

and see whether they list something resembling these

        en_US.ISO8859-1     de_DE.ISO8859-1     ru_RU.ISO8859-5
        en_US.iso88591      de_DE.iso88591      ru_RU.iso88595
        en_US               de_DE               ru_RU
        en                  de                  ru
        english             german              russian
        english.iso88591    german.iso88591     russian.iso88595
        english.roman8                          russian.koi8r

Sadly, even though the calling interface for C<setlocale()> has been
standardized, names of locales and the directories where the
configuration resides have not been.  The basic form of the name is
I<language[_territory[.codeset]][@modifier]>.
The I<language> and I<country>
are usually from the standards B<ISO 3166> and B<ISO 639>, the
two-letter abbreviations for the countries and the languages of the
world, respectively.  The I<codeset> part often mentions some B<ISO
8859> character set, the Latin codesets.  For example, C<ISO 8859-1>
is the so-called "Western European codeset" that can be used to encode
most Western European languages adequately.  Again, there are several
ways to write even the name of that one standard.  Lamentably.
I<modifier> is very individualized to the rest of the locale, naming
some variant, such as a different currency symbol than the locale would
normally contain.

Two special locales are worth particular mention: "C" and "POSIX".
Currently these are effectively the same locale: the difference is
mainly that the first one is defined by the C standard, the second by
the POSIX standard.  They define the B<default locale> in which
every program starts in the absence of locale information in its
environment.  (The I<default> default locale, if you will.)  Its language
is (American) English and its character codeset ASCII or, rarely, a
superset thereof (such as the "DEC Multinational Character Set
(DEC-MCS)").  B<Warning>. The C locale delivered by some vendors
may not actually exactly match what the C standard calls for.  So
beware.

B<NOTE>: Not all systems have the "POSIX" locale (not all systems are
POSIX-conformant), so use "C" when you need explicitly to specify this
default locale.

=head2 LOCALE PROBLEMS

You may encounter the following warning message at Perl startup:

	perl: warning: Setting locale failed.
	perl: warning: Please check that your locale settings:
	        LC_ALL = "En_US",
	        LANG = (unset)
	    are supported and installed on your system.
	perl: warning: Falling back to the standard locale ("C").

This means that your locale settings had C<LC_ALL> set to "En_US" and
LANG exists but has no value.  Perl tried to believe you but could not.
Instead, Perl gave up and fell back to the "C" locale, the default locale
that is supposed to work no matter what.  (On Windows, it first tries
falling back to the system default locale.)  This usually means your
locale settings were wrong, they mention locales your system has never
heard of, or the locale installation in your system has problems (for
example, some system files are broken or missing).  There are quick and
temporary fixes to these problems, as well as more thorough and lasting
fixes.

=head3 Testing for broken locales

If you are building Perl from source, the Perl test suite file
F<lib/locale.t> can be used to test the locales on your system.
Setting the environment variable C<PERL_DEBUG_FULL_TEST> to 1
will cause it to output detailed results.  For example, on Linux, you
could say

 PERL_DEBUG_FULL_TEST=1 ./perl -T -Ilib lib/locale.t > locale.log 2>&1

Besides many other tests, it will test every locale it finds on your
system to see if they conform to the POSIX standard.  If any have
errors, it will include a summary near the end of the output of which
locales passed all its tests, and which failed, and why.

=head3 Temporarily fixing locale problems

The two quickest fixes are either to render Perl silent about any
locale inconsistencies or to run Perl under the default locale "C".

Perl's moaning about locale problems can be silenced by setting the
environment variable C<PERL_BADLANG> to "0" or "".
This method really just sweeps the problem under the carpet: you tell
Perl to shut up even when Perl sees that something is wrong.  Do not
be surprised if later something locale-dependent misbehaves.

Perl can be run under the "C" locale by setting the environment
variable C<LC_ALL> to "C".  This method is perhaps a bit more civilized
than the C<PERL_BADLANG> approach, but setting C<LC_ALL> (or
other locale variables) may affect other programs as well, not just
Perl.  In particular, external programs run from within Perl will see
these changes.  If you make the new settings permanent (read on), all
programs you run see the changes.  See L</"ENVIRONMENT"> for
the full list of relevant environment variables and L</"USING LOCALES">
for their effects in Perl.  Effects in other programs are
easily deducible.  For example, the variable C<LC_COLLATE> may well affect
your B<sort> program (or whatever the program that arranges "records"
alphabetically in your system is called).

You can test out changing these variables temporarily, and if the
new settings seem to help, put those settings into your shell startup
files.  Consult your local documentation for the exact details.  For
Bourne-like shells (B<sh>, B<ksh>, B<bash>, B<zsh>):

	LC_ALL=en_US.ISO8859-1
	export LC_ALL

This assumes that we saw the locale "en_US.ISO8859-1" using the commands
discussed above.  We decided to try that instead of the above faulty
locale "En_US".

And in Csh-ish shells (B<csh>, B<tcsh>)

	setenv LC_ALL en_US.ISO8859-1

or if you have the "env" application you can do (in any shell)

	env LC_ALL=en_US.ISO8859-1 perl ...

If you do not know what shell you have, consult your local
helpdesk or the equivalent.

=head3 Permanently fixing locale problems

The slower but superior fixes are when you may be able to yourself
fix the misconfiguration of your own environment variables.  The
mis(sing)configuration of the whole system's locales usually requires
the help of your system administrator.

First, see earlier in this document about L</Finding locales>.  That tells
how to find which locales are really supported--and more importantly,
installed--on your system.  In our example error message, environment
variables affecting the locale are listed in the order of decreasing
importance (and unset variables do not matter).  Therefore, having
LC_ALL set to "En_US" must have been the bad choice, as shown by the
error message.  First try fixing locale settings listed first.

Second, if using the listed commands you see something B<exactly>
(prefix matches do not count and case usually counts) like "En_US"
without the quotes, then you should be okay because you are using a
locale name that should be installed and available in your system.
In this case, see L</Permanently fixing your system's locale configuration>.

=head3 Permanently fixing your system's locale configuration

This is when you see something like:

	perl: warning: Please check that your locale settings:
	        LC_ALL = "En_US",
	        LANG = (unset)
	    are supported and installed on your system.

but then cannot see that "En_US" listed by the above-mentioned
commands.  You may see things like "en_US.ISO8859-1", but that isn't
the same.  In this case, try running under a locale
that you can list and which somehow matches what you tried.  The
rules for matching locale names are a bit vague because
standardization is weak in this area.  See again the
L</Finding locales> about general rules.

=head3 Fixing system locale configuration

Contact a system administrator (preferably your own) and report the exact
error message you get, and ask them to read this same documentation you
are now reading.  They should be able to check whether there is something
wrong with the locale configuration of the system.  The L</Finding locales>
section is unfortunately a bit vague about the exact commands and places
because these things are not that standardized.

=head2 The localeconv function

The C<POSIX::localeconv()> function allows you to get particulars of the
locale-dependent numeric formatting information specified by the current
underlying C<LC_NUMERIC> and C<LC_MONETARY> locales (regardless of
whether called from within the scope of C<S<use locale>> or not).  (If
you just want the name of
the current locale for a particular category, use C<POSIX::setlocale()>
with a single parameter--see L</The setlocale function>.)

        use POSIX qw(locale_h);

        # Get a reference to a hash of locale-dependent info
        $locale_values = localeconv();

        # Output sorted list of the values
        for (sort keys %$locale_values) {
            printf "%-20s = %s\n", $_, $locale_values->{$_}
        }

C<localeconv()> takes no arguments, and returns B<a reference to> a hash.
The keys of this hash are variable names for formatting, such as
C<decimal_point> and C<thousands_sep>.  The values are the
corresponding, er, values.  See L<POSIX/localeconv> for a longer
example listing the categories an implementation might be expected to
provide; some provide more and others fewer.  You don't need an
explicit C<use locale>, because C<localeconv()> always observes the
current locale.

Here's a simple-minded example program that rewrites its command-line
parameters as integers correctly formatted in the current locale:

    use POSIX qw(locale_h);

    # Get some of locale's numeric formatting parameters
    my ($thousands_sep, $grouping) =
            @{localeconv()}{'thousands_sep', 'grouping'};

    # Apply defaults if values are missing
    $thousands_sep = ',' unless $thousands_sep;

    # grouping and mon_grouping are packed lists
    # of small integers (characters) telling the
    # grouping (thousand_seps and mon_thousand_seps
    # being the group dividers) of numbers and
    # monetary quantities.  The integers' meanings:
    # 255 means no more grouping, 0 means repeat
    # the previous grouping, 1-254 means use that
    # as the current grouping.  Grouping goes from
    # right to left (low to high digits).  In the
    # below we cheat slightly by never using anything
    # else than the first grouping (whatever that is).
    if ($grouping) {
        @grouping = unpack("C*", $grouping);
    } else {
        @grouping = (3);
    }

    # Format command line params for current locale
    for (@ARGV) {
        $_ = int;    # Chop non-integer part
        1 while
        s/(\d)(\d{$grouping[0]}($|$thousands_sep))/$1$thousands_sep$2/;
        print "$_";
    }
    print "\n";

Note that if the platform doesn't have C<LC_NUMERIC> and/or
C<LC_MONETARY> available or enabled, the corresponding elements of the
hash will be missing.

=head2 I18N::Langinfo

Another interface for querying locale-dependent information is the
C<I18N::Langinfo::langinfo()> function.

The following example will import the C<langinfo()> function itself and
three constants to be used as arguments to C<langinfo()>: a constant for
the abbreviated first day of the week (the numbering starts from
Sunday = 1) and two more constants for the affirmative and negative
answers for a yes/no question in the current locale.

    use I18N::Langinfo qw(langinfo ABDAY_1 YESSTR NOSTR);

    my ($abday_1, $yesstr, $nostr)
                = map { langinfo } qw(ABDAY_1 YESSTR NOSTR);

    print "$abday_1? [$yesstr/$nostr] ";

In other words, in the "C" (or English) locale the above will probably
print something like:

    Sun? [yes/no]

See L<I18N::Langinfo> for more information.

=head1 LOCALE CATEGORIES

The following subsections describe basic locale categories.  Beyond these,
some combination categories allow manipulation of more than one
basic category at a time.  See L</"ENVIRONMENT"> for a discussion of these.

=head2 Category C<LC_COLLATE>: Collation: Text Comparisons and Sorting

In the scope of a S<C<use locale>> form that includes collation, Perl
looks to the C<LC_COLLATE>
environment variable to determine the application's notions on collation
(ordering) of characters.  For example, "b" likely follows "a" in Latin
alphabets, but where do "E<aacute>" and "E<aring>" belong?  And while
"color" follows "chocolate" in English, what about in traditional Spanish?

The following collations all make sense and you may meet any of them
if you C<"use locale">.

	A B C D E a b c d e
	A a B b C c D d E e
	a A b B c C d D e E
	a b c d e A B C D E

Here is a code snippet to tell what "word"
characters are in the current locale, in that locale's order:

        use locale;
        print +(sort grep /\w/, map { chr } 0..255), "\n";

Compare this with the characters that you see and their order if you
state explicitly that the locale should be ignored:

        no locale;
        print +(sort grep /\w/, map { chr } 0..255), "\n";

This machine-native collation (which is what you get unless S<C<use
locale>> has appeared earlier in the same block) must be used for
sorting raw binary data, whereas the locale-dependent collation of the
first example is useful for natural text.

As noted in L</USING LOCALES>, C<cmp> compares according to the current
collation locale when C<use locale> is in effect, but falls back to a
char-by-char comparison for strings that the locale says are equal. You
can use C<POSIX::strcoll()> if you don't want this fall-back:

        use POSIX qw(strcoll);
        $equal_in_locale =
            !strcoll("space and case ignored", "SpaceAndCaseIgnored");

C<$equal_in_locale> will be true if the collation locale specifies a
dictionary-like ordering that ignores space characters completely and
which folds case.

Perl uses the platform's C library collation functions C<strcoll()> and
C<strxfrm()>.  That means you get whatever they give.  On some
platforms, these functions work well on UTF-8 locales, giving
a reasonable default collation for the code points that are important in
that locale.  (And if they aren't working well, the problem may only be
that the locale definition is deficient, so can be fixed by using a
better definition file.  Unicode's definitions (see L</Freely available
locale definitions>) provide reasonable UTF-8 locale collation
definitions.)  Starting in Perl v5.26, Perl's use of these functions has
been made more seamless.  This may be sufficient for your needs.  For
more control, and to make sure strings containing any code point (not
just the ones important in the locale) collate properly, the
L<Unicode::Collate> module is suggested.

In non-UTF-8 locales (hence single byte), code points above 0xFF are
technically invalid.  But if present, again starting in v5.26, they will
collate to the same position as the highest valid code point does.  This
generally gives good results, but the collation order may be skewed if
the valid code point gets special treatment when it forms particular
sequences with other characters as defined by the locale.
When two strings collate identically, the code point order is used as a
tie breaker.

If Perl detects that there are problems with the locale collation order,
it reverts to using non-locale collation rules for that locale.

If you have a single string that you want to check for "equality in
locale" against several others, you might think you could gain a little
efficiency by using C<POSIX::strxfrm()> in conjunction with C<eq>:

        use POSIX qw(strxfrm);
        $xfrm_string = strxfrm("Mixed-case string");
        print "locale collation ignores spaces\n"
            if $xfrm_string eq strxfrm("Mixed-casestring");
        print "locale collation ignores hyphens\n"
            if $xfrm_string eq strxfrm("Mixedcase string");
        print "locale collation ignores case\n"
            if $xfrm_string eq strxfrm("mixed-case string");

C<strxfrm()> takes a string and maps it into a transformed string for use
in char-by-char comparisons against other transformed strings during
collation.  "Under the hood", locale-affected Perl comparison operators
call C<strxfrm()> for both operands, then do a char-by-char
comparison of the transformed strings.  By calling C<strxfrm()> explicitly
and using a non locale-affected comparison, the example attempts to save
a couple of transformations.  But in fact, it doesn't save anything: Perl
magic (see L<perlguts/Magic Variables>) creates the transformed version of a
string the first time it's needed in a comparison, then keeps this version around
in case it's needed again.  An example rewritten the easy way with
C<cmp> runs just about as fast.  It also copes with null characters
embedded in strings; if you call C<strxfrm()> directly, it treats the first
null it finds as a terminator.  Don't expect the transformed strings
it produces to be portable across systems--or even from one revision
of your operating system to the next.  In short, don't call C<strxfrm()>
directly: let Perl do it for you.

Note: C<use locale> isn't shown in some of these examples because it isn't
needed: C<strcoll()> and C<strxfrm()> are POSIX:: functions
which use the standard system-supplied C<libc> functions that
always obey the current C<LC_COLLATE> locale.

=head2 Category C<LC_CTYPE>: Character Types

In the scope of a S<C<use locale>> form that includes C<LC_CTYPE>, Perl
obeys the C<LC_CTYPE> locale
setting.  This controls the application's notion of which characters are
alphabetic, numeric, punctuation, I<etc>.  This affects Perl's C<\w>
regular expression metanotation,
which stands for alphanumeric characters--that is, alphabetic,
numeric, and the platform's native underscore.
(Consult L<perlre> for more information about
regular expressions.)  Thanks to C<LC_CTYPE>, depending on your locale
setting, characters like "E<aelig>", "E<eth>", "E<szlig>", and
"E<oslash>" may be understood as C<\w> characters.
It also affects things like C<\s>, C<\D>, and the POSIX character
classes, like C<[[:graph:]]>.  (See L<perlrecharclass> for more
information on all these.)

The C<LC_CTYPE> locale also provides the map used in transliterating
characters between lower and uppercase.  This affects the case-mapping
functions--C<fc()>, C<lc()>, C<lcfirst()>, C<uc()>, and C<ucfirst()>;
case-mapping
interpolation with C<\F>, C<\l>, C<\L>, C<\u>, or C<\U> in double-quoted
strings and C<s///> substitutions; and case-insensitive regular expression
pattern matching using the C<i> modifier.

Starting in v5.20, Perl supports UTF-8 locales for C<LC_CTYPE>, but
otherwise Perl only supports single-byte locales, such as the ISO 8859
series.  This means that wide character locales, for example for Asian
languages, are not well-supported.  Use of these locales may cause core
dumps.  If the platform has the capability for Perl to detect such a
locale, starting in Perl v5.22, L<Perl will warn, default
enabled|warnings/Category Hierarchy>, using the C<locale> warning
category, whenever such a locale is switched into.  The UTF-8 locale
support is actually a
superset of POSIX locales, because it is really full Unicode behavior
as if no C<LC_CTYPE> locale were in effect at all (except for tainting;
see L</SECURITY>).  POSIX locales, even UTF-8 ones,
are lacking certain concepts in Unicode, such as the idea that changing
the case of a character could expand to be more than one character.
Perl in a UTF-8 locale, will give you that expansion.  Prior to v5.20,
Perl treated a UTF-8 locale on some platforms like an ISO 8859-1 one,
with some restrictions, and on other platforms more like the "C" locale.
For releases v5.16 and v5.18, C<S<use locale 'not_characters>> could be
used as a workaround for this (see L</Unicode and UTF-8>).

Note that there are quite a few things that are unaffected by the
current locale.  Any literal character is the native character for the
given platform.  Hence 'A' means the character at code point 65 on ASCII
platforms, and 193 on EBCDIC.  That may or may not be an 'A' in the
current locale, if that locale even has an 'A'.
Similarly, all the escape sequences for particular characters,
C<\n> for example, always mean the platform's native one.  This means,
for example, that C<\N> in regular expressions (every character
but new-line) works on the platform character set.

Starting in v5.22, Perl will by default warn when switching into a
locale that redefines any ASCII printable character (plus C<\t> and
C<\n>) into a different class than expected.  This is likely to
happen on modern locales only on EBCDIC platforms, where, for example,
a CCSID 0037 locale on a CCSID 1047 machine moves C<"[">, but it can
happen on ASCII platforms with the ISO 646 and other
7-bit locales that are essentially obsolete.  Things may still work,
depending on what features of Perl are used by the program.  For
example, in the example from above where C<"|"> becomes a C<\w>, and
there are no regular expressions where this matters, the program may
still work properly.  The warning lists all the characters that
it can determine could be adversely affected.

B<Note:> A broken or malicious C<LC_CTYPE> locale definition may result
in clearly ineligible characters being considered to be alphanumeric by
your application.  For strict matching of (mundane) ASCII letters and
digits--for example, in command strings--locale-aware applications
should use C<\w> with the C</a> regular expression modifier.  See L</"SECURITY">.

=head2 Category C<LC_NUMERIC>: Numeric Formatting

After a proper C<POSIX::setlocale()> call, and within the scope
of a C<use locale> form that includes numerics, Perl obeys the
C<LC_NUMERIC> locale information, which controls an application's idea
of how numbers should be formatted for human readability.
In most implementations the only effect is to
change the character used for the decimal point--perhaps from "."  to ",".
The functions aren't aware of such niceties as thousands separation and
so on. (See L</The localeconv function> if you care about these things.)

 use POSIX qw(strtod setlocale LC_NUMERIC);
 use locale;

 setlocale LC_NUMERIC, "";

 $n = 5/2;   # Assign numeric 2.5 to $n

 $x = " $n"; # Locale-dependent conversion to string

 print "half five is $n\n";       # Locale-dependent output

 printf "half five is %g\n", $n;  # Locale-dependent output

 print "DECIMAL POINT IS COMMA\n"
          if $n == (strtod("2,5"))[0]; # Locale-dependent conversion

See also L<I18N::Langinfo> and C<RADIXCHAR>.

=head2 Category C<LC_MONETARY>: Formatting of monetary amounts

The C standard defines the C<LC_MONETARY> category, but not a function
that is affected by its contents.  (Those with experience of standards
committees will recognize that the working group decided to punt on the
issue.  POSIX 2001 added the C<strfmon()> function to format currency
amounts, but there is no official function to parse strings representing
currency values.)

Perl essentially takes no notice of this category.  On POSIX systems, you
can call C<strfmon()> from XS code to create formatted strings, and/or you
you can query the C<LC_MONETARY> locale-specific values with
L</The localeconv function> and use the information that it returns in your
application's own formatting of currency amounts.  However, you may well
find that the information, voluminous and complex though it may be, still
does not quite meet your requirements: currency formatting is a hard nut
to crack.

See also C<CRNCYSTR> in L<I18N::Langinfo>.

=head2 Category C<LC_TIME>: Respresentation of time

Output produced by C<POSIX::strftime()>, which builds a formatted
human-readable date/time string, is affected by the current C<LC_TIME>
locale.  Thus, in a French locale, the output produced by the C<%B>
format element (full month name) for the first month of the year would
be "janvier".  Here's how to get a list of long month names in the
current locale:

        use POSIX qw(strftime);
        for (0..11) {
            $long_month_name[$_] =
                strftime("%B", 0, 0, 0, 1, $_, 96);
        }

Note: C<use locale> isn't needed in this example: C<strftime()> is a POSIX::
function which uses the standard system-supplied C<libc> function that
always obeys the current C<LC_TIME> locale.

See also L<I18N::Langinfo> and C<ABDAY_1>..C<ABDAY_7>, C<DAY_1>..C<DAY_7>,
C<ABMON_1>..C<ABMON_12>, and C<ABMON_1>..C<ABMON_12>.

There is also the libc C<strptime()> function defined starting in POSIX
2001 (it's not in Windows) that parses formatted time strings.  There is
currently no pure perl access to this function, so you need to write XS
code to use it.

=head2 Category C<LC_MESSAGES>: System messages

This category is used by perl to create a string describing a system
error number, such as what you would get by saying
L<C<"$!">|perlvar/$ERRNO> or L<C<"$^E">|perlvar/$EXTENDED_OS_ERROR>.
On some systems and locales, the string will be in the language of the
locale given by C<LC_MESSAGES>.  But not many systems have bothered to
install such translations for all locales available on the system.  If
no translation is available for a given locale, the string will be in
English.  See L<Errno> for information about portably using error codes.

The other categories mentioned so far are required to exist in any
platform on which Perl can run.  But this category is a POSIX extension,
and Perl runs on platforms, Windows, for example, that don't have it.  On
such platforms the underlying language for the system errors will be
whatever C<LC_CTYPE> gives, or English.

This category in conjunction with L<I18N::Langinfo> can be used to
output yes/no in its locale's language, and to parse strings that
contain "yes" or "no" in that language.

=head2 Other categories

Some platforms have additional categories.  These are not used by Perl
itself.  L<I18N::Langinfo> may be used to query them, yielding stub
values on platforms where they don't exist.  But again note that things
Perl interacts with may use these, including extensions outside the
standard Perl distribution, and by the operating system and its
utilities.

=head1 SECURITY

Although the main discussion of Perl security issues can be found in
L<perlsec>, a discussion of Perl's locale handling would be incomplete
if it did not draw your attention to locale-dependent security issues.
Locales--particularly on systems that allow unprivileged users to
build their own locales--are untrustworthy.  A malicious (or just plain
broken) locale can make a locale-aware application give unexpected
results.  Here are a few possibilities:

=over 4

=item *

Regular expression checks for safe file names or mail addresses using
C<\w> may be spoofed by an C<LC_CTYPE> locale that claims that
characters such as C<"E<gt>"> and C<"|"> are alphanumeric.

=item *

String interpolation with case-mapping, as in, say, C<$dest =
"C:\U$name.$ext">, may produce dangerous results if a bogus C<LC_CTYPE>
case-mapping table is in effect.

=item *

A sneaky C<LC_COLLATE> locale could result in the names of students with
"D" grades appearing ahead of those with "A"s.

=item *

An application that takes the trouble to use information in
C<LC_MONETARY> may format debits as if they were credits and vice versa
if that locale has been subverted.  Or it might make payments in US
dollars instead of Hong Kong dollars.

=item *

The date and day names in dates formatted by C<strftime()> could be
manipulated to advantage by a malicious user able to subvert the
C<LC_TIME> locale.  ("Look--it says I wasn't in the building on
Sunday.")

=back

Such dangers are not peculiar to the locale system: any aspect of an
application's environment which may be modified maliciously presents
similar challenges.  Similarly, they are not specific to Perl: any
programming language that allows you to write programs that take
account of their environment exposes you to these issues.

Perl cannot protect you from all possibilities shown in the
examples--there is no substitute for your own vigilance--but, when
C<use locale> is in effect, Perl uses the tainting mechanism (see
L<perlsec>) to mark string results that become locale-dependent, and
which may be untrustworthy in consequence.

