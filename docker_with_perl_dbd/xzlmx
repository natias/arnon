
=head2 Advanced Topics

=over 4

=item *

String Equivalence

The question of string equivalence turns somewhat complicated
in Unicode: what do you mean by "equal"?

(Is C<LATIN CAPITAL LETTER A WITH ACUTE> equal to
C<LATIN CAPITAL LETTER A>?)

The short answer is that by default Perl compares equivalence (C<eq>,
C<ne>) based only on code points of the characters.  In the above
case, the answer is no (because 0x00C1 != 0x0041).  But sometimes, any
CAPITAL LETTER A's should be considered equal, or even A's of any case.

The long answer is that you need to consider character normalization
and casing issues: see L<Unicode::Normalize>, Unicode Technical Report #15,
L<Unicode Normalization Forms|https://www.unicode.org/reports/tr15> and
sections on case mapping in the L<Unicode Standard|https://www.unicode.org>.

As of Perl 5.8.0, the "Full" case-folding of I<Case
Mappings/SpecialCasing> is implemented, but bugs remain in C<qr//i> with them,
mostly fixed by 5.14, and essentially entirely by 5.18.

=item *

String Collation

People like to see their strings nicely sorted--or as Unicode
parlance goes, collated.  But again, what do you mean by collate?

(Does C<LATIN CAPITAL LETTER A WITH ACUTE> come before or after
C<LATIN CAPITAL LETTER A WITH GRAVE>?)

The short answer is that by default, Perl compares strings (C<lt>,
C<le>, C<cmp>, C<ge>, C<gt>) based only on the code points of the
characters.  In the above case, the answer is "after", since
C<0x00C1> > C<0x00C0>.

The long answer is that "it depends", and a good answer cannot be
given without knowing (at the very least) the language context.
See L<Unicode::Collate>, and I<Unicode Collation Algorithm>
L<https://www.unicode.org/reports/tr10/>

=back

=head2 Miscellaneous

=over 4

=item *

Character Ranges and Classes

Character ranges in regular expression bracketed character classes ( e.g.,
C</[a-z]/>) and in the C<tr///> (also known as C<y///>) operator are not
magically Unicode-aware.  What this means is that C<[A-Za-z]> will not
magically start to mean "all alphabetic letters" (not that it does mean that
even for 8-bit characters; for those, if you are using locales (L<perllocale>),
use C</[[:alpha:]]/>; and if not, use the 8-bit-aware property C<\p{alpha}>).

All the properties that begin with C<\p> (and its inverse C<\P>) are actually
character classes that are Unicode-aware.  There are dozens of them, see
L<perluniprops>.

Starting in v5.22, you can use Unicode code points as the end points of
regular expression pattern character ranges, and the range will include
all Unicode code points that lie between those end points, inclusive.

 qr/ [ \N{U+03} - \N{U+20} ] /xx

includes the code points
C<\N{U+03}>, C<\N{U+04}>, ..., C<\N{U+20}>.

This also works for ranges in C<tr///> starting in Perl v5.24.

=item *

String-To-Number Conversions

Unicode does define several other decimal--and numeric--characters
besides the familiar 0 to 9, such as the Arabic and Indic digits.
Perl does not support string-to-number conversion for digits other
than ASCII C<0> to C<9> (and ASCII C<a> to C<f> for hexadecimal).
To get safe conversions from any Unicode string, use
L<Unicode::UCD/num()>.

=back

=head2 Questions With Answers

=over 4

=item *

Will My Old Scripts Break?

Very probably not.  Unless you are generating Unicode characters
somehow, old behaviour should be preserved.  About the only behaviour
that has changed and which could start generating Unicode is the old
behaviour of C<chr()> where supplying an argument more than 255
produced a character modulo 255.  C<chr(300)>, for example, was equal
to C<chr(45)> or "-" (in ASCII), now it is LATIN CAPITAL LETTER I WITH
BREVE.

=item *

How Do I Make My Scripts Work With Unicode?

Very little work should be needed since nothing changes until you
generate Unicode data.  The most important thing is getting input as
Unicode; for that, see the earlier I/O discussion.
To get full seamless Unicode support, add
C<use feature 'unicode_strings'> (or C<use v5.12> or higher) to your
script.

=item *

How Do I Know Whether My String Is In Unicode?

You shouldn't have to care.  But you may if your Perl is before 5.14.0
or you haven't specified C<use feature 'unicode_strings'> or C<use
5.012> (or higher) because otherwise the rules for the code points
in the range 128 to 255 are different depending on
whether the string they are contained within is in Unicode or not.
(See L<perlunicode/When Unicode Does Not Happen>.)

To determine if a string is in Unicode, use:

    print utf8::is_utf8($string) ? 1 : 0, "\n";

But note that this doesn't mean that any of the characters in the
string are necessary UTF-8 encoded, or that any of the characters have
code points greater than 0xFF (255) or even 0x80 (128), or that the
string has any characters at all.  All the C<is_utf8()> does is to
return the value of the internal "utf8ness" flag attached to the
C<$string>.  If the flag is off, the bytes in the scalar are interpreted
as a single byte encoding.  If the flag is on, the bytes in the scalar
are interpreted as the (variable-length, potentially multi-byte) UTF-8 encoded
code points of the characters.  Bytes added to a UTF-8 encoded string are
automatically upgraded to UTF-8.  If mixed non-UTF-8 and UTF-8 scalars
are merged (double-quoted interpolation, explicit concatenation, or
printf/sprintf parameter substitution), the result will be UTF-8 encoded
as if copies of the byte strings were upgraded to UTF-8: for example,

    $x = "ab\x80c";
    $y = "\x{100}";
    print "$x = $y\n";

the output string will be UTF-8-encoded C<ab\x80c = \x{100}\n>, but
C<$x> will stay byte-encoded.

Sometimes you might really need to know the byte length of a string
instead of the character length. For that use the C<bytes> pragma
and the C<length()> function:

    my $unicode = chr(0x100);
    print length($unicode), "\n"; # will print 1
    use bytes;
    print length($unicode), "\n"; # will print 2
                                  # (the 0xC4 0x80 of the UTF-8)
    no bytes;

=item *

How Do I Find Out What Encoding a File Has?

You might try L<Encode::Guess>, but it has a number of limitations.

=item *

How Do I Detect Data That's Not Valid In a Particular Encoding?

Use the C<Encode> package to try converting it.
For example,

    use Encode 'decode';

    if (eval { decode('UTF-8', $string, Encode::FB_CROAK); 1 }) {
        # $string is valid UTF-8
    } else {
        # $string is not valid UTF-8
    }

Or use C<unpack> to try decoding it:

    use warnings;
    @chars = unpack("C0U*", $string_of_bytes_that_I_think_is_utf8);

If invalid, a C<Malformed UTF-8 character> warning is produced. The "C0" means
"process the string character per character".  Without that, the
C<unpack("U*", ...)> would work in C<U0> mode (the default if the format
string starts with C<U>) and it would return the bytes making up the UTF-8
encoding of the target string, something that will always work.

=item *

How Do I Convert Binary Data Into a Particular Encoding, Or Vice Versa?

This probably isn't as useful as you might think.
Normally, you shouldn't need to.

In one sense, what you are asking doesn't make much sense: encodings
are for characters, and binary data are not "characters", so converting
"data" into some encoding isn't meaningful unless you know in what
character set and encoding the binary data is in, in which case it's
not just binary data, now is it?

If you have a raw sequence of bytes that you know should be
interpreted via a particular encoding, you can use C<Encode>:

    use Encode 'from_to';
    from_to($data, "iso-8859-1", "UTF-8"); # from latin-1 to UTF-8

The call to C<from_to()> changes the bytes in C<$data>, but nothing
material about the nature of the string has changed as far as Perl is
concerned.  Both before and after the call, the string C<$data>
contains just a bunch of 8-bit bytes. As far as Perl is concerned,
the encoding of the string remains as "system-native 8-bit bytes".

You might relate this to a fictional 'Translate' module:

   use Translate;
   my $phrase = "Yes";
   Translate::from_to($phrase, 'english', 'deutsch');
   ## phrase now contains "Ja"

The contents of the string changes, but not the nature of the string.
Perl doesn't know any more after the call than before that the
contents of the string indicates the affirmative.

Back to converting data.  If you have (or want) data in your system's
native 8-bit encoding (e.g. Latin-1, EBCDIC, etc.), you can use
pack/unpack to convert to/from Unicode.

    $native_string  = pack("W*", unpack("U*", $Unicode_string));
    $Unicode_string = pack("U*", unpack("W*", $native_string));

If you have a sequence of bytes you B<know> is valid UTF-8,
but Perl doesn't know it yet, you can make Perl a believer, too:

    $Unicode = $bytes;
    utf8::decode($Unicode);

or:

    $Unicode = pack("U0a*", $bytes);

You can find the bytes that make up a UTF-8 sequence with

    @bytes = unpack("C*", $Unicode_string)

and you can create well-formed Unicode with

    $Unicode_string = pack("U*", 0xff, ...)

=item *

How Do I Display Unicode?  How Do I Input Unicode?

See L<http://www.alanwood.net/unicode/> and
L<http://www.cl.cam.ac.uk/~mgk25/unicode.html>

=item *

How Does Unicode Work With Traditional Locales?

If your locale is a UTF-8 locale, starting in Perl v5.26, Perl works
well for all categories; before this, starting with Perl v5.20, it works
for all categories but C<LC_COLLATE>, which deals with
sorting and the C<cmp> operator.  But note that the standard
C<L<Unicode::Collate>> and C<L<Unicode::Collate::Locale>> modules offer
much more powerful solutions to collation issues, and work on earlier
releases.

For other locales, starting in Perl 5.16, you can specify

    use locale ':not_characters';

to get Perl to work well with them.  The catch is that you
have to translate from the locale character set to/from Unicode
yourself.  See L</Unicode IE<sol>O> above for how to

    use open ':locale';

to accomplish this, but full details are in L<perllocale/Unicode and
UTF-8>, including gotchas that happen if you don't specify
C<:not_characters>.

=back

=head2 Hexadecimal Notation

The Unicode standard prefers using hexadecimal notation because
that more clearly shows the division of Unicode into blocks of 256 characters.
Hexadecimal is also simply shorter than decimal.  You can use decimal
notation, too, but learning to use hexadecimal just makes life easier
with the Unicode standard.  The C<U+HHHH> notation uses hexadecimal,
for example.

The C<0x> prefix means a hexadecimal number, the digits are 0-9 I<and>
a-f (or A-F, case doesn't matter).  Each hexadecimal digit represents
four bits, or half a byte.  C<print 0x..., "\n"> will show a
hexadecimal number in decimal, and C<printf "%x\n", $decimal> will
show a decimal number in hexadecimal.  If you have just the
"hex digits" of a hexadecimal number, you can use the C<hex()> function.

    print 0x0009, "\n";    # 9
    print 0x000a, "\n";    # 10
    print 0x000f, "\n";    # 15
    print 0x0010, "\n";    # 16
    print 0x0011, "\n";    # 17
    print 0x0100, "\n";    # 256

    print 0x0041, "\n";    # 65

    printf "%x\n",  65;    # 41
    printf "%#x\n", 65;    # 0x41

    print hex("41"), "\n"; # 65

=head2 Further Resources

=over 4

=item *

Unicode Consortium

L<https://www.unicode.org/>

=item *

Unicode FAQ

L<https://www.unicode.org/faq/>

=item *

Unicode Glossary

L<https://www.unicode.org/glossary/>

=item *

Unicode Recommended Reading List

The Unicode Consortium has a list of articles and books, some of which
give a much more in depth treatment of Unicode:
L<http://unicode.org/resources/readinglist.html>

=item *

Unicode Useful Resources

L<https://www.unicode.org/unicode/onlinedat/resources.html>

=item *

Unicode and Multilingual Support in HTML, Fonts, Web Browsers and Other Applications

L<http://www.alanwood.net/unicode/>

=item *

UTF-8 and Unicode FAQ for Unix/Linux

L<http://www.cl.cam.ac.uk/~mgk25/unicode.html>

=item *

Legacy Character Sets

L<http://www.czyborra.com/>
L<http://www.eki.ee/letter/>

=item *

You can explore various information from the Unicode data files using
the C<Unicode::UCD> module.

=back

=head1 UNICODE IN OLDER PERLS

If you cannot upgrade your Perl to 5.8.0 or later, you can still
do some Unicode processing by using the modules C<Unicode::String>,
C<Unicode::Map8>, and C<Unicode::Map>, available from CPAN.
If you have the GNU recode installed, you can also use the
Perl front-end C<Convert::Recode> for character conversions.

The following are fast conversions from ISO 8859-1 (Latin-1) bytes
to UTF-8 bytes and back, the code works even with older Perl 5 versions.

    # ISO 8859-1 to UTF-8
    s/([\x80-\xFF])/chr(0xC0|ord($1)>>6).chr(0x80|ord($1)&0x3F)/eg;

    # UTF-8 to ISO 8859-1
    s/([\xC2\xC3])([\x80-\xBF])/chr(ord($1)<<6&0xC0|ord($2)&0x3F)/eg;

=head1 SEE ALSO

L<perlunitut>, L<perlunicode>, L<Encode>, L<open>, L<utf8>, L<bytes>,
L<perlretut>, L<perlrun>, L<Unicode::Collate>, L<Unicode::Normalize>,
L<Unicode::UCD>

=head1 ACKNOWLEDGMENTS

Thanks to the kind readers of the perl5-porters@perl.org,
perl-unicode@perl.org, linux-utf8@nl.linux.org, and unicore@unicode.org
mailing lists for their valuable feedback.

=head1 AUTHOR, COPYRIGHT, AND LICENSE

Copyright 2001-2011 Jarkko Hietaniemi E<lt>jhi@iki.fiE<gt>.
Now maintained by Perl 5 Porters.

This document may be distributed under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                               usr/local/lib/perl5/5.40.0/pod/perluniprops.pod                                                     0000644 0000000 0000000 00001567372 14714567415 017563  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =begin comment

# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
# This file is machine-generated by lib/unicore/mktables from the Unicode
# database, Version 15.0.0.  Any changes made here will be lost!


To change this file, edit lib/unicore/mktables instead.

=end comment

=head1 NAME

perluniprops - Index of Unicode Version 15.0.0 character properties in Perl

=head1 DESCRIPTION

This document provides information about the portion of the Unicode database
that deals with character properties, that is the portion that is defined on
single code points.  (L</Other information in the Unicode data base>
below briefly mentions other data that Unicode provides.)

Perl can provide access to all non-provisional Unicode character properties,
though not all are enabled by default.  The omitted ones are the Unihan
properties and certain
deprecated or Unicode-internal properties.  (An installation may choose to
recompile Perl's tables to change this.  See L</Unicode character
properties that are NOT accepted by Perl>.)

For most purposes, access to Unicode properties from the Perl core is through
regular expression matches, as described in the next section.
For some special purposes, and to access the properties that are not suitable
for regular expression matching, all the Unicode character properties that
Perl handles are accessible via the standard L<Unicode::UCD> module, as
described in the section L</Properties accessible through Unicode::UCD>.

Perl also provides some additional extensions and short-cut synonyms
for Unicode properties.

This document merely lists all available properties and does not attempt to
explain what each property really means.  There is a brief description of each
Perl extension; see L<perlunicode/Other Properties> for more information on
these.  There is some detail about Blocks, Scripts, General_Category,
and Bidi_Class in L<perlunicode>, but to find out about the intricacies of the
official Unicode properties, refer to the Unicode standard.  A good starting
place is L<http://www.unicode.org/reports/tr44/>.

Note that you can define your own properties; see
L<perlunicode/"User-Defined Character Properties">.

=head1 Properties accessible through C<\p{}> and C<\P{}>

The Perl regular expression C<\p{}> and C<\P{}> constructs give access to
most of the Unicode character properties.  The table below shows all these
constructs, both single and compound forms.

B<Compound forms> consist of two components, separated by an equals sign or a
colon.  The first component is the property name, and the second component is
the particular value of the property to match against, for example,
C<\p{Script_Extensions: Greek}> and C<\p{Script_Extensions=Greek}> both mean
to match characters whose Script_Extensions property value is Greek.
(C<Script_Extensions> is an improved version of the C<Script> property.)

B<Single forms>, like C<\p{Greek}>, are mostly Perl-defined shortcuts for
their equivalent compound forms.  The table shows these equivalences.  (In our
example, C<\p{Greek}> is a just a shortcut for
C<\p{Script_Extensions=Greek}>).  There are also a few Perl-defined single
forms that are not shortcuts for a compound form.  One such is C<\p{Word}>.
These are also listed in the table.

In parsing these constructs, Perl always ignores Upper/lower case differences
everywhere within the {braces}.  Thus C<\p{Greek}> means the same thing as
C<\p{greek}>.  But note that changing the case of the C<"p"> or C<"P"> before
the left brace completely changes the meaning of the construct, from "match"
(for C<\p{}>) to "doesn't match" (for C<\P{}>).  Casing in this document is
for improved legibility.

Also, white space, hyphens, and underscores are normally ignored
everywhere between the {braces}, and hence can be freely added or removed
even if the C</x> modifier hasn't been specified on the regular expression.
But in the table below a 'B<T>' at the beginning of an entry
means that tighter (stricter) rules are used for that entry:

=over 4

=over 4

=item Single form (C<\p{name}>) tighter rules:

White space, hyphens, and underscores ARE significant
except for:

=over 4

=item * white space adjacent to a non-word character

=item * underscores separating digits in numbers

=back

That means, for example, that you can freely add or remove white space
adjacent to (but within) the braces without affecting the meaning.

=item Compound form (C<\p{name=value}> or C<\p{name:value}>) tighter rules:

The tighter rules given above for the single form apply to everything to the
right of the colon or equals; the looser rules still apply to everything to
the left.

That means, for example, that you can freely add or remove white space
adjacent to (but within) the braces and the colon or equal sign.

=back

=back

Some properties are considered obsolete by Unicode, but still available.
There are several varieties of obsolescence:

=over 4

=over 4

=item Stabilized

A property may be stabilized.  Such a determination does not indicate
that the property should or should not be used; instead it is a declaration
that the property will not be maintained nor extended for newly encoded
characters.  Such properties are marked with an 'B<S>' in the
table.

=item Deprecated

A property may be deprecated, perhaps because its original intent
has been replaced by another property, or because its specification was
somehow defective.  This means that its use is strongly
discouraged, so much so that a warning will be issued if used, unless the
regular expression is in the scope of a C<S<no warnings 'deprecated'>>
statement.  A 'B<D>' flags each such entry in the table, and
the entry there for the longest, most descriptive version of the property will
give the reason it is deprecated, and perhaps advice.  Perl may issue such a
warning, even for properties that aren't officially deprecated by Unicode,
when there used to be characters or code points that were matched by them, but
no longer.  This is to warn you that your program may not work like it did on
earlier Unicode releases.

A deprecated property may be made unavailable in a future Perl version, so it
is best to move away from them.

A deprecated property may also be stabilized, but this fact is not shown.

=item Obsolete

Properties marked with an 'B<O>' in the table are considered (plain)
obsolete.  Generally this designation is given to properties that Unicode once
used for internal purposes (but not any longer).

=item Discouraged

This is not actually a Unicode-specified obsolescence, but applies to certain
Perl extensions that are present for backwards compatibility, but are
discouraged from being used.  These are not obsolete, but their meanings are
not stable.  Future Unicode versions could force any of these extensions to be
removed without warning, replaced by another property with the same name that
means something different.  An 'B<X>' flags each such entry in the
table.  Use the equivalent shown instead.


In particular, matches in the Block property have single forms
defined by Perl that begin with C<"In_">, C<"Is_>, or even with no prefix at
all,  Like all B<DISCOURAGED> forms, these are not stable.  For example,
C<\p{Block=Deseret}> can currently be written as C<\p{In_Deseret}>,
C<\p{Is_Deseret}>, or C<\p{Deseret}>.  But, a new Unicode version may
come along that would force Perl to change the meaning of one or more of
these, and your program would no longer be correct.  Currently there are no
such conflicts with the form that begins C<"In_">, but there are many with the
other two shortcuts, and Unicode continues to define new properties that begin
with C<"In">, so it's quite possible that a conflict will occur in the future.
The compound form is guaranteed to not become obsolete, and its meaning is
clearer anyway.  See L<perlunicode/"Blocks"> for more information about this.

User-defined properties must begin with "In" or "Is".  These override any
Unicode property of the same name.


=back

=back

The table below has two columns.  The left column contains the C<\p{}>
constructs to look up, possibly preceded by the flags mentioned above; and
the right column contains information about them, like a description, or
synonyms.  The table shows both the single and compound forms for each
property that has them.  If the left column is a short name for a property,
the right column will give its longer, more descriptive name; and if the left
column is the longest name, the right column will show any equivalent shortest
name, in both single and compound forms if applicable.

If braces are not needed to specify a property (e.g., C<\pL>), the left
column contains both forms, with and without braces.

The right column will also caution you if a property means something different
than what might normally be expected.

All single forms are Perl extensions; a few compound forms are as well, and
are noted as such.

Numbers in (parentheses) indicate the total number of Unicode code points
matched by the property.  For the entries that give the longest, most
descriptive version of the property, the count is followed by a list of some
of the code points matched by it.  The list includes all the matched
characters in the 0-255 range, enclosed in the familiar [brackets] the same as
a regular expression bracketed character class.  Following that, the next few
higher matching ranges are also given.  To avoid visual ambiguity, the SPACE
character is represented as C<\x20>.

For emphasis, those properties that match no code points at all are listed as
well in a separate section following the table.

Most properties match the same code points regardless of whether C<"/i">
case-insensitive matching is specified or not.  But a few properties are
affected.  These are shown with the notation S<C<(/i= I<other_property>)>>
in the second column.  Under case-insensitive matching they match the
same code pode points as the property I<other_property>.

There is no description given for most non-Perl defined properties (See
L<http://www.unicode.org/reports/tr44/> for that).

For compactness, 'B<*>' is used as a wildcard instead of showing all possible
combinations.  For example, entries like:

 \p{Gc: *}                                  \p{General_Category: *}

mean that 'Gc' is a synonym for 'General_Category', and anything that is valid
for the latter is also valid for the former.  Similarly,

 \p{Is_*}                                   \p{*}

means that if and only if, for example, C<\p{Foo}> exists, then
C<\p{Is_Foo}> and C<\p{IsFoo}> are also valid and all mean the same thing.
And similarly, C<\p{Foo=Bar}> means the same as C<\p{Is_Foo=Bar}> and
C<\p{IsFoo=Bar}>.  "*" here is restricted to something not beginning with an
underscore.

Also, in binary properties, 'Yes', 'T', and 'True' are all synonyms for 'Y'.
And 'No', 'F', and 'False' are all synonyms for 'N'.  The table shows 'Y*' and
'N*' to indicate this, and doesn't have separate entries for the other
possibilities.  Note that not all properties which have values 'Yes' and 'No'
are binary, and they have all their values spelled out without using this wild
card, and a C<NOT> clause in their description that highlights their not being
binary.  These also require the compound form to match them, whereas true
binary properties have both single and compound forms available.

Note that all non-essential underscores are removed in the display of the
short names below.

B<Legend summary:>

=over 4

=item Z<>B<*> is a wild-card

=item B<(\d+)> in the info column gives the number of Unicode code points matched
by this property.

=item B<D> means this is deprecated.

=item B<O> means this is obsolete.

=item B<S> means this is stabilized.

=item B<T> means tighter (stricter) name matching applies.

=item B<X> means use of this form is discouraged, and may not be
stable.

=back

       NAME                           INFO

   \p{Adlam}               \p{Script_Extensions=Adlam} (Short:
                             \p{Adlm}; NOT \p{Block=Adlam}) (90)
   \p{Adlm}                \p{Adlam} (= \p{Script_Extensions=Adlam})
                             (NOT \p{Block=Adlam}) (90)
 X \p{Aegean_Numbers}      \p{Block=Aegean_Numbers} (64)
 T \p{Age: 1.1}            \p{Age=V1_1} (33_979)
   \p{Age: V1_1}           Code point's usage introduced in version
                             1.1 (33_979: U+0000..01F5, U+01FA..0217,
                             U+0250..02A8, U+02B0..02DE,
                             U+02E0..02E9, U+0300..0345 ...)
 T \p{Age: 2.0}            \p{Age=V2_0} (144_521)
   \p{Age: V2_0}           Code point's usage was introduced in
                             version 2.0; See also Property
                             'Present_In' (144_521: U+0591..05A1,
                             U+05A3..05AF, U+05C4, U+0F00..0F47,
                             U+0F49..0F69, U+0F71..0F8B ...)
 T \p{Age: 2.1}            \p{Age=V2_1} (2)
   \p{Age: V2_1}           Code point's usage was introduced in
                             version 2.1; See also Property
                             'Present_In' (2: U+20AC, U+FFFC)
 T \p{Age: 3.0}            \p{Age=V3_0} (10_307)
   \p{Age: V3_0}           Code point's usage was introduced in
                             version 3.0; See also Property
                             'Present_In' (10_307: U+01F6..01F9,
                             U+0218..021F, U+0222..0233,
                             U+02A9..02AD, U+02DF, U+02EA..02EE ...)
 T \p{Age: 3.1}            \p{Age=V3_1} (44_978)
   \p{Age: V3_1}           Code point's usage was introduced in
                             version 3.1; See also Property
                             'Present_In' (44_978: U+03F4..03F5,
                             U+FDD0..FDEF, U+10300..1031E,
                             U+10320..10323, U+10330..1034A,
                             U+10400..10425 ...)
 T \p{Age: 3.2}            \p{Age=V3_2} (1016)
   \p{Age: V3_2}           Code point's usage was introduced in
                             version 3.2; See also Property
                             'Present_In' (1016: U+0220, U+034F,
                             U+0363..036F, U+03D8..03D9, U+03F6,
                             U+048A..048B ...)
 T \p{Age: 4.0}            \p{Age=V4_0} (1226)
   \p{Age: V4_0}           Code point's usage was introduced in
                             version 4.0; See also Property
                             'Present_In' (1226: U+0221,
                             U+0234..0236, U+02AE..02AF,
                             U+02EF..02FF, U+0350..0357, U+035D..035F
                             ...)
 T \p{Age: 4.1}            \p{Age=V4_1} (1273)
   \p{Age: V4_1}           Code point's usage was introduced in
                             version 4.1; See also Property
                             'Present_In' (1273: U+0237..0241,
                             U+0358..035C, U+03FC..03FF,
                             U+04F6..04F7, U+05A2, U+05C5..05C7 ...)
 T \p{Age: 5.0}            \p{Age=V5_0} (1369)
   \p{Age: V5_0}           Code point's usage was introduced in
                             version 5.0; See also Property
                             'Present_In' (1369: U+0242..024F,
                             U+037B..037D, U+04CF, U+04FA..04FF,
                             U+0510..0513, U+05BA ...)
 T \p{Age: 5.1}            \p{Age=V5_1} (1624)
   \p{Age: V5_1}           Code point's usage was introduced in
                             version 5.1; See also Property
                             'Present_In' (1624: U+0370..0373,
                             U+0376..0377, U+03CF, U+0487,
                             U+0514..0523, U+0606..060A ...)
 T \p{Age: 5.2}            \p{Age=V5_2} (6648)
   \p{Age: V5_2}           Code point's usage was introduced in
                             version 5.2; See also Property
                             'Present_In' (6648: U+0524..0525,
                             U+0800..082D, U+0830..083E, U+0900,
                             U+094E, U+0955 ...)
 T \p{Age: 6.0}            \p{Age=V6_0} (2088)
   \p{Age: V6_0}           Code point's usage was introduced in
                             version 6.0; See also Property
                             'Present_In' (2088: U+0526..0527,
                             U+0620, U+065F, U+0840..085B, U+085E,
                             U+093A..093B ...)
 T \p{Age: 6.1}            \p{Age=V6_1} (732)
   \p{Age: V6_1}           Code point's usage was introduced in
                             version 6.1; See also Property
                             'Present_In' (732: U+058F, U+0604,
                             U+08A0, U+08A2..08AC, U+08E4..08FE,
                             U+0AF0 ...)
 T \p{Age: 6.2}            \p{Age=V6_2} (1)
   \p{Age: V6_2}           Code point's usage was introduced in
                             version 6.2; See also Property
                             'Present_In' (1: U+20BA)
 T \p{Age: 6.3}            \p{Age=V6_3} (5)
   \p{Age: V6_3}           Code point's usage was introduced in
                             version 6.3; See also Property
                             'Present_In' (5: U+061C, U+2066..2069)
 T \p{Age: 7.0}            \p{Age=V7_0} (2834)
   \p{Age: V7_0}           Code point's usage was introduced in
                             version 7.0; See also Property
                             'Present_In' (2834: U+037F,
                             U+0528..052F, U+058D..058E, U+0605,
                             U+08A1, U+08AD..08B2 ...)
 T \p{Age: 8.0}            \p{Age=V8_0} (7716)
   \p{Age: V8_0}           Code point's usage was introduced in
                             version 8.0; See also Property
                             'Present_In' (7716: U+08B3..08B4,
                             U+08E3, U+0AF9, U+0C5A, U+0D5F, U+13F5
                             ...)
 T \p{Age: 9.0}            \p{Age=V9_0} (7500)
   \p{Age: V9_0}           Code point's usage was introduced in
                             version 9.0; See also Property
                             'Present_In' (7500: U+08B6..08BD,
                             U+08D4..08E2, U+0C80, U+0D4F,
                             U+0D54..0D56, U+0D58..0D5E ...)
 T \p{Age: 10.0}           \p{Age=V10_0} (8518)
   \p{Age: V10_0}          Code point's usage was introduced in
                             version 10.0; See also Property
                             'Present_In' (8518: U+0860..086A,
                             U+09FC..09FD, U+0AFA..0AFF, U+0D00,
                             U+0D3B..0D3C, U+1CF7 ...)
 T \p{Age: 11.0}           \p{Age=V11_0} (684)
   \p{Age: V11_0}          Code point's usage was introduced in
                             version 11.0; See also Property
                             'Present_In' (684: U+0560, U+0588,
                             U+05EF, U+07FD..07FF, U+08D3, U+09FE ...)
 T \p{Age: 12.0}           \p{Age=V12_0} (554)
   \p{Age: V12_0}          Code point's usage was introduced in
                             version 12.0; See also Property
                             'Present_In' (554: U+0C77, U+0E86,
                             U+0E89, U+0E8C, U+0E8E..0E93, U+0E98 ...)
 T \p{Age: 12.1}           \p{Age=V12_1} (1)
   \p{Age: V12_1}          Code point's usage was introduced in
                             version 12.1; See also Property
                             'Present_In' (1: U+32FF)
 T \p{Age: 13.0}           \p{Age=V13_0} (5930)
   \p{Age: V13_0}          Code point's usage was introduced in
                             version 13.0; See also Property
                             'Present_In' (5930: U+08BE..08C7,
                             U+0B55, U+0D04, U+0D81, U+1ABF..1AC0,
                             U+2B97 ...)
 T \p{Age: 14.0}           \p{Age=V14_0} (838)
   \p{Age: V14_0}          Code point's usage was introduced in
                             version 14.0; See also Property
                             'Present_In' (838: U+061D, U+0870..088E,
                             U+0890..0891, U+0898..089F, U+08B5,
                             U+08C8..08D2 ...)
 T \p{Age: 15.0}           \p{Age=V15_0} (4489)
   \p{Age: V15_0}          Code point's usage was introduced in
                             version 15.0; See also Property
                             'Present_In' (4489: U+0CF3, U+0ECE,
                             U+10EFD..10EFF, U+1123F..11241,
                             U+11B00..11B09, U+11F00..11F10 ...)
   \p{Age: NA}             \p{Age=Unassigned} (825_279 plus all
                             above-Unicode code points)
   \p{Age: Unassigned}     Code point's usage has not been assigned
                             in any Unicode release thus far.
 (Short: \p{Age=NA}) (825_279 plus all above-Unicode code points:
                             U+0378..0379, U+0380..0383, U+038B,
                             U+038D, U+03A2, U+0530 ...)
   \p{Aghb}                \p{Caucasian_Albanian} (=
                             \p{Script_Extensions=
                             Caucasian_Albanian}) (NOT \p{Block=
                             Caucasian_Albanian}) (53)
   \p{AHex}                \p{PosixXDigit} (= \p{ASCII_Hex_Digit=Y})
                             (22)
   \p{AHex: *}             \p{ASCII_Hex_Digit: *}
   \p{Ahom}                \p{Script_Extensions=Ahom} (NOT \p{Block=
                             Ahom}) (65)
 X \p{Alchemical}          \p{Alchemical_Symbols} (= \p{Block=
                             Alchemical_Symbols}) (128)
 X \p{Alchemical_Symbols}  \p{Block=Alchemical_Symbols} (Short:
                             \p{InAlchemical}) (128)
   \p{All}                 All code points, including those above
                             Unicode.  Same as qr/./s (1_114_112 plus
                             all above-Unicode code points:
                             U+0000..infinity)
   \p{Alnum}               \p{XPosixAlnum} (138_445)
   \p{Alpha}               \p{XPosixAlpha} (= \p{Alphabetic=Y})
                             (137_765)
   \p{Alpha: *}            \p{Alphabetic: *}
   \p{Alphabetic}          \p{XPosixAlpha} (= \p{Alphabetic=Y})
                             (137_765)
   \p{Alphabetic: N*}      (Short: \p{Alpha=N}, \P{Alpha}) (976_347
                             plus all above-Unicode code points:
                             [\x00-\x20!\"#\$\%&\'\(\)*+,\-.\/0-9:;<=
                             >?\@\[\\\]\^_`\{\|\}~\x7f-\xa9\xab-\xb4
                             \xb6-\xb9\xbb-\xbf\xd7\xf7],
                             U+02C2..02C5, U+02D2..02DF,
                             U+02E5..02EB, U+02ED, U+02EF..0344 ...)
   \p{Alphabetic: Y*}      (Short: \p{Alpha=Y}, \p{Alpha}) (137_765:
                             [A-Za-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6
                             \xf8-\xff], U+0100..02C1, U+02C6..02D1,
                             U+02E0..02E4, U+02EC, U+02EE ...)
 X \p{Alphabetic_PF}       \p{Alphabetic_Presentation_Forms} (=
                             \p{Block=Alphabetic_Presentation_Forms})
                             (80)
 X \p{Alphabetic_Presentation_Forms} \p{Block=
                             Alphabetic_Presentation_Forms} (Short:
                             \p{InAlphabeticPF}) (80)
   \p{Anatolian_Hieroglyphs} \p{Script_Extensions=
                             Anatolian_Hieroglyphs} (Short: \p{Hluw};
                             NOT \p{Block=Anatolian_Hieroglyphs})
                             (583)
 X \p{Ancient_Greek_Music} \p{Ancient_Greek_Musical_Notation} (=
                             \p{Block=
                             Ancient_Greek_Musical_Notation}) (80)
 X \p{Ancient_Greek_Musical_Notation} \p{Block=
                             Ancient_Greek_Musical_Notation} (Short:
                             \p{InAncientGreekMusic}) (80)
 X \p{Ancient_Greek_Numbers} \p{Block=Ancient_Greek_Numbers} (80)
 X \p{Ancient_Symbols}     \p{Block=Ancient_Symbols} (64)
   \p{Any}                 All Unicode code points (1_114_112:
                             U+0000..10FFFF)
   \p{Arab}                \p{Arabic} (= \p{Script_Extensions=
                             Arabic}) (NOT \p{Block=Arabic}) (1414)
   \p{Arabic}              \p{Script_Extensions=Arabic} (Short:
                             \p{Arab}; NOT \p{Block=Arabic}) (1414)
 X \p{Arabic_Ext_A}        \p{Arabic_Extended_A} (= \p{Block=
                             Arabic_Extended_A}) (96)
 X \p{Arabic_Ext_B}        \p{Arabic_Extended_B} (= \p{Block=
                             Arabic_Extended_B}) (48)
 X \p{Arabic_Ext_C}        \p{Arabic_Extended_C} (= \p{Block=
                             Arabic_Extended_C}) (64)
 X \p{Arabic_Extended_A}   \p{Block=Arabic_Extended_A} (Short:
                             \p{InArabicExtA}) (96)
 X \p{Arabic_Extended_B}   \p{Block=Arabic_Extended_B} (Short:
                             \p{InArabicExtB}) (48)
 X \p{Arabic_Extended_C}   \p{Block=Arabic_Extended_C} (Short:
                             \p{InArabicExtC}) (64)
 X \p{Arabic_Math}         \p{Arabic_Mathematical_Alphabetic_Symbols}
                             (= \p{Block=
                             Arabic_Mathematical_Alphabetic_Symbols})
                             (256)
 X \p{Arabic_Mathematical_Alphabetic_Symbols} \p{Block=
                             Arabic_Mathematical_Alphabetic_Symbols}
                             (Short: \p{InArabicMath}) (256)
 X \p{Arabic_PF_A}         \p{Arabic_Presentation_Forms_A} (=
                             \p{Block=Arabic_Presentation_Forms_A})
                             (688)
 X \p{Arabic_PF_B}         \p{Arabic_Presentation_Forms_B} (=
                             \p{Block=Arabic_Presentation_Forms_B})
                             (144)
 X \p{Arabic_Presentation_Forms_A} \p{Block=
                             Arabic_Presentation_Forms_A} (Short:
                             \p{InArabicPFA}) (688)
 X \p{Arabic_Presentation_Forms_B} \p{Block=
                             Arabic_Presentation_Forms_B} (Short:
                             \p{InArabicPFB}) (144)
 X \p{Arabic_Sup}          \p{Arabic_Supplement} (= \p{Block=
                             Arabic_Supplement}) (48)
 X \p{Arabic_Supplement}   \p{Block=Arabic_Supplement} (Short:
                             \p{InArabicSup}) (48)
   \p{Armenian}            \p{Script_Extensions=Armenian} (Short:
                             \p{Armn}; NOT \p{Block=Armenian}) (96)
   \p{Armi}                \p{Imperial_Aramaic} (=
                             \p{Script_Extensions=Imperial_Aramaic})
                             (NOT \p{Block=Imperial_Aramaic}) (31)
   \p{Armn}                \p{Armenian} (= \p{Script_Extensions=
                             Armenian}) (NOT \p{Block=Armenian}) (96)
 X \p{Arrows}              \p{Block=Arrows} (112)
   \p{ASCII}               \p{Block=Basic_Latin} (128)
   \p{ASCII_Hex_Digit}     \p{PosixXDigit} (= \p{ASCII_Hex_Digit=Y})
                             (22)
   \p{ASCII_Hex_Digit: N*} (Short: \p{AHex=N}, \P{AHex}) (1_114_090
                             plus all above-Unicode code points:
                             [\x00-\x20!\"#\$\%&\'\(\)*+,\-.\/:;<=>?
                             \@G-Z\[\\\]\^_`g-z\{\|\}~\x7f-\xff],
                             U+0100..infinity)
   \p{ASCII_Hex_Digit: Y*} (Short: \p{AHex=Y}, \p{AHex}) (22: [0-9A-
                             Fa-f])
   \p{Assigned}            All assigned code points (288_767:
                             U+0000..0377, U+037A..037F,
                             U+0384..038A, U+038C, U+038E..03A1,
                             U+03A3..052F ...)
   \p{Avestan}             \p{Script_Extensions=Avestan} (Short:
                             \p{Avst}; NOT \p{Block=Avestan}) (61)
   \p{Avst}                \p{Avestan} (= \p{Script_Extensions=
                             Avestan}) (NOT \p{Block=Avestan}) (61)
   \p{Bali}                \p{Balinese} (= \p{Script_Extensions=
                             Balinese}) (NOT \p{Block=Balinese}) (124)
   \p{Balinese}            \p{Script_Extensions=Balinese} (Short:
                             \p{Bali}; NOT \p{Block=Balinese}) (124)
   \p{Bamu}                \p{Bamum} (= \p{Script_Extensions=Bamum})
                             (NOT \p{Block=Bamum}) (657)
   \p{Bamum}               \p{Script_Extensions=Bamum} (Short:
                             \p{Bamu}; NOT \p{Block=Bamum}) (657)
 X \p{Bamum_Sup}           \p{Bamum_Supplement} (= \p{Block=
                             Bamum_Supplement}) (576)
 X \p{Bamum_Supplement}    \p{Block=Bamum_Supplement} (Short:
                             \p{InBamumSup}) (576)
 X \p{Basic_Latin}         \p{ASCII} (= \p{Block=Basic_Latin}) (128)
   \p{Bass}                \p{Bassa_Vah} (= \p{Script_Extensions=
                             Bassa_Vah}) (NOT \p{Block=Bassa_Vah})
                             (36)
   \p{Bassa_Vah}           \p{Script_Extensions=Bassa_Vah} (Short:
                             \p{Bass}; NOT \p{Block=Bassa_Vah}) (36)
   \p{Batak}               \p{Script_Extensions=Batak} (Short:
                             \p{Batk}; NOT \p{Block=Batak}) (56)
   \p{Batk}                \p{Batak} (= \p{Script_Extensions=Batak})
                             (NOT \p{Block=Batak}) (56)
   \p{Bc: *}               \p{Bidi_Class: *}
   \p{Beng}                \p{Bengali} (= \p{Script_Extensions=
                             Bengali}) (NOT \p{Block=Bengali}) (113)
