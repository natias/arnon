#define isIDCONT_uvchr(c)                                                   \
                    generic_uvchr_(CC_WORDCHAR_, _is_uni_perl_idcont, c)
#define isIDFIRST_uvchr(c)                                                  \
                    generic_uvchr_(CC_IDFIRST_, _is_uni_perl_idstart, c)
#define isLOWER_uvchr(c)      generic_invlist_uvchr_(CC_LOWER_, c)
#define isPRINT_uvchr(c)      generic_invlist_uvchr_(CC_PRINT_, c)

#define isPUNCT_uvchr(c)      generic_invlist_uvchr_(CC_PUNCT_, c)
#define isSPACE_uvchr(c)      generic_uvchr_(CC_SPACE_, is_XPERLSPACE_cp_high, c)
#define isPSXSPC_uvchr(c)     isSPACE_uvchr(c)

#define isUPPER_uvchr(c)      generic_invlist_uvchr_(CC_UPPER_, c)
#define isVERTWS_uvchr(c)     generic_uvchr_(CC_VERTSPACE_, is_VERTWS_cp_high, c)
#define isWORDCHAR_uvchr(c)   generic_invlist_uvchr_(CC_WORDCHAR_, c)
#define isXDIGIT_uvchr(c)     generic_uvchr_(CC_XDIGIT_, is_XDIGIT_cp_high, c)

#define toFOLD_uvchr(c,s,l)	to_uni_fold(c,s,l)
#define toLOWER_uvchr(c,s,l)	to_uni_lower(c,s,l)
#define toTITLE_uvchr(c,s,l)	to_uni_title(c,s,l)
#define toUPPER_uvchr(c,s,l)	to_uni_upper(c,s,l)

/* For backwards compatibility, even though '_uni' should mean official Unicode
 * code points, in Perl it means native for those below 256 */
#define isALPHA_uni(c)          isALPHA_uvchr(c)
#define isALPHANUMERIC_uni(c)   isALPHANUMERIC_uvchr(c)
#define isASCII_uni(c)          isASCII_uvchr(c)
#define isBLANK_uni(c)          isBLANK_uvchr(c)
#define isCNTRL_uni(c)          isCNTRL_uvchr(c)
#define isDIGIT_uni(c)          isDIGIT_uvchr(c)
#define isGRAPH_uni(c)          isGRAPH_uvchr(c)
#define isIDCONT_uni(c)         isIDCONT_uvchr(c)
#define isIDFIRST_uni(c)        isIDFIRST_uvchr(c)
#define isLOWER_uni(c)          isLOWER_uvchr(c)
#define isPRINT_uni(c)          isPRINT_uvchr(c)
#define isPUNCT_uni(c)          isPUNCT_uvchr(c)
#define isSPACE_uni(c)          isSPACE_uvchr(c)
#define isPSXSPC_uni(c)         isPSXSPC_uvchr(c)
#define isUPPER_uni(c)          isUPPER_uvchr(c)
#define isVERTWS_uni(c)         isVERTWS_uvchr(c)
#define isWORDCHAR_uni(c)       isWORDCHAR_uvchr(c)
#define isXDIGIT_uni(c)         isXDIGIT_uvchr(c)
#define toFOLD_uni(c,s,l)       toFOLD_uvchr(c,s,l)
#define toLOWER_uni(c,s,l)      toLOWER_uvchr(c,s,l)
#define toTITLE_uni(c,s,l)      toTITLE_uvchr(c,s,l)
#define toUPPER_uni(c,s,l)      toUPPER_uvchr(c,s,l)

/* For internal core Perl use only: the base macros for defining macros like
 * isALPHA_LC_uvchr.  These are like isALPHA_LC, but the input can be any code
 * point, not just 0-255.  Like generic_uvchr_, there are two versions, one for
 * simple class definitions; the other for more complex.  These are like
 * generic_uvchr_, so see it for more info. */
#define generic_LC_uvchr_(latin1, above_latin1, c)                            \
                                    (c < 256 ? latin1(c) : above_latin1(c))
#define generic_LC_invlist_uvchr_(latin1, classnum, c)                        \
                            (c < 256 ? latin1(c) : _is_uni_FOO(classnum, c))

#define isALPHA_LC_uvchr(c)  generic_LC_invlist_uvchr_(isALPHA_LC, CC_ALPHA_, c)
#define isALPHANUMERIC_LC_uvchr(c)  generic_LC_invlist_uvchr_(isALPHANUMERIC_LC, \
                                                         CC_ALPHANUMERIC_, c)
#define isASCII_LC_uvchr(c)   isASCII_LC(c)
#define isBLANK_LC_uvchr(c)  generic_LC_uvchr_(isBLANK_LC,                    \
                                                        is_HORIZWS_cp_high, c)
#define isCNTRL_LC_uvchr(c)  (c < 256 ? isCNTRL_LC(c) : 0)
#define isDIGIT_LC_uvchr(c)  generic_LC_invlist_uvchr_(isDIGIT_LC, CC_DIGIT_, c)
#define isGRAPH_LC_uvchr(c)  generic_LC_invlist_uvchr_(isGRAPH_LC, CC_GRAPH_, c)
#define isIDCONT_LC_uvchr(c) generic_LC_uvchr_(isIDCONT_LC,                   \
                                                  _is_uni_perl_idcont, c)
#define isIDFIRST_LC_uvchr(c) generic_LC_uvchr_(isIDFIRST_LC,                 \
                                                  _is_uni_perl_idstart, c)
#define isLOWER_LC_uvchr(c)  generic_LC_invlist_uvchr_(isLOWER_LC, CC_LOWER_, c)
#define isPRINT_LC_uvchr(c)  generic_LC_invlist_uvchr_(isPRINT_LC, CC_PRINT_, c)
#define isPSXSPC_LC_uvchr(c)  isSPACE_LC_uvchr(c)
#define isPUNCT_LC_uvchr(c)  generic_LC_invlist_uvchr_(isPUNCT_LC, CC_PUNCT_, c)
#define isSPACE_LC_uvchr(c)  generic_LC_uvchr_(isSPACE_LC,                    \
                                                    is_XPERLSPACE_cp_high, c)
#define isUPPER_LC_uvchr(c)  generic_LC_invlist_uvchr_(isUPPER_LC, CC_UPPER_, c)
#define isWORDCHAR_LC_uvchr(c) generic_LC_invlist_uvchr_(isWORDCHAR_LC,       \
                                                           CC_WORDCHAR_, c)
#define isXDIGIT_LC_uvchr(c) generic_LC_uvchr_(isXDIGIT_LC,                   \
                                                       is_XDIGIT_cp_high, c)

#define isBLANK_LC_uni(c)    isBLANK_LC_uvchr(UNI_TO_NATIVE(c))

/* The "_safe" macros make sure that we don't attempt to read beyond 'e', but
 * they don't otherwise go out of their way to look for malformed UTF-8.  If
 * they can return accurate results without knowing if the input is otherwise
 * malformed, they do so.  For example isASCII is accurate in spite of any
 * non-length malformations because it looks only at a single byte. Likewise
 * isDIGIT looks just at the first byte for code points 0-255, as all UTF-8
 * variant ones return FALSE.  But, if the input has to be well-formed in order
 * for the results to be accurate, the macros will test and if malformed will
 * call a routine to die
 *
 * Except for toke.c, the macros do assume that e > p, asserting that on
 * DEBUGGING builds.  Much code that calls these depends on this being true,
 * for other reasons.  toke.c is treated specially as using the regular
 * assertion breaks it in many ways.  All strings that these operate on there
 * are supposed to have an extra NUL character at the end,  so that *e = \0. A
 * bunch of code in toke.c assumes that this is true, so the assertion allows
 * for that */
#ifdef PERL_IN_TOKE_C
#  define _utf8_safe_assert(p,e) ((e) > (p) || ((e) == (p) && *(p) == '\0'))
#else
#  define _utf8_safe_assert(p,e) ((e) > (p))
#endif

#define generic_utf8_safe_(classnum, p, e, above_latin1)                    \
    ((! _utf8_safe_assert(p, e))                                            \
      ? (_force_out_malformed_utf8_message((U8 *) (p), (U8 *) (e), 0, 1), 0)\
      : (UTF8_IS_INVARIANT(*(p)))                                           \
          ? generic_isCC_(*(p), classnum)                                   \
          : (UTF8_IS_DOWNGRADEABLE_START(*(p))                              \
             ? ((LIKELY((e) - (p) > 1 && UTF8_IS_CONTINUATION(*((p)+1))))   \
                ? generic_isCC_(EIGHT_BIT_UTF8_TO_NATIVE(*(p), *((p)+1 )),  \
                                classnum)                                   \
                : (_force_out_malformed_utf8_message(                       \
                                        (U8 *) (p), (U8 *) (e), 0, 1), 0))  \
             : above_latin1))
/* Like the above, but calls 'above_latin1(p)' to get the utf8 value.
 * 'above_latin1' can be a macro */
#define generic_func_utf8_safe_(classnum, above_latin1, p, e)               \
                    generic_utf8_safe_(classnum, p, e, above_latin1(p, e))
#define generic_non_invlist_utf8_safe_(classnum, above_latin1, p, e)        \
          generic_utf8_safe_(classnum, p, e,                                \
                             (UNLIKELY((e) - (p) < UTF8SKIP(p))             \
                              ? (_force_out_malformed_utf8_message(         \
                                      (U8 *) (p), (U8 *) (e), 0, 1), 0)     \
                              : above_latin1(p)))
/* Like the above, but passes classnum to _isFOO_utf8(), instead of having an
 * 'above_latin1' parameter */
#define generic_invlist_utf8_safe_(classnum, p, e)                          \
            generic_utf8_safe_(classnum, p, e, _is_utf8_FOO(classnum, p, e))

/* Like the above, but should be used only when it is known that there are no
 * characters in the upper-Latin1 range (128-255 on ASCII platforms) which the
 * class is TRUE for.  Hence it can skip the tests for this range.
 * 'above_latin1' should include its arguments */
#define generic_utf8_safe_no_upper_latin1_(classnum, p, e, above_latin1)    \
         (__ASSERT_(_utf8_safe_assert(p, e))                                \
         (isASCII(*(p)))                                                    \
          ? generic_isCC_(*(p), classnum)                                   \
          : (UTF8_IS_DOWNGRADEABLE_START(*(p)))                             \
             ? 0 /* Note that doesn't check validity for latin1 */          \
             : above_latin1)


#define isALPHA_utf8(p, e)         isALPHA_utf8_safe(p, e)
#define isALPHANUMERIC_utf8(p, e)  isALPHANUMERIC_utf8_safe(p, e)
#define isASCII_utf8(p, e)         isASCII_utf8_safe(p, e)
#define isBLANK_utf8(p, e)         isBLANK_utf8_safe(p, e)
#define isCNTRL_utf8(p, e)         isCNTRL_utf8_safe(p, e)
#define isDIGIT_utf8(p, e)         isDIGIT_utf8_safe(p, e)
#define isGRAPH_utf8(p, e)         isGRAPH_utf8_safe(p, e)
#define isIDCONT_utf8(p, e)        isIDCONT_utf8_safe(p, e)
#define isIDFIRST_utf8(p, e)       isIDFIRST_utf8_safe(p, e)
#define isLOWER_utf8(p, e)         isLOWER_utf8_safe(p, e)
#define isPRINT_utf8(p, e)         isPRINT_utf8_safe(p, e)
#define isPSXSPC_utf8(p, e)        isPSXSPC_utf8_safe(p, e)
#define isPUNCT_utf8(p, e)         isPUNCT_utf8_safe(p, e)
#define isSPACE_utf8(p, e)         isSPACE_utf8_safe(p, e)
#define isUPPER_utf8(p, e)         isUPPER_utf8_safe(p, e)
#define isVERTWS_utf8(p, e)        isVERTWS_utf8_safe(p, e)
#define isWORDCHAR_utf8(p, e)      isWORDCHAR_utf8_safe(p, e)
#define isXDIGIT_utf8(p, e)        isXDIGIT_utf8_safe(p, e)

#define isALPHA_utf8_safe(p, e)  generic_invlist_utf8_safe_(CC_ALPHA_, p, e)
#define isALPHANUMERIC_utf8_safe(p, e)                                      \
                        generic_invlist_utf8_safe_(CC_ALPHANUMERIC_, p, e)
#define isASCII_utf8_safe(p, e)                                             \
    /* Because ASCII is invariant under utf8, the non-utf8 macro            \
    * works */                                                              \
    (__ASSERT_(_utf8_safe_assert(p, e)) isASCII(*(p)))
#define isBLANK_utf8_safe(p, e)                                             \
        generic_non_invlist_utf8_safe_(CC_BLANK_, is_HORIZWS_high, p, e)

#ifdef EBCDIC
    /* Because all controls are UTF-8 invariants in EBCDIC, we can use this
     * more efficient macro instead of the more general one */
#   define isCNTRL_utf8_safe(p, e)                                          \
                    (__ASSERT_(_utf8_safe_assert(p, e)) isCNTRL_L1(*(p)))
#else
#   define isCNTRL_utf8_safe(p, e)  generic_utf8_safe_(CC_CNTRL_, p, e, 0)
#endif

#define isDIGIT_utf8_safe(p, e)                                             \
            generic_utf8_safe_no_upper_latin1_(CC_DIGIT_, p, e,             \
                                            _is_utf8_FOO(CC_DIGIT_, p, e))
#define isGRAPH_utf8_safe(p, e)    generic_invlist_utf8_safe_(CC_GRAPH_, p, e)
#define isIDCONT_utf8_safe(p, e)   generic_func_utf8_safe_(CC_WORDCHAR_,    \
                                                 _is_utf8_perl_idcont, p, e)

/* To prevent S_scan_word in toke.c from hanging, we have to make sure that
 * IDFIRST is an alnum.  See
 * https://github.com/Perl/perl5/issues/10275 for more detail than you
 * ever wanted to know about.  (In the ASCII range, there isn't a difference.)
 * This used to be not the XID version, but we decided to go with the more
 * modern Unicode definition */
#define isIDFIRST_utf8_safe(p, e)                                           \
    generic_func_utf8_safe_(CC_IDFIRST_,                                    \
                            _is_utf8_perl_idstart, (U8 *) (p), (U8 *) (e))

#define isLOWER_utf8_safe(p, e)     generic_invlist_utf8_safe_(CC_LOWER_, p, e)
#define isPRINT_utf8_safe(p, e)     generic_invlist_utf8_safe_(CC_PRINT_, p, e)
#define isPSXSPC_utf8_safe(p, e)     isSPACE_utf8_safe(p, e)
#define isPUNCT_utf8_safe(p, e)     generic_invlist_utf8_safe_(CC_PUNCT_, p, e)
#define isSPACE_utf8_safe(p, e)                                             \
    generic_non_invlist_utf8_safe_(CC_SPACE_, is_XPERLSPACE_high, p, e)
#define isUPPER_utf8_safe(p, e)  generic_invlist_utf8_safe_(CC_UPPER_, p, e)
#define isVERTWS_utf8_safe(p, e)                                            \
        generic_non_invlist_utf8_safe_(CC_VERTSPACE_, is_VERTWS_high, p, e)
#define isWORDCHAR_utf8_safe(p, e)                                          \
                             generic_invlist_utf8_safe_(CC_WORDCHAR_, p, e)
#define isXDIGIT_utf8_safe(p, e)                                            \
                   generic_utf8_safe_no_upper_latin1_(CC_XDIGIT_, p, e,     \
                             (UNLIKELY((e) - (p) < UTF8SKIP(p))             \
                              ? (_force_out_malformed_utf8_message(         \
                                      (U8 *) (p), (U8 *) (e), 0, 1), 0)     \
                              : is_XDIGIT_high(p)))

#define toFOLD_utf8(p,e,s,l)	toFOLD_utf8_safe(p,e,s,l)
#define toLOWER_utf8(p,e,s,l)	toLOWER_utf8_safe(p,e,s,l)
#define toTITLE_utf8(p,e,s,l)	toTITLE_utf8_safe(p,e,s,l)
#define toUPPER_utf8(p,e,s,l)	toUPPER_utf8_safe(p,e,s,l)

/* For internal core use only, subject to change */
#define _toFOLD_utf8_flags(p,e,s,l,f)  _to_utf8_fold_flags (p,e,s,l,f)
#define _toLOWER_utf8_flags(p,e,s,l,f) _to_utf8_lower_flags(p,e,s,l,f)
#define _toTITLE_utf8_flags(p,e,s,l,f) _to_utf8_title_flags(p,e,s,l,f)
#define _toUPPER_utf8_flags(p,e,s,l,f) _to_utf8_upper_flags(p,e,s,l,f)

#define toFOLD_utf8_safe(p,e,s,l)   _toFOLD_utf8_flags(p,e,s,l, FOLD_FLAGS_FULL)
#define toLOWER_utf8_safe(p,e,s,l)  _toLOWER_utf8_flags(p,e,s,l, 0)
#define toTITLE_utf8_safe(p,e,s,l)  _toTITLE_utf8_flags(p,e,s,l, 0)
#define toUPPER_utf8_safe(p,e,s,l)  _toUPPER_utf8_flags(p,e,s,l, 0)

#define isALPHA_LC_utf8(p, e)         isALPHA_LC_utf8_safe(p, e)
#define isALPHANUMERIC_LC_utf8(p, e)  isALPHANUMERIC_LC_utf8_safe(p, e)
#define isASCII_LC_utf8(p, e)         isASCII_LC_utf8_safe(p, e)
#define isBLANK_LC_utf8(p, e)         isBLANK_LC_utf8_safe(p, e)
#define isCNTRL_LC_utf8(p, e)         isCNTRL_LC_utf8_safe(p, e)
#define isDIGIT_LC_utf8(p, e)         isDIGIT_LC_utf8_safe(p, e)
#define isGRAPH_LC_utf8(p, e)         isGRAPH_LC_utf8_safe(p, e)
#define isIDCONT_LC_utf8(p, e)        isIDCONT_LC_utf8_safe(p, e)
#define isIDFIRST_LC_utf8(p, e)       isIDFIRST_LC_utf8_safe(p, e)
#define isLOWER_LC_utf8(p, e)         isLOWER_LC_utf8_safe(p, e)
#define isPRINT_LC_utf8(p, e)         isPRINT_LC_utf8_safe(p, e)
#define isPSXSPC_LC_utf8(p, e)        isPSXSPC_LC_utf8_safe(p, e)
#define isPUNCT_LC_utf8(p, e)         isPUNCT_LC_utf8_safe(p, e)
#define isSPACE_LC_utf8(p, e)         isSPACE_LC_utf8_safe(p, e)
#define isUPPER_LC_utf8(p, e)         isUPPER_LC_utf8_safe(p, e)
#define isWORDCHAR_LC_utf8(p, e)      isWORDCHAR_LC_utf8_safe(p, e)
#define isXDIGIT_LC_utf8(p, e)        isXDIGIT_LC_utf8_safe(p, e)

/* For internal core Perl use only: the base macros for defining macros like
 * isALPHA_LC_utf8_safe.  These are like generic_utf8_, but if the first code
 * point in 'p' is within the 0-255 range, it uses locale rules from the
 * passed-in 'macro' parameter */
#define generic_LC_utf8_safe_(macro, p, e, above_latin1)                    \
         (__ASSERT_(_utf8_safe_assert(p, e))                                \
         (UTF8_IS_INVARIANT(*(p)))                                          \
          ? macro(*(p))                                                     \
          : (UTF8_IS_DOWNGRADEABLE_START(*(p))                              \
             ? ((LIKELY((e) - (p) > 1 && UTF8_IS_CONTINUATION(*((p)+1))))   \
                ? macro(EIGHT_BIT_UTF8_TO_NATIVE(*(p), *((p)+1)))           \
                : (_force_out_malformed_utf8_message(                       \
                                        (U8 *) (p), (U8 *) (e), 0, 1), 0))  \
              : above_latin1))

#define generic_LC_invlist_utf8_safe_(macro, classnum, p, e)                  \
            generic_LC_utf8_safe_(macro, p, e,                              \
                                            _is_utf8_FOO(classnum, p, e))

#define generic_LC_func_utf8_safe_(macro, above_latin1, p, e)               \
            generic_LC_utf8_safe_(macro, p, e, above_latin1(p, e))

#define generic_LC_non_invlist_utf8_safe_(classnum, above_latin1, p, e)       \
          generic_LC_utf8_safe_(classnum, p, e,                             \
                             (UNLIKELY((e) - (p) < UTF8SKIP(p))             \
                              ? (_force_out_malformed_utf8_message(         \
                                      (U8 *) (p), (U8 *) (e), 0, 1), 0)     \
                              : above_latin1(p)))

#define isALPHANUMERIC_LC_utf8_safe(p, e)                                   \
            generic_LC_invlist_utf8_safe_(isALPHANUMERIC_LC,                \
                                        CC_ALPHANUMERIC_, p, e)
#define isALPHA_LC_utf8_safe(p, e)                                          \
            generic_LC_invlist_utf8_safe_(isALPHA_LC, CC_ALPHA_, p, e)
#define isASCII_LC_utf8_safe(p, e)                                          \
                    (__ASSERT_(_utf8_safe_assert(p, e)) isASCII_LC(*(p)))
#define isBLANK_LC_utf8_safe(p, e)                                          \
        generic_LC_non_invlist_utf8_safe_(isBLANK_LC, is_HORIZWS_high, p, e)
#define isCNTRL_LC_utf8_safe(p, e)                                          \
            generic_LC_utf8_safe_(isCNTRL_LC, p, e, 0)
#define isDIGIT_LC_utf8_safe(p, e)                                          \
            generic_LC_invlist_utf8_safe_(isDIGIT_LC, CC_DIGIT_, p, e)
#define isGRAPH_LC_utf8_safe(p, e)                                          \
            generic_LC_invlist_utf8_safe_(isGRAPH_LC, CC_GRAPH_, p, e)
#define isIDCONT_LC_utf8_safe(p, e)                                         \
            generic_LC_func_utf8_safe_(isIDCONT_LC,                         \
                                                _is_utf8_perl_idcont, p, e)
#define isIDFIRST_LC_utf8_safe(p, e)                                        \
            generic_LC_func_utf8_safe_(isIDFIRST_LC,                        \
                                               _is_utf8_perl_idstart, p, e)
#define isLOWER_LC_utf8_safe(p, e)                                          \
            generic_LC_invlist_utf8_safe_(isLOWER_LC, CC_LOWER_, p, e)
#define isPRINT_LC_utf8_safe(p, e)                                          \
            generic_LC_invlist_utf8_safe_(isPRINT_LC, CC_PRINT_, p, e)
#define isPSXSPC_LC_utf8_safe(p, e)    isSPACE_LC_utf8_safe(p, e)
#define isPUNCT_LC_utf8_safe(p, e)                                          \
            generic_LC_invlist_utf8_safe_(isPUNCT_LC, CC_PUNCT_, p, e)
#define isSPACE_LC_utf8_safe(p, e)                                          \
    generic_LC_non_invlist_utf8_safe_(isSPACE_LC, is_XPERLSPACE_high, p, e)
#define isUPPER_LC_utf8_safe(p, e)                                          \
            generic_LC_invlist_utf8_safe_(isUPPER_LC, CC_UPPER_, p, e)
#define isWORDCHAR_LC_utf8_safe(p, e)                                       \
            generic_LC_invlist_utf8_safe_(isWORDCHAR_LC, CC_WORDCHAR_, p, e)
#define isXDIGIT_LC_utf8_safe(p, e)                                         \
        generic_LC_non_invlist_utf8_safe_(isXDIGIT_LC, is_XDIGIT_high, p, e)

/* Macros for backwards compatibility and for completeness when the ASCII and
 * Latin1 values are identical */
#define isALPHAU(c)         isALPHA_L1(c)
#define isDIGIT_L1(c)       isDIGIT_A(c)
#define isOCTAL(c)          isOCTAL_A(c)
#define isOCTAL_L1(c)       isOCTAL_A(c)
#define isXDIGIT_L1(c)      isXDIGIT_A(c)
#define isALNUM(c)          isWORDCHAR(c)
#define isALNUM_A(c)        isALNUM(c)
#define isALNUMU(c)         isWORDCHAR_L1(c)
#define isALNUM_LC(c)       isWORDCHAR_LC(c)
#define isALNUM_uni(c)      isWORDCHAR_uni(c)
#define isALNUM_LC_uvchr(c) isWORDCHAR_LC_uvchr(c)
#define isALNUM_utf8(p,e)   isWORDCHAR_utf8(p,e)
#define isALNUM_utf8_safe(p,e) isWORDCHAR_utf8_safe(p,e)
#define isALNUM_LC_utf8(p,e)isWORDCHAR_LC_utf8(p,e)
#define isALNUM_LC_utf8_safe(p,e)isWORDCHAR_LC_utf8_safe(p,e)
#define isALNUMC_A(c)       isALPHANUMERIC_A(c)      /* Mnemonic: "C's alnum" */
#define isALNUMC_L1(c)      isALPHANUMERIC_L1(c)
#define isALNUMC(c)	    isALPHANUMERIC(c)
#define isALNUMC_LC(c)	    isALPHANUMERIC_LC(c)
#define isALNUMC_uni(c)     isALPHANUMERIC_uni(c)
#define isALNUMC_LC_uvchr(c) isALPHANUMERIC_LC_uvchr(c)
#define isALNUMC_utf8(p,e)  isALPHANUMERIC_utf8(p,e)
#define isALNUMC_utf8_safe(p,e)  isALPHANUMERIC_utf8_safe(p,e)
#define isALNUMC_LC_utf8_safe(p,e) isALPHANUMERIC_LC_utf8_safe(p,e)

/* On EBCDIC platforms, CTRL-@ is 0, CTRL-A is 1, etc, just like on ASCII,
 * except that they don't necessarily mean the same characters, e.g. CTRL-D is
 * 4 on both systems, but that is EOT on ASCII;  ST on EBCDIC.
 * '?' is special-cased on EBCDIC to APC, which is the control there that is
 * the outlier from the block that contains the other controls, just like
 * toCTRL('?') on ASCII yields DEL, the control that is the outlier from the C0
 * block.  If it weren't special cased, it would yield a non-control.
 * The conversion works both ways, so toCTRL('D') is 4, and toCTRL(4) is D,
 * etc. */
#ifndef EBCDIC
#  define toCTRL(c)    (__ASSERT_(FITS_IN_8_BITS(c)) toUPPER(((U8)(c))) ^ 64)
#else
#  define toCTRL(c)   (__ASSERT_(FITS_IN_8_BITS(c))                     \
                      ((isPRINT_A(c))                                   \
                       ? (UNLIKELY((c) == '?')                          \
                         ? QUESTION_MARK_CTRL                           \
                         : (NATIVE_TO_LATIN1(toUPPER((U8) (c))) ^ 64))  \
                       : (UNLIKELY((c) == QUESTION_MARK_CTRL)           \
                         ? '?'                                          \
                         : (LATIN1_TO_NATIVE(((U8) (c)) ^ 64)))))
#endif

/*
=for apidoc Ay||line_t
The typedef to use to declare variables that are to hold line numbers.

=cut

  Line numbers are unsigned, 32 bits.
*/
typedef U32 line_t;
#define LINE_Tf  U32uf
#define NOLINE ((line_t) 4294967295UL)  /* = FFFFFFFF */

/* Helpful alias for version prescan */
#define is_LAX_VERSION(a,b) \
        (a != Perl_prescan_version(aTHX_ a, FALSE, b, NULL, NULL, NULL, NULL))

#define is_STRICT_VERSION(a,b) \
        (a != Perl_prescan_version(aTHX_ a, TRUE, b, NULL, NULL, NULL, NULL))

#define BADVERSION(a,b,c) \
        if (b) { \
            *b = c; \
        } \
        return a;

/* Converts a character KNOWN to represent a hexadecimal digit (0-9, A-F, or
 * a-f) to its numeric value without using any branches.  The input is
 * validated only by an assert() in DEBUGGING builds.
 *
 * It works by right shifting and isolating the bit that is 0 for the digits,
 * and 1 for at least the alphas A-F, a-f.  The bit is shifted to the ones
 * position, and then to the eights position.  Both are added together to form
 * 0 if the input is '0'-'9' and to form 9 if alpha.  This is added to the
 * final four bits of the input to form the correct value. */
#define XDIGIT_VALUE(c) (__ASSERT_(isXDIGIT(c))                             \
           ((NATIVE_TO_LATIN1(c) >> 6) & 1)  /* 1 if alpha; 0 if not */     \
         + ((NATIVE_TO_LATIN1(c) >> 3) & 8)  /* 8 if alpha; 0 if not */     \
         + ((c) & 0xF))   /* 0-9 if input valid hex digit */

/* The argument is a string pointer, which is advanced. */
#define READ_XDIGIT(s)  ((s)++, XDIGIT_VALUE(*((s) - 1)))

/* Converts a character known to represent an octal digit (0-7) to its numeric
 * value.  The input is validated only by an assert() in DEBUGGING builds.  In
 * both ASCII and EBCDIC the last 3 bits of the octal digits range from 0-7. */
#define OCTAL_VALUE(c) (__ASSERT_(isOCTAL(c)) (7 & (c)))

/* Efficiently returns a boolean as to if two native characters are equivalent
 * case-insensitively.  At least one of the characters must be one of [A-Za-z];
 * the ALPHA in the name is to remind you of that.  This is asserted() in
 * DEBUGGING builds.  Because [A-Za-z] are invariant under UTF-8, this macro
 * works (on valid input) for both non- and UTF-8-encoded bytes.
 *
 * When one of the inputs is a compile-time constant and gets folded by the
 * compiler, this reduces to an AND and a TEST.  On both EBCDIC and ASCII
 * machines, 'A' and 'a' differ by a single bit; the same with the upper and
 * lower case of all other ASCII-range alphabetics.  On ASCII platforms, they
 * are 32 apart; on EBCDIC, they are 64.  At compile time, this uses an
 * exclusive 'or' to find that bit and then inverts it to form a mask, with
 * just a single 0, in the bit position where the upper- and lowercase differ.
 * */
#define isALPHA_FOLD_EQ(c1, c2)                                         \
                      (__ASSERT_(isALPHA_A(c1) || isALPHA_A(c2))        \
                      ((c1) & ~('A' ^ 'a')) ==  ((c2) & ~('A' ^ 'a')))
#define isALPHA_FOLD_NE(c1, c2) (! isALPHA_FOLD_EQ((c1), (c2)))

/*
=for apidoc_section $memory

=for apidoc Am|void|Newx|void* ptr|int nitems|type
=for apidoc_item |void*|safemalloc|size_t size

The XSUB-writer's interface to the C C<malloc> function.

Memory obtained by this should B<ONLY> be freed with L</"Safefree">.

In 5.9.3, Newx() and friends replace the older New() API, and drops
the first parameter, I<x>, a debug aid which allowed callers to identify
themselves.  This aid has been superseded by a new build option,
PERL_MEM_LOG (see L<perlhacktips/PERL_MEM_LOG>).  The older API is still
there for use in XS modules supporting older perls.

=for apidoc Am|void|Newxc|void* ptr|int nitems|type|cast
The XSUB-writer's interface to the C C<malloc> function, with
cast.  See also C<L</Newx>>.

Memory obtained by this should B<ONLY> be freed with L</"Safefree">.

=for apidoc Am|void|Newxz|void* ptr|int nitems|type
=for apidoc_item |void*|safecalloc|size_t nitems|size_t item_size

The XSUB-writer's interface to the C C<calloc> function.  The allocated
memory is zeroed with C<memzero>.  See also C<L</Newx>>.

Memory obtained by this should B<ONLY> be freed with L</"Safefree">.

=for apidoc Am|void|Renew|void* ptr|int nitems|type
=for apidoc_item |void*|saferealloc|void *ptr|size_t size

The XSUB-writer's interface to the C C<realloc> function.

Memory obtained by this should B<ONLY> be freed with L</"Safefree">.

=for apidoc Am|void|Renewc|void* ptr|int nitems|type|cast
The XSUB-writer's interface to the C C<realloc> function, with
cast.

Memory obtained by this should B<ONLY> be freed with L</"Safefree">.

=for apidoc Am|void|Safefree|void* ptr
The XSUB-writer's interface to the C C<free> function.

This should B<ONLY> be used on memory obtained using L</"Newx"> and friends.

=for apidoc_section $string
=for apidoc    Am|void  |Move |void* src|void* dest|int nitems|type
=for apidoc_item |void *|MoveD|void* src|void* dest|int nitems|type
The XSUB-writer's interface to the C C<memmove> function.  The C<src> is the
source, C<dest> is the destination, C<nitems> is the number of items, and
C<type> is the type.  Can do overlapping moves.  See also C<L</Copy>>.

C<MoveD> is like C<Move> but returns C<dest>.  Useful
for encouraging compilers to tail-call
optimise.

=for apidoc    Am|void  |Copy |void* src|void* dest|int nitems|type
=for apidoc_item |void *|CopyD|void* src|void* dest|int nitems|type
The XSUB-writer's interface to the C C<memcpy> function.  The C<src> is the
source, C<dest> is the destination, C<nitems> is the number of items, and
C<type> is the type.  May fail on overlapping copies.  See also C<L</Move>>.

C<CopyD> is like C<Copy> but returns C<dest>.  Useful
for encouraging compilers to tail-call
optimise.

=for apidoc    Am|void  |NewCopy |void* src|void* dest|int nitems|type
Combines Newx() and Copy() into a single macro. Dest will be allocated
using Newx() and then src will be copied into it.

=for apidoc    Am|void  |Zero |void* dest|int nitems|type
=for apidoc_item |void *|ZeroD|void* dest|int nitems|type

The XSUB-writer's interface to the C C<memzero> function.  The C<dest> is the
destination, C<nitems> is the number of items, and C<type> is the type.

C<ZeroD> is like C<Zero> but returns C<dest>.  Useful
for encouraging compilers to tail-call
optimise.

=for apidoc_section $utility
=for apidoc Amu|void|StructCopy|type *src|type *dest|type
This is an architecture-independent macro that does a shallow copy of one
structure to another.

=for apidoc Am|void|PoisonWith|void* dest|int nitems|type|U8 byte

Fill up memory with a byte pattern (a byte repeated over and over
again) that hopefully catches attempts to access uninitialized memory.

=for apidoc Am|void|PoisonNew|void* dest|int nitems|type

PoisonWith(0xAB) for catching access to allocated but uninitialized memory.

=for apidoc Am|void|PoisonFree|void* dest|int nitems|type

PoisonWith(0xEF) for catching access to freed memory.

=for apidoc Am|void|Poison|void* dest|int nitems|type

PoisonWith(0xEF) for catching access to freed memory.

=cut */

/* Maintained for backwards-compatibility only. Use newSV() instead. */
#ifndef PERL_CORE
#define NEWSV(x,len)	newSV(len)
#endif

#define MEM_SIZE_MAX ((MEM_SIZE)-1)

#define _PERL_STRLEN_ROUNDUP_UNCHECKED(n) (((n) - 1 + PERL_STRLEN_ROUNDUP_QUANTUM) & ~((MEM_SIZE)PERL_STRLEN_ROUNDUP_QUANTUM - 1))

#ifdef PERL_MALLOC_WRAP

/* This expression will be constant-folded at compile time.  It checks
 * whether or not the type of the count n is so small (e.g. U8 or U16, or
 * U32 on 64-bit systems) that there's no way a wrap-around could occur.
 * As well as avoiding the need for a run-time check in some cases, it's
 * designed to avoid compiler warnings like:
 *     comparison is always false due to limited range of data type
 * It's mathematically equivalent to
 *    max(n) * sizeof(t) > MEM_SIZE_MAX
 */


#  define _MEM_WRAP_NEEDS_RUNTIME_CHECK(n,t) \
    (  sizeof(MEM_SIZE) < sizeof(n) \
    || sizeof(t) > ((MEM_SIZE)1 << 8*(sizeof(MEM_SIZE) - sizeof(n))))

/* This is written in a slightly odd way to avoid various spurious
 * compiler warnings. We *want* to write the expression as
 *    _MEM_WRAP_NEEDS_RUNTIME_CHECK(n,t) && (n > C)
 * (for some compile-time constant C), but even when the LHS
 * constant-folds to false at compile-time, g++ insists on emitting
 * warnings about the RHS (e.g. "comparison is always false"), so instead
 * we write it as
 *
 *    (cond ? n : X) > C
 *
 * where X is a constant with X > C always false. Choosing a value for X
 * is tricky. If 0, some compilers will complain about 0 > C always being
 * false; if 1, Coverity complains when n happens to be the constant value
 * '1', that cond ? 1 : 1 has the same value on both branches; so use C
 * for X and hope that nothing else whines.
 */

#  define _MEM_WRAP_WILL_WRAP(n,t) \
      ((_MEM_WRAP_NEEDS_RUNTIME_CHECK(n,t) ? (MEM_SIZE)(n) : \
            MEM_SIZE_MAX/sizeof(t)) > MEM_SIZE_MAX/sizeof(t))

#  define MEM_WRAP_CHECK(n,t) \
        (void)(UNLIKELY(_MEM_WRAP_WILL_WRAP(n,t)) \
        && (croak_memory_wrap(),0))

#  define MEM_WRAP_CHECK_1(n,t,a) \
        (void)(UNLIKELY(_MEM_WRAP_WILL_WRAP(n,t)) \
        && (Perl_croak_nocontext("%s",(a)),0))

/* "a" arg must be a string literal */
#  define MEM_WRAP_CHECK_s(n,t,a) \
        (   (void) (UNLIKELY(_MEM_WRAP_WILL_WRAP(n,t))          \
         && (Perl_croak_nocontext(ASSERT_IS_LITERAL(a)), 0)))

#  define MEM_WRAP_CHECK_(n,t) MEM_WRAP_CHECK(n,t),

#  define PERL_STRLEN_ROUNDUP(n) ((void)(((n) > MEM_SIZE_MAX - 2 * PERL_STRLEN_ROUNDUP_QUANTUM) ? (croak_memory_wrap(),0) : 0), _PERL_STRLEN_ROUNDUP_UNCHECKED(n))
#else

#  define MEM_WRAP_CHECK(n,t)
#  define MEM_WRAP_CHECK_1(n,t,a)
#  define MEM_WRAP_CHECK_s(n,t,a)
#  define MEM_WRAP_CHECK_(n,t)

#  define PERL_STRLEN_ROUNDUP(n) _PERL_STRLEN_ROUNDUP_UNCHECKED(n)

#endif

#ifdef PERL_MEM_LOG
/*
 * If PERL_MEM_LOG is defined, all Newx()s, Renew()s, and Safefree()s
 * go through functions, which are handy for debugging breakpoints, but
 * which more importantly get the immediate calling environment (file and
 * line number, and C function name if available) passed in.  This info can
 * then be used for logging the calls, for which one gets a sample
 * implementation unless -DPERL_MEM_LOG_NOIMPL is also defined.
 *
 * Known problems:
 * - not all memory allocs get logged, only those
 *   that go through Newx() and derivatives (while all
 *   Safefrees do get logged)
 * - __FILE__ and __LINE__ do not work everywhere
 * - __func__ or __FUNCTION__ even less so
 * - I think more goes on after the perlio frees but
 *   the thing is that STDERR gets closed (as do all
 *   the file descriptors)
 * - no deeper calling stack than the caller of the Newx()
 *   or the kind, but do I look like a C reflection/introspection
 *   utility to you?
 * - the function prototypes for the logging functions
 *   probably should maybe be somewhere else than handy.h
 * - one could consider inlining (macrofying) the logging
 *   for speed, but I am too lazy
 * - one could imagine recording the allocations in a hash,
 *   (keyed by the allocation address?), and maintain that
 *   through reallocs and frees, but how to do that without
 *   any News() happening...?
 * - lots of -Ddefines to get useful/controllable output
 * - lots of ENV reads
 */

# ifdef PERL_CORE
#  ifndef PERL_MEM_LOG_NOIMPL
enum mem_log_type {
  MLT_ALLOC,
  MLT_REALLOC,
  MLT_FREE,
  MLT_NEW_SV,
  MLT_DEL_SV
};
#  endif
# endif

#endif

#ifdef PERL_MEM_LOG
#define MEM_LOG_ALLOC(n,t,a)     Perl_mem_log_alloc(n,sizeof(t),STRINGIFY(t),a,__FILE__,__LINE__,FUNCTION__)
#define MEM_LOG_REALLOC(n,t,v,a) Perl_mem_log_realloc(n,sizeof(t),STRINGIFY(t),v,a,__FILE__,__LINE__,FUNCTION__)
#define MEM_LOG_FREE(a)          Perl_mem_log_free(a,__FILE__,__LINE__,FUNCTION__)
#endif

#ifndef MEM_LOG_ALLOC
#define MEM_LOG_ALLOC(n,t,a)     (a)
#endif
#ifndef MEM_LOG_REALLOC
#define MEM_LOG_REALLOC(n,t,v,a) (a)
#endif
#ifndef MEM_LOG_FREE
#define MEM_LOG_FREE(a)          (a)
#endif

#define Newx(v,n,t)	(v = (MEM_WRAP_CHECK_(n,t) (t*)MEM_LOG_ALLOC(n,t,safemalloc((MEM_SIZE)((n)*sizeof(t))))))
#define Newxc(v,n,t,c)	(v = (MEM_WRAP_CHECK_(n,t) (c*)MEM_LOG_ALLOC(n,t,safemalloc((MEM_SIZE)((n)*sizeof(t))))))
#define Newxz(v,n,t)	(v = (MEM_WRAP_CHECK_(n,t) (t*)MEM_LOG_ALLOC(n,t,safecalloc((n),sizeof(t)))))

#ifndef PERL_CORE
/* pre 5.9.x compatibility */
#define New(x,v,n,t)	Newx(v,n,t)
#define Newc(x,v,n,t,c)	Newxc(v,n,t,c)
#define Newz(x,v,n,t)	Newxz(v,n,t)
#endif

#define Renew(v,n,t) \
          (v = (MEM_WRAP_CHECK_(n,t) (t*)MEM_LOG_REALLOC(n,t,v,saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t))))))
#define Renewc(v,n,t,c) \
          (v = (MEM_WRAP_CHECK_(n,t) (c*)MEM_LOG_REALLOC(n,t,v,saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t))))))

#ifdef PERL_POISON
#define Safefree(d) \
  ((d) ? (void)(safefree(MEM_LOG_FREE((Malloc_t)(d))), Poison(&(d), 1, Malloc_t)) : (void) 0)
#else
#define Safefree(d)	safefree(MEM_LOG_FREE((Malloc_t)(d)))
#endif

/* assert that a valid ptr has been supplied - use this instead of assert(ptr)  *
 * as it handles cases like constant string arguments without throwing warnings *
 * the cast is required, as is the inequality check, to avoid warnings          */
#define perl_assert_ptr(p) assert( ((void*)(p)) != 0 )


#define Move(s,d,n,t)	(MEM_WRAP_CHECK_(n,t) perl_assert_ptr(d), perl_assert_ptr(s), (void)memmove((char*)(d),(const char*)(s), (n) * sizeof(t)))
#define Copy(s,d,n,t)	(MEM_WRAP_CHECK_(n,t) perl_assert_ptr(d), perl_assert_ptr(s), (void)memcpy((char*)(d),(const char*)(s), (n) * sizeof(t)))
#define Zero(d,n,t)	(MEM_WRAP_CHECK_(n,t) perl_assert_ptr(d), (void)memzero((char*)(d), (n) * sizeof(t)))

/* Like above, but returns a pointer to 'd' */
#define MoveD(s,d,n,t)	(MEM_WRAP_CHECK_(n,t) perl_assert_ptr(d), perl_assert_ptr(s), memmove((char*)(d),(const char*)(s), (n) * sizeof(t)))
#define CopyD(s,d,n,t)	(MEM_WRAP_CHECK_(n,t) perl_assert_ptr(d), perl_assert_ptr(s), memcpy((char*)(d),(const char*)(s), (n) * sizeof(t)))
#define ZeroD(d,n,t)	(MEM_WRAP_CHECK_(n,t) perl_assert_ptr(d), memzero((char*)(d), (n) * sizeof(t)))

#define NewCopy(s,d,n,t) STMT_START {   \
    Newx(d,n,t);                        \
    Copy(s,d,n,t);                      \
} STMT_END

#define PoisonWith(d,n,t,b)	(MEM_WRAP_CHECK_(n,t) (void)memset((char*)(d), (U8)(b), (n) * sizeof(t)))
#define PoisonNew(d,n,t)	PoisonWith(d,n,t,0xAB)
#define PoisonFree(d,n,t)	PoisonWith(d,n,t,0xEF)
#define Poison(d,n,t)		PoisonFree(d,n,t)

#ifdef PERL_POISON
#  define PERL_POISON_EXPR(x) x
#else
#  define PERL_POISON_EXPR(x)
#endif

/* Shallow copy */
#define StructCopy(s,d,t) (*((t*)(d)) = *((t*)(s)))

/*
=for apidoc_section $utility

=for apidoc Am|STRLEN|C_ARRAY_LENGTH|void *a

Returns the number of elements in the input C array (so you want your
zero-based indices to be less than but not equal to).

=for apidoc Am|void *|C_ARRAY_END|void *a

Returns a pointer to one element past the final element of the input C array.

=cut

C_ARRAY_END is one past the last: half-open/half-closed range, not
last-inclusive range.
*/
#define C_ARRAY_LENGTH(a)	(sizeof(a)/sizeof((a)[0]))
#define C_ARRAY_END(a)		((a) + C_ARRAY_LENGTH(a))

#if defined(PERL_CORE) || defined(PERL_EXT_RE_BUILD)
/* strlen() of a literal string constant.  Restricting this to core, in part
 * because it can generate compiler warnings about comparing unlike signs */
#  define STRLENs(s)  (sizeof("" s "") - 1)
#endif

#ifdef NEED_VA_COPY
# ifdef va_copy
#  define Perl_va_copy(s, d) va_copy(d, s)
# elif defined(__va_copy)
#  define Perl_va_copy(s, d) __va_copy(d, s)
# else
#  define Perl_va_copy(s, d) Copy(s, d, 1, va_list)
# endif
#endif

/* convenience debug macros */
#ifdef USE_ITHREADS
#define pTHX_FORMAT  "Perl interpreter: 0x%p"
#define pTHX__FORMAT ", Perl interpreter: 0x%p"
#define pTHX_VALUE_   (void *)my_perl,
#define pTHX_VALUE    (void *)my_perl
#define pTHX__VALUE_ ,(void *)my_perl,
#define pTHX__VALUE  ,(void *)my_perl
#else
#define pTHX_FORMAT
#define pTHX__FORMAT
#define pTHX_VALUE_
#define pTHX_VALUE
#define pTHX__VALUE_
#define pTHX__VALUE
#endif /* USE_ITHREADS */

/*
 Perl_deprecate was not part of the public API, and did not have a deprecate()
 shortcut macro defined without -DPERL_CORE. Neither codesearch.google.com nor
 CPAN::Unpack show any users outside the core.

=for apidoc_section $warning
=for apidoc Cdm||deprecate|U32 category|"message"
Wrapper around Perl_ck_warner_d() to produce a deprecated warning in the
given category with an appropriate message. The C<message> argument must
be a C string. The string " is deprecated" will automatically be added
to the end of the C<message>.

=for apidoc Cdm||deprecate_disappears_in|U32 category|"when"|"message"
Wrapper around Perl_ck_warner_d() to produce a deprecated warning in the
given category with an appropriate message that the construct referred
to by the message will disappear in a specific release.  The C<when> and
C<message> arguments must be a C string.  The C<when> string is expected
to be of the form "5.40", with no minor element in the version.  The actual
message output will be the result of the following expression C<message
" is deprecated, and will disappear in Perl " when> which is why C<message>
and C<when> must be literal C strings.

=for apidoc Cdm||deprecate_fatal_in|U32 category|"when"|"message"
Wrapper around Perl_ck_warner_d() to produce a deprecated warning in the
given category with an appropriate message that the construct referred
to by the message will become fatal in a specific release.  The C<when>
and C<message> arguments must be a C string.  The C<when> string is expected
to be of the form "5.40", with no minor element in the version.  The actual
message output will be the result of the following expression C<message " is
deprecated, and will become fatal in Perl " when> which is why C<message>
and C<when> must be literal C strings.

=cut
*/

#ifdef PERL_CORE
#  define deprecate(category,message)                       \
    Perl_ck_warner_d(aTHX_ packWARN(category),              \
        message " is deprecated")

#  define deprecate_disappears_in(category,when,message)    \
    Perl_ck_warner_d(aTHX_ packWARN(category),              \
        message " is deprecated, and will disappear in Perl " when)

#  define deprecate_fatal_in(category,when,message)         \
    Perl_ck_warner_d(aTHX_ packWARN(category),              \
        message " is deprecated, and will become fatal in Perl " when)
#endif

/* Internal macros to deal with gids and uids */
#ifdef PERL_CORE

#  if Uid_t_size > IVSIZE
#    define sv_setuid(sv, uid)       sv_setnv((sv), (NV)(uid))
#    define SvUID(sv)                SvNV(sv)
#  elif Uid_t_sign <= 0
#    define sv_setuid(sv, uid)       sv_setiv((sv), (IV)(uid))
#    define SvUID(sv)                SvIV(sv)
#  else
#    define sv_setuid(sv, uid)       sv_setuv((sv), (UV)(uid))
#    define SvUID(sv)                SvUV(sv)
#  endif /* Uid_t_size */

#  if Gid_t_size > IVSIZE
#    define sv_setgid(sv, gid)       sv_setnv((sv), (NV)(gid))
#    define SvGID(sv)                SvNV(sv)
#  elif Gid_t_sign <= 0
#    define sv_setgid(sv, gid)       sv_setiv((sv), (IV)(gid))
#    define SvGID(sv)                SvIV(sv)
#  else
#    define sv_setgid(sv, gid)       sv_setuv((sv), (UV)(gid))
#    define SvGID(sv)                SvUV(sv)
#  endif /* Gid_t_size */

#endif

/* These are simple Marsaglia XOR-SHIFT RNG's for 64 and 32 bits. These
 * RNG's are of reasonable quality, very fast, and have the interesting
 * property that provided 'x' is non-zero they create a cycle of 2^32-1
 * or 2^64-1 "random" like numbers, with the exception of 0. Thus they
 * are very useful when you want an integer to "dance" in a random way,
 * but you also never want it to become 0 and thus false.
 *
 * Obviously they leave x unchanged if it starts out as 0.
 *
 * We have two variants just because that can be helpful in certain
 * places. There is no advantage to either, they are equally bad as each
 * other as far RNG's go. Sufficiently random for many purposes, but
 * insufficiently random for serious use as they fail important tests in
 * the Test01 BigCrush RNG test suite by Lâ€™Ecuyer and Simard. (Note
 * that Drand48 also fails BigCrush). The main point is they produce
 * different sequences and in places where we want some randomlike
 * behavior they are cheap and easy.
 *
 * Marsaglia was one of the early researchers into RNG testing and wrote
 * the Diehard RNG test suite, which after his death become the
 * Dieharder RNG suite, and was generally supplanted by the Test01 suite
 * by L'Ecruyer and associates.
 *
 * There are dozens of shift parameters that create a pseudo random ring
 * of integers 1..2^N-1, if you need a different sequence just read the
 * paper and select a set of parameters. In fact, simply reversing the
 * shift order from L/R/L to R/L/R should result in another valid
 * example, but read the paper before you do that.
 *
 * PDF of the original paper:
 *  https://www.jstatsoft.org/article/download/v008i14/916
 * Wikipedia:
 *  https://en.wikipedia.org/wiki/Xorshift
 * Criticism:
 *  https://www.iro.umontreal.ca/~lecuyer/myftp/papers/xorshift.pdf
 * Test01:
 *  http://simul.iro.umontreal.ca/testu01/tu01.html
 * Diehard:
 *  https://en.wikipedia.org/wiki/Diehard_tests
 * Dieharder:
 *  https://webhome.phy.duke.edu/~rgb/General/rand_rate/rand_rate.abs
 *
 */

/* 32 bit version */
#define PERL_XORSHIFT32_A(x)    \
STMT_START {                    \
    (x) ^= ((x) << 13);         \
    (x) ^= ((x) >> 17);         \
    (x) ^= ((x) << 5);          \
} STMT_END

/* 64 bit version */
#define PERL_XORSHIFT64_A(x)    \
STMT_START {                    \
    (x) ^= ((x) << 13);         \
    (x) ^= ((x) >> 7);          \
    (x) ^= ((x) << 17);         \
} STMT_END

/* 32 bit version */
#define PERL_XORSHIFT32_B(x)    \
STMT_START {                    \
    (x) ^= ((x) << 5);          \
    (x) ^= ((x) >> 27);         \
    (x) ^= ((x) << 8);          \
} STMT_END

/* 64 bit version - currently this is unused,
 * it is provided here to complement the 32 bit _B
 * variant which IS used. */
#define PERL_XORSHIFT64_B(x)    \
STMT_START {                    \
    (x) ^= ((x) << 15);         \
    (x) ^= ((x) >> 49);         \
    (x) ^= ((x) << 26);         \
} STMT_END

#ifdef PERL_CORE
/* Convenience macros for dealing with IV_MIN:
   In two's complement system, the absolute value of IV_MIN (i.e. -IV_MIN)
   cannot be represented in IV.  Thus we cannot use simple negation
   (like "-iv") if "iv" might be IV_MIN or -IV_MIN.
   Note that expressions like "iv = -(UV)iv;" is also not portable
   as "-(UV)iv" may not fit in IV range and attempt to convert such value
   to IV might get implementation-defined result or raise a signal.  */

/* Negate IV in the range [IV_MIN, 0) to positive (absolute) UV value.
   Written this way to avoid every subexpression never cause signed integer
   overflow (even for two's complement), and make it possible to be compiled
   into single negation by optimizing compilers. */
#  define NEGATE_2UV(iv) (ASSUME((iv) < 0), (UV)-((iv) + 1) + 1U)

/* Absolute value of IV_MIN as UV.  */
#  define ABS_IV_MIN    NEGATE_2UV(IV_MIN)

/* Negate UV in the range [0, abs(IV_MIN)] to zero or negative IV value
   in the range [IV_MIN, 0].  Written this way to avoid casting non-IV value
   into IV (which is either the result is implementation-defined or an
   implementation-defined signal is raised).  Note that "8" below is an
   arbitrary value to force both branches of conditional operator to be
   non-constant and eventually make it possible to be compiled into
   single negation by optimizing compilers. */
#  define NEGATE_2IV(uv) (ASSUME((uv) <= ABS_IV_MIN), \
                          (uv) < 8U ? -(IV)(uv) : -(IV)((uv) - 8U) - 8)

#endif  /* PERL_CORE */

#endif  /* PERL_HANDY_H_ */

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                        usr/local/lib/perl5/5.40.0/x86_64-linux-gnu/CORE/hv.h                                               0000444 0000000 0000000 00000067167 14714567415 017725  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    hv.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2005, 2006, 2007, 2008, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/* These control hash traversal randomization and the environment variable PERL_PERTURB_KEYS.
 * Currently disabling this functionality will break a few tests, but should otherwise work fine.
 * See perlrun for more details. */

#if defined(PERL_PERTURB_KEYS_DISABLED)
#   define PL_HASH_RAND_BITS_ENABLED        0
#   define PERL_HASH_ITER_BUCKET(iter)      ((iter)->xhv_riter)
#else
#   define PERL_HASH_RANDOMIZE_KEYS         1
#   if defined(PERL_PERTURB_KEYS_RANDOM)
#       define PL_HASH_RAND_BITS_ENABLED    1
#   elif defined(PERL_PERTURB_KEYS_DETERMINISTIC)
#       define PL_HASH_RAND_BITS_ENABLED    2
