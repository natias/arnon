	case SQLCS_LIT_NULL:			return "SQLCS_LIT_NULL";/* for typecheck of NULL and empty_clob() lits */
	}

	sv = sv_2mortal(newSViv((IV)attr));
	return SvPV(sv,PL_na);
}

/*used to look up the name of a OCI_DTYPE_PARAM Attribute Types
  used only for debugging */
char *
oci_dtype_attr_name(ub4 attr)
{
	dTHX;
	SV *sv;
	switch (attr) {
/*=======================Describe Handle Parameter Attributes ===============*/
	case OCI_ATTR_DATA_SIZE:			return "OCI_ATTR_DATA_SIZE";	/* maximum size of the data */
	case OCI_ATTR_DATA_TYPE:			return "OCI_ATTR_DATA_TYPE";	/* the SQL type of the column/argument */
	case OCI_ATTR_DISP_SIZE:			return "OCI_ATTR_DISP_SIZE";	/* the display size */
	case OCI_ATTR_NAME:					return "OCI_ATTR_NAME";			/* the name of the column/argument */
	case OCI_ATTR_PRECISION:			return "OCI_ATTR_PRECISION";	/* precision if number type */
	case OCI_ATTR_SCALE:				return "OCI_ATTR_SCALE"; 		/* scale if number type */
	case OCI_ATTR_IS_NULL:				return "OCI_ATTR_IS_NULL";		/* is it null ? */
	case OCI_ATTR_TYPE_NAME: 			return "OCI_ATTR_TYPE_NAME";
  /* name of the named data type or a package name for package private types */
	case OCI_ATTR_SCHEMA_NAME: 			return "OCI_ATTR_SCHEMA_NAME";	/* the schema name */
	case OCI_ATTR_SUB_NAME: 			return "OCI_ATTR_SUB_NAME";		/* type name if package private type */
	case OCI_ATTR_POSITION:				return "OCI_ATTR_POSITION";
	case OCI_ATTR_CHAR_USED:            return "OCI_ATTR_CHAR_USED";	/* char length semantics */
	case OCI_ATTR_CHAR_SIZE:             return "OCI_ATTR_CHAR_SIZE";	/* char length */
	case OCI_ATTR_CHARSET_ID:			return "OCI_ATTR_CHARSET_ID";	/* Character Set ID */
	case OCI_ATTR_CHARSET_FORM:			return "OCI_ATTR_CHARSET_FORM";	/* Character Set Form */
	}

	sv = sv_2mortal(newSViv((IV)attr));
	return SvPV(sv,PL_na);

}

/*used to look up the name of non a OCI_DTYPE_PARAM Attribute Types
  used only for debugging */
char *
oci_attr_name(ub4 attr)
{
	dTHX;
	SV *sv;
	switch (attr) {
#ifdef ORA_OCI_102
	case OCI_ATTR_MODULE:                    return "OCI_ATTR_MODULE";        /* module for tracing */
	case OCI_ATTR_ACTION:                    return "OCI_ATTR_ACTION";        /* action for tracing */
	case OCI_ATTR_CLIENT_INFO:               return "OCI_ATTR_CLIENT_INFO";               /* client info */
	case OCI_ATTR_COLLECT_CALL_TIME:         return "OCI_ATTR_COLLECT_CALL_TIME";         /* collect call time */
	case OCI_ATTR_CALL_TIME:                 return "OCI_ATTR_CALL_TIME";         /* extract call time */
	case OCI_ATTR_ECONTEXT_ID:               return "OCI_ATTR_ECONTEXT_ID";      /* execution-id context */
	case OCI_ATTR_ECONTEXT_SEQ:              return "OCI_ATTR_ECONTEXT_SEQ";  /*execution-id sequence num */


	/*------------------------------ Session attributes -------------------------*/
	case OCI_ATTR_SESSION_STATE:             return "OCI_ATTR_SESSION_STATE";             /* session state */

	case OCI_ATTR_SESSION_STATETYPE:         return "OCI_ATTR_SESSION_STATETYPE";        /* session state type */
	case OCI_SESSION_STATELESS_DEF: 		 return "OCI_SESSION_STATELESS_DEF";                    /* valid state types */

	case OCI_ATTR_SESSION_STATE_CLEARED:     return "OCI_ATTR_SESSION_STATE_CLEARED";     /* session state cleared*/
	case OCI_ATTR_SESSION_MIGRATED:          return "OCI_ATTR_SESSION_MIGRATED";       /* did session migrate*/
	case OCI_ATTR_SESSION_PRESERVE_STATE:    return "OCI_ATTR_SESSION_PRESERVE_STATE";    /* preserve session state */
#endif
#ifdef ORA_OCI_112
	case OCI_ATTR_DRIVER_NAME:               return "OCI_ATTR_DRIVER_NAME";               /* Driver Name */
#endif
	case OCI_ATTR_CLIENT_IDENTIFIER:         return "OCI_ATTR_CLIENT_IDENTIFIER";   /* value of client id to set*/

	/*=============================Attribute Types===============================*/
#ifdef ORA_OCI_112
    case OCI_ATTR_PURITY:				return "OCI_ATTR_PURITY"; /* for DRCP session purity */
    case OCI_ATTR_CONNECTION_CLASS:		return "OCI_ATTR_CONNECTION_CLASS"; /* for DRCP connection class */
#endif
	case OCI_ATTR_FNCODE:				return "OCI_ATTR_FNCODE";		/* the OCI function code */
	case OCI_ATTR_OBJECT:				return "OCI_ATTR_OBJECT"; /* is the environment initialized in object mode */
	case OCI_ATTR_NONBLOCKING_MODE:		return "OCI_ATTR_NONBLOCKING_MODE";		/* non blocking mode */
	case OCI_ATTR_SQLCODE:				return "OCI_ATTR_SQLCODE";				/* the SQL verb */
	case OCI_ATTR_ENV:					return "OCI_ATTR_ENV";				/* the environment handle */
	case OCI_ATTR_SERVER:				return "OCI_ATTR_SERVER";			/* the server handle*/
	case OCI_ATTR_SESSION:				return "OCI_ATTR_SESSION";			/* the user session handle*/
	case OCI_ATTR_TRANS:				return "OCI_ATTR_TRANS";			/* the transaction handle */
	case OCI_ATTR_ROW_COUNT:			return "OCI_ATTR_ROW_COUNT";		/* the rows processed so far */
	case OCI_ATTR_SQLFNCODE:			return "OCI_ATTR_SQLFNCODE";		/* the SQL verb of the statement */
	case OCI_ATTR_PREFETCH_ROWS:		return "OCI_ATTR_PREFETCH_ROWS";	/* sets the number of rows to prefetch */
	case OCI_ATTR_NESTED_PREFETCH_ROWS:	return "OCI_ATTR_NESTED_PREFETCH_ROWS"; /* the prefetch rows of nested table*/
	case OCI_ATTR_PREFETCH_MEMORY:		return "OCI_ATTR_PREFETCH_MEMORY";		/* memory limit for rows fetched */
	case OCI_ATTR_NESTED_PREFETCH_MEMORY:return "OCI_ATTR_NESTED_PREFETCH_MEMORY";	/* memory limit for nested rows */
	case OCI_ATTR_CHAR_COUNT:			return "OCI_ATTR_CHAR_COUNT";			 /* this specifies the bind and define size in characters */
	case OCI_ATTR_PDSCL:				return "OCI_ATTR_PDSCL";			/* packed decimal scale*/
	/*case OCI_ATTR_FSPRECISION OCI_ATTR_PDSCL:return "";					 fs prec for datetime data types */
	case OCI_ATTR_PDPRC:				return "OCI_ATTR_PDPRC";			/* packed decimal format*/
	/*case OCI_ATTR_LFPRECISION OCI_ATTR_PDPRC: return "";					fs prec for datetime data types */
	case OCI_ATTR_PARAM_COUNT:			return "OCI_ATTR_PARAM_COUNT";		/* number of column in the select list */
	case OCI_ATTR_ROWID:				return "OCI_ATTR_ROWID";			/* the rowid */
	case OCI_ATTR_CHARSET:				return "OCI_ATTR_CHARSET";			/* the character set value */
	case OCI_ATTR_NCHAR:				return "OCI_ATTR_NCHAR";			/* NCHAR type */
	case OCI_ATTR_USERNAME:				return "OCI_ATTR_USERNAME";			/* username attribute */
	case OCI_ATTR_PASSWORD:				return "OCI_ATTR_PASSWORD";			/* password attribute */
	case OCI_ATTR_STMT_TYPE:			return "OCI_ATTR_STMT_TYPE";		/* statement type */
	case OCI_ATTR_INTERNAL_NAME:		return "OCI_ATTR_INTERNAL_NAME";	/* user friendly global name */
	case OCI_ATTR_EXTERNAL_NAME:		return "OCI_ATTR_EXTERNAL_NAME";	/* the internal name for global txn */
	case OCI_ATTR_XID:					return "OCI_ATTR_XID";				/* XOPEN defined global transaction id */
	case OCI_ATTR_TRANS_LOCK:			return "OCI_ATTR_TRANS_LOCK";		/* */
	case OCI_ATTR_TRANS_NAME:			return "OCI_ATTR_TRANS_NAME";		/* string to identify a global transaction */
	case OCI_ATTR_HEAPALLOC:			return "OCI_ATTR_HEAPALLOC";		/* memory allocated on the heap */
	case OCI_ATTR_CHARSET_FORM:			return "OCI_ATTR_CHARSET_FORM";		/* Character Set Form */
	case OCI_ATTR_MAXDATA_SIZE:			return "OCI_ATTR_MAXDATA_SIZE";		/* Maximum size of data on the server  */
	case OCI_ATTR_CACHE_OPT_SIZE:		return "OCI_ATTR_CACHE_OPT_SIZE";	/* object cache optimal size */
	case OCI_ATTR_CACHE_MAX_SIZE:		return "OCI_ATTR_CACHE_MAX_SIZE";	/* object cache maximum size percentage */
	case OCI_ATTR_PINOPTION:			return "OCI_ATTR_PINOPTION";		/* object cache default pin option */
	case OCI_ATTR_ALLOC_DURATION:		return "OCI_ATTR_ALLOC_DURATION";	/* object cache default allocation duration */
	case OCI_ATTR_PIN_DURATION:			return "OCI_ATTR_PIN_DURATION";		/* object cache default pin duration */
	case OCI_ATTR_FDO:					return "OCI_ATTR_FDO";		/* Format Descriptor object attribute */
	case OCI_ATTR_POSTPROCESSING_CALLBACK:		return "OCI_ATTR_POSTPROCESSING_CALLBACK"; /* Callback to process outbind data */
	case OCI_ATTR_POSTPROCESSING_CONTEXT:		return "OCI_ATTR_POSTPROCESSING_CONTEXT";  /* Callback context to process outbind data */
	case OCI_ATTR_ROWS_RETURNED:		return "OCI_ATTR_ROWS_RETURNED"; 	/* Number of rows returned in current iter - for Bind handles */
	case OCI_ATTR_FOCBK:				return "OCI_ATTR_FOCBK";			/* Failover Callback attribute */
	case OCI_ATTR_IN_V8_MODE:			return "OCI_ATTR_IN_V8_MODE";		/* is the server/service context in V8 mode */
	case OCI_ATTR_LOBEMPTY:				return "OCI_ATTR_LOBEMPTY";			/* empty lob ? */
	case OCI_ATTR_SESSLANG:				return "OCI_ATTR_SESSLANG";			/* session language handle */
	case OCI_ATTR_VISIBILITY:			return "OCI_ATTR_VISIBILITY";		/* visibility */
	case OCI_ATTR_RELATIVE_MSGID:		return "OCI_ATTR_RELATIVE_MSGID";	/* relative message id */
	case OCI_ATTR_SEQUENCE_DEVIATION:	return "OCI_ATTR_SEQUENCE_DEVIATION";	/* sequence deviation */

	case OCI_ATTR_CONSUMER_NAME:		return "OCI_ATTR_CONSUMER_NAME";	/* consumer name */
	case OCI_ATTR_DEQ_MODE:				return "OCI_ATTR_DEQ_MODE";			/* dequeue mode */
	case OCI_ATTR_NAVIGATION:			return "OCI_ATTR_NAVIGATION";		/* navigation */
	case OCI_ATTR_WAIT:					return "OCI_ATTR_WAIT";				/* wait */
	case OCI_ATTR_DEQ_MSGID:			return "OCI_ATTR_DEQ_MSGID";		/* dequeue message id */

	case OCI_ATTR_PRIORITY:				return "OCI_ATTR_PRIORITY";			/* priority */
	case OCI_ATTR_DELAY:				return "OCI_ATTR_DELAY";			/* delay */
	case OCI_ATTR_EXPIRATION:			return "OCI_ATTR_EXPIRATION";		/* expiration */
	case OCI_ATTR_CORRELATION:			return "OCI_ATTR_CORRELATION";		/* correlation id */
	case OCI_ATTR_ATTEMPTS:				return "OCI_ATTR_ATTEMPTS";			/* # of attempts */
	case OCI_ATTR_RECIPIENT_LIST:		return "OCI_ATTR_RECIPIENT_LIST";	/* recipient list */
	case OCI_ATTR_EXCEPTION_QUEUE:		return "OCI_ATTR_EXCEPTION_QUEUE";	/* exception queue name */
	case OCI_ATTR_ENQ_TIME:				return "OCI_ATTR_ENQ_TIME";			/* enqueue time (only OCIAttrGet) */
	case OCI_ATTR_MSG_STATE:			return "OCI_ATTR_MSG_STATE";		/* message state (only OCIAttrGet) */
																			/* NOTE: 64-66 used below */
	case OCI_ATTR_AGENT_NAME:			return "OCI_ATTR_AGENT_NAME";		/* agent name */
	case OCI_ATTR_AGENT_ADDRESS:		return "OCI_ATTR_AGENT_ADDRESS";	/* agent address */
	case OCI_ATTR_AGENT_PROTOCOL:		return "OCI_ATTR_AGENT_PROTOCOL";	/* agent protocol */

	case OCI_ATTR_SENDER_ID:			return "OCI_ATTR_SENDER_ID";		/* sender id */
	case OCI_ATTR_ORIGINAL_MSGID:		return "OCI_ATTR_ORIGINAL_MSGID";	/* original message id */

	case OCI_ATTR_QUEUE_NAME:			return "OCI_ATTR_QUEUE_NAME";		/* queue name */
	case OCI_ATTR_NFY_MSGID:			return "OCI_ATTR_NFY_MSGID";		/* message id */
	case OCI_ATTR_MSG_PROP:				return "OCI_ATTR_MSG_PROP";			/* message properties */

	case OCI_ATTR_NUM_DML_ERRORS:		return "OCI_ATTR_NUM_DML_ERRORS";	/* num of errs in array DML */
	case OCI_ATTR_DML_ROW_OFFSET:		return "OCI_ATTR_DML_ROW_OFFSET";	/* row offset in the array */

	case OCI_ATTR_DATEFORMAT:			return "OCI_ATTR_DATEFORMAT";		/* default date format string */
	case OCI_ATTR_BUF_ADDR:				return "OCI_ATTR_BUF_ADDR";			/* buffer address */
	case OCI_ATTR_BUF_SIZE:				return "OCI_ATTR_BUF_SIZE";			/* buffer size */
	case OCI_ATTR_DIRPATH_MODE:			return "OCI_ATTR_DIRPATH_MODE";		/* mode of direct path operation */
	case OCI_ATTR_DIRPATH_NOLOG:		return "OCI_ATTR_DIRPATH_NOLOG";	/* nologging option */
	case OCI_ATTR_DIRPATH_PARALLEL:		return "OCI_ATTR_DIRPATH_PARALLEL";	/* parallel (temp seg) option */
	case OCI_ATTR_NUM_ROWS:				return "OCI_ATTR_NUM_ROWS"; 		/* number of rows in column array */
																			/* NOTE that OCI_ATTR_NUM_COLS is a column*/
																			/* array attribute too.*/
	case OCI_ATTR_COL_COUNT:			return "OCI_ATTR_COL_COUNT";        /* columns of column array*/
																			/*processed so far.       */
	case OCI_ATTR_STREAM_OFFSET:		return "OCI_ATTR_STREAM_OFFSET";	/* str off of last row processed*/
/*	case OCI_ATTR_SHARED_HEAPALLO:		return "";							Shared Heap Allocation Size */

	case OCI_ATTR_SERVER_GROUP:			return "OCI_ATTR_SERVER_GROUP";		/* server group name */

	case OCI_ATTR_MIGSESSION:			return "OCI_ATTR_MIGSESSION"; 		/* migratable session attribute */

	case OCI_ATTR_NOCACHE:				return "OCI_ATTR_NOCACHE";			/* Temporary LOBs */

	case OCI_ATTR_MEMPOOL_SIZE:			return "OCI_ATTR_MEMPOOL_SIZE";		/* Pool Size */
	case OCI_ATTR_MEMPOOL_INSTNAME:		return "OCI_ATTR_MEMPOOL_INSTNAME";	/* Instance name */
	case OCI_ATTR_MEMPOOL_APPNAME:		return "OCI_ATTR_MEMPOOL_APPNAME";	/* Application name */
	case OCI_ATTR_MEMPOOL_HOMENAME:		return "OCI_ATTR_MEMPOOL_HOMENAME";	/* Home Directory name */
	case OCI_ATTR_MEMPOOL_MODEL:		return "OCI_ATTR_MEMPOOL_MODEL";	/* Pool Model (proc,thrd,both)*/
	case OCI_ATTR_MODES:				return "OCI_ATTR_MODES";			/* Modes */

	case OCI_ATTR_SUBSCR_NAME:			return "OCI_ATTR_SUBSCR_NAME";		/* name of subscription */
	case OCI_ATTR_SUBSCR_CALLBACK:		return "OCI_ATTR_SUBSCR_CALLBACK";	/* associated callback */
	case OCI_ATTR_SUBSCR_CTX:			return "OCI_ATTR_SUBSCR_CTX";		/* associated callback context */
	case OCI_ATTR_SUBSCR_PAYLOAD:		return "OCI_ATTR_SUBSCR_PAYLOAD";	/* associated payload */
	case OCI_ATTR_SUBSCR_NAMESPACE:		return "OCI_ATTR_SUBSCR_NAMESPACE"; /* associated namespace */

	case OCI_ATTR_PROXY_CREDENTIALS:	return "OCI_ATTR_PROXY_CREDENTIALS";	/* Proxy user credentials */
	case OCI_ATTR_INITIAL_CLIENT_ROLES:	return "OCI_ATTR_INITIAL_CLIENT_ROLES";	/* Initial client role list */

	case OCI_ATTR_UNK:					return "OCI_ATTR_UNK";				/* unknown attribute */
	case OCI_ATTR_NUM_COLS:				return "OCI_ATTR_NUM_COLS";			/* number of columns */
	case OCI_ATTR_LIST_COLUMNS:			return "OCI_ATTR_LIST_COLUMNS";		/* parameter of the column list */
	case OCI_ATTR_RDBA:					return "OCI_ATTR_RDBA";				/* DBA of the segment header */
	case OCI_ATTR_CLUSTERED:			return "OCI_ATTR_CLUSTERED";		/* whether the table is clustered */
	case OCI_ATTR_PARTITIONED:			return "OCI_ATTR_PARTITIONED";		/* whether the table is partitioned */
	case OCI_ATTR_INDEX_ONLY:			return "OCI_ATTR_INDEX_ONLY";		/* whether the table is index only */
	case OCI_ATTR_LIST_ARGUMENTS:		return "OCI_ATTR_LIST_ARGUMENTS";	/* parameter of the argument list */
	case OCI_ATTR_LIST_SUBPROGRAMS:		return "OCI_ATTR_LIST_SUBPROGRAMS";	/* parameter of the subprogram list */
	case OCI_ATTR_REF_TDO:				return "OCI_ATTR_REF_TDO";			/* REF to the type descriptor */
	case OCI_ATTR_LINK:					return "OCI_ATTR_LINK";				/* the database link name */
	case OCI_ATTR_MIN:					return "OCI_ATTR_MIN";				/* minimum value */
	case OCI_ATTR_MAX:					return "OCI_ATTR_MAX";				/* maximum value */
	case OCI_ATTR_INCR:					return "OCI_ATTR_INCR";				/* increment value */
	case OCI_ATTR_CACHE:				return "OCI_ATTR_CACHE";			/* number of sequence numbers cached */
	case OCI_ATTR_ORDER:				return "OCI_ATTR_ORDER";			/* whether the sequence is ordered */
	case OCI_ATTR_HW_MARK:				return "OCI_ATTR_HW_MARK";			/* high-water mark */
	case OCI_ATTR_TYPE_SCHEMA:			return "OCI_ATTR_TYPE_SCHEMA";		/* type's schema name */
	case OCI_ATTR_TIMESTAMP:			return "OCI_ATTR_TIMESTAMP";		/* timestamp of the object */
	case OCI_ATTR_NUM_ATTRS:			return "OCI_ATTR_NUM_ATTRS";		/* number of sttributes */
	case OCI_ATTR_NUM_PARAMS:			return "OCI_ATTR_NUM_PARAMS";		/* number of parameters */
	case OCI_ATTR_OBJID:				return "OCI_ATTR_OBJID";			/* object id for a table or view */
	case OCI_ATTR_PTYPE:				return "OCI_ATTR_PTYPE";			/* type of info described by */
	case OCI_ATTR_PARAM:				return "OCI_ATTR_PARAM";			/* parameter descriptor */
	case OCI_ATTR_OVERLOAD_ID:			return "OCI_ATTR_OVERLOAD_ID";		/* overload ID for funcs and procs */
	case OCI_ATTR_TABLESPACE:			return "OCI_ATTR_TABLESPACE";		/* table name space */
	case OCI_ATTR_TDO:					return "OCI_ATTR_TDO";				/* TDO of a type */
	case OCI_ATTR_LTYPE:				return "OCI_ATTR_LTYPE";			/* list type */
	case OCI_ATTR_PARSE_ERROR_OFFSET:	return "OCI_ATTR_PARSE_ERROR_OFFSET";/* Parse Error offset */
	case OCI_ATTR_IS_TEMPORARY:			return "OCI_ATTR_IS_TEMPORARY";		/* whether table is temporary */
	case OCI_ATTR_IS_TYPED:				return "OCI_ATTR_IS_TYPED";			/* whether table is typed */
	case OCI_ATTR_DURATION:				return "OCI_ATTR_DURATION";			/* duration of temporary table */
	case OCI_ATTR_IS_INVOKER_RIGHTS:	return "OCI_ATTR_IS_INVOKER_RIGHTS";/* is invoker rights */
	case OCI_ATTR_OBJ_NAME:				return "OCI_ATTR_OBJ_NAME";			/* top level schema obj name */
	case OCI_ATTR_OBJ_SCHEMA:			return "OCI_ATTR_OBJ_SCHEMA";		/* schema name */
	case OCI_ATTR_OBJ_ID:				return "OCI_ATTR_OBJ_ID";			/* top level schema object id */

	case OCI_ATTR_DIRPATH_SORTED_INDEX:	return "OCI_ATTR_DIRPATH_SORTED_INDEX";/* index that data is sorted on */
																			   /* direct path index maint method (see oci8dp.h) */
	case OCI_ATTR_DIRPATH_INDEX_MAINT_METHOD:	return "OCI_ATTR_DIRPATH_INDEX_MAINT_METHOD";/* parallel load: db file, initial and next extent sizes */

	case OCI_ATTR_DIRPATH_FILE:			return "OCI_ATTR_DIRPATH_FILE";		/* DB file to load into */
	case OCI_ATTR_DIRPATH_STORAGE_INITIAL:		return "OCI_ATTR_DIRPATH_STORAGE_INITIAL";	/* initial extent size */
	case OCI_ATTR_DIRPATH_STORAGE_NEXT:	return "OCI_ATTR_DIRPATH_STORAGE_NEXT";	/* next extent size */


	case OCI_ATTR_TRANS_TIMEOUT:		return "OCI_ATTR_TRANS_TIMEOUT";	/* transaction timeout */
	case OCI_ATTR_SERVER_STATUS:		return "OCI_ATTR_SERVER_STATUS";	/* state of the server handle */
	case OCI_ATTR_STATEMENT:			return "OCI_ATTR_STATEMENT"; 		/* statement txt in stmt hdl */
																			/* statement should not be executed in cache*/
	/*case OCI_ATTR_NO_CACHE:			return "";*/
	case OCI_ATTR_DEQCOND:				return "OCI_ATTR_DEQCOND";			/* dequeue condition */
	case OCI_ATTR_RESERVED_2:			return "OCI_ATTR_RESERVED_2";		/* reserved */


	case OCI_ATTR_SUBSCR_RECPT:			return "OCI_ATTR_SUBSCR_RECPT";		/* recipient of subscription */
	case OCI_ATTR_SUBSCR_RECPTPROTO:	return "OCI_ATTR_SUBSCR_RECPTPROTO";/* protocol for recipient */

	/* 8.2 dpapi support of ADTs */
	case OCI_ATTR_DIRPATH_EXPR_TYPE:	return "OCI_ATTR_DIRPATH_EXPR_TYPE";	/* expr type of OCI_ATTR_NAME */

	case OCI_ATTR_DIRPATH_INPUT:		return "OCI_ATTR_DIRPATH_INPUT";	/* input in text or stream format*/
/*	case OCI_DIRPATH_INPUT_TEXT:				return "";
	case OCI_DIRPATH_INPUT_STREAM:				return "";
	case OCI_DIRPATH_INPUT_UNKNOWN:				return "";	*/
	case OCI_ATTR_LDAP_HOST:			return "OCI_ATTR_LDAP_HOST";		/* LDAP host to connect to */
	case OCI_ATTR_LDAP_PORT:			return "OCI_ATTR_LDAP_PORT";		/* LDAP port to connect to */
	case OCI_ATTR_BIND_DN:				return "OCI_ATTR_BIND_DN";			/* bind DN */
	case OCI_ATTR_LDAP_CRED:			return "OCI_ATTR_LDAP_CRED";		/* credentials to connect to LDAP */
	case OCI_ATTR_WALL_LOC:				return "OCI_ATTR_WALL_LOC";			/* client wallet location */
	case OCI_ATTR_LDAP_AUTH:			return "OCI_ATTR_LDAP_AUTH";		/* LDAP authentication method */
	case OCI_ATTR_LDAP_CTX:				return "OCI_ATTR_LDAP_CTX";			/* LDAP administration context DN */
	case OCI_ATTR_SERVER_DNS:			return "OCI_ATTR_SERVER_DNS";		/* list of registration server DNs */

	case OCI_ATTR_DN_COUNT:				return "OCI_ATTR_DN_COUNT";			/* the number of server DNs */
	case OCI_ATTR_SERVER_DN:			return "OCI_ATTR_SERVER_DN";		/* server DN attribute */

	case OCI_ATTR_MAXCHAR_SIZE:			return "OCI_ATTR_MAXCHAR_SIZE";		/* max char size of data */

	case OCI_ATTR_CURRENT_POSITION:		return "OCI_ATTR_CURRENT_POSITION"; /* for scrollable result sets*/

	/* Added to get attributes for ref cursor to statement handle */
	case OCI_ATTR_RESERVED_3:			return "OCI_ATTR_RESERVED_3";		/* reserved */
	case OCI_ATTR_RESERVED_4:			return "OCI_ATTR_RESERVED_4";		/* reserved */
	case OCI_ATTR_DIRPATH_FN_CTX:		return "";							/* fn ctx ADT attrs or args */
	case OCI_ATTR_DIGEST_ALGO:			return "OCI_ATTR_DIRPATH_FN_CTX";	/* digest algorithm */
	case OCI_ATTR_CERTIFICATE:			return "OCI_ATTR_CERTIFICATE";		/* certificate */
	case OCI_ATTR_SIGNATURE_ALGO:		return "OCI_ATTR_SIGNATURE_ALGO";	/* signature algorithm */
	case OCI_ATTR_CANONICAL_ALGO:		return "OCI_ATTR_CANONICAL_ALGO";	/* canonicalization algo. */
	case OCI_ATTR_PRIVATE_KEY:			return "OCI_ATTR_PRIVATE_KEY";		/* private key */
	case OCI_ATTR_DIGEST_VALUE:			return "OCI_ATTR_DIGEST_VALUE";		/* digest value */
	case OCI_ATTR_SIGNATURE_VAL:		return "OCI_ATTR_SIGNATURE_VAL";	/* signature value */
	case OCI_ATTR_SIGNATURE:			return "OCI_ATTR_SIGNATURE";		/* signature */

	/* attributes for setting OCI stmt caching specifics in svchp */
	case OCI_ATTR_STMTCACHESIZE :		return "OCI_ATTR_STMTCACHESIZE";	/* size of the stm cache */

	/* --------------------------- Connection Pool Attributes ------------------ */
	case OCI_ATTR_CONN_NOWAIT:			return "OCI_ATTR_CONN_NOWAIT";
	case OCI_ATTR_CONN_BUSY_COUNT:		return "OCI_ATTR_CONN_BUSY_COUNT";
	case OCI_ATTR_CONN_OPEN_COUNT:		return "OCI_ATTR_CONN_OPEN_COUNT";
	case OCI_ATTR_CONN_TIMEOUT:			return "OCI_ATTR_CONN_TIMEOUT";
	case OCI_ATTR_STMT_STATE:			return "OCI_ATTR_STMT_STATE";
	case OCI_ATTR_CONN_MIN:				return "OCI_ATTR_CONN_MIN";
	case OCI_ATTR_CONN_MAX:				return "OCI_ATTR_CONN_MAX";
	case OCI_ATTR_CONN_INCR:			return "OCI_ATTR_CONN_INCR";

	case OCI_ATTR_DIRPATH_OID:			return "OCI_ATTR_DIRPATH_OID";		/* loading into an OID col */

	case OCI_ATTR_NUM_OPEN_STMTS:		return "OCI_ATTR_NUM_OPEN_STMTS";	/* open stmts in session */
	case OCI_ATTR_DESCRIBE_NATIVE:		return "OCI_ATTR_DESCRIBE_NATIVE";	/* get native info via desc */

	case OCI_ATTR_BIND_COUNT:			return "OCI_ATTR_BIND_COUNT";		/* number of bind postions */
	case OCI_ATTR_HANDLE_POSITION:		return "OCI_ATTR_HANDLE_POSITION";	/* pos of bind/define handle */
	case OCI_ATTR_RESERVED_5:			return "OCI_ATTR_RESERVED_5";		/* reserved */
	case OCI_ATTR_SERVER_BUSY:			return "OCI_ATTR_SERVER_BUSY";		/* call in progress on server*/

	case OCI_ATTR_DIRPATH_SID:			return "OCI_ATTR_DIRPATH_SID";		/* loading into an SID col */
	/* notification presentation for recipient */
	case OCI_ATTR_SUBSCR_RECPTPRES:		return "OCI_ATTR_SUBSCR_RECPTPRES";
	case OCI_ATTR_TRANSFORMATION:		return "OCI_ATTR_TRANSFORMATION"; 	/* AQ message transformation */

	case OCI_ATTR_ROWS_FETCHED:			return "OCI_ATTR_ROWS_FETCHED";		/* rows fetched in last call */

	/* --------------------------- Snapshot attributes ------------------------- */
	case OCI_ATTR_SCN_BASE:				return "OCI_ATTR_SCN_BASE";			/* snapshot base */
	case OCI_ATTR_SCN_WRAP:				return "OCI_ATTR_SCN_WRAP";			/* snapshot wrap */

	/* --------------------------- Miscellaneous attributes --------------------- */
	case OCI_ATTR_RESERVED_6:			return "OCI_ATTR_RESERVED_6";		/* reserved */
	case OCI_ATTR_READONLY_TXN:			return "OCI_ATTR_READONLY_TXN";		/* txn is readonly */
	case OCI_ATTR_RESERVED_7:			return "OCI_ATTR_RESERVED_7";		/* reserved */
	case OCI_ATTR_ERRONEOUS_COLUMN:		return "OCI_ATTR_ERRONEOUS_COLUMN"; /* position of erroneous col */
	case OCI_ATTR_RESERVED_8:			return "OCI_ATTR_RESERVED_8";		/* reserved */

	/* -------------------- 8.2 dpapi support of ADTs continued ---------------- */
	case OCI_ATTR_DIRPATH_OBJ_CONSTR:	return "OCI_ATTR_DIRPATH_OBJ_CONSTR"; /* obj type of subst obj tbl */

	/************************FREE attribute     207      *************************/
	/************************FREE attribute     208      *************************/
	case OCI_ATTR_ENV_UTF16:			return "OCI_ATTR_ENV_UTF16";		/* is env in utf16 mode? */
	case OCI_ATTR_RESERVED_9:			return "OCI_ATTR_RESERVED_9";		/* reserved for TMZ */
	case OCI_ATTR_RESERVED_10:			return "OCI_ATTR_RESERVED_10";		/* reserved */

	/* Attr to allow setting of the stream version PRIOR to calling Prepare */
	case OCI_ATTR_DIRPATH_STREAM_VERSION:	return "OCI_ATTR_DIRPATH_STREAM_VERSION";	/* version of the stream*/
/*	case OCI_ATTR_RESERVED_11:				return "OCI_ATTR_RESERVED_11";	reserved */

	case OCI_ATTR_RESERVED_12:			return "OCI_ATTR_RESERVED_12";		/* reserved */
	case OCI_ATTR_RESERVED_13:			return "OCI_ATTR_RESERVED_13";		/* reserved */

	/* OCI_ATTR_RESERVED_14 */
#ifdef OCI_ATTR_RESERVED_15
	case OCI_ATTR_RESERVED_15:			return "OCI_ATTR_RESERVED_15";		/* reserved */
#endif
#ifdef OCI_ATTR_RESERVED_16
	case OCI_ATTR_RESERVED_16:			return "OCI_ATTR_RESERVED_16";		/* reserved */
#endif

	}
	sv = sv_2mortal(newSViv((IV)attr));
	return SvPV(sv,PL_na);
}

/*used to look up the name of a fetchtype constant
  used only for debugging */
char *
oci_fetch_options(ub4 fetchtype)
{
	dTHX;
	SV *sv;
	switch (fetchtype) {
	/* fetch options */
		case OCI_FETCH_CURRENT:		return "OCI_FETCH_CURRENT";
		case OCI_FETCH_NEXT:		return "OCI_FETCH_NEXT";
		case OCI_FETCH_FIRST:		return "OCI_FETCH_FIRST";
		case OCI_FETCH_LAST:		return "OCI_FETCH_LAST";
		case OCI_FETCH_PRIOR:		return "OCI_FETCH_PRIOR";
		case OCI_FETCH_ABSOLUTE:	return "OCI_FETCH_ABSOLUTE";
		case OCI_FETCH_RELATIVE:	return "OCI_FETCH_RELATIVE";
	}
	sv = sv_2mortal(newSViv((IV)fetchtype));
	return SvPV(sv,PL_na);
}




static sb4
oci_error_get(imp_xxh_t *imp_xxh,
              OCIError *errhp, sword status, char *what, SV *errstr, int debug)
{
	dTHX;
	text errbuf[1024];
	ub4 recno = 0;
	sb4 errcode = 0;
	sb4 eg_errcode = 0;
	sword eg_status;

	if (!SvOK(errstr))
		sv_setpv(errstr,"");

	if (!errhp) {
		sv_catpv(errstr, oci_status_name(status));
		if (what) {
			sv_catpv(errstr, " ");
			sv_catpv(errstr, what);
		}
		return status;
	}

	while( ++recno
           && OCIErrorGet_log_stat(imp_xxh, errhp, recno, (text*)NULL, &eg_errcode, errbuf,
		(ub4)sizeof(errbuf), OCI_HTYPE_ERROR, eg_status) != OCI_NO_DATA
		&& eg_status != OCI_INVALID_HANDLE
		&& recno < 100) {
		if (debug >= 4 || recno>1/*XXX temp*/)
			PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                          "	OCIErrorGet after %s (er%ld:%s): %d, %ld: %s\n",
			what ? what : "<NULL>", (long)recno,
			(eg_status==OCI_SUCCESS) ? "ok" : oci_status_name(eg_status),
			status, (long)eg_errcode, errbuf);

		errcode = eg_errcode;
		sv_catpv(errstr, (char*)errbuf);

		if (*(SvEND(errstr)-1) == '\n')
			--SvCUR(errstr);
	}

	if (what || status != OCI_ERROR) {
		sv_catpv(errstr, (debug<0) ? " (" : " (DBD ");
		sv_catpv(errstr, oci_status_name(status));
		if (what) {
			sv_catpv(errstr, ": ");
			sv_catpv(errstr, what);
		}
		sv_catpv(errstr, ")");
	}
	return errcode;
}


int
oci_error_err(SV *h, OCIError *errhp, sword status, char *what, sb4 force_err)
{

	dTHX;
	D_imp_xxh(h);
	sb4 errcode;
        int utf8_is_implied = 0;
	SV *errstr_sv = sv_newmortal();
	SV *errcode_sv = sv_newmortal();
	errcode = oci_error_get(imp_xxh, errhp, status, what, errstr_sv,
                            DBIc_DBISTATE(imp_xxh)->debug);

        if(DBIc_TYPE(imp_xxh) == DBIt_ST)
        {
            imp_sth_t * imp_sth = (imp_sth_t*)imp_xxh;
            D_imp_dbh_from_sth;
            utf8_is_implied = CSFORM_IMPLIES_UTF8(imp_dbh, SQLCS_IMPLICIT);
        }
        else if(DBIc_TYPE(imp_xxh) == DBIt_DB)
            utf8_is_implied = CSFORM_IMPLIES_UTF8((imp_dbh_t *)imp_xxh, SQLCS_IMPLICIT);
        else if(DBIc_TYPE(imp_xxh) == DBIt_DR)
            utf8_is_implied = 0;

	if (utf8_is_implied) {
#ifdef sv_utf8_decode
            sv_utf8_decode(errstr_sv);
#else
            SvUTF8_on(errstr_sv);
#endif
	}

	/* DBIc_ERR *must* be SvTRUE (for RaiseError etc), some */
	/* errors, like OCI_INVALID_HANDLE, don't set errcode. */
	if (force_err)
		errcode = force_err;
	if (status == OCI_SUCCESS_WITH_INFO)
		errcode = 0; /* record as a "warning" for DBI>=1.43 */
	else if (errcode == 0)
		errcode = (status != 0) ? status : -10000;

	sv_setiv(errcode_sv, errcode);
	DBIh_SET_ERR_SV(h, imp_xxh, errcode_sv, errstr_sv, &PL_sv_undef, &PL_sv_undef);
	return 0; /* always returns 0 */

}


char *
ora_sql_error(imp_sth_t *imp_sth, char *msg)
{
	dTHX;
#ifdef OCI_ATTR_PARSE_ERROR_OFFSET
	D_imp_dbh_from_sth;
	SV  *msgsv, *sqlsv;
	char buf[99];
	sword status = 0;
	ub2 parse_error_offset = 0;
	OCIAttrGet_stmhp_stat(imp_sth, &parse_error_offset, 0,
						  OCI_ATTR_PARSE_ERROR_OFFSET, status);
	imp_dbh->parse_error_offset = parse_error_offset;
	if (!parse_error_offset)
		return msg;
	sprintf(buf,"error possibly near <*> indicator at char %d in '",
		parse_error_offset);
	msgsv = sv_2mortal(newSVpv(buf,0));
	sqlsv = sv_2mortal(newSVpv(imp_sth->statement,0));
	sv_insert(sqlsv, parse_error_offset, 0, "<*>", 3);
	sv_catsv(msgsv, sqlsv);
	sv_catpv(msgsv, "'");
	return SvPV(msgsv,PL_na);
#else
	imp_sth = imp_sth; /* not unused */
	return msg;
#endif
}


void *
oci_db_handle(imp_dbh_t *imp_dbh, int handle_type, int flags)
{
	dTHX;
	 switch(handle_type) {
	 	case OCI_HTYPE_ENV:		return imp_dbh->envhp;
	 	case OCI_HTYPE_ERROR:	return imp_dbh->errhp;
	 	case OCI_HTYPE_SERVER:	return imp_dbh->srvhp;
	 	case OCI_HTYPE_SVCCTX:	return imp_dbh->svchp;
	 	case OCI_HTYPE_SESSION:	return imp_dbh->seshp;
	 	/*case OCI_HTYPE_AUTHINFO:return imp_dbh->authp;*/
	 }
	 croak("Can't get OCI handle type %d from DBI database handle", handle_type);
	 if( flags ) {/* For GCC not to warn on unused parameter */}
	 /* satisfy compiler warning, even though croak will never return */
	 return 0;
}

void *
oci_st_handle(imp_sth_t *imp_sth, int handle_type, int flags)
{
	dTHX;
	 switch(handle_type) {
	 	case OCI_HTYPE_ENV:		return imp_sth->envhp;
		case OCI_HTYPE_ERROR:	return imp_sth->errhp;
	 	case OCI_HTYPE_SERVER:	return imp_sth->srvhp;
	 	case OCI_HTYPE_SVCCTX:	return imp_sth->svchp;
	 	case OCI_HTYPE_STMT:	return imp_sth->stmhp;
	 }
	 croak("Can't get OCI handle type %d from DBI statement handle", handle_type);
	 if( flags ) {/* For GCC not to warn on unused parameter */}
	 /* satisfy compiler warning, even though croak will never return */
	 return 0;
}


int
dbd_st_prepare(SV *sth, imp_sth_t *imp_sth, char *statement, SV *attribs)
{
	dTHX;
	D_imp_dbh_from_sth;
	sword status 		 = 0;
	IV  ora_piece_size	 = 0;
	IV  ora_pers_lob	 = 0;
	IV  ora_piece_lob	 = 0;
	IV  ora_clbk_lob	 = 0;
	int ora_check_sql 	 = 1;	/* to force a describe to check SQL	*/
	IV  ora_placeholders = 1;	/* find and handle placeholders */
	/* XXX we set ora_check_sql on for now to force setup of the	*/
	/* row cache. Change later to set up row cache using just a	*/
	/* a memory size, perhaps also default $RowCacheSize to a	*/
	/* negative value. OCI_ATTR_PREFETCH_MEMORY */


	if (!DBIc_ACTIVE(imp_dbh)) {
		oci_error(sth, NULL, OCI_ERROR, "Database disconnected");
		return 0;
	}

	imp_dbh->parse_error_offset = 0;

	imp_sth->done_desc = 0;
	imp_sth->get_oci_handle = oci_st_handle;

	if (DBIc_COMPAT(imp_sth)) {
		static SV *ora_pad_empty;
		if (!ora_pad_empty) {
			ora_pad_empty= perl_get_sv("Oraperl::ora_pad_empty", GV_ADDMULTI);
			if (!SvOK(ora_pad_empty) && getenv("ORAPERL_PAD_EMPTY"))
				sv_setiv(ora_pad_empty, atoi(getenv("ORAPERL_PAD_EMPTY")));
		}
		imp_sth->ora_pad_empty = (SvOK(ora_pad_empty)) ? SvIV(ora_pad_empty) : 0;
	}

	imp_sth->auto_lob = 1;
	imp_sth->exe_mode  = OCI_DEFAULT;

	if (attribs) {
		SV **svp;
		IV ora_auto_lob = 1;
		DBD_ATTRIB_GET_IV(  attribs, "ora_placeholders", 16, svp, ora_placeholders);
		DBD_ATTRIB_GET_IV(  attribs, "ora_auto_lob", 12, svp, ora_auto_lob);
		DBD_ATTRIB_GET_IV(  attribs, "ora_pers_lob", 12, svp, ora_pers_lob);
		DBD_ATTRIB_GET_IV(  attribs, "ora_clbk_lob", 12, svp, ora_clbk_lob);
		DBD_ATTRIB_GET_IV(  attribs, "ora_piece_lob", 13, svp, ora_piece_lob);
		DBD_ATTRIB_GET_IV(  attribs, "ora_piece_size", 14, svp, ora_piece_size);

		imp_sth->auto_lob	= (ora_auto_lob) ? 1 : 0;
		imp_sth->pers_lob	= (ora_pers_lob) ? 1 : 0;
		imp_sth->clbk_lob 	= (ora_clbk_lob) ? 1 : 0;
		imp_sth->piece_lob	= (ora_piece_lob) ? 1 : 0;
		imp_sth->piece_size	= (ora_piece_size) ? ora_piece_size : 0;
		imp_sth->prefetch_rows 	= 0;
		imp_sth->prefetch_memory= 0;
		/* ora_check_sql only works for selects owing to Oracle behaviour */
		DBD_ATTRIB_GET_IV(  attribs, "ora_check_sql", 13, svp, ora_check_sql);
		DBD_ATTRIB_GET_IV(  attribs, "ora_exe_mode", 12, svp, imp_sth->exe_mode);
		DBD_ATTRIB_GET_IV(  attribs, "ora_prefetch_memory",  19, svp, imp_sth->prefetch_memory);
		DBD_ATTRIB_GET_IV(  attribs, "ora_prefetch_rows",  17, svp, imp_sth->prefetch_rows);
		DBD_ATTRIB_GET_IV(  attribs, "ora_row_cache_off",  17, svp, imp_sth->row_cache_off);
		DBD_ATTRIB_GET_IV(  attribs, "ora_verbose",  11, svp, dbd_verbose);
		DBD_ATTRIB_GET_IV(  attribs, "ora_oci_success_warn",  20, svp, oci_warn);
		DBD_ATTRIB_GET_IV(  attribs, "ora_objects",  11, svp, ora_objects);
		DBD_ATTRIB_GET_IV(  attribs, "ora_ncs_buff_mtpl",  17, svp,ora_ncs_buff_mtpl);
        DBD_ATTRIB_GET_IV(  attribs, "RowCacheSize",12,svp, imp_sth->RowCacheSize);

		if (!dbd_verbose)
			DBD_ATTRIB_GET_IV(  attribs, "dbd_verbose",  11, svp, dbd_verbose);
	}


 	/* scan statement for '?', ':1' and/or ':foo' style placeholders	*/
	if (ora_placeholders)
		dbd_preparse(imp_sth, statement);
	else imp_sth->statement = savepv(statement);

	imp_sth->envhp = imp_dbh->envhp;
	imp_sth->errhp = imp_dbh->errhp;
	imp_sth->srvhp = imp_dbh->srvhp;
	imp_sth->svchp = imp_dbh->svchp;



	OCIHandleAlloc_ok(imp_dbh, imp_dbh->envhp, &imp_sth->stmhp, OCI_HTYPE_STMT, status);
	OCIStmtPrepare_log_stat(imp_sth, imp_sth->stmhp, imp_sth->errhp,
			(text*)imp_sth->statement, (ub4)strlen(imp_sth->statement),
			OCI_NTV_SYNTAX, OCI_DEFAULT, status);

	if (status != OCI_SUCCESS) {
		oci_error(sth, imp_sth->errhp, status, "OCIStmtPrepare");
		OCIHandleFree_log_stat(imp_sth, imp_sth->stmhp, OCI_HTYPE_STMT, status);

		return 0;
	}


	OCIAttrGet_stmhp_stat(imp_sth, &imp_sth->stmt_type, 0, OCI_ATTR_STMT_TYPE, status);

	if (DBIc_DBISTATE(imp_sth)->debug >= 3 || dbd_verbose >= 3 )
		PerlIO_printf(
            DBIc_LOGPIO(imp_sth),
            "	dbd_st_prepare'd sql %s ( auto_lob%d, check_sql%d)\n",
			oci_stmt_type_name(imp_sth->stmt_type),
			imp_sth->auto_lob, ora_check_sql);

	DBIc_IMPSET_on(imp_sth);

	if (ora_check_sql) {
		if (!dbd_describe(sth, imp_sth))
			return 0;
	}

	return 1;
}


sb4
dbd_phs_in(dvoid *octxp, OCIBind *bindp, ub4 iter, ub4 index,
		  dvoid **bufpp, ub4 *alenp, ub1 *piecep, dvoid **indpp)
{
	dTHX;
	phs_t *phs = (phs_t*)octxp;
	STRLEN phs_len;
	AV *tuples_av;
	SV *sv;
	AV *av;
	SV **sv_p;
	if( bindp ){ /* For GCC not to warn on unused parameter*/ }

	tuples_av = phs->imp_sth->bind_tuples;
	if(tuples_av) {
		/* NOTE: we already checked the validity in ora_st_bind_for_array_exec(). */
		sv_p = av_fetch(tuples_av, phs->imp_sth->rowwise ? (int)iter : phs->idx, 0);
		av = (AV*)SvRV(*sv_p);
		sv_p = av_fetch(av, phs->imp_sth->rowwise ? phs->idx : (int)iter, 0);
		sv = *sv_p;
		if(SvOK(sv)) {
			*bufpp = SvPV(sv, phs_len);
			phs->alen = (phs->alen_incnull) ? phs_len+1 : phs_len;
			phs->indp = 0;
		}
		else {
			*bufpp = SvPVX(sv);
			phs->alen = 0;
			phs->indp = -1;
		}
	}
	else
		if (phs->desc_h) {
			*bufpp  = phs->desc_h;
			phs->alen = 0;
			phs->indp = 0;
		}
		else
			if (SvOK(phs->sv)) {
				*bufpp  = SvPV(phs->sv, phs_len);
				phs->alen = (phs->alen_incnull) ? phs_len+1 : phs_len;;
				phs->indp = 0;
			}
			else {
				*bufpp  = SvPVX(phs->sv);	/* not actually used? */
				phs->alen = 0;
				phs->indp = -1;
			}
	*alenp  = phs->alen;
	*indpp  = &phs->indp;
	*piecep = OCI_ONE_PIECE;
	/* MJE commented out as we are avoiding DBIS now but as this is
	   an Oracle callback there is no way to pass something non
	   OCI into this func.

	if (DBIS->debug >= 3 || dbd_verbose >= 3 )
		PerlIO_printf(DBILOGFP, "		in  '%s' [%lu,%lu]: len %2lu, ind %d%s, value=%s\n",
			phs->name, ul_t(iter), ul_t(index), ul_t(phs->alen), phs->indp,
			(phs->desc_h) ? " via descriptor" : "",neatsvpv(phs->sv,10));
	*/
	if (!tuples_av && (index > 0 || iter > 0))
		croak(" Arrays and multiple iterations not currently supported by DBD::Oracle (in %d/%d)", index,iter);

	return OCI_CONTINUE;
}

/*
``Binding and Defining''

Binding RETURNING...INTO variables

As mentioned in the previous section, an OCI application implements the placeholders in the RETURNING clause as
pure OUT bind variables. An application must adhere to the following rules when working with these bind variables:

  1.Bind RETURNING clause placeholders in OCI_DATA_AT_EXEC mode using OCIBindByName() or
	OCIBindByPos(), followed by a call to OCIBindDynamic() for each placeholder.

	Note: The OCI only supports the callback mechanism for RETURNING clause binds. The polling mechanism is
	not supported.

  2.When binding RETURNING clause placeholders, you must supply a valid out bind function as the ocbfp
	parameter of the OCIBindDynamic() call. This function must provide storage to hold the returned data.
  3.The icbfp parameter of OCIBindDynamic() call should provide a "dummy" function which returns NULL values
	when called.
  4.The piecep parameter of OCIBindDynamic() must be set to OCI_ONE_PIECE.
  5.No duplicate binds are allowed in a DML statement with a RETURNING clause (i.e., no duplication between bind
	variables in the DML section and the RETURNING section of the statement).

When a callback function is called, the OCI_ATTR_ROWS_RETURNED attribute of the bind handle tells the
application the number of rows being returned in that particular iteration. Thus, when the callback is called the first
time in a particular iteration (i.e., index=0), the user can allocate space for all the rows which will be returned for that
bind variable. When the callback is called subsequently (with index>0) within the same iteration, the user can merely
increment the buffer pointer to the correct memory within the allocated space to retrieve the data.

Every bind handle has a OCI_ATTR_MAXDATA_SIZE attribute. This attribute specifies the number of bytes to be
allocated on the server to accommodate the client-side bind data after any necessary character set conversions.

	Note: Character set conversions performed when data is sent to the server may result in the data expanding or
	contracting, so its size on the client may not be the same as its size on the server.

An application will typically set OCI_ATTR_MAXDATA_SIZE to the maximum size of the column or the size of the
PL/SQL variable, depending on how it is used. Oracle issues an error if OCI_ATTR_MAXDATA_SIZE is not a large
enough value to accommodate the data after conversion, and the operation will fail.
*/

sb4
dbd_phs_out(dvoid *octxp, OCIBind *bindp,
	ub4 iter,	/* execution itteration (0...)	*/
	ub4 index,	/* array index (0..)		*/
	dvoid **bufpp,	/* A pointer to a buffer to write the bind value/piece.	*/
	ub4 **alenpp,	/* A pointer to a storage for OCI to fill in the size	*/
			/* of the bind value/piece after it has been read.	*/
	ub1 *piecep,	/* */
	dvoid **indpp,	/* Return a pointer to contain the indicator value which either an sb2	*/
			/* value or a pointer to an indicator structure for named data types.	*/
	ub2 **rcodepp)	/* Returns a pointer to contains the return code.	*/
{
	dTHX;
	phs_t *phs = (phs_t*)octxp;	/* context */
	/*imp_sth_t *imp_sth = phs->imp_sth;*/
	if( bindp ) { /* For GCC not to warn on unused parameter */ }

	if (phs->desc_h) { /* a  descriptor if present  (LOBs etc)*/
		*bufpp  = phs->desc_h;
		phs->alen = 0;

	}
	else {
		SV *sv = phs->sv;

		if (SvTYPE(sv) == SVt_RV && SvTYPE(SvRV(sv)) == SVt_PVAV) {
			sv = *av_fetch((AV*)SvRV(sv), (IV)iter, 1);
			if (!SvOK(sv))
				sv_setpv(sv,"");
		}

        *bufpp = SvGROW(sv, (size_t)(((phs->maxlen < 28) ? 28 : phs->maxlen)));
		phs->alen = SvLEN(sv);	/* max buffer size now, actual data len later */

	}
	*alenpp = &phs->alen;
	*indpp  = &phs->indp;
	*rcodepp= &phs->arcode;
    /* MJE commented out as we are avoiding DBIS now but as this is
       an Oracle callback there is no way to pass something non
       OCI into this func.

	if (DBIS->debug >= 3 || dbd_verbose >= 3 )
 		PerlIO_printf(DBILOGFP, "		out '%s' [%ld,%ld]: alen %2ld, piece %d%s\n",
			phs->name, ul_t(iter), ul_t(index), ul_t(phs->alen), *piecep,
			(phs->desc_h) ? " via descriptor" : "");
    */
	*piecep = OCI_ONE_PIECE;
	return OCI_CONTINUE;
}

/* --------------------------------------------------------------
	Fetch callback fill buffers.
	Finaly figured out how this fucntion works
	Seems it is like this. The function inits and then fills the
	buffer (fb_ary->abuf) with the data from the select until it
	either runs out of data or its piece size is reached
	(fb_ary->bufl).  If its piece size is reached it then goes and gets
	the the next piece and sets *piecep ==OCI_NEXT_PIECE at this point
	I take the data in the buffer and memcpy it onto my buffer
	(fb_ary->cb_abuf). This will go on until it runs out of full pieces
	so when it returns to back to the fetch I add what remains in
	(fb_ary->bufl) (the last piece) and memcpy onto my  buffer (fb_ary->cb_abuf)
	to get it all.  I also take set fb_ary->cb_abuf back to empty just
	to keep things clean
 -------------------------------------------------------------- */
sb4
presist_lob_fetch_cbk(dvoid *octxp, OCIDefine *dfnhp, ub4 iter, dvoid **bufpp,
					  ub4 **alenpp, ub1 *piecep, dvoid **indpp, ub2 **rcpp)
{
	dTHX;
	imp_fbh_t	*fbh =(imp_fbh_t*)octxp;
	fb_ary_t	*fb_ary;
	fb_ary	= fbh->fb_ary;
	*bufpp	= (dvoid *) fb_ary->abuf;
	*alenpp	= &fb_ary->bufl;
	*indpp	= (dvoid *) fb_ary->aindp;
	*rcpp	= fb_ary->arcode;


	if (dbd_verbose >= 5 ) {
		PerlIO_printf(DBILOGFP, " In presist_lob_fetch_cbk\n");
	}

	if ( *piecep ==OCI_NEXT_PIECE ){/*more than one piece*/

		memcpy(fb_ary->cb_abuf+fb_ary->piece_count*fb_ary->bufl,fb_ary->abuf,fb_ary->bufl );
	/*as we will be using both blobs and clobs we have to use
	  pointer arithmetic to get the values right.  in this case we simply
	  copy all of the memory of the buff into the cb buffer starting
	  at the piece count * the  buffer length
	  */

		fb_ary->piece_count++;/*used to tell me how many pieces I have, Might be able to use aindp for this?*/

	}


	return OCI_CONTINUE;

}

/* TAF or Transparent Application Failoever callback
   Works like this.  The fuction below is registered on the server,
   when the server is set up to use it, when an exe is called (not sure about other server round trips)
   and the server fails tt should get into this cbk error below.
   It will wait X seconds and then try to reconnect (up to n times if that is the users choice)
   That is how I see it working */

sb4
taf_cbk(dvoid *svchp, dvoid *envhp, dvoid *fo_ctx,ub4 fo_type, ub4 fo_event )
{
	dTHX;
    int return_count;
    int ret;
	taf_callback_t *cb =(taf_callback_t*)fo_ctx;

	dSP;
	PUSHMARK(SP);
	XPUSHs(sv_2mortal(newSViv(fo_event)));
	XPUSHs(sv_2mortal(newSViv(fo_type)));
    XPUSHs(SvRV(cb->dbh_ref));

	PUTBACK;
	return_count = call_sv(cb->function, G_SCALAR);

    SPAGAIN;

    if (return_count != 1)
        croak("Expected one scalar back from taf handler");

    ret = POPi;

	switch (fo_event){

		case OCI_FO_BEGIN:
		case OCI_FO_ABORT:
		case OCI_FO_END:
		case OCI_FO_REAUTH:
		{
			break;
		}
		case OCI_FO_ERROR:
		{
            if (ret == OCI_FO_RETRY) {
                return OCI_FO_RETRY;
            }
			break;
		}

		default:
		{
			break;
		}
	}
    PUTBACK;

	return 0;
}


sb4
reg_taf_callback(SV *dbh, imp_dbh_t *imp_dbh)
{
	dTHX;
	OCIFocbkStruct 	tafailover;
	sword 			status;

    imp_dbh->taf_ctx.function = imp_dbh->taf_function;
    imp_dbh->taf_ctx.dbh_ref = newRV_inc(dbh);

	if (dbd_verbose >= 5 ) {
  		PerlIO_printf(DBIc_LOGPIO(imp_dbh), " In reg_taf_callback\n");
	}

/* set the context up as a pointer to the taf callback struct*/
	tafailover.fo_ctx = &imp_dbh->taf_ctx;
	tafailover.callback_function = &taf_cbk;

/* register the callback */
	OCIAttrSet_log_stat(imp_dbh, imp_dbh->srvhp, (ub4) OCI_HTYPE_SERVER,
                        (dvoid *) &tafailover, (ub4) 0,
                        (ub4) OCI_ATTR_FOCBK, imp_dbh->errhp, status);

	return status;
}

#ifdef UTF8_SUPPORT
/* How many bytes are n utf8 chars in buffer */
static ub4
ora_utf8_to_bytes (ub1 *buffer, ub4 chars_wanted, ub4 max_bytes)
{
	dTHX;
	ub4 i = 0;
	while (i < max_bytes && (chars_wanted-- > 0)) {
		i += UTF8SKIP(&buffer[i]);
	}
	return (i < max_bytes)? i : max_bytes;
}


#if 0 /* save this for later just in case... */
/* Given the 5.6.0 implementation of utf8 handling in perl,
 * avoid setting the UTF8 flag as much as possible. Almost
 * every binary operator in Perl will do conversions when
 * strings marked as UTF8 are involved.
 * Maybe setting the flag should be default in Japan or
 * Europe? Deduce that from NLS_LANG? Possibly...
 */

int
set_utf8(SV *sv) {
	ub1 *c;
	for (c = (ub1*)SvPVX(sv); c < (ub1*)SvEND(sv); c++) {
		if (*c & 0x80) {
			SvUTF8_on(sv);
			return 1;
		}
	}
	return 0;
}
#endif
#endif

