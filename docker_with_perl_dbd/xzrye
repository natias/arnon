            "guint\n" "%s_override_properties (GObjectClass *klass" % (i.name_lower)
        )
        if len(i.properties) == 0:
            self.outfile.write(" G_GNUC_UNUSED")
        self.outfile.write(", guint property_id_begin)\n" "{\n")
        for p in i.properties:
            self.outfile.write(
                '  g_object_class_override_property (klass, property_id_begin++, "%s");\n'
                % (p.name_hyphen)
            )
        self.outfile.write("  return property_id_begin - 1;\n" "}\n" "\n")
        self.outfile.write("\n")

    # ----------------------------------------------------------------------------------------------------

    def generate_interface(self, i):
        self.outfile.write("\n")

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %s:\n"
                " *\n"
                " * Abstract interface type for the D-Bus interface #%s.\n"
                % (i.camel_name, i.name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write("\n")

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sIface:\n"
                " * @parent_iface: The parent interface.\n" % (i.camel_name),
                False,
            )
        )

        doc_bits = {}
        if len(i.methods) > 0:
            for m in i.methods:
                key = (m.since, "_method_%s" % m.name_lower)
                value = "@handle_%s: " % (m.name_lower)
                value += "Handler for the #%s::handle-%s signal." % (
                    i.camel_name,
                    m.name_hyphen,
                )
                doc_bits[key] = value
        if len(i.signals) > 0:
            for s in i.signals:
                key = (s.since, "_signal_%s" % s.name_lower)
                value = "@%s: " % (s.name_lower)
                value += "Handler for the #%s::%s signal." % (
                    i.camel_name,
                    s.name_hyphen,
                )
                doc_bits[key] = value
        if len(i.properties) > 0:
            for p in i.properties:
                key = (p.since, "_prop_get_%s" % p.name_lower)
                value = "@get_%s: " % (p.name_lower)
                value += "Getter for the #%s:%s property." % (
                    i.camel_name,
                    p.name_hyphen,
                )
                doc_bits[key] = value
        for key in sorted(doc_bits.keys(), key=utils.version_cmp_key):
            self.outfile.write(" * %s\n" % doc_bits[key])

        self.outfile.write(
            self.docbook_gen.expand(
                " *\n" " * Virtual table for the D-Bus interface #%s.\n" % (i.name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write("\n")

        self.outfile.write(
            "typedef %sIface %sInterface;\n" % (i.camel_name, i.camel_name)
        )
        self.outfile.write(
            "G_DEFINE_INTERFACE (%s, %s, G_TYPE_OBJECT)\n"
            % (i.camel_name, i.name_lower)
        )
        self.outfile.write("\n")

        self.outfile.write(
            "static void\n"
            "%s_default_init (%sIface *iface" % (i.name_lower, i.camel_name)
        )
        if len(i.methods) == 0 and len(i.signals) == 0 and len(i.properties) == 0:
            self.outfile.write(" G_GNUC_UNUSED)\n")
        else:
            self.outfile.write(")\n")
        self.outfile.write("{\n")
        if len(i.methods) > 0:
            self.outfile.write(
                "  /* GObject signals for incoming D-Bus method calls: */\n"
            )
            for m in i.methods:
                self.outfile.write(
                    self.docbook_gen.expand(
                        "  /**\n"
                        "   * %s::handle-%s:\n"
                        "   * @object: A #%s.\n"
                        "   * @invocation: A #GDBusMethodInvocation.\n"
                        % (i.camel_name, m.name_hyphen, i.camel_name),
                        False,
                    )
                )
                if m.unix_fd:
                    self.outfile.write(
                        "   * @fd_list: (nullable): A #GUnixFDList or %NULL.\n"
                    )
                for a in m.in_args:
                    self.outfile.write(
                        "   * @arg_%s: Argument passed by remote caller.\n" % (a.name)
                    )
                self.outfile.write(
                    self.docbook_gen.expand(
                        "   *\n"
                        "   * Signal emitted when a remote caller is invoking the %s.%s() D-Bus method.\n"
                        "   *\n"
                        "   * If a signal handler returns %%TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call %s_complete_%s() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %%G_DBUS_ERROR_UNKNOWN_METHOD error is returned.\n"
                        "   *\n"
                        "   * Returns: %%G_DBUS_METHOD_INVOCATION_HANDLED or %%TRUE if the invocation was handled, %%G_DBUS_METHOD_INVOCATION_UNHANDLED or %%FALSE to let other signal handlers run.\n"
                        % (i.name, m.name, i.name_lower, m.name_lower),
                        False,
                    )
                )
                self.write_gtkdoc_deprecated_and_since_and_close(m, self.outfile, 2)
                if m.unix_fd:
                    extra_args = 2
                else:
                    extra_args = 1
                self.outfile.write(
                    '  g_signal_new ("handle-%s",\n'
                    "    G_TYPE_FROM_INTERFACE (iface),\n"
                    "    G_SIGNAL_RUN_LAST,\n"
                    "    G_STRUCT_OFFSET (%sIface, handle_%s),\n"
                    "    g_signal_accumulator_true_handled,\n"
                    "    NULL,\n"  # accu_data
                    "    g_cclosure_marshal_generic,\n"
                    "    G_TYPE_BOOLEAN,\n"
                    "    %d,\n"
                    "    G_TYPE_DBUS_METHOD_INVOCATION"
                    % (
                        m.name_hyphen,
                        i.camel_name,
                        m.name_lower,
                        len(m.in_args) + extra_args,
                    )
                )
                if m.unix_fd:
                    self.outfile.write(", G_TYPE_UNIX_FD_LIST")
                for a in m.in_args:
                    self.outfile.write(", %s" % (a.gtype))
                self.outfile.write(");\n")
                self.outfile.write("\n")

        if len(i.signals) > 0:
            self.outfile.write("  /* GObject signals for received D-Bus signals: */\n")
            for s in i.signals:
                self.outfile.write(
                    self.docbook_gen.expand(
                        "  /**\n"
                        "   * %s::%s:\n"
                        "   * @object: A #%s.\n"
                        % (i.camel_name, s.name_hyphen, i.camel_name),
                        False,
                    )
                )
                for a in s.args:
                    self.outfile.write("   * @arg_%s: Argument.\n" % (a.name))
                self.outfile.write(
                    self.docbook_gen.expand(
                        "   *\n"
                        "   * On the client-side, this signal is emitted whenever the D-Bus signal #%s::%s is received.\n"
                        "   *\n"
                        "   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.\n"
                        % (i.name, s.name),
                        False,
                    )
                )
                self.write_gtkdoc_deprecated_and_since_and_close(s, self.outfile, 2)
                self.outfile.write(
                    '  g_signal_new ("%s",\n'
                    "    G_TYPE_FROM_INTERFACE (iface),\n"
                    "    G_SIGNAL_RUN_LAST,\n"
                    "    G_STRUCT_OFFSET (%sIface, %s),\n"
                    "    NULL,\n"  # accumulator
                    "    NULL,\n"  # accu_data
                    "    g_cclosure_marshal_generic,\n"
                    "    G_TYPE_NONE,\n"
                    "    %d" % (s.name_hyphen, i.camel_name, s.name_lower, len(s.args))
                )
                for a in s.args:
                    self.outfile.write(", %s" % (a.gtype))
                self.outfile.write(");\n")
                self.outfile.write("\n")

        if len(i.properties) > 0:
            self.outfile.write("  /* GObject properties for D-Bus properties: */\n")
            for p in i.properties:
                if p.readable and p.writable:
                    hint = "Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side."
                elif p.readable:
                    hint = "Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side."
                elif p.writable:
                    hint = "Since the D-Bus property for this #GObject property is writable but not readable, it is meaningful to write to it on both the client- and service-side. It is only meaningful, however, to read from it on the service-side."
                else:
                    print_error(
                        'Cannot handle property "{}" that neither readable nor writable'.format(
                            p.name
                        )
                    )
                self.outfile.write(
                    self.docbook_gen.expand(
                        "  /**\n"
                        "   * %s:%s:\n"
                        "   *\n"
                        "   * Represents the D-Bus property #%s:%s.\n"
                        "   *\n"
                        "   * %s\n"
                        % (i.camel_name, p.name_hyphen, i.name, p.name, hint),
                        False,
                    )
                )
                self.write_gtkdoc_deprecated_and_since_and_close(p, self.outfile, 2)
                self.outfile.write("  g_object_interface_install_property (iface,\n")
                if p.arg.gtype == "G_TYPE_VARIANT":
                    s = (
                        'g_param_spec_variant ("%s", "%s", "%s", G_VARIANT_TYPE ("%s"), NULL'
                        % (p.name_hyphen, p.name, p.name, p.arg.signature)
                    )
                elif p.arg.signature == "b":
                    s = 'g_param_spec_boolean ("%s", "%s", "%s", FALSE' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "y":
                    s = 'g_param_spec_uchar ("%s", "%s", "%s", 0, 255, 0' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "n":
                    s = (
                        'g_param_spec_int ("%s", "%s", "%s", G_MININT16, G_MAXINT16, 0'
                        % (p.name_hyphen, p.name, p.name)
                    )
                elif p.arg.signature == "q":
                    s = 'g_param_spec_uint ("%s", "%s", "%s", 0, G_MAXUINT16, 0' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "i":
                    s = (
                        'g_param_spec_int ("%s", "%s", "%s", G_MININT32, G_MAXINT32, 0'
                        % (p.name_hyphen, p.name, p.name)
                    )
                elif p.arg.signature == "u":
                    s = 'g_param_spec_uint ("%s", "%s", "%s", 0, G_MAXUINT32, 0' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "x":
                    s = (
                        'g_param_spec_int64 ("%s", "%s", "%s", G_MININT64, G_MAXINT64, 0'
                        % (p.name_hyphen, p.name, p.name)
                    )
                elif p.arg.signature == "t":
                    s = 'g_param_spec_uint64 ("%s", "%s", "%s", 0, G_MAXUINT64, 0' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "d":
                    s = (
                        'g_param_spec_double ("%s", "%s", "%s", -G_MAXDOUBLE, G_MAXDOUBLE, 0.0'
                        % (p.name_hyphen, p.name, p.name)
                    )
                elif p.arg.signature == "s":
                    s = 'g_param_spec_string ("%s", "%s", "%s", NULL' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "o":
                    s = 'g_param_spec_string ("%s", "%s", "%s", NULL' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "g":
                    s = 'g_param_spec_string ("%s", "%s", "%s", NULL' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "ay":
                    s = 'g_param_spec_string ("%s", "%s", "%s", NULL' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "as":
                    s = 'g_param_spec_boxed ("%s", "%s", "%s", G_TYPE_STRV' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "ao":
                    s = 'g_param_spec_boxed ("%s", "%s", "%s", G_TYPE_STRV' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "aay":
                    s = 'g_param_spec_boxed ("%s", "%s", "%s", G_TYPE_STRV' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                else:
                    print_error(
                        'Unsupported gtype "{}" for GParamSpec'.format(p.arg.gtype)
                    )
                flags = "G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS"
                if p.deprecated:
                    flags = "G_PARAM_DEPRECATED | " + flags
                self.outfile.write("    %s, %s));" % (s, flags))
                self.outfile.write("\n")

        self.outfile.write("}\n" "\n")

    # ----------------------------------------------------------------------------------------------------

    def generate_property_accessors(self, i):
        for p in i.properties:
            # getter
            if p.readable and p.writable:
                hint = "Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side."
            elif p.readable:
                hint = "Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side."
            elif p.writable:
                hint = "Since this D-Bus property is not readable, it is only meaningful to use this function on the service-side."
            else:
                print_error(
                    'Cannot handle property "{}" that neither readable nor writable'.format(
                        p.name
                    )
                )
            self.outfile.write(
                self.docbook_gen.expand(
                    "/**\n"
                    " * %s_get_%s: (skip)\n"
                    " * @object: A #%s.\n"
                    " *\n"
                    " * Gets the value of the #%s:%s D-Bus property.\n"
                    " *\n"
                    " * %s\n"
                    " *\n"
                    % (i.name_lower, p.name_lower, i.camel_name, i.name, p.name, hint),
                    False,
                )
            )
            if p.arg.free_func is not None:
                self.outfile.write(
                    " * The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use %s_dup_%s() if on another thread.\n"
                    " *\n"
                    " * Returns: (transfer none) (nullable): The property value or %%NULL if the property is not set. Do not free the returned value, it belongs to @object.\n"
                    % (i.name_lower, p.name_lower)
                )
            else:
                self.outfile.write(" * Returns: The property value.\n")
            self.write_gtkdoc_deprecated_and_since_and_close(p, self.outfile, 0)
            self.outfile.write(
                "%s\n"
                "%s_get_%s (%s *object)\n"
                "{\n" % (p.arg.ctype_in, i.name_lower, p.name_lower, i.camel_name)
            )
            self.outfile.write(
                "  return %s%s_GET_IFACE (object)->get_%s (object);\n"
                % (i.ns_upper, i.name_upper, p.name_lower)
            )
            self.outfile.write("}\n")
            self.outfile.write("\n")
            if p.arg.free_func is not None:

                self.outfile.write(
                    self.docbook_gen.expand(
                        "/**\n"
                        " * %s_dup_%s: (skip)\n"
                        " * @object: A #%s.\n"
                        " *\n"
                        " * Gets a copy of the #%s:%s D-Bus property.\n"
                        " *\n"
                        " * %s\n"
                        " *\n"
                        " * Returns: (transfer full) (nullable): The property value or %%NULL if the property is not set. The returned value should be freed with %s().\n"
                        % (
                            i.name_lower,
                            p.name_lower,
                            i.camel_name,
                            i.name,
                            p.name,
                            hint,
                            p.arg.free_func,
                        ),
                        False,
                    )
                )
                self.write_gtkdoc_deprecated_and_since_and_close(p, self.outfile, 0)
                self.outfile.write(
                    "%s\n"
                    "%s_dup_%s (%s *object)\n"
                    "{\n"
                    "  %svalue;\n"
                    % (
                        p.arg.ctype_in_dup,
                        i.name_lower,
                        p.name_lower,
                        i.camel_name,
                        p.arg.ctype_in_dup,
                    )
                )
                self.outfile.write(
                    '  g_object_get (G_OBJECT (object), "%s", &value, NULL);\n'
                    % (p.name_hyphen)
                )
                self.outfile.write("  return value;\n")
                self.outfile.write("}\n")
                self.outfile.write("\n")

            # setter
            if p.readable and p.writable:
                hint = "Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side."
            elif p.readable:
                hint = "Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side."
            elif p.writable:
                hint = "Since this D-Bus property is writable, it is meaningful to use this function on both the client- and service-side."
            else:
                print_error(
                    'Cannot handle property "{}" that neither readable nor writable'.format(
                        p.name
                    )
                )
            self.outfile.write(
                self.docbook_gen.expand(
                    "/**\n"
                    " * %s_set_%s: (skip)\n"
                    " * @object: A #%s.\n"
                    " * @value: The value to set.\n"
                    " *\n"
                    " * Sets the #%s:%s D-Bus property to @value.\n"
                    " *\n"
                    " * %s\n"
                    % (i.name_lower, p.name_lower, i.camel_name, i.name, p.name, hint),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(p, self.outfile, 0)
            self.outfile.write(
                "void\n"
                "%s_set_%s (%s *object, %svalue)\n"
                "{\n" % (i.name_lower, p.name_lower, i.camel_name, p.arg.ctype_in)
            )
            self.outfile.write(
                '  g_object_set (G_OBJECT (object), "%s", value, NULL);\n'
                % (p.name_hyphen)
            )
            self.outfile.write("}\n")
            self.outfile.write("\n")

    # ---------------------------------------------------------------------------------------------------

    def generate_signal_emitters(self, i):
        for s in i.signals:
            self.outfile.write(
                self.docbook_gen.expand(
                    "/**\n"
                    " * %s_emit_%s:\n"
                    " * @object: A #%s.\n" % (i.name_lower, s.name_lower, i.camel_name),
                    False,
                )
            )
            for a in s.args:
                self.outfile.write(
                    " * @arg_%s: Argument to pass with the signal.\n" % (a.name)
                )
            self.outfile.write(
                self.docbook_gen.expand(
                    " *\n" " * Emits the #%s::%s D-Bus signal.\n" % (i.name, s.name),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(s, self.outfile, 0)
            self.outfile.write(
                "void\n"
                "%s_emit_%s (\n"
                "    %s *object" % (i.name_lower, s.name_lower, i.camel_name)
            )
            for a in s.args:
                self.outfile.write(",\n    %sarg_%s" % (a.ctype_in, a.name))
            self.outfile.write(
                ")\n" "{\n" '  g_signal_emit_by_name (object, "%s"' % (s.name_hyphen)
            )
            for a in s.args:
                self.outfile.write(", arg_%s" % a.name)
            self.outfile.write(");\n")
            self.outfile.write("}\n" "\n")

    # ---------------------------------------------------------------------------------------------------

    def generate_method_calls(self, i):
        for m in i.methods:
            # async begin
            self.outfile.write(
                "/**\n"
                " * %s_call_%s:\n"
                " * @proxy: A #%sProxy.\n" % (i.name_lower, m.name_lower, i.camel_name)
            )
            for a in m.in_args:
                self.outfile.write(
                    " * @arg_%s: Argument to pass with the method invocation.\n"
                    % (a.name)
                )
            if self.glib_min_required >= (2, 64):
                self.outfile.write(
                    " * @call_flags: Flags from the #GDBusCallFlags enumeration. If you want to allow interactive\n"
                    "       authorization be sure to set %G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION.\n"
                    ' * @timeout_msec: The timeout in milliseconds (with %G_MAXINT meaning "infinite") or\n'
                    "       -1 to use the proxy default timeout.\n"
                )
            if m.unix_fd:
                self.outfile.write(
                    " * @fd_list: (nullable): A #GUnixFDList or %NULL.\n"
                )
            self.outfile.write(
                self.docbook_gen.expand(
                    " * @cancellable: (nullable): A #GCancellable or %%NULL.\n"
                    " * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %%NULL.\n"
                    " * @user_data: User data to pass to @callback.\n"
                    " *\n"
                    " * Asynchronously invokes the %s.%s() D-Bus method on @proxy.\n"
                    " * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).\n"
                    " * You can then call %s_call_%s_finish() to get the result of the operation.\n"
                    " *\n"
                    " * See %s_call_%s_sync() for the synchronous, blocking version of this method.\n"
                    % (
                        i.name,
                        m.name,
                        i.name_lower,
                        m.name_lower,
                        i.name_lower,
                        m.name_lower,
                    ),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(m, self.outfile, 0)
            self.outfile.write(
                "void\n"
                "%s_call_%s (\n"
                "    %s *proxy" % (i.name_lower, m.name_lower, i.camel_name)
            )
            for a in m.in_args:
                self.outfile.write(",\n    %sarg_%s" % (a.ctype_in, a.name))
            if self.glib_min_required >= (2, 64):
                self.outfile.write(
                    ",\n    GDBusCallFlags call_flags" ",\n    gint timeout_msec"
                )
            if m.unix_fd:
                self.outfile.write(",\n    GUnixFDList *fd_list")
            self.outfile.write(
                ",\n"
                "    GCancellable *cancellable,\n"
                "    GAsyncReadyCallback callback,\n"
                "    gpointer user_data)\n"
                "{\n"
            )
            if m.unix_fd:
                self.outfile.write(
                    "  g_dbus_proxy_call_with_unix_fd_list (G_DBUS_PROXY (proxy),\n"
                )
            else:
                self.outfile.write("  g_dbus_proxy_call (G_DBUS_PROXY (proxy),\n")
            self.outfile.write('    "%s",\n' '    g_variant_new ("(' % (m.name))
            for a in m.in_args:
                self.outfile.write("%s" % (a.format_in))
            self.outfile.write(')"')
            for a in m.in_args:
                self.outfile.write(",\n                   arg_%s" % (a.name))
            self.outfile.write("),\n")
            if self.glib_min_required >= (2, 64):
                self.outfile.write("    call_flags,\n" "    timeout_msec,\n")
            else:
                self.outfile.write("    G_DBUS_CALL_FLAGS_NONE,\n" "    -1,\n")
            if m.unix_fd:
                self.outfile.write("    fd_list,\n")
            self.outfile.write(
                "    cancellable,\n" "    callback,\n" "    user_data);\n"
            )
            self.outfile.write("}\n" "\n")
            # async finish
            self.outfile.write(
                "/**\n"
                " * %s_call_%s_finish:\n"
                " * @proxy: A #%sProxy.\n" % (i.name_lower, m.name_lower, i.camel_name)
            )
            for a in m.out_args:
                self.outfile.write(
                    " * @out_%s: (out) (optional)%s: Return location for return parameter or %%NULL to ignore.\n"
                    % (a.name, " " + a.array_annotation if a.array_annotation else "")
                )
            if m.unix_fd:
                self.outfile.write(
                    " * @out_fd_list: (out) (optional): Return location for a #GUnixFDList or %NULL to ignore.\n"
                )
            self.outfile.write(
                self.docbook_gen.expand(
                    " * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to %s_call_%s().\n"
                    " * @error: Return location for error or %%NULL.\n"
                    " *\n"
                    " * Finishes an operation started with %s_call_%s().\n"
                    " *\n"
                    " * Returns: (skip): %%TRUE if the call succeeded, %%FALSE if @error is set.\n"
                    % (i.name_lower, m.name_lower, i.name_lower, m.name_lower),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(m, self.outfile, 0)
            self.outfile.write(
                "gboolean\n"
                "%s_call_%s_finish (\n"
                "    %s *proxy" % (i.name_lower, m.name_lower, i.camel_name)
            )
            for a in m.out_args:
                self.outfile.write(",\n    %sout_%s" % (a.ctype_out, a.name))
            if m.unix_fd:
                self.outfile.write(",\n    GUnixFDList **out_fd_list")
            self.outfile.write(
                ",\n"
                "    GAsyncResult *res,\n"
                "    GError **error)\n"
                "{\n"
                "  GVariant *_ret;\n"
            )
            if m.unix_fd:
                self.outfile.write(
                    "  _ret = g_dbus_proxy_call_with_unix_fd_list_finish (G_DBUS_PROXY (proxy), out_fd_list, res, error);\n"
                )
            else:
                self.outfile.write(
                    "  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);\n"
                )
            self.outfile.write("  if (_ret == NULL)\n" "    goto _out;\n")
            self.outfile.write("  g_variant_get (_ret,\n" '                 "(')
            for a in m.out_args:
                self.outfile.write("%s" % (a.format_out))
            self.outfile.write(')"')
            for a in m.out_args:
                self.outfile.write(",\n                 out_%s" % (a.name))
            self.outfile.write(");\n" "  g_variant_unref (_ret);\n")
            self.outfile.write("_out:\n" "  return _ret != NULL;\n" "}\n" "\n")

            # sync
            self.outfile.write(
                "/**\n"
                " * %s_call_%s_sync:\n"
                " * @proxy: A #%sProxy.\n" % (i.name_lower, m.name_lower, i.camel_name)
            )
            for a in m.in_args:
                self.outfile.write(
                    " * @arg_%s: Argument to pass with the method invocation.\n"
                    % (a.name)
                )
            if self.glib_min_required >= (2, 64):
                self.outfile.write(
                    " * @call_flags: Flags from the #GDBusCallFlags enumeration. If you want to allow interactive\n"
                    "       authorization be sure to set %G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION.\n"
                    ' * @timeout_msec: The timeout in milliseconds (with %G_MAXINT meaning "infinite") or\n'
                    "       -1 to use the proxy default timeout.\n"
                )
            if m.unix_fd:
                self.outfile.write(
                    " * @fd_list: (nullable): A #GUnixFDList or %NULL.\n"
                )
            for a in m.out_args:
                self.outfile.write(
                    " * @out_%s: (out) (optional)%s: Return location for return parameter or %%NULL to ignore.\n"
                    % (a.name, " " + a.array_annotation if a.array_annotation else "")
                )
            if m.unix_fd:
                self.outfile.write(
                    " * @out_fd_list: (out): Return location for a #GUnixFDList or %NULL.\n"
                )
            self.outfile.write(
                self.docbook_gen.expand(
                    " * @cancellable: (nullable): A #GCancellable or %%NULL.\n"
                    " * @error: Return location for error or %%NULL.\n"
                    " *\n"
                    " * Synchronously invokes the %s.%s() D-Bus method on @proxy. The calling thread is blocked until a reply is received.\n"
                    " *\n"
                    " * See %s_call_%s() for the asynchronous version of this method.\n"
                    " *\n"
                    " * Returns: (skip): %%TRUE if the call succeeded, %%FALSE if @error is set.\n"
                    % (i.name, m.name, i.name_lower, m.name_lower),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(m, self.outfile, 0)
            self.outfile.write(
                "gboolean\n"
                "%s_call_%s_sync (\n"
                "    %s *proxy" % (i.name_lower, m.name_lower, i.camel_name)
            )
            for a in m.in_args:
                self.outfile.write(",\n    %sarg_%s" % (a.ctype_in, a.name))
            if self.glib_min_required >= (2, 64):
                self.outfile.write(
                    ",\n    GDBusCallFlags call_flags" ",\n    gint timeout_msec"
                )
            if m.unix_fd:
                self.outfile.write(",\n    GUnixFDList  *fd_list")
            for a in m.out_args:
                self.outfile.write(",\n    %sout_%s" % (a.ctype_out, a.name))
            if m.unix_fd:
                self.outfile.write(",\n    GUnixFDList **out_fd_list")
            self.outfile.write(
                ",\n"
                "    GCancellable *cancellable,\n"
                "    GError **error)\n"
                "{\n"
                "  GVariant *_ret;\n"
            )
            if m.unix_fd:
                self.outfile.write(
                    "  _ret = g_dbus_proxy_call_with_unix_fd_list_sync (G_DBUS_PROXY (proxy),\n"
                )
            else:
                self.outfile.write(
                    "  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),\n"
                )
            self.outfile.write('    "%s",\n' '    g_variant_new ("(' % (m.name))
            for a in m.in_args:
                self.outfile.write("%s" % (a.format_in))
            self.outfile.write(')"')
            for a in m.in_args:
                self.outfile.write(",\n                   arg_%s" % (a.name))
            self.outfile.write("),\n")
            if self.glib_min_required >= (2, 64):
                self.outfile.write("    call_flags,\n" "    timeout_msec,\n")
            else:
                self.outfile.write("    G_DBUS_CALL_FLAGS_NONE,\n" "    -1,\n")
            if m.unix_fd:
                self.outfile.write("    fd_list,\n" "    out_fd_list,\n")
            self.outfile.write(
                "    cancellable,\n"
                "    error);\n"
                "  if (_ret == NULL)\n"
                "    goto _out;\n"
            )
            self.outfile.write("  g_variant_get (_ret,\n" '                 "(')
            for a in m.out_args:
                self.outfile.write("%s" % (a.format_out))
            self.outfile.write(')"')
            for a in m.out_args:
                self.outfile.write(",\n                 out_%s" % (a.name))
            self.outfile.write(");\n" "  g_variant_unref (_ret);\n")
            self.outfile.write("_out:\n" "  return _ret != NULL;\n" "}\n" "\n")

    # ---------------------------------------------------------------------------------------------------

    def generate_method_completers(self, i):
        for m in i.methods:
            self.outfile.write(
                "/**\n"
                " * %s_complete_%s:\n"
                " * @object: A #%s.\n"
                " * @invocation: (transfer full): A #GDBusMethodInvocation.\n"
                % (i.name_lower, m.name_lower, i.camel_name)
            )
            if m.unix_fd:
                self.outfile.write(
                    " * @fd_list: (nullable): A #GUnixFDList or %NULL.\n"
                )
            for a in m.out_args:
                self.outfile.write(" * @%s: Parameter to return.\n" % (a.name))
            self.outfile.write(
                self.docbook_gen.expand(
                    " *\n"
                    " * Helper function used in service implementations to finish handling invocations of the %s.%s() D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.\n"
                    " *\n"
                    " * This method will free @invocation, you cannot use it afterwards.\n"
                    % (i.name, m.name),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(m, self.outfile, 0)
            self.outfile.write(
                "void\n"
                "%s_complete_%s (\n"
                "    %s *object G_GNUC_UNUSED,\n"
                "    GDBusMethodInvocation *invocation"
                % (i.name_lower, m.name_lower, i.camel_name)
            )
            if m.unix_fd:
                self.outfile.write(",\n    GUnixFDList *fd_list")
            for a in m.out_args:
                self.outfile.write(",\n    %s%s" % (a.ctype_in, a.name))
            self.outfile.write(")\n" "{\n")

            if m.unix_fd:
                self.outfile.write(
                    "  g_dbus_method_invocation_return_value_with_unix_fd_list (invocation,\n"
                    '    g_variant_new ("('
                )
            else:
                self.outfile.write(
                    "  g_dbus_method_invocation_return_value (invocation,\n"
                    '    g_variant_new ("('
                )
            for a in m.out_args:
                self.outfile.write("%s" % (a.format_in))
            self.outfile.write(')"')
            for a in m.out_args:
                self.outfile.write(",\n                   %s" % (a.name))
            if m.unix_fd:
                self.outfile.write("),\n    fd_list);\n")
            else:
                self.outfile.write("));\n")
            self.outfile.write("}\n" "\n")

    # ---------------------------------------------------------------------------------------------------

    def generate_proxy(self, i):
        # class boilerplate
        self.outfile.write(
            "/* ------------------------------------------------------------------------ */\n"
            "\n"
        )

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sProxy:\n"
                " *\n"
                " * The #%sProxy structure contains only private data and should only be accessed using the provided API.\n"
                % (i.camel_name, i.camel_name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write("\n")

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sProxyClass:\n"
                " * @parent_class: The parent class.\n"
                " *\n"
                " * Class structure for #%sProxy.\n" % (i.camel_name, i.camel_name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write("\n")

        self.outfile.write(
            "struct _%sProxyPrivate\n"
            "{\n"
            "  GData *qdata;\n"
            "};\n"
            "\n" % i.camel_name
        )

        self.outfile.write(
            "static void %s_proxy_iface_init (%sIface *iface);\n"
            "\n" % (i.name_lower, i.camel_name)
        )
        self.outfile.write("#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38\n")
        self.outfile.write(
            "G_DEFINE_TYPE_WITH_CODE (%sProxy, %s_proxy, G_TYPE_DBUS_PROXY,\n"
            % (i.camel_name, i.name_lower)
        )
        self.outfile.write(
            "                         G_ADD_PRIVATE (%sProxy)\n" % (i.camel_name)
        )
        self.outfile.write(
            "                         G_IMPLEMENT_INTERFACE (%sTYPE_%s, %s_proxy_iface_init))\n\n"
            % (i.ns_upper, i.name_upper, i.name_lower)
        )
        self.outfile.write("#else\n")
        self.outfile.write(
            "G_DEFINE_TYPE_WITH_CODE (%sProxy, %s_proxy, G_TYPE_DBUS_PROXY,\n"
            % (i.camel_name, i.name_lower)
        )
        self.outfile.write(
            "                         G_IMPLEMENT_INTERFACE (%sTYPE_%s, %s_proxy_iface_init))\n\n"
            % (i.ns_upper, i.name_upper, i.name_lower)
        )
        self.outfile.write("#endif\n")

        # finalize
        self.outfile.write(
            "static void\n"
            "%s_proxy_finalize (GObject *object)\n"
            "{\n" % (i.name_lower)
        )
        self.outfile.write(
            "  %sProxy *proxy = %s%s_PROXY (object);\n"
            % (i.camel_name, i.ns_upper, i.name_upper)
        )
        self.outfile.write("  g_datalist_clear (&proxy->priv->qdata);\n")
        self.outfile.write(
            "  G_OBJECT_CLASS (%s_proxy_parent_class)->finalize (object);\n"
            "}\n"
            "\n" % (i.name_lower)
        )

        # property accessors
        #
        # Note that we are guaranteed that prop_id starts at 1 and is
        # laid out in the same order as introspection data pointers
        #
        self.outfile.write(
            "static void\n"
            "%s_proxy_get_property (GObject      *object" % (i.name_lower)
        )
        if len(i.properties) == 0:
            self.outfile.write(
                " G_GNUC_UNUSED,\n"
                "  guint         prop_id G_GNUC_UNUSED,\n"
                "  GValue       *value G_GNUC_UNUSED,\n"
            )
        else:
            self.outfile.write(
                ",\n" "  guint         prop_id,\n" "  GValue       *value,\n"
            )
        self.outfile.write("  GParamSpec   *pspec G_GNUC_UNUSED)\n" "{\n")
        if len(i.properties) > 0:
            self.outfile.write(
                "  const _ExtendedGDBusPropertyInfo *info;\n"
                "  GVariant *variant;\n"
                "  g_assert (prop_id != 0 && prop_id - 1 < %d);\n"
                "  info = (const _ExtendedGDBusPropertyInfo *) _%s_property_info_pointers[prop_id - 1];\n"
                "  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);\n"
                "  if (info->use_gvariant)\n"
                "    {\n"
                "      g_value_set_variant (value, variant);\n"
                "    }\n"
                "  else\n"
                "    {\n"
                # could be that we don't have the value in cache - in that case, we do
                # nothing and the user gets the default value for the GType
                "      if (variant != NULL)\n"
                "        g_dbus_gvariant_to_gvalue (variant, value);\n"
                "    }\n"
                "  if (variant != NULL)\n"
                "    g_variant_unref (variant);\n" % (len(i.properties), i.name_lower)
            )
        self.outfile.write("}\n" "\n")
        if len(i.properties) > 0:
            self.outfile.write(
                "static void\n"
                "%s_proxy_set_property_cb (GDBusProxy *proxy,\n"
                "  GAsyncResult *res,\n"
                "  gpointer      user_data)\n"
                "{\n" % (i.name_lower)
            )
            self.outfile.write(
                "  const _ExtendedGDBusPropertyInfo *info = user_data;\n"
                "  GError *error;\n"
                "  GVariant *_ret;\n"
                "  error = NULL;\n"
                "  _ret = g_dbus_proxy_call_finish (proxy, res, &error);\n"
                "  if (!_ret)\n"
                "    {\n"
                "      g_warning (\"Error setting property '%%s' on interface %s: %%s (%%s, %%d)\",\n"
                "                 info->parent_struct.name, \n"
                "                 error->message, g_quark_to_string (error->domain), error->code);\n"
                "      g_error_free (error);\n"
                "    }\n"
                "  else\n"
                "    {\n"
                "      g_variant_unref (_ret);\n"
                "    }\n" % (i.name)
            )
            self.outfile.write("}\n" "\n")
        self.outfile.write("static void\n" "%s_proxy_set_property (" % (i.name_lower))
        if len(i.properties) == 0:
            self.outfile.write(
