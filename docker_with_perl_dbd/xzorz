	GAUDI2_QUEUE_ID_NIC_3_0 = 168,
	GAUDI2_QUEUE_ID_NIC_3_1 = 169,
	GAUDI2_QUEUE_ID_NIC_3_2 = 170,
	GAUDI2_QUEUE_ID_NIC_3_3 = 171,
	GAUDI2_QUEUE_ID_NIC_4_0 = 172,
	GAUDI2_QUEUE_ID_NIC_4_1 = 173,
	GAUDI2_QUEUE_ID_NIC_4_2 = 174,
	GAUDI2_QUEUE_ID_NIC_4_3 = 175,
	GAUDI2_QUEUE_ID_NIC_5_0 = 176,
	GAUDI2_QUEUE_ID_NIC_5_1 = 177,
	GAUDI2_QUEUE_ID_NIC_5_2 = 178,
	GAUDI2_QUEUE_ID_NIC_5_3 = 179,
	GAUDI2_QUEUE_ID_NIC_6_0 = 180,
	GAUDI2_QUEUE_ID_NIC_6_1 = 181,
	GAUDI2_QUEUE_ID_NIC_6_2 = 182,
	GAUDI2_QUEUE_ID_NIC_6_3 = 183,
	GAUDI2_QUEUE_ID_NIC_7_0 = 184,
	GAUDI2_QUEUE_ID_NIC_7_1 = 185,
	GAUDI2_QUEUE_ID_NIC_7_2 = 186,
	GAUDI2_QUEUE_ID_NIC_7_3 = 187,
	GAUDI2_QUEUE_ID_NIC_8_0 = 188,
	GAUDI2_QUEUE_ID_NIC_8_1 = 189,
	GAUDI2_QUEUE_ID_NIC_8_2 = 190,
	GAUDI2_QUEUE_ID_NIC_8_3 = 191,
	GAUDI2_QUEUE_ID_NIC_9_0 = 192,
	GAUDI2_QUEUE_ID_NIC_9_1 = 193,
	GAUDI2_QUEUE_ID_NIC_9_2 = 194,
	GAUDI2_QUEUE_ID_NIC_9_3 = 195,
	GAUDI2_QUEUE_ID_NIC_10_0 = 196,
	GAUDI2_QUEUE_ID_NIC_10_1 = 197,
	GAUDI2_QUEUE_ID_NIC_10_2 = 198,
	GAUDI2_QUEUE_ID_NIC_10_3 = 199,
	GAUDI2_QUEUE_ID_NIC_11_0 = 200,
	GAUDI2_QUEUE_ID_NIC_11_1 = 201,
	GAUDI2_QUEUE_ID_NIC_11_2 = 202,
	GAUDI2_QUEUE_ID_NIC_11_3 = 203,
	GAUDI2_QUEUE_ID_NIC_12_0 = 204,
	GAUDI2_QUEUE_ID_NIC_12_1 = 205,
	GAUDI2_QUEUE_ID_NIC_12_2 = 206,
	GAUDI2_QUEUE_ID_NIC_12_3 = 207,
	GAUDI2_QUEUE_ID_NIC_13_0 = 208,
	GAUDI2_QUEUE_ID_NIC_13_1 = 209,
	GAUDI2_QUEUE_ID_NIC_13_2 = 210,
	GAUDI2_QUEUE_ID_NIC_13_3 = 211,
	GAUDI2_QUEUE_ID_NIC_14_0 = 212,
	GAUDI2_QUEUE_ID_NIC_14_1 = 213,
	GAUDI2_QUEUE_ID_NIC_14_2 = 214,
	GAUDI2_QUEUE_ID_NIC_14_3 = 215,
	GAUDI2_QUEUE_ID_NIC_15_0 = 216,
	GAUDI2_QUEUE_ID_NIC_15_1 = 217,
	GAUDI2_QUEUE_ID_NIC_15_2 = 218,
	GAUDI2_QUEUE_ID_NIC_15_3 = 219,
	GAUDI2_QUEUE_ID_NIC_16_0 = 220,
	GAUDI2_QUEUE_ID_NIC_16_1 = 221,
	GAUDI2_QUEUE_ID_NIC_16_2 = 222,
	GAUDI2_QUEUE_ID_NIC_16_3 = 223,
	GAUDI2_QUEUE_ID_NIC_17_0 = 224,
	GAUDI2_QUEUE_ID_NIC_17_1 = 225,
	GAUDI2_QUEUE_ID_NIC_17_2 = 226,
	GAUDI2_QUEUE_ID_NIC_17_3 = 227,
	GAUDI2_QUEUE_ID_NIC_18_0 = 228,
	GAUDI2_QUEUE_ID_NIC_18_1 = 229,
	GAUDI2_QUEUE_ID_NIC_18_2 = 230,
	GAUDI2_QUEUE_ID_NIC_18_3 = 231,
	GAUDI2_QUEUE_ID_NIC_19_0 = 232,
	GAUDI2_QUEUE_ID_NIC_19_1 = 233,
	GAUDI2_QUEUE_ID_NIC_19_2 = 234,
	GAUDI2_QUEUE_ID_NIC_19_3 = 235,
	GAUDI2_QUEUE_ID_NIC_20_0 = 236,
	GAUDI2_QUEUE_ID_NIC_20_1 = 237,
	GAUDI2_QUEUE_ID_NIC_20_2 = 238,
	GAUDI2_QUEUE_ID_NIC_20_3 = 239,
	GAUDI2_QUEUE_ID_NIC_21_0 = 240,
	GAUDI2_QUEUE_ID_NIC_21_1 = 241,
	GAUDI2_QUEUE_ID_NIC_21_2 = 242,
	GAUDI2_QUEUE_ID_NIC_21_3 = 243,
	GAUDI2_QUEUE_ID_NIC_22_0 = 244,
	GAUDI2_QUEUE_ID_NIC_22_1 = 245,
	GAUDI2_QUEUE_ID_NIC_22_2 = 246,
	GAUDI2_QUEUE_ID_NIC_22_3 = 247,
	GAUDI2_QUEUE_ID_NIC_23_0 = 248,
	GAUDI2_QUEUE_ID_NIC_23_1 = 249,
	GAUDI2_QUEUE_ID_NIC_23_2 = 250,
	GAUDI2_QUEUE_ID_NIC_23_3 = 251,
	GAUDI2_QUEUE_ID_ROT_0_0 = 252,
	GAUDI2_QUEUE_ID_ROT_0_1 = 253,
	GAUDI2_QUEUE_ID_ROT_0_2 = 254,
	GAUDI2_QUEUE_ID_ROT_0_3 = 255,
	GAUDI2_QUEUE_ID_ROT_1_0 = 256,
	GAUDI2_QUEUE_ID_ROT_1_1 = 257,
	GAUDI2_QUEUE_ID_ROT_1_2 = 258,
	GAUDI2_QUEUE_ID_ROT_1_3 = 259,
	GAUDI2_QUEUE_ID_CPU_PQ = 260,
	GAUDI2_QUEUE_ID_SIZE
};

/*
 * Engine Numbering
 *
 * Used in the "busy_engines_mask" field in `struct hl_info_hw_idle'
 */

enum goya_engine_id {
	GOYA_ENGINE_ID_DMA_0 = 0,
	GOYA_ENGINE_ID_DMA_1,
	GOYA_ENGINE_ID_DMA_2,
	GOYA_ENGINE_ID_DMA_3,
	GOYA_ENGINE_ID_DMA_4,
	GOYA_ENGINE_ID_MME_0,
	GOYA_ENGINE_ID_TPC_0,
	GOYA_ENGINE_ID_TPC_1,
	GOYA_ENGINE_ID_TPC_2,
	GOYA_ENGINE_ID_TPC_3,
	GOYA_ENGINE_ID_TPC_4,
	GOYA_ENGINE_ID_TPC_5,
	GOYA_ENGINE_ID_TPC_6,
	GOYA_ENGINE_ID_TPC_7,
	GOYA_ENGINE_ID_SIZE
};

enum gaudi_engine_id {
	GAUDI_ENGINE_ID_DMA_0 = 0,
	GAUDI_ENGINE_ID_DMA_1,
	GAUDI_ENGINE_ID_DMA_2,
	GAUDI_ENGINE_ID_DMA_3,
	GAUDI_ENGINE_ID_DMA_4,
	GAUDI_ENGINE_ID_DMA_5,
	GAUDI_ENGINE_ID_DMA_6,
	GAUDI_ENGINE_ID_DMA_7,
	GAUDI_ENGINE_ID_MME_0,
	GAUDI_ENGINE_ID_MME_1,
	GAUDI_ENGINE_ID_MME_2,
	GAUDI_ENGINE_ID_MME_3,
	GAUDI_ENGINE_ID_TPC_0,
	GAUDI_ENGINE_ID_TPC_1,
	GAUDI_ENGINE_ID_TPC_2,
	GAUDI_ENGINE_ID_TPC_3,
	GAUDI_ENGINE_ID_TPC_4,
	GAUDI_ENGINE_ID_TPC_5,
	GAUDI_ENGINE_ID_TPC_6,
	GAUDI_ENGINE_ID_TPC_7,
	GAUDI_ENGINE_ID_NIC_0,
	GAUDI_ENGINE_ID_NIC_1,
	GAUDI_ENGINE_ID_NIC_2,
	GAUDI_ENGINE_ID_NIC_3,
	GAUDI_ENGINE_ID_NIC_4,
	GAUDI_ENGINE_ID_NIC_5,
	GAUDI_ENGINE_ID_NIC_6,
	GAUDI_ENGINE_ID_NIC_7,
	GAUDI_ENGINE_ID_NIC_8,
	GAUDI_ENGINE_ID_NIC_9,
	GAUDI_ENGINE_ID_SIZE
};

enum gaudi2_engine_id {
	GAUDI2_DCORE0_ENGINE_ID_EDMA_0 = 0,
	GAUDI2_DCORE0_ENGINE_ID_EDMA_1,
	GAUDI2_DCORE0_ENGINE_ID_MME,
	GAUDI2_DCORE0_ENGINE_ID_TPC_0,
	GAUDI2_DCORE0_ENGINE_ID_TPC_1,
	GAUDI2_DCORE0_ENGINE_ID_TPC_2,
	GAUDI2_DCORE0_ENGINE_ID_TPC_3,
	GAUDI2_DCORE0_ENGINE_ID_TPC_4,
	GAUDI2_DCORE0_ENGINE_ID_TPC_5,
	GAUDI2_DCORE0_ENGINE_ID_DEC_0,
	GAUDI2_DCORE0_ENGINE_ID_DEC_1,
	GAUDI2_DCORE1_ENGINE_ID_EDMA_0,
	GAUDI2_DCORE1_ENGINE_ID_EDMA_1,
	GAUDI2_DCORE1_ENGINE_ID_MME,
	GAUDI2_DCORE1_ENGINE_ID_TPC_0,
	GAUDI2_DCORE1_ENGINE_ID_TPC_1,
	GAUDI2_DCORE1_ENGINE_ID_TPC_2,
	GAUDI2_DCORE1_ENGINE_ID_TPC_3,
	GAUDI2_DCORE1_ENGINE_ID_TPC_4,
	GAUDI2_DCORE1_ENGINE_ID_TPC_5,
	GAUDI2_DCORE1_ENGINE_ID_DEC_0,
	GAUDI2_DCORE1_ENGINE_ID_DEC_1,
	GAUDI2_DCORE2_ENGINE_ID_EDMA_0,
	GAUDI2_DCORE2_ENGINE_ID_EDMA_1,
	GAUDI2_DCORE2_ENGINE_ID_MME,
	GAUDI2_DCORE2_ENGINE_ID_TPC_0,
	GAUDI2_DCORE2_ENGINE_ID_TPC_1,
	GAUDI2_DCORE2_ENGINE_ID_TPC_2,
	GAUDI2_DCORE2_ENGINE_ID_TPC_3,
	GAUDI2_DCORE2_ENGINE_ID_TPC_4,
	GAUDI2_DCORE2_ENGINE_ID_TPC_5,
	GAUDI2_DCORE2_ENGINE_ID_DEC_0,
	GAUDI2_DCORE2_ENGINE_ID_DEC_1,
	GAUDI2_DCORE3_ENGINE_ID_EDMA_0,
	GAUDI2_DCORE3_ENGINE_ID_EDMA_1,
	GAUDI2_DCORE3_ENGINE_ID_MME,
	GAUDI2_DCORE3_ENGINE_ID_TPC_0,
	GAUDI2_DCORE3_ENGINE_ID_TPC_1,
	GAUDI2_DCORE3_ENGINE_ID_TPC_2,
	GAUDI2_DCORE3_ENGINE_ID_TPC_3,
	GAUDI2_DCORE3_ENGINE_ID_TPC_4,
	GAUDI2_DCORE3_ENGINE_ID_TPC_5,
	GAUDI2_DCORE3_ENGINE_ID_DEC_0,
	GAUDI2_DCORE3_ENGINE_ID_DEC_1,
	GAUDI2_DCORE0_ENGINE_ID_TPC_6,
	GAUDI2_ENGINE_ID_PDMA_0,
	GAUDI2_ENGINE_ID_PDMA_1,
	GAUDI2_ENGINE_ID_ROT_0,
	GAUDI2_ENGINE_ID_ROT_1,
	GAUDI2_PCIE_ENGINE_ID_DEC_0,
	GAUDI2_PCIE_ENGINE_ID_DEC_1,
	GAUDI2_ENGINE_ID_NIC0_0,
	GAUDI2_ENGINE_ID_NIC0_1,
	GAUDI2_ENGINE_ID_NIC1_0,
	GAUDI2_ENGINE_ID_NIC1_1,
	GAUDI2_ENGINE_ID_NIC2_0,
	GAUDI2_ENGINE_ID_NIC2_1,
	GAUDI2_ENGINE_ID_NIC3_0,
	GAUDI2_ENGINE_ID_NIC3_1,
	GAUDI2_ENGINE_ID_NIC4_0,
	GAUDI2_ENGINE_ID_NIC4_1,
	GAUDI2_ENGINE_ID_NIC5_0,
	GAUDI2_ENGINE_ID_NIC5_1,
	GAUDI2_ENGINE_ID_NIC6_0,
	GAUDI2_ENGINE_ID_NIC6_1,
	GAUDI2_ENGINE_ID_NIC7_0,
	GAUDI2_ENGINE_ID_NIC7_1,
	GAUDI2_ENGINE_ID_NIC8_0,
	GAUDI2_ENGINE_ID_NIC8_1,
	GAUDI2_ENGINE_ID_NIC9_0,
	GAUDI2_ENGINE_ID_NIC9_1,
	GAUDI2_ENGINE_ID_NIC10_0,
	GAUDI2_ENGINE_ID_NIC10_1,
	GAUDI2_ENGINE_ID_NIC11_0,
	GAUDI2_ENGINE_ID_NIC11_1,
	GAUDI2_ENGINE_ID_SIZE
};

/*
 * ASIC specific PLL index
 *
 * Used to retrieve in frequency info of different IPs via
 * HL_INFO_PLL_FREQUENCY under HL_IOCTL_INFO IOCTL. The enums need to be
 * used as an index in struct hl_pll_frequency_info
 */

enum hl_goya_pll_index {
	HL_GOYA_CPU_PLL = 0,
	HL_GOYA_IC_PLL,
	HL_GOYA_MC_PLL,
	HL_GOYA_MME_PLL,
	HL_GOYA_PCI_PLL,
	HL_GOYA_EMMC_PLL,
	HL_GOYA_TPC_PLL,
	HL_GOYA_PLL_MAX
};

enum hl_gaudi_pll_index {
	HL_GAUDI_CPU_PLL = 0,
	HL_GAUDI_PCI_PLL,
	HL_GAUDI_SRAM_PLL,
	HL_GAUDI_HBM_PLL,
	HL_GAUDI_NIC_PLL,
	HL_GAUDI_DMA_PLL,
	HL_GAUDI_MESH_PLL,
	HL_GAUDI_MME_PLL,
	HL_GAUDI_TPC_PLL,
	HL_GAUDI_IF_PLL,
	HL_GAUDI_PLL_MAX
};

enum hl_gaudi2_pll_index {
	HL_GAUDI2_CPU_PLL = 0,
	HL_GAUDI2_PCI_PLL,
	HL_GAUDI2_SRAM_PLL,
	HL_GAUDI2_HBM_PLL,
	HL_GAUDI2_NIC_PLL,
	HL_GAUDI2_DMA_PLL,
	HL_GAUDI2_MESH_PLL,
	HL_GAUDI2_MME_PLL,
	HL_GAUDI2_TPC_PLL,
	HL_GAUDI2_IF_PLL,
	HL_GAUDI2_VID_PLL,
	HL_GAUDI2_MSS_PLL,
	HL_GAUDI2_PLL_MAX
};

/**
 * enum hl_goya_dma_direction - Direction of DMA operation inside a LIN_DMA packet that is
 *                              submitted to the GOYA's DMA QMAN. This attribute is not relevant
 *                              to the H/W but the kernel driver use it to parse the packet's
 *                              addresses and patch/validate them.
 * @HL_DMA_HOST_TO_DRAM: DMA operation from Host memory to GOYA's DDR.
 * @HL_DMA_HOST_TO_SRAM: DMA operation from Host memory to GOYA's SRAM.
 * @HL_DMA_DRAM_TO_SRAM: DMA operation from GOYA's DDR to GOYA's SRAM.
 * @HL_DMA_SRAM_TO_DRAM: DMA operation from GOYA's SRAM to GOYA's DDR.
 * @HL_DMA_SRAM_TO_HOST: DMA operation from GOYA's SRAM to Host memory.
 * @HL_DMA_DRAM_TO_HOST: DMA operation from GOYA's DDR to Host memory.
 * @HL_DMA_DRAM_TO_DRAM: DMA operation from GOYA's DDR to GOYA's DDR.
 * @HL_DMA_SRAM_TO_SRAM: DMA operation from GOYA's SRAM to GOYA's SRAM.
 * @HL_DMA_ENUM_MAX: number of values in enum
 */
enum hl_goya_dma_direction {
	HL_DMA_HOST_TO_DRAM,
	HL_DMA_HOST_TO_SRAM,
	HL_DMA_DRAM_TO_SRAM,
	HL_DMA_SRAM_TO_DRAM,
	HL_DMA_SRAM_TO_HOST,
	HL_DMA_DRAM_TO_HOST,
	HL_DMA_DRAM_TO_DRAM,
	HL_DMA_SRAM_TO_SRAM,
	HL_DMA_ENUM_MAX
};

/**
 * enum hl_device_status - Device status information.
 * @HL_DEVICE_STATUS_OPERATIONAL: Device is operational.
 * @HL_DEVICE_STATUS_IN_RESET: Device is currently during reset.
 * @HL_DEVICE_STATUS_MALFUNCTION: Device is unusable.
 * @HL_DEVICE_STATUS_NEEDS_RESET: Device needs reset because auto reset was disabled.
 * @HL_DEVICE_STATUS_IN_DEVICE_CREATION: Device is operational but its creation is still in
 *                                       progress.
 * @HL_DEVICE_STATUS_IN_RESET_AFTER_DEVICE_RELEASE: Device is currently during reset that was
 *                                                  triggered because the user released the device
 * @HL_DEVICE_STATUS_LAST: Last status.
 */
enum hl_device_status {
	HL_DEVICE_STATUS_OPERATIONAL,
	HL_DEVICE_STATUS_IN_RESET,
	HL_DEVICE_STATUS_MALFUNCTION,
	HL_DEVICE_STATUS_NEEDS_RESET,
	HL_DEVICE_STATUS_IN_DEVICE_CREATION,
	HL_DEVICE_STATUS_IN_RESET_AFTER_DEVICE_RELEASE,
	HL_DEVICE_STATUS_LAST = HL_DEVICE_STATUS_IN_RESET_AFTER_DEVICE_RELEASE
};

enum hl_server_type {
	HL_SERVER_TYPE_UNKNOWN = 0,
	HL_SERVER_GAUDI_HLS1 = 1,
	HL_SERVER_GAUDI_HLS1H = 2,
	HL_SERVER_GAUDI_TYPE1 = 3,
	HL_SERVER_GAUDI_TYPE2 = 4,
	HL_SERVER_GAUDI2_HLS2 = 5
};

/*
 * Notifier event values - for the notification mechanism and the HL_INFO_GET_EVENTS command
 *
 * HL_NOTIFIER_EVENT_TPC_ASSERT		- Indicates TPC assert event
 * HL_NOTIFIER_EVENT_UNDEFINED_OPCODE	- Indicates undefined operation code
 * HL_NOTIFIER_EVENT_DEVICE_RESET	- Indicates device requires a reset
 * HL_NOTIFIER_EVENT_CS_TIMEOUT		- Indicates CS timeout error
 * HL_NOTIFIER_EVENT_DEVICE_UNAVAILABLE	- Indicates device is unavailable
 * HL_NOTIFIER_EVENT_USER_ENGINE_ERR	- Indicates device engine in error state
 * HL_NOTIFIER_EVENT_GENERAL_HW_ERR     - Indicates device HW error
 */
#define HL_NOTIFIER_EVENT_TPC_ASSERT		(1ULL << 0)
#define HL_NOTIFIER_EVENT_UNDEFINED_OPCODE	(1ULL << 1)
#define HL_NOTIFIER_EVENT_DEVICE_RESET		(1ULL << 2)
#define HL_NOTIFIER_EVENT_CS_TIMEOUT		(1ULL << 3)
#define HL_NOTIFIER_EVENT_DEVICE_UNAVAILABLE	(1ULL << 4)
#define HL_NOTIFIER_EVENT_USER_ENGINE_ERR	(1ULL << 5)
#define HL_NOTIFIER_EVENT_GENERAL_HW_ERR	(1ULL << 6)

/* Opcode for management ioctl
 *
 * HW_IP_INFO            - Receive information about different IP blocks in the
 *                         device.
 * HL_INFO_HW_EVENTS     - Receive an array describing how many times each event
 *                         occurred since the last hard reset.
 * HL_INFO_DRAM_USAGE    - Retrieve the dram usage inside the device and of the
 *                         specific context. This is relevant only for devices
 *                         where the dram is managed by the kernel driver
 * HL_INFO_HW_IDLE       - Retrieve information about the idle status of each
 *                         internal engine.
 * HL_INFO_DEVICE_STATUS - Retrieve the device's status. This opcode doesn't
 *                         require an open context.
 * HL_INFO_DEVICE_UTILIZATION  - Retrieve the total utilization of the device
 *                               over the last period specified by the user.
 *                               The period can be between 100ms to 1s, in
 *                               resolution of 100ms. The return value is a
 *                               percentage of the utilization rate.
 * HL_INFO_HW_EVENTS_AGGREGATE - Receive an array describing how many times each
 *                               event occurred since the driver was loaded.
 * HL_INFO_CLK_RATE            - Retrieve the current and maximum clock rate
 *                               of the device in MHz. The maximum clock rate is
 *                               configurable via sysfs parameter
 * HL_INFO_RESET_COUNT   - Retrieve the counts of the soft and hard reset
 *                         operations performed on the device since the last
 *                         time the driver was loaded.
 * HL_INFO_TIME_SYNC     - Retrieve the device's time alongside the host's time
 *                         for synchronization.
 * HL_INFO_CS_COUNTERS   - Retrieve command submission counters
 * HL_INFO_PCI_COUNTERS  - Retrieve PCI counters
 * HL_INFO_CLK_THROTTLE_REASON - Retrieve clock throttling reason
 * HL_INFO_SYNC_MANAGER  - Retrieve sync manager info per dcore
 * HL_INFO_TOTAL_ENERGY  - Retrieve total energy consumption
 * HL_INFO_PLL_FREQUENCY - Retrieve PLL frequency
 * HL_INFO_POWER         - Retrieve power information
 * HL_INFO_OPEN_STATS    - Retrieve info regarding recent device open calls
 * HL_INFO_DRAM_REPLACED_ROWS - Retrieve DRAM replaced rows info
 * HL_INFO_DRAM_PENDING_ROWS - Retrieve DRAM pending rows num
 * HL_INFO_LAST_ERR_OPEN_DEV_TIME - Retrieve timestamp of the last time the device was opened
 *                                  and CS timeout or razwi error occurred.
 * HL_INFO_CS_TIMEOUT_EVENT - Retrieve CS timeout timestamp and its related CS sequence number.
 * HL_INFO_RAZWI_EVENT - Retrieve parameters of razwi:
 *                            Timestamp of razwi.
 *                            The address which accessing it caused the razwi.
 *                            Razwi initiator.
 *                            Razwi cause, was it a page fault or MMU access error.
 * HL_INFO_DEV_MEM_ALLOC_PAGE_SIZES - Retrieve valid page sizes for device memory allocation
 * HL_INFO_SECURED_ATTESTATION - Retrieve attestation report of the boot.
 * HL_INFO_REGISTER_EVENTFD   - Register eventfd for event notifications.
 * HL_INFO_UNREGISTER_EVENTFD - Unregister eventfd
 * HL_INFO_GET_EVENTS         - Retrieve the last occurred events
 * HL_INFO_UNDEFINED_OPCODE_EVENT - Retrieve last undefined opcode error information.
 */
#define HL_INFO_HW_IP_INFO			0
#define HL_INFO_HW_EVENTS			1
#define HL_INFO_DRAM_USAGE			2
#define HL_INFO_HW_IDLE				3
#define HL_INFO_DEVICE_STATUS			4
#define HL_INFO_DEVICE_UTILIZATION		6
#define HL_INFO_HW_EVENTS_AGGREGATE		7
#define HL_INFO_CLK_RATE			8
#define HL_INFO_RESET_COUNT			9
#define HL_INFO_TIME_SYNC			10
#define HL_INFO_CS_COUNTERS			11
#define HL_INFO_PCI_COUNTERS			12
#define HL_INFO_CLK_THROTTLE_REASON		13
#define HL_INFO_SYNC_MANAGER			14
#define HL_INFO_TOTAL_ENERGY			15
#define HL_INFO_PLL_FREQUENCY			16
#define HL_INFO_POWER				17
#define HL_INFO_OPEN_STATS			18
#define HL_INFO_DRAM_REPLACED_ROWS		21
#define HL_INFO_DRAM_PENDING_ROWS		22
#define HL_INFO_LAST_ERR_OPEN_DEV_TIME		23
#define HL_INFO_CS_TIMEOUT_EVENT		24
#define HL_INFO_RAZWI_EVENT			25
#define HL_INFO_DEV_MEM_ALLOC_PAGE_SIZES	26
#define HL_INFO_SECURED_ATTESTATION		27
#define HL_INFO_REGISTER_EVENTFD		28
#define HL_INFO_UNREGISTER_EVENTFD		29
#define HL_INFO_GET_EVENTS			30
#define HL_INFO_UNDEFINED_OPCODE_EVENT		31
#define HL_INFO_ENGINE_STATUS			32

#define HL_INFO_VERSION_MAX_LEN			128
#define HL_INFO_CARD_NAME_MAX_LEN		16

/* Maximum buffer size for retrieving engines status */
#define HL_ENGINES_DATA_MAX_SIZE	SZ_1M

/**
 * struct hl_info_hw_ip_info - hardware information on various IPs in the ASIC
 * @sram_base_address: The first SRAM physical base address that is free to be
 *                     used by the user.
 * @dram_base_address: The first DRAM virtual or physical base address that is
 *                     free to be used by the user.
 * @dram_size: The DRAM size that is available to the user.
 * @sram_size: The SRAM size that is available to the user.
 * @num_of_events: The number of events that can be received from the f/w. This
 *                 is needed so the user can what is the size of the h/w events
 *                 array he needs to pass to the kernel when he wants to fetch
 *                 the event counters.
 * @device_id: PCI device ID of the ASIC.
 * @module_id: Module ID of the ASIC for mezzanine cards in servers
 *             (From OCP spec).
 * @decoder_enabled_mask: Bit-mask that represents which decoders are enabled.
 * @first_available_interrupt_id: The first available interrupt ID for the user
 *                                to be used when it works with user interrupts.
 *                                Relevant for Gaudi2 and later.
 * @server_type: Server type that the Gaudi ASIC is currently installed in.
 *               The value is according to enum hl_server_type
 * @cpld_version: CPLD version on the board.
 * @psoc_pci_pll_nr: PCI PLL NR value. Needed by the profiler in some ASICs.
 * @psoc_pci_pll_nf: PCI PLL NF value. Needed by the profiler in some ASICs.
 * @psoc_pci_pll_od: PCI PLL OD value. Needed by the profiler in some ASICs.
 * @psoc_pci_pll_div_factor: PCI PLL DIV factor value. Needed by the profiler
 *                           in some ASICs.
 * @tpc_enabled_mask: Bit-mask that represents which TPCs are enabled. Relevant
 *                    for Goya/Gaudi only.
 * @dram_enabled: Whether the DRAM is enabled.
 * @security_enabled: Whether security is enabled on device.
 * @mme_master_slave_mode: Indicate whether the MME is working in master/slave
 *                         configuration. Relevant for Greco and later.
 * @cpucp_version: The CPUCP f/w version.
 * @card_name: The card name as passed by the f/w.
 * @tpc_enabled_mask_ext: Bit-mask that represents which TPCs are enabled.
 *                        Relevant for Greco and later.
 * @dram_page_size: The DRAM physical page size.
 * @edma_enabled_mask: Bit-mask that represents which EDMAs are enabled.
 *                     Relevant for Gaudi2 and later.
 * @number_of_user_interrupts: The number of interrupts that are available to the userspace
 *                             application to use. Relevant for Gaudi2 and later.
 * @device_mem_alloc_default_page_size: default page size used in device memory allocation.
 */
struct hl_info_hw_ip_info {
	__u64 sram_base_address;
	__u64 dram_base_address;
	__u64 dram_size;
	__u32 sram_size;
	__u32 num_of_events;
	__u32 device_id;
	__u32 module_id;
	__u32 decoder_enabled_mask;
	__u16 first_available_interrupt_id;
	__u16 server_type;
	__u32 cpld_version;
	__u32 psoc_pci_pll_nr;
	__u32 psoc_pci_pll_nf;
	__u32 psoc_pci_pll_od;
	__u32 psoc_pci_pll_div_factor;
	__u8 tpc_enabled_mask;
	__u8 dram_enabled;
	__u8 security_enabled;
	__u8 mme_master_slave_mode;
	__u8 cpucp_version[HL_INFO_VERSION_MAX_LEN];
	__u8 card_name[HL_INFO_CARD_NAME_MAX_LEN];
	__u64 tpc_enabled_mask_ext;
	__u64 dram_page_size;
	__u32 edma_enabled_mask;
	__u16 number_of_user_interrupts;
	__u16 pad2;
	__u64 reserved4;
	__u64 device_mem_alloc_default_page_size;
};

struct hl_info_dram_usage {
	__u64 dram_free_mem;
	__u64 ctx_dram_mem;
};

#define HL_BUSY_ENGINES_MASK_EXT_SIZE	2

struct hl_info_hw_idle {
	__u32 is_idle;
	/*
	 * Bitmask of busy engines.
	 * Bits definition is according to `enum <chip>_engine_id'.
	 */
	__u32 busy_engines_mask;

	/*
	 * Extended Bitmask of busy engines.
	 * Bits definition is according to `enum <chip>_engine_id'.
	 */
	__u64 busy_engines_mask_ext[HL_BUSY_ENGINES_MASK_EXT_SIZE];
};

struct hl_info_device_status {
	__u32 status;
	__u32 pad;
};

struct hl_info_device_utilization {
	__u32 utilization;
	__u32 pad;
};

struct hl_info_clk_rate {
	__u32 cur_clk_rate_mhz;
	__u32 max_clk_rate_mhz;
};

struct hl_info_reset_count {
	__u32 hard_reset_cnt;
	__u32 soft_reset_cnt;
};

struct hl_info_time_sync {
	__u64 device_time;
	__u64 host_time;
};

/**
 * struct hl_info_pci_counters - pci counters
 * @rx_throughput: PCI rx throughput KBps
 * @tx_throughput: PCI tx throughput KBps
 * @replay_cnt: PCI replay counter
 */
struct hl_info_pci_counters {
	__u64 rx_throughput;
	__u64 tx_throughput;
	__u64 replay_cnt;
};

enum hl_clk_throttling_type {
	HL_CLK_THROTTLE_TYPE_POWER,
	HL_CLK_THROTTLE_TYPE_THERMAL,
	HL_CLK_THROTTLE_TYPE_MAX
};

/* clk_throttling_reason masks */
#define HL_CLK_THROTTLE_POWER		(1 << HL_CLK_THROTTLE_TYPE_POWER)
#define HL_CLK_THROTTLE_THERMAL		(1 << HL_CLK_THROTTLE_TYPE_THERMAL)

/**
 * struct hl_info_clk_throttle - clock throttling reason
 * @clk_throttling_reason: each bit represents a clk throttling reason
 * @clk_throttling_timestamp_us: represents CPU timestamp in microseconds of the start-event
 * @clk_throttling_duration_ns: the clock throttle time in nanosec
 */
struct hl_info_clk_throttle {
	__u32 clk_throttling_reason;
	__u32 pad;
	__u64 clk_throttling_timestamp_us[HL_CLK_THROTTLE_TYPE_MAX];
	__u64 clk_throttling_duration_ns[HL_CLK_THROTTLE_TYPE_MAX];
};

/**
 * struct hl_info_energy - device energy information
 * @total_energy_consumption: total device energy consumption
 */
struct hl_info_energy {
	__u64 total_energy_consumption;
};

#define HL_PLL_NUM_OUTPUTS 4

struct hl_pll_frequency_info {
	__u16 output[HL_PLL_NUM_OUTPUTS];
};

/**
 * struct hl_open_stats_info - device open statistics information
 * @open_counter: ever growing counter, increased on each successful dev open
 * @last_open_period_ms: duration (ms) device was open last time
 * @is_compute_ctx_active: Whether there is an active compute context executing
 * @compute_ctx_in_release: true if the current compute context is being released
 */
struct hl_open_stats_info {
	__u64 open_counter;
	__u64 last_open_period_ms;
	__u8 is_compute_ctx_active;
	__u8 compute_ctx_in_release;
	__u8 pad[6];
};

/**
 * struct hl_power_info - power information
 * @power: power consumption
 */
struct hl_power_info {
	__u64 power;
};

/**
 * struct hl_info_sync_manager - sync manager information
 * @first_available_sync_object: first available sob
 * @first_available_monitor: first available monitor
 * @first_available_cq: first available cq
 */
struct hl_info_sync_manager {
	__u32 first_available_sync_object;
	__u32 first_available_monitor;
	__u32 first_available_cq;
	__u32 reserved;
};

/**
 * struct hl_info_cs_counters - command submission counters
 * @total_out_of_mem_drop_cnt: total dropped due to memory allocation issue
 * @ctx_out_of_mem_drop_cnt: context dropped due to memory allocation issue
 * @total_parsing_drop_cnt: total dropped due to error in packet parsing
 * @ctx_parsing_drop_cnt: context dropped due to error in packet parsing
 * @total_queue_full_drop_cnt: total dropped due to queue full
 * @ctx_queue_full_drop_cnt: context dropped due to queue full
 * @total_device_in_reset_drop_cnt: total dropped due to device in reset
 * @ctx_device_in_reset_drop_cnt: context dropped due to device in reset
 * @total_max_cs_in_flight_drop_cnt: total dropped due to maximum CS in-flight
 * @ctx_max_cs_in_flight_drop_cnt: context dropped due to maximum CS in-flight
 * @total_validation_drop_cnt: total dropped due to validation error
 * @ctx_validation_drop_cnt: context dropped due to validation error
 */
struct hl_info_cs_counters {
	__u64 total_out_of_mem_drop_cnt;
	__u64 ctx_out_of_mem_drop_cnt;
	__u64 total_parsing_drop_cnt;
	__u64 ctx_parsing_drop_cnt;
	__u64 total_queue_full_drop_cnt;
	__u64 ctx_queue_full_drop_cnt;
	__u64 total_device_in_reset_drop_cnt;
	__u64 ctx_device_in_reset_drop_cnt;
	__u64 total_max_cs_in_flight_drop_cnt;
	__u64 ctx_max_cs_in_flight_drop_cnt;
	__u64 total_validation_drop_cnt;
	__u64 ctx_validation_drop_cnt;
};

/**
 * struct hl_info_last_err_open_dev_time - last error boot information.
 * @timestamp: timestamp of last time the device was opened and error occurred.
 */
struct hl_info_last_err_open_dev_time {
	__s64 timestamp;
};

/**
 * struct hl_info_cs_timeout_event - last CS timeout information.
 * @timestamp: timestamp when last CS timeout event occurred.
 * @seq: sequence number of last CS timeout event.
 */
struct hl_info_cs_timeout_event {
	__s64 timestamp;
	__u64 seq;
};

#define HL_RAZWI_PAGE_FAULT 0
#define HL_RAZWI_MMU_ACCESS_ERROR 1

/**
 * struct hl_info_razwi_event - razwi information.
 * @timestamp: timestamp of razwi.
 * @addr: address which accessing it caused razwi.
 * @engine_id_1: engine id of the razwi initiator, if it was initiated by engine that does not
 *               have engine id it will be set to U16_MAX.
 * @engine_id_2: second engine id of razwi initiator. Might happen that razwi have 2 possible
 *               engines which one them caused the razwi. In that case, it will contain the
 *               second possible engine id, otherwise it will be set to U16_MAX.
 * @no_engine_id: if razwi initiator does not have engine id, this field will be set to 1,
 *                otherwise 0.
 * @error_type: cause of razwi, page fault or access error, otherwise it will be set to U8_MAX.
 * @pad: padding to 64 bit.
 */
struct hl_info_razwi_event {
	__s64 timestamp;
	__u64 addr;
	__u16 engine_id_1;
	__u16 engine_id_2;
	__u8 no_engine_id;
	__u8 error_type;
	__u8 pad[2];
};

#define MAX_QMAN_STREAMS_INFO		4
#define OPCODE_INFO_MAX_ADDR_SIZE	8
/**
 * struct hl_info_undefined_opcode_event - info about last undefined opcode error
 * @timestamp: timestamp of the undefined opcode error
 * @cb_addr_streams: CB addresses (per stream) that are currently exists in the PQ
 *                   entries. In case all streams array entries are
 *                   filled with values, it means the execution was in Lower-CP.
 * @cq_addr: the address of the current handled command buffer
 * @cq_size: the size of the current handled command buffer
 * @cb_addr_streams_len: num of streams - actual len of cb_addr_streams array.
 *                       should be equal to 1 in case of undefined opcode
 *                       in Upper-CP (specific stream) and equal to 4 incase
 *                       of undefined opcode in Lower-CP.
 * @engine_id: engine-id that the error occurred on
 * @stream_id: the stream id the error occurred on. In case the stream equals to
 *             MAX_QMAN_STREAMS_INFO it means the error occurred on a Lower-CP.
 */
struct hl_info_undefined_opcode_event {
	__s64 timestamp;
	__u64 cb_addr_streams[MAX_QMAN_STREAMS_INFO][OPCODE_INFO_MAX_ADDR_SIZE];
	__u64 cq_addr;
	__u32 cq_size;
	__u32 cb_addr_streams_len;
	__u32 engine_id;
	__u32 stream_id;
};

/**
 * struct hl_info_dev_memalloc_page_sizes - valid page sizes in device mem alloc information.
 * @page_order_bitmask: bitmap in which a set bit represents the order of the supported page size
 *                      (e.g. 0x2100000 means that 1MB and 32MB pages are supported).
 */
struct hl_info_dev_memalloc_page_sizes {
	__u64 page_order_bitmask;
};

#define SEC_PCR_DATA_BUF_SZ	256
#define SEC_PCR_QUOTE_BUF_SZ	510	/* (512 - 2) 2 bytes used for size */
#define SEC_SIGNATURE_BUF_SZ	255	/* (256 - 1) 1 byte used for size */
#define SEC_PUB_DATA_BUF_SZ	510	/* (512 - 2) 2 bytes used for size */
#define SEC_CERTIFICATE_BUF_SZ	2046	/* (2048 - 2) 2 bytes used for size */

/*
 * struct hl_info_sec_attest - attestation report of the boot
 * @nonce: number only used once. random number provided by host. this also passed to the quote
 *         command as a qualifying data.
 * @pcr_quote_len: length of the attestation quote data (bytes)
 * @pub_data_len: length of the public data (bytes)
 * @certificate_len: length of the certificate (bytes)
 * @pcr_num_reg: number of PCR registers in the pcr_data array
 * @pcr_reg_len: length of each PCR register in the pcr_data array (bytes)
 * @quote_sig_len: length of the attestation report signature (bytes)
 * @pcr_data: raw values of the PCR registers
 * @pcr_quote: attestation report data structure
 * @quote_sig: signature structure of the attestation report
 * @public_data: public key for the signed attestation
 *		 (outPublic + name + qualifiedName)
 * @certificate: certificate for the attestation signing key
 */
struct hl_info_sec_attest {
	__u32 nonce;
	__u16 pcr_quote_len;
	__u16 pub_data_len;
	__u16 certificate_len;
	__u8 pcr_num_reg;
	__u8 pcr_reg_len;
	__u8 quote_sig_len;
	__u8 pcr_data[SEC_PCR_DATA_BUF_SZ];
	__u8 pcr_quote[SEC_PCR_QUOTE_BUF_SZ];
	__u8 quote_sig[SEC_SIGNATURE_BUF_SZ];
	__u8 public_data[SEC_PUB_DATA_BUF_SZ];
	__u8 certificate[SEC_CERTIFICATE_BUF_SZ];
	__u8 pad0[2];
};

enum gaudi_dcores {
	HL_GAUDI_WS_DCORE,
	HL_GAUDI_WN_DCORE,
	HL_GAUDI_EN_DCORE,
	HL_GAUDI_ES_DCORE
};

/**
 * struct hl_info_args - Main structure to retrieve device related information.
 * @return_pointer: User space address of the relevant structure related to HL_INFO_* operation
 *                  mentioned in @op.
 * @return_size: Size of the structure used in @return_pointer, just like "size" in "snprintf", it
 *               limits how many bytes the kernel can write. For hw_events array, the size should be
 *               hl_info_hw_ip_info.num_of_events * sizeof(__u32).
 * @op: Defines which type of information to be retrieved. Refer HL_INFO_* for details.
 * @dcore_id: DCORE id for which the information is relevant (for Gaudi refer to enum gaudi_dcores).
 * @ctx_id: Context ID of the user. Currently not in use.
 * @period_ms: Period value, in milliseconds, for utilization rate in range 100ms - 1000ms in 100 ms
 *             resolution. Currently not in use.
 * @pll_index: Index as defined in hl_<asic type>_pll_index enumeration.
 * @eventfd: event file descriptor for event notifications.
 * @user_buffer_actual_size: Actual data size which was copied to user allocated buffer by the
 *                           driver. It is possible for the user to allocate buffer larger than
 *                           needed, hence updating this variable so user will know the exact amount
 *                           of bytes copied by the kernel to the buffer.
 * @sec_attest_nonce: Nonce number used for attestation report.
 * @pad: Padding to 64 bit.
 */
struct hl_info_args {
	__u64 return_pointer;
	__u32 return_size;
	__u32 op;

	union {
		__u32 dcore_id;
		__u32 ctx_id;
		__u32 period_ms;
		__u32 pll_index;
		__u32 eventfd;
		__u32 user_buffer_actual_size;
		__u32 sec_attest_nonce;
	};

	__u32 pad;
};

/* Opcode to create a new command buffer */
#define HL_CB_OP_CREATE		0
/* Opcode to destroy previously created command buffer */
#define HL_CB_OP_DESTROY	1
/* Opcode to retrieve information about a command buffer */
#define HL_CB_OP_INFO		2

/* 2MB minus 32 bytes for 2xMSG_PROT */
#define HL_MAX_CB_SIZE		(0x200000 - 32)

/* Indicates whether the command buffer should be mapped to the device's MMU */
#define HL_CB_FLAGS_MAP			0x1

/* Used with HL_CB_OP_INFO opcode to get the device va address for kernel mapped CB */
#define HL_CB_FLAGS_GET_DEVICE_VA	0x2

struct hl_cb_in {
	/* Handle of CB or 0 if we want to create one */
	__u64 cb_handle;
	/* HL_CB_OP_* */
	__u32 op;

	/* Size of CB. Maximum size is HL_MAX_CB_SIZE. The minimum size that
	 * will be allocated, regardless of this parameter's value, is PAGE_SIZE
	 */
	__u32 cb_size;

	/* Context ID - Currently not in use */
	__u32 ctx_id;
	/* HL_CB_FLAGS_* */
	__u32 flags;
};

struct hl_cb_out {
	union {
		/* Handle of CB */
		__u64 cb_handle;

		union {
			/* Information about CB */
			struct {
				/* Usage count of CB */
				__u32 usage_cnt;
				__u32 pad;
			};

			/* CB mapped address to device MMU */
			__u64 device_va;
		};
	};
};

union hl_cb_args {
	struct hl_cb_in in;
	struct hl_cb_out out;
};

/* HL_CS_CHUNK_FLAGS_ values
 *
 * HL_CS_CHUNK_FLAGS_USER_ALLOC_CB:
 *      Indicates if the CB was allocated and mapped by userspace
 *      (relevant to greco and above). User allocated CB is a command buffer,
 *      allocated by the user, via malloc (or similar). After allocating the
 *      CB, the user invokes - “memory ioctl” to map the user memory into a
 *      device virtual address. The user provides this address via the
 *      cb_handle field. The interface provides the ability to create a
 *      large CBs, Which aren’t limited to “HL_MAX_CB_SIZE”. Therefore, it
 *      increases the PCI-DMA queues throughput. This CB allocation method
 *      also reduces the use of Linux DMA-able memory pool. Which are limited
 *      and used by other Linux sub-systems.
 */
#define HL_CS_CHUNK_FLAGS_USER_ALLOC_CB 0x1

/*
 * This structure size must always be fixed to 64-bytes for backward
 * compatibility
 */
struct hl_cs_chunk {
	union {
		/* Goya/Gaudi:
		 * For external queue, this represents a Handle of CB on the
		 * Host.
		 * For internal queue in Goya, this represents an SRAM or
		 * a DRAM address of the internal CB. In Gaudi, this might also
		 * represent a mapped host address of the CB.
		 *
		 * Greco onwards:
		 * For H/W queue, this represents either a Handle of CB on the
		 * Host, or an SRAM, a DRAM, or a mapped host address of the CB.
		 *
		 * A mapped host address is in the device address space, after
		 * a host address was mapped by the device MMU.
		 */
		__u64 cb_handle;

		/* Relevant only when HL_CS_FLAGS_WAIT or
		 * HL_CS_FLAGS_COLLECTIVE_WAIT is set
		 * This holds address of array of u64 values that contain
		 * signal CS sequence numbers. The wait described by
		 * this job will listen on all those signals
		 * (wait event per signal)
		 */
		__u64 signal_seq_arr;

		/*
		 * Relevant only when HL_CS_FLAGS_WAIT or
		 * HL_CS_FLAGS_COLLECTIVE_WAIT is set
		 * along with HL_CS_FLAGS_ENCAP_SIGNALS.
		 * This is the CS sequence which has the encapsulated signals.
		 */
		__u64 encaps_signal_seq;
	};

	/* Index of queue to put the CB on */
	__u32 queue_index;

	union {
		/*
		 * Size of command buffer with valid packets
		 * Can be smaller then actual CB size
		 */
		__u32 cb_size;

		/* Relevant only when HL_CS_FLAGS_WAIT or
		 * HL_CS_FLAGS_COLLECTIVE_WAIT is set.
		 * Number of entries in signal_seq_arr
		 */
		__u32 num_signal_seq_arr;

		/* Relevant only when HL_CS_FLAGS_WAIT or
		 * HL_CS_FLAGS_COLLECTIVE_WAIT is set along
		 * with HL_CS_FLAGS_ENCAP_SIGNALS
		 * This set the signals range that the user want to wait for
		 * out of the whole reserved signals range.
		 * e.g if the signals range is 20, and user don't want
		 * to wait for signal 8, so he set this offset to 7, then
		 * he call the API again with 9 and so on till 20.
		 */
		__u32 encaps_signal_offset;
	};

	/* HL_CS_CHUNK_FLAGS_* */
	__u32 cs_chunk_flags;

	/* Relevant only when HL_CS_FLAGS_COLLECTIVE_WAIT is set.
	 * This holds the collective engine ID. The wait described by this job
	 * will sync with this engine and with all NICs before completion.
