#define PERL_ARGS_ASSERT_PARSE_UNIPROP_STRING	\
	assert(name); assert(user_defined_ptr); assert(msg)
STATIC void	S_populate_ANYOF_from_invlist(pTHX_ regnode *node, SV** invlist_ptr);
#define PERL_ARGS_ASSERT_POPULATE_ANYOF_FROM_INVLIST	\
	assert(node); assert(invlist_ptr)
STATIC void	S_rck_elide_nothing(pTHX_ regnode *node);
#define PERL_ARGS_ASSERT_RCK_ELIDE_NOTHING	\
	assert(node)
PERL_STATIC_NO_RET void	S_re_croak(pTHX_ bool utf8, const char* pat, ...)
			__attribute__noreturn__
			__attribute__format__(__printf__,pTHX_2,pTHX_3);
#define PERL_ARGS_ASSERT_RE_CROAK	\
	assert(pat)

STATIC regnode_offset	S_reg(pTHX_ RExC_state_t *pRExC_state, I32 paren, I32 *flagp, U32 depth);
#define PERL_ARGS_ASSERT_REG	\
	assert(pRExC_state); assert(flagp)
STATIC regnode_offset	S_reg2Lanode(pTHX_ RExC_state_t *pRExC_state, const U8 op, const U32 arg1, const I32 arg2);
#define PERL_ARGS_ASSERT_REG2LANODE	\
	assert(pRExC_state)
STATIC regnode_offset	S_reg_la_NOTHING(pTHX_ RExC_state_t *pRExC_state, U32 flags, const char *type);
#define PERL_ARGS_ASSERT_REG_LA_NOTHING	\
	assert(pRExC_state); assert(type)
STATIC regnode_offset	S_reg_la_OPFAIL(pTHX_ RExC_state_t *pRExC_state, U32 flags, const char *type);
#define PERL_ARGS_ASSERT_REG_LA_OPFAIL	\
	assert(pRExC_state); assert(type)
STATIC regnode_offset	S_reg_node(pTHX_ RExC_state_t *pRExC_state, U8 op);
#define PERL_ARGS_ASSERT_REG_NODE	\
	assert(pRExC_state)
STATIC SV *	S_reg_scan_name(pTHX_ RExC_state_t *pRExC_state, U32 flags);
#define PERL_ARGS_ASSERT_REG_SCAN_NAME	\
	assert(pRExC_state)
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE char *	S_reg_skipcomment(RExC_state_t *pRExC_state, char * p);
#define PERL_ARGS_ASSERT_REG_SKIPCOMMENT	\
	assert(pRExC_state); assert(p)
#endif
STATIC regnode_offset	S_reganode(pTHX_ RExC_state_t *pRExC_state, U8 op, U32 arg);
#define PERL_ARGS_ASSERT_REGANODE	\
	assert(pRExC_state)
STATIC regnode_offset	S_regatom(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth);
#define PERL_ARGS_ASSERT_REGATOM	\
	assert(pRExC_state); assert(flagp)
STATIC regnode_offset	S_regbranch(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, I32 first, U32 depth);
#define PERL_ARGS_ASSERT_REGBRANCH	\
	assert(pRExC_state); assert(flagp)
STATIC regnode_offset	S_regclass(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth, const bool stop_at_1, bool allow_multi_fold, const bool silence_non_portable, const bool strict, bool optimizable, SV** ret_invlist);
#define PERL_ARGS_ASSERT_REGCLASS	\
	assert(pRExC_state); assert(flagp)
STATIC unsigned int	S_regex_set_precedence(const U8 my_operator)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_REGEX_SET_PRECEDENCE

STATIC void	S_reginsert(pTHX_ RExC_state_t *pRExC_state, const U8 op, const regnode_offset operand, const U32 depth);
#define PERL_ARGS_ASSERT_REGINSERT	\
	assert(pRExC_state)
STATIC regnode_offset	S_regnode_guts(pTHX_ RExC_state_t *pRExC_state, const STRLEN extra_len);
#define PERL_ARGS_ASSERT_REGNODE_GUTS	\
	assert(pRExC_state)
STATIC regnode_offset	S_regpiece(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth);
#define PERL_ARGS_ASSERT_REGPIECE	\
	assert(pRExC_state); assert(flagp)
STATIC regnode_offset	S_regpnode(pTHX_ RExC_state_t *pRExC_state, U8 op, SV * arg);
#define PERL_ARGS_ASSERT_REGPNODE	\
	assert(pRExC_state); assert(arg)
STATIC bool	S_regtail(pTHX_ RExC_state_t * pRExC_state, const regnode_offset p, const regnode_offset val, const U32 depth)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_REGTAIL	\
	assert(pRExC_state); assert(p); assert(val)

STATIC void	S_scan_commit(pTHX_ const RExC_state_t *pRExC_state, struct scan_data_t *data, SSize_t *minlenp, int is_inf);
#define PERL_ARGS_ASSERT_SCAN_COMMIT	\
	assert(pRExC_state); assert(data); assert(minlenp)
STATIC void	S_set_ANYOF_arg(pTHX_ RExC_state_t* const pRExC_state, regnode* const node, SV* const cp_list, SV* const runtime_defns, SV* const only_utf8_locale_list);
#define PERL_ARGS_ASSERT_SET_ANYOF_ARG	\
	assert(pRExC_state); assert(node)
STATIC void	S_set_regex_pv(pTHX_ RExC_state_t *pRExC_state, REGEXP *Rx);
#define PERL_ARGS_ASSERT_SET_REGEX_PV	\
	assert(pRExC_state); assert(Rx)
STATIC void	S_skip_to_be_ignored_text(pTHX_ RExC_state_t *pRExC_state, char ** p, const bool force_to_xmod);
#define PERL_ARGS_ASSERT_SKIP_TO_BE_IGNORED_TEXT	\
	assert(pRExC_state); assert(p)
STATIC void	S_ssc_add_range(pTHX_ regnode_ssc *ssc, UV const start, UV const end);
#define PERL_ARGS_ASSERT_SSC_ADD_RANGE	\
	assert(ssc)
STATIC void	S_ssc_and(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc, const regnode_charclass *and_with);
#define PERL_ARGS_ASSERT_SSC_AND	\
	assert(pRExC_state); assert(ssc); assert(and_with)
STATIC void	S_ssc_anything(pTHX_ regnode_ssc *ssc);
#define PERL_ARGS_ASSERT_SSC_ANYTHING	\
	assert(ssc)
STATIC void	S_ssc_clear_locale(regnode_ssc *ssc);
#define PERL_ARGS_ASSERT_SSC_CLEAR_LOCALE	\
	assert(ssc)
STATIC void	S_ssc_cp_and(pTHX_ regnode_ssc *ssc, UV const cp);
#define PERL_ARGS_ASSERT_SSC_CP_AND	\
	assert(ssc)
STATIC void	S_ssc_finalize(pTHX_ RExC_state_t *pRExC_state, regnode_ssc *ssc);
#define PERL_ARGS_ASSERT_SSC_FINALIZE	\
	assert(pRExC_state); assert(ssc)
STATIC void	S_ssc_init(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc);
#define PERL_ARGS_ASSERT_SSC_INIT	\
	assert(pRExC_state); assert(ssc)
STATIC void	S_ssc_intersection(pTHX_ regnode_ssc *ssc, SV* const invlist, const bool invert_2nd);
#define PERL_ARGS_ASSERT_SSC_INTERSECTION	\
	assert(ssc); assert(invlist)
STATIC int	S_ssc_is_anything(const regnode_ssc *ssc)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SSC_IS_ANYTHING	\
	assert(ssc)

STATIC int	S_ssc_is_cp_posixl_init(const RExC_state_t *pRExC_state, const regnode_ssc *ssc)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SSC_IS_CP_POSIXL_INIT	\
	assert(pRExC_state); assert(ssc)

STATIC void	S_ssc_or(pTHX_ const RExC_state_t *pRExC_state, regnode_ssc *ssc, const regnode_charclass *or_with);
#define PERL_ARGS_ASSERT_SSC_OR	\
	assert(pRExC_state); assert(ssc); assert(or_with)
STATIC void	S_ssc_union(pTHX_ regnode_ssc *ssc, SV* const invlist, const bool invert_2nd);
#define PERL_ARGS_ASSERT_SSC_UNION	\
	assert(ssc); assert(invlist)
STATIC SSize_t	S_study_chunk(pTHX_ RExC_state_t *pRExC_state, regnode **scanp, SSize_t *minlenp, SSize_t *deltap, regnode *last, struct scan_data_t *data, I32 stopparen, U32 recursed_depth, regnode_ssc *and_withp, U32 flags, U32 depth, bool was_mutate_ok);
#define PERL_ARGS_ASSERT_STUDY_CHUNK	\
	assert(pRExC_state); assert(scanp); assert(minlenp); assert(deltap); assert(last)
#endif
#if defined(PERL_IN_REGCOMP_C) || defined (PERL_IN_DUMP_C) || defined(PERL_IN_OP_C)
PERL_CALLCONV void	Perl__invlist_dump(pTHX_ PerlIO *file, I32 level, const char* const indent, SV* const invlist);
#define PERL_ARGS_ASSERT__INVLIST_DUMP	\
	assert(file); assert(indent); assert(invlist)
#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_DOOP_C) || defined(PERL_IN_OP_C)
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE SV*	S_add_cp_to_invlist(pTHX_ SV* invlist, const UV cp)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_ADD_CP_TO_INVLIST
#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE void	S_invlist_extend(pTHX_ SV* const invlist, const UV len);
#define PERL_ARGS_ASSERT_INVLIST_EXTEND	\
	assert(invlist)
#endif
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE UV	S_invlist_highest(SV* const invlist)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_INVLIST_HIGHEST	\
	assert(invlist)
#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE void	S_invlist_set_len(pTHX_ SV* const invlist, const UV len, const bool offset);
#define PERL_ARGS_ASSERT_INVLIST_SET_LEN	\
	assert(invlist)
#endif
#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_DOOP_C) || defined(PERL_IN_OP_C) || defined(PERL_IN_UTF8_C)
PERL_CALLCONV SV*	Perl__add_range_to_invlist(pTHX_ SV* invlist, UV start, UV end)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__ADD_RANGE_TO_INVLIST

/* PERL_CALLCONV void	_invlist_intersection(pTHX_ SV* const a, SV* const b, SV** i); */
#define PERL_ARGS_ASSERT__INVLIST_INTERSECTION
PERL_CALLCONV void	Perl__invlist_intersection_maybe_complement_2nd(pTHX_ SV* const a, SV* const b, const bool complement_b, SV** i);
#define PERL_ARGS_ASSERT__INVLIST_INTERSECTION_MAYBE_COMPLEMENT_2ND	\
	assert(b); assert(i)
PERL_CALLCONV void	Perl__invlist_invert(pTHX_ SV* const invlist);
#define PERL_ARGS_ASSERT__INVLIST_INVERT	\
	assert(invlist)
/* PERL_CALLCONV void	_invlist_subtract(pTHX_ SV* const a, SV* const b, SV** result); */
#define PERL_ARGS_ASSERT__INVLIST_SUBTRACT
/* PERL_CALLCONV void	_invlist_union(pTHX_ SV* const a, SV* const b, SV** output); */
#define PERL_ARGS_ASSERT__INVLIST_UNION
PERL_CALLCONV void	Perl__invlist_union_maybe_complement_2nd(pTHX_ SV* const a, SV* const b, const bool complement_b, SV** output);
#define PERL_ARGS_ASSERT__INVLIST_UNION_MAYBE_COMPLEMENT_2ND	\
	assert(b); assert(output)
PERL_CALLCONV SV*	Perl__new_invlist(pTHX_ IV initial_size)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__NEW_INVLIST

PERL_CALLCONV SV*	Perl__setup_canned_invlist(pTHX_ const STRLEN size, const UV element0, UV** other_elements_ptr)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__SETUP_CANNED_INVLIST	\
	assert(other_elements_ptr)

#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_DQUOTE_C) || defined(PERL_IN_TOKE_C)
PERL_CALLCONV const char *	Perl_form_alien_digit_msg(pTHX_ const U8 which, const STRLEN valids_len, const char * const first_bad, const char * const send, const bool UTF, const bool braced)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_FORM_ALIEN_DIGIT_MSG	\
	assert(first_bad); assert(send)

PERL_CALLCONV bool	Perl_grok_bslash_c(pTHX_ const char source, U8 * result, const char** message, U32 * packed_warn)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_GROK_BSLASH_C	\
	assert(result); assert(message)

PERL_CALLCONV bool	Perl_grok_bslash_o(pTHX_ char** s, const char* const send, UV* uv, const char** message, U32 * packed_warn, const bool strict, const bool allow_UV_MAX, const bool utf8)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_GROK_BSLASH_O	\
	assert(s); assert(send); assert(uv); assert(message)

PERL_CALLCONV bool	Perl_grok_bslash_x(pTHX_ char** s, const char* const send, UV* uv, const char** message, U32 * packed_warn, const bool strict, const bool allow_UV_MAX, const bool utf8)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_GROK_BSLASH_X	\
	assert(s); assert(send); assert(uv); assert(message)

#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_DQUOTE_C) || defined(PERL_IN_TOKE_C) || defined(PERL_IN_UTF8_C)
PERL_CALLCONV const char *	Perl_form_cp_too_large_msg(pTHX_ const U8 which, const char * string, const Size_t len, const UV cp)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_FORM_CP_TOO_LARGE_MSG

#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_OP_C)
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE STRLEN*	S_get_invlist_iter_addr(SV* invlist)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_GET_INVLIST_ITER_ADDR	\
	assert(invlist)
#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE void	S_invlist_iterfinish(SV* invlist);
#define PERL_ARGS_ASSERT_INVLIST_ITERFINISH	\
	assert(invlist)
#endif
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE void	S_invlist_iterinit(SV* invlist);
#define PERL_ARGS_ASSERT_INVLIST_ITERINIT	\
	assert(invlist)
#endif
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE bool	S_invlist_iternext(SV* invlist, UV* start, UV* end)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_INVLIST_ITERNEXT	\
	assert(invlist); assert(start); assert(end)
#endif

#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_PERL_C) || defined(PERL_IN_UTF8_C)
PERL_CALLCONV bool	Perl__invlistEQ(pTHX_ SV* const a, SV* const b, const bool complement_b);
#define PERL_ARGS_ASSERT__INVLISTEQ	\
	assert(a); assert(b)
PERL_CALLCONV SV*	Perl__new_invlist_C_array(pTHX_ const UV* const list)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__NEW_INVLIST_C_ARRAY	\
	assert(list)

#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_PP_C) || defined(PERL_IN_TOKE_C) || defined(PERL_IN_UNIVERSAL_C)
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE const char *	S_get_regex_charset_name(const U32 flags, STRLEN* const lenp);
#define PERL_ARGS_ASSERT_GET_REGEX_CHARSET_NAME	\
	assert(lenp)
#endif
#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)
PERL_CALLCONV int	Perl_re_printf(pTHX_ const char *fmt, ...)
			__attribute__format__(__printf__,pTHX_1,pTHX_2);
#define PERL_ARGS_ASSERT_RE_PRINTF	\
	assert(fmt)

PERL_CALLCONV void	Perl_regprop(pTHX_ const regexp *prog, SV* sv, const regnode* o, const regmatch_info *reginfo, const RExC_state_t *pRExC_state);
#define PERL_ARGS_ASSERT_REGPROP	\
	assert(sv); assert(o)
#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C)	 || defined(PERL_IN_PP_C) || defined(PERL_IN_OP_C)		 || defined(PERL_IN_TOKE_C) || defined(PERL_IN_UTF8_C)		 || defined(PERL_IN_DOOP_C)
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE bool	S__invlist_contains_cp(SV* const invlist, const UV cp)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__INVLIST_CONTAINS_CP	\
	assert(invlist)
#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE UV	S__invlist_len(SV* const invlist)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__INVLIST_LEN	\
	assert(invlist)
#endif

PERL_CALLCONV SSize_t	Perl__invlist_search(SV* const invlist, const UV cp)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__INVLIST_SEARCH	\
	assert(invlist)

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE bool*	S_get_invlist_offset_addr(SV* invlist)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_GET_INVLIST_OFFSET_ADDR	\
	assert(invlist)
#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE UV*	S_invlist_array(SV* const invlist)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_INVLIST_ARRAY	\
	assert(invlist)
#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE bool	S_is_invlist(const SV* const invlist)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_INVLIST
#endif

#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_TOKE_C)
PERL_CALLCONV bool	Perl_is_grapheme(pTHX_ const U8 * strbeg, const U8 * s, const U8 *strend, const UV cp)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_GRAPHEME	\
	assert(strbeg); assert(s); assert(strend)

#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_UTF8_C)
PERL_CALLCONV UV	Perl__to_fold_latin1(const U8 c, U8 *p, STRLEN *lenp, const unsigned int flags);
#define PERL_ARGS_ASSERT__TO_FOLD_LATIN1	\
	assert(p); assert(lenp)
#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_SV_C)
PERL_CALLCONV SV*	Perl_invlist_clone(pTHX_ SV* const invlist, SV* newlist);
#define PERL_ARGS_ASSERT_INVLIST_CLONE	\
	assert(invlist)
#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_TOKE_C)
PERL_CALLCONV bool	Perl_regcurly(const char *s, const char *e, const char * result[5])
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_REGCURLY	\
	assert(s); assert(e)

#endif
#if defined(PERL_IN_REGEXEC_C)
STATIC LB_enum	S_advance_one_LB(pTHX_ U8 ** curpos, const U8 * const strend, const bool utf8_target)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_ADVANCE_ONE_LB	\
	assert(curpos); assert(strend)

STATIC SB_enum	S_advance_one_SB(pTHX_ U8 ** curpos, const U8 * const strend, const bool utf8_target)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_ADVANCE_ONE_SB	\
	assert(curpos); assert(strend)

STATIC WB_enum	S_advance_one_WB(pTHX_ U8 ** curpos, const U8 * const strend, const bool utf8_target, const bool skip_Extend_Format)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_ADVANCE_ONE_WB	\
	assert(curpos); assert(strend)

STATIC GCB_enum	S_backup_one_GCB(pTHX_ const U8 * const strbeg, U8 ** curpos, const bool utf8_target)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_BACKUP_ONE_GCB	\
	assert(strbeg); assert(curpos)

STATIC LB_enum	S_backup_one_LB(pTHX_ const U8 * const strbeg, U8 ** curpos, const bool utf8_target)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_BACKUP_ONE_LB	\
	assert(strbeg); assert(curpos)

STATIC SB_enum	S_backup_one_SB(pTHX_ const U8 * const strbeg, U8 ** curpos, const bool utf8_target)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_BACKUP_ONE_SB	\
	assert(strbeg); assert(curpos)

STATIC WB_enum	S_backup_one_WB(pTHX_ WB_enum * previous, const U8 * const strbeg, U8 ** curpos, const bool utf8_target)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_BACKUP_ONE_WB	\
	assert(previous); assert(strbeg); assert(curpos)

STATIC char*	S_find_byclass(pTHX_ regexp * prog, const regnode *c, char *s, const char *strend, regmatch_info *reginfo)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_FIND_BYCLASS	\
	assert(prog); assert(c); assert(s); assert(strend)

STATIC U8 *	S_find_next_masked(U8 * s, const U8 * send, const U8 byte, const U8 mask)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_FIND_NEXT_MASKED	\
	assert(s); assert(send)

STATIC U8 *	S_find_span_end(U8* s, const U8 * send, const U8 span_byte)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_FIND_SPAN_END	\
	assert(s); assert(send)

STATIC U8 *	S_find_span_end_mask(U8 * s, const U8 * send, const U8 span_byte, const U8 mask)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_FIND_SPAN_END_MASK	\
	assert(s); assert(send)

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE I32	S_foldEQ_latin1_s2_folded(const char* a, const char* b, I32 len);
#define PERL_ARGS_ASSERT_FOLDEQ_LATIN1_S2_FOLDED	\
	assert(a); assert(b)
#endif
STATIC bool	S_isFOO_lc(pTHX_ const U8 classnum, const U8 character)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_ISFOO_LC

STATIC bool	S_isFOO_utf8_lc(pTHX_ const U8 classnum, const U8* character, const U8* e)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_ISFOO_UTF8_LC	\
	assert(character); assert(e)

STATIC bool	S_isGCB(pTHX_ const GCB_enum before, const GCB_enum after, const U8 * const strbeg, const U8 * const curpos, const bool utf8_target)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_ISGCB	\
	assert(strbeg); assert(curpos)

STATIC bool	S_isLB(pTHX_ LB_enum before, LB_enum after, const U8 * const strbeg, const U8 * const curpos, const U8 * const strend, const bool utf8_target)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_ISLB	\
	assert(strbeg); assert(curpos); assert(strend)

STATIC bool	S_isSB(pTHX_ SB_enum before, SB_enum after, const U8 * const strbeg, const U8 * const curpos, const U8 * const strend, const bool utf8_target)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_ISSB	\
	assert(strbeg); assert(curpos); assert(strend)

STATIC bool	S_isWB(pTHX_ WB_enum previous, WB_enum before, WB_enum after, const U8 * const strbeg, const U8 * const curpos, const U8 * const strend, const bool utf8_target)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_ISWB	\
	assert(strbeg); assert(curpos); assert(strend)

STATIC I32	S_reg_check_named_buff_matched(const regexp *rex, const regnode *scan)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_REG_CHECK_NAMED_BUFF_MATCHED	\
	assert(rex); assert(scan)

STATIC void	S_regcp_restore(pTHX_ regexp *rex, I32 ix, U32 *maxopenparen_p _pDEPTH);
#define PERL_ARGS_ASSERT_REGCP_RESTORE	\
	assert(rex); assert(maxopenparen_p)
STATIC void	S_regcppop(pTHX_ regexp *rex, U32 *maxopenparen_p _pDEPTH);
#define PERL_ARGS_ASSERT_REGCPPOP	\
	assert(rex); assert(maxopenparen_p)
STATIC CHECKPOINT	S_regcppush(pTHX_ const regexp *rex, I32 parenfloor, U32 maxopenparen _pDEPTH);
#define PERL_ARGS_ASSERT_REGCPPUSH	\
	assert(rex)
STATIC U8*	S_reghop3(U8 *s, SSize_t off, const U8 *lim)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_REGHOP3	\
	assert(s); assert(lim)

STATIC U8*	S_reghop4(U8 *s, SSize_t off, const U8 *llim, const U8 *rlim)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_REGHOP4	\
	assert(s); assert(llim); assert(rlim)

STATIC U8*	S_reghopmaybe3(U8 *s, SSize_t off, const U8 * const lim)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_REGHOPMAYBE3	\
	assert(s); assert(lim)

STATIC bool	S_reginclass(pTHX_ regexp * const prog, const regnode * const n, const U8 * const p, const U8 * const p_end, bool const utf8_target)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_REGINCLASS	\
	assert(n); assert(p); assert(p_end)

STATIC SSize_t	S_regmatch(pTHX_ regmatch_info *reginfo, char *startpos, regnode *prog)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_REGMATCH	\
	assert(reginfo); assert(startpos); assert(prog)

STATIC I32	S_regrepeat(pTHX_ regexp *prog, char **startposp, const regnode *p, char *loceol, regmatch_info *const reginfo, I32 max _pDEPTH)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_REGREPEAT	\
	assert(prog); assert(startposp); assert(p); assert(loceol); assert(reginfo)

STATIC bool	S_regtry(pTHX_ regmatch_info *reginfo, char **startposp)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_REGTRY	\
	assert(reginfo); assert(startposp)

STATIC bool	S_to_byte_substr(pTHX_ regexp * prog);
#define PERL_ARGS_ASSERT_TO_BYTE_SUBSTR	\
	assert(prog)
STATIC void	S_to_utf8_substr(pTHX_ regexp * prog);
#define PERL_ARGS_ASSERT_TO_UTF8_SUBSTR	\
	assert(prog)
#endif
#if defined(PERL_IN_SCOPE_C)
STATIC void	S_save_pushptri32ptr(pTHX_ void *const ptr1, const I32 i, void *const ptr2, const int type);
#define PERL_ARGS_ASSERT_SAVE_PUSHPTRI32PTR
STATIC SV*	S_save_scalar_at(pTHX_ SV **sptr, const U32 flags);
#define PERL_ARGS_ASSERT_SAVE_SCALAR_AT	\
	assert(sptr)
#endif
#if defined(PERL_IN_SV_C)
STATIC char *	S_F0convert(NV nv, char *const endbuf, STRLEN *const len);
#define PERL_ARGS_ASSERT_F0CONVERT	\
	assert(endbuf); assert(len)
STATIC void	S_anonymise_cv_maybe(pTHX_ GV *gv, CV *cv);
#define PERL_ARGS_ASSERT_ANONYMISE_CV_MAYBE	\
	assert(gv); assert(cv)
STATIC void	S_assert_uft8_cache_coherent(pTHX_ const char *const func, STRLEN from_cache, STRLEN real, SV *const sv);
#define PERL_ARGS_ASSERT_ASSERT_UFT8_CACHE_COHERENT	\
	assert(func); assert(sv)
STATIC bool	S_curse(pTHX_ SV * const sv, const bool check_refcnt);
#define PERL_ARGS_ASSERT_CURSE	\
	assert(sv)
STATIC STRLEN	S_expect_number(pTHX_ const char **const pattern)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_EXPECT_NUMBER	\
	assert(pattern)

STATIC SSize_t	S_find_array_subscript(pTHX_ const AV *const av, const SV *const val);
#define PERL_ARGS_ASSERT_FIND_ARRAY_SUBSCRIPT	\
	assert(val)
STATIC SV *	S_find_hash_subscript(pTHX_ const HV *const hv, const SV *const val);
#define PERL_ARGS_ASSERT_FIND_HASH_SUBSCRIPT	\
	assert(val)
STATIC SV*	S_find_uninit_var(pTHX_ const OP *const obase, const SV *const uninit_sv, bool match, const char **desc_p);
#define PERL_ARGS_ASSERT_FIND_UNINIT_VAR	\
	assert(desc_p)
STATIC bool	S_glob_2number(pTHX_ GV* const gv);
#define PERL_ARGS_ASSERT_GLOB_2NUMBER	\
	assert(gv)
STATIC void	S_glob_assign_glob(pTHX_ SV *const dsv, SV *const ssv, const int dtype);
#define PERL_ARGS_ASSERT_GLOB_ASSIGN_GLOB	\
	assert(dsv); assert(ssv)
PERL_CALLCONV SV *	Perl_more_sv(pTHX);
#define PERL_ARGS_ASSERT_MORE_SV
STATIC void	S_not_a_number(pTHX_ SV *const sv);
#define PERL_ARGS_ASSERT_NOT_A_NUMBER	\
	assert(sv)
STATIC void	S_not_incrementable(pTHX_ SV *const sv);
#define PERL_ARGS_ASSERT_NOT_INCREMENTABLE	\
	assert(sv)
STATIC PTR_TBL_ENT_t *	S_ptr_table_find(PTR_TBL_t *const tbl, const void *const sv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_PTR_TABLE_FIND	\
	assert(tbl)

STATIC bool	S_sv_2iuv_common(pTHX_ SV *const sv);
#define PERL_ARGS_ASSERT_SV_2IUV_COMMON	\
	assert(sv)
STATIC void	S_sv_add_arena(pTHX_ char *const ptr, const U32 size, const U32 flags);
#define PERL_ARGS_ASSERT_SV_ADD_ARENA	\
	assert(ptr)
STATIC const char *	S_sv_display(pTHX_ SV *const sv, char *tmpbuf, STRLEN tmpbuf_size);
#define PERL_ARGS_ASSERT_SV_DISPLAY	\
	assert(sv); assert(tmpbuf)
STATIC STRLEN	S_sv_pos_b2u_midway(pTHX_ const U8 *const s, const U8 *const target, const U8 *end, STRLEN endu);
#define PERL_ARGS_ASSERT_SV_POS_B2U_MIDWAY	\
	assert(s); assert(target); assert(end)
STATIC STRLEN	S_sv_pos_u2b_cached(pTHX_ SV *const sv, MAGIC **const mgp, const U8 *const start, const U8 *const send, STRLEN uoffset, STRLEN uoffset0, STRLEN boffset0);
#define PERL_ARGS_ASSERT_SV_POS_U2B_CACHED	\
	assert(sv); assert(mgp); assert(start); assert(send)
STATIC STRLEN	S_sv_pos_u2b_forwards(const U8 *const start, const U8 *const send, STRLEN *const uoffset, bool *const at_end, bool *canonical_position);
#define PERL_ARGS_ASSERT_SV_POS_U2B_FORWARDS	\
	assert(start); assert(send); assert(uoffset); assert(at_end); assert(canonical_position)
STATIC STRLEN	S_sv_pos_u2b_midway(const U8 *const start, const U8 *send, STRLEN uoffset, const STRLEN uend);
#define PERL_ARGS_ASSERT_SV_POS_U2B_MIDWAY	\
	assert(start); assert(send)
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE void	S_sv_unglob(pTHX_ SV *const sv, U32 flags);
#define PERL_ARGS_ASSERT_SV_UNGLOB	\
	assert(sv)
#endif
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE char *	S_uiv_2buf(char *const buf, const IV iv, UV uv, const int is_uv, char **const peob)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_UIV_2BUF	\
	assert(buf); assert(peob)
#endif

STATIC void	S_utf8_mg_len_cache_update(pTHX_ SV *const sv, MAGIC **const mgp, const STRLEN ulen);
#define PERL_ARGS_ASSERT_UTF8_MG_LEN_CACHE_UPDATE	\
	assert(sv); assert(mgp)
STATIC void	S_utf8_mg_pos_cache_update(pTHX_ SV *const sv, MAGIC **const mgp, const STRLEN byte, const STRLEN utf8, const STRLEN blen);
#define PERL_ARGS_ASSERT_UTF8_MG_POS_CACHE_UPDATE	\
	assert(sv); assert(mgp)
STATIC I32	S_visit(pTHX_ SVFUNC_t f, const U32 flags, const U32 mask);
#define PERL_ARGS_ASSERT_VISIT	\
	assert(f)
#  if defined(USE_ITHREADS)
STATIC SV*	S_sv_dup_common(pTHX_ const SV *const ssv, CLONE_PARAMS *const param)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SV_DUP_COMMON	\
	assert(ssv); assert(param)

STATIC SV **	S_sv_dup_inc_multiple(pTHX_ SV *const *source, SV **dest, SSize_t items, CLONE_PARAMS *const param);
#define PERL_ARGS_ASSERT_SV_DUP_INC_MULTIPLE	\
	assert(source); assert(dest); assert(param)
STATIC void	S_unreferenced_to_tmp_stack(pTHX_ AV *const unreferenced);
#define PERL_ARGS_ASSERT_UNREFERENCED_TO_TMP_STACK	\
	assert(unreferenced)
#  endif
#endif
#if defined(PERL_IN_SV_C) || defined (PERL_IN_OP_C)
PERL_CALLCONV SV *	Perl_varname(pTHX_ const GV *const gv, const char gvtype, PADOFFSET targ, const SV *const keyname, SSize_t aindex, int subscript_type)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_VARNAME

#endif
#if defined(PERL_IN_TOKE_C)
STATIC int	S_ao(pTHX_ int toketype);
#define PERL_ARGS_ASSERT_AO
STATIC void	S_check_uni(pTHX);
#define PERL_ARGS_ASSERT_CHECK_UNI
STATIC void	S_checkcomma(pTHX_ const char *s, const char *name, const char *what);
#define PERL_ARGS_ASSERT_CHECKCOMMA	\
	assert(s); assert(name); assert(what)
STATIC char *	S_filter_gets(pTHX_ SV *sv, STRLEN append)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_FILTER_GETS	\
	assert(sv)

STATIC HV *	S_find_in_my_stash(pTHX_ const char *pkgname, STRLEN len)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_FIND_IN_MY_STASH	\
	assert(pkgname)

STATIC void	S_force_ident(pTHX_ const char *s, int kind);
#define PERL_ARGS_ASSERT_FORCE_IDENT	\
	assert(s)
STATIC void	S_force_ident_maybe_lex(pTHX_ char pit);
#define PERL_ARGS_ASSERT_FORCE_IDENT_MAYBE_LEX
STATIC void	S_force_next(pTHX_ I32 type);
#define PERL_ARGS_ASSERT_FORCE_NEXT
STATIC char*	S_force_strict_version(pTHX_ char *s);
#define PERL_ARGS_ASSERT_FORCE_STRICT_VERSION	\
	assert(s)
STATIC char*	S_force_version(pTHX_ char *s, int guessing);
#define PERL_ARGS_ASSERT_FORCE_VERSION	\
	assert(s)
STATIC char*	S_force_word(pTHX_ char *start, int token, int check_keyword, int allow_pack);
#define PERL_ARGS_ASSERT_FORCE_WORD	\
	assert(start)
STATIC SV*	S_get_and_check_backslash_N_name_wrapper(pTHX_ const char* s, const char* const e)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_GET_AND_CHECK_BACKSLASH_N_NAME_WRAPPER	\
	assert(s); assert(e)

STATIC void	S_incline(pTHX_ const char *s, const char *end);
#define PERL_ARGS_ASSERT_INCLINE	\
	assert(s); assert(end)
STATIC int	S_intuit_method(pTHX_ char *s, SV *ioname, CV *cv);
#define PERL_ARGS_ASSERT_INTUIT_METHOD	\
	assert(s)
STATIC int	S_intuit_more(pTHX_ char *s, char *e);
#define PERL_ARGS_ASSERT_INTUIT_MORE	\
	assert(s); assert(e)
STATIC I32	S_lop(pTHX_ I32 f, U8 x, char *s);
#define PERL_ARGS_ASSERT_LOP	\
	assert(s)
PERL_STATIC_NO_RET void	S_missingterm(pTHX_ char *s, STRLEN len)
			__attribute__noreturn__;
#define PERL_ARGS_ASSERT_MISSINGTERM

STATIC SV*	S_new_constant(pTHX_ const char *s, STRLEN len, const char *key, STRLEN keylen, SV *sv, SV *pv, const char *type, STRLEN typelen, const char ** error_msg);
#define PERL_ARGS_ASSERT_NEW_CONSTANT	\
	assert(key); assert(sv)
STATIC void	S_no_op(pTHX_ const char *const what, char *s);
#define PERL_ARGS_ASSERT_NO_OP	\
	assert(what)
STATIC void	S_parse_ident(pTHX_ char **s, char **d, char * const e, int allow_package, bool is_utf8, bool check_dollar, bool tick_warn);
#define PERL_ARGS_ASSERT_PARSE_IDENT	\
	assert(s); assert(d); assert(e)
STATIC int	S_pending_ident(pTHX);
#define PERL_ARGS_ASSERT_PENDING_IDENT
STATIC char*	S_scan_const(pTHX_ char *start)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SCAN_CONST	\
	assert(start)

STATIC char*	S_scan_formline(pTHX_ char *s)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SCAN_FORMLINE	\
	assert(s)

STATIC char*	S_scan_heredoc(pTHX_ char *s)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SCAN_HEREDOC	\
	assert(s)

STATIC char*	S_scan_ident(pTHX_ char *s, char *dest, STRLEN destlen, I32 ck_uni);
#define PERL_ARGS_ASSERT_SCAN_IDENT	\
	assert(s); assert(dest)
STATIC char*	S_scan_inputsymbol(pTHX_ char *start)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SCAN_INPUTSYMBOL	\
	assert(start)

STATIC char*	S_scan_pat(pTHX_ char *start, I32 type)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SCAN_PAT	\
	assert(start)

STATIC char*	S_scan_subst(pTHX_ char *start)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SCAN_SUBST	\
	assert(start)

STATIC char*	S_scan_trans(pTHX_ char *start)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SCAN_TRANS	\
	assert(start)

STATIC I32	S_sublex_done(pTHX)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SUBLEX_DONE

STATIC I32	S_sublex_push(pTHX)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SUBLEX_PUSH

STATIC I32	S_sublex_start(pTHX)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SUBLEX_START

STATIC char*	S_swallow_bom(pTHX_ U8 *s)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SWALLOW_BOM	\
	assert(s)

STATIC char *	S_tokenize_use(pTHX_ int is_use, char *s)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_TOKENIZE_USE	\
	assert(s)

STATIC SV*	S_tokeq(pTHX_ SV *sv);
#define PERL_ARGS_ASSERT_TOKEQ	\
	assert(sv)
STATIC void	S_update_debugger_info(pTHX_ SV *orig_sv, const char *const buf, STRLEN len);
#define PERL_ARGS_ASSERT_UPDATE_DEBUGGER_INFO
STATIC int	S_yywarn(pTHX_ const char *const s, U32 flags);
#define PERL_ARGS_ASSERT_YYWARN	\
	assert(s)
#endif
#if defined(PERL_IN_UNIVERSAL_C)
STATIC bool	S_isa_lookup(pTHX_ HV *stash, SV *namesv, const char * name, STRLEN len, U32 flags);
STATIC bool	S_sv_derived_from_svpvn(pTHX_ SV *sv, SV *namesv, const char * name, const STRLEN len, U32 flags);
#endif
#if defined(PERL_IN_UTF8_C)
STATIC UV	S__to_utf8_case(pTHX_ const UV original, const U8 *p, U8* ustrp, STRLEN *lenp, SV *invlist, const I32 * const invmap, const U32 * const * const aux_tables, const U8 * const aux_table_lengths, const char * const normal);
#define PERL_ARGS_ASSERT__TO_UTF8_CASE	\
	assert(ustrp); assert(lenp); assert(invlist); assert(invmap); assert(normal)
STATIC UV	S_check_locale_boundary_crossing(pTHX_ const U8* const p, const UV result, U8* const ustrp, STRLEN *lenp)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CHECK_LOCALE_BOUNDARY_CROSSING	\
	assert(p); assert(ustrp); assert(lenp)

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE int	S_does_utf8_overflow(const U8 * const s, const U8 * e, const bool consider_overlongs)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DOES_UTF8_OVERFLOW	\
	assert(s); assert(e)
#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE int	S_isFF_overlong(const U8 * const s, const STRLEN len)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_ISFF_OVERLONG	\
	assert(s)
#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE bool	S_is_utf8_common(pTHX_ const U8 *const p, const U8 *const e, SV* const invlist)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_UTF8_COMMON	\
	assert(p); assert(e)
#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE int	S_is_utf8_overlong(const U8 * const s, const STRLEN len)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_IS_UTF8_OVERLONG	\
	assert(s)
#endif

STATIC HV *	S_new_msg_hv(pTHX_ const char * const message, U32 categories, U32 flag)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEW_MSG_HV	\
	assert(message)

STATIC UV	S_to_case_cp_list(pTHX_ const UV original, const U32 ** const remaining_list, Size_t * remaining_count, SV *invlist, const I32 * const invmap, const U32 * const * const aux_tables, const U8 * const aux_table_lengths, const char * const normal);
#define PERL_ARGS_ASSERT_TO_CASE_CP_LIST	\
	assert(invlist); assert(invmap); assert(normal)
STATIC U8	S_to_lower_latin1(const U8 c, U8 *p, STRLEN *lenp, const char dummy)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_TO_LOWER_LATIN1

STATIC UV	S_turkic_fc(pTHX_ const U8 * const p, const U8 * const e, U8* ustrp, STRLEN *lenp);
#define PERL_ARGS_ASSERT_TURKIC_FC	\
	assert(p); assert(e); assert(ustrp); assert(lenp)
STATIC UV	S_turkic_lc(pTHX_ const U8 * const p0, const U8 * const e, U8* ustrp, STRLEN *lenp);
#define PERL_ARGS_ASSERT_TURKIC_LC	\
	assert(p0); assert(e); assert(ustrp); assert(lenp)
STATIC UV	S_turkic_uc(pTHX_ const U8 * const p, const U8 * const e, U8* ustrp, STRLEN *lenp);
#define PERL_ARGS_ASSERT_TURKIC_UC	\
	assert(p); assert(e); assert(ustrp); assert(lenp)
STATIC char *	S_unexpected_non_continuation_text(pTHX_ const U8 * const s, STRLEN print_len, const STRLEN non_cont_byte_pos, const STRLEN expect_len)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_UNEXPECTED_NON_CONTINUATION_TEXT	\
	assert(s)

#endif
#if defined(PERL_IN_UTF8_C) || defined(PERL_IN_PP_C)
PERL_CALLCONV UV	Perl__to_upper_title_latin1(pTHX_ const U8 c, U8 *p, STRLEN *lenp, const char S_or_s);
#define PERL_ARGS_ASSERT__TO_UPPER_TITLE_LATIN1	\
	assert(p); assert(lenp)
#endif
#if defined(PERL_IN_UTIL_C)
STATIC bool	S_ckwarn_common(pTHX_ U32 w);
#define PERL_ARGS_ASSERT_CKWARN_COMMON
STATIC bool	S_invoke_exception_hook(pTHX_ SV *ex, bool warn);
#define PERL_ARGS_ASSERT_INVOKE_EXCEPTION_HOOK
STATIC SV*	S_mess_alloc(pTHX);
#define PERL_ARGS_ASSERT_MESS_ALLOC
STATIC SV *	S_with_queued_errors(pTHX_ SV *ex);
#define PERL_ARGS_ASSERT_WITH_QUEUED_ERRORS	\
	assert(ex)
STATIC void	S_xs_version_bootcheck(pTHX_ U32 items, U32 ax, const char *xs_p, STRLEN xs_len);
#define PERL_ARGS_ASSERT_XS_VERSION_BOOTCHECK	\
	assert(xs_p)
#  if defined(PERL_MEM_LOG) && !defined(PERL_MEM_LOG_NOIMPL)
STATIC void	S_mem_log_common(enum mem_log_type mlt, const UV n, const UV typesize, const char *type_name, const SV *sv, Malloc_t oldalloc, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname);
#define PERL_ARGS_ASSERT_MEM_LOG_COMMON	\
	assert(type_name); assert(filename); assert(funcname)
#  endif
#endif
#if defined(PERL_MEM_LOG)
PERL_CALLCONV Malloc_t	Perl_mem_log_alloc(const UV nconst, UV typesize, const char *type_name, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname);
#define PERL_ARGS_ASSERT_MEM_LOG_ALLOC	\
	assert(type_name); assert(filename); assert(funcname)
PERL_CALLCONV Malloc_t	Perl_mem_log_free(Malloc_t oldalloc, const char *filename, const int linenumber, const char *funcname);
#define PERL_ARGS_ASSERT_MEM_LOG_FREE	\
	assert(filename); assert(funcname)
PERL_CALLCONV Malloc_t	Perl_mem_log_realloc(const UV n, const UV typesize, const char *type_name, Malloc_t oldalloc, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname);
#define PERL_ARGS_ASSERT_MEM_LOG_REALLOC	\
	assert(type_name); assert(filename); assert(funcname)
#endif
#if defined(PERL_USES_PL_PIDSTATUS) && defined(PERL_IN_UTIL_C)
STATIC void	S_pidgone(pTHX_ Pid_t pid, int status);
#define PERL_ARGS_ASSERT_PIDGONE
#endif
#if defined(PERL_USE_3ARG_SIGHANDLER)
PERL_CALLCONV Signal_t	Perl_csighandler(int sig, Siginfo_t *info, void *uap);
#define PERL_ARGS_ASSERT_CSIGHANDLER
PERL_CALLCONV Signal_t	Perl_sighandler(int sig, Siginfo_t *info, void *uap);
#define PERL_ARGS_ASSERT_SIGHANDLER
#endif
#if defined(U64TYPE)	/* HAS_QUAD undefined outside of core */
#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE unsigned	Perl_lsbit_pos64(U64 word)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_LSBIT_POS64
#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE unsigned	Perl_msbit_pos64(U64 word)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_MSBIT_POS64
#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE unsigned	Perl_single_1bit_pos64(U64 word)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SINGLE_1BIT_POS64
#endif

#endif
#if defined(UNLINK_ALL_VERSIONS)
PERL_CALLCONV I32	Perl_unlnk(pTHX_ const char* f);
#define PERL_ARGS_ASSERT_UNLNK	\
	assert(f)
#endif
#if defined(USE_C_BACKTRACE)
PERL_CALLCONV bool	Perl_dump_c_backtrace(pTHX_ PerlIO* fp, int max_depth, int skip);
#define PERL_ARGS_ASSERT_DUMP_C_BACKTRACE	\
	assert(fp)
/* PERL_CALLCONV void	free_c_backtrace(pTHX_ Perl_c_backtrace* bt); */
#define PERL_ARGS_ASSERT_FREE_C_BACKTRACE
PERL_CALLCONV Perl_c_backtrace*	Perl_get_c_backtrace(pTHX_ int max_depth, int skip);
#define PERL_ARGS_ASSERT_GET_C_BACKTRACE
PERL_CALLCONV SV*	Perl_get_c_backtrace_dump(pTHX_ int max_depth, int skip);
#define PERL_ARGS_ASSERT_GET_C_BACKTRACE_DUMP
#endif
#if defined(USE_DTRACE)
PERL_CALLCONV void	Perl_dtrace_probe_call(pTHX_ CV *cv, bool is_call);
#define PERL_ARGS_ASSERT_DTRACE_PROBE_CALL	\
	assert(cv)
PERL_CALLCONV void	Perl_dtrace_probe_load(pTHX_ const char *name, bool is_loading);
#define PERL_ARGS_ASSERT_DTRACE_PROBE_LOAD	\
	assert(name)
PERL_CALLCONV void	Perl_dtrace_probe_op(pTHX_ const OP *op);
#define PERL_ARGS_ASSERT_DTRACE_PROBE_OP	\
	assert(op)
PERL_CALLCONV void	Perl_dtrace_probe_phase(pTHX_ enum perl_phase phase);
#define PERL_ARGS_ASSERT_DTRACE_PROBE_PHASE
#endif
#if defined(USE_ITHREADS)
PERL_CALLCONV PADOFFSET	Perl_alloccopstash(pTHX_ HV *hv);
#define PERL_ARGS_ASSERT_ALLOCCOPSTASH	\
	assert(hv)
PERL_CALLCONV void*	Perl_any_dup(pTHX_ void* v, const PerlInterpreter* proto_perl)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_ANY_DUP	\
	assert(proto_perl)

PERL_CALLCONV void	Perl_clone_params_del(CLONE_PARAMS *param);
#define PERL_ARGS_ASSERT_CLONE_PARAMS_DEL	\
	assert(param)
PERL_CALLCONV CLONE_PARAMS *	Perl_clone_params_new(PerlInterpreter *const from, PerlInterpreter *const to)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CLONE_PARAMS_NEW	\
	assert(from); assert(to)

#ifndef PERL_NO_INLINE_FUNCTIONS
PERL_STATIC_INLINE AV*	Perl_cop_file_avn(pTHX_ const COP *cop);
#define PERL_ARGS_ASSERT_COP_FILE_AVN	\
	assert(cop)
#endif
PERL_CALLCONV PERL_CONTEXT*	Perl_cx_dup(pTHX_ PERL_CONTEXT* cx, I32 ix, I32 max, CLONE_PARAMS* param)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_CX_DUP	\
	assert(param)

PERL_CALLCONV DIR*	Perl_dirp_dup(pTHX_ DIR *const dp, CLONE_PARAMS *const param)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_DIRP_DUP	\
	assert(param)

PERL_CALLCONV PerlIO*	Perl_fp_dup(pTHX_ PerlIO *const fp, const char type, CLONE_PARAMS *const param);
#define PERL_ARGS_ASSERT_FP_DUP	\
	assert(param)
PERL_CALLCONV GP*	Perl_gp_dup(pTHX_ GP *const gp, CLONE_PARAMS *const param)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_GP_DUP	\
	assert(param)

PERL_CALLCONV HE*	Perl_he_dup(pTHX_ const HE* e, bool shared, CLONE_PARAMS* param)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_HE_DUP	\
	assert(param)

PERL_CALLCONV HEK*	Perl_hek_dup(pTHX_ HEK* e, CLONE_PARAMS* param)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_HEK_DUP	\
	assert(param)

PERL_CALLCONV MAGIC*	Perl_mg_dup(pTHX_ MAGIC *mg, CLONE_PARAMS *const param)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_MG_DUP	\
	assert(param)

PERL_CALLCONV struct mro_meta*	Perl_mro_meta_dup(pTHX_ struct mro_meta* smeta, CLONE_PARAMS* param);
#define PERL_ARGS_ASSERT_MRO_META_DUP	\
	assert(smeta); assert(param)
PERL_CALLCONV OP*	Perl_newPADOP(pTHX_ I32 type, I32 flags, SV* sv)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_NEWPADOP	\
	assert(sv)

PERL_CALLCONV PADLIST *	Perl_padlist_dup(pTHX_ PADLIST *srcpad, CLONE_PARAMS *param)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_PADLIST_DUP	\
	assert(srcpad); assert(param)

PERL_CALLCONV PADNAME *	Perl_padname_dup(pTHX_ PADNAME *src, CLONE_PARAMS *param)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_PADNAME_DUP	\
	assert(src); assert(param)

PERL_CALLCONV PADNAMELIST *	Perl_padnamelist_dup(pTHX_ PADNAMELIST *srcpad, CLONE_PARAMS *param)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_PADNAMELIST_DUP	\
	assert(srcpad); assert(param)

PERL_CALLCONV yy_parser*	Perl_parser_dup(pTHX_ const yy_parser *const proto, CLONE_PARAMS *const param);
#define PERL_ARGS_ASSERT_PARSER_DUP	\
	assert(param)
PERL_CALLCONV PerlInterpreter*	perl_clone(PerlInterpreter *proto_perl, UV flags);
#define PERL_ARGS_ASSERT_PERL_CLONE	\
	assert(proto_perl)
PERL_CALLCONV void	Perl_re_dup_guts(pTHX_ const REGEXP *sstr, REGEXP *dstr, CLONE_PARAMS* param);
#define PERL_ARGS_ASSERT_RE_DUP_GUTS	\
	assert(sstr); assert(dstr); assert(param)
PERL_CALLCONV void*	Perl_regdupe_internal(pTHX_ REGEXP * const r, CLONE_PARAMS* param);
#define PERL_ARGS_ASSERT_REGDUPE_INTERNAL	\
	assert(r); assert(param)
PERL_CALLCONV void	Perl_rvpv_dup(pTHX_ SV *const dsv, const SV *const ssv, CLONE_PARAMS *const param);
#define PERL_ARGS_ASSERT_RVPV_DUP	\
	assert(dsv); assert(ssv); assert(param)
PERL_CALLCONV PERL_SI*	Perl_si_dup(pTHX_ PERL_SI* si, CLONE_PARAMS* param)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SI_DUP	\
	assert(param)

PERL_CALLCONV ANY*	Perl_ss_dup(pTHX_ PerlInterpreter* proto_perl, CLONE_PARAMS* param)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SS_DUP	\
	assert(proto_perl); assert(param)

PERL_CALLCONV SV*	Perl_sv_dup(pTHX_ const SV *const ssv, CLONE_PARAMS *const param)
			__attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SV_DUP	\
	assert(param)

PERL_CALLCONV SV*	Perl_sv_dup_inc(pTHX_ const SV *const ssv, CLONE_PARAMS *const param)
			__attribute__warn_unused_result__;
