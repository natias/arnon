  vec($_, 7, 1) = 1   ==        128 00000001000000000000000000000000
  vec($_, 8, 1) = 1   ==        256 00000000100000000000000000000000
  vec($_, 9, 1) = 1   ==        512 00000000010000000000000000000000
  vec($_,10, 1) = 1   ==       1024 00000000001000000000000000000000
  vec($_,11, 1) = 1   ==       2048 00000000000100000000000000000000
  vec($_,12, 1) = 1   ==       4096 00000000000010000000000000000000
  vec($_,13, 1) = 1   ==       8192 00000000000001000000000000000000
  vec($_,14, 1) = 1   ==      16384 00000000000000100000000000000000
  vec($_,15, 1) = 1   ==      32768 00000000000000010000000000000000
  vec($_,16, 1) = 1   ==      65536 00000000000000001000000000000000
  vec($_,17, 1) = 1   ==     131072 00000000000000000100000000000000
  vec($_,18, 1) = 1   ==     262144 00000000000000000010000000000000
  vec($_,19, 1) = 1   ==     524288 00000000000000000001000000000000
  vec($_,20, 1) = 1   ==    1048576 00000000000000000000100000000000
  vec($_,21, 1) = 1   ==    2097152 00000000000000000000010000000000
  vec($_,22, 1) = 1   ==    4194304 00000000000000000000001000000000
  vec($_,23, 1) = 1   ==    8388608 00000000000000000000000100000000
  vec($_,24, 1) = 1   ==   16777216 00000000000000000000000010000000
  vec($_,25, 1) = 1   ==   33554432 00000000000000000000000001000000
  vec($_,26, 1) = 1   ==   67108864 00000000000000000000000000100000
  vec($_,27, 1) = 1   ==  134217728 00000000000000000000000000010000
  vec($_,28, 1) = 1   ==  268435456 00000000000000000000000000001000
  vec($_,29, 1) = 1   ==  536870912 00000000000000000000000000000100
  vec($_,30, 1) = 1   == 1073741824 00000000000000000000000000000010
  vec($_,31, 1) = 1   == 2147483648 00000000000000000000000000000001
  vec($_, 0, 2) = 1   ==          1 10000000000000000000000000000000
  vec($_, 1, 2) = 1   ==          4 00100000000000000000000000000000
  vec($_, 2, 2) = 1   ==         16 00001000000000000000000000000000
  vec($_, 3, 2) = 1   ==         64 00000010000000000000000000000000
  vec($_, 4, 2) = 1   ==        256 00000000100000000000000000000000
  vec($_, 5, 2) = 1   ==       1024 00000000001000000000000000000000
  vec($_, 6, 2) = 1   ==       4096 00000000000010000000000000000000
  vec($_, 7, 2) = 1   ==      16384 00000000000000100000000000000000
  vec($_, 8, 2) = 1   ==      65536 00000000000000001000000000000000
  vec($_, 9, 2) = 1   ==     262144 00000000000000000010000000000000
  vec($_,10, 2) = 1   ==    1048576 00000000000000000000100000000000
  vec($_,11, 2) = 1   ==    4194304 00000000000000000000001000000000
  vec($_,12, 2) = 1   ==   16777216 00000000000000000000000010000000
  vec($_,13, 2) = 1   ==   67108864 00000000000000000000000000100000
  vec($_,14, 2) = 1   ==  268435456 00000000000000000000000000001000
  vec($_,15, 2) = 1   == 1073741824 00000000000000000000000000000010
  vec($_, 0, 2) = 2   ==          2 01000000000000000000000000000000
  vec($_, 1, 2) = 2   ==          8 00010000000000000000000000000000
  vec($_, 2, 2) = 2   ==         32 00000100000000000000000000000000
  vec($_, 3, 2) = 2   ==        128 00000001000000000000000000000000
  vec($_, 4, 2) = 2   ==        512 00000000010000000000000000000000
  vec($_, 5, 2) = 2   ==       2048 00000000000100000000000000000000
  vec($_, 6, 2) = 2   ==       8192 00000000000001000000000000000000
  vec($_, 7, 2) = 2   ==      32768 00000000000000010000000000000000
  vec($_, 8, 2) = 2   ==     131072 00000000000000000100000000000000
  vec($_, 9, 2) = 2   ==     524288 00000000000000000001000000000000
  vec($_,10, 2) = 2   ==    2097152 00000000000000000000010000000000
  vec($_,11, 2) = 2   ==    8388608 00000000000000000000000100000000
  vec($_,12, 2) = 2   ==   33554432 00000000000000000000000001000000
  vec($_,13, 2) = 2   ==  134217728 00000000000000000000000000010000
  vec($_,14, 2) = 2   ==  536870912 00000000000000000000000000000100
  vec($_,15, 2) = 2   == 2147483648 00000000000000000000000000000001
  vec($_, 0, 4) = 1   ==          1 10000000000000000000000000000000
  vec($_, 1, 4) = 1   ==         16 00001000000000000000000000000000
  vec($_, 2, 4) = 1   ==        256 00000000100000000000000000000000
  vec($_, 3, 4) = 1   ==       4096 00000000000010000000000000000000
  vec($_, 4, 4) = 1   ==      65536 00000000000000001000000000000000
  vec($_, 5, 4) = 1   ==    1048576 00000000000000000000100000000000
  vec($_, 6, 4) = 1   ==   16777216 00000000000000000000000010000000
  vec($_, 7, 4) = 1   ==  268435456 00000000000000000000000000001000
  vec($_, 0, 4) = 2   ==          2 01000000000000000000000000000000
  vec($_, 1, 4) = 2   ==         32 00000100000000000000000000000000
  vec($_, 2, 4) = 2   ==        512 00000000010000000000000000000000
  vec($_, 3, 4) = 2   ==       8192 00000000000001000000000000000000
  vec($_, 4, 4) = 2   ==     131072 00000000000000000100000000000000
  vec($_, 5, 4) = 2   ==    2097152 00000000000000000000010000000000
  vec($_, 6, 4) = 2   ==   33554432 00000000000000000000000001000000
  vec($_, 7, 4) = 2   ==  536870912 00000000000000000000000000000100
  vec($_, 0, 4) = 4   ==          4 00100000000000000000000000000000
  vec($_, 1, 4) = 4   ==         64 00000010000000000000000000000000
  vec($_, 2, 4) = 4   ==       1024 00000000001000000000000000000000
  vec($_, 3, 4) = 4   ==      16384 00000000000000100000000000000000
  vec($_, 4, 4) = 4   ==     262144 00000000000000000010000000000000
  vec($_, 5, 4) = 4   ==    4194304 00000000000000000000001000000000
  vec($_, 6, 4) = 4   ==   67108864 00000000000000000000000000100000
  vec($_, 7, 4) = 4   == 1073741824 00000000000000000000000000000010
  vec($_, 0, 4) = 8   ==          8 00010000000000000000000000000000
  vec($_, 1, 4) = 8   ==        128 00000001000000000000000000000000
  vec($_, 2, 4) = 8   ==       2048 00000000000100000000000000000000
  vec($_, 3, 4) = 8   ==      32768 00000000000000010000000000000000
  vec($_, 4, 4) = 8   ==     524288 00000000000000000001000000000000
  vec($_, 5, 4) = 8   ==    8388608 00000000000000000000000100000000
  vec($_, 6, 4) = 8   ==  134217728 00000000000000000000000000010000
  vec($_, 7, 4) = 8   == 2147483648 00000000000000000000000000000001
  vec($_, 0, 8) = 1   ==          1 10000000000000000000000000000000
  vec($_, 1, 8) = 1   ==        256 00000000100000000000000000000000
  vec($_, 2, 8) = 1   ==      65536 00000000000000001000000000000000
  vec($_, 3, 8) = 1   ==   16777216 00000000000000000000000010000000
  vec($_, 0, 8) = 2   ==          2 01000000000000000000000000000000
  vec($_, 1, 8) = 2   ==        512 00000000010000000000000000000000
  vec($_, 2, 8) = 2   ==     131072 00000000000000000100000000000000
  vec($_, 3, 8) = 2   ==   33554432 00000000000000000000000001000000
  vec($_, 0, 8) = 4   ==          4 00100000000000000000000000000000
  vec($_, 1, 8) = 4   ==       1024 00000000001000000000000000000000
  vec($_, 2, 8) = 4   ==     262144 00000000000000000010000000000000
  vec($_, 3, 8) = 4   ==   67108864 00000000000000000000000000100000
  vec($_, 0, 8) = 8   ==          8 00010000000000000000000000000000
  vec($_, 1, 8) = 8   ==       2048 00000000000100000000000000000000
  vec($_, 2, 8) = 8   ==     524288 00000000000000000001000000000000
  vec($_, 3, 8) = 8   ==  134217728 00000000000000000000000000010000
  vec($_, 0, 8) = 16  ==         16 00001000000000000000000000000000
  vec($_, 1, 8) = 16  ==       4096 00000000000010000000000000000000
  vec($_, 2, 8) = 16  ==    1048576 00000000000000000000100000000000
  vec($_, 3, 8) = 16  ==  268435456 00000000000000000000000000001000
  vec($_, 0, 8) = 32  ==         32 00000100000000000000000000000000
  vec($_, 1, 8) = 32  ==       8192 00000000000001000000000000000000
  vec($_, 2, 8) = 32  ==    2097152 00000000000000000000010000000000
  vec($_, 3, 8) = 32  ==  536870912 00000000000000000000000000000100
  vec($_, 0, 8) = 64  ==         64 00000010000000000000000000000000
  vec($_, 1, 8) = 64  ==      16384 00000000000000100000000000000000
  vec($_, 2, 8) = 64  ==    4194304 00000000000000000000001000000000
  vec($_, 3, 8) = 64  == 1073741824 00000000000000000000000000000010
  vec($_, 0, 8) = 128 ==        128 00000001000000000000000000000000
  vec($_, 1, 8) = 128 ==      32768 00000000000000010000000000000000
  vec($_, 2, 8) = 128 ==    8388608 00000000000000000000000100000000
  vec($_, 3, 8) = 128 == 2147483648 00000000000000000000000000000001

=item wait
X<wait>

=for Pod::Functions wait for any child process to die

Behaves like L<wait(2)> on your system: it waits for a child
process to terminate and returns the pid of the deceased process, or
C<-1> if there are no child processes.  The status is returned in
L<C<$?>|perlvar/$?> and
L<C<${^CHILD_ERROR_NATIVE}>|perlvar/${^CHILD_ERROR_NATIVE}>.
Note that a return value of C<-1> could mean that child processes are
being automatically reaped, as described in L<perlipc>.

If you use L<C<wait>|/wait> in your handler for
L<C<$SIG{CHLD}>|perlvar/%SIG>, it may accidentally wait for the child
created by L<C<qx>|/qxE<sol>STRINGE<sol>> or L<C<system>|/system LIST>.
See L<perlipc> for details.

Equivalent to L<C<waitpid(-1, 0)>|/waitpid PID,FLAGS>.

Portability issues: L<perlport/wait>.

=item waitpid PID,FLAGS
X<waitpid>

=for Pod::Functions wait for a particular child process to die

Waits for a particular child process to terminate and returns the pid of
the deceased process, or C<-1> if there is no such child process.  A
non-blocking wait (with L<WNOHANG|POSIX/C<WNOHANG>> in FLAGS) can return 0 if
there are child processes matching PID but none have terminated yet.
The status is returned in L<C<$?>|perlvar/$?> and
L<C<${^CHILD_ERROR_NATIVE}>|perlvar/${^CHILD_ERROR_NATIVE}>.

A PID of C<0> indicates to wait for any child process whose process group ID is
equal to that of the current process.  A PID of less than C<-1> indicates to
wait for any child process whose process group ID is equal to -PID.  A PID of
C<-1> indicates to wait for any child process.

If you say

    use POSIX ":sys_wait_h";

    my $kid;
    do {
        $kid = waitpid(-1, WNOHANG);
    } while $kid > 0;

or

    1 while waitpid(-1, WNOHANG) > 0;

then you can do a non-blocking wait for all pending zombie processes (see
L<POSIX/WAIT>).
Non-blocking wait is available on machines supporting either the
L<waitpid(2)> or L<wait4(2)> syscalls.  However, waiting for a particular
pid with FLAGS of C<0> is implemented everywhere.  (Perl emulates the
system call by remembering the status values of processes that have
exited but have not been harvested by the Perl script yet.)

Note that on some systems, a return value of C<-1> could mean that child
processes are being automatically reaped.  See L<perlipc> for details,
and for other examples.

Portability issues: L<perlport/waitpid>.

=item wantarray
X<wantarray> X<context>

=for Pod::Functions get void vs scalar vs list context of current subroutine call

Returns true if the context of the currently executing subroutine or
L<C<eval>|/eval EXPR> is looking for a list value.  Returns false if the
context is
looking for a scalar.  Returns the undefined value if the context is
looking for no value (void context).

    return unless defined wantarray; # don't bother doing more
    my @a = complex_calculation();
    return wantarray ? @a : "@a";

L<C<wantarray>|/wantarray>'s result is unspecified in the top level of a file,
in a C<BEGIN>, C<UNITCHECK>, C<CHECK>, C<INIT> or C<END> block, or
in a C<DESTROY> method.

This function should have been named wantlist() instead.

=item warn LIST
X<warn> X<warning> X<STDERR>

=for Pod::Functions print debugging info

Emits a warning, usually by printing it to C<STDERR>.  C<warn> interprets
its operand LIST in the same way as C<die>, but is slightly different
in what it defaults to when LIST is empty or makes an empty string.
If it is empty and L<C<$@>|perlvar/$@> already contains an exception
value then that value is used after appending C<"\t...caught">.  If it
is empty and C<$@> is also empty then the string C<"Warning: Something's
wrong"> is used.

By default, the exception derived from the operand LIST is stringified
and printed to C<STDERR>.  This behaviour can be altered by installing
a L<C<$SIG{__WARN__}>|perlvar/%SIG> handler.  If there is such a
handler then no message is automatically printed; it is the handler's
responsibility to deal with the exception
as it sees fit (like, for instance, converting it into a
L<C<die>|/die LIST>).  Most
handlers must therefore arrange to actually display the
warnings that they are not prepared to deal with, by calling
L<C<warn>|/warn LIST>
again in the handler.  Note that this is quite safe and will not
produce an endless loop, since C<__WARN__> hooks are not called from
inside one.

You will find this behavior is slightly different from that of
L<C<$SIG{__DIE__}>|perlvar/%SIG> handlers (which don't suppress the
error text, but can instead call L<C<die>|/die LIST> again to change
it).

Using a C<__WARN__> handler provides a powerful way to silence all
warnings (even the so-called mandatory ones).  An example:

    # wipe out *all* compile-time warnings
    BEGIN { $SIG{'__WARN__'} = sub { warn $_[0] if $DOWARN } }
    my $foo = 10;
    my $foo = 20;          # no warning about duplicate my $foo,
                           # but hey, you asked for it!
    # no compile-time or run-time warnings before here
    $DOWARN = 1;

    # run-time warnings enabled after here
    warn "\$foo is alive and $foo!";     # does show up

See L<perlvar> for details on setting L<C<%SIG>|perlvar/%SIG> entries
and for more
examples.  See the L<Carp> module for other kinds of warnings using its
C<carp> and C<cluck> functions.

=item write FILEHANDLE
X<write>

=item write EXPR

=item write

=for Pod::Functions print a picture record

Writes a formatted record (possibly multi-line) to the specified FILEHANDLE,
using the format associated with that file.  By default the format for
a file is the one having the same name as the filehandle, but the
format for the current output channel (see the
L<C<select>|/select FILEHANDLE> function) may be set explicitly by
assigning the name of the format to the L<C<$~>|perlvar/$~> variable.

Top of form processing is handled automatically:  if there is insufficient
room on the current page for the formatted record, the page is advanced by
writing a form feed and a special top-of-page
format is used to format the new
page header before the record is written.  By default, the top-of-page
format is the name of the filehandle with C<_TOP> appended, or C<top>
in the current package if the former does not exist.  This would be a
problem with autovivified filehandles, but it may be dynamically set to the
format of your choice by assigning the name to the L<C<$^>|perlvar/$^>
variable while that filehandle is selected.  The number of lines
remaining on the current page is in variable L<C<$->|perlvar/$->, which
can be set to C<0> to force a new page.

If FILEHANDLE is unspecified, output goes to the current default output
channel, which starts out as STDOUT but may be changed by the
L<C<select>|/select FILEHANDLE> operator.  If the FILEHANDLE is an EXPR,
then the expression
is evaluated and the resulting string is used to look up the name of
the FILEHANDLE at run time.  For more on formats, see L<perlform>.

Note that write is I<not> the opposite of
L<C<read>|/read FILEHANDLE,SCALAR,LENGTH,OFFSET>.  Unfortunately.

=item y///

=for Pod::Functions transliterate a string

The transliteration operator.  Same as
L<C<trE<sol>E<sol>E<sol>>|/trE<sol>E<sol>E<sol>>.  See
L<perlop/"Quote-Like Operators">.

=back

=head2 Non-function Keywords by Cross-reference

=head3 perldata

=over

=item __DATA__

=item __END__

These keywords are documented in L<perldata/"Special Literals">.

=back

=head3 perlmod

=over

=item BEGIN

=item CHECK

=item END

=item INIT

=item UNITCHECK

These compile phase keywords are documented in L<perlmod/"BEGIN, UNITCHECK, CHECK, INIT and END">.

=back

=head3 perlobj

=over

=item DESTROY

This method keyword is documented in L<perlobj/"Destructors">.

=back

=head3 perlop

=over

=item and

=item cmp

=item eq

=item ge

=item gt

=item isa

=item le

=item lt

=item ne

=item not

=item or

=item x

=item xor

These operators are documented in L<perlop>.

=back

=head3 perlsub

=over

=item AUTOLOAD

This keyword is documented in L<perlsub/"Autoloading">.

=back

=head3 perlsyn

=over

=item else

=item elsif

=item for

=item foreach

=item if

=item unless

=item until

=item while

These flow-control keywords are documented in L<perlsyn/"Compound Statements">.

=item elseif

The "else if" keyword is spelled C<elsif> in Perl.  There's no C<elif>
or C<else if> either.  It does parse C<elseif>, but only to warn you
about not using it.

See the documentation for flow-control keywords in L<perlsyn/"Compound
Statements">.

=back

=over

=item default

=item given

=item when

These flow-control keywords related to the experimental switch feature are
documented in L<perlsyn/"Switch Statements">.

=back

=over

=item try

=item catch

=item finally

These flow-control keywords related to the experimental C<try> feature are
documented in L<perlsyn/"Try Catch Exception Handling">.

=back

=over

=item defer

This flow-control keyword related to the experimental C<defer> feature is
documented in L<perlsyn/"defer blocks">.

=back

=over

=item ADJUST

This class-related phaser block is documented in L<perlclass>.

=back

=cut
                                                                                                                                                                                                usr/local/lib/perl5/5.40.0/pod/perlgit.pod                                                          0000644 0000000 0000000 00000076056 14714567415 016460  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =encoding utf8

=for comment
Consistent formatting of this file is achieved with:
  perl ./Porting/podtidy pod/perlgit.pod

=head1 NAME

perlgit - Detailed information about git and the Perl repository

=head1 DESCRIPTION

This document provides details on using git to develop Perl. If you are
just interested in working on a quick patch, see L<perlhack> first.
This document is intended for people who are regular contributors to
Perl, including those with write access to the git repository.

=head1 CLONING THE REPOSITORY

All of Perl's source code is kept centrally in a Git repository at
I<github.com>.

You can make a read-only clone of the repository by running:

  % git clone git@github.com:Perl/perl5.git perl

If you cannot use that for firewall reasons, you can also clone via http:

  % git clone https://github.com/Perl/perl5.git perl

=head1 WORKING WITH THE REPOSITORY

Once you have changed into the repository directory, you can inspect
it. After a clone the repository will contain a single local branch,
which will be the current branch as well, as indicated by the asterisk.

  % git branch
  * blead

Using the -a switch to C<branch> will also show the remote tracking
branches in the repository:

  % git branch -a
  * blead
    origin/HEAD
    origin/blead
  ...

The branches that begin with "origin" correspond to the "git remote"
that you cloned from (which is named "origin"). Each branch on the
remote will be exactly tracked by these branches. You should NEVER do
work on these remote tracking branches. You only ever do work in a
local branch. Local branches can be configured to automerge (on pull)
from a designated remote tracking branch. This is the case with the
default branch C<blead> which will be configured to merge from the
remote tracking branch C<origin/blead>.

You can see recent commits:

  % git log

And pull new changes from the repository, and update your local
repository (must be clean first)

  % git pull

Assuming we are on the branch C<blead> immediately after a pull, this
command would be more or less equivalent to:

  % git fetch
  % git merge origin/blead

In fact if you want to update your local repository without touching
your working directory you do:

  % git fetch

And if you want to update your remote-tracking branches for all defined
remotes simultaneously you can do

  % git remote update

Neither of these last two commands will update your working directory,
however both will update the remote-tracking branches in your
repository.

To make a local branch of a remote branch:

  % git checkout -b maint-5.10 origin/maint-5.10

To switch back to blead:

  % git checkout blead

=head2 Finding out your status

The most common git command you will use will probably be

  % git status

This command will produce as output a description of the current state
of the repository, including modified files and unignored untracked
files, and in addition it will show things like what files have been
staged for the next commit, and usually some useful information about
how to change things. For instance the following:

 % git status
 On branch blead
 Your branch is ahead of 'origin/blead' by 1 commit.

 Changes to be committed:
   (use "git reset HEAD <file>..." to unstage)

       modified:   pod/perlgit.pod

 Changes not staged for commit:
   (use "git add <file>..." to update what will be committed)
   (use "git checkout -- <file>..." to discard changes in working
                                                              directory)

       modified:   pod/perlgit.pod

 Untracked files:
   (use "git add <file>..." to include in what will be committed)

       deliberate.untracked

This shows that there were changes to this document staged for commit,
and that there were further changes in the working directory not yet
staged. It also shows that there was an untracked file in the working
directory, and as you can see shows how to change all of this. It also
shows that there is one commit on the working branch C<blead> which has
not been pushed to the C<origin> remote yet. B<NOTE>: This output
is also what you see as a template if you do not provide a message to
C<git commit>.

=head2 Patch workflow

First, please read L<perlhack> for details on hacking the Perl core.
That document covers many details on how to create a good patch.

If you already have a Perl repository, you should ensure that you're on
the I<blead> branch, and your repository is up to date:

  % git checkout blead
  % git pull

It's preferable to patch against the latest blead version, since this
is where new development occurs for all changes other than critical bug
fixes. Critical bug fix patches should be made against the relevant
maint branches, or should be submitted with a note indicating all the
branches where the fix should be applied.

Now that we have everything up to date, we need to create a temporary
new branch for these changes and switch into it:

  % git checkout -b orange

which is the short form of

  % git branch orange
  % git checkout orange

Creating a topic branch makes it easier for the maintainers to rebase
or merge back into the master blead for a more linear history. If you
don't work on a topic branch the maintainer has to manually cherry pick
your changes onto blead before they can be applied.

That'll get you scolded on perl5-porters, so don't do that. Be Awesome.

Then make your changes. For example, if Leon Brocard changes his name
to Orange Brocard, we should change his name in the AUTHORS file:

  % perl -pi -e 's{Leon Brocard}{Orange Brocard}' AUTHORS

You can see what files are changed:

  % git status
  On branch orange
  Changes to be committed:
    (use "git reset HEAD <file>..." to unstage)

     modified:   AUTHORS

And you can see the changes:

 % git diff
 diff --git a/AUTHORS b/AUTHORS
 index 293dd70..722c93e 100644
 --- a/AUTHORS
 +++ b/AUTHORS
 @@ -541,7 +541,7 @@    Lars Hecking              <lhecking@nmrc.ucc.ie>
  Laszlo Molnar                  <laszlo.molnar@eth.ericsson.se>
  Leif Huhn                      <leif@hale.dkstat.com>
  Len Johnson                    <lenjay@ibm.net>
 -Leon Brocard                   <acme@astray.com>
 +Orange Brocard                 <acme@astray.com>
  Les Peters                     <lpeters@aol.net>
  Lesley Binks                   <lesley.binks@gmail.com>
  Lincoln D. Stein               <lstein@cshl.org>

Now commit your change locally:

 % git commit -a -m 'Rename Leon Brocard to Orange Brocard'
 Created commit 6196c1d: Rename Leon Brocard to Orange Brocard
  1 files changed, 1 insertions(+), 1 deletions(-)

The C<-a> option is used to include all files that git tracks that you
have changed. If at this time, you only want to commit some of the
files you have worked on, you can omit the C<-a> and use the command
C<S<git add I<FILE ...>>> before doing the commit. C<S<git add
--interactive>> allows you to even just commit portions of files
instead of all the changes in them.

The C<-m> option is used to specify the commit message. If you omit it,
git will open a text editor for you to compose the message
interactively. This is useful when the changes are more complex than
the sample given here, and, depending on the editor, to know that the
first line of the commit message doesn't exceed the 50 character legal
maximum. See L<perlhack/Commit message> for more information about what
makes a good commit message.

Once you've finished writing your commit message and exited your
editor, git will write your change to disk and tell you something like
this:

 Created commit daf8e63: explain git status and stuff about remotes
  1 files changed, 83 insertions(+), 3 deletions(-)

If you re-run C<git status>, you should see something like this:

 % git status
 On branch orange
 Untracked files:
   (use "git add <file>..." to include in what will be committed)

       deliberate.untracked

 nothing added to commit but untracked files present (use "git add" to
                                                                  track)

When in doubt, before you do anything else, check your status and read
it carefully, many questions are answered directly by the git status
output.

You can examine your last commit with:

  % git show HEAD

and if you are not happy with either the description or the patch
itself you can fix it up by editing the files once more and then issue:

  % git commit -a --amend

Now, create a fork on GitHub to push your branch to, and add it as a
remote if you haven't already, as described in the GitHub documentation
at L<https://help.github.com/en/articles/working-with-forks>:

  % git remote add fork git@github.com:MyUser/perl5.git

And push the branch to your fork:

  % git push -u fork orange

You should now submit a Pull Request (PR) on GitHub from the new branch
to blead. For more information, see the GitHub documentation at
L<https://help.github.com/en/articles/creating-a-pull-request-from-a-fork>.

You can also send patch files to
L<perl5-porters@perl.org|mailto:perl5-porters@perl.org> directly if the
patch is not ready to be applied, but intended for discussion.

To create a patch file for all your local changes:

  % git format-patch -M blead..
  0001-Rename-Leon-Brocard-to-Orange-Brocard.patch

Or for a lot of changes, e.g. from a topic branch:

  % git format-patch --stdout -M blead.. > topic-branch-changes.patch

If you want to delete your temporary branch, you may do so with:

 % git checkout blead
 % git branch -d orange
 error: The branch 'orange' is not an ancestor of your current HEAD.
 If you are sure you want to delete it, run 'git branch -D orange'.
 % git branch -D orange
 Deleted branch orange.

=head2 A note on derived files

Be aware that many files in the distribution are derivative--avoid
patching them, because git won't see the changes to them, and the build
process will overwrite them. Patch the originals instead. Most
utilities (like perldoc) are in this category, i.e. patch
F<utils/perldoc.PL> rather than F<utils/perldoc>. Similarly, don't
create patches for files under F<$src_root/ext> from their copies found
in F<$install_root/lib>. If you are unsure about the proper location of
a file that may have gotten copied while building the source
distribution, consult the F<MANIFEST>.

=head2 Cleaning a working directory

The command C<git clean> can with varying arguments be used as a
replacement for C<make clean>.

To reset your working directory to a pristine condition you can do:

  % git clean -dxf

However, be aware this will delete ALL untracked content. You can use

  % git clean -Xf

to remove all ignored untracked files, such as build and test
byproduct, but leave any manually created files alone.

If you only want to cancel some uncommitted edits, you can use C<git
checkout> and give it a list of files to be reverted, or C<git checkout
-f> to revert them all.

If you want to cancel one or several commits, you can use C<git reset>.

=head2 Bisecting

C<git> provides a built-in way to determine which commit should be blamed
for introducing a given bug. C<git bisect> performs a binary search of
history to locate the first failing commit. It is fast, powerful and
flexible, but requires some setup and to automate the process an auxiliary
shell script is needed.

The core provides a wrapper program, F<Porting/bisect.pl>, which attempts to
simplify as much as possible, making bisecting as simple as running a Perl
one-liner. For example, if you want to know when this became an error:

    perl -e 'my $x := 2'

you simply run this:

    .../Porting/bisect.pl -e 'my $x := 2;'

Using F<Porting/bisect.pl>, with one command (and no other files) it's easy to
find out

=over 4

=item *

Which commit caused this example code to break?

=item *

Which commit caused this example code to start working?

=item *

Which commit added the first file to match this regex?

=item *

Which commit removed the last file to match this regex?

=back

usually without needing to know which versions of perl to use as start and
end revisions, as F<Porting/bisect.pl> automatically searches to find the
earliest stable version for which the test case passes. Run
C<Porting/bisect.pl --help> for the full documentation, including how to
set the C<Configure> and build time options.

If you require more flexibility than F<Porting/bisect.pl> has to offer, you'll
need to run C<git bisect> yourself. It's most useful to use C<git bisect run>
to automate the building and testing of perl revisions. For this you'll need
a shell script for C<git> to call to test a particular revision. An example
script is F<Porting/bisect-example.sh>, which you should copy B<outside> of
the repository, as the bisect process will reset the state to a clean checkout
as it runs. The instructions below assume that you copied it as F<~/run> and
then edited it as appropriate.

You first enter in bisect mode with:

  % git bisect start

For example, if the bug is present on C<HEAD> but wasn't in 5.10.0,
C<git> will learn about this when you enter:

  % git bisect bad
  % git bisect good perl-5.10.0
  Bisecting: 853 revisions left to test after this

This results in checking out the median commit between C<HEAD> and
C<perl-5.10.0>. You can then run the bisecting process with:

  % git bisect run ~/run

When the first bad commit is isolated, C<git bisect> will tell you so:

  ca4cfd28534303b82a216cfe83a1c80cbc3b9dc5 is first bad commit
  commit ca4cfd28534303b82a216cfe83a1c80cbc3b9dc5
  Author: Dave Mitchell <davem@fdisolutions.com>
  Date:   Sat Feb 9 14:56:23 2008 +0000

      [perl #49472] Attributes + Unknown Error
      ...

  bisect run success

You can peek into the bisecting process with C<git bisect log> and
C<git bisect visualize>. C<git bisect reset> will get you out of bisect
mode.

Please note that the first C<good> state must be an ancestor of the
first C<bad> state. If you want to search for the commit that I<solved>
some bug, you have to negate your test case (i.e. exit with C<1> if OK
and C<0> if not) and still mark the lower bound as C<good> and the
upper as C<bad>. The "first bad commit" has then to be understood as
the "first commit where the bug is solved".

C<git help bisect> has much more information on how you can tweak your
binary searches.

Following bisection you may wish to configure, build and test perl at
commits identified by the bisection process.  Sometimes, particularly
with older perls, C<make> may fail during this process.  In this case
you may be able to patch the source code at the older commit point.  To
do so, please follow the suggestions provided in
L<perlhack/Building perl at older commits>.

=head2 Topic branches and rewriting history

Individual committers should create topic branches under
B<yourname>/B<some_descriptive_name>:

  % branch="$yourname/$some_descriptive_name"
  % git checkout -b $branch
  ... do local edits, commits etc ...
  % git push origin -u $branch

Should you be stuck with an ancient version of git (prior to 1.7), then
C<git push> will not have the C<-u> switch, and you have to replace the
last step with the following sequence:

  % git push origin $branch:refs/heads/$branch
  % git config branch.$branch.remote origin
  % git config branch.$branch.merge refs/heads/$branch

If you want to make changes to someone else's topic branch, you should
check with its creator before making any change to it.

You
might sometimes find that the original author has edited the branch's
history. There are lots of good reasons for this. Sometimes, an author
might simply be rebasing the branch onto a newer source point.
Sometimes, an author might have found an error in an early commit which
they wanted to fix before merging the branch to blead.

Currently the master repository is configured to forbid
non-fast-forward merges. This means that the branches within can not be
rebased and pushed as a single step.

The only way you will ever be allowed to rebase or modify the history
of a pushed branch is to delete it and push it as a new branch under
the same name. Please think carefully about doing this. It may be
better to sequentially rename your branches so that it is easier for
others working with you to cherry-pick their local changes onto the new
version. (XXX: needs explanation).

If you want to rebase a personal topic branch, you will have to delete
your existing topic branch and push as a new version of it. You can do
this via the following formula (see the explanation about C<refspec>'s
in the git push documentation for details) after you have rebased your
branch:

  # first rebase
  % git checkout $user/$topic
  % git fetch
  % git rebase origin/blead

  # then "delete-and-push"
  % git push origin :$user/$topic
  % git push origin $user/$topic

B<NOTE:> it is forbidden at the repository level to delete any of the
"primary" branches. That is any branch matching
C<m!^(blead|maint|perl)!>. Any attempt to do so will result in git
producing an error like this:

  % git push origin :blead
  *** It is forbidden to delete blead/maint branches in this repository
  error: hooks/update exited with error code 1
  error: hook declined to update refs/heads/blead
  To ssh://perl5.git.perl.org/perl
   ! [remote rejected] blead (hook declined)
   error: failed to push some refs to 'ssh://perl5.git.perl.org/perl'

As a matter of policy we do B<not> edit the history of the blead and
maint-* branches. If a typo (or worse) sneaks into a commit to blead or
maint-*, we'll fix it in another commit. The only types of updates
allowed on these branches are "fast-forwards", where all history is
preserved.

Annotated tags in the canonical perl.git repository will never be
deleted or modified. Think long and hard about whether you want to push
a local tag to perl.git before doing so. (Pushing simple tags is
not allowed.)

=head2 Grafts

The perl history contains one mistake which was not caught in the
conversion: a merge was recorded in the history between blead and
maint-5.10 where no merge actually occurred. Due to the nature of git,
this is now impossible to fix in the public repository. You can remove
this mis-merge locally by adding the following line to your
C<.git/info/grafts> file:

 296f12bbbbaa06de9be9d09d3dcf8f4528898a49 434946e0cb7a32589ed92d18008aaa1d88515930

It is particularly important to have this graft line if any bisecting
is done in the area of the "merge" in question.

=head1 WRITE ACCESS TO THE GIT REPOSITORY

Once you have write access, you will need to modify the URL for the
origin remote to enable pushing. Edit F<.git/config> with the
git-config(1) command:

  % git config remote.origin.url git@github.com:Perl/perl5.git
