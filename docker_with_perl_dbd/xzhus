	|b:match_words|.  Similar to |[{|.

							*]%* *v_]%* *o_]%*
]%	Go to [count] next unmatched group, as specified by
	|b:match_words|.  Similar to |]}|.

							*v_a%*
a%	In Visual mode, select the matching group, as specified by
	|b:match_words|, containing the cursor.  Similar to |v_a[|.
	A [count] is ignored, and only the first character of the closing
	pattern is selected.

In Vim, as in plain vi, the percent key, |%|, jumps the cursor from a brace,
bracket, or paren to its match.  This can be configured with the 'matchpairs'
option.  The matchit plugin extends this in several ways:

	    You can match whole words, such as "if" and "endif", not just
	single characters.  You can also specify a |regular-expression|.
	    You can define groups with more than two words, such as "if",
	"else", "endif".  Banging on the "%" key will cycle from the "if" to
	the first "else", the next "else", ..., the closing "endif", and back
	to the opening "if".  Nested structures are skipped.  Using |g%| goes
	in the reverse direction.
	    By default, words inside comments and strings are ignored, unless
	the cursor is inside a comment or string when you type "%".  If the
	only thing you want to do is modify the behavior of "%" so that it
	behaves this way, you do not have to define |b:match_words|, since the
	script uses the 'matchpairs' option as well as this variable.

See |matchit-details| for details on what the script does, and |b:match_words|
for how to specify matching patterns.

MODES:			*matchit-modes* *matchit-v_%* *matchit-o_%*

Mostly, % and related motions (|g%| and |[%| and |]%|) should just work like built-in
|motion| commands in |Operator-pending| and |Visual| modes (as of 8.1.648)

LANGUAGES:					*matchit-languages*

Currently, the following languages are supported:  Ada, ASP with VBS, Csh,
DTD, Entity, Essbase, Fortran, HTML, JSP (same as HTML), LaTeX, Lua, Pascal,
SGML, Shell, Tcsh, Vim, XML.  Other languages may already have support via
the default |filetype-plugin|s in the standard vim distribution.

To support a new language, see |matchit-newlang| below.

DETAILS:				*matchit-details* *matchit-parse*

Here is an outline of what matchit.vim does each time you hit the "%" key.  If
there are |backref|s in |b:match_words| then the first step is to produce a
version in which these back references have been eliminated; if there are no
|backref|s then this step is skipped.  This step is called parsing.  For
example, "\(foo\|bar\):end\1" is parsed to yield
"\(foo\|bar\):end\(foo\|bar\)".  This can get tricky, especially if there are
nested groups.  If debugging is turned on, the parsed version is saved as
|b:match_pat|.

							*matchit-choose*
Next, the script looks for a word on the current line that matches the pattern
just constructed.  It includes the patterns from the 'matchpairs' option.
The goal is to do what you expect, which turns out to be a little complicated.
The script follows these rules:

	Insist on a match that ends on or after the cursor.
	Prefer a match that includes the cursor position (that is, one that
		starts on or before the cursor).
	Prefer a match that starts as close to the cursor as possible.
	If more than one pattern in |b:match_words| matches, choose the one
		that is listed first.

Examples:

	Suppose you >
		:let b:match_words = '<:>,<tag>:</tag>'
<	and hit "%" with the cursor on or before the "<" in "a <tag> is born".
	The pattern '<' comes first, so it is preferred over '<tag>', which
	also matches.  If the cursor is on the "t", however, then '<tag>' is
	preferred, because this matches a bit of text containing the cursor.
	If the two groups of patterns were reversed then '<' would never be
	preferred.

	Suppose you >
		:let b:match_words = 'if:end if'
<	(Note the space!) and hit "%" with the cursor at the end of "end if".
	Then "if" matches, which is probably not what you want, but if the
	cursor starts on the "end " then "end if" is chosen.  (You can avoid
	this problem by using a more complicated pattern.)

If there is no match, the cursor does not move.  (Before version 1.13 of the
script, it would fall back on the usual behavior of |%|).  If debugging is
turned on, the matched bit of text is saved as |b:match_match| and the cursor
column of the start of the match is saved as |b:match_col|.

Next, the script looks through |b:match_words| (original and parsed versions)
for the group and pattern that match.  If debugging is turned on, the group is
saved as |b:match_ini| (the first pattern) and |b:match_tail| (the rest).  If
there are |backref|s then, in addition, the matching pattern is saved as
|b:match_word| and a table of translations is saved as |b:match_table|.  If
there are |backref|s, these are determined from the matching pattern and
|b:match_match| and substituted into each pattern in the matching group.

The script decides whether to search forwards or backwards and chooses
arguments for the |searchpair()| function.  Then, the cursor is moved to the
start of the match, and |searchpair()| is called.  By default, matching
structures inside strings and comments are ignored.  This can be changed by
setting |b:match_skip|.

==============================================================================
2. Activation						*matchit-activate*

To use the matchit plugin add this line to your |vimrc|: >
	packadd! matchit

The script should start working the next time you start Vim.

To use the matching plugin after startup, you can use this command (note the
omitted '!'): >
	packadd matchit

To use the matchit plugin after Vim has started, execute this command: >
       packadd matchit

(Earlier versions of the script did nothing unless a |buffer-variable| named
|b:match_words| was defined.  Even earlier versions contained autocommands
that set this variable for various file types.  Now, |b:match_words| is
defined in many of the default |filetype-plugin|s instead.)

For a new language, you can add autocommands to the script or to your vimrc
file, but the recommended method is to add a line such as >
	let b:match_words = '\<foo\>:\<bar\>'
to the |filetype-plugin| for your language.  See |b:match_words| below for how
this variable is interpreted.

TROUBLESHOOTING					*matchit-troubleshoot*

The script should work in most installations of Vim.  It may not work if Vim
was compiled with a minimal feature set, for example if the |+syntax| option
was not enabled.  If your Vim has support for syntax compiled in, but you do
not have |syntax| highlighting turned on, matchit.vim should work, but it may
fail to skip matching groups in comments and strings.  If the |filetype|
mechanism is turned off, the |b:match_words| variable will probably not be
defined automatically.

==============================================================================
3. Configuration					*matchit-configure*

There are several variables that govern the behavior of matchit.vim.  Note
that these are variables local to the buffer, not options, so use |:let| to
define them, not |:set|.  Some of these variables have values that matter; for
others, it only matters whether the variable has been defined.  All of these
can be defined in the |filetype-plugin| or autocommand that defines
|b:match_words| or "on the fly."

The main variable is |b:match_words|.  It is described in the section below on
supporting a new language.

				*MatchError* *matchit-hl* *matchit-highlight*
MatchError is the highlight group for error messages from the script.  By
default, it is linked to WarningMsg.  If you do not want to be bothered by
error messages, you can define this to be something invisible.  For example,
if you use the GUI version of Vim and your command line is normally white, you
can do >
	:hi MatchError guifg=white guibg=white
<
						*b:match_ignorecase*
If you >
	:let b:match_ignorecase = 1
then matchit.vim acts as if 'ignorecase' is set: for example, "end" and "END"
are equivalent.  If you >
	:let b:match_ignorecase = 0
then matchit.vim treats "end" and "END" differently.  (There will be no
b:match_infercase option unless someone requests it.)

						*b:match_debug*
Define b:match_debug if you want debugging information to be saved.  See
|matchit-debug|, below.

						*b:match_skip*
If b:match_skip is defined, it is passed as the skip argument to
|searchpair()|.  This controls when matching structures are skipped, or
ignored.  By default, they are ignored inside comments and strings, as
determined by the |syntax| mechanism.  (If syntax highlighting is turned off,
nothing is skipped.)  You can set b:match_skip to a string, which evaluates to
a non-zero, numerical value if the match is to be skipped or zero if the match
should not be skipped.  In addition, the following special values are
supported by matchit.vim:
	s:foo becomes (current syntax item) =~ foo
	S:foo becomes (current syntax item) !~ foo
	r:foo becomes (line before cursor) =~ foo
	R:foo becomes (line before cursor) !~ foo
(The "s" is meant to suggest "syntax", and the "r" is meant to suggest
"regular expression".)

Examples:

	You can get the default behavior with >
		:let b:match_skip = 's:comment\|string'
<
	If you want to skip matching structures unless they are at the start
	of the line (ignoring whitespace) then you can >
		:let b:match_skip = 'R:^\s*'
<	Do not do this if strings or comments can span several lines, since
	the normal syntax checking will not be done if you set b:match_skip.

	In LaTeX, since "%" is used as the comment character, you can >
		:let b:match_skip = 'r:%'
<	Unfortunately, this will skip anything after "\%", an escaped "%".  To
	allow for this, and also "\\%" (an escaped backslash followed by the
	comment character) you can >
		:let b:match_skip = 'r:\(^\|[^\\]\)\(\\\\\)*%'
<
==============================================================================
4. Supporting a New Language				*matchit-newlang*
							*b:match_words*
In order for matchit.vim to support a new language, you must define a suitable
pattern for |b:match_words|.  You may also want to set some of the
|matchit-configure| variables, as described above.  If your language has a
complicated syntax, or many keywords, you will need to know something about
Vim's |regular-expression|s.

The format for |b:match_words| is similar to that of the 'matchpairs' option:
it is a comma (,)-separated list of groups; each group is a colon(:)-separated
list of patterns (regular expressions).  Commas and backslashes that are part
of a pattern should be escaped with backslashes ('\:' and '\,').  It is OK to
have only one group; the effect is undefined if a group has only one pattern.
A simple example is >
	:let b:match_words = '\<if\>:\<endif\>,'
		\ . '\<while\>:\<continue\>:\<break\>:\<endwhile\>'
(In Vim regular expressions, |\<| and |\>| denote word boundaries.  Thus "if"
matches the end of "endif" but "\<if\>" does not.)  Then banging on the "%"
key will bounce the cursor between "if" and the matching "endif"; and from
"while" to any matching "continue" or "break", then to the matching "endwhile"
and back to the "while".  It is almost always easier to use |literal-string|s
(single quotes) as above:  '\<if\>' rather than "\\<if\\>" and so on.

Exception:  If the ":" character does not appear in b:match_words, then it is
treated as an expression to be evaluated.  For example, >
	:let b:match_words = 'GetMatchWords()'
allows you to define a function.  This can return a different string depending
on the current syntax, for example.

Once you have defined the appropriate value of |b:match_words|, you will
probably want to have this set automatically each time you edit the
appropriate file type.  The recommended way to do this is by adding the
definition to a |filetype-plugin| file.

Tips: Be careful that your initial pattern does not match your final pattern.
See the example above for the use of word-boundary expressions.  It is usually
better to use ".\{-}" (as many as necessary) instead of ".*" (as many as
possible).  See |\{-|.  For example, in the string "<tag>label</tag>", "<.*>"
matches the whole string whereas "<.\{-}>" and "<[^>]*>" match "<tag>" and
"</tag>".

				*matchit-spaces* *matchit-s:notend*
If "if" is to be paired with "end if" (Note the space!) then word boundaries
are not enough.  Instead, define a regular expression s:notend that will match
anything but "end" and use it as follows: >
	:let s:notend = '\%(\<end\s\+\)\@<!'
	:let b:match_words = s:notend . '\<if\>:\<end\s\+if\>'
<							*matchit-s:sol*
This is a simplified version of what is done for Ada.  The s:notend is a
|script-variable|.  Similarly, you may want to define a start-of-line regular
expression >
	:let s:sol = '\%(^\|;\)\s*'
if keywords are only recognized after the start of a line or after a
semicolon (;), with optional white space.

					*matchit-backref* *matchit-\1*
In any group, the expressions |\1|, |\2|, ..., |\9| refer to parts of the
INITIAL pattern enclosed in |\(|escaped parentheses|\)|.  These are referred
to as back references, or backrefs.  For example, >
	:let b:match_words = '\<b\(o\+\)\>:\(h\)\1\>'
means that "bo" pairs with "ho" and "boo" pairs with "hoo" and so on.  Note
that "\1" does not refer to the "\(h\)" in this example.  If you have
"\(nested \(parentheses\)\) then "\d" refers to the d-th "\(" and everything
up to and including the matching "\)":  in "\(nested\(parentheses\)\)", "\1"
refers to everything and "\2" refers to "\(parentheses\)".  If you use a
variable such as |s:notend| or |s:sol| in the previous paragraph then remember
to count any "\(" patterns in this variable.  You do not have to count groups
defined by |\%(\)|.

It should be possible to resolve back references from any pattern in the
group.  For example, >
	:let b:match_words = '\(foo\)\(bar\):more\1:and\2:end\1\2'
would not work because "\2" cannot be determined from "morefoo" and "\1"
cannot be determined from "andbar".  On the other hand, >
	:let b:match_words = '\(\(foo\)\(bar\)\):\3\2:end\1'
should work (and have the same effect as "foobar:barfoo:endfoobar"), although
this has not been thoroughly tested.

You can use |zero-width| patterns such as |\@<=| and |\zs|.  (The latter has
not been thoroughly tested in matchit.vim.)  For example, if the keyword "if"
must occur at the start of the line, with optional white space, you might use
the pattern "\(^\s*\)\@<=if" so that the cursor will end on the "i" instead of
at the start of the line.  For another example, if HTML had only one tag then
one could >
	:let b:match_words = '<:>,<\@<=tag>:<\@<=/tag>'
so that "%" can bounce between matching "<" and ">" pairs or (starting on
"tag" or "/tag") between matching tags.  Without the |\@<=|, the script would
bounce from "tag" to the "<" in "</tag>", and another "%" would not take you
back to where you started.

DEBUGGING				*matchit-debug* *:MatchDebug*

If you are having trouble figuring out the appropriate definition of
|b:match_words| then you can take advantage of the same information I use when
debugging the script.  This is especially true if you are not sure whether
your patterns or my script are at fault!  To make this more convenient, I have
made the command :MatchDebug, which defines the variable |b:match_debug| and
creates a Matchit menu.  This menu makes it convenient to check the values of
the variables described below.  You will probably also want to read
|matchit-details| above.

Defining the variable |b:match_debug| causes the script to set the following
variables, each time you hit the "%" key.  Several of these are only defined
if |b:match_words| includes |backref|s.

							*b:match_pat*
The b:match_pat variable is set to |b:match_words| with |backref|s parsed.
							*b:match_match*
The b:match_match variable is set to the bit of text that is recognized as a
match.
							*b:match_col*
The b:match_col variable is set to the cursor column of the start of the
matching text.
							*b:match_wholeBR*
The b:match_wholeBR variable is set to the comma-separated group of patterns
that matches, with |backref|s unparsed.
							*b:match_iniBR*
The b:match_iniBR variable is set to the first pattern in |b:match_wholeBR|.
							*b:match_ini*
The b:match_ini variable is set to the first pattern in |b:match_wholeBR|,
with |backref|s resolved from |b:match_match|.
							*b:match_tail*
The b:match_tail variable is set to the remaining patterns in
|b:match_wholeBR|, with |backref|s resolved from |b:match_match|.
							*b:match_word*
The b:match_word variable is set to the pattern from |b:match_wholeBR| that
matches |b:match_match|.
							*b:match_table*
The back reference '\'.d refers to the same thing as '\'.b:match_table[d] in
|b:match_word|.

==============================================================================
5. Known Bugs and Limitations				*matchit-bugs*

Repository: https://github.com/chrisbra/matchit/
Bugs can be reported at the repository and the latest development snapshot can
also be downloaded there.

Just because I know about a bug does not mean that it is on my todo list.  I
try to respond to reports of bugs that cause real problems.  If it does not
cause serious problems, or if there is a work-around, a bug may sit there for
a while.  Moral:  if a bug (known or not) bothers you, let me know.

It would be nice if "\0" were recognized as the entire pattern.  That is, it
would be nice if "foo:\end\0" had the same effect as "\(foo\):\end\1".  I may
try to implement this in a future version.  (This is not so easy to arrange as
you might think!)

==============================================================================
vim:tw=78:ts=8:fo=tcq2:ft=help:
                                                                                                                                                                                                                                          usr/share/vim/vim90/pack/dist/opt/matchit/doc/tags                                                  0000644 0000000 0000000 00000003651 14424703754 020477  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        :MatchDebug	matchit.txt	/*:MatchDebug*
MatchError	matchit.txt	/*MatchError*
[%	matchit.txt	/*[%*
]%	matchit.txt	/*]%*
b:match_col	matchit.txt	/*b:match_col*
b:match_debug	matchit.txt	/*b:match_debug*
b:match_ignorecase	matchit.txt	/*b:match_ignorecase*
b:match_ini	matchit.txt	/*b:match_ini*
b:match_iniBR	matchit.txt	/*b:match_iniBR*
b:match_match	matchit.txt	/*b:match_match*
b:match_pat	matchit.txt	/*b:match_pat*
b:match_skip	matchit.txt	/*b:match_skip*
b:match_table	matchit.txt	/*b:match_table*
b:match_tail	matchit.txt	/*b:match_tail*
b:match_wholeBR	matchit.txt	/*b:match_wholeBR*
b:match_word	matchit.txt	/*b:match_word*
b:match_words	matchit.txt	/*b:match_words*
g%	matchit.txt	/*g%*
matchit	matchit.txt	/*matchit*
matchit-%	matchit.txt	/*matchit-%*
matchit-\1	matchit.txt	/*matchit-\\1*
matchit-activate	matchit.txt	/*matchit-activate*
matchit-backref	matchit.txt	/*matchit-backref*
matchit-bugs	matchit.txt	/*matchit-bugs*
matchit-choose	matchit.txt	/*matchit-choose*
matchit-configure	matchit.txt	/*matchit-configure*
matchit-debug	matchit.txt	/*matchit-debug*
matchit-details	matchit.txt	/*matchit-details*
matchit-highlight	matchit.txt	/*matchit-highlight*
matchit-hl	matchit.txt	/*matchit-hl*
matchit-intro	matchit.txt	/*matchit-intro*
matchit-languages	matchit.txt	/*matchit-languages*
matchit-modes	matchit.txt	/*matchit-modes*
matchit-newlang	matchit.txt	/*matchit-newlang*
matchit-o_%	matchit.txt	/*matchit-o_%*
matchit-parse	matchit.txt	/*matchit-parse*
matchit-s:notend	matchit.txt	/*matchit-s:notend*
matchit-s:sol	matchit.txt	/*matchit-s:sol*
matchit-spaces	matchit.txt	/*matchit-spaces*
matchit-troubleshoot	matchit.txt	/*matchit-troubleshoot*
matchit-v_%	matchit.txt	/*matchit-v_%*
matchit.txt	matchit.txt	/*matchit.txt*
matchit.vim	matchit.txt	/*matchit.vim*
o_[%	matchit.txt	/*o_[%*
o_]%	matchit.txt	/*o_]%*
o_g%	matchit.txt	/*o_g%*
v_[%	matchit.txt	/*v_[%*
v_]%	matchit.txt	/*v_]%*
v_a%	matchit.txt	/*v_a%*
v_g%	matchit.txt	/*v_g%*
                                                                                       usr/share/vim/vim90/pack/dist/opt/matchit/plugin/                                                   0000755 0000000 0000000 00000000000 14723046434 020337  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/vim/vim90/pack/dist/opt/matchit/plugin/matchit.vim                                        0000644 0000000 0000000 00000010735 14424703754 022516  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        "  matchit.vim: (global plugin) Extended "%" matching
"  Maintainer:  Christian Brabandt
"  Version:     1.18
"  Last Change: 2020 Dec 23
"  Repository:  https://github.com/chrisbra/matchit
"  Previous URL:http://www.vim.org/script.php?script_id=39
"  Previous Maintainer:  Benji Fisher PhD   <benji@member.AMS.org>

" Documentation:
"  The documentation is in a separate file: ../doc/matchit.txt

" Credits:
"  Vim editor by Bram Moolenaar (Thanks, Bram!)
"  Original script and design by Raul Segura Acevedo
"  Support for comments by Douglas Potts
"  Support for back references and other improvements by Benji Fisher
"  Support for many languages by Johannes Zellner
"  Suggestions for improvement, bug reports, and support for additional
"  languages by Jordi-Albert Batalla, Neil Bird, Servatius Brandt, Mark
"  Collett, Stephen Wall, Dany St-Amant, Yuheng Xie, and Johannes Zellner.

" Debugging:
"  If you'd like to try the built-in debugging commands...
"   :MatchDebug      to activate debugging for the current buffer
"  This saves the values of several key script variables as buffer-local
"  variables.  See the MatchDebug() function, below, for details.

" TODO:  I should think about multi-line patterns for b:match_words.
"   This would require an option:  how many lines to scan (default 1).
"   This would be useful for Python, maybe also for *ML.
" TODO:  Maybe I should add a menu so that people will actually use some of
"   the features that I have implemented.
" TODO:  Eliminate the MultiMatch function.  Add yet another argument to
"   Match_wrapper() instead.
" TODO:  Allow :let b:match_words = '\(\(foo\)\(bar\)\):\3\2:end\1'
" TODO:  Make backrefs safer by using '\V' (very no-magic).
" TODO:  Add a level of indirection, so that custom % scripts can use my
"   work but extend it.

" Allow user to prevent loading and prevent duplicate loading.
if exists("g:loaded_matchit") || &cp
  finish
endif
let g:loaded_matchit = 1

let s:save_cpo = &cpo
set cpo&vim

nnoremap <silent> <Plug>(MatchitNormalForward)     :<C-U>call matchit#Match_wrapper('',1,'n')<CR>
nnoremap <silent> <Plug>(MatchitNormalBackward)    :<C-U>call matchit#Match_wrapper('',0,'n')<CR>
xnoremap <silent> <Plug>(MatchitVisualForward)     :<C-U>call matchit#Match_wrapper('',1,'v')<CR>
      \:if col("''") != col("$") \| exe ":normal! m'" \| endif<cr>gv``
xnoremap <silent> <Plug>(MatchitVisualBackward)    :<C-U>call matchit#Match_wrapper('',0,'v')<CR>m'gv``
onoremap <silent> <Plug>(MatchitOperationForward)  :<C-U>call matchit#Match_wrapper('',1,'o')<CR>
onoremap <silent> <Plug>(MatchitOperationBackward) :<C-U>call matchit#Match_wrapper('',0,'o')<CR>

" Analogues of [{ and ]} using matching patterns:
nnoremap <silent> <Plug>(MatchitNormalMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>
nnoremap <silent> <Plug>(MatchitNormalMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>
xnoremap <silent> <Plug>(MatchitVisualMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>m'gv``
xnoremap <silent> <Plug>(MatchitVisualMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>m'gv``
onoremap <silent> <Plug>(MatchitOperationMultiBackward) :<C-U>call matchit#MultiMatch("bW", "o")<CR>
onoremap <silent> <Plug>(MatchitOperationMultiForward)  :<C-U>call matchit#MultiMatch("W",  "o")<CR>

" text object:
xmap <silent> <Plug>(MatchitVisualTextObject) <Plug>(MatchitVisualMultiBackward)o<Plug>(MatchitVisualMultiForward)

if !exists("g:no_plugin_maps")
  nmap <silent> %  <Plug>(MatchitNormalForward)
  nmap <silent> g% <Plug>(MatchitNormalBackward)
  xmap <silent> %  <Plug>(MatchitVisualForward)
  xmap <silent> g% <Plug>(MatchitVisualBackward)
  omap <silent> %  <Plug>(MatchitOperationForward)
  omap <silent> g% <Plug>(MatchitOperationBackward)

  " Analogues of [{ and ]} using matching patterns:
  nmap <silent> [% <Plug>(MatchitNormalMultiBackward)
  nmap <silent> ]% <Plug>(MatchitNormalMultiForward)
  xmap <silent> [% <Plug>(MatchitVisualMultiBackward)
  xmap <silent> ]% <Plug>(MatchitVisualMultiForward)
  omap <silent> [% <Plug>(MatchitOperationMultiBackward)
  omap <silent> ]% <Plug>(MatchitOperationMultiForward)

  " Text object
  xmap a% <Plug>(MatchitVisualTextObject)
endif

" Call this function to turn on debugging information.  Every time the main
" script is run, buffer variables will be saved.  These can be used directly
" or viewed using the menu items below.
if !exists(":MatchDebug")
  command! -nargs=0 MatchDebug call matchit#Match_debug()
endif

let &cpo = s:save_cpo
unlet s:save_cpo

" vim:sts=2:sw=2:et:
                                   usr/share/vim/vim90/pack/dist/opt/shellmenu/                                                        0000755 0000000 0000000 00000000000 14723046434 017404  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/vim/vim90/pack/dist/opt/shellmenu/plugin/                                                 0000755 0000000 0000000 00000000000 14723046434 020702  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/vim/vim90/pack/dist/opt/shellmenu/plugin/shellmenu.vim                                    0000644 0000000 0000000 00000012445 14424703754 023424  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " When you're writing shell scripts and you are in doubt which test to use,
" which shell environment variables are defined, what the syntax of the case
" statement is, and you need to invoke 'man sh'?
"
" Your problems are over now!
"
" Attached is a Vim script file for turning gvim into a shell script editor.
" It may also be used as an example how to use menus in Vim.
"
" Maintainer: Ada (Haowen) Yu <me@yuhaowen.com>
" Original author: Lennart Schultz <les@dmi.min.dk> (mail unreachable)

" Make sure the '<' and 'C' flags are not included in 'cpoptions', otherwise
" <CR> would not be recognized.  See ":help 'cpoptions'".
let s:cpo_save = &cpo
set cpo&vim

imenu ShellMenu.Statements.for	for  in <CR>do<CR><CR>done<esc>ki	<esc>kk0elli
imenu ShellMenu.Statements.case	case  in<CR>) ;;<CR>esac<esc>bki	<esc>k0elli
imenu ShellMenu.Statements.if	if   <CR>then<CR><CR>fi<esc>ki	<esc>kk0elli
imenu ShellMenu.Statements.if-else	if   <CR>then<CR><CR>else<CR><CR>fi<esc>ki	<esc>kki	<esc>kk0elli
imenu ShellMenu.Statements.elif	elif   <CR>then<CR><CR><esc>ki	<esc>kk0elli
imenu ShellMenu.Statements.while	while   do<CR><CR>done<esc>ki	<esc>kk0elli
imenu ShellMenu.Statements.break	break 
imenu ShellMenu.Statements.continue	continue 
imenu ShellMenu.Statements.function	() {<CR><CR>}<esc>ki	<esc>k0i
imenu ShellMenu.Statements.return	return 
imenu ShellMenu.Statements.return-true	return 0
imenu ShellMenu.Statements.return-false	return 1
imenu ShellMenu.Statements.exit	exit 
imenu ShellMenu.Statements.shift	shift 
imenu ShellMenu.Statements.trap	trap 
imenu ShellMenu.Test.Existence	[ -e  ]<esc>hi
imenu ShellMenu.Test.Existence\ -\ file		[ -f  ]<esc>hi
imenu ShellMenu.Test.Existence\ -\ file\ (not\ empty)	[ -s  ]<esc>hi
imenu ShellMenu.Test.Existence\ -\ directory	[ -d  ]<esc>hi
imenu ShellMenu.Test.Existence\ -\ executable	[ -x  ]<esc>hi
imenu ShellMenu.Test.Existence\ -\ readable	[ -r  ]<esc>hi
imenu ShellMenu.Test.Existence\ -\ writable	[ -w  ]<esc>hi
imenu ShellMenu.Test.String\ is\ empty [ x = "x$" ]<esc>hhi
imenu ShellMenu.Test.String\ is\ not\ empty [ x != "x$" ]<esc>hhi
imenu ShellMenu.Test.Strings\ are\ equal [ "" = "" ]<esc>hhhhhhhi
imenu ShellMenu.Test.Strings\ are\ not\ equal [ "" != "" ]<esc>hhhhhhhhi
imenu ShellMenu.Test.Value\ is\ greater\ than [  -gt  ]<esc>hhhhhhi
imenu ShellMenu.Test.Value\ is\ greater\ equal [  -ge  ]<esc>hhhhhhi
imenu ShellMenu.Test.Values\ are\ equal [  -eq  ]<esc>hhhhhhi
imenu ShellMenu.Test.Values\ are\ not\ equal [  -ne  ]<esc>hhhhhhi
imenu ShellMenu.Test.Value\ is\ less\ than [  -lt  ]<esc>hhhhhhi
imenu ShellMenu.Test.Value\ is\ less\ equal [  -le  ]<esc>hhhhhhi
imenu ShellMenu.ParmSub.Substitute\ word\ if\ parm\ not\ set ${:-}<esc>hhi
imenu ShellMenu.ParmSub.Set\ parm\ to\ word\ if\ not\ set ${:=}<esc>hhi
imenu ShellMenu.ParmSub.Substitute\ word\ if\ parm\ set\ else\ nothing ${:+}<esc>hhi
imenu ShellMenu.ParmSub.If\ parm\ not\ set\ print\ word\ and\ exit ${:?}<esc>hhi
imenu ShellMenu.SpShVars.Number\ of\ positional\ parameters ${#}
imenu ShellMenu.SpShVars.All\ positional\ parameters\ (quoted\ spaces) ${*}
imenu ShellMenu.SpShVars.All\ positional\ parameters\ (unquoted\ spaces) ${@}
imenu ShellMenu.SpShVars.Flags\ set ${-}
imenu ShellMenu.SpShVars.Return\ code\ of\ last\ command ${?}
imenu ShellMenu.SpShVars.Process\ number\ of\ this\ shell ${$}
imenu ShellMenu.SpShVars.Process\ number\ of\ last\ background\ command ${!}
imenu ShellMenu.Environ.HOME ${HOME}
imenu ShellMenu.Environ.PATH ${PATH}
imenu ShellMenu.Environ.CDPATH ${CDPATH}
imenu ShellMenu.Environ.MAIL ${MAIL}
imenu ShellMenu.Environ.MAILCHECK ${MAILCHECK}
imenu ShellMenu.Environ.PS1 ${PS1}
imenu ShellMenu.Environ.PS2 ${PS2}
imenu ShellMenu.Environ.IFS ${IFS}
imenu ShellMenu.Environ.SHACCT ${SHACCT}
imenu ShellMenu.Environ.SHELL ${SHELL}
imenu ShellMenu.Environ.LC_CTYPE ${LC_CTYPE}
imenu ShellMenu.Environ.LC_MESSAGES ${LC_MESSAGES}
imenu ShellMenu.Builtins.cd cd
imenu ShellMenu.Builtins.echo echo
imenu ShellMenu.Builtins.eval eval
imenu ShellMenu.Builtins.exec exec
imenu ShellMenu.Builtins.export export
imenu ShellMenu.Builtins.getopts getopts
imenu ShellMenu.Builtins.hash hash
imenu ShellMenu.Builtins.newgrp newgrp
imenu ShellMenu.Builtins.pwd pwd
imenu ShellMenu.Builtins.read read
imenu ShellMenu.Builtins.readonly readonly
imenu ShellMenu.Builtins.return return
imenu ShellMenu.Builtins.times times
imenu ShellMenu.Builtins.type type
imenu ShellMenu.Builtins.umask umask
imenu ShellMenu.Builtins.wait wait
imenu ShellMenu.Set.set set
imenu ShellMenu.Set.unset unset
imenu ShellMenu.Set.Mark\ created\ or\ modified\ variables\ for\ export set -a
imenu ShellMenu.Set.Exit\ when\ command\ returns\ non-zero\ status set -e
imenu ShellMenu.Set.Disable\ file\ name\ expansion set -f
imenu ShellMenu.Set.Locate\ and\ remember\ commands\ when\ being\ looked\ up set -h
imenu ShellMenu.Set.All\ assignment\ statements\ are\ placed\ in\ the\ environment\ for\ a\ command set -k
imenu ShellMenu.Set.Read\ commands\ but\ do\ not\ execute\ them set -n
imenu ShellMenu.Set.Exit\ after\ reading\ and\ executing\ one\ command set -t
imenu ShellMenu.Set.Treat\ unset\ variables\ as\ an\ error\ when\ substituting set -u
imenu ShellMenu.Set.Print\ shell\ input\ lines\ as\ they\ are\ read set -v
imenu ShellMenu.Set.Print\ commands\ and\ their\ arguments\ as\ they\ are\ executed set -x

" Restore the previous value of 'cpoptions'.
let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                           usr/share/vim/vim90/pack/dist/opt/swapmouse/                                                        0000755 0000000 0000000 00000000000 14723046434 017433  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/vim/vim90/pack/dist/opt/swapmouse/plugin/                                                 0000755 0000000 0000000 00000000000 14723046434 020731  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/vim/vim90/pack/dist/opt/swapmouse/plugin/swapmouse.vim                                    0000644 0000000 0000000 00000001530 14424703754 023473  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " These macros swap the left and right mouse buttons (for left handed)
" Don't forget to do ":set mouse=a" or the mouse won't work at all
noremap	 <LeftMouse>	<RightMouse>
noremap	 <2-LeftMouse>	<2-RightMouse>
noremap	 <3-LeftMouse>	<3-RightMouse>
noremap	 <4-LeftMouse>	<4-RightMouse>
noremap	 <LeftDrag>	<RightDrag>
noremap	 <LeftRelease>	<RightRelease>
noremap	 <RightMouse>	<LeftMouse>
noremap	 <2-RightMouse>	<2-LeftMouse>
noremap	 <3-RightMouse>	<3-LeftMouse>
noremap	 <4-RightMouse>	<4-LeftMouse>
noremap	 <RightDrag>	<LeftDrag>
noremap	 <RightRelease>	<LeftRelease>
noremap	 g<LeftMouse>	<C-RightMouse>
noremap	 g<RightMouse>	<C-LeftMouse>
noremap! <LeftMouse>	<RightMouse>
noremap! <LeftDrag>	<RightDrag>
noremap! <LeftRelease>	<RightRelease>
noremap! <RightMouse>	<LeftMouse>
noremap! <RightDrag>	<LeftDrag>
noremap! <RightRelease>	<LeftRelease>
                                                                                                                                                                        usr/share/vim/vim90/pack/dist/opt/termdebug/                                                        0000755 0000000 0000000 00000000000 14723046434 017366  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/vim/vim90/pack/dist/opt/termdebug/plugin/                                                 0000755 0000000 0000000 00000000000 14723046434 020664  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/vim/vim90/pack/dist/opt/termdebug/plugin/termdebug.vim                                    0000644 0000000 0000000 00000130747 14424703754 023376  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Debugger plugin using gdb.
"
" Author: Bram Moolenaar
" Copyright: Vim license applies, see ":help license"
" Last Change: 2022 Nov 10
"
" WORK IN PROGRESS - The basics works stable, more to come
" Note: In general you need at least GDB 7.12 because this provides the
" frame= response in MI thread-selected events we need to sync stack to file.
" The one included with "old" MingW is too old (7.6.1), you may upgrade it or
" use a newer version from http://www.equation.com/servlet/equation.cmd?fa=gdb
"
" There are two ways to run gdb:
" - In a terminal window; used if possible, does not work on MS-Windows
"   Not used when g:termdebug_use_prompt is set to 1.
" - Using a "prompt" buffer; may use a terminal window for the program
"
" For both the current window is used to view source code and shows the
" current statement from gdb.
"
" USING A TERMINAL WINDOW
"
" Opens two visible terminal windows:
" 1. runs a pty for the debugged program, as with ":term NONE"
" 2. runs gdb, passing the pty of the debugged program
" A third terminal window is hidden, it is used for communication with gdb.
"
" USING A PROMPT BUFFER
"
" Opens a window with a prompt buffer to communicate with gdb.
" Gdb is run as a job with callbacks for I/O.
" On Unix another terminal window is opened to run the debugged program
" On MS-Windows a separate console is opened to run the debugged program
"
" The communication with gdb uses GDB/MI.  See:
" https://sourceware.org/gdb/current/onlinedocs/gdb/GDB_002fMI.html

" In case this gets sourced twice.
if exists(':Termdebug')
  finish
endif

" Need either the +terminal feature or +channel and the prompt buffer.
" The terminal feature does not work with gdb on win32.
if has('terminal') && !has('win32')
  let s:way = 'terminal'
elseif has('channel') && exists('*prompt_setprompt')
  let s:way = 'prompt'
else
  if has('terminal')
    let s:err = 'Cannot debug, missing prompt buffer support'
  else
    let s:err = 'Cannot debug, +channel feature is not supported'
  endif
  command -nargs=* -complete=file -bang Termdebug echoerr s:err
  command -nargs=+ -complete=file -bang TermdebugCommand echoerr s:err
  finish
endif

let s:keepcpo = &cpo
set cpo&vim

" The command that starts debugging, e.g. ":Termdebug vim".
" To end type "quit" in the gdb window.
command -nargs=* -complete=file -bang Termdebug call s:StartDebug(<bang>0, <f-args>)
command -nargs=+ -complete=file -bang TermdebugCommand call s:StartDebugCommand(<bang>0, <f-args>)

let s:pc_id = 12
let s:asm_id = 13
let s:break_id = 14  " breakpoint number is added to this
let s:stopped = 1

let s:parsing_disasm_msg = 0
let s:asm_lines = []
let s:asm_addr = ''

" Take a breakpoint number as used by GDB and turn it into an integer.
" The breakpoint may contain a dot: 123.4 -> 123004
" The main breakpoint has a zero subid.
func s:Breakpoint2SignNumber(id, subid)
  return s:break_id + a:id * 1000 + a:subid
endfunction

func s:Highlight(init, old, new)
  let default = a:init ? 'default ' : ''
  if a:new ==# 'light' && a:old !=# 'light'
    exe "hi " . default . "debugPC term=reverse ctermbg=lightblue guibg=lightblue"
  elseif a:new ==# 'dark' && a:old !=# 'dark'
    exe "hi " . default . "debugPC term=reverse ctermbg=darkblue guibg=darkblue"
  endif
endfunc

call s:Highlight(1, '', &background)
hi default debugBreakpoint term=reverse ctermbg=red guibg=red
hi default debugBreakpointDisabled term=reverse ctermbg=gray guibg=gray

" Get the command to execute the debugger as a list, defaults to ["gdb"].
func s:GetCommand()
  if exists('g:termdebug_config')
    let cmd = get(g:termdebug_config, 'command', 'gdb')
  elseif exists('g:termdebugger')
    let cmd = g:termdebugger
  else
    let cmd = 'gdb'
  endif

  return type(cmd) == v:t_list ? copy(cmd) : [cmd]
endfunc

func s:StartDebug(bang, ...)
  " First argument is the command to debug, second core file or process ID.
  call s:StartDebug_internal({'gdb_args': a:000, 'bang': a:bang})
endfunc

func s:StartDebugCommand(bang, ...)
  " First argument is the command to debug, rest are run arguments.
  call s:StartDebug_internal({'gdb_args': [a:1], 'proc_args': a:000[1:], 'bang': a:bang})
endfunc

func s:StartDebug_internal(dict)
  if exists('s:gdbwin')
    echoerr 'Terminal debugger already running, cannot run two'
    return
  endif
  let gdbcmd = s:GetCommand()
  if !executable(gdbcmd[0])
    echoerr 'Cannot execute debugger program "' .. gdbcmd[0] .. '"'
    return
  endif

  let s:ptywin = 0
  let s:pid = 0
  let s:asmwin = 0

  if exists('#User#TermdebugStartPre')
    doauto <nomodeline> User TermdebugStartPre
  endif

  " Uncomment this line to write logging in "debuglog".
  " call ch_logfile('debuglog', 'w')

  let s:sourcewin = win_getid(winnr())

  " Remember the old value of 'signcolumn' for each buffer that it's set in, so
  " that we can restore the value for all buffers.
  let b:save_signcolumn = &signcolumn
  let s:signcolumn_buflist = [bufnr()]

  let s:save_columns = 0
  let s:allleft = 0
  let wide = 0
  if exists('g:termdebug_config')
    let wide = get(g:termdebug_config, 'wide', 0)
  elseif exists('g:termdebug_wide')
    let wide = g:termdebug_wide
  endif
  if wide > 0
    if &columns < wide
      let s:save_columns = &columns
      let &columns = wide
      " If we make the Vim window wider, use the whole left half for the debug
      " windows.
      let s:allleft = 1
    endif
    let s:vertical = 1
  else
    let s:vertical = 0
  endif

  " Override using a terminal window by setting g:termdebug_use_prompt to 1.
  let use_prompt = 0
  if exists('g:termdebug_config')
    let use_prompt = get(g:termdebug_config, 'use_prompt', 0)
  elseif exists('g:termdebug_use_prompt')
    let use_prompt = g:termdebug_use_prompt
  endif
  if has('terminal') && !has('win32') && !use_prompt
    let s:way = 'terminal'
  else
    let s:way = 'prompt'
  endif

  if s:way == 'prompt'
    call s:StartDebug_prompt(a:dict)
  else
    call s:StartDebug_term(a:dict)
  endif

  if s:GetDisasmWindow()
    let curwinid = win_getid(winnr())
    call s:GotoAsmwinOrCreateIt()
    call win_gotoid(curwinid)
  endif

  if exists('#User#TermdebugStartPost')
    doauto <nomodeline> User TermdebugStartPost
  endif
endfunc

" Use when debugger didn't start or ended.
func s:CloseBuffers()
  exe 'bwipe! ' . s:ptybuf
  exe 'bwipe! ' . s:commbuf
  unlet! s:gdbwin
endfunc

func s:CheckGdbRunning()
  let gdbproc = term_getjob(s:gdbbuf)
  if gdbproc == v:null || job_status(gdbproc) !=# 'run'
    echoerr string(s:GetCommand()[0]) . ' exited unexpectedly'
    call s:CloseBuffers()
    return ''
  endif
  return 'ok'
endfunc

" Open a terminal window without a job, to run the debugged program in.
func s:StartDebug_term(dict)
  let s:ptybuf = term_start('NONE', {
	\ 'term_name': 'debugged program',
	\ 'vertical': s:vertical,
	\ })
  if s:ptybuf == 0
    echoerr 'Failed to open the program terminal window'
    return
  endif
  let pty = job_info(term_getjob(s:ptybuf))['tty_out']
  let s:ptywin = win_getid(winnr())
  if s:vertical
    " Assuming the source code window will get a signcolumn, use two more
    " columns for that, thus one less for the terminal window.
    exe (&columns / 2 - 1) . "wincmd |"
    if s:allleft
      " use the whole left column
      wincmd H
    endif
  endif

  " Create a hidden terminal window to communicate with gdb
  let s:commbuf = term_start('NONE', {
	\ 'term_name': 'gdb communication',
	\ 'out_cb': function('s:CommOutput'),
	\ 'hidden': 1,
	\ })
  if s:commbuf == 0
    echoerr 'Failed to open the communication terminal window'
    exe 'bwipe! ' . s:ptybuf
    return
  endif
  let commpty = job_info(term_getjob(s:commbuf))['tty_out']

  let gdb_args = get(a:dict, 'gdb_args', [])
  let proc_args = get(a:dict, 'proc_args', [])

  let gdb_cmd = s:GetCommand()

  if exists('g:termdebug_config') && has_key(g:termdebug_config, 'command_add_args')
    let gdb_cmd = g:termdebug_config.command_add_args(gdb_cmd, pty)
  else
    " Add -quiet to avoid the intro message causing a hit-enter prompt.
    let gdb_cmd += ['-quiet']
    " Disable pagination, it causes everything to stop at the gdb
    let gdb_cmd += ['-iex', 'set pagination off']
    " Interpret commands while the target is running.  This should usually only
    " be exec-interrupt, since many commands don't work properly while the
    " target is running (so execute during startup).
    let gdb_cmd += ['-iex', 'set mi-async on']
    " Open a terminal window to run the debugger.
    let gdb_cmd += ['-tty', pty]
    " Command executed _after_ startup is done, provides us with the necessary
    " feedback
    let gdb_cmd += ['-ex', 'echo startupdone\n']
  endif

  if exists('g:termdebug_config') && has_key(g:termdebug_config, 'command_filter')
    let gdb_cmd = g:termdebug_config.command_filter(gdb_cmd)
  endif

  " Adding arguments requested by the user
  let gdb_cmd += gdb_args

  call ch_log('executing "' . join(gdb_cmd) . '"')
  let s:gdbbuf = term_start(gdb_cmd, {
	\ 'term_finish': 'close',
	\ })
  if s:gdbbuf == 0
    echoerr 'Failed to open the gdb terminal window'
    call s:CloseBuffers()
    return
  endif
  let s:gdbwin = win_getid(winnr())

  " Wait for the "startupdone" message before sending any commands.
  let try_count = 0
  while 1
    if s:CheckGdbRunning() != 'ok'
      return
    endif

    for lnum in range(1, 200)
      if term_getline(s:gdbbuf, lnum) =~ 'startupdone'
        let try_count = 9999
        break
      endif
    endfor
    let try_count += 1
    if try_count > 300
      " done or give up after five seconds
      break
    endif
    sleep 10m
  endwhile

  " Set arguments to be run.
  if len(proc_args)
    call term_sendkeys(s:gdbbuf, 'server set args ' . join(proc_args) . "\r")
  endif

  " Connect gdb to the communication pty, using the GDB/MI interface.
  " Prefix "server" to avoid adding this to the history.
  call term_sendkeys(s:gdbbuf, 'server new-ui mi ' . commpty . "\r")

  " Wait for the response to show up, users may not notice the error and wonder
  " why the debugger doesn't work.
  let try_count = 0
  while 1
    if s:CheckGdbRunning() != 'ok'
      return
    endif

    let response = ''
    for lnum in range(1, 200)
      let line1 = term_getline(s:gdbbuf, lnum)
      let line2 = term_getline(s:gdbbuf, lnum + 1)
      if line1 =~ 'new-ui mi '
        " response can be in the same line or the next line
        let response = line1 . line2
        if response =~ 'Undefined command'
          echoerr 'Sorry, your gdb is too old, gdb 7.12 is required'
          " CHECKME: possibly send a "server show version" here
          call s:CloseBuffers()
          return
        endif
        if response =~ 'New UI allocated'
          " Success!
          break
        endif
      elseif line1 =~ 'Reading symbols from' && line2 !~ 'new-ui mi '
        " Reading symbols might take a while, try more times
        let try_count -= 1
      endif
    endfor
    if response =~ 'New UI allocated'
      break
    endif
    let try_count += 1
    if try_count > 100
      echoerr 'Cannot check if your gdb works, continuing anyway'
      break
    endif
    sleep 10m
  endwhile

  call job_setoptions(term_getjob(s:gdbbuf), {'exit_cb': function('s:EndTermDebug')})
