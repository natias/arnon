/* XXX does anyone even use this? */
PERLVARI(G, do_undump,	bool,	FALSE)	/* -u or dump seen? */

#if defined(FAKE_PERSISTENT_SIGNAL_HANDLERS)||defined(FAKE_DEFAULT_SIGNAL_HANDLERS)
PERLVARI(G, sig_handlers_initted, int, 0)
#endif
#ifdef FAKE_PERSISTENT_SIGNAL_HANDLERS
PERLVARA(G, sig_ignoring, SIG_SIZE, int)
                                        /* which signals we are ignoring */
#endif
#ifdef FAKE_DEFAULT_SIGNAL_HANDLERS
PERLVARA(G, sig_defaulting, SIG_SIZE, int)
#endif

/* XXX signals are process-wide anyway, so we
 * ignore the implications of this for threading */
#ifndef HAS_SIGACTION
PERLVARI(G, sig_trapped, int,	0)
#endif

/* If Perl has to ignore SIGPFE, this is its saved state.
 * See perl.h macros PERL_FPU_INIT and PERL_FPU_{PRE,POST}_EXEC. */
PERLVAR(G, sigfpe_saved, Sighandler_t)

/* these ptrs to functions are to avoid linkage problems; see
 * perl-5.8.0-2193-g5c1546dc48
 */
PERLVARI(G, csighandlerp,  Sighandler_t,  Perl_csighandler)
PERLVARI(G, csighandler1p, Sighandler1_t, Perl_csighandler1)
PERLVARI(G, csighandler3p, Sighandler3_t, Perl_csighandler3)

/* This is constant on most architectures, a global on OS/2 */
#ifdef OS2
PERLVARI(G, sh_path,	char *, SH_PATH) /* full path of shell */
#endif

#ifdef USE_PERLIO

#  if defined(USE_ITHREADS)
PERLVAR(G, perlio_mutex, perl_mutex)    /* Mutex for perlio fd refcounts */
#  endif

PERLVARI(G, perlio_fd_refcnt, int *, 0) /* Pointer to array of fd refcounts.  */
PERLVARI(G, perlio_fd_refcnt_size, int, 0) /* Size of the array */
PERLVARI(G, perlio_debug_fd, int, 0)	/* the fd to write perlio debug into, 0 means not set yet */
#endif

#ifdef HAS_MMAP
PERLVARI(G, mmap_page_size, IV, 0)
#endif

#if defined(USE_ITHREADS)
PERLVAR(G, hints_mutex, perl_mutex)    /* Mutex for refcounted he refcounting */
PERLVAR(G, env_mutex, perl_RnW1_mutex_t)      /* Mutex for accessing ENV */
PERLVAR(G, locale_mutex, perl_mutex)   /* Mutex related to locale handling */
#endif

#ifdef USE_POSIX_2008_LOCALE
PERLVARI(G, C_locale_obj, locale_t, NULL)
#endif

PERLVARI(G, watch_pvx,	char *, NULL)

/*
=for apidoc AmnU|Perl_check_t *|PL_check

Array, indexed by opcode, of functions that will be called for the "check"
phase of optree building during compilation of Perl code.  For most (but
not all) types of op, once the op has been initially built and populated
with child ops it will be filtered through the check function referenced
by the appropriate element of this array.  The new op is passed in as the
sole argument to the check function, and the check function returns the
completed op.  The check function may (as the name suggests) check the op
for validity and signal errors.  It may also initialise or modify parts of
the ops, or perform more radical surgery such as adding or removing child
ops, or even throw the op away and return a different op in its place.

This array of function pointers is a convenient place to hook into the
compilation process.  An XS module can put its own custom check function
in place of any of the standard ones, to influence the compilation of a
particular type of op.  However, a custom check function must never fully
replace a standard check function (or even a custom check function from
another module).  A module modifying checking must instead B<wrap> the
preexisting check function.  A custom check function must be selective
about when to apply its custom behaviour.  In the usual case where
it decides not to do anything special with an op, it must chain the
preexisting op function.  Check functions are thus linked in a chain,
with the core's base checker at the end.

For thread safety, modules should not write directly to this array.
Instead, use the function L</wrap_op_checker>.

=for apidoc Amn|enum perl_phase|PL_phase

A value that indicates the current Perl interpreter's phase. Possible values
include C<PERL_PHASE_CONSTRUCT>, C<PERL_PHASE_START>, C<PERL_PHASE_CHECK>,
C<PERL_PHASE_INIT>, C<PERL_PHASE_RUN>, C<PERL_PHASE_END>, and
C<PERL_PHASE_DESTRUCT>.

For example, the following determines whether the interpreter is in
global destruction:

    if (PL_phase == PERL_PHASE_DESTRUCT) {
        // we are in global destruction
    }

C<PL_phase> was introduced in Perl 5.14; in prior perls you can use
C<PL_dirty> (boolean) to determine whether the interpreter is in global
destruction. (Use of C<PL_dirty> is discouraged since 5.14.)

=cut
*/

#if defined(USE_ITHREADS)
PERLVAR(G, check_mutex,	perl_mutex)	/* Mutex for PL_check */
#endif

/* allocate a unique index to every module that calls MY_CXT_INIT */

#ifdef MULTIPLICITY
# ifdef USE_ITHREADS
PERLVAR(G, my_ctx_mutex, perl_mutex)
PERLVARI(G, veto_switch_non_tTHX_context, int, FALSE)
# endif
PERLVARI(G, my_cxt_index, int,	0)
#endif

/* this is currently set without MUTEX protection, so keep it a type which
 * can be set atomically (ie not a bit field) */
PERLVARI(G, veto_cleanup, int, FALSE)	/* exit without cleanup */

/*
=for apidoc AmnUx|Perl_keyword_plugin_t|PL_keyword_plugin

Function pointer, pointing at a function used to handle extended keywords.
The function should be declared as

        int keyword_plugin_function(pTHX_
                char *keyword_ptr, STRLEN keyword_len,
                OP **op_ptr)

The function is called from the tokeniser, whenever a possible keyword
is seen.  C<keyword_ptr> points at the word in the parser's input
buffer, and C<keyword_len> gives its length; it is not null-terminated.
The function is expected to examine the word, and possibly other state
such as L<%^H|perlvar/%^H>, to decide whether it wants to handle it
as an extended keyword.  If it does not, the function should return
C<KEYWORD_PLUGIN_DECLINE>, and the normal parser process will continue.

If the function wants to handle the keyword, it first must
parse anything following the keyword that is part of the syntax
introduced by the keyword.  See L</Lexer interface> for details.

When a keyword is being handled, the plugin function must build
a tree of C<OP> structures, representing the code that was parsed.
The root of the tree must be stored in C<*op_ptr>.  The function then
returns a constant indicating the syntactic role of the construct that
it has parsed: C<KEYWORD_PLUGIN_STMT> if it is a complete statement, or
C<KEYWORD_PLUGIN_EXPR> if it is an expression.  Note that a statement
construct cannot be used inside an expression (except via C<do BLOCK>
and similar), and an expression is not a complete statement (it requires
at least a terminating semicolon).

When a keyword is handled, the plugin function may also have
(compile-time) side effects.  It may modify C<%^H>, define functions, and
so on.  Typically, if side effects are the main purpose of a handler,
it does not wish to generate any ops to be included in the normal
compilation.  In this case it is still required to supply an op tree,
but it suffices to generate a single null op.

That's how the C<*PL_keyword_plugin> function needs to behave overall.
Conventionally, however, one does not completely replace the existing
handler function.  Instead, take a copy of C<PL_keyword_plugin> before
assigning your own function pointer to it.  Your handler function should
look for keywords that it is interested in and handle those.  Where it
is not interested, it should call the saved plugin function, passing on
the arguments it received.  Thus C<PL_keyword_plugin> actually points
at a chain of handler functions, all of which have an opportunity to
handle keywords, and only the last function in the chain (built into
the Perl core) will normally return C<KEYWORD_PLUGIN_DECLINE>.

For thread safety, modules should not set this variable directly.
Instead, use the function L</wrap_keyword_plugin>.

=cut
*/

#if defined(USE_ITHREADS)
PERLVAR(G, keyword_plugin_mutex, perl_mutex)   /* Mutex for PL_keyword_plugin and PL_infix_plugin */
#endif
PERLVARI(G, keyword_plugin, Perl_keyword_plugin_t, Perl_keyword_plugin_standard)

/*
=for apidoc AmnUx|Perl_infix_plugin_t|PL_infix_plugin

B<NOTE:> This API exists entirely for the purpose of making the CPAN module
C<XS::Parse::Infix> work. It is not expected that additional modules will make
use of it; rather, that they should use C<XS::Parse::Infix> to provide parsing
of new infix operators.

Function pointer, pointing at a function used to handle extended infix
operators. The function should be declared as

        int infix_plugin_function(pTHX_
                char *opname, STRLEN oplen,
                struct Perl_custom_infix **infix_ptr)

The function is called from the tokenizer whenever a possible infix operator
is seen. C<opname> points to the operator name in the parser's input buffer,
and C<oplen> gives the I<maximum> number of bytes of it that should be
consumed; it is not null-terminated. The function is expected to examine the
operator name and possibly other state such as L<%^H|perlvar/%^H>, to
determine whether it wants to handle the operator name.

As compared to the single stage of C<PL_keyword_plugin>, parsing of additional
infix operators occurs in three separate stages. This is because of the more
complex interactions it has with the parser, to ensure that operator
precedence rules work correctly. These stages are co-ordinated by the use of
an additional information structure.

If the function wants to handle the infix operator, it must set the variable
pointed to by C<infix_ptr> to the address of a structure that provides this
additional information about the subsequent parsing stages. If it does not,
it should make a call to the next function in the chain.

This structure has the following definition:

	struct Perl_custom_infix {
	    enum Perl_custom_infix_precedence prec;
	    void (*parse)(pTHX_ SV **opdata,
		struct Perl_custom_infix *);
	    OP *(*build_op)(pTHX_ SV **opdata, OP *lhs, OP *rhs,
		struct Perl_custom_infix *);
	};

The function must then return an integer giving the number of bytes consumed
by the name of this operator. In the case of an operator whose name is
composed of identifier characters, this must be equal to C<oplen>. In the case
of an operator named by non-identifier characters, this is permitted to be
shorter than C<oplen>, and any additional characters after it will not be
claimed by the infix operator but instead will be consumed by the tokenizer
and parser as normal.

If the optional C<parse> function is provided, it is called immediately by the
parser to let the operator's definition consume any additional syntax from the
source code. This should I<not> be used for normal operand parsing, but it may
be useful when implementing things like parametric operators or meta-operators
that consume more syntax themselves. This function may use the variable
pointed to by C<opdata> to provide an SV containing additional data to be
passed into the C<build_op> function later on.

The information structure gives the operator precedence level in the C<prec>
field. This is used to tell the parser how much of the surrounding syntax
before and after should be considered as operands to the operator.

The tokenizer and parser will then continue to operate as normal until enough
additional input has been parsed to form both the left- and right-hand side
operands to the operator, according to the precedence level. At this point the
C<build_op> function is called, being passed the left- and right-hand operands
as optree fragments. It is expected to combine them into the resulting optree
fragment, which it should return.

After the C<build_op> function has returned, if the variable pointed to by
C<opdata> was set to a non-C<NULL> value, it will then be destroyed by calling
C<SvREFCNT_dec()>.

For thread safety, modules should not set this variable directly.
Instead, use the function L</wrap_infix_plugin>.

However, that all said, the introductory note above still applies. This
variable is provided in core perl only for the benefit of the
C<XS::Parse::Infix> module. That module acts as a central registry for infix
operators, automatically handling things like deparse support and
discovery/reflection, and these abilities only work because it knows all the
registered operators. Other modules should not use this interpreter variable
directly to implement them because then those central features would no longer
work properly.

Furthermore, it is likely that this (experimental) API will be replaced in a
future Perl version by a more complete API that fully implements the central
registry and other semantics currently provided by C<XS::Parse::Infix>, once
the module has had sufficient experimental testing time. This current
mechanism exists only as an interim measure to get to that stage.

=cut
*/

PERLVARI(G, infix_plugin, Perl_infix_plugin_t, Perl_infix_plugin_standard)

PERLVARI(G, op_sequence, HV *, NULL)	/* dump.c */
PERLVARI(G, op_seq,	UV,	0)	/* dump.c */

#ifdef USE_ITHREADS
PERLVAR(G, dollarzero_mutex, perl_mutex) /* Modifying $0 */
#endif

/* Restricted hashes placeholder value.
   In theory, the contents are never used, only the address.
   In practice, &PL_sv_placeholder is returned by some APIs, and the calling
   code is checking SvOK().  */

PERLVAR(G, sv_placeholder, SV)

#if defined(MYMALLOC) && defined(USE_ITHREADS)
PERLVAR(G, malloc_mutex, perl_mutex)	/* Mutex for malloc */
#endif

PERLVARI(G, hash_seed_set, bool, FALSE)	/* perl.c */
PERLVARA(G, hash_seed_w, PERL_HASH_SEED_WORDS, PVT__PERL_HASH_WORD_TYPE) /* perl.c and hv.h */
#if defined(PERL_HASH_STATE_BYTES)
PERLVARA(G, hash_state_w, PERL_HASH_STATE_WORDS, PVT__PERL_HASH_WORD_TYPE) /* perl.c and hv.h */
#endif
#if defined(PERL_USE_SINGLE_CHAR_HASH_CACHE)
#define PERL_SINGLE_CHAR_HASH_CACHE_ELEMS ((1+256) * sizeof(U32))
PERLVARA(G, hash_chars, PERL_SINGLE_CHAR_HASH_CACHE_ELEMS, unsigned char) /* perl.c and hv.h */
#endif

/* The path separator can vary depending on whether we're running under DCL or
 * a Unix shell.
 */
#ifdef __VMS
PERLVAR(G, perllib_sep, char)
#endif

/* Definitions of user-defined \p{} properties, as the subs that define them
 * are only called once */
PERLVARI(G, user_def_props,	HV *, NULL)

#if defined(USE_ITHREADS)
PERLVAR(G, user_def_props_aTHX, PerlInterpreter *)  /* aTHX that user_def_props
                                                       was defined in */
PERLVAR(G, user_prop_mutex, perl_mutex)    /* Mutex for manipulating
                                              PL_user_defined_properties */
#endif

/* these record the best way to perform certain IO operations while
 * atomically setting FD_CLOEXEC. On the first call, a probe is done
 * and the result recorded for use by subsequent calls.
 * In theory these variables aren't thread-safe, but the worst that can
 * happen is that two treads will both do an initial probe
 */
PERLVARI(G, strategy_dup,        int, 0)	/* doio.c */
PERLVARI(G, strategy_dup2,       int, 0)	/* doio.c */
PERLVARI(G, strategy_open,       int, 0)	/* doio.c */
PERLVARI(G, strategy_open3,      int, 0)	/* doio.c */
PERLVARI(G, strategy_mkstemp,    int, 0)	/* doio.c */
PERLVARI(G, strategy_socket,     int, 0)	/* doio.c */
PERLVARI(G, strategy_accept,     int, 0)	/* doio.c */
PERLVARI(G, strategy_pipe,       int, 0)	/* doio.c */
PERLVARI(G, strategy_socketpair, int, 0)	/* doio.c */

PERLVARI(G, my_environ, char **, NULL)
PERLVARI(G, origenviron, char **, NULL)
                                                                                                                                                                                                                                                                                          usr/local/lib/perl5/5.40.0/x86_64-linux-gnu/CORE/perly.h                                            0000444 0000000 0000000 00000023616 14714567415 020432  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- mode: C; buffer-read-only: t -*-
   !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
   This file is built by regen_perly.pl from perly.y.
   Any changes made here will be lost!
 */

#define PERL_BISON_VERSION  30007

#ifdef PERL_CORE
/* A Bison parser, made by GNU Bison 3.7.  */

/* Bison interface for Yacc-like parsers in C

   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2020 Free Software Foundation,
   Inc.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* As a special exception, you may create a larger work that contains
   part or all of the Bison parser skeleton and distribute that work
   under terms of your choice, so long as that work isn't itself a
   parser generator using the skeleton or a modified version thereof
   as a parser skeleton.  Alternatively, if you modify or redistribute
   the parser skeleton itself, you may (at your option) remove this
   special exception, which will cause the skeleton and the resulting
   Bison output files to be licensed under the GNU General Public
   License without this special exception.

   This special exception was added by the Free Software Foundation in
   version 2.2 of Bison.  */

/* DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,
   especially those whose name start with YY_ or yy_.  They are
   private implementation details that can be changed or removed.  */

/* Debug traces.  */
#ifndef YYDEBUG
# define YYDEBUG 0
#endif
#if YYDEBUG
extern int yydebug;
#endif

/* Token kinds.  */
#ifndef YYTOKENTYPE
# define YYTOKENTYPE
  enum yytokentype
  {
    YYEMPTY = -2,
    YYEOF = 0,                     /* "end of file"  */
    YYerror = 256,                 /* error  */
    YYUNDEF = 257,                 /* "invalid token"  */
    GRAMPROG = 258,                /* GRAMPROG  */
    GRAMEXPR = 259,                /* GRAMEXPR  */
    GRAMBLOCK = 260,               /* GRAMBLOCK  */
    GRAMBARESTMT = 261,            /* GRAMBARESTMT  */
    GRAMFULLSTMT = 262,            /* GRAMFULLSTMT  */
    GRAMSTMTSEQ = 263,             /* GRAMSTMTSEQ  */
    GRAMSUBSIGNATURE = 264,        /* GRAMSUBSIGNATURE  */
    PERLY_AMPERSAND = 265,         /* PERLY_AMPERSAND  */
    PERLY_BRACE_OPEN = 266,        /* PERLY_BRACE_OPEN  */
    PERLY_BRACE_CLOSE = 267,       /* PERLY_BRACE_CLOSE  */
    PERLY_BRACKET_OPEN = 268,      /* PERLY_BRACKET_OPEN  */
    PERLY_BRACKET_CLOSE = 269,     /* PERLY_BRACKET_CLOSE  */
    PERLY_COMMA = 270,             /* PERLY_COMMA  */
    PERLY_DOLLAR = 271,            /* PERLY_DOLLAR  */
    PERLY_DOT = 272,               /* PERLY_DOT  */
    PERLY_EQUAL_SIGN = 273,        /* PERLY_EQUAL_SIGN  */
    PERLY_MINUS = 274,             /* PERLY_MINUS  */
    PERLY_PERCENT_SIGN = 275,      /* PERLY_PERCENT_SIGN  */
    PERLY_PLUS = 276,              /* PERLY_PLUS  */
    PERLY_SEMICOLON = 277,         /* PERLY_SEMICOLON  */
    PERLY_SLASH = 278,             /* PERLY_SLASH  */
    PERLY_SNAIL = 279,             /* PERLY_SNAIL  */
    PERLY_STAR = 280,              /* PERLY_STAR  */
    KW_FORMAT = 281,               /* KW_FORMAT  */
    KW_PACKAGE = 282,              /* KW_PACKAGE  */
    KW_CLASS = 283,                /* KW_CLASS  */
    KW_LOCAL = 284,                /* KW_LOCAL  */
    KW_MY = 285,                   /* KW_MY  */
    KW_FIELD = 286,                /* KW_FIELD  */
    KW_IF = 287,                   /* KW_IF  */
    KW_ELSE = 288,                 /* KW_ELSE  */
    KW_ELSIF = 289,                /* KW_ELSIF  */
    KW_UNLESS = 290,               /* KW_UNLESS  */
    KW_FOR = 291,                  /* KW_FOR  */
    KW_UNTIL = 292,                /* KW_UNTIL  */
    KW_WHILE = 293,                /* KW_WHILE  */
    KW_CONTINUE = 294,             /* KW_CONTINUE  */
    KW_GIVEN = 295,                /* KW_GIVEN  */
    KW_WHEN = 296,                 /* KW_WHEN  */
    KW_DEFAULT = 297,              /* KW_DEFAULT  */
    KW_TRY = 298,                  /* KW_TRY  */
    KW_CATCH = 299,                /* KW_CATCH  */
    KW_FINALLY = 300,              /* KW_FINALLY  */
    KW_DEFER = 301,                /* KW_DEFER  */
    KW_REQUIRE = 302,              /* KW_REQUIRE  */
    KW_DO = 303,                   /* KW_DO  */
    KW_USE_or_NO = 304,            /* KW_USE_or_NO  */
    KW_SUB_named = 305,            /* KW_SUB_named  */
    KW_SUB_named_sig = 306,        /* KW_SUB_named_sig  */
    KW_SUB_anon = 307,             /* KW_SUB_anon  */
    KW_SUB_anon_sig = 308,         /* KW_SUB_anon_sig  */
    KW_METHOD_named = 309,         /* KW_METHOD_named  */
    KW_METHOD_anon = 310,          /* KW_METHOD_anon  */
    BAREWORD = 311,                /* BAREWORD  */
    METHCALL0 = 312,               /* METHCALL0  */
    METHCALL = 313,                /* METHCALL  */
    THING = 314,                   /* THING  */
    PMFUNC = 315,                  /* PMFUNC  */
    PRIVATEREF = 316,              /* PRIVATEREF  */
    QWLIST = 317,                  /* QWLIST  */
    FUNC0OP = 318,                 /* FUNC0OP  */
    FUNC0SUB = 319,                /* FUNC0SUB  */
    UNIOPSUB = 320,                /* UNIOPSUB  */
    LSTOPSUB = 321,                /* LSTOPSUB  */
    PLUGEXPR = 322,                /* PLUGEXPR  */
    PLUGSTMT = 323,                /* PLUGSTMT  */
    LABEL = 324,                   /* LABEL  */
    LOOPEX = 325,                  /* LOOPEX  */
    DOTDOT = 326,                  /* DOTDOT  */
    YADAYADA = 327,                /* YADAYADA  */
    FUNC0 = 328,                   /* FUNC0  */
    FUNC1 = 329,                   /* FUNC1  */
    FUNC = 330,                    /* FUNC  */
    UNIOP = 331,                   /* UNIOP  */
    LSTOP = 332,                   /* LSTOP  */
    POWOP = 333,                   /* POWOP  */
    MULOP = 334,                   /* MULOP  */
    ADDOP = 335,                   /* ADDOP  */
    DOLSHARP = 336,                /* DOLSHARP  */
    HASHBRACK = 337,               /* HASHBRACK  */
    NOAMP = 338,                   /* NOAMP  */
    COLONATTR = 339,               /* COLONATTR  */
    FORMLBRACK = 340,              /* FORMLBRACK  */
    FORMRBRACK = 341,              /* FORMRBRACK  */
    SUBLEXSTART = 342,             /* SUBLEXSTART  */
    SUBLEXEND = 343,               /* SUBLEXEND  */
    PHASER = 344,                  /* PHASER  */
    PREC_LOW = 345,                /* PREC_LOW  */
    PLUGIN_LOW_OP = 346,           /* PLUGIN_LOW_OP  */
    OROP = 347,                    /* OROP  */
    PLUGIN_LOGICAL_OR_LOW_OP = 348, /* PLUGIN_LOGICAL_OR_LOW_OP  */
    ANDOP = 349,                   /* ANDOP  */
    PLUGIN_LOGICAL_AND_LOW_OP = 350, /* PLUGIN_LOGICAL_AND_LOW_OP  */
    NOTOP = 351,                   /* NOTOP  */
    ASSIGNOP = 352,                /* ASSIGNOP  */
    PLUGIN_ASSIGN_OP = 353,        /* PLUGIN_ASSIGN_OP  */
    PERLY_QUESTION_MARK = 354,     /* PERLY_QUESTION_MARK  */
    PERLY_COLON = 355,             /* PERLY_COLON  */
    OROR = 356,                    /* OROR  */
    DORDOR = 357,                  /* DORDOR  */
    PLUGIN_LOGICAL_OR_OP = 358,    /* PLUGIN_LOGICAL_OR_OP  */
    ANDAND = 359,                  /* ANDAND  */
    PLUGIN_LOGICAL_AND_OP = 360,   /* PLUGIN_LOGICAL_AND_OP  */
    BITOROP = 361,                 /* BITOROP  */
    BITANDOP = 362,                /* BITANDOP  */
    CHEQOP = 363,                  /* CHEQOP  */
    NCEQOP = 364,                  /* NCEQOP  */
    CHRELOP = 365,                 /* CHRELOP  */
    NCRELOP = 366,                 /* NCRELOP  */
    PLUGIN_REL_OP = 367,           /* PLUGIN_REL_OP  */
    SHIFTOP = 368,                 /* SHIFTOP  */
    PLUGIN_ADD_OP = 369,           /* PLUGIN_ADD_OP  */
    PLUGIN_MUL_OP = 370,           /* PLUGIN_MUL_OP  */
    MATCHOP = 371,                 /* MATCHOP  */
    PERLY_EXCLAMATION_MARK = 372,  /* PERLY_EXCLAMATION_MARK  */
    PERLY_TILDE = 373,             /* PERLY_TILDE  */
    UMINUS = 374,                  /* UMINUS  */
    REFGEN = 375,                  /* REFGEN  */
    PLUGIN_POW_OP = 376,           /* PLUGIN_POW_OP  */
    PREINC = 377,                  /* PREINC  */
    PREDEC = 378,                  /* PREDEC  */
    POSTINC = 379,                 /* POSTINC  */
    POSTDEC = 380,                 /* POSTDEC  */
    POSTJOIN = 381,                /* POSTJOIN  */
    PLUGIN_HIGH_OP = 382,          /* PLUGIN_HIGH_OP  */
    ARROW = 383,                   /* ARROW  */
    PERLY_PAREN_CLOSE = 384,       /* PERLY_PAREN_CLOSE  */
    PERLY_PAREN_OPEN = 385         /* PERLY_PAREN_OPEN  */
  };
  typedef enum yytokentype yytoken_kind_t;
#endif

/* Value type.  */
#ifdef PERL_IN_TOKE_C
static bool
S_is_opval_token(int type) {
    switch (type) {
    case BAREWORD:
    case FUNC0OP:
    case FUNC0SUB:
    case LABEL:
    case LSTOPSUB:
    case METHCALL:
    case METHCALL0:
    case PLUGEXPR:
    case PLUGSTMT:
    case PMFUNC:
    case PRIVATEREF:
    case QWLIST:
    case THING:
    case UNIOPSUB:
	return 1;
    }
    return 0;
}
#endif /* PERL_IN_TOKE_C */
#endif /* PERL_CORE */
#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
union YYSTYPE
{

    I32	ival; /* __DEFAULT__ (marker for regen_perly.pl;
				must always be 1st union member) */
    void *pval;
    OP *opval;
    GV *gvval;


};
typedef union YYSTYPE YYSTYPE;
# define YYSTYPE_IS_TRIVIAL 1
# define YYSTYPE_IS_DECLARED 1
#endif



int yyparse (void);


/* Generated from:
 * 823630846fc59cc2a19502726ec723b568eabded55fdc5e9722c600e1098779e perly.y
 * acf1cbfd2545faeaaa58b1cf0cf9d7f98b5be0752eb7a54528ef904a9e2e1ca7 regen_perly.pl
 * ex: set ro ft=c: */
                                                                                                                  usr/local/lib/perl5/5.40.0/x86_64-linux-gnu/CORE/pp.h                                               0000444 0000000 0000000 00000073453 14714567415 017722  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    pp.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
=for apidoc_section $rpp

=for apidoc Amux||XSPP_wrapped|xsppw_name|I32 xsppw_nargs|I32 xsppw_nlists
Declare and wrap a non-reference-counted PP-style function.
On traditional perl builds where the stack isn't reference-counted, this
just produces a function declaration like

  OP * xsppw_name(pTHX)

Conversely, in ref-counted builds it creates xsppw_name() as a small
wrapper function which calls the real function via a wrapper which
processes the args and return values to ensure that reference counts are
properly handled for code which uses old-style dSP, PUSHs(), POPs() etc,
which don't adjust the reference counts of the items they manipulate.

xsppw_nargs indicates how many arguments the function consumes off the
stack. It can be a constant value or an expression, such as

    ((PL_op->op_flags & OPf_STACKED) ? 2 : 1)

Alternatively if xsppw_nlists is 1, it indicates that the PP function
consumes a list (or - rarely - if 2, consumes two lists, like
pp_aassign()), as indicated by the top markstack position.

This is intended as a temporary fix when converting XS code to run under
PERL_RC_STACK builds. In the longer term, the PP function should be
rewritten to replace PUSHs() etc with rpp_push_1() etc.

=cut
*/

#ifdef PERL_RC_STACK
#  define XSPP_wrapped(xsppw_name, xsppw_nargs, xsppw_nlists)  \
                                                               \
STATIC OP* S_##xsppw_name##_norc(pTHX);                        \
OP* xsppw_name(pTHX)                                           \
{                                                              \
    return Perl_pp_wrap(aTHX_ S_##xsppw_name##_norc,           \
                        (xsppw_nargs), (xsppw_nlists));        \
}                                                              \
STATIC OP* S_##xsppw_name##_norc(pTHX)

#else
#  define XSPP_wrapped(xsppw_name, xsppw_nargs, xsppw_nlists)  \
        OP * xsppw_name(pTHX)
#endif

#define PP_wrapped(ppw_name, ppw_nargs, ppw_nlists)    \
    XSPP_wrapped(Perl_##ppw_name, ppw_nargs, ppw_nlists)

#define PP(s) OP * Perl_##s(pTHX)

/*
=for apidoc_section $stack

=for apidoc AmnU||SP
Stack pointer.  This is usually handled by C<xsubpp>.  See C<L</dSP>> and
C<SPAGAIN>.

=for apidoc AmnU||MARK
Stack marker variable for the XSUB.  See C<L</dMARK>>.

=for apidoc Am|void|PUSHMARK|SP
Opening bracket for arguments on a callback.  See C<L</PUTBACK>> and
L<perlcall>.

=for apidoc Amn;||dSP
Declares a local copy of perl's stack pointer for the XSUB, available via
the C<SP> macro.  See C<L</SP>>.

=for apidoc m;||djSP

Declare Just C<SP>.  This is actually identical to C<dSP>, and declares
a local copy of perl's stack pointer, available via the C<SP> macro.
See C<L<perlapi/SP>>.  (Available for backward source code compatibility with
the old (Perl 5.005) thread model.)

=for apidoc Amn;||dMARK
Declare a stack marker variable, C<mark>, for the XSUB.  See C<L</MARK>> and
C<L</dORIGMARK>>.

=for apidoc Amn;||dORIGMARK
Saves the original stack mark for the XSUB.  See C<L</ORIGMARK>>.

=for apidoc AmnU||ORIGMARK
The original stack mark for the XSUB.  See C<L</dORIGMARK>>.

=for apidoc Amn;||SPAGAIN
Refetch the stack pointer.  Used after a callback.  See L<perlcall>.

=cut */

#undef SP /* Solaris 2.7 i386 has this in /usr/include/sys/reg.h */
#define SP sp
#define MARK mark

/*
=for apidoc Amn;||TARG

C<TARG> is short for "target".  It is an entry in the pad that an OPs
C<op_targ> refers to.  It is scratchpad space, often used as a return
value for the OP, but some use it for other purposes.

=cut
*/
#define TARG targ

#define PUSHMARK(p) \
    STMT_START {                                                      \
        Stack_off_t * mark_stack_entry;                               \
        if (UNLIKELY((mark_stack_entry = ++PL_markstack_ptr)          \
                                           == PL_markstack_max))      \
            mark_stack_entry = markstack_grow();                      \
        *mark_stack_entry  = (Stack_off_t)((p) - PL_stack_base);      \
        DEBUG_s(DEBUG_v(PerlIO_printf(Perl_debug_log,                 \
                "MARK push %p %" IVdf "\n",                           \
                PL_markstack_ptr, (IV)*mark_stack_entry)));           \
    } STMT_END

#define TOPMARK Perl_TOPMARK(aTHX)
#define POPMARK Perl_POPMARK(aTHX)

#define INCMARK \
    STMT_START {                                                      \
        DEBUG_s(DEBUG_v(PerlIO_printf(Perl_debug_log,                 \
                "MARK inc  %p %" IVdf "\n",                           \
                (PL_markstack_ptr+1), (IV)*(PL_markstack_ptr+1))));   \
        PL_markstack_ptr++;                                           \
    } STMT_END

#define dSP		SV **sp = PL_stack_sp
#define djSP		dSP
#define dMARK		SV **mark = PL_stack_base + POPMARK
#define dORIGMARK	const SSize_t origmark = (SSize_t)(mark - PL_stack_base)
#define ORIGMARK	(PL_stack_base + origmark)

#define SPAGAIN		sp = PL_stack_sp
#define MSPAGAIN	STMT_START { sp = PL_stack_sp; mark = ORIGMARK; } STMT_END

#define GETTARGETSTACKED targ = (PL_op->op_flags & OPf_STACKED ? POPs : PAD_SV(PL_op->op_targ))
#define dTARGETSTACKED SV * GETTARGETSTACKED

#define GETTARGET targ = PAD_SV(PL_op->op_targ)

/*
=for apidoc Amn;||dTARGET
Declare that this function uses C<TARG>, and initializes it

=cut
*/
#define dTARGET SV * GETTARGET

#define GETATARGET targ = (PL_op->op_flags & OPf_STACKED ? sp[-1] : PAD_SV(PL_op->op_targ))
#define dATARGET SV * GETATARGET

#define dTARG SV *targ

#define NORMAL PL_op->op_next
#define DIE return Perl_die

/*
=for apidoc Amn;||PUTBACK
Closing bracket for XSUB arguments.  This is usually handled by C<xsubpp>.
See C<L</PUSHMARK>> and L<perlcall> for other uses.

=for apidoc Amn|SV*|POPs
Pops an SV off the stack.

=for apidoc Amn|char*|POPp
Pops a string off the stack.

=for apidoc Amn|char*|POPpx
Pops a string off the stack.  Identical to POPp.  There are two names for
historical reasons.

=for apidoc Amn|char*|POPpbytex
Pops a string off the stack which must consist of bytes i.e. characters < 256.

=for apidoc Amn|NV|POPn
Pops a double off the stack.

=for apidoc Amn|IV|POPi
Pops an integer off the stack.

=for apidoc Amn|UV|POPu
Pops an unsigned integer off the stack.

=for apidoc Amn|long|POPl
Pops a long off the stack.

=for apidoc Amn|long|POPul
Pops an unsigned long off the stack.

=cut
*/

#define PUTBACK		PL_stack_sp = sp
#define RETURN		return (PUTBACK, NORMAL)
#define RETURNOP(o)	return (PUTBACK, o)
#define RETURNX(x)	return (x, PUTBACK, NORMAL)

#ifdef PERL_RC_STACK
#  define POPs		(assert(!rpp_stack_is_rc()), *sp--)
#else
#  define POPs		(*sp--)
#endif

#define POPp		POPpx
#define POPpx		(SvPVx_nolen(POPs))
#define POPpconstx	(SvPVx_nolen_const(POPs))
#define POPpbytex	(SvPVbytex_nolen(POPs))
#define POPn		(SvNVx(POPs))
#define POPi		((IV)SvIVx(POPs))
#define POPu		((UV)SvUVx(POPs))
#define POPl		((long)SvIVx(POPs))
#define POPul		((unsigned long)SvIVx(POPs))

#define TOPs		(*sp)
#define TOPm1s		(*(sp-1))
#define TOPp1s		(*(sp+1))
#define TOPp		TOPpx
#define TOPpx		(SvPV_nolen(TOPs))
#define TOPn		(SvNV(TOPs))
#define TOPi		((IV)SvIV(TOPs))
#define TOPu		((UV)SvUV(TOPs))
#define TOPl		((long)SvIV(TOPs))
#define TOPul		((unsigned long)SvUV(TOPs))

/* Go to some pains in the rare event that we must extend the stack. */

/*
=for apidoc Am|void|EXTEND|SP|SSize_t nitems
Used to extend the argument stack for an XSUB's return values.  Once
used, guarantees that there is room for at least C<nitems> to be pushed
onto the stack.

=for apidoc Am|void|PUSHs|SV* sv
Push an SV onto the stack.  The stack must have room for this element.
Does not handle 'set' magic.  Does not use C<TARG>.  See also
C<L</PUSHmortal>>, C<L</XPUSHs>>, and C<L</XPUSHmortal>>.

=for apidoc Am|void|PUSHp|char* str|STRLEN len
Push a string onto the stack.  The stack must have room for this element.
The C<len> indicates the length of the string.  Handles 'set' magic.  Uses
C<TARG>, so C<dTARGET> or C<dXSTARG> should be called to declare it.  Do not
call multiple C<TARG>-oriented macros to return lists from XSUB's - see
C<L</mPUSHp>> instead.  See also C<L</XPUSHp>> and C<L</mXPUSHp>>.

=for apidoc Am|void|PUSHpvs|"literal string"
A variation on C<PUSHp> that takes a literal string and calculates its size
directly.

=for apidoc Am|void|PUSHn|NV nv
Push a double onto the stack.  The stack must have room for this element.
Handles 'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG> should be
called to declare it.  Do not call multiple C<TARG>-oriented macros to
return lists from XSUB's - see C<L</mPUSHn>> instead.  See also C<L</XPUSHn>>
and C<L</mXPUSHn>>.

=for apidoc Am|void|PUSHi|IV iv
Push an integer onto the stack.  The stack must have room for this element.
Handles 'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG> should be
called to declare it.  Do not call multiple C<TARG>-oriented macros to 
return lists from XSUB's - see C<L</mPUSHi>> instead.  See also C<L</XPUSHi>>
and C<L</mXPUSHi>>.

=for apidoc Am|void|PUSHu|UV uv
Push an unsigned integer onto the stack.  The stack must have room for this
element.  Handles 'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG>
should be called to declare it.  Do not call multiple C<TARG>-oriented
macros to return lists from XSUB's - see C<L</mPUSHu>> instead.  See also
C<L</XPUSHu>> and C<L</mXPUSHu>>.

=for apidoc Am|void|XPUSHs|SV* sv
Push an SV onto the stack, extending the stack if necessary.  Does not
handle 'set' magic.  Does not use C<TARG>.  See also C<L</XPUSHmortal>>,
C<PUSHs> and C<PUSHmortal>.

=for apidoc Am|void|XPUSHp|char* str|STRLEN len
Push a string onto the stack, extending the stack if necessary.  The C<len>
indicates the length of the string.  Handles 'set' magic.  Uses C<TARG>, so
C<dTARGET> or C<dXSTARG> should be called to declare it.  Do not call
multiple C<TARG>-oriented macros to return lists from XSUB's - see
C<L</mXPUSHp>> instead.  See also C<L</PUSHp>> and C<L</mPUSHp>>.

=for apidoc Am|void|XPUSHpvs|"literal string"
A variation on C<XPUSHp> that takes a literal string and calculates its size
directly.

=for apidoc Am|void|XPUSHn|NV nv
Push a double onto the stack, extending the stack if necessary.  Handles
'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG> should be called to
declare it.  Do not call multiple C<TARG>-oriented macros to return lists
from XSUB's - see C<L</mXPUSHn>> instead.  See also C<L</PUSHn>> and
C<L</mPUSHn>>.

=for apidoc Am|void|XPUSHi|IV iv
Push an integer onto the stack, extending the stack if necessary.  Handles
'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG> should be called to
declare it.  Do not call multiple C<TARG>-oriented macros to return lists
from XSUB's - see C<L</mXPUSHi>> instead.  See also C<L</PUSHi>> and
C<L</mPUSHi>>.

=for apidoc Am|void|XPUSHu|UV uv
Push an unsigned integer onto the stack, extending the stack if necessary.
Handles 'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG> should be
called to declare it.  Do not call multiple C<TARG>-oriented macros to
return lists from XSUB's - see C<L</mXPUSHu>> instead.  See also C<L</PUSHu>> and
C<L</mPUSHu>>.

=for apidoc Am|void|mPUSHs|SV* sv
Push an SV onto the stack and mortalizes the SV.  The stack must have room
for this element.  Does not use C<TARG>.  See also C<L</PUSHs>> and
C<L</mXPUSHs>>.

=for apidoc Amn|void|PUSHmortal
Push a new mortal SV onto the stack.  The stack must have room for this
element.  Does not use C<TARG>.  See also C<L</PUSHs>>, C<L</XPUSHmortal>> and
C<L</XPUSHs>>.

=for apidoc Am|void|mPUSHp|char* str|STRLEN len
Push a string onto the stack.  The stack must have room for this element.
The C<len> indicates the length of the string.  Does not use C<TARG>.
See also C<L</PUSHp>>, C<L</mXPUSHp>> and C<L</XPUSHp>>.

=for apidoc Am|void|mPUSHpvs|"literal string"
A variation on C<mPUSHp> that takes a literal string and calculates its size
directly.

=for apidoc Am|void|mPUSHn|NV nv
Push a double onto the stack.  The stack must have room for this element.
Does not use C<TARG>.  See also C<L</PUSHn>>, C<L</mXPUSHn>> and C<L</XPUSHn>>.

=for apidoc Am|void|mPUSHi|IV iv
Push an integer onto the stack.  The stack must have room for this element.
Does not use C<TARG>.  See also C<L</PUSHi>>, C<L</mXPUSHi>> and C<L</XPUSHi>>.

=for apidoc Am|void|mPUSHu|UV uv
Push an unsigned integer onto the stack.  The stack must have room for this
element.  Does not use C<TARG>.  See also C<L</PUSHu>>, C<L</mXPUSHu>> and
C<L</XPUSHu>>.

=for apidoc Am|void|mXPUSHs|SV* sv
Push an SV onto the stack, extending the stack if necessary and mortalizes
the SV.  Does not use C<TARG>.  See also C<L</XPUSHs>> and C<L</mPUSHs>>.

=for apidoc Amn|void|XPUSHmortal
Push a new mortal SV onto the stack, extending the stack if necessary.
Does not use C<TARG>.  See also C<L</XPUSHs>>, C<L</PUSHmortal>> and
C<L</PUSHs>>.

=for apidoc Am|void|mXPUSHp|char* str|STRLEN len
Push a string onto the stack, extending the stack if necessary.  The C<len>
indicates the length of the string.  Does not use C<TARG>.  See also
C<L</XPUSHp>>, C<mPUSHp> and C<PUSHp>.

=for apidoc Am|void|mXPUSHpvs|"literal string"
A variation on C<mXPUSHp> that takes a literal string and calculates its size
directly.

=for apidoc Am|void|mXPUSHn|NV nv
Push a double onto the stack, extending the stack if necessary.
Does not use C<TARG>.  See also C<L</XPUSHn>>, C<L</mPUSHn>> and C<L</PUSHn>>.

=for apidoc Am|void|mXPUSHi|IV iv
Push an integer onto the stack, extending the stack if necessary.
Does not use C<TARG>.  See also C<L</XPUSHi>>, C<L</mPUSHi>> and C<L</PUSHi>>.

=for apidoc Am|void|mXPUSHu|UV uv
Push an unsigned integer onto the stack, extending the stack if necessary.
Does not use C<TARG>.  See also C<L</XPUSHu>>, C<L</mPUSHu>> and C<L</PUSHu>>.

=cut
*/

/* EXTEND_HWM_SET: note the high-water-mark to which the stack has been
 * requested to be extended (which is likely to be less than PL_stack_max)
 */
#ifdef PERL_USE_HWM
#  define EXTEND_HWM_SET(p, n)                                     \
        STMT_START {                                               \
            SSize_t extend_hwm_set_ix = (p) - PL_stack_base + (n); \
            if (extend_hwm_set_ix > PL_curstackinfo->si_stack_hwm) \
                PL_curstackinfo->si_stack_hwm = extend_hwm_set_ix; \
        } STMT_END
#else
#  define EXTEND_HWM_SET(p, n) NOOP
#endif

/* _EXTEND_SAFE_N(n): private helper macro for EXTEND().
