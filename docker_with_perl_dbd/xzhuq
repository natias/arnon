  call <SID>OptionL("fdl")
  call <SID>AddOption("foldlevelstart", gettext("value for 'foldlevel' when starting to edit a file"))
  call append("$", " \tset fdls=" . &fdls)
  call <SID>AddOption("foldcolumn", gettext("width of the column used to indicate folds"))
  call append("$", "\t" .. s:local_to_window)
  call <SID>OptionL("fdc")
  call <SID>AddOption("foldtext", gettext("expression used to display the text of a closed fold"))
  call append("$", "\t" .. s:local_to_window)
  call <SID>OptionL("fdt")
  call <SID>AddOption("foldclose", gettext("set to \"all\" to close a fold when the cursor leaves it"))
  call <SID>OptionG("fcl", &fcl)
  call <SID>AddOption("foldopen", gettext("specifies for which commands a fold will be opened"))
  call <SID>OptionG("fdo", &fdo)
  call <SID>AddOption("foldminlines", gettext("minimum number of screen lines for a fold to be closed"))
  call append("$", "\t" .. s:local_to_window)
  call <SID>OptionL("fml")
  call <SID>AddOption("commentstring", gettext("template for comments; used to put the marker in"))
  call <SID>OptionL("cms")
  call <SID>AddOption("foldmethod", gettext("folding type: \"manual\", \"indent\", \"expr\", \"marker\",\n\"syntax\" or \"diff\""))
  call append("$", "\t" .. s:local_to_window)
  call <SID>OptionL("fdm")
  call <SID>AddOption("foldexpr", gettext("expression used when 'foldmethod' is \"expr\""))
  call append("$", "\t" .. s:local_to_window)
  call <SID>OptionL("fde")
  call <SID>AddOption("foldignore", gettext("used to ignore lines when 'foldmethod' is \"indent\""))
  call append("$", "\t" .. s:local_to_window)
  call <SID>OptionL("fdi")
  call <SID>AddOption("foldmarker", gettext("markers used when 'foldmethod' is \"marker\""))
  call append("$", "\t" .. s:local_to_window)
  call <SID>OptionL("fmr")
  call <SID>AddOption("foldnestmax", gettext("maximum fold depth for when 'foldmethod' is \"indent\" or \"syntax\""))
  call append("$", "\t" .. s:local_to_window)
  call <SID>OptionL("fdn")
endif


if has("diff")
  call <SID>Header(gettext("diff mode"))
  call <SID>AddOption("diff", gettext("use diff mode for the current window"))
  call append("$", "\t" .. s:local_to_window)
  call <SID>BinOptionL("diff")
  call <SID>AddOption("diffopt", gettext("options for using diff mode"))
  call <SID>OptionG("dip", &dip)
  call <SID>AddOption("diffexpr", gettext("expression used to obtain a diff file"))
  call <SID>OptionG("dex", &dex)
  call <SID>AddOption("patchexpr", gettext("expression used to patch a file"))
  call <SID>OptionG("pex", &pex)
endif


call <SID>Header(gettext("mapping"))
call <SID>AddOption("maxmapdepth", gettext("maximum depth of mapping"))
call append("$", " \tset mmd=" . &mmd)
call <SID>AddOption("remap", gettext("recognize mappings in mapped keys"))
call <SID>BinOptionG("remap", &remap)
call <SID>AddOption("timeout", gettext("allow timing out halfway into a mapping"))
call <SID>BinOptionG("to", &to)
call <SID>AddOption("ttimeout", gettext("allow timing out halfway into a key code"))
call <SID>BinOptionG("ttimeout", &ttimeout)
call <SID>AddOption("timeoutlen", gettext("time in msec for 'timeout'"))
call append("$", " \tset tm=" . &tm)
call <SID>AddOption("ttimeoutlen", gettext("time in msec for 'ttimeout'"))
call append("$", " \tset ttm=" . &ttm)


call <SID>Header(gettext("reading and writing files"))
call <SID>AddOption("modeline", gettext("enable using settings from modelines when reading a file"))
call append("$", "\t" .. s:local_to_buffer)
call <SID>BinOptionL("ml")
call <SID>AddOption("modelineexpr", gettext("allow setting expression options from a modeline"))
call <SID>BinOptionG("mle", &mle)
call <SID>AddOption("modelines", gettext("number of lines to check for modelines"))
call append("$", " \tset mls=" . &mls)
call <SID>AddOption("binary", gettext("binary file editing"))
call append("$", "\t" .. s:local_to_buffer)
call <SID>BinOptionL("bin")
call <SID>AddOption("endofline", gettext("last line in the file has an end-of-line"))
call append("$", "\t" .. s:local_to_buffer)
call <SID>BinOptionL("eol")
call <SID>AddOption("endoffile", gettext("last line in the file followed by CTRL-Z"))
call append("$", "\t" .. s:local_to_buffer)
call <SID>BinOptionL("eof")
call <SID>AddOption("fixendofline", gettext("fixes missing end-of-line at end of text file"))
call append("$", "\t" .. s:local_to_buffer)
call <SID>BinOptionL("fixeol")
call <SID>AddOption("bomb", gettext("prepend a Byte Order Mark to the file"))
call append("$", "\t" .. s:local_to_buffer)
call <SID>BinOptionL("bomb")
call <SID>AddOption("fileformat", gettext("end-of-line format: \"dos\", \"unix\" or \"mac\""))
call append("$", "\t" .. s:local_to_buffer)
call <SID>OptionL("ff")
call <SID>AddOption("fileformats", gettext("list of file formats to look for when editing a file"))
call <SID>OptionG("ffs", &ffs)
call <SID>AddOption("textmode", gettext("obsolete, use 'fileformat'"))
call append("$", "\t" .. s:local_to_buffer)
call <SID>BinOptionL("tx")
call <SID>AddOption("textauto", gettext("obsolete, use 'fileformats'"))
call <SID>BinOptionG("ta", &ta)
call <SID>AddOption("write", gettext("writing files is allowed"))
call <SID>BinOptionG("write", &write)
call <SID>AddOption("writebackup", gettext("write a backup file before overwriting a file"))
call <SID>BinOptionG("wb", &wb)
call <SID>AddOption("backup", gettext("keep a backup after overwriting a file"))
call <SID>BinOptionG("bk", &bk)
call <SID>AddOption("backupskip", gettext("patterns that specify for which files a backup is not made"))
call append("$", " \tset bsk=" . &bsk)
call <SID>AddOption("backupcopy", gettext("whether to make the backup as a copy or rename the existing file"))
call append("$", "\t" .. s:global_or_local)
call append("$", " \tset bkc=" . &bkc)
call <SID>AddOption("backupdir", gettext("list of directories to put backup files in"))
call <SID>OptionG("bdir", &bdir)
call <SID>AddOption("backupext", gettext("file name extension for the backup file"))
call <SID>OptionG("bex", &bex)
call <SID>AddOption("autowrite", gettext("automatically write a file when leaving a modified buffer"))
call <SID>BinOptionG("aw", &aw)
call <SID>AddOption("autowriteall", gettext("as 'autowrite', but works with more commands"))
call <SID>BinOptionG("awa", &awa)
call <SID>AddOption("writeany", gettext("always write without asking for confirmation"))
call <SID>BinOptionG("wa", &wa)
call <SID>AddOption("autoread", gettext("automatically read a file when it was modified outside of Vim"))
call append("$", "\t" .. s:global_or_local)
call <SID>BinOptionG("ar", &ar)
call <SID>AddOption("patchmode", gettext("keep oldest version of a file; specifies file name extension"))
call <SID>OptionG("pm", &pm)
call <SID>AddOption("fsync", gettext("forcibly sync the file to disk after writing it"))
call <SID>BinOptionG("fs", &fs)
call <SID>AddOption("shortname", gettext("use 8.3 file names"))
call append("$", "\t" .. s:local_to_buffer)
call <SID>BinOptionL("sn")
call <SID>AddOption("cryptmethod", gettext("encryption method for file writing: zip, blowfish or blowfish2"))
call append("$", "\t" .. s:local_to_buffer)
call <SID>OptionL("cm")


call <SID>Header(gettext("the swap file"))
call <SID>AddOption("directory", gettext("list of directories for the swap file"))
call <SID>OptionG("dir", &dir)
call <SID>AddOption("swapfile", gettext("use a swap file for this buffer"))
call append("$", "\t" .. s:local_to_buffer)
call <SID>BinOptionL("swf")
call <SID>AddOption("swapsync", gettext("\"sync\", \"fsync\" or empty; how to flush a swap file to disk"))
call <SID>OptionG("sws", &sws)
call <SID>AddOption("updatecount", gettext("number of characters typed to cause a swap file update"))
call append("$", " \tset uc=" . &uc)
call <SID>AddOption("updatetime", gettext("time in msec after which the swap file will be updated"))
call append("$", " \tset ut=" . &ut)
call <SID>AddOption("maxmem", gettext("maximum amount of memory in Kbyte used for one buffer"))
call append("$", " \tset mm=" . &mm)
call <SID>AddOption("maxmemtot", gettext("maximum amount of memory in Kbyte used for all buffers"))
call append("$", " \tset mmt=" . &mmt)


call <SID>Header(gettext("command line editing"))
call <SID>AddOption("history", gettext("how many command lines are remembered"))
call append("$", " \tset hi=" . &hi)
call <SID>AddOption("wildchar", gettext("key that triggers command-line expansion"))
call append("$", " \tset wc=" . &wc)
call <SID>AddOption("wildcharm", gettext("like 'wildchar' but can also be used in a mapping"))
call append("$", " \tset wcm=" . &wcm)
call <SID>AddOption("wildmode", gettext("specifies how command line completion works"))
call <SID>OptionG("wim", &wim)
if has("wildoptions")
  call <SID>AddOption("wildoptions", gettext("empty or \"tagfile\" to list file name of matching tags"))
  call <SID>OptionG("wop", &wop)
endif
call <SID>AddOption("suffixes", gettext("list of file name extensions that have a lower priority"))
call <SID>OptionG("su", &su)
if has("file_in_path")
  call <SID>AddOption("suffixesadd", gettext("list of file name extensions added when searching for a file"))
  call append("$", "\t" .. s:local_to_buffer)
  call <SID>OptionL("sua")
endif
if has("wildignore")
  call <SID>AddOption("wildignore", gettext("list of patterns to ignore files for file name completion"))
  call <SID>OptionG("wig", &wig)
endif
call <SID>AddOption("fileignorecase", gettext("ignore case when using file names"))
call <SID>BinOptionG("fic", &fic)
call <SID>AddOption("wildignorecase", gettext("ignore case when completing file names"))
call <SID>BinOptionG("wic", &wic)
if has("wildmenu")
  call <SID>AddOption("wildmenu", gettext("command-line completion shows a list of matches"))
  call <SID>BinOptionG("wmnu", &wmnu)
endif
call <SID>AddOption("cedit", gettext("key used to open the command-line window"))
call <SID>OptionG("cedit", &cedit)
call <SID>AddOption("cmdwinheight", gettext("height of the command-line window"))
call <SID>OptionG("cwh", &cwh)


call <SID>Header(gettext("executing external commands"))
call <SID>AddOption("shell", gettext("name of the shell program used for external commands"))
call <SID>OptionG("sh", &sh)
if has("amiga")
  call <SID>AddOption("shelltype", gettext("when to use the shell or directly execute a command"))
  call append("$", " \tset st=" . &st)
endif
call <SID>AddOption("shellquote", gettext("character(s) to enclose a shell command in"))
call <SID>OptionG("shq", &shq)
call <SID>AddOption("shellxquote", gettext("like 'shellquote' but include the redirection"))
call <SID>OptionG("sxq", &sxq)
call <SID>AddOption("shellxescape", gettext("characters to escape when 'shellxquote' is ("))
call <SID>OptionG("sxe", &sxe)
call <SID>AddOption("shellcmdflag", gettext("argument for 'shell' to execute a command"))
call <SID>OptionG("shcf", &shcf)
call <SID>AddOption("shellredir", gettext("used to redirect command output to a file"))
call <SID>OptionG("srr", &srr)
call <SID>AddOption("shelltemp", gettext("use a temp file for shell commands instead of using a pipe"))
call <SID>BinOptionG("stmp", &stmp)
call <SID>AddOption("equalprg", gettext("program used for \"=\" command"))
call append("$", "\t" .. s:global_or_local)
call <SID>OptionG("ep", &ep)
call <SID>AddOption("formatprg", gettext("program used to format lines with \"gq\" command"))
call <SID>OptionG("fp", &fp)
call <SID>AddOption("keywordprg", gettext("program used for the \"K\" command"))
call <SID>OptionG("kp", &kp)
call <SID>AddOption("warn", gettext("warn when using a shell command and a buffer has changes"))
call <SID>BinOptionG("warn", &warn)


if has("quickfix")
  call <SID>Header(gettext("running make and jumping to errors (quickfix)"))
  call <SID>AddOption("errorfile", gettext("name of the file that contains error messages"))
  call <SID>OptionG("ef", &ef)
  call <SID>AddOption("errorformat", gettext("list of formats for error messages"))
  call append("$", "\t" .. s:global_or_local)
  call <SID>OptionG("efm", &efm)
  call <SID>AddOption("makeprg", gettext("program used for the \":make\" command"))
  call append("$", "\t" .. s:global_or_local)
  call <SID>OptionG("mp", &mp)
  call <SID>AddOption("shellpipe", gettext("string used to put the output of \":make\" in the error file"))
  call <SID>OptionG("sp", &sp)
  call <SID>AddOption("makeef", gettext("name of the errorfile for the 'makeprg' command"))
  call <SID>OptionG("mef", &mef)
  call <SID>AddOption("grepprg", gettext("program used for the \":grep\" command"))
  call append("$", "\t" .. s:global_or_local)
  call <SID>OptionG("gp", &gp)
  call <SID>AddOption("grepformat", gettext("list of formats for output of 'grepprg'"))
  call <SID>OptionG("gfm", &gfm)
  call <SID>AddOption("makeencoding", gettext("encoding of the \":make\" and \":grep\" output"))
  call append("$", "\t" .. s:global_or_local)
  call <SID>OptionG("menc", &menc)
  call <SID>AddOption("quickfixtextfunc", gettext("function to display text in the quickfix window"))
  call <SID>OptionG("qftf", &qftf)
endif


if has("win32")
  call <SID>Header(gettext("system specific"))
  call <SID>AddOption("shellslash", gettext("use forward slashes in file names; for Unix-like shells"))
  call <SID>BinOptionG("ssl", &ssl)
  call <SID>AddOption("completeslash", gettext("specifies slash/backslash used for completion"))
  call <SID>OptionG("csl", &csl)
endif


call <SID>Header(gettext("language specific"))
call <SID>AddOption("isfname", gettext("specifies the characters in a file name"))
call <SID>OptionG("isf", &isf)
call <SID>AddOption("isident", gettext("specifies the characters in an identifier"))
call <SID>OptionG("isi", &isi)
call <SID>AddOption("iskeyword", gettext("specifies the characters in a keyword"))
call append("$", "\t" .. s:local_to_buffer)
call <SID>OptionL("isk")
call <SID>AddOption("isprint", gettext("specifies printable characters"))
call <SID>OptionG("isp", &isp)
if has("textobjects")
  call <SID>AddOption("quoteescape", gettext("specifies escape characters in a string"))
  call append("$", "\t" .. s:local_to_buffer)
  call <SID>OptionL("qe")
endif
if has("rightleft")
  call <SID>AddOption("rightleft", gettext("display the buffer right-to-left"))
  call append("$", "\t" .. s:local_to_window)
  call <SID>BinOptionL("rl")
  call <SID>AddOption("rightleftcmd", gettext("when to edit the command-line right-to-left"))
  call append("$", "\t" .. s:local_to_window)
  call <SID>OptionL("rlc")
  call <SID>AddOption("revins", gettext("insert characters backwards"))
  call <SID>BinOptionG("ri", &ri)
  call <SID>AddOption("allowrevins", gettext("allow CTRL-_ in Insert and Command-line mode to toggle 'revins'"))
  call <SID>BinOptionG("ari", &ari)
  call <SID>AddOption("aleph", gettext("the ASCII code for the first letter of the Hebrew alphabet"))
  call append("$", " \tset al=" . &al)
  call <SID>AddOption("hkmap", gettext("use Hebrew keyboard mapping"))
  call <SID>BinOptionG("hk", &hk)
  call <SID>AddOption("hkmapp", gettext("use phonetic Hebrew keyboard mapping"))
  call <SID>BinOptionG("hkp", &hkp)
endif
if has("arabic")
  call <SID>AddOption("arabic", gettext("prepare for editing Arabic text"))
  call append("$", "\t" .. s:local_to_window)
  call <SID>BinOptionL("arab")
  call <SID>AddOption("arabicshape", gettext("perform shaping of Arabic characters"))
  call <SID>BinOptionG("arshape", &arshape)
  call <SID>AddOption("termbidi", gettext("terminal will perform bidi handling"))
  call <SID>BinOptionG("tbidi", &tbidi)
endif
if has("keymap")
  call <SID>AddOption("keymap", gettext("name of a keyboard mapping"))
  call <SID>OptionL("kmp")
endif
if has("langmap")
  call <SID>AddOption("langmap", gettext("list of characters that are translated in Normal mode"))
  call <SID>OptionG("lmap", &lmap)
  call <SID>AddOption("langremap", gettext("apply 'langmap' to mapped characters"))
  call <SID>BinOptionG("lrm", &lrm)
endif
if has("xim")
  call <SID>AddOption("imdisable", gettext("when set never use IM; overrules following IM options"))
  call <SID>BinOptionG("imd", &imd)
endif
call <SID>AddOption("iminsert", gettext("in Insert mode: 1: use :lmap; 2: use IM; 0: neither"))
call append("$", "\t" .. s:local_to_window)
call <SID>OptionL("imi")
call <SID>AddOption("imstyle", gettext("input method style, 0: on-the-spot, 1: over-the-spot"))
call <SID>OptionG("imst", &imst)
call <SID>AddOption("imsearch", gettext("entering a search pattern: 1: use :lmap; 2: use IM; 0: neither"))
call append("$", "\t" .. s:local_to_window)
call <SID>OptionL("ims")
if has("xim")
  call <SID>AddOption("imcmdline", gettext("when set always use IM when starting to edit a command line"))
  call <SID>BinOptionG("imc", &imc)
  call <SID>AddOption("imstatusfunc", gettext("function to obtain IME status"))
  call <SID>OptionG("imsf", &imsf)
  call <SID>AddOption("imactivatefunc", gettext("function to enable/disable IME"))
  call <SID>OptionG("imaf", &imaf)
endif


call <SID>Header(gettext("multi-byte characters"))
call <SID>AddOption("encoding", gettext("character encoding used in Vim: \"latin1\", \"utf-8\",\n\"euc-jp\", \"big5\", etc."))
call <SID>OptionG("enc", &enc)
call <SID>AddOption("fileencoding", gettext("character encoding for the current file"))
call append("$", "\t" .. s:local_to_buffer)
call <SID>OptionL("fenc")
call <SID>AddOption("fileencodings", gettext("automatically detected character encodings"))
call <SID>OptionG("fencs", &fencs)
call <SID>AddOption("termencoding", gettext("character encoding used by the terminal"))
call <SID>OptionG("tenc", &tenc)
call <SID>AddOption("charconvert", gettext("expression used for character encoding conversion"))
call <SID>OptionG("ccv", &ccv)
call <SID>AddOption("delcombine", gettext("delete combining (composing) characters on their own"))
call <SID>BinOptionG("deco", &deco)
call <SID>AddOption("maxcombine", gettext("maximum number of combining (composing) characters displayed"))
call <SID>OptionG("mco", &mco)
if has("xim") && has("gui_gtk")
  call <SID>AddOption("imactivatekey", gettext("key that activates the X input method"))
  call <SID>OptionG("imak", &imak)
endif
call <SID>AddOption("ambiwidth", gettext("width of ambiguous width characters"))
call <SID>OptionG("ambw", &ambw)
call <SID>AddOption("emoji", gettext("emoji characters are full width"))
call <SID>BinOptionG("emo", &emo)


call <SID>Header(gettext("various"))
call <SID>AddOption("virtualedit", gettext("when to use virtual editing: \"block\", \"insert\", \"all\"\nand/or \"onemore\""))
call <SID>OptionG("ve", &ve)
call <SID>AddOption("eventignore", gettext("list of autocommand events which are to be ignored"))
call <SID>OptionG("ei", &ei)
call <SID>AddOption("loadplugins", gettext("load plugin scripts when starting up"))
call <SID>BinOptionG("lpl", &lpl)
call <SID>AddOption("exrc", gettext("enable reading .vimrc/.exrc/.gvimrc in the current directory"))
call <SID>BinOptionG("ex", &ex)
call <SID>AddOption("secure", gettext("safer working with script files in the current directory"))
call <SID>BinOptionG("secure", &secure)
call <SID>AddOption("gdefault", gettext("use the 'g' flag for \":substitute\""))
call <SID>BinOptionG("gd", &gd)
call <SID>AddOption("edcompatible", gettext("'g' and 'c' flags of \":substitute\" toggle"))
call <SID>BinOptionG("ed", &ed)
if exists("+opendevice")
  call <SID>AddOption("opendevice", gettext("allow reading/writing devices"))
  call <SID>BinOptionG("odev", &odev)
endif
if exists("+maxfuncdepth")
  call <SID>AddOption("maxfuncdepth", gettext("maximum depth of function calls"))
  call append("$", " \tset mfd=" . &mfd)
endif
if has("mksession")
  call <SID>AddOption("sessionoptions", gettext("list of words that specifies what to put in a session file"))
  call <SID>OptionG("ssop", &ssop)
  call <SID>AddOption("viewoptions", gettext("list of words that specifies what to save for :mkview"))
  call <SID>OptionG("vop", &vop)
  call <SID>AddOption("viewdir", gettext("directory where to store files with :mkview"))
  call <SID>OptionG("vdir", &vdir)
endif
if has("viminfo")
  call <SID>AddOption("viminfo", gettext("list that specifies what to write in the viminfo file"))
  call <SID>OptionG("vi", &vi)
  call <SID>AddOption("viminfofile", gettext("file name used for the viminfo file"))
  call <SID>OptionG("vif", &vif)
endif
if has("quickfix")
  call <SID>AddOption("bufhidden", gettext("what happens with a buffer when it's no longer in a window"))
  call append("$", "\t" .. s:local_to_buffer)
  call <SID>OptionL("bh")
  call <SID>AddOption("buftype", gettext("empty, \"nofile\", \"nowrite\", \"quickfix\", etc.: type of buffer"))
  call append("$", "\t" .. s:local_to_buffer)
  call <SID>OptionL("bt")
endif
call <SID>AddOption("buflisted", gettext("whether the buffer shows up in the buffer list"))
call append("$", "\t" .. s:local_to_buffer)
call <SID>BinOptionL("bl")
call <SID>AddOption("debug", gettext("set to \"msg\" to see all error messages"))
call append("$", " \tset debug=" . &debug)
if has("signs")
  call <SID>AddOption("signcolumn", gettext("whether to show the signcolumn"))
  call append("$", "\t" .. s:local_to_window)
  call <SID>OptionL("scl")
endif
if has("mzscheme")
  call <SID>AddOption("mzquantum", gettext("interval in milliseconds between polls for MzScheme threads"))
  call append("$", " \tset mzq=" . &mzq)
endif
if exists("&luadll")
  call <SID>AddOption("luadll", gettext("name of the Lua dynamic library"))
  call <SID>OptionG("luadll", &luadll)
endif
if exists("&perldll")
  call <SID>AddOption("perldll", gettext("name of the Perl dynamic library"))
  call <SID>OptionG("perldll", &perldll)
endif
if has('pythonx')
  call <SID>AddOption("pyxversion", gettext("whether to use Python 2 or 3"))
  call append("$", " \tset pyx=" . &wd)
endif
if exists("&pythondll")
  call <SID>AddOption("pythondll", gettext("name of the Python 2 dynamic library"))
  call <SID>OptionG("pythondll", &pythondll)
endif
if exists("&pythonhome")
  call <SID>AddOption("pythonhome", gettext("name of the Python 2 home directory"))
  call <SID>OptionG("pythonhome", &pythonhome)
endif
if exists("&pythonthreedll")
  call <SID>AddOption("pythonthreedll", gettext("name of the Python 3 dynamic library"))
  call <SID>OptionG("pythonthreedll", &pythonthreedll)
endif
if exists("&pythonthreehome")
  call <SID>AddOption("pythonthreehome", gettext("name of the Python 3 home directory"))
  call <SID>OptionG("pythonthreehome", &pythonthreehome)
endif
if exists("&rubydll")
  call <SID>AddOption("rubydll", gettext("name of the Ruby dynamic library"))
  call <SID>OptionG("rubydll", &rubydll)
endif
if exists("&tcldll")
  call <SID>AddOption("tcldll", gettext("name of the Tcl dynamic library"))
  call <SID>OptionG("tcldll", &tcldll)
endif
if exists("&mzschemedll")
  call <SID>AddOption("mzschemedll", gettext("name of the MzScheme dynamic library"))
  call <SID>OptionG("mzschemedll", &mzschemedll)
  call <SID>AddOption("mzschemegcdll", gettext("name of the MzScheme GC dynamic library"))
  call <SID>OptionG("mzschemegcdll", &mzschemegcdll)
endif

set cpo&vim

" go to first line
1

" reset 'modified', so that ":q" can be used to close the window
setlocal nomodified

if has("syntax")
  " Use Vim highlighting, with some additional stuff
  setlocal ft=vim
  syn match optwinHeader "^ \=[0-9].*"
  syn match optwinName "^[a-z]*\t" nextgroup=optwinComment
  syn match optwinComment ".*" contained
  syn match optwinComment "^\t.*"
  if !exists("did_optwin_syntax_inits")
    let did_optwin_syntax_inits = 1
    hi link optwinHeader Title
    hi link optwinName Identifier
    hi link optwinComment Comment
  endif
endif

" Install autocommands to enable mappings in option-window
noremap <silent> <buffer> <CR> <C-\><C-N>:call <SID>CR()<CR>
inoremap <silent> <buffer> <CR> <Esc>:call <SID>CR()<CR>
noremap <silent> <buffer> <Space> :call <SID>Space()<CR>

" Make the buffer be deleted when the window is closed.
setlocal buftype=nofile bufhidden=delete noswapfile

augroup optwin
  au! BufUnload,BufHidden option-window nested
	\ call <SID>unload() | delfun <SID>unload
augroup END

func <SID>unload()
  delfun <SID>CR
  delfun <SID>Space
  delfun <SID>Find
  delfun <SID>Update
  delfun <SID>OptionL
  delfun <SID>OptionG
  delfun <SID>BinOptionL
  delfun <SID>BinOptionG
  delfun <SID>Header
  au! optwin
endfunc

" Restore the previous value of 'title' and 'icon'.
let &title = s:old_title
let &icon = s:old_icon
let &ru = s:old_ru
let &sc = s:old_sc
let &cpo = s:cpo_save
let &ul = s:old_ul
unlet s:old_title s:old_icon s:old_ru s:old_sc s:cpo_save s:idx s:lnum s:old_ul

" vim: ts=8 sw=2 sts=2
                                                                                                                                                                                       usr/share/vim/vim90/pack/                                                                           0000755 0000000 0000000 00000000000 14723046434 013643  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/vim/vim90/pack/dist/                                                                      0000755 0000000 0000000 00000000000 14723046434 014606  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/vim/vim90/pack/dist/opt/                                                                  0000755 0000000 0000000 00000000000 14723046434 015410  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/vim/vim90/pack/dist/opt/cfilter/                                                          0000755 0000000 0000000 00000000000 14723046434 017040  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/vim/vim90/pack/dist/opt/cfilter/plugin/                                                   0000755 0000000 0000000 00000000000 14723046434 020336  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/vim/vim90/pack/dist/opt/cfilter/plugin/cfilter.vim                                        0000644 0000000 0000000 00000004023 14424703754 022505  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        vim9script

# cfilter.vim: Plugin to filter entries from a quickfix/location list
# Last Change: Jun 30, 2022
# Maintainer: Yegappan Lakshmanan (yegappan AT yahoo DOT com)
# Version: 2.0
#
# Commands to filter the quickfix list:
#   :Cfilter[!] /{pat}/
#       Create a new quickfix list from entries matching {pat} in the current
#       quickfix list. Both the file name and the text of the entries are
#       matched against {pat}. If ! is supplied, then entries not matching
#       {pat} are used. The pattern can be optionally enclosed using one of
#       the following characters: ', ", /. If the pattern is empty, then the
#       last used search pattern is used.
#   :Lfilter[!] /{pat}/
#       Same as :Cfilter but operates on the current location list.
#

def Qf_filter(qf: bool, searchpat: string, bang: string)
  var Xgetlist: func
  var Xsetlist: func
  var cmd: string
  var firstchar: string
  var lastchar: string
  var pat: string
  var title: string
  var Cond: func
  var items: list<any>

  if qf
    Xgetlist = function('getqflist')
    Xsetlist = function('setqflist')
    cmd = ':Cfilter' .. bang
  else
    Xgetlist = function('getloclist', [0])
    Xsetlist = function('setloclist', [0])
    cmd = ':Lfilter' .. bang
  endif

  firstchar = searchpat[0]
  lastchar = searchpat[-1 :]
  if firstchar == lastchar &&
              (firstchar == '/' || firstchar == '"' || firstchar == "'")
    pat = searchpat[1 : -2]
    if pat == ''
      # Use the last search pattern
      pat = @/
    endif
  else
    pat = searchpat
  endif

  if pat == ''
    return
  endif

  if bang == '!'
    Cond = (_, val) => val.text !~# pat && bufname(val.bufnr) !~# pat
  else
    Cond = (_, val) => val.text =~# pat || bufname(val.bufnr) =~# pat
  endif

  items = filter(Xgetlist(), Cond)
  title = cmd .. ' /' .. pat .. '/'
  Xsetlist([], ' ', {title: title, items: items})
enddef

command! -nargs=+ -bang Cfilter Qf_filter(true, <q-args>, <q-bang>)
command! -nargs=+ -bang Lfilter Qf_filter(false, <q-args>, <q-bang>)

# vim: shiftwidth=2 sts=2 expandtab
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             usr/share/vim/vim90/pack/dist/opt/dvorak/                                                           0000755 0000000 0000000 00000000000 14723046434 016676  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/vim/vim90/pack/dist/opt/dvorak/dvorak/                                                    0000755 0000000 0000000 00000000000 14723046434 020164  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/vim/vim90/pack/dist/opt/dvorak/dvorak/disable.vim                                         0000644 0000000 0000000 00000001245 14424703754 022311  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Back to Qwerty keyboard after using Dvorak.

iunmap a
iunmap b
iunmap c
iunmap d
iunmap e
iunmap f
iunmap g
iunmap h
iunmap i
iunmap j
iunmap k
iunmap l
iunmap m
iunmap n
iunmap o
iunmap p
iunmap q
iunmap r
iunmap s
iunmap t
iunmap u
iunmap v
iunmap w
iunmap x
iunmap y
iunmap z
iunmap ;
iunmap '
iunmap "
iunmap ,
iunmap .
iunmap /
iunmap A
iunmap B
iunmap C
iunmap D
iunmap E
iunmap F
iunmap G
iunmap H
iunmap I
iunmap J
iunmap K
iunmap L
iunmap M
iunmap N
iunmap O
iunmap P
iunmap Q
iunmap R
iunmap S
iunmap T
iunmap U
iunmap V
iunmap W
iunmap X
iunmap Y
iunmap Z
iunmap <
iunmap >
iunmap ?
iunmap :
iunmap [
iunmap ]
iunmap {
iunmap }
iunmap -
iunmap _
iunmap =
iunmap +
                                                                                                                                                                                                                                                                                                                                                           usr/share/vim/vim90/pack/dist/opt/dvorak/dvorak/enable.vim                                          0000644 0000000 0000000 00000002122 14424703754 022127  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Dvorak keyboard, only in Insert mode.
"
" Change "inoremap" to "map!" to also use in Ex mode.
" Also change disable.vim then: "iunmap" to "unmap!".
"
" You may want to add a list of map's too.

inoremap a a
inoremap b x
inoremap c j
inoremap d e
inoremap e .
inoremap f u
inoremap g i
inoremap h d
inoremap i c
inoremap j h
inoremap k t
inoremap l n
inoremap m m
inoremap n b
inoremap o r
inoremap p l
inoremap q '
inoremap r p
inoremap s o
inoremap t y
inoremap u g
inoremap v k
inoremap w ,
inoremap x q
inoremap y f
inoremap z ;
inoremap ; s
inoremap ' -
inoremap " _
inoremap , w
inoremap . v
inoremap / z
inoremap A A
inoremap B X
inoremap C J
inoremap D E
inoremap E >
inoremap F U
inoremap G I
inoremap H D
inoremap I C
inoremap J H
inoremap K T
inoremap L N
inoremap M M
inoremap N B
inoremap O R
inoremap P L
inoremap Q "
inoremap R P
inoremap S O
inoremap T Y
inoremap U G
inoremap V K
inoremap W <
inoremap X Q
inoremap Y F
inoremap Z :
inoremap < W
inoremap > V
inoremap ? Z
inoremap : S
inoremap [ /
inoremap ] =
inoremap { ?
inoremap } +
inoremap - [
inoremap _ {
inoremap = ]
inoremap + }
                                                                                                                                                                                                                                                                                                                                                                                                                                              usr/share/vim/vim90/pack/dist/opt/dvorak/plugin/                                                    0000755 0000000 0000000 00000000000 14723046434 020174  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/vim/vim90/pack/dist/opt/dvorak/plugin/dvorak.vim                                          0000644 0000000 0000000 00000001001 14424703754 022172  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " When using a dvorak keyboard this file may be of help to you.
" These mappings have been made by Lawrence Kesteloot <kesteloo@cs.unc.edu>.
" What they do is that the most often used keys, like hjkl, are put in a more
" easy to use position.
" It may take some time to learn using this.

if exists("g:loaded_dvorak_plugin")
  finish
endif
let g:loaded_dvorak_plugin = 1

" Key to go into dvorak mode:
map ,d :runtime dvorak/enable.vim<CR>

" Key to get out of dvorak mode:
map ,q :runtime dvorak/disable.vim<CR>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               usr/share/vim/vim90/pack/dist/opt/editexisting/                                                     0000755 0000000 0000000 00000000000 14723046434 020110  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/vim/vim90/pack/dist/opt/editexisting/plugin/                                              0000755 0000000 0000000 00000000000 14723046434 021406  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/vim/vim90/pack/dist/opt/editexisting/plugin/editexisting.vim                              0000644 0000000 0000000 00000007070 14424703754 024632  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim Plugin:	Edit the file with an existing Vim if possible
" Maintainer:	Bram Moolenaar
" Last Change:	2022 Jun 17

" To use add ":packadd! editexisting" in your vimrc file.

" This plugin serves two purposes:
" 1. On startup, if we were invoked with one file name argument and the file
"    is not modified then try to find another Vim instance that is editing
"    this file.  If there is one then bring it to the foreground and exit.
" 2. When a file is edited and a swap file exists for it, try finding that
"    other Vim and bring it to the foreground.  Requires Vim 7, because it
"    uses the SwapExists autocommand event.

" Function that finds the Vim instance that is editing "filename" and brings
" it to the foreground.
func s:EditElsewhere(filename)
  let fname_esc = substitute(a:filename, "'", "''", "g")

  let servers = serverlist()
  while servers != ''
    " Get next server name in "servername"; remove it from "servers".
    let i = match(servers, "\n")
    if i == -1
      let servername = servers
      let servers = ''
    else
      let servername = strpart(servers, 0, i)
      let servers = strpart(servers, i + 1)
    endif

    " Skip ourselves.
    if servername ==? v:servername
      continue
    endif

    " Check if this server is editing our file.
    try
      if remote_expr(servername, "bufloaded('" . fname_esc . "')")
	" Yes, bring it to the foreground.
	if has("win32")
	  call remote_foreground(servername)
	endif
	call remote_expr(servername, "foreground()")

	if remote_expr(servername, "exists('*EditExisting')")
	  " Make sure the file is visible in a window (not hidden).
	  " If v:swapcommand exists and is set, send it to the server.
	  if exists("v:swapcommand")
	    let c = substitute(v:swapcommand, "'", "''", "g")
	    call remote_expr(servername, "EditExisting('" . fname_esc . "', '" . c . "')")
	  else
	    call remote_expr(servername, "EditExisting('" . fname_esc . "', '')")
	  endif
	endif

	if !(has('vim_starting') && has('gui_running') && has('gui_win32'))
	  " Tell the user what is happening.  Not when the GUI is starting
	  " though, it would result in a message box.
	  echomsg "File is being edited by " . servername
	  sleep 2
	endif
	return 'q'
      endif
    catch /^Vim\%((\a\+)\)\=:E241:/
      " Unable to send to this server, ignore it.
    endtry
  endwhile
  return ''
endfunc

" When the plugin is loaded and there is one file name argument: Find another
" Vim server that is editing this file right now.
if argc() == 1 && !&modified
  if s:EditElsewhere(expand("%:p")) == 'q'
    quit
  endif
endif

" Setup for handling the situation that an existing swap file is found.
try
  au! SwapExists * let v:swapchoice = s:EditElsewhere(expand("<afile>:p"))
catch
  " Without SwapExists we don't do anything for ":edit" commands
endtry

" Function used on the server to make the file visible and possibly execute a
" command.
func! EditExisting(fname, command)
  " Get the window number of the file in the current tab page.
  let winnr = bufwinnr(a:fname)
  if winnr <= 0
    " Not found, look in other tab pages.
    let bufnr = bufnr(a:fname)
    for i in range(tabpagenr('$'))
      if index(tabpagebuflist(i + 1), bufnr) >= 0
	" Make this tab page the current one and find the window number.
	exe 'tabnext ' . (i + 1)
	let winnr = bufwinnr(a:fname)
	break
      endif
    endfor
  endif

  if winnr > 0
    exe winnr . "wincmd w"
  elseif exists('*fnameescape')
    exe "split " . fnameescape(a:fname)
  else
    exe "split " . escape(a:fname, " \t\n*?[{`$\\%#'\"|!<")
  endif

  if a:command != ''
    exe "normal! " . a:command
  endif

  redraw
endfunc
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        usr/share/vim/vim90/pack/dist/opt/justify/                                                          0000755 0000000 0000000 00000000000 14723046434 017105  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/vim/vim90/pack/dist/opt/justify/plugin/                                                   0000755 0000000 0000000 00000000000 14723046434 020403  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/vim/vim90/pack/dist/opt/justify/plugin/justify.vim                                        0000644 0000000 0000000 00000021710 14424703754 022621  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Function to left and right align text.
"
" Written by:	Preben "Peppe" Guldberg <c928400@student.dtu.dk>
" Created:	980806 14:13 (or around that time anyway)
" Revised:	001103 00:36 (See "Revisions" below)


" function Justify( [ textwidth [, maxspaces [, indent] ] ] )
"
" Justify()  will  left  and  right  align  a  line  by  filling  in  an
" appropriate amount of spaces.  Extra  spaces  are  added  to  existing
" spaces starting from the right side of the line.  As an  example,  the
" following documentation has been justified.
"
" The function takes the following arguments:

" textwidth argument
" ------------------
" If not specified, the value of the 'textwidth'  option  is  used.   If
" 'textwidth' is zero a value of 80 is used.
"
" Additionally the arguments 'tw' and '' are  accepted.   The  value  of
" 'textwidth' will be used. These are handy, if you just want to specify
" the maxspaces argument.

" maxspaces argument
" ------------------
" If specified, alignment will only be done, if the  longest  space  run
" after alignment is no longer than maxspaces.
"
" An argument of '' is accepted, should the user  like  to  specify  all
" arguments.
"
" To aid user defined commands, negative  values  are  accepted  aswell.
" Using a negative value specifies the default behaviour: any length  of
" space runs will be used to justify the text.

" indent argument
" ---------------
" This argument specifies how a line should be indented. The default  is
" to keep the current indentation.
"
" Negative  values:  Keep  current   amount   of   leading   whitespace.
" Positive values: Indent all lines with leading whitespace  using  this
" amount of whitespace.
"
" Note that the value 0, needs to be quoted as  a  string.   This  value
" leads to a left flushed text.
"
" Additionally units of  'shiftwidth'/'sw'  and  'tabstop'/'ts'  may  be
" added. In this case, if the value of indent is positive, the amount of
" whitespace to be  added  will  be  multiplied  by  the  value  of  the
" 'shiftwidth' and 'tabstop' settings.  If these  units  are  used,  the
"  argument must  be  given  as  a  string,  eg.   Justify('','','2sw').
"
" If the values of 'sw' or 'tw' are negative, they  are  treated  as  if
" they were 0, which means that the text is flushed left.  There  is  no
" check if a negative number prefix is used to  change  the  sign  of  a
" negative 'sw' or 'ts' value.
"
" As with the other arguments,  ''  may  be  used  to  get  the  default
" behaviour.


" Notes:
"
" If the line, adjusted for space runs and leading/trailing  whitespace,
" is wider than the used textwidth, the line will be left untouched  (no
" whitespace removed).  This should be equivalent to  the  behaviour  of
" :left, :right and :center.
"
" If the resulting line is shorter than the used textwidth  it  is  left
" untouched.
"
" All space runs in the line  are  truncated  before  the  alignment  is
" carried out.
"
" If you have set 'noexpandtab', :retab!  is used to replace space  runs
"  with whitespace  using  the  value  of  'tabstop'.   This  should  be
" conformant with :left, :right and :center.
"
" If joinspaces is set, an extra space is added after '.', '?' and  '!'.
" If 'cpooptions' include 'j', extra space  is  only  added  after  '.'.
" (This may on occasion conflict with maxspaces.)


" Related mappings:
"
" Mappings that will align text using the current text width,  using  at
" most four spaces in a  space  run  and  keeping  current  indentation.
nmap _j :%call Justify('tw',4)<CR>
vmap _j :call Justify('tw',4)<CR>
"
" Mappings that will remove space runs and format lines (might be useful
" prior to aligning the text).
nmap ,gq :%s/\s\+/ /g<CR>gq1G
vmap ,gq :s/\s\+/ /g<CR>gvgq


" User defined command:
"
" The following is an ex command that works as a shortcut to the Justify
" function.  Arguments to Justify() can  be  added  after  the  command.
com! -range -nargs=* Justify <line1>,<line2>call Justify(<f-args>)
"
" The following commands are all equivalent:
"
" 1. Simplest use of Justify():
"       :call Justify()
"       :Justify
"
" 2. The _j mapping above via the ex command:
"       :%Justify tw 4
"
" 3.  Justify  visualised  text  at  72nd  column  while  indenting  all
" previously indented text two shiftwidths
"       :'<,'>call Justify(72,'','2sw')
"       :'<,'>Justify 72 -1 2sw
"
" This documentation has been justified  using  the  following  command:
":se et|kz|1;/^" function Justify(/+,'z-g/^" /s/^" //|call Justify(70,3)|s/^/" /

" Revisions:
" 001103: If 'joinspaces' was set, calculations could be wrong.
"	  Tabs at start of line could also lead to errors.
"	  Use setline() instead of "exec 's/foo/bar/' - safer.
"	  Cleaned up the code a bit.
"
