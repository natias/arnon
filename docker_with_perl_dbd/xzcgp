11C4  ; [.18EB.0020.0002.11C4] # HANGUL JONGSEONG KIYEOK-SIOS-KIYEOK
11C5  ; [.18EC.0020.0002.11C5] # HANGUL JONGSEONG NIEUN-KIYEOK
11C6  ; [.18ED.0020.0002.11C6] # HANGUL JONGSEONG NIEUN-TIKEUT
11C7  ; [.18EE.0020.0002.11C7] # HANGUL JONGSEONG NIEUN-SIOS
11C8  ; [.18EF.0020.0002.11C8] # HANGUL JONGSEONG NIEUN-PANSIOS
11C9  ; [.18F0.0020.0002.11C9] # HANGUL JONGSEONG NIEUN-THIEUTH
11CA  ; [.18F1.0020.0002.11CA] # HANGUL JONGSEONG TIKEUT-KIYEOK
11CB  ; [.18F2.0020.0002.11CB] # HANGUL JONGSEONG TIKEUT-RIEUL
11CC  ; [.18F3.0020.0002.11CC] # HANGUL JONGSEONG RIEUL-KIYEOK-SIOS
11CD  ; [.18F4.0020.0002.11CD] # HANGUL JONGSEONG RIEUL-NIEUN
11CE  ; [.18F5.0020.0002.11CE] # HANGUL JONGSEONG RIEUL-TIKEUT
11CF  ; [.18F6.0020.0002.11CF] # HANGUL JONGSEONG RIEUL-TIKEUT-HIEUH
11D0  ; [.18F7.0020.0002.11D0] # HANGUL JONGSEONG SSANGRIEUL
11D1  ; [.18F8.0020.0002.11D1] # HANGUL JONGSEONG RIEUL-MIEUM-KIYEOK
11D2  ; [.18F9.0020.0002.11D2] # HANGUL JONGSEONG RIEUL-MIEUM-SIOS
11D3  ; [.18FA.0020.0002.11D3] # HANGUL JONGSEONG RIEUL-PIEUP-SIOS
11D4  ; [.18FB.0020.0002.11D4] # HANGUL JONGSEONG RIEUL-PIEUP-HIEUH
11D5  ; [.18FC.0020.0002.11D5] # HANGUL JONGSEONG RIEUL-KAPYEOUNPIEUP
11D6  ; [.18FD.0020.0002.11D6] # HANGUL JONGSEONG RIEUL-SSANGSIOS
11D7  ; [.18FE.0020.0002.11D7] # HANGUL JONGSEONG RIEUL-PANSIOS
11D8  ; [.18FF.0020.0002.11D8] # HANGUL JONGSEONG RIEUL-KHIEUKH
11D9  ; [.1900.0020.0002.11D9] # HANGUL JONGSEONG RIEUL-YEORINHIEUH
11DA  ; [.1901.0020.0002.11DA] # HANGUL JONGSEONG MIEUM-KIYEOK
11DB  ; [.1902.0020.0002.11DB] # HANGUL JONGSEONG MIEUM-RIEUL
11DC  ; [.1903.0020.0002.11DC] # HANGUL JONGSEONG MIEUM-PIEUP
11DD  ; [.1904.0020.0002.11DD] # HANGUL JONGSEONG MIEUM-SIOS
11DE  ; [.1905.0020.0002.11DE] # HANGUL JONGSEONG MIEUM-SSANGSIOS
11DF  ; [.1906.0020.0002.11DF] # HANGUL JONGSEONG MIEUM-PANSIOS
11E0  ; [.1907.0020.0002.11E0] # HANGUL JONGSEONG MIEUM-CHIEUCH
11E1  ; [.1908.0020.0002.11E1] # HANGUL JONGSEONG MIEUM-HIEUH
11E2  ; [.1909.0020.0002.11E2] # HANGUL JONGSEONG KAPYEOUNMIEUM
11E3  ; [.190A.0020.0002.11E3] # HANGUL JONGSEONG PIEUP-RIEUL
11E4  ; [.190B.0020.0002.11E4] # HANGUL JONGSEONG PIEUP-PHIEUPH
11E5  ; [.190C.0020.0002.11E5] # HANGUL JONGSEONG PIEUP-HIEUH
11E6  ; [.190D.0020.0002.11E6] # HANGUL JONGSEONG KAPYEOUNPIEUP
11E7  ; [.190E.0020.0002.11E7] # HANGUL JONGSEONG SIOS-KIYEOK
11E8  ; [.190F.0020.0002.11E8] # HANGUL JONGSEONG SIOS-TIKEUT
11E9  ; [.1910.0020.0002.11E9] # HANGUL JONGSEONG SIOS-RIEUL
11EA  ; [.1911.0020.0002.11EA] # HANGUL JONGSEONG SIOS-PIEUP
11EB  ; [.1912.0020.0002.11EB] # HANGUL JONGSEONG PANSIOS
11EC  ; [.1913.0020.0002.11EC] # HANGUL JONGSEONG IEUNG-KIYEOK
11ED  ; [.1914.0020.0002.11ED] # HANGUL JONGSEONG IEUNG-SSANGKIYEOK
11EE  ; [.1915.0020.0002.11EE] # HANGUL JONGSEONG SSANGIEUNG
11EF  ; [.1916.0020.0002.11EF] # HANGUL JONGSEONG IEUNG-KHIEUKH
11F0  ; [.1917.0020.0002.11F0] # HANGUL JONGSEONG YESIEUNG
11F1  ; [.1918.0020.0002.11F1] # HANGUL JONGSEONG YESIEUNG-SIOS
11F2  ; [.1919.0020.0002.11F2] # HANGUL JONGSEONG YESIEUNG-PANSIOS
11F3  ; [.191A.0020.0002.11F3] # HANGUL JONGSEONG PHIEUPH-PIEUP
11F4  ; [.191B.0020.0002.11F4] # HANGUL JONGSEONG KAPYEOUNPHIEUPH
11F5  ; [.191C.0020.0002.11F5] # HANGUL JONGSEONG HIEUH-NIEUN
11F6  ; [.191D.0020.0002.11F6] # HANGUL JONGSEONG HIEUH-RIEUL
11F7  ; [.191E.0020.0002.11F7] # HANGUL JONGSEONG HIEUH-MIEUM
11F8  ; [.191F.0020.0002.11F8] # HANGUL JONGSEONG HIEUH-PIEUP
11F9  ; [.1920.0020.0002.11F9] # HANGUL JONGSEONG YEORINHIEUH
3041  ; [.1921.0020.000D.3041] # HIRAGANA LETTER SMALL A
3042  ; [.1921.0020.000E.3042] # HIRAGANA LETTER A
30A1  ; [.1921.0020.000F.30A1] # KATAKANA LETTER SMALL A
30A2  ; [.1921.0020.0011.30A2] # KATAKANA LETTER A
3043  ; [.1922.0020.000D.3043] # HIRAGANA LETTER SMALL I
3044  ; [.1922.0020.000E.3044] # HIRAGANA LETTER I
30A3  ; [.1922.0020.000F.30A3] # KATAKANA LETTER SMALL I
30A4  ; [.1922.0020.0011.30A4] # KATAKANA LETTER I
3045  ; [.1923.0020.000D.3045] # HIRAGANA LETTER SMALL U
3046  ; [.1923.0020.000E.3046] # HIRAGANA LETTER U
30A5  ; [.1923.0020.000F.30A5] # KATAKANA LETTER SMALL U
30A6  ; [.1923.0020.0011.30A6] # KATAKANA LETTER U
3094  ; [.1923.0020.000E.3046][.0000.013D.0002.3099] # HIRAGANA LETTER VU; QQCM
30F4  ; [.1923.0020.0011.30A6][.0000.013D.0002.3099] # KATAKANA LETTER VU; QQCM
3047  ; [.1924.0020.000D.3047] # HIRAGANA LETTER SMALL E
3048  ; [.1924.0020.000E.3048] # HIRAGANA LETTER E
30A7  ; [.1924.0020.000F.30A7] # KATAKANA LETTER SMALL E
30A8  ; [.1924.0020.0011.30A8] # KATAKANA LETTER E
3049  ; [.1925.0020.000D.3049] # HIRAGANA LETTER SMALL O
304A  ; [.1925.0020.000E.304A] # HIRAGANA LETTER O
30A9  ; [.1925.0020.000F.30A9] # KATAKANA LETTER SMALL O
30AA  ; [.1925.0020.0011.30AA] # KATAKANA LETTER O
304B  ; [.1926.0020.000E.304B] # HIRAGANA LETTER KA
30F5  ; [.1926.0020.000F.30F5] # KATAKANA LETTER SMALL KA
30AB  ; [.1926.0020.0011.30AB] # KATAKANA LETTER KA
304C  ; [.1926.0020.000E.304B][.0000.013D.0002.3099] # HIRAGANA LETTER GA; QQCM
30AC  ; [.1926.0020.0011.30AB][.0000.013D.0002.3099] # KATAKANA LETTER GA; QQCM
304D  ; [.1927.0020.000E.304D] # HIRAGANA LETTER KI
30AD  ; [.1927.0020.0011.30AD] # KATAKANA LETTER KI
304E  ; [.1927.0020.000E.304D][.0000.013D.0002.3099] # HIRAGANA LETTER GI; QQCM
30AE  ; [.1927.0020.0011.30AD][.0000.013D.0002.3099] # KATAKANA LETTER GI; QQCM
304F  ; [.1928.0020.000E.304F] # HIRAGANA LETTER KU
30AF  ; [.1928.0020.0011.30AF] # KATAKANA LETTER KU
3050  ; [.1928.0020.000E.304F][.0000.013D.0002.3099] # HIRAGANA LETTER GU; QQCM
30B0  ; [.1928.0020.0011.30AF][.0000.013D.0002.3099] # KATAKANA LETTER GU; QQCM
3051  ; [.1929.0020.000E.3051] # HIRAGANA LETTER KE
30F6  ; [.1929.0020.000F.30F6] # KATAKANA LETTER SMALL KE
30B1  ; [.1929.0020.0011.30B1] # KATAKANA LETTER KE
3052  ; [.1929.0020.000E.3051][.0000.013D.0002.3099] # HIRAGANA LETTER GE; QQCM
30B2  ; [.1929.0020.0011.30B1][.0000.013D.0002.3099] # KATAKANA LETTER GE; QQCM
3053  ; [.192A.0020.000E.3053] # HIRAGANA LETTER KO
30B3  ; [.192A.0020.0011.30B3] # KATAKANA LETTER KO
3054  ; [.192A.0020.000E.3053][.0000.013D.0002.3099] # HIRAGANA LETTER GO; QQCM
30B4  ; [.192A.0020.0011.30B3][.0000.013D.0002.3099] # KATAKANA LETTER GO; QQCM
3055  ; [.192B.0020.000E.3055] # HIRAGANA LETTER SA
30B5  ; [.192B.0020.0011.30B5] # KATAKANA LETTER SA
3056  ; [.192B.0020.000E.3055][.0000.013D.0002.3099] # HIRAGANA LETTER ZA; QQCM
30B6  ; [.192B.0020.0011.30B5][.0000.013D.0002.3099] # KATAKANA LETTER ZA; QQCM
3057  ; [.192C.0020.000E.3057] # HIRAGANA LETTER SI
30B7  ; [.192C.0020.0011.30B7] # KATAKANA LETTER SI
3058  ; [.192C.0020.000E.3057][.0000.013D.0002.3099] # HIRAGANA LETTER ZI; QQCM
30B8  ; [.192C.0020.0011.30B7][.0000.013D.0002.3099] # KATAKANA LETTER ZI; QQCM
3059  ; [.192D.0020.000E.3059] # HIRAGANA LETTER SU
30B9  ; [.192D.0020.0011.30B9] # KATAKANA LETTER SU
305A  ; [.192D.0020.000E.3059][.0000.013D.0002.3099] # HIRAGANA LETTER ZU; QQCM
30BA  ; [.192D.0020.0011.30B9][.0000.013D.0002.3099] # KATAKANA LETTER ZU; QQCM
305B  ; [.192E.0020.000E.305B] # HIRAGANA LETTER SE
30BB  ; [.192E.0020.0011.30BB] # KATAKANA LETTER SE
305C  ; [.192E.0020.000E.305B][.0000.013D.0002.3099] # HIRAGANA LETTER ZE; QQCM
30BC  ; [.192E.0020.0011.30BB][.0000.013D.0002.3099] # KATAKANA LETTER ZE; QQCM
305D  ; [.192F.0020.000E.305D] # HIRAGANA LETTER SO
30BD  ; [.192F.0020.0011.30BD] # KATAKANA LETTER SO
305E  ; [.192F.0020.000E.305D][.0000.013D.0002.3099] # HIRAGANA LETTER ZO; QQCM
30BE  ; [.192F.0020.0011.30BD][.0000.013D.0002.3099] # KATAKANA LETTER ZO; QQCM
305F  ; [.1930.0020.000E.305F] # HIRAGANA LETTER TA
30BF  ; [.1930.0020.0011.30BF] # KATAKANA LETTER TA
3060  ; [.1930.0020.000E.305F][.0000.013D.0002.3099] # HIRAGANA LETTER DA; QQCM
30C0  ; [.1930.0020.0011.30BF][.0000.013D.0002.3099] # KATAKANA LETTER DA; QQCM
3061  ; [.1931.0020.000E.3061] # HIRAGANA LETTER TI
30C1  ; [.1931.0020.0011.30C1] # KATAKANA LETTER TI
3062  ; [.1931.0020.000E.3061][.0000.013D.0002.3099] # HIRAGANA LETTER DI; QQCM
30C2  ; [.1931.0020.0011.30C1][.0000.013D.0002.3099] # KATAKANA LETTER DI; QQCM
3063  ; [.1932.0020.000D.3063] # HIRAGANA LETTER SMALL TU
3064  ; [.1932.0020.000E.3064] # HIRAGANA LETTER TU
30C3  ; [.1932.0020.000F.30C3] # KATAKANA LETTER SMALL TU
30C4  ; [.1932.0020.0011.30C4] # KATAKANA LETTER TU
3065  ; [.1932.0020.000E.3064][.0000.013D.0002.3099] # HIRAGANA LETTER DU; QQCM
30C5  ; [.1932.0020.0011.30C4][.0000.013D.0002.3099] # KATAKANA LETTER DU; QQCM
3066  ; [.1933.0020.000E.3066] # HIRAGANA LETTER TE
30C6  ; [.1933.0020.0011.30C6] # KATAKANA LETTER TE
3067  ; [.1933.0020.000E.3066][.0000.013D.0002.3099] # HIRAGANA LETTER DE; QQCM
30C7  ; [.1933.0020.0011.30C6][.0000.013D.0002.3099] # KATAKANA LETTER DE; QQCM
3068  ; [.1934.0020.000E.3068] # HIRAGANA LETTER TO
30C8  ; [.1934.0020.0011.30C8] # KATAKANA LETTER TO
3069  ; [.1934.0020.000E.3068][.0000.013D.0002.3099] # HIRAGANA LETTER DO; QQCM
30C9  ; [.1934.0020.0011.30C8][.0000.013D.0002.3099] # KATAKANA LETTER DO; QQCM
306A  ; [.1935.0020.000E.306A] # HIRAGANA LETTER NA
30CA  ; [.1935.0020.0011.30CA] # KATAKANA LETTER NA
306B  ; [.1936.0020.000E.306B] # HIRAGANA LETTER NI
30CB  ; [.1936.0020.0011.30CB] # KATAKANA LETTER NI
306C  ; [.1937.0020.000E.306C] # HIRAGANA LETTER NU
30CC  ; [.1937.0020.0011.30CC] # KATAKANA LETTER NU
306D  ; [.1938.0020.000E.306D] # HIRAGANA LETTER NE
30CD  ; [.1938.0020.0011.30CD] # KATAKANA LETTER NE
306E  ; [.1939.0020.000E.306E] # HIRAGANA LETTER NO
30CE  ; [.1939.0020.0011.30CE] # KATAKANA LETTER NO
306F  ; [.193A.0020.000E.306F] # HIRAGANA LETTER HA
30CF  ; [.193A.0020.0011.30CF] # KATAKANA LETTER HA
3070  ; [.193A.0020.000E.306F][.0000.013D.0002.3099] # HIRAGANA LETTER BA; QQCM
30D0  ; [.193A.0020.0011.30CF][.0000.013D.0002.3099] # KATAKANA LETTER BA; QQCM
3071  ; [.193A.0020.000E.306F][.0000.013E.0002.309A] # HIRAGANA LETTER PA; QQCM
30D1  ; [.193A.0020.0011.30CF][.0000.013E.0002.309A] # KATAKANA LETTER PA; QQCM
3072  ; [.193B.0020.000E.3072] # HIRAGANA LETTER HI
30D2  ; [.193B.0020.0011.30D2] # KATAKANA LETTER HI
3073  ; [.193B.0020.000E.3072][.0000.013D.0002.3099] # HIRAGANA LETTER BI; QQCM
30D3  ; [.193B.0020.0011.30D2][.0000.013D.0002.3099] # KATAKANA LETTER BI; QQCM
3074  ; [.193B.0020.000E.3072][.0000.013E.0002.309A] # HIRAGANA LETTER PI; QQCM
30D4  ; [.193B.0020.0011.30D2][.0000.013E.0002.309A] # KATAKANA LETTER PI; QQCM
3075  ; [.193C.0020.000E.3075] # HIRAGANA LETTER HU
30D5  ; [.193C.0020.0011.30D5] # KATAKANA LETTER HU
3076  ; [.193C.0020.000E.3075][.0000.013D.0002.3099] # HIRAGANA LETTER BU; QQCM
30D6  ; [.193C.0020.0011.30D5][.0000.013D.0002.3099] # KATAKANA LETTER BU; QQCM
3077  ; [.193C.0020.000E.3075][.0000.013E.0002.309A] # HIRAGANA LETTER PU; QQCM
30D7  ; [.193C.0020.0011.30D5][.0000.013E.0002.309A] # KATAKANA LETTER PU; QQCM
3078  ; [.193D.0020.000E.3078] # HIRAGANA LETTER HE
30D8  ; [.193D.0020.0011.30D8] # KATAKANA LETTER HE
3079  ; [.193D.0020.000E.3078][.0000.013D.0002.3099] # HIRAGANA LETTER BE; QQCM
30D9  ; [.193D.0020.0011.30D8][.0000.013D.0002.3099] # KATAKANA LETTER BE; QQCM
307A  ; [.193D.0020.000E.3078][.0000.013E.0002.309A] # HIRAGANA LETTER PE; QQCM
30DA  ; [.193D.0020.0011.30D8][.0000.013E.0002.309A] # KATAKANA LETTER PE; QQCM
307B  ; [.193E.0020.000E.307B] # HIRAGANA LETTER HO
30DB  ; [.193E.0020.0011.30DB] # KATAKANA LETTER HO
307C  ; [.193E.0020.000E.307B][.0000.013D.0002.3099] # HIRAGANA LETTER BO; QQCM
30DC  ; [.193E.0020.0011.30DB][.0000.013D.0002.3099] # KATAKANA LETTER BO; QQCM
307D  ; [.193E.0020.000E.307B][.0000.013E.0002.309A] # HIRAGANA LETTER PO; QQCM
30DD  ; [.193E.0020.0011.30DB][.0000.013E.0002.309A] # KATAKANA LETTER PO; QQCM
307E  ; [.193F.0020.000E.307E] # HIRAGANA LETTER MA
30DE  ; [.193F.0020.0011.30DE] # KATAKANA LETTER MA
307F  ; [.1940.0020.000E.307F] # HIRAGANA LETTER MI
30DF  ; [.1940.0020.0011.30DF] # KATAKANA LETTER MI
3080  ; [.1941.0020.000E.3080] # HIRAGANA LETTER MU
30E0  ; [.1941.0020.0011.30E0] # KATAKANA LETTER MU
3081  ; [.1942.0020.000E.3081] # HIRAGANA LETTER ME
30E1  ; [.1942.0020.0011.30E1] # KATAKANA LETTER ME
3082  ; [.1943.0020.000E.3082] # HIRAGANA LETTER MO
30E2  ; [.1943.0020.0011.30E2] # KATAKANA LETTER MO
3083  ; [.1944.0020.000D.3083] # HIRAGANA LETTER SMALL YA
3084  ; [.1944.0020.000E.3084] # HIRAGANA LETTER YA
30E3  ; [.1944.0020.000F.30E3] # KATAKANA LETTER SMALL YA
30E4  ; [.1944.0020.0011.30E4] # KATAKANA LETTER YA
3085  ; [.1945.0020.000D.3085] # HIRAGANA LETTER SMALL YU
3086  ; [.1945.0020.000E.3086] # HIRAGANA LETTER YU
30E5  ; [.1945.0020.000F.30E5] # KATAKANA LETTER SMALL YU
30E6  ; [.1945.0020.0011.30E6] # KATAKANA LETTER YU
3087  ; [.1946.0020.000D.3087] # HIRAGANA LETTER SMALL YO
3088  ; [.1946.0020.000E.3088] # HIRAGANA LETTER YO
30E7  ; [.1946.0020.000F.30E7] # KATAKANA LETTER SMALL YO
30E8  ; [.1946.0020.0011.30E8] # KATAKANA LETTER YO
3089  ; [.1947.0020.000E.3089] # HIRAGANA LETTER RA
30E9  ; [.1947.0020.0011.30E9] # KATAKANA LETTER RA
308A  ; [.1948.0020.000E.308A] # HIRAGANA LETTER RI
30EA  ; [.1948.0020.0011.30EA] # KATAKANA LETTER RI
308B  ; [.1949.0020.000E.308B] # HIRAGANA LETTER RU
30EB  ; [.1949.0020.0011.30EB] # KATAKANA LETTER RU
308C  ; [.194A.0020.000E.308C] # HIRAGANA LETTER RE
30EC  ; [.194A.0020.0011.30EC] # KATAKANA LETTER RE
308D  ; [.194B.0020.000E.308D] # HIRAGANA LETTER RO
30ED  ; [.194B.0020.0011.30ED] # KATAKANA LETTER RO
308E  ; [.194C.0020.000D.308E] # HIRAGANA LETTER SMALL WA
308F  ; [.194C.0020.000E.308F] # HIRAGANA LETTER WA
30EE  ; [.194C.0020.000F.30EE] # KATAKANA LETTER SMALL WA
30EF  ; [.194C.0020.0011.30EF] # KATAKANA LETTER WA
30F7  ; [.194C.0020.0011.30EF][.0000.013D.0002.3099] # KATAKANA LETTER VA; QQCM
3090  ; [.194D.0020.000E.3090] # HIRAGANA LETTER WI
30F0  ; [.194D.0020.0011.30F0] # KATAKANA LETTER WI
30F8  ; [.194D.0020.0011.30F0][.0000.013D.0002.3099] # KATAKANA LETTER VI; QQCM
3091  ; [.194E.0020.000E.3091] # HIRAGANA LETTER WE
30F1  ; [.194E.0020.0011.30F1] # KATAKANA LETTER WE
30F9  ; [.194E.0020.0011.30F1][.0000.013D.0002.3099] # KATAKANA LETTER VE; QQCM
3092  ; [.194F.0020.000E.3092] # HIRAGANA LETTER WO
30F2  ; [.194F.0020.0011.30F2] # KATAKANA LETTER WO
30FA  ; [.194F.0020.0011.30F2][.0000.013D.0002.3099] # KATAKANA LETTER VO; QQCM
3093  ; [.1950.0020.000E.3093] # HIRAGANA LETTER N
30F3  ; [.1950.0020.0011.30F3] # KATAKANA LETTER N
                                                                                                                                                                                                                                                                                                                                                                                                                          usr/share/perl/5.36.0/Unicode/UCD.pm                                                                0000644 0000000 0000000 00000553554 14530460112 015226  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Unicode::UCD;

use strict;
use warnings;
no warnings 'surrogate';    # surrogates can be inputs to this
use charnames ();

our $VERSION = '0.78';

sub DEBUG () { 0 }
$|=1 if DEBUG;

require Exporter;

our @ISA = qw(Exporter);

our @EXPORT_OK = qw(charinfo
		    charblock charscript
		    charblocks charscripts
		    charinrange
		    charprop
		    charprops_all
		    general_categories bidi_types
		    compexcl
		    casefold all_casefolds casespec
		    namedseq
                    num
                    prop_aliases
                    prop_value_aliases
                    prop_values
                    prop_invlist
                    prop_invmap
                    search_invlist
                    MAX_CP
                );

use Carp;

sub IS_ASCII_PLATFORM { ord("A") == 65 }

=head1 NAME

Unicode::UCD - Unicode character database

=head1 SYNOPSIS

    use Unicode::UCD 'charinfo';
    my $charinfo   = charinfo($codepoint);

    use Unicode::UCD 'charprop';
    my $value  = charprop($codepoint, $property);

    use Unicode::UCD 'charprops_all';
    my $all_values_hash_ref = charprops_all($codepoint);

    use Unicode::UCD 'casefold';
    my $casefold = casefold($codepoint);

    use Unicode::UCD 'all_casefolds';
    my $all_casefolds_ref = all_casefolds();

    use Unicode::UCD 'casespec';
    my $casespec = casespec($codepoint);

    use Unicode::UCD 'charblock';
    my $charblock  = charblock($codepoint);

    use Unicode::UCD 'charscript';
    my $charscript = charscript($codepoint);

    use Unicode::UCD 'charblocks';
    my $charblocks = charblocks();

    use Unicode::UCD 'charscripts';
    my $charscripts = charscripts();

    use Unicode::UCD qw(charscript charinrange);
    my $range = charscript($script);
    print "looks like $script\n" if charinrange($range, $codepoint);

    use Unicode::UCD qw(general_categories bidi_types);
    my $categories = general_categories();
    my $types = bidi_types();

    use Unicode::UCD 'prop_aliases';
    my @space_names = prop_aliases("space");

    use Unicode::UCD 'prop_value_aliases';
    my @gc_punct_names = prop_value_aliases("Gc", "Punct");

    use Unicode::UCD 'prop_values';
    my @all_EA_short_names = prop_values("East_Asian_Width");

    use Unicode::UCD 'prop_invlist';
    my @puncts = prop_invlist("gc=punctuation");

    use Unicode::UCD 'prop_invmap';
    my ($list_ref, $map_ref, $format, $missing)
                                      = prop_invmap("General Category");

    use Unicode::UCD 'search_invlist';
    my $index = search_invlist(\@invlist, $code_point);

    # The following function should be used only internally in
    # implementations of the Unicode Normalization Algorithm, and there
    # are better choices than it.
    use Unicode::UCD 'compexcl';
    my $compexcl = compexcl($codepoint);

    use Unicode::UCD 'namedseq';
    my $namedseq = namedseq($named_sequence_name);

    my $unicode_version = Unicode::UCD::UnicodeVersion();

    my $convert_to_numeric =
              Unicode::UCD::num("\N{RUMI DIGIT ONE}\N{RUMI DIGIT TWO}");

=head1 DESCRIPTION

The Unicode::UCD module offers a series of functions that
provide a simple interface to the Unicode
Character Database.

=head2 code point argument

Some of the functions are called with a I<code point argument>, which is either
a decimal or a hexadecimal scalar designating a code point in the platform's
native character set (extended to Unicode), or a string containing C<U+>
followed by hexadecimals
designating a Unicode code point.  A leading 0 will force a hexadecimal
interpretation, as will a hexadecimal digit that isn't a decimal digit.

Examples:

    223     # Decimal 223 in native character set
    0223    # Hexadecimal 223, native (= 547 decimal)
    0xDF    # Hexadecimal DF, native (= 223 decimal)
    '0xDF'  # String form of hexadecimal (= 223 decimal)
    'U+DF'  # Hexadecimal DF, in Unicode's character set
                              (= LATIN SMALL LETTER SHARP S)

Note that the largest code point in Unicode is U+10FFFF.

=cut

our %caseless_equivalent;
our $e_precision;
our %file_to_swash_name;
our @inline_definitions;
our %loose_property_name_of;
our %loose_property_to_file_of;
our %loose_to_file_of;
our $MAX_CP;
our %nv_floating_to_rational;
our %prop_aliases;
our %stricter_to_file_of;
our %strict_property_to_file_of;
our %SwashInfo;
our %why_deprecated;

my $v_unicode_version;  # v-string.

sub openunicode {
    my (@path) = @_;
    my $rfh;
    for my $d (@INC) {
        use File::Spec;
        my $f = File::Spec->catfile($d, "unicore", @path);
        return $rfh if open($rfh, '<', $f);
    }
    croak __PACKAGE__, ": failed to find ",
        File::Spec->catfile("unicore", @path), " in @INC";
}

sub _dclone ($) {   # Use Storable::dclone if available; otherwise emulate it.

    use if defined &DynaLoader::boot_DynaLoader, Storable => qw(dclone);

    return dclone(shift) if defined &dclone;

    my $arg = shift;
    my $type = ref $arg;
    return $arg unless $type;   # No deep cloning needed for scalars

    if ($type eq 'ARRAY') {
        my @return;
        foreach my $element (@$arg) {
            push @return, &_dclone($element);
        }
        return \@return;
    }
    elsif ($type eq 'HASH') {
        my %return;
        foreach my $key (keys %$arg) {
            $return{$key} = &_dclone($arg->{$key});
        }
        return \%return;
    }
    else {
        croak "_dclone can't handle " . $type;
    }
}

=head2 B<charinfo()>

    use Unicode::UCD 'charinfo';

    my $charinfo = charinfo(0x41);

This returns information about the input L</code point argument>
as a reference to a hash of fields as defined by the Unicode
standard.  If the L</code point argument> is not assigned in the standard
(i.e., has the general category C<Cn> meaning C<Unassigned>)
or is a non-character (meaning it is guaranteed to never be assigned in
the standard),
C<undef> is returned.

Fields that aren't applicable to the particular code point argument exist in the
returned hash, and are empty.

For results that are less "raw" than this function returns, or to get the values for
any property, not just the few covered by this function, use the
L</charprop()> function.

The keys in the hash with the meanings of their values are:

=over

=item B<code>

the input native L</code point argument> expressed in hexadecimal, with
leading zeros
added if necessary to make it contain at least four hexdigits

=item B<name>

name of I<code>, all IN UPPER CASE.
Some control-type code points do not have names.
This field will be empty for C<Surrogate> and C<Private Use> code points,
and for the others without a name,
it will contain a description enclosed in angle brackets, like
C<E<lt>controlE<gt>>.


=item B<category>

The short name of the general category of I<code>.
This will match one of the keys in the hash returned by L</general_categories()>.

The L</prop_value_aliases()> function can be used to get all the synonyms
of the category name.

=item B<combining>

the combining class number for I<code> used in the Canonical Ordering Algorithm.
For Unicode 5.1, this is described in Section 3.11 C<Canonical Ordering Behavior>
available at
L<http://www.unicode.org/versions/Unicode5.1.0/>

The L</prop_value_aliases()> function can be used to get all the synonyms
of the combining class number.

=item B<bidi>

bidirectional type of I<code>.
This will match one of the keys in the hash returned by L</bidi_types()>.

The L</prop_value_aliases()> function can be used to get all the synonyms
of the bidi type name.

=item B<decomposition>

is empty if I<code> has no decomposition; or is one or more codes
(separated by spaces) that, taken in order, represent a decomposition for
I<code>.  Each has at least four hexdigits.
The codes may be preceded by a word enclosed in angle brackets, then a space,
like C<E<lt>compatE<gt> >, giving the type of decomposition

This decomposition may be an intermediate one whose components are also
decomposable.  Use L<Unicode::Normalize> to get the final decomposition in one
step.

=item B<decimal>

if I<code> represents a decimal digit this is its integer numeric value

=item B<digit>

if I<code> represents some other digit-like number, this is its integer
numeric value

=item B<numeric>

if I<code> represents a whole or rational number, this is its numeric value.
Rational values are expressed as a string like C<1/4>.

=item B<mirrored>

C<Y> or C<N> designating if I<code> is mirrored in bidirectional text

=item B<unicode10>

name of I<code> in the Unicode 1.0 standard if one
existed for this code point and is different from the current name

=item B<comment>

As of Unicode 6.0, this is always empty.

=item B<upper>

is, if non-empty, the uppercase mapping for I<code> expressed as at least four
hexdigits.  This indicates that the full uppercase mapping is a single
character, and is identical to the simple (single-character only) mapping.
When this field is empty, it means that the simple uppercase mapping is
I<code> itself; you'll need some other means, (like L</charprop()> or
L</casespec()> to get the full mapping.

=item B<lower>

is, if non-empty, the lowercase mapping for I<code> expressed as at least four
hexdigits.  This indicates that the full lowercase mapping is a single
character, and is identical to the simple (single-character only) mapping.
When this field is empty, it means that the simple lowercase mapping is
I<code> itself; you'll need some other means, (like L</charprop()> or
L</casespec()> to get the full mapping.

=item B<title>

is, if non-empty, the titlecase mapping for I<code> expressed as at least four
hexdigits.  This indicates that the full titlecase mapping is a single
character, and is identical to the simple (single-character only) mapping.
When this field is empty, it means that the simple titlecase mapping is
I<code> itself; you'll need some other means, (like L</charprop()> or
L</casespec()> to get the full mapping.

=item B<block>

the block I<code> belongs to (used in C<\p{Blk=...}>).
The L</prop_value_aliases()> function can be used to get all the synonyms
of the block name.

See L</Blocks versus Scripts>.

=item B<script>

the script I<code> belongs to.
The L</prop_value_aliases()> function can be used to get all the synonyms
of the script name.  Note that this is the older "Script" property value, and
not the improved "Script_Extensions" value.

See L</Blocks versus Scripts>.

=back

Note that you cannot do (de)composition and casing based solely on the
I<decomposition>, I<combining>, I<lower>, I<upper>, and I<title> fields; you
will need also the L</casespec()> function and the C<Composition_Exclusion>
property.  (Or you could just use the L<lc()|perlfunc/lc>,
L<uc()|perlfunc/uc>, and L<ucfirst()|perlfunc/ucfirst> functions, and the
L<Unicode::Normalize> module.)

=cut

my %Cache;

# Digits may be separated by a single underscore
my $digits = qr/ ( [0-9] _? )+ (?!:_) /x;

# A sign can be surrounded by white space
my $sign = qr/ \s* [+-]? \s* /x;

my $f_float = qr/  $sign $digits+ \. $digits*    # e.g., 5.0, 5.
                 | $sign $digits* \. $digits+/x; # 0.7, .7

# A number may be an integer, a rational, or a float with an optional exponent
# We (shudder) accept a signed denominator
my $number = qr{  ^ $sign $digits+ $
                | ^ $sign $digits+ \/ $sign $digits+ $
                | ^ $f_float (?: [Ee] [+-]? $digits )? $}x;

sub loose_name ($) {
    # Given a lowercase property or property-value name, return its
    # standardized version that is expected for look-up in the 'loose' hashes
    # in UCD.pl (hence, this depends on what mktables does).  This squeezes
    # out blanks, underscores and dashes.  The complication stems from the
    # grandfathered-in 'L_', which retains a single trailing underscore.

# integer or float (no exponent)
my $integer_or_float_re = qr/ ^ -? \d+ (:? \. \d+ )? $ /x;

# Also includes rationals
my $numeric_re = qr! $integer_or_float_re | ^ -? \d+ / \d+ $ !x;
    return $_[0] if $_[0] =~ $numeric_re;

    (my $loose = $_[0]) =~ s/[-_ \t]//g;

    return $loose if $loose !~ / ^ (?: is | to )? l $/x;
    return 'l_' if $_[0] =~ / l .* _ /x;    # If original had a trailing '_'
    return $loose;
}

##
## "SWASH" == "SWATCH HASH". A "swatch" is a swatch of the Unicode landscape.
## It's a data structure that encodes a set of Unicode characters.
##

{
    use re "/aa";  # Nothing here uses above Latin1.

    # If a floating point number is within this distance from the value of a
    # fraction, it is considered to be that fraction, even if many more digits
    # are specified that don't exactly match.
    my $min_floating_slop;

    # To guard against this program calling something that in turn ends up
    # calling this program with the same inputs, and hence infinitely
    # recursing, we keep a stack of the properties that are currently in
    # progress, pushed upon entry, popped upon return.
    my @recursed;

    sub SWASHNEW {
        my ($class, $type, $list, $minbits) = @_;
        my $user_defined = 0;
        local $^D = 0 if $^D;

        $class = "" unless defined $class;
        print STDERR __LINE__, ": class=$class, type=$type, list=",
                                (defined $list) ? $list : ':undef:',
                                ", minbits=$minbits\n" if DEBUG;

        ##
        ## Get the list of codepoints for the type.
        ## Called from swash_init (see utf8.c) or SWASHNEW itself.
        ##
        ## Callers of swash_init:
        ##     prop_invlist
        ##     Unicode::UCD::prop_invmap
        ##
        ## Given a $type, our goal is to fill $list with the set of codepoint
        ## ranges. If $type is false, $list passed is used.
        ##
        ## $minbits:
        ##     For binary properties, $minbits must be 1.
        ##     For character mappings (case and transliteration), $minbits must
        ##     be a number except 1.
        ##
        ## $list (or that filled according to $type):
        ##     Refer to perlunicode.pod, "User-Defined Character Properties."
        ##
        ##     For binary properties, only characters with the property value
        ##     of True should be listed. The 3rd column, if any, will be ignored
        ##
        ## To make the parsing of $type clear, this code takes the a rather
        ## unorthodox approach of last'ing out of the block once we have the
        ## info we need. Were this to be a subroutine, the 'last' would just
        ## be a 'return'.
        ##
        #   If a problem is found $type is returned;
        #   Upon success, a new (or cached) blessed object is returned with
        #   keys TYPE, BITS, EXTRAS, LIST, and with values having the
        #   same meanings as the input parameters.
        #   SPECIALS contains a reference to any special-treatment hash in the
        #       property.
        #   INVERT_IT is non-zero if the result should be inverted before use
        #   USER_DEFINED is non-zero if the result came from a user-defined
        my $file; ## file to load data from, and also part of the %Cache key.

        # Change this to get a different set of Unicode tables
        my $unicore_dir = 'unicore';
        my $invert_it = 0;
        my $list_is_from_mktables = 0;  # Is $list returned from a mktables
                                        # generated file?  If so, we know it's
                                        # well behaved.

        if ($type)
        {
            # Verify that this isn't a recursive call for this property.
            # Can't use croak, as it may try to recurse to here itself.
            my $class_type = $class . "::$type";
            if (grep { $_ eq $class_type } @recursed) {
                CORE::die "panic: Infinite recursion in SWASHNEW for '$type'\n";
            }
            push @recursed, $class_type;

            $type =~ s/^\s+//;
            $type =~ s/\s+$//;

            # regcomp.c surrounds the property name with '__" and '_i' if this
            # is to be caseless matching.
            my $caseless = $type =~ s/^(.*)__(.*)_i$/$1$2/;

            print STDERR __LINE__, ": type=$type, caseless=$caseless\n" if DEBUG;

        GETFILE:
            {
                ##
                ## It could be a user-defined property.  Look in current
                ## package if no package given
                ##


                my $caller0 = caller(0);
                my $caller1 = $type =~ s/(.+):://
                              ? $1
                              : $caller0 eq 'main'
                                ? 'main'
                                : caller(1);

                if (defined $caller1 && $type =~ /^I[ns]\w+$/) {
                    my $prop = "${caller1}::$type";
                    if (exists &{$prop}) {
                        # stolen from Scalar::Util::PP::tainted()
                        my $tainted;
                        {
                            local($@, $SIG{__DIE__}, $SIG{__WARN__});
                            local $^W = 0;
                            no warnings;
                            eval { kill 0 * $prop };
                            $tainted = 1 if $@ =~ /^Insecure/;
                        }
                        die "Insecure user-defined property \\p{$prop}\n"
                            if $tainted;
                        no strict 'refs';
                        $list = &{$prop}($caseless);
                        $user_defined = 1;
                        last GETFILE;
                    }
                }

                require "$unicore_dir/UCD.pl";

                # All property names are matched caselessly
                my $property_and_table = CORE::lc $type;
                print STDERR __LINE__, ": $property_and_table\n" if DEBUG;

                # See if is of the compound form 'property=value', where the
                # value indicates the table we should use.
                my ($property, $table, @remainder) =
                                    split /\s*[:=]\s*/, $property_and_table, -1;
                if (@remainder) {
                    pop @recursed if @recursed;
                    return $type;
                }

                my $prefix;
                if (! defined $table) {

                    # Here, is the single form.  The property becomes empty, and
                    # the whole value is the table.
                    $table = $property;
                    $prefix = $property = "";
                } else {
                    print STDERR __LINE__, ": $property\n" if DEBUG;

                    # Here it is the compound property=table form.  The property
                    # name is always loosely matched, and always can have an
                    # optional 'is' prefix (which isn't true in the single
                    # form).
                    $property = loose_name($property) =~ s/^is//r;

                    # And convert to canonical form.  Quit if not valid.
                    $property = $loose_property_name_of{$property};
                    if (! defined $property) {
                        pop @recursed if @recursed;
                        return $type;
                    }

                    $prefix = "$property=";

                    # If the rhs looks like it is a number...
                    print STDERR __LINE__, ": table=$table\n" if DEBUG;

                    if ($table =~ $number) {
                        print STDERR __LINE__, ": table=$table\n" if DEBUG;

                        # Split on slash, in case it is a rational, like \p{1/5}
                        my @parts = split m{ \s* / \s* }x, $table, -1;
                        print __LINE__, ": $type\n" if @parts > 2 && DEBUG;

                        foreach my $part (@parts) {
                            print __LINE__, ": part=$part\n" if DEBUG;

                            $part =~ s/^\+\s*//;    # Remove leading plus
                            $part =~ s/^-\s*/-/;    # Remove blanks after unary
                                                    # minus

                            # Remove underscores between digits.
                            $part =~ s/(?<= [0-9] ) _ (?= [0-9] ) //xg;

                            # No leading zeros (but don't make a single '0'
                            # into a null string)
                            $part =~ s/ ^ ( -? ) 0+ /$1/x;
                            $part .= '0' if $part eq '-' || $part eq "";

                            # No trailing zeros after a decimal point
                            $part =~ s/ ( \. [0-9]*? ) 0+ $ /$1/x;

                            # Begin with a 0 if a leading decimal point
                            $part =~ s/ ^ ( -? ) \. /${1}0./x;

                            # Ensure not a trailing decimal point: turn into an
                            # integer
                            $part =~ s/ \. $ //x;

                            print STDERR __LINE__, ": part=$part\n" if DEBUG;
                            #return $type if $part eq "";
                        }

                        #  If a rational...
                        if (@parts == 2) {

                            # If denominator is negative, get rid of it, and ...
                            if ($parts[1] =~ s/^-//) {

                                # If numerator is also negative, convert the
                                # whole thing to positive, else move the minus
                                # to the numerator
                                if ($parts[0] !~ s/^-//) {
                                    $parts[0] = '-' . $parts[0];
                                }
                            }
                            $table = join '/', @parts;
                        }
                        elsif ($property ne 'nv' || $parts[0] !~ /\./) {

                            # Here is not numeric value, or doesn't have a
                            # decimal point.  No further manipulation is
                            # necessary.  (Note the hard-coded property name.
                            # This could fail if other properties eventually
                            # had fractions as well; perhaps the cjk ones
                            # could evolve to do that.  This hard-coding could
                            # be fixed by mktables generating a list of
                            # properties that could have fractions.)
                            $table = $parts[0];
                        } else {

                            # Here is a floating point numeric_value.  Convert
                            # to rational.  Get a normalized form, like
                            # 5.00E-01, and look that up in the hash

                            my $float = sprintf "%.*e",
                                                $e_precision,
                                                0 + $parts[0];

                            if (exists $nv_floating_to_rational{$float}) {
                                $table = $nv_floating_to_rational{$float};
                            } else {
                                pop @recursed if @recursed;
                                return $type;
                            }
                        }
                        print STDERR __LINE__, ": $property=$table\n" if DEBUG;
                    }
                }

                # Combine lhs (if any) and rhs to get something that matches
                # the syntax of the lookups.
                $property_and_table = "$prefix$table";
                print STDERR __LINE__, ": $property_and_table\n" if DEBUG;

                # First try stricter matching.
                $file = $stricter_to_file_of{$property_and_table};

                # If didn't find it, try again with looser matching by editing
                # out the applicable characters on the rhs and looking up
                # again.
                my $strict_property_and_table;
                if (! defined $file) {

                    # This isn't used unless the name begins with 'to'
                    $strict_property_and_table = $property_and_table =~  s/^to//r;
                    $table = loose_name($table);
                    $property_and_table = "$prefix$table";
                    print STDERR __LINE__, ": $property_and_table\n" if DEBUG;
                    $file = $loose_to_file_of{$property_and_table};
                    print STDERR __LINE__, ": $property_and_table\n" if DEBUG;
                }

                # Add the constant and go fetch it in.
                if (defined $file) {

                    # If the file name contains a !, it means to invert.  The
                    # 0+ makes sure result is numeric
                    $invert_it = 0 + $file =~ s/!//;

                    if ($caseless
                        && exists $caseless_equivalent{$property_and_table})
                    {
                        $file = $caseless_equivalent{$property_and_table};
                    }

                    # The pseudo-directory '#' means that there really isn't a
                    # file to read, the data is in-line as part of the string;
                    # we extract it below.
                    $file = "$unicore_dir/lib/$file.pl" unless $file =~ m!^#/!;
                    last GETFILE;
                }
                print STDERR __LINE__, ": didn't find $property_and_table\n" if DEBUG;

                ##
                ## Last attempt -- see if it's a standard "To" name
                ## (e.g. "ToLower")  ToTitle is used by ucfirst().
                ## The user-level way to access ToDigit() and ToFold()
                ## is to use Unicode::UCD.
                ##
                # Only check if caller wants non-binary
                if ($minbits != 1) {
                    if ($property_and_table =~ s/^to//) {
                    # Look input up in list of properties for which we have
                    # mapping files.  First do it with the strict approach
                        if (defined ($file = $strict_property_to_file_of{
                                                    $strict_property_and_table}))
                        {
                            $type = $file_to_swash_name{$file};
                            print STDERR __LINE__, ": type set to $type\n"
                                                                        if DEBUG;
                            $file = "$unicore_dir/$file.pl";
                            last GETFILE;
                        }
                        elsif (defined ($file =
                          $loose_property_to_file_of{$property_and_table}))
                        {
                            $type = $file_to_swash_name{$file};
                            print STDERR __LINE__, ": type set to $type\n"
                                                                        if DEBUG;
                            $file = "$unicore_dir/$file.pl";
                            last GETFILE;
                        }   # If that fails see if there is a corresponding binary
                            # property file
                        elsif (defined ($file =
                                    $loose_to_file_of{$property_and_table}))
                        {

                            # Here, there is no map file for the property we
                            # are trying to get the map of, but this is a
                            # binary property, and there is a file for it that
                            # can easily be translated to a mapping, so use
                            # that, treating this as a binary property.
                            # Setting 'minbits' here causes it to be stored as
                            # such in the cache, so if someone comes along
                            # later looking for just a binary, they get it.
                            $minbits = 1;

                            # The 0+ makes sure is numeric
                            $invert_it = 0 + $file =~ s/!//;
                            $file = "$unicore_dir/lib/$file.pl"
                                                         unless $file =~ m!^#/!;
                            last GETFILE;
                        }
                    }
                }

                ##
                ## If we reach this line, it's because we couldn't figure
                ## out what to do with $type. Ouch.
                ##

                pop @recursed if @recursed;
                return $type;
            } # end of GETFILE block

            if (defined $file) {
                print STDERR __LINE__, ": found it (file='$file')\n" if DEBUG;

                ##
                ## If we reach here, it was due to a 'last GETFILE' above
                ## (exception: user-defined properties and mappings), so we
                ## have a filename, so now we load it if we haven't already.

                # The pseudo-directory '#' means the result isn't really a
                # file, but is in-line, with semi-colons to be turned into
