    # $provider - a value corresponding to OSSL_PROVIDER
    #
    # returns: (integer) returns 1 if the self tests pass, 0 on error

Check openssl doc L<https://www.openssl.org/docs/manmaster/man3/OSSL_PROVIDER_self_test.html>

=back

=head3 Low level API: TLS PSK related functions

B<COMPATIBILITY:> not available in Net-SSLeay-1.92 and before.  The TLSv1.3 specific functions require at least OpenSSL 1.1.1 and the others require at least OpenSSL 1.0.0. Not available in LibreSSL.

=over

=item * CTX_use_psk_identity_hint

Set PSK identity hint for SSL_CTX on TLS server for TLSv1.2 and earlier versions.

    my $ret = Net::SSLeay::CTX_use_psk_identity_hint($ctx, $hint);
    # $ctx - value corresponding to OpenSSL SSL_CTX structure
    # $hint - string, a hint sent to the TLS clients
    #
    # returns: 1 on success, 0 on failure

Example:

    my $ret = Net::SSLeay::CTX_use_psk_identity_hint($ctx, 'ctx server identity_hint');

Check openssl doc L<https://www.openssl.org/docs/manmaster/man3/SSL_CTX_use_psk_identity_hint.html>

=item * use_psk_identity_hint

Set PSK identity hint for SSL on TLS server for TLSv1.2 and earlier versions.

    my $ret = Net::SSLeay::use_psk_identity_hint($ssl, $hint);
    # $ssl - value corresponding to OpenSSL SSL structure
    # $hint - string, a hint sent to the TLS clients
    #
    # returns: 1 on success, 0 on failure

Example:

    my $ret = Net::SSLeay::use_psk_identity_hint($ssl, 'ssl server identity_hint');

Check openssl doc L<https://www.openssl.org/docs/manmaster/man3/SSL_use_psk_identity_hint.html>

=item * CTX_set_psk_server_callback

Set a callback for an SSL_CTX on TLS server for using PSKs with all TLS versions.

B<NOTE:> With TLSv1.3 Net::SSLeay::CTX_set_psk_find_session_callback
or Net::SSLeay::set_psk_find_session_callback is recommended.

    # First set up a callback function.
    sub tls12_psk_cb {
        my ($ssl, $identity, $max_psk_len) = @_;

        # Note: $identity is potentially hostile user supplied data

        my $psk = pack('H*', 'deadbeef');
        return $psk if length $psk <= $max_psk_len;

        return undef;
    }

    my $cb = \&tls12_psk_cb;
    Net::SSLeay::CTX_set_psk_server_callback($ctx, $cb);
    # $ctx - value corresponding to OpenSSL SSL_CTX structure
    # $cb - reference to callback function
    #
    # returns: no return value

The callback function must return a PSK in packed binary format, or
C<undef> to trigger C<unknown_psk_identity> alert and TLS handshake
failure. If TLS handshake failure without PSK specific alert is
required, return packed random data.

Check openssl doc L<https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_psk_server_callback.html>

=item * set_psk_server_callback

Set a callback for an SSL on TLS server for using PSKs with all TLS versions.

B<NOTE:> With TLSv1.3 Net::SSLeay::CTX_set_psk_find_session_callback
or Net::SSLeay::set_psk_find_session_callback is recommended.

    Net::SSLeay::set_psk_server_callback($ssl, $cb);
    # $ssl - value corresponding to OpenSSL SSL structure
    # $cb - reference to callback function
    #
    # returns: no return value

See Net::SSLeay::CTX_set_psk_server_callback() documentation for
a full example with a callback.

Check openssl doc L<https://www.openssl.org/docs/manmaster/man3/SSL_set_psk_server_callback.html>

=item * CTX_set_psk_find_session_callback

Set a callback for an SSL_CTX on TLS server for using TLSv1.3 PSKs.

    # First set up a callback function.
    sub tls13_psk_cb {
        my ($ssl, $identity) = @_;

        # Note: $identity is potentially hostile user supplied data

        my $sess = Net::SSLeay::SESSION_new();
        my $cipher = Net::SSLeay::CIPHER_find($ssl, pack('n', 0x1301));
        Net::SSLeay::SESSION_set1_master_key($sess, pack('H*', 'deadbeef'));
        Net::SSLeay::SESSION_set_cipher($sess, $cipher);
        Net::SSLeay::SESSION_set_protocol_version($sess, Net::SSLeay::version($ssl));

        return (1, $sess);
    }

    my $cb = \&tls13_psk_cb;
    Net::SSLeay::CTX_set_psk_find_session_callback($ctx, $cb);
    # $ctx - value corresponding to OpenSSL SSL_CTX structure
    # $cb - reference to callback function
    #
    # returns: no return value

The callback function must return a two value list. When the first
value is 0, the connection setup fails. When the first value is 1, the
second value must be a valid C<SSL_SESSION> or C<undef>. When the
second value is a valid C<SSL_SESSION>, the TLS handshake proceeds
with PSK authentication. When the the second value is C<undef>, PSK is
not used the TLS handshake proceeds with certificate authentication.

Check openssl doc L<https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_psk_find_session_callback.html>

=item * set_psk_find_session_callback

Set a callback for an SSL on TLS server for using TLSv1.3 PSKs.

    Net::SSLeay::set_psk_find_session_callback($ssl, $cb);
    # $ssl - value corresponding to OpenSSL SSL structure
    # $cb - reference to callback function
    #
    # returns: no return value

See Net::SSLeay::CTX_set_psk_find_session_callback() documentation for
a full example with a callback.

Check openssl doc L<https://www.openssl.org/docs/manmaster/man3/SSL_set_psk_find_session_callback.html>

=item * CTX_set_psk_use_session_callback

Set a callback for an SSL_CTX on TLS client for using TLSv1.3 PSKs.

    # First set up a callback function.
    sub tls13_use_psk_cb {
        my ($ssl, $md) = @_;

        my $psk_identity = "test-tls-psk";
        my $sess = Net::SSLeay::SESSION_new();
        my $cipher = Net::SSLeay::CIPHER_find($ssl, pack('n', 0x1301));
        Net::SSLeay::SESSION_set1_master_key($sess, pack('H*', 'deadbeef'));
        Net::SSLeay::SESSION_set_cipher($sess, $cipher);
        Net::SSLeay::SESSION_set_protocol_version($sess, Net::SSLeay::TLS1_3_VERSION());

        # Typically not defined, see OpenSSL manual
        if ($md) {
            my $sess_md = Net::SSLeay::CIPHER_get_handshake_digest($cipher);
            my $md_type; $md_type = Net::SSLeay::EVP_MD_type($md) if $md;
            my $sess_md_type = Net::SSLeay::EVP_MD_type($sess_md);

            if ($md_type != $sess_md_type) {
                # Example only: guess and try SHA384
                my $switched_cipher = Net::SSLeay::CIPHER_find($ssl, pack('n', 0x1302));
                my $switched_md = Net::SSLeay::CIPHER_get_handshake_digest($switched_cipher);
                my $switched_md_type = Net::SSLeay::EVP_MD_type($switched_md);
                if ($md_type != $switched_md_type) {
                    # Guessed wrong, can't proceed with mismatched digest function
                    Net::SSLeay::SESSION_free($sess);
                    return (0, undef, undef);
                }
                Net::SSLeay::SESSION_set_cipher($sess, $switched_cipher);
            }
        }

        return (1, $psk_identity, $sess);
    }

    my $cb = \&tls13_use_psk_cb;
    Net::SSLeay::CTX_set_psk_use_session_callback($ctx, $cb);
    # $ctx - value corresponding to OpenSSL SSL_CTX structure
    # $cb - reference to callback function
    #
    # returns: no return value

The callback function must return a two value list. When the first
value is 0, the connection setup fails. When the first value is 1, the
second value must be a valid C<SSL_SESSION> or C<undef>. When the
second value is a valid C<SSL_SESSION>, the TLS handshake proceeds
with PSK authentication. When the the second value is C<undef>, PSK is
not used the TLS handshake proceeds with certificate authentication.

Check openssl doc L<https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_psk_find_session_callback.html>

=item * set_psk_use_session_callback

Set a callback for an SSL on TLS client for using TLSv1.3 PSKs.

    # First set up a callback function.
    sub tls13_psk_cb {
        my ($ssl, $identity) = @_;

        # Note: $identity is potentially hostile user supplied data

        my $sess = Net::SSLeay::SESSION_new();
        my $cipher = Net::SSLeay::CIPHER_find($ssl, pack('n', 0x1301));
        Net::SSLeay::SESSION_set1_master_key($sess, pack('H*', 'deadbeef'));
        Net::SSLeay::SESSION_set_cipher($sess, $cipher);
        Net::SSLeay::SESSION_set_protocol_version($sess, Net::SSLeay::version($ssl));

        return (1, $sess);
    }

    my $cb = \&tls13_psk_cb;
    Net::SSLeay::CTX_set_psk_find_session_callback($ctx, $cb);
    # $ctx - value corresponding to OpenSSL SSL_CTX structure
    # $cb - reference to callback function
    #
    # returns: no return value

The callback function must return a two value list. When the first
value is 0, the connection setup fails. When the first value is 1, the
second value must be a valid C<SSL_SESSION> or C<undef>. When the
second value is a valid C<SSL_SESSION>, the TLS handshake proceeds
with PSK authentication. When the the second value is C<undef>, PSK is
not used the TLS handshake proceeds with certificate authentication.

Check openssl doc L<https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_psk_find_session_callback.html>

=back

=head2 Constants

There are many openssl constants available in L<Net::SSLeay>. You can use them like this:

    use Net::SSLeay;
    print &Net::SSLeay::NID_commonName;
    # or
    print Net::SSLeay::NID_commonName();

Or you can import them and use:

    use Net::SSLeay qw/NID_commonName/;
    print &NID_commonName;
    # or
    print NID_commonName();
    # or
    print NID_commonName;

The constants names are derived from openssl constants, however constants starting with C<SSL_> prefix
have name with C<SSL_> part stripped - e.g. openssl's constant C<SSL_OP_ALL> is available as C<Net::SSLeay::OP_ALL>

The list of all available constant names:

=for comment

The list below is automatically generated - do not manually modify it.
To add or remove a constant, edit helper_script/constants.txt, then run
helper_script/update-exported-constants.

=for start_constants

    AD_ACCESS_DENIED                        OPENSSL_INIT_NO_LOAD_CRYPTO_STRINGS
    AD_BAD_CERTIFICATE                      OPENSSL_INIT_NO_LOAD_SSL_STRINGS
    AD_BAD_CERTIFICATE_HASH_VALUE           OPENSSL_MODULES_DIR
    AD_BAD_CERTIFICATE_STATUS_RESPONSE      OPENSSL_PLATFORM
    AD_BAD_RECORD_MAC                       OPENSSL_VERSION
    AD_CERTIFICATE_EXPIRED                  OPENSSL_VERSION_MAJOR
    AD_CERTIFICATE_REQUIRED                 OPENSSL_VERSION_MINOR
    AD_CERTIFICATE_REVOKED                  OPENSSL_VERSION_NUMBER
    AD_CERTIFICATE_UNKNOWN                  OPENSSL_VERSION_PATCH
    AD_CERTIFICATE_UNOBTAINABLE             OPENSSL_VERSION_STRING
    AD_CLOSE_NOTIFY                         OP_ALL
    AD_DECODE_ERROR                         OP_ALLOW_CLIENT_RENEGOTIATION
    AD_DECOMPRESSION_FAILURE                OP_ALLOW_NO_DHE_KEX
    AD_DECRYPTION_FAILED                    OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION
    AD_DECRYPT_ERROR                        OP_CIPHER_SERVER_PREFERENCE
    AD_EXPORT_RESTRICTION                   OP_CISCO_ANYCONNECT
    AD_HANDSHAKE_FAILURE                    OP_CLEANSE_PLAINTEXT
    AD_ILLEGAL_PARAMETER                    OP_COOKIE_EXCHANGE
    AD_INAPPROPRIATE_FALLBACK               OP_CRYPTOPRO_TLSEXT_BUG
    AD_INSUFFICIENT_SECURITY                OP_DISABLE_TLSEXT_CA_NAMES
    AD_INTERNAL_ERROR                       OP_DONT_INSERT_EMPTY_FRAGMENTS
    AD_MISSING_EXTENSION                    OP_ENABLE_KTLS
    AD_NO_APPLICATION_PROTOCOL              OP_ENABLE_MIDDLEBOX_COMPAT
    AD_NO_CERTIFICATE                       OP_EPHEMERAL_RSA
    AD_NO_RENEGOTIATION                     OP_IGNORE_UNEXPECTED_EOF
    AD_PROTOCOL_VERSION                     OP_LEGACY_SERVER_CONNECT
    AD_RECORD_OVERFLOW                      OP_MICROSOFT_BIG_SSLV3_BUFFER
    AD_UNEXPECTED_MESSAGE                   OP_MICROSOFT_SESS_ID_BUG
    AD_UNKNOWN_CA                           OP_MSIE_SSLV2_RSA_PADDING
    AD_UNKNOWN_PSK_IDENTITY                 OP_NETSCAPE_CA_DN_BUG
    AD_UNRECOGNIZED_NAME                    OP_NETSCAPE_CHALLENGE_BUG
    AD_UNSUPPORTED_CERTIFICATE              OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG
    AD_UNSUPPORTED_EXTENSION                OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG
    AD_USER_CANCELLED                       OP_NON_EXPORT_FIRST
    ASN1_STRFLGS_ESC_CTRL                   OP_NO_ANTI_REPLAY
    ASN1_STRFLGS_ESC_MSB                    OP_NO_CLIENT_RENEGOTIATION
    ASN1_STRFLGS_ESC_QUOTE                  OP_NO_COMPRESSION
    ASN1_STRFLGS_RFC2253                    OP_NO_ENCRYPT_THEN_MAC
    ASYNC_NO_JOBS                           OP_NO_EXTENDED_MASTER_SECRET
    ASYNC_PAUSED                            OP_NO_QUERY_MTU
    CB_ACCEPT_EXIT                          OP_NO_RENEGOTIATION
    CB_ACCEPT_LOOP                          OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION
    CB_ALERT                                OP_NO_SSL_MASK
    CB_CONNECT_EXIT                         OP_NO_SSLv2
    CB_CONNECT_LOOP                         OP_NO_SSLv3
    CB_EXIT                                 OP_NO_TICKET
    CB_HANDSHAKE_DONE                       OP_NO_TLSv1
    CB_HANDSHAKE_START                      OP_NO_TLSv1_1
    CB_LOOP                                 OP_NO_TLSv1_2
    CB_READ                                 OP_NO_TLSv1_3
    CB_READ_ALERT                           OP_PKCS1_CHECK_1
    CB_WRITE                                OP_PKCS1_CHECK_2
    CB_WRITE_ALERT                          OP_PRIORITIZE_CHACHA
    CLIENT_HELLO_CB                         OP_SAFARI_ECDHE_ECDSA_BUG
    CLIENT_HELLO_ERROR                      OP_SINGLE_DH_USE
    CLIENT_HELLO_RETRY                      OP_SINGLE_ECDH_USE
    CLIENT_HELLO_SUCCESS                    OP_SSLEAY_080_CLIENT_DH_BUG
    CONF_MFLAGS_DEFAULT_SECTION             OP_SSLREF2_REUSE_CERT_TYPE_BUG
    CONF_MFLAGS_IGNORE_ERRORS               OP_TLSEXT_PADDING
    CONF_MFLAGS_IGNORE_MISSING_FILE         OP_TLS_BLOCK_PADDING_BUG
    CONF_MFLAGS_IGNORE_RETURN_CODES         OP_TLS_D5_BUG
    CONF_MFLAGS_NO_DSO                      OP_TLS_ROLLBACK_BUG
    CONF_MFLAGS_SILENT                      READING
    ERROR_NONE                              RECEIVED_SHUTDOWN
    ERROR_SSL                               RETRY_VERIFY
    ERROR_SYSCALL                           RSA_3
    ERROR_WANT_ACCEPT                       RSA_F4
    ERROR_WANT_ASYNC                        R_BAD_AUTHENTICATION_TYPE
    ERROR_WANT_ASYNC_JOB                    R_BAD_CHECKSUM
    ERROR_WANT_CLIENT_HELLO_CB              R_BAD_MAC_DECODE
    ERROR_WANT_CONNECT                      R_BAD_RESPONSE_ARGUMENT
    ERROR_WANT_READ                         R_BAD_SSL_FILETYPE
    ERROR_WANT_RETRY_VERIFY                 R_BAD_SSL_SESSION_ID_LENGTH
    ERROR_WANT_WRITE                        R_BAD_STATE
    ERROR_WANT_X509_LOOKUP                  R_BAD_WRITE_RETRY
    ERROR_ZERO_RETURN                       R_CHALLENGE_IS_DIFFERENT
    EVP_PKS_DSA                             R_CIPHER_TABLE_SRC_ERROR
    EVP_PKS_EC                              R_INVALID_CHALLENGE_LENGTH
    EVP_PKS_RSA                             R_NO_CERTIFICATE_SET
    EVP_PKT_ENC                             R_NO_CERTIFICATE_SPECIFIED
    EVP_PKT_EXCH                            R_NO_CIPHER_LIST
    EVP_PKT_EXP                             R_NO_CIPHER_MATCH
    EVP_PKT_SIGN                            R_NO_PRIVATEKEY
    EVP_PK_DH                               R_NO_PUBLICKEY
    EVP_PK_DSA                              R_NULL_SSL_CTX
    EVP_PK_EC                               R_PEER_DID_NOT_RETURN_A_CERTIFICATE
    EVP_PK_RSA                              R_PEER_ERROR
    FILETYPE_ASN1                           R_PEER_ERROR_CERTIFICATE
    FILETYPE_PEM                            R_PEER_ERROR_NO_CIPHER
    F_CLIENT_CERTIFICATE                    R_PEER_ERROR_UNSUPPORTED_CERTIFICATE_TYPE
    F_CLIENT_HELLO                          R_PUBLIC_KEY_ENCRYPT_ERROR
    F_CLIENT_MASTER_KEY                     R_PUBLIC_KEY_IS_NOT_RSA
    F_D2I_SSL_SESSION                       R_READ_WRONG_PACKET_TYPE
    F_GET_CLIENT_FINISHED                   R_SHORT_READ
    F_GET_CLIENT_HELLO                      R_SSL_SESSION_ID_IS_DIFFERENT
    F_GET_CLIENT_MASTER_KEY                 R_UNABLE_TO_EXTRACT_PUBLIC_KEY
    F_GET_SERVER_FINISHED                   R_UNKNOWN_REMOTE_ERROR_TYPE
    F_GET_SERVER_HELLO                      R_UNKNOWN_STATE
    F_GET_SERVER_VERIFY                     R_X509_LIB
    F_I2D_SSL_SESSION                       SENT_SHUTDOWN
    F_READ_N                                SESSION_ASN1_VERSION
    F_REQUEST_CERTIFICATE                   SESS_CACHE_BOTH
    F_SERVER_HELLO                          SESS_CACHE_CLIENT
    F_SSL_CERT_NEW                          SESS_CACHE_NO_AUTO_CLEAR
    F_SSL_GET_NEW_SESSION                   SESS_CACHE_NO_INTERNAL
    F_SSL_NEW                               SESS_CACHE_NO_INTERNAL_LOOKUP
    F_SSL_READ                              SESS_CACHE_NO_INTERNAL_STORE
    F_SSL_RSA_PRIVATE_DECRYPT               SESS_CACHE_OFF
    F_SSL_RSA_PUBLIC_ENCRYPT                SESS_CACHE_SERVER
    F_SSL_SESSION_NEW                       SESS_CACHE_UPDATE_TIME
    F_SSL_SESSION_PRINT_FP                  SSL2_MT_CLIENT_CERTIFICATE
    F_SSL_SET_FD                            SSL2_MT_CLIENT_FINISHED
    F_SSL_SET_RFD                           SSL2_MT_CLIENT_HELLO
    F_SSL_SET_WFD                           SSL2_MT_CLIENT_MASTER_KEY
    F_SSL_USE_CERTIFICATE                   SSL2_MT_ERROR
    F_SSL_USE_CERTIFICATE_ASN1              SSL2_MT_REQUEST_CERTIFICATE
    F_SSL_USE_CERTIFICATE_FILE              SSL2_MT_SERVER_FINISHED
    F_SSL_USE_PRIVATEKEY                    SSL2_MT_SERVER_HELLO
    F_SSL_USE_PRIVATEKEY_ASN1               SSL2_MT_SERVER_VERIFY
    F_SSL_USE_PRIVATEKEY_FILE               SSL2_VERSION
    F_SSL_USE_RSAPRIVATEKEY                 SSL3_MT_CCS
    F_SSL_USE_RSAPRIVATEKEY_ASN1            SSL3_MT_CERTIFICATE
    F_SSL_USE_RSAPRIVATEKEY_FILE            SSL3_MT_CERTIFICATE_REQUEST
    F_WRITE_PENDING                         SSL3_MT_CERTIFICATE_STATUS
    GEN_DIRNAME                             SSL3_MT_CERTIFICATE_URL
    GEN_DNS                                 SSL3_MT_CERTIFICATE_VERIFY
    GEN_EDIPARTY                            SSL3_MT_CHANGE_CIPHER_SPEC
    GEN_EMAIL                               SSL3_MT_CLIENT_HELLO
    GEN_IPADD                               SSL3_MT_CLIENT_KEY_EXCHANGE
    GEN_OTHERNAME                           SSL3_MT_ENCRYPTED_EXTENSIONS
    GEN_RID                                 SSL3_MT_END_OF_EARLY_DATA
    GEN_URI                                 SSL3_MT_FINISHED
    GEN_X400                                SSL3_MT_HELLO_REQUEST
    LIBRESSL_VERSION_NUMBER                 SSL3_MT_KEY_UPDATE
    MBSTRING_ASC                            SSL3_MT_MESSAGE_HASH
    MBSTRING_BMP                            SSL3_MT_NEWSESSION_TICKET
    MBSTRING_FLAG                           SSL3_MT_NEXT_PROTO
    MBSTRING_UNIV                           SSL3_MT_SERVER_DONE
    MBSTRING_UTF8                           SSL3_MT_SERVER_HELLO
    MIN_RSA_MODULUS_LENGTH_IN_BYTES         SSL3_MT_SERVER_KEY_EXCHANGE
    MODE_ACCEPT_MOVING_WRITE_BUFFER         SSL3_MT_SUPPLEMENTAL_DATA
    MODE_ASYNC                              SSL3_RT_ALERT
    MODE_AUTO_RETRY                         SSL3_RT_APPLICATION_DATA
    MODE_ENABLE_PARTIAL_WRITE               SSL3_RT_CHANGE_CIPHER_SPEC
    MODE_NO_AUTO_CHAIN                      SSL3_RT_HANDSHAKE
    MODE_RELEASE_BUFFERS                    SSL3_RT_HEADER
    NID_OCSP_sign                           SSL3_RT_INNER_CONTENT_TYPE
    NID_SMIMECapabilities                   SSL3_VERSION
    NID_X500                                SSLEAY_BUILT_ON
    NID_X509                                SSLEAY_CFLAGS
    NID_ad_OCSP                             SSLEAY_DIR
    NID_ad_ca_issuers                       SSLEAY_PLATFORM
    NID_algorithm                           SSLEAY_VERSION
    NID_authority_key_identifier            ST_ACCEPT
    NID_basic_constraints                   ST_BEFORE
    NID_bf_cbc                              ST_CONNECT
    NID_bf_cfb64                            ST_INIT
    NID_bf_ecb                              ST_OK
    NID_bf_ofb64                            ST_READ_BODY
    NID_cast5_cbc                           ST_READ_HEADER
    NID_cast5_cfb64                         TLS1_1_VERSION
    NID_cast5_ecb                           TLS1_2_VERSION
    NID_cast5_ofb64                         TLS1_3_VERSION
    NID_certBag                             TLS1_VERSION
    NID_certificate_policies                TLSEXT_STATUSTYPE_ocsp
    NID_client_auth                         TLSEXT_TYPE_application_layer_protocol_negotiation
    NID_code_sign                           TLSEXT_TYPE_cert_type
    NID_commonName                          TLSEXT_TYPE_certificate_authorities
    NID_countryName                         TLSEXT_TYPE_client_authz
    NID_crlBag                              TLSEXT_TYPE_client_cert_type
    NID_crl_distribution_points             TLSEXT_TYPE_client_certificate_url
    NID_crl_number                          TLSEXT_TYPE_compress_certificate
    NID_crl_reason                          TLSEXT_TYPE_cookie
    NID_delta_crl                           TLSEXT_TYPE_early_data
    NID_des_cbc                             TLSEXT_TYPE_ec_point_formats
    NID_des_cfb64                           TLSEXT_TYPE_elliptic_curves
    NID_des_ecb                             TLSEXT_TYPE_encrypt_then_mac
    NID_des_ede                             TLSEXT_TYPE_extended_master_secret
    NID_des_ede3                            TLSEXT_TYPE_key_share
    NID_des_ede3_cbc                        TLSEXT_TYPE_max_fragment_length
    NID_des_ede3_cfb64                      TLSEXT_TYPE_next_proto_neg
    NID_des_ede3_ofb64                      TLSEXT_TYPE_padding
    NID_des_ede_cbc                         TLSEXT_TYPE_post_handshake_auth
    NID_des_ede_cfb64                       TLSEXT_TYPE_psk
    NID_des_ede_ofb64                       TLSEXT_TYPE_psk_kex_modes
    NID_des_ofb64                           TLSEXT_TYPE_quic_transport_parameters
    NID_description                         TLSEXT_TYPE_renegotiate
    NID_desx_cbc                            TLSEXT_TYPE_server_authz
    NID_dhKeyAgreement                      TLSEXT_TYPE_server_cert_type
    NID_dnQualifier                         TLSEXT_TYPE_server_name
    NID_dsa                                 TLSEXT_TYPE_session_ticket
    NID_dsaWithSHA                          TLSEXT_TYPE_signature_algorithms
    NID_dsaWithSHA1                         TLSEXT_TYPE_signature_algorithms_cert
    NID_dsaWithSHA1_2                       TLSEXT_TYPE_signed_certificate_timestamp
    NID_dsa_2                               TLSEXT_TYPE_srp
    NID_email_protect                       TLSEXT_TYPE_status_request
    NID_ext_key_usage                       TLSEXT_TYPE_supported_groups
    NID_ext_req                             TLSEXT_TYPE_supported_versions
    NID_friendlyName                        TLSEXT_TYPE_truncated_hmac
    NID_givenName                           TLSEXT_TYPE_trusted_ca_keys
    NID_hmacWithSHA1                        TLSEXT_TYPE_use_srtp
    NID_id_ad                               TLSEXT_TYPE_user_mapping
    NID_id_ce                               VERIFY_CLIENT_ONCE
    NID_id_kp                               VERIFY_FAIL_IF_NO_PEER_CERT
    NID_id_pbkdf2                           VERIFY_NONE
    NID_id_pe                               VERIFY_PEER
    NID_id_pkix                             VERIFY_POST_HANDSHAKE
    NID_id_qt_cps                           V_OCSP_CERTSTATUS_GOOD
    NID_id_qt_unotice                       V_OCSP_CERTSTATUS_REVOKED
    NID_idea_cbc                            V_OCSP_CERTSTATUS_UNKNOWN
    NID_idea_cfb64                          WRITING
    NID_idea_ecb                            X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT
    NID_idea_ofb64                          X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS
    NID_info_access                         X509_CHECK_FLAG_NEVER_CHECK_SUBJECT
    NID_initials                            X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS
    NID_invalidity_date                     X509_CHECK_FLAG_NO_WILDCARDS
    NID_issuer_alt_name                     X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS
    NID_keyBag                              X509_CRL_VERSION_1
    NID_key_usage                           X509_CRL_VERSION_2
    NID_localKeyID                          X509_FILETYPE_ASN1
    NID_localityName                        X509_FILETYPE_DEFAULT
    NID_md2                                 X509_FILETYPE_PEM
    NID_md2WithRSAEncryption                X509_LOOKUP
    NID_md5                                 X509_PURPOSE_ANY
    NID_md5WithRSA                          X509_PURPOSE_CRL_SIGN
    NID_md5WithRSAEncryption                X509_PURPOSE_NS_SSL_SERVER
    NID_md5_sha1                            X509_PURPOSE_OCSP_HELPER
    NID_mdc2                                X509_PURPOSE_SMIME_ENCRYPT
    NID_mdc2WithRSA                         X509_PURPOSE_SMIME_SIGN
    NID_ms_code_com                         X509_PURPOSE_SSL_CLIENT
    NID_ms_code_ind                         X509_PURPOSE_SSL_SERVER
    NID_ms_ctl_sign                         X509_PURPOSE_TIMESTAMP_SIGN
    NID_ms_efs                              X509_REQ_VERSION_1
    NID_ms_ext_req                          X509_REQ_VERSION_2
    NID_ms_sgc                              X509_REQ_VERSION_3
    NID_name                                X509_TRUST_COMPAT
    NID_netscape                            X509_TRUST_DEFAULT
    NID_netscape_base_url                   X509_TRUST_EMAIL
    NID_netscape_ca_policy_url              X509_TRUST_OBJECT_SIGN
    NID_netscape_ca_revocation_url          X509_TRUST_OCSP_REQUEST
    NID_netscape_cert_extension             X509_TRUST_OCSP_SIGN
    NID_netscape_cert_sequence              X509_TRUST_SSL_CLIENT
    NID_netscape_cert_type                  X509_TRUST_SSL_SERVER
    NID_netscape_comment                    X509_TRUST_TSA
    NID_netscape_data_type                  X509_VERSION_1
    NID_netscape_renewal_url                X509_VERSION_2
    NID_netscape_revocation_url             X509_VERSION_3
    NID_netscape_ssl_server_name            X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH
    NID_ns_sgc                              X509_V_ERR_AKID_SKID_MISMATCH
    NID_organizationName                    X509_V_ERR_APPLICATION_VERIFICATION
    NID_organizationalUnitName              X509_V_ERR_AUTHORITY_KEY_IDENTIFIER_CRITICAL
    NID_pbeWithMD2AndDES_CBC                X509_V_ERR_CA_BCONS_NOT_CRITICAL
    NID_pbeWithMD2AndRC2_CBC                X509_V_ERR_CA_CERT_MISSING_KEY_USAGE
    NID_pbeWithMD5AndCast5_CBC              X509_V_ERR_CA_KEY_TOO_SMALL
    NID_pbeWithMD5AndDES_CBC                X509_V_ERR_CA_MD_TOO_WEAK
    NID_pbeWithMD5AndRC2_CBC                X509_V_ERR_CERT_CHAIN_TOO_LONG
    NID_pbeWithSHA1AndDES_CBC               X509_V_ERR_CERT_HAS_EXPIRED
    NID_pbeWithSHA1AndRC2_CBC               X509_V_ERR_CERT_NOT_YET_VALID
    NID_pbe_WithSHA1And128BitRC2_CBC        X509_V_ERR_CERT_REJECTED
    NID_pbe_WithSHA1And128BitRC4            X509_V_ERR_CERT_REVOKED
    NID_pbe_WithSHA1And2_Key_TripleDES_CBC  X509_V_ERR_CERT_SIGNATURE_FAILURE
    NID_pbe_WithSHA1And3_Key_TripleDES_CBC  X509_V_ERR_CERT_UNTRUSTED
    NID_pbe_WithSHA1And40BitRC2_CBC         X509_V_ERR_CRL_HAS_EXPIRED
    NID_pbe_WithSHA1And40BitRC4             X509_V_ERR_CRL_NOT_YET_VALID
    NID_pbes2                               X509_V_ERR_CRL_PATH_VALIDATION_ERROR
    NID_pbmac1                              X509_V_ERR_CRL_SIGNATURE_FAILURE
    NID_pkcs                                X509_V_ERR_DANE_NO_MATCH
    NID_pkcs3                               X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT
    NID_pkcs7                               X509_V_ERR_DIFFERENT_CRL_SCOPE
    NID_pkcs7_data                          X509_V_ERR_EC_KEY_EXPLICIT_PARAMS
    NID_pkcs7_digest                        X509_V_ERR_EE_KEY_TOO_SMALL
    NID_pkcs7_encrypted                     X509_V_ERR_EMAIL_MISMATCH
    NID_pkcs7_enveloped                     X509_V_ERR_EMPTY_SUBJECT_ALT_NAME
    NID_pkcs7_signed                        X509_V_ERR_EMPTY_SUBJECT_SAN_NOT_CRITICAL
    NID_pkcs7_signedAndEnveloped            X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD
    NID_pkcs8ShroudedKeyBag                 X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD
    NID_pkcs9                               X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD
    NID_pkcs9_challengePassword             X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD
    NID_pkcs9_contentType                   X509_V_ERR_EXCLUDED_VIOLATION
    NID_pkcs9_countersignature              X509_V_ERR_EXTENSIONS_REQUIRE_VERSION_3
    NID_pkcs9_emailAddress                  X509_V_ERR_HOSTNAME_MISMATCH
    NID_pkcs9_extCertAttributes             X509_V_ERR_INVALID_CA
    NID_pkcs9_messageDigest                 X509_V_ERR_INVALID_CALL
    NID_pkcs9_signingTime                   X509_V_ERR_INVALID_EXTENSION
    NID_pkcs9_unstructuredAddress           X509_V_ERR_INVALID_NON_CA
    NID_pkcs9_unstructuredName              X509_V_ERR_INVALID_POLICY_EXTENSION
    NID_private_key_usage_period            X509_V_ERR_INVALID_PURPOSE
    NID_rc2_40_cbc                          X509_V_ERR_IP_ADDRESS_MISMATCH
    NID_rc2_64_cbc                          X509_V_ERR_ISSUER_NAME_EMPTY
    NID_rc2_cbc                             X509_V_ERR_KEYUSAGE_NO_CERTSIGN
    NID_rc2_cfb64                           X509_V_ERR_KEYUSAGE_NO_CRL_SIGN
    NID_rc2_ecb                             X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE
    NID_rc2_ofb64                           X509_V_ERR_KU_KEY_CERT_SIGN_INVALID_FOR_NON_CA
    NID_rc4                                 X509_V_ERR_MISSING_AUTHORITY_KEY_IDENTIFIER
    NID_rc4_40                              X509_V_ERR_MISSING_SUBJECT_KEY_IDENTIFIER
    NID_rc5_cbc                             X509_V_ERR_NO_EXPLICIT_POLICY
    NID_rc5_cfb64                           X509_V_ERR_NO_ISSUER_PUBLIC_KEY
    NID_rc5_ecb                             X509_V_ERR_NO_VALID_SCTS
    NID_rc5_ofb64                           X509_V_ERR_OCSP_CERT_UNKNOWN
    NID_ripemd160                           X509_V_ERR_OCSP_VERIFY_FAILED
    NID_ripemd160WithRSA                    X509_V_ERR_OCSP_VERIFY_NEEDED
    NID_rle_compression                     X509_V_ERR_OUT_OF_MEM
    NID_rsa                                 X509_V_ERR_PATHLEN_INVALID_FOR_NON_CA
    NID_rsaEncryption                       X509_V_ERR_PATHLEN_WITHOUT_KU_KEY_CERT_SIGN
    NID_rsadsi                              X509_V_ERR_PATH_LENGTH_EXCEEDED
    NID_safeContentsBag                     X509_V_ERR_PATH_LOOP
    NID_sdsiCertificate                     X509_V_ERR_PERMITTED_VIOLATION
    NID_secretBag                           X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED
    NID_serialNumber                        X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED
    NID_server_auth                         X509_V_ERR_PROXY_SUBJECT_NAME_VIOLATION
    NID_sha                                 X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN
    NID_sha1                                X509_V_ERR_SIGNATURE_ALGORITHM_INCONSISTENCY
    NID_sha1WithRSA                         X509_V_ERR_SIGNATURE_ALGORITHM_MISMATCH
    NID_sha1WithRSAEncryption               X509_V_ERR_STORE_LOOKUP
    NID_sha224                              X509_V_ERR_SUBJECT_ISSUER_MISMATCH
    NID_sha224WithRSAEncryption             X509_V_ERR_SUBJECT_KEY_IDENTIFIER_CRITICAL
    NID_sha256                              X509_V_ERR_SUBJECT_NAME_EMPTY
    NID_sha256WithRSAEncryption             X509_V_ERR_SUBTREE_MINMAX
    NID_sha384                              X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256
    NID_sha384WithRSAEncryption             X509_V_ERR_SUITE_B_INVALID_ALGORITHM
    NID_sha3_224                            X509_V_ERR_SUITE_B_INVALID_CURVE
    NID_sha3_256                            X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM
    NID_sha3_384                            X509_V_ERR_SUITE_B_INVALID_VERSION
    NID_sha3_512                            X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED
    NID_sha512                              X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY
    NID_sha512WithRSAEncryption             X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE
    NID_sha512_224                          X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE
    NID_sha512_224WithRSAEncryption         X509_V_ERR_UNABLE_TO_GET_CRL
    NID_sha512_256                          X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER
    NID_sha512_256WithRSAEncryption         X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT
    NID_shaWithRSAEncryption                X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY
    NID_shake128                            X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE
    NID_shake256                            X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION
    NID_stateOrProvinceName                 X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION
    NID_subject_alt_name                    X509_V_ERR_UNNESTED_RESOURCE
    NID_subject_key_identifier              X509_V_ERR_UNSPECIFIED
    NID_surname                             X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX
    NID_sxnet                               X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE
    NID_time_stamp                          X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE
    NID_title                               X509_V_ERR_UNSUPPORTED_NAME_SYNTAX
    NID_undef                               X509_V_ERR_UNSUPPORTED_SIGNATURE_ALGORITHM
    NID_uniqueIdentifier                    X509_V_FLAG_ALLOW_PROXY_CERTS
    NID_x509Certificate                     X509_V_FLAG_CB_ISSUER_CHECK
    NID_x509Crl                             X509_V_FLAG_CHECK_SS_SIGNATURE
    NID_zlib_compression                    X509_V_FLAG_CRL_CHECK
    NOTHING                                 X509_V_FLAG_CRL_CHECK_ALL
    OCSP_RESPONSE_STATUS_INTERNALERROR      X509_V_FLAG_EXPLICIT_POLICY
    OCSP_RESPONSE_STATUS_MALFORMEDREQUEST   X509_V_FLAG_EXTENDED_CRL_SUPPORT
    OCSP_RESPONSE_STATUS_SIGREQUIRED        X509_V_FLAG_IGNORE_CRITICAL
    OCSP_RESPONSE_STATUS_SUCCESSFUL         X509_V_FLAG_INHIBIT_ANY
    OCSP_RESPONSE_STATUS_TRYLATER           X509_V_FLAG_INHIBIT_MAP
    OCSP_RESPONSE_STATUS_UNAUTHORIZED       X509_V_FLAG_LEGACY_VERIFY
    OPENSSL_BUILT_ON                        X509_V_FLAG_NOTIFY_POLICY
    OPENSSL_CFLAGS                          X509_V_FLAG_NO_ALT_CHAINS
    OPENSSL_CPU_INFO                        X509_V_FLAG_NO_CHECK_TIME
    OPENSSL_DIR                             X509_V_FLAG_PARTIAL_CHAIN
    OPENSSL_ENGINES_DIR                     X509_V_FLAG_POLICY_CHECK
    OPENSSL_FULL_VERSION_STRING             X509_V_FLAG_POLICY_MASK
    OPENSSL_INFO_CONFIG_DIR                 X509_V_FLAG_SUITEB_128_LOS
    OPENSSL_INFO_CPU_SETTINGS               X509_V_FLAG_SUITEB_128_LOS_ONLY
    OPENSSL_INFO_DIR_FILENAME_SEPARATOR     X509_V_FLAG_SUITEB_192_LOS
    OPENSSL_INFO_DSO_EXTENSION              X509_V_FLAG_TRUSTED_FIRST
    OPENSSL_INFO_ENGINES_DIR                X509_V_FLAG_USE_CHECK_TIME
    OPENSSL_INFO_LIST_SEPARATOR             X509_V_FLAG_USE_DELTAS
    OPENSSL_INFO_MODULES_DIR                X509_V_FLAG_X509_STRICT
    OPENSSL_INFO_SEED_SOURCE                X509_V_OK
    OPENSSL_INIT_ADD_ALL_CIPHERS            XN_FLAG_COMPAT
    OPENSSL_INIT_ADD_ALL_DIGESTS            XN_FLAG_DN_REV
    OPENSSL_INIT_ASYNC                      XN_FLAG_DUMP_UNKNOWN_FIELDS
    OPENSSL_INIT_ATFORK                     XN_FLAG_FN_ALIGN
    OPENSSL_INIT_ENGINE_AFALG               XN_FLAG_FN_LN
    OPENSSL_INIT_ENGINE_CAPI                XN_FLAG_FN_MASK
    OPENSSL_INIT_ENGINE_CRYPTODEV           XN_FLAG_FN_NONE
    OPENSSL_INIT_ENGINE_DYNAMIC             XN_FLAG_FN_OID
    OPENSSL_INIT_ENGINE_OPENSSL             XN_FLAG_FN_SN
    OPENSSL_INIT_ENGINE_PADLOCK             XN_FLAG_MULTILINE
    OPENSSL_INIT_ENGINE_RDRAND              XN_FLAG_ONELINE
    OPENSSL_INIT_LOAD_CONFIG                XN_FLAG_RFC2253
    OPENSSL_INIT_LOAD_CRYPTO_STRINGS        XN_FLAG_SEP_COMMA_PLUS
    OPENSSL_INIT_LOAD_SSL_STRINGS           XN_FLAG_SEP_CPLUS_SPC
    OPENSSL_INIT_NO_ADD_ALL_CIPHERS         XN_FLAG_SEP_MASK
    OPENSSL_INIT_NO_ADD_ALL_DIGESTS         XN_FLAG_SEP_MULTILINE
    OPENSSL_INIT_NO_ATEXIT                  XN_FLAG_SEP_SPLUS_SPC
    OPENSSL_INIT_NO_LOAD_CONFIG             XN_FLAG_SPC_EQ

=for end_constants

=head2 INTERNAL ONLY functions (do not use these)

The following functions are not intended for use from outside of L<Net::SSLeay> module.
They might be removed, renamed or changed without prior notice in future version.

Simply B<DO NOT USE THEM>!

=over

=item * hello

=item * blength

=item * constant

=back

=head1 EXAMPLES

One very good example to look at is the implementation of C<sslcat()> in the
C<SSLeay.pm> file.

The following is a simple SSLeay client (with too little error checking :-(

    #!/usr/bin/perl
    use Socket;
    use Net::SSLeay qw(die_now die_if_ssl_error) ;
    Net::SSLeay::load_error_strings();
    Net::SSLeay::SSLeay_add_ssl_algorithms();
    Net::SSLeay::randomize();

    ($dest_serv, $port, $msg) = @ARGV;      # Read command line
    $port = getservbyname ($port, 'tcp') unless $port =~ /^\d+$/;
    $dest_ip = gethostbyname ($dest_serv);
    $dest_serv_params  = sockaddr_in($port, $dest_ip);

    socket  (S, &AF_INET, &SOCK_STREAM, 0)  or die "socket: $!";
    connect (S, $dest_serv_params)          or die "connect: $!";
    select  (S); $| = 1; select (STDOUT);   # Eliminate STDIO buffering

    # The network connection is now open, lets fire up SSL

    $ctx = Net::SSLeay::CTX_new() or die_now("Failed to create SSL_CTX $!");
    Net::SSLeay::CTX_set_options($ctx, &Net::SSLeay::OP_ALL)
         or die_if_ssl_error("ssl ctx set options");
    $ssl = Net::SSLeay::new($ctx) or die_now("Failed to create SSL $!");
    Net::SSLeay::set_fd($ssl, fileno(S));   # Must use fileno
    $res = Net::SSLeay::connect($ssl) and die_if_ssl_error("ssl connect");
    print "Cipher `" . Net::SSLeay::get_cipher($ssl) . "'\n";

    # Exchange data

    $res = Net::SSLeay::write($ssl, $msg);  # Perl knows how long $msg is
    die_if_ssl_error("ssl write");
    CORE::shutdown S, 1;  # Half close --> No more output, sends EOF to server
    $got = Net::SSLeay::read($ssl);         # Perl returns undef on failure
    die_if_ssl_error("ssl read");
    print $got;

    Net::SSLeay::free ($ssl);               # Tear down connection
    Net::SSLeay::CTX_free ($ctx);
    close S;

The following is a simple SSLeay echo server (non forking):

    #!/usr/bin/perl -w
    use Socket;
    use Net::SSLeay qw(die_now die_if_ssl_error);
    Net::SSLeay::load_error_strings();
    Net::SSLeay::SSLeay_add_ssl_algorithms();
    Net::SSLeay::randomize();

    $our_ip = "\0\0\0\0"; # Bind to all interfaces
    $port = 1235;
    $sockaddr_template = 'S n a4 x8';
    $our_serv_params = pack ($sockaddr_template, &AF_INET, $port, $our_ip);

    socket (S, &AF_INET, &SOCK_STREAM, 0)  or die "socket: $!";
    bind (S, $our_serv_params)             or die "bind:   $!";
    listen (S, 5)                          or die "listen: $!";
    $ctx = Net::SSLeay::CTX_new ()         or die_now("CTX_new ($ctx): $!");
    Net::SSLeay::CTX_set_options($ctx, &Net::SSLeay::OP_ALL)
         or die_if_ssl_error("ssl ctx set options");

    # Following will ask password unless private key is not encrypted
    Net::SSLeay::CTX_use_RSAPrivateKey_file ($ctx, 'plain-rsa.pem',
                                             &Net::SSLeay::FILETYPE_PEM);
    die_if_ssl_error("private key");
    Net::SSLeay::CTX_use_certificate_file ($ctx, 'plain-cert.pem',
                                            &Net::SSLeay::FILETYPE_PEM);
    die_if_ssl_error("certificate");

    while (1) {
        print "Accepting connections...\n";
        ($addr = accept (NS, S))           or die "accept: $!";
        select (NS); $| = 1; select (STDOUT);  # Piping hot!

        ($af,$client_port,$client_ip) = unpack($sockaddr_template,$addr);
        @inetaddr = unpack('C4',$client_ip);
        print "$af connection from " .
        join ('.', @inetaddr) . ":$client_port\n";

        # We now have a network connection, lets fire up SSLeay...

        $ssl = Net::SSLeay::new($ctx)      or die_now("SSL_new ($ssl): $!");
        Net::SSLeay::set_fd($ssl, fileno(NS));

        $err = Net::SSLeay::accept($ssl) and die_if_ssl_error('ssl accept');
        print "Cipher `" . Net::SSLeay::get_cipher($ssl) . "'\n";

        # Connected. Exchange some data.

        $got = Net::SSLeay::read($ssl);     # Returns undef on fail
        die_if_ssl_error("ssl read");
        print "Got `$got' (" . length ($got) . " chars)\n";

        Net::SSLeay::write ($ssl, uc ($got)) or die "write: $!";
        die_if_ssl_error("ssl write");

        Net::SSLeay::free ($ssl);           # Tear down connection
        close NS;
    }

Yet another echo server. This one runs from C</etc/inetd.conf> so it avoids
all the socket code overhead. Only caveat is opening an rsa key file -
it had better be without any encryption or else it will not know where
to ask for the password. Note how C<STDIN> and C<STDOUT> are wired to SSL.

    #!/usr/bin/perl
    # /etc/inetd.conf
    #    ssltst stream tcp nowait root /path/to/server.pl server.pl
    # /etc/services
    #    ssltst        1234/tcp

    use Net::SSLeay qw(die_now die_if_ssl_error);
    Net::SSLeay::load_error_strings();
    Net::SSLeay::SSLeay_add_ssl_algorithms();
    Net::SSLeay::randomize();

    chdir '/key/dir' or die "chdir: $!";
    $| = 1;  # Piping hot!
    open LOG, ">>/dev/console" or die "Can't open log file $!";
    select LOG; print "server.pl started\n";

    $ctx = Net::SSLeay::CTX_new()     or die_now "CTX_new ($ctx) ($!)";
    $ssl = Net::SSLeay::new($ctx)     or die_now "new ($ssl) ($!)";
    Net::SSLeay::set_options($ssl, &Net::SSLeay::OP_ALL)
        and die_if_ssl_error("ssl set options");

    # We get already open network connection from inetd, now we just
    # need to attach SSLeay to STDIN and STDOUT
    Net::SSLeay::set_rfd($ssl, fileno(STDIN));
    Net::SSLeay::set_wfd($ssl, fileno(STDOUT));

    Net::SSLeay::use_RSAPrivateKey_file ($ssl, 'plain-rsa.pem',
                                         Net::SSLeay::FILETYPE_PEM);
    die_if_ssl_error("private key");
    Net::SSLeay::use_certificate_file ($ssl, 'plain-cert.pem',
                                       Net::SSLeay::FILETYPE_PEM);
    die_if_ssl_error("certificate");

    Net::SSLeay::accept($ssl) and die_if_ssl_err("ssl accept: $!");
    print "Cipher `" . Net::SSLeay::get_cipher($ssl) . "'\n";

    $got = Net::SSLeay::read($ssl);
    die_if_ssl_error("ssl read");
    print "Got `$got' (" . length ($got) . " chars)\n";

    Net::SSLeay::write ($ssl, uc($got)) or die "write: $!";
    die_if_ssl_error("ssl write");

    Net::SSLeay::free ($ssl);         # Tear down the connection
    Net::SSLeay::CTX_free ($ctx);
    close LOG;

There are also a number of example/test programs in the examples directory:

    sslecho.pl   -  A simple server, not unlike the one above
    minicli.pl   -  Implements a client using low level SSLeay routines
    sslcat.pl    -  Demonstrates using high level sslcat utility function
    get_page.pl  -  Is a utility for getting html pages from secure servers
    callback.pl  -  Demonstrates certificate verification and callback usage
    stdio_bulk.pl       - Does SSL over Unix pipes
    ssl-inetd-serv.pl   - SSL server that can be invoked from inetd.conf
    httpd-proxy-snif.pl - Utility that allows you to see how a browser
                          sends https request to given server and what reply
                          it gets back (very educative :-)
    makecert.pl  -  Creates a self signed cert (does not use this module)

=head1 INSTALLATION

See README and README.* in the distribution directory for installation guidance on a variety of platforms.

=head1 LIMITATIONS

C<Net::SSLeay::read()> uses an internal buffer of 32KB, thus no single read
will return more. In practice one read returns much less, usually
as much as fits in one network packet. To work around this,
you should use a loop like this:

    $reply = '';
    while ($got = Net::SSLeay::read($ssl)) {
        last if print_errs('SSL_read');
        $reply .= $got;
    }

Although there is no built-in limit in C<Net::SSLeay::write()>, the network
packet size limitation applies here as well, thus use:

    $written = 0;

    while ($written < length($message)) {
        $written += Net::SSLeay::write($ssl, substr($message, $written));
        last if print_errs('SSL_write');
    }

Or alternatively you can just use the following convenience functions:

    Net::SSLeay::ssl_write_all($ssl, $message) or die "ssl write failure";
    $got = Net::SSLeay::ssl_read_all($ssl) or die "ssl read failure";

=head1 KNOWN BUGS AND CAVEATS

LibreSSL versions in the 3.1 - 3.3 series contain a TLS 1.3 implementation that
is not fully compatible with the libssl API, but is still advertised during
protocol auto-negotiation. If you encounter problems or unexpected behaviour
with SSL or SSL_CTX objects whose protocol version was automatically negotiated
and libssl is provided by any of these versions of LibreSSL, it could be because
the peers negotiated to use TLS 1.3 - try setting the maximum protocol version
to TLS 1.2 (via C<Net::SSLeay::set_max_proto_version()> or
C<Net::SSLeay::CTX_set_max_proto_version()>) before establishing the connection.
The first stable LibreSSL version with a fully libssl-compatible TLS 1.3
implementation is 3.4.1.

An OpenSSL bug CVE-2015-0290 "OpenSSL Multiblock Corrupted Pointer Issue"
can cause POST requests of over 90kB to fail or crash. This bug is reported to be fixed in
OpenSSL 1.0.2a.

Autoloader emits a

    Argument "xxx" isn't numeric in entersub at blib/lib/Net/SSLeay.pm'

warning if die_if_ssl_error is made autoloadable. If you figure out why,
drop me a line.

Callback set using C<SSL_set_verify()> does not appear to work. This may
well be an openssl problem (e.g. see C<ssl/ssl_lib.c> line 1029). Try using
C<SSL_CTX_set_verify()> instead and do not be surprised if even this stops
working in future versions.

Callback and certificate verification stuff is generally too little tested.

Random numbers are not initialized randomly enough, especially if you
do not have C</dev/random> and/or C</dev/urandom> (such as in Solaris
platforms - but it's been suggested that cryptorand daemon from the SUNski
package solves this). In this case you should investigate third party
software that can emulate these devices, e.g. by way of a named pipe
to some program.

Another gotcha with random number initialization is randomness
depletion. This phenomenon, which has been extensively discussed in
OpenSSL, Apache-SSL, and Apache-mod_ssl forums, can cause your
script to block if you use C</dev/random> or to operate insecurely
if you use C</dev/urandom>. What happens is that when too much
randomness is drawn from the operating system's randomness pool
then randomness can temporarily be unavailable. C</dev/random> solves
this problem by waiting until enough randomness can be gathered - and
this can take a long time since blocking reduces activity in the
machine and less activity provides less random events: a vicious circle.
C</dev/urandom> solves this dilemma more pragmatically by simply returning
predictable "random" numbers. Some C</dev/urandom> emulation software
however actually seems to implement C</dev/random> semantics. Caveat emptor.

I've been pointed to two such daemons by Mik Firestone <mik@@speed.stdio._com>
who has used them on Solaris 8:

=over

=item 1

Entropy Gathering Daemon (EGD) at L<https://egd.sourceforge.net/>

=item 2

Pseudo-random number generating daemon (PRNGD) at
L<https://prngd.sourceforge.net/>

=back

If you are using the low level API functions to communicate with other
SSL implementations, you would do well to call

    Net::SSLeay::CTX_set_options($ctx, &Net::SSLeay::OP_ALL)
        or die_if_ssl_error("ssl ctx set options");

to cope with some well know bugs in some other SSL
implementations. The high level API functions always set all known
compatibility options.

Sometimes C<sslcat()> (and the high level HTTPS functions that build on it)
is too fast in signaling the EOF to legacy HTTPS servers. This causes
the server to return empty page. To work around this problem you can
set the global variable

    $Net::SSLeay::slowly = 1;   # Add sleep so broken servers can keep up

HTTP/1.1 is not supported. Specifically this module does not know to
issue or serve multiple http requests per connection. This is a serious
shortcoming, but using the SSL session cache on your server helps to
alleviate the CPU load somewhat.

As of version 1.09 many newer OpenSSL auxiliary functions were
added (from C<REM_AUTOMATICALLY_GENERATED_1_09> onwards in C<SSLeay.xs>).
Unfortunately I have not had any opportunity to test these. Some of
them are trivial enough that I believe they "just work", but others
have rather complex interfaces with function pointers and all. In these
cases you should proceed wit great caution.

This module defaults to using OpenSSL automatic protocol negotiation
code for automatically detecting the version of the SSL/TLS protocol
that the other end talks. With most web servers this works just
fine, but once in a while I get complaints from people that the module
does not work with some web servers. Usually this can be solved
by explicitly setting the protocol version, e.g.

    $Net::SSLeay::ssl_version = 2;  # Insist on SSLv2
    $Net::SSLeay::ssl_version = 3;  # Insist on SSLv3
    $Net::SSLeay::ssl_version = 10; # Insist on TLSv1
    $Net::SSLeay::ssl_version = 11; # Insist on TLSv1.1
    $Net::SSLeay::ssl_version = 12; # Insist on TLSv1.2
    $Net::SSLeay::ssl_version = 13; # Insist on TLSv1.3

Although the autonegotiation is nice to have, the SSL standards
do not formally specify any such mechanism. Most of the world has
accepted the SSLeay/OpenSSL way of doing it as the de facto standard. But
for the few that think differently, you have to explicitly speak
the correct version. This is not really a bug, but rather a deficiency
in the standards. If a site refuses to respond or sends back some
nonsensical error codes (at the SSL handshake level), try this option
before mailing me.

On some systems, OpenSSL may be compiled without support for SSLv2.
If this is the case, Net::SSLeay will warn if ssl_version has been set
to 2.
