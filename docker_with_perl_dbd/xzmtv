 * Tests whether the value of n would be truncated when implicitly cast to
 * SSize_t as an arg to stack_grow(). If so, sets it to -1 instead to
 * trigger a panic. It will be constant folded on platforms where this
 * can't happen.
 */

#define _EXTEND_SAFE_N(n) \
        (sizeof(n) > sizeof(SSize_t) && ((SSize_t)(n) != (n)) ? -1 : (n))

#ifdef STRESS_REALLOC
# define EXTEND_SKIP(p, n) EXTEND_HWM_SET(p, n)

# define EXTEND(p,n)   STMT_START {                                     \
                           sp = stack_grow(sp,p,_EXTEND_SAFE_N(n));     \
                           PERL_UNUSED_VAR(sp);                         \
                       } STMT_END
/* Same thing, but update mark register too. */
# define MEXTEND(p,n)   STMT_START {                                    \
                            const SSize_t markoff = mark - PL_stack_base; \
                            sp = stack_grow(sp,p,_EXTEND_SAFE_N(n));    \
                            mark = PL_stack_base + markoff;             \
                            PERL_UNUSED_VAR(sp);                        \
                        } STMT_END
#else

/* _EXTEND_NEEDS_GROW(p,n): private helper macro for EXTEND().
 * Tests to see whether n is too big and we need to grow the stack. Be
 * very careful if modifying this. There are many ways to get things wrong
 * (wrapping, truncating etc) that could cause a false negative and cause
 * the call to stack_grow() to be skipped. On the other hand, false
 * positives are safe.
 * Bear in mind that sizeof(p) may be less than, equal to, or greater
 * than sizeof(n), and while n is documented to be signed, someone might
 * pass an unsigned value or expression. In general don't use casts to
 * avoid warnings; instead expect the caller to fix their code.
 * It is legal for p to be greater than PL_stack_max.
 * If the allocated stack is already very large but current usage is
 * small, then PL_stack_max - p might wrap round to a negative value, but
 * this just gives a safe false positive
 */

#  define _EXTEND_NEEDS_GROW(p,n) ((n) < 0 || PL_stack_max - (p) < (n))


/* EXTEND_SKIP(): used for where you would normally call EXTEND(), but
 * you know for sure that a previous op will have already extended the
 * stack sufficiently.  For example pp_enteriter ensures that there
 * is always at least 1 free slot, so pp_iter can return &PL_sv_yes/no
 * without checking each time. Calling EXTEND_SKIP() defeats the HWM
 * debugging mechanism which would otherwise whine
 */

#  define EXTEND_SKIP(p, n) STMT_START {                                \
                                EXTEND_HWM_SET(p, n);                   \
                                assert(!_EXTEND_NEEDS_GROW(p,n));       \
                            } STMT_END


#  define EXTEND(p,n)   STMT_START {                                    \
                         EXTEND_HWM_SET(p, n);                          \
                         if (UNLIKELY(_EXTEND_NEEDS_GROW(p,n))) {       \
                           sp = stack_grow(sp,p,_EXTEND_SAFE_N(n));     \
                           PERL_UNUSED_VAR(sp);                         \
                         }                                              \
                        } STMT_END
/* Same thing, but update mark register too. */
#  define MEXTEND(p,n)  STMT_START {                                    \
                         EXTEND_HWM_SET(p, n);                          \
                         if (UNLIKELY(_EXTEND_NEEDS_GROW(p,n))) {       \
                           const SSize_t markoff = mark - PL_stack_base;\
                           sp = stack_grow(sp,p,_EXTEND_SAFE_N(n));     \
                           mark = PL_stack_base + markoff;              \
                           PERL_UNUSED_VAR(sp);                         \
                         }                                              \
                        } STMT_END
#endif


/* set TARG to the IV value i. If do_taint is false,
 * assume that PL_tainted can never be true */
#define TARGi(i, do_taint) \
    STMT_START {                                                        \
        IV TARGi_iv = i;                                                \
        if (LIKELY(                                                     \
              ((SvFLAGS(TARG) & (SVTYPEMASK|SVf_THINKFIRST|SVf_IVisUV)) == SVt_IV) \
            & (do_taint ? !TAINT_get : 1)))                             \
        {                                                               \
            /* Cheap SvIOK_only().                                      \
             * Assert that flags which SvIOK_only() would test or       \
             * clear can't be set, because we're SVt_IV */              \
            assert(!(SvFLAGS(TARG) &                                    \
                (SVf_OOK|SVf_UTF8|(SVf_OK & ~(SVf_IOK|SVp_IOK)))));     \
            SvFLAGS(TARG) |= (SVf_IOK|SVp_IOK);                         \
            /* SvIV_set() where sv_any points to head */                \
            TARG->sv_u.svu_iv = TARGi_iv;                               \
        }                                                               \
        else                                                            \
            sv_setiv_mg(targ, TARGi_iv);                                \
    } STMT_END

/* set TARG to the UV value u. If do_taint is false,
 * assume that PL_tainted can never be true */
#define TARGu(u, do_taint) \
    STMT_START {                                                        \
        UV TARGu_uv = u;                                                \
        if (LIKELY(                                                     \
              ((SvFLAGS(TARG) & (SVTYPEMASK|SVf_THINKFIRST|SVf_IVisUV)) == SVt_IV) \
            & (do_taint ? !TAINT_get : 1)                               \
            & (TARGu_uv <= (UV)IV_MAX)))                                \
        {                                                               \
            /* Cheap SvIOK_only().                                      \
             * Assert that flags which SvIOK_only() would test or       \
             * clear can't be set, because we're SVt_IV */              \
            assert(!(SvFLAGS(TARG) &                                    \
                (SVf_OOK|SVf_UTF8|(SVf_OK & ~(SVf_IOK|SVp_IOK)))));     \
            SvFLAGS(TARG) |= (SVf_IOK|SVp_IOK);                         \
            /* SvIV_set() where sv_any points to head */                \
            TARG->sv_u.svu_iv = TARGu_uv;                               \
        }                                                               \
        else                                                            \
            sv_setuv_mg(targ, TARGu_uv);                                \
    } STMT_END

/* set TARG to the NV value n. If do_taint is false,
 * assume that PL_tainted can never be true */
#define TARGn(n, do_taint) \
    STMT_START {                                                        \
        NV TARGn_nv = n;                                                \
        if (LIKELY(                                                     \
              ((SvFLAGS(TARG) & (SVTYPEMASK|SVf_THINKFIRST)) == SVt_NV) \
            & (do_taint ? !TAINT_get : 1)))                             \
        {                                                               \
            /* Cheap SvNOK_only().                                      \
             * Assert that flags which SvNOK_only() would test or       \
             * clear can't be set, because we're SVt_NV */              \
            assert(!(SvFLAGS(TARG) &                                    \
                (SVf_OOK|SVf_UTF8|(SVf_OK & ~(SVf_NOK|SVp_NOK)))));     \
            SvFLAGS(TARG) |= (SVf_NOK|SVp_NOK);                         \
            SvNV_set(TARG, TARGn_nv);                                   \
        }                                                               \
        else                                                            \
            sv_setnv_mg(targ, TARGn_nv);                                \
    } STMT_END

#ifdef PERL_RC_STACK
#  define PUSHs(s)	(assert(!rpp_stack_is_rc()), *++sp = (s))
#else
#  define PUSHs(s)	(*++sp = (s))
#endif

#define PUSHTARG	STMT_START { SvSETMAGIC(TARG); PUSHs(TARG); } STMT_END
#define PUSHp(p,l)	STMT_START { sv_setpvn(TARG, (p), (l)); PUSHTARG; } STMT_END
#define PUSHpvs(s)      PUSHp("" s "", sizeof(s)-1)
#define PUSHn(n)	STMT_START { TARGn(n,1); PUSHs(TARG); } STMT_END
#define PUSHi(i)	STMT_START { TARGi(i,1); PUSHs(TARG); } STMT_END
#define PUSHu(u)	STMT_START { TARGu(u,1); PUSHs(TARG); } STMT_END

#define XPUSHs(s)	STMT_START { EXTEND(sp,1); PUSHs(s); } STMT_END
#define XPUSHTARG	STMT_START { SvSETMAGIC(TARG); XPUSHs(TARG); } STMT_END
#define XPUSHp(p,l)	STMT_START { sv_setpvn(TARG, (p), (l)); XPUSHTARG; } STMT_END
#define XPUSHpvs(s)     XPUSHp("" s "", sizeof(s)-1)
#define XPUSHn(n)	STMT_START { TARGn(n,1); XPUSHs(TARG); } STMT_END
#define XPUSHi(i)	STMT_START { TARGi(i,1); XPUSHs(TARG); } STMT_END
#define XPUSHu(u)	STMT_START { TARGu(u,1); XPUSHs(TARG); } STMT_END
#define XPUSHundef	STMT_START { SvOK_off(TARG); XPUSHs(TARG); } STMT_END

#define mPUSHs(s)	PUSHs(sv_2mortal(s))
#define PUSHmortal	PUSHs(sv_newmortal())
#define mPUSHp(p,l)	PUSHs(newSVpvn_flags((p), (l), SVs_TEMP))
#define mPUSHpvs(s)     mPUSHp("" s "", sizeof(s)-1)
#define mPUSHn(n)	sv_setnv(PUSHmortal, (NV)(n))
#define mPUSHi(i)	sv_setiv(PUSHmortal, (IV)(i))
#define mPUSHu(u)	sv_setuv(PUSHmortal, (UV)(u))

#define mXPUSHs(s)	XPUSHs(sv_2mortal(s))
#define XPUSHmortal	XPUSHs(sv_newmortal())
#define mXPUSHp(p,l)	STMT_START { EXTEND(sp,1); mPUSHp((p), (l)); } STMT_END
#define mXPUSHpvs(s)    mXPUSHp("" s "", sizeof(s)-1)
#define mXPUSHn(n)	STMT_START { EXTEND(sp,1); mPUSHn(n); } STMT_END
#define mXPUSHi(i)	STMT_START { EXTEND(sp,1); mPUSHi(i); } STMT_END
#define mXPUSHu(u)	STMT_START { EXTEND(sp,1); mPUSHu(u); } STMT_END

#define SETs(s)		(*sp = s)
#define SETTARG		STMT_START { SvSETMAGIC(TARG); SETs(TARG); } STMT_END
#define SETp(p,l)	STMT_START { sv_setpvn(TARG, (p), (l)); SETTARG; } STMT_END
#define SETn(n)		STMT_START { TARGn(n,1); SETs(TARG); } STMT_END
#define SETi(i)		STMT_START { TARGi(i,1); SETs(TARG); } STMT_END
#define SETu(u)		STMT_START { TARGu(u,1); SETs(TARG); } STMT_END

#define dTOPss		SV *sv = TOPs
#define dPOPss		SV *sv = POPs
#define dTOPnv		NV value = TOPn
#define dPOPnv		NV value = POPn
#define dPOPnv_nomg	NV value = (sp--, SvNV_nomg(TOPp1s))
#define dTOPiv		IV value = TOPi
#define dPOPiv		IV value = POPi
#define dTOPuv		UV value = TOPu
#define dPOPuv		UV value = POPu

#define dPOPXssrl(X)	SV *right = POPs; SV *left = CAT2(X,s)
#define dPOPXnnrl(X)	NV right = POPn; NV left = CAT2(X,n)
#define dPOPXiirl(X)	IV right = POPi; IV left = CAT2(X,i)

#define USE_LEFT(sv) \
        (SvOK(sv) || !(PL_op->op_flags & OPf_STACKED))
#define dPOPXiirl_ul_nomg(X) \
    IV right = (sp--, SvIV_nomg(TOPp1s));		\
    SV *leftsv = CAT2(X,s);				\
    IV left = USE_LEFT(leftsv) ? SvIV_nomg(leftsv) : 0

#define dPOPPOPssrl	dPOPXssrl(POP)
#define dPOPPOPnnrl	dPOPXnnrl(POP)
#define dPOPPOPiirl	dPOPXiirl(POP)

#define dPOPTOPssrl	dPOPXssrl(TOP)
#define dPOPTOPnnrl	dPOPXnnrl(TOP)
#define dPOPTOPnnrl_nomg \
    NV right = SvNV_nomg(TOPs); NV left = (sp--, SvNV_nomg(TOPs))
#define dPOPTOPiirl	dPOPXiirl(TOP)
#define dPOPTOPiirl_ul_nomg dPOPXiirl_ul_nomg(TOP)
#define dPOPTOPiirl_nomg \
    IV right = SvIV_nomg(TOPs); IV left = (sp--, SvIV_nomg(TOPs))

#define RETPUSHYES	RETURNX(PUSHs(&PL_sv_yes))
#define RETPUSHNO	RETURNX(PUSHs(&PL_sv_no))
#define RETPUSHUNDEF	RETURNX(PUSHs(&PL_sv_undef))

#define RETSETYES	RETURNX(SETs(&PL_sv_yes))
#define RETSETNO	RETURNX(SETs(&PL_sv_no))
#define RETSETUNDEF	RETURNX(SETs(&PL_sv_undef))
#define RETSETTARG	STMT_START { SETTARG; RETURN; } STMT_END

#define ARGTARG		PL_op->op_targ

#define MAXARG		(PL_op->op_private & OPpARG4_MASK)

/* for backcompat - use switch_argstack() instead */

#define SWITCHSTACK(f,t) \
    STMT_START {		\
        PL_curstack = f;        \
        PL_stack_sp = sp;       \
        switch_argstack(t);     \
        sp = PL_stack_sp;       \
    } STMT_END

#define EXTEND_MORTAL(n) \
    STMT_START {						\
        SSize_t eMiX = PL_tmps_ix + (n);			\
        if (UNLIKELY(eMiX >= PL_tmps_max))			\
            (void)Perl_tmps_grow_p(aTHX_ eMiX);			\
    } STMT_END

#define AMGf_noright	1
#define AMGf_noleft	2
#define AMGf_assign	4       /* op supports mutator variant, e.g. $x += 1 */
#define AMGf_unary	8
#define AMGf_numeric	0x10	/* for Perl_try_amagic_bin */

#define AMGf_want_list	0x40
#define AMGf_numarg	0x80


/* do SvGETMAGIC on the stack args before checking for overload */

#define tryAMAGICun_MG(method, flags) STMT_START { \
        if ( UNLIKELY((SvFLAGS(TOPs) & (SVf_ROK|SVs_GMG))) \
                && Perl_try_amagic_un(aTHX_ method, flags)) \
            return NORMAL; \
    } STMT_END
#define tryAMAGICbin_MG(method, flags) STMT_START { \
        if ( UNLIKELY(((SvFLAGS(TOPm1s)|SvFLAGS(TOPs)) & (SVf_ROK|SVs_GMG))) \
                && Perl_try_amagic_bin(aTHX_ method, flags)) \
            return NORMAL; \
    } STMT_END

#define AMG_CALLunary(sv,meth) \
    amagic_call(sv,&PL_sv_undef, meth, AMGf_noright | AMGf_unary)

/* No longer used in core. Use AMG_CALLunary instead */
#define AMG_CALLun(sv,meth) AMG_CALLunary(sv, CAT2(meth,_amg))

/* This is no longer used anywhere in the core. You might wish to consider
   calling amagic_deref_call() directly, as it has a cleaner interface.  */
#define tryAMAGICunDEREF(meth)						\
    STMT_START {							\
        sv = amagic_deref_call(*sp, CAT2(meth,_amg));			\
        SPAGAIN;							\
    } STMT_END


/* 2019: no longer used in core */
#define opASSIGN (PL_op->op_flags & OPf_STACKED)

/*
=for apidoc mnU||LVRET
True if this op will be the return value of an lvalue subroutine

=cut */
#define LVRET ((PL_op->op_private & OPpMAYBE_LVSUB) && is_lvalue_sub())

#define SvCANEXISTDELETE(sv) \
 (!SvRMAGICAL(sv)            \
  || !(mg = mg_find((const SV *) sv, PERL_MAGIC_tied))           \
  || (   (stash = SvSTASH(SvRV(SvTIED_obj(MUTABLE_SV(sv), mg)))) \
      && gv_fetchmethod_autoload(stash, "EXISTS", TRUE)          \
      && gv_fetchmethod_autoload(stash, "DELETE", TRUE)          \
     )                       \
  )

#ifdef PERL_CORE

/* These are just for Perl_tied_method(), which is not part of the public API.
   Use 0x04 rather than the next available bit, to help the compiler if the
   architecture can generate more efficient instructions.  */
#  define TIED_METHOD_MORTALIZE_NOT_NEEDED	0x04
#  define TIED_METHOD_ARGUMENTS_ON_STACK	0x08
#  define TIED_METHOD_SAY			0x10

/* Used in various places that need to dereference a glob or globref */
#  define MAYBE_DEREF_GV_flags(sv,phlags)                          \
    (                                                               \
        (void)(((phlags) & SV_GMAGIC) && (SvGETMAGIC(sv),0)),        \
        isGV_with_GP(sv)                                              \
          ? (GV *)(sv)                                                \
          : SvROK(sv) && SvTYPE(SvRV(sv)) <= SVt_PVLV &&               \
            (SvGETMAGIC(SvRV(sv)), isGV_with_GP(SvRV(sv)))              \
             ? (GV *)SvRV(sv)                                            \
             : NULL                                                       \
    )
#  define MAYBE_DEREF_GV(sv)      MAYBE_DEREF_GV_flags(sv,SV_GMAGIC)
#  define MAYBE_DEREF_GV_nomg(sv) MAYBE_DEREF_GV_flags(sv,0)

#  define FIND_RUNCV_padid_eq	1
#  define FIND_RUNCV_level_eq	2

#endif

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                                                                     usr/local/lib/perl5/5.40.0/x86_64-linux-gnu/CORE/pp_proto.h                                         0000444 0000000 0000000 00000050722 14714567415 021137  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- mode: C; buffer-read-only: t -*-
   !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
   This file is built by opcode.pl from its data.
   Any changes made here will be lost!
 */

PERL_CALLCONV PP(do_kv) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_aassign) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_abs) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_accept) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_add) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_aeach) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_aelem) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_aelemfast) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_aelemfastlex_store) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_akeys) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_alarm) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_and) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_anoncode) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_anonconst) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_anonhash) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_anonlist) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_argcheck) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_argdefelem) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_argelem) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_aslice) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_atan2) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_av2arylen) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_avhvswitch) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_backtick) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_bind) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_binmode) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_bit_and) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_bit_or) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_bless) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_blessed) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_break) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_caller) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_catch) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_ceil) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_chdir) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_chop) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_chown) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_chr) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_chroot) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_classname) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_clonecv) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_close) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_closedir) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_cmpchain_and) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_cmpchain_dup) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_complement) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_concat) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_cond_expr) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_const) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_continue) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_coreargs) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_crypt) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_dbmopen) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_dbstate) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_defined) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_delete) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_die) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_divide) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_each) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_ehostent) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_emptyavhv) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_enter) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_entereval) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_entergiven) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_enteriter) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_enterloop) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_entersub) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_entertry) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_entertrycatch) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_enterwhen) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_enterwrite) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_eof) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_eq) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_exec) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_exists) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_exit) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_fc) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_fileno) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_flip) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_flock) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_floor) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_flop) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_fork) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_formline) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_ftis) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_ftlink) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_ftrowned) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_ftrread) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_fttext) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_fttty) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_ge) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_gelem) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_getc) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_getlogin) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_getpeername) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_getpgrp) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_getppid) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_getpriority) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_ggrent) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_ghostent) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_glob) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_gmtime) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_gnetent) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_goto) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_gprotoent) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_gpwent) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_grepstart) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_grepwhile) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_gservent) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_gt) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_gv) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_gvsv) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_helem) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_helemexistsor) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_hintseval) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_hslice) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_i_add) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_i_divide) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_i_eq) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_i_ge) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_i_gt) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_i_le) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_i_lt) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_i_modulo) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_i_multiply) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_i_ncmp) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_i_ne) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_i_negate) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_i_subtract) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_index) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_initfield) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_int) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_introcv) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_ioctl) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_is_bool) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_is_tainted) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_is_weak) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_isa) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_iter) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_join) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_kvaslice) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_kvhslice) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_last) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_lc) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_le) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_leave) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_leaveeval) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_leavegiven) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_leaveloop) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_leavesub) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_leavesublv) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_leavetry) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_leavetrycatch) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_leavewhen) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_leavewrite) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_left_shift) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_length) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_link) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_list) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_listen) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_lock) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_lslice) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_lt) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_lvavref) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_lvref) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_lvrefslice) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_mapwhile) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_match) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_method) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_method_named) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_method_redir) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_method_redir_super) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_method_super) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_methstart) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_mkdir) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_modulo) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_multiconcat) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_multideref) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_multiply) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_nbit_and) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_nbit_or) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_ncmp) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_ncomplement) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_ne) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_negate) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_next) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_nextstate) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_not) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_null) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_oct) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_once) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_open) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_open_dir) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_or) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_ord) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_pack) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_padav) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_padcv) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_padhv) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_padrange) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_padsv) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_padsv_store) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_pipe_op) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_poptry) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_pos) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_postdec) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_postinc) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_pow) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_predec) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_preinc) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_print) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_prototype) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_prtf) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_push) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_pushdefer) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_pushmark) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_qr) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_quotemeta) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_rand) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_range) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_rcatline) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_readdir) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_readline) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_readlink) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_redo) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_ref) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_refaddr) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_refassign) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_refgen) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_reftype) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_regcomp) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_regcreset) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_rename) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_repeat) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_require) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_reset) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_return) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_reverse) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_rewinddir) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_right_shift) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_rmdir) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_runcv) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_rv2av) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_rv2cv) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_rv2gv) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_rv2sv) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_sassign) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_sbit_and) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_sbit_or) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_schop) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_scmp) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_scomplement) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_seekdir) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_select) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_semctl) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_semget) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_seq) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_setpgrp) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_setpriority) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_shift) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_shmwrite) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_shostent) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_shutdown) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_sin) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_sle) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_sleep) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_smartmatch) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_sne) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_socket) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_sockpair) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_sort) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_splice) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_split) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_sprintf) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_srand) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_srefgen) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_sselect) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_ssockopt) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_stat) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_stringify) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_stub) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_study) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_subst) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_substcont) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_substr) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_subtract) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_syscall) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_sysopen) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_sysread) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_sysseek) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_system) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_syswrite) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_tell) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_telldir) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_tie) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_tied) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_time) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_tms) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_trans) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_truncate) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_uc) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_ucfirst) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_umask) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_undef) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_unpack) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_unshift) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_unstack) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_untie) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_unweaken) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_vec) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_wait) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_waitpid) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_wantarray) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_warn) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_weaken) __attribute__visibility__("hidden");
PERL_CALLCONV PP(pp_xor) __attribute__visibility__("hidden");
PERL_CALLCONV PP(unimplemented_op) __attribute__visibility__("hidden");

/* ex: set ro ft=c: */
                                              usr/local/lib/perl5/5.40.0/x86_64-linux-gnu/CORE/proto.h                                            0000444 0000000 0000000 00001243701 14714567415 020442  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- mode: C; buffer-read-only: t -*-
 *
 *    proto.h
 *
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013,
 *    2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022
 *    by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is built by regen/embed.pl from embed.fnc, intrpvar.h,
 * perlvars.h, regen/opcodes, regen/embed.pl, regen/embed_lib.pl and
 * regen/HeaderParser.pm.
 * Any changes made here will be lost!
 *
 * Edit those files and run 'make regen_headers' to effect changes.
 */

START_EXTERN_C
PERL_CALLCONV int
Perl_Gv_AMupdate(pTHX_ HV *stash, bool destructing);
#define PERL_ARGS_ASSERT_GV_AMUPDATE            \
        assert(stash)

PERL_CALLCONV const char *
Perl_PerlIO_context_layers(pTHX_ const char *mode);
#define PERL_ARGS_ASSERT_PERLIO_CONTEXT_LAYERS

PERL_CALLCONV int
Perl_PerlLIO_dup2_cloexec(pTHX_ int oldfd, int newfd)
        __attribute__visibility__("hidden");
#define PERL_ARGS_ASSERT_PERLLIO_DUP2_CLOEXEC

PERL_CALLCONV int
Perl_PerlLIO_dup_cloexec(pTHX_ int oldfd)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
#define PERL_ARGS_ASSERT_PERLLIO_DUP_CLOEXEC

PERL_CALLCONV int
Perl_PerlLIO_open3_cloexec(pTHX_ const char *file, int flag, int perm)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
#define PERL_ARGS_ASSERT_PERLLIO_OPEN3_CLOEXEC  \
        assert(file)

PERL_CALLCONV int
Perl_PerlLIO_open_cloexec(pTHX_ const char *file, int flag)
        __attribute__warn_unused_result__
        __attribute__visibility__("hidden");
#define PERL_ARGS_ASSERT_PERLLIO_OPEN_CLOEXEC   \
        assert(file)

/* PERL_CALLCONV const XOP *
Perl_custom_op_xop(pTHX_ const OP *o); */

PERL_CALLCONV const char *
Perl_langinfo(const nl_item item);
#define PERL_ARGS_ASSERT_PERL_LANGINFO

PERL_CALLCONV const char *
Perl_langinfo8(const nl_item item, utf8ness_t *utf8ness);
#define PERL_ARGS_ASSERT_PERL_LANGINFO8         \
        assert(utf8ness)

PERL_CALLCONV HV *
Perl_localeconv(pTHX);
#define PERL_ARGS_ASSERT_PERL_LOCALECONV

PERL_CALLCONV const char *
Perl_setlocale(const int category, const char *locale);
#define PERL_ARGS_ASSERT_PERL_SETLOCALE

PERL_CALLCONV void *
Perl_Slab_Alloc(pTHX_ size_t sz)
        __attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_SLAB_ALLOC

PERL_CALLCONV void
Perl_Slab_Free(pTHX_ void *op);
#define PERL_ARGS_ASSERT_SLAB_FREE              \
        assert(op)

/* PERL_CALLCONV void
SvREFCNT_dec_set_NULL(pTHX_ SV *sv); */

PERL_CALLCONV const char *
Perl__byte_dump_string(pTHX_ const U8 * const start, const STRLEN len, const bool format);
#define PERL_ARGS_ASSERT__BYTE_DUMP_STRING

PERL_CALLCONV void
Perl__force_out_malformed_utf8_message(pTHX_ const U8 * const p, const U8 * const e, const U32 flags, const bool die_here);
#define PERL_ARGS_ASSERT__FORCE_OUT_MALFORMED_UTF8_MESSAGE \
        assert(p); assert(e)

PERL_CALLCONV Size_t
Perl__inverse_folds(pTHX_ const UV cp, U32 *first_folds_to, const U32 **remaining_folds_to)
        __attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__INVERSE_FOLDS         \
        assert(first_folds_to); assert(remaining_folds_to)

PERL_CALLCONV bool
Perl__is_in_locale_category(pTHX_ const bool compiling, const int category);
#define PERL_ARGS_ASSERT__IS_IN_LOCALE_CATEGORY

PERL_CALLCONV bool
Perl__is_uni_FOO(pTHX_ const U8 classnum, const UV c)
        __attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__IS_UNI_FOO

PERL_CALLCONV bool
Perl__is_uni_perl_idcont(pTHX_ UV c)
        __attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__IS_UNI_PERL_IDCONT

PERL_CALLCONV bool
Perl__is_uni_perl_idstart(pTHX_ UV c)
        __attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__IS_UNI_PERL_IDSTART

PERL_CALLCONV bool
Perl__is_utf8_FOO(pTHX_ const U8 classnum, const U8 *p, const U8 * const e)
        __attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__IS_UTF8_FOO           \
        assert(p); assert(e)

PERL_CALLCONV bool
Perl__is_utf8_perl_idcont(pTHX_ const U8 *p, const U8 * const e)
        __attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__IS_UTF8_PERL_IDCONT   \
        assert(p); assert(e)

PERL_CALLCONV bool
Perl__is_utf8_perl_idstart(pTHX_ const U8 *p, const U8 * const e)
        __attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT__IS_UTF8_PERL_IDSTART  \
        assert(p); assert(e)

PERL_CALLCONV UV
Perl__to_uni_fold_flags(pTHX_ UV c, U8 *p, STRLEN *lenp, U8 flags);
#define PERL_ARGS_ASSERT__TO_UNI_FOLD_FLAGS     \
        assert(p); assert(lenp)

PERL_CALLCONV UV
Perl__to_utf8_fold_flags(pTHX_ const U8 *p, const U8 *e, U8 *ustrp, STRLEN *lenp, U8 flags);
#define PERL_ARGS_ASSERT__TO_UTF8_FOLD_FLAGS    \
        assert(p); assert(ustrp)

PERL_CALLCONV UV
Perl__to_utf8_lower_flags(pTHX_ const U8 *p, const U8 *e, U8 *ustrp, STRLEN *lenp, bool flags);
#define PERL_ARGS_ASSERT__TO_UTF8_LOWER_FLAGS   \
        assert(p); assert(ustrp)

PERL_CALLCONV UV
Perl__to_utf8_title_flags(pTHX_ const U8 *p, const U8 *e, U8 *ustrp, STRLEN *lenp, bool flags);
#define PERL_ARGS_ASSERT__TO_UTF8_TITLE_FLAGS   \
        assert(p); assert(ustrp)

PERL_CALLCONV UV
Perl__to_utf8_upper_flags(pTHX_ const U8 *p, const U8 *e, U8 *ustrp, STRLEN *lenp, bool flags);
#define PERL_ARGS_ASSERT__TO_UTF8_UPPER_FLAGS   \
        assert(p); assert(ustrp)

PERL_CALLCONV UV
Perl__utf8n_to_uvchr_msgs_helper(const U8 *s, STRLEN curlen, STRLEN *retlen, const U32 flags, U32 *errors, AV **msgs);
#define PERL_ARGS_ASSERT__UTF8N_TO_UVCHR_MSGS_HELPER \
        assert(s)

PERL_CALLCONV_NO_RET void
Perl_abort_execution(pTHX_ SV *msg_sv, const char * const name)
        __attribute__noreturn__
        __attribute__visibility__("hidden");
#define PERL_ARGS_ASSERT_ABORT_EXECUTION        \
        assert(name)

PERL_CALLCONV LOGOP *
Perl_alloc_LOGOP(pTHX_ I32 type, OP *first, OP *other)
        __attribute__visibility__("hidden");
#define PERL_ARGS_ASSERT_ALLOC_LOGOP

PERL_CALLCONV PADOFFSET
Perl_allocmy(pTHX_ const char * const name, const STRLEN len, const U32 flags)
        __attribute__visibility__("hidden");
#define PERL_ARGS_ASSERT_ALLOCMY                \
        assert(name)

PERL_CALLCONV bool
Perl_amagic_applies(pTHX_ SV *sv, int method, int flags);
#define PERL_ARGS_ASSERT_AMAGIC_APPLIES         \
        assert(sv)

PERL_CALLCONV SV *
Perl_amagic_call(pTHX_ SV *left, SV *right, int method, int dir);
#define PERL_ARGS_ASSERT_AMAGIC_CALL            \
        assert(left); assert(right)

PERL_CALLCONV SV *
Perl_amagic_deref_call(pTHX_ SV *ref, int method);
#define PERL_ARGS_ASSERT_AMAGIC_DEREF_CALL      \
        assert(ref)

PERL_CALLCONV bool
Perl_amagic_is_enabled(pTHX_ int method)
        __attribute__visibility__("hidden");
#define PERL_ARGS_ASSERT_AMAGIC_IS_ENABLED

PERL_CALLCONV SSize_t
Perl_apply(pTHX_ I32 type, SV **mark, SV **sp)
        __attribute__visibility__("hidden");
#define PERL_ARGS_ASSERT_APPLY                  \
        assert(mark); assert(sp)

PERL_CALLCONV void
Perl_apply_attrs_string(pTHX_ const char *stashpv, CV *cv, const char *attrstr, STRLEN len);
#define PERL_ARGS_ASSERT_APPLY_ATTRS_STRING     \
        assert(stashpv); assert(cv); assert(attrstr)

PERL_CALLCONV OP *
Perl_apply_builtin_cv_attributes(pTHX_ CV *cv, OP *attrlist);
#define PERL_ARGS_ASSERT_APPLY_BUILTIN_CV_ATTRIBUTES \
        assert(cv)

PERL_CALLCONV void
Perl_atfork_lock(void);
#define PERL_ARGS_ASSERT_ATFORK_LOCK

PERL_CALLCONV void
Perl_atfork_unlock(void);
#define PERL_ARGS_ASSERT_ATFORK_UNLOCK

PERL_CALLCONV SV **
Perl_av_arylen_p(pTHX_ AV *av);
#define PERL_ARGS_ASSERT_AV_ARYLEN_P            \
        assert(av)

PERL_CALLCONV void
Perl_av_clear(pTHX_ AV *av);
#define PERL_ARGS_ASSERT_AV_CLEAR               \
        assert(av)

PERL_CALLCONV void
Perl_av_create_and_push(pTHX_ AV ** const avp, SV * const val);
#define PERL_ARGS_ASSERT_AV_CREATE_AND_PUSH     \
        assert(avp); assert(val)

PERL_CALLCONV SV **
Perl_av_create_and_unshift_one(pTHX_ AV ** const avp, SV * const val);
#define PERL_ARGS_ASSERT_AV_CREATE_AND_UNSHIFT_ONE \
        assert(avp); assert(val)

PERL_CALLCONV SV *
Perl_av_delete(pTHX_ AV *av, SSize_t key, I32 flags);
#define PERL_ARGS_ASSERT_AV_DELETE              \
        assert(av)

PERL_CALLCONV void
Perl_av_dump(pTHX_ AV *av);
#define PERL_ARGS_ASSERT_AV_DUMP

PERL_CALLCONV bool
Perl_av_exists(pTHX_ AV *av, SSize_t key)
        __attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_AV_EXISTS              \
        assert(av)

PERL_CALLCONV void
Perl_av_extend(pTHX_ AV *av, SSize_t key);
#define PERL_ARGS_ASSERT_AV_EXTEND              \
        assert(av)

PERL_CALLCONV void
Perl_av_extend_guts(pTHX_ AV *av, SSize_t key, SSize_t *maxp, SV ***allocp, SV ***arrayp)
        __attribute__visibility__("hidden");
#define PERL_ARGS_ASSERT_AV_EXTEND_GUTS         \
        assert(maxp); assert(allocp); assert(arrayp)

PERL_CALLCONV SV **
Perl_av_fetch(pTHX_ AV *av, SSize_t key, I32 lval)
        __attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_AV_FETCH               \
        assert(av)

PERL_CALLCONV void
Perl_av_fill(pTHX_ AV *av, SSize_t fill);
#define PERL_ARGS_ASSERT_AV_FILL                \
        assert(av)

PERL_CALLCONV IV *
Perl_av_iter_p(pTHX_ AV *av);
#define PERL_ARGS_ASSERT_AV_ITER_P              \
        assert(av)

PERL_CALLCONV SSize_t
Perl_av_len(pTHX_ AV *av)
        __attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_AV_LEN                 \
        assert(av)

PERL_CALLCONV AV *
Perl_av_make(pTHX_ SSize_t size, SV **strp)
        __attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_AV_MAKE                \
        assert(strp)

PERL_CALLCONV SV *
Perl_av_nonelem(pTHX_ AV *av, SSize_t ix)
        __attribute__visibility__("hidden");
#define PERL_ARGS_ASSERT_AV_NONELEM             \
        assert(av)

PERL_CALLCONV SV *
Perl_av_pop(pTHX_ AV *av);
#define PERL_ARGS_ASSERT_AV_POP                 \
        assert(av)

PERL_CALLCONV void
Perl_av_push(pTHX_ AV *av, SV *val);
#define PERL_ARGS_ASSERT_AV_PUSH                \
        assert(av); assert(val)

PERL_CALLCONV void
Perl_av_reify(pTHX_ AV *av);
#define PERL_ARGS_ASSERT_AV_REIFY               \
        assert(av)

PERL_CALLCONV SV *
Perl_av_shift(pTHX_ AV *av)
        __attribute__warn_unused_result__;
#define PERL_ARGS_ASSERT_AV_SHIFT               \
        assert(av)

