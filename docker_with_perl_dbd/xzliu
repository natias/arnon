 _inverse_folds
 invert
 invlist_array
 _invlist_array_init
 invlist_clear
 invlist_clone
 _invlist_contains_cp
 invlist_contents
 _invlist_dump
 _invlistEQ
 invlist_extend
 invlist_highest
 _invlist_intersection
 _invlist_intersection_maybe_complement_2nd
 _invlist_invert
 invlist_is_iterating
 invlist_iterfinish
 invlist_iterinit
 invlist_iternext
 _invlist_len
 invlist_max
 invlist_previous_index
 _invlist_search
 invlist_set_len
 invlist_set_previous_index
 _invlist_subtract
 invlist_trim
 _invlist_union
 _invlist_union_maybe_complement_2nd
 invmap_dump
 invoke_exception_hook
 io_close
 isFF_overlong
 is_grapheme
 _is_in_locale_category
 is_invlist
 is_standard_filehandle_name
 _is_uni_FOO
 _is_uni_perl_idcont
 _is_uni_perl_idstart
 is_utf8_char_helper_
 is_utf8_common
 is_utf8_FF_helper_
 _is_utf8_FOO
 is_utf8_overlong
 _is_utf8_perl_idcont
 _is_utf8_perl_idstart
 jmaybe
 join_exact
 keyword
 keyword_plugin_standard
 list
 load_charnames
 locale_panic
 localize
 lossless_NV_to_IV
 lsbit_pos32
 lsbit_pos64
 magic_clear_all_env
 magic_cleararylen_p
 magic_clearenv
 magic_clearhook
 magic_clearhookall
 magic_clearisa
 magic_clearpack
 magic_clearsig
 magic_copycallchecker
 magic_existspack
 magic_freearylen_p
 magic_freecollxfrm
 magic_freemglob
 magic_freeovrld
 magic_freeutf8
 magic_get
 magic_getarylen
 magic_getdebugvar
 magic_getdefelem
 magic_getnkeys
 magic_getpack
 magic_getpos
 magic_getsig
 magic_getsubstr
 magic_gettaint
 magic_getuvar
 magic_getvec
 magic_killbackrefs
 magic_nextpack
 magic_regdata_cnt
 magic_regdatum_get
 magic_regdatum_set
 magic_scalarpack
 magic_set
 magic_set_all_env
 magic_setarylen
 magic_setcollxfrm
 magic_setdbline
 magic_setdebugvar
 magic_setdefelem
 magic_setenv
 magic_sethook
 magic_sethookall
 magic_setisa
 magic_setlvref
 magic_setmglob
 magic_setnkeys
 magic_setnonelem
 magic_setpack
 magic_setpos
 magic_setregexp
 magic_setsig
 magic_setsigall
 magic_setsubstr
 magic_settaint
 magic_setutf8
 magic_setuvar
 magic_setvec
 magic_sizepack
 magic_wipepack
 make_trie
 malloced_size
 malloc_good_size
 markstack_grow
 mbtowc_
 mem_collxfrm_
 mem_log_alloc
 mem_log_del_sv
 mem_log_free
 mem_log_new_sv
 mem_log_realloc
 mg_find_mglob
 mg_size
 mode_from_discipline
 more_bodies
 more_sv
 moreswitches
 mortal_getenv
 mortalized_pv_copy
 mro_get_private_data
 mro_meta_dup
 mro_meta_init
 msbit_pos32
 msbit_pos64
 multiconcat_stringify
 multideref_stringify
 my_atof2
 my_atof3
 my_attrs
 my_clearenv
 my_lstat
 my_lstat_flags
 my_memrchr
 my_mkostemp_cloexec
 my_mkstemp_cloexec
 my_stat
 my_stat_flags
 my_strerror
 my_unexec
 newFORM
 _new_invlist
 _new_invlist_C_array
 newMETHOP_internal
 newPROG
 new_stackinfo
 new_stackinfo_flags
 newSTUB
 newSVavdefelem
 newXS_deffile
 nextargv
 no_bareword_allowed
 no_bareword_filehandle
 noperl_die
 notify_parser_that_changed_to_utf8
 oopsAV
 oopsHV
 op_clear
 op_integerize
 op_lvalue_flags
 opmethod_stash
 op_prune_chain_head
 op_relocate_sv
 opslab_force_free
 opslab_free
 opslab_free_nopad
 op_std_init
 op_varname
 package
 package_version
 pad_add_weakref
 padlist_store
 padname_free
 PadnameIN_SCOPE
 padnamelist_free
 parser_dup
 parser_free
 parser_free_nexttoke_ops
 parse_unicode_opts
 path_is_searchable
 peep
 perl_alloc_using
 perl_clone_using
 PerlEnv_putenv
 PerlIO_context_layers
 PerlIO_restore_errno
 PerlIO_save_errno
 PerlLIO_dup_cloexec
 PerlLIO_dup2_cloexec
 PerlLIO_open_cloexec
 PerlLIO_open3_cloexec
 PerlProc_pipe_cloexec
 PerlSock_accept_cloexec
 PerlSock_socket_cloexec
 PerlSock_socketpair_cloexec
 perly_sighandler
 pmruntime
 POPMARK
 populate_anyof_bitmap_from_invlist
 populate_bitmap_from_invlist
 populate_invlist_from_bitmap
 populate_isa
 pregfree
 pregfree2
 prepare_export_lexical
 ptr_hash
 qerror
 ReANY
 reentrant_free
 reentrant_init
 reentrant_retry
 reentrant_size
 re_exec_indentf
 ref
 reg_add_data
 regcurly
 regdump
 regdupe_internal
 regexec_flags
 regfree_internal
 reginitcolors
 reg_named_buff
 reg_named_buff_all
 reg_named_buff_exists
 reg_named_buff_fetch
 reg_named_buff_firstkey
 reg_named_buff_iter
 reg_named_buff_nextkey
 reg_named_buff_scalar
 regnext
 regnode_after
 reg_numbered_buff_fetch
 reg_numbered_buff_fetch_flags
 reg_numbered_buff_length
 reg_numbered_buff_store
 regprop
 reg_qr_package
 reg_skipcomment
 reg_temp_copy
 re_indentf
 re_intuit_start
 re_intuit_string
 re_op_compile
 report_evil_fh
 report_redefined_cv
 report_wrongway_fh
 re_printf
 rpeep
 rsignal_restore
 rsignal_save
 rvpv_dup
 rxres_save
 same_dirent
 save_bool
 save_clearsv
 save_delete
 save_destructor
 save_destructor_x
 save_freeop
 save_freepv
 save_freesv
 save_int
 save_iv
 save_I8
 save_I16
 save_I32
 save_mortalizesv
 save_pptr
 save_pushi32ptr
 save_pushptrptr
 save_re_context
 save_sptr
 savestack_grow
 savestack_grow_cnt
 save_strlen
 sawparens
 scalar
 scalarvoid
 scan_commit
 scan_num
 seed
 set_ANYOF_arg
 set_caret_X
 setfd_cloexec
 setfd_cloexec_for_nonsysfd
 setfd_cloexec_or_inhexec_by_sysfdness
 setfd_inhexec
 setfd_inhexec_for_sysfd
 set_numeric_standard
 set_numeric_underlying
 set_padlist
 _setup_canned_invlist
 share_hek
 should_warn_nl
 should_we_output_Debug_r
 sighandler
 sighandler1
 sighandler3
 single_1bit_pos32
 single_1bit_pos64
 Slab_Alloc
 Slab_Free
 Slab_to_ro
 Slab_to_rw
 softref2xv
 sortsv_flags_impl
 ssc_init
 stack_grow
 str_to_version
 strxfrm
 study_chunk
 sub_crush_depth
 sv_add_backref
 sv_buf_to_ro
 sv_del_backref
 sv_i_ncmp
 sv_i_ncmp_desc
 sv_2iv
 sv_magicext_mglob
 sv_mark_arenas
 sv_ncmp
 sv_ncmp_desc
 sv_only_taint_gmagic
 sv_or_pv_pos_u2b
 sv_pvbyten_force_wrapper
 sv_pvutf8n_force_wrapper
 sv_resetpvn
 sv_sethek
 sv_sweep_arenas
 SvTRUE_common
 sv_unglob
 sv_2uv
 switch_locale_context
 sys_init
 sys_init3
 sys_intern_clear
 sys_intern_dup
 sys_intern_init
 sys_term
 tied_method
 tmps_grow_p
 _to_fold_latin1
 TOPMARK
 to_uni_fold
 _to_uni_fold_flags
 to_uni_lower
 to_uni_title
 to_uni_upper
 _to_upper_title_latin1
 _to_utf8_fold_flags
 _to_utf8_lower_flags
 _to_utf8_title_flags
 _to_utf8_upper_flags
 translate_substr_offsets
 try_amagic_bin
 try_amagic_un
 uiv_2buf
 unlnk
 unshare_hek
 unwind_paren
 _utf8n_to_uvchr_msgs_helper
 utf16_to_utf8_base
 utf16_to_utf8_reversed
 utf16_to_utf8
 utf8_to_uvchr_buf_helper
 utilize
 uvoffuni_to_utf8_flags_msgs
 variant_byte_number
 varname
 vivify_defelem
 vivify_ref
 wait4pid
 warn_elem_scalar_context
 warn_problematic_locale
 was_lvalue_sub
 watch
 win32_croak_not_implemented
 write_to_stderr
 xs_boot_epilog
 xs_handshake
 yyerror
 yyerror_pv
 yyerror_pvn
 yylex
 yyparse
 yyquit
 yyunlex

Next are the experimental undocumented elements


X<alloc_LOGOP>X<av_remove_offset>X<clear_defarray_simple>
X<create_eval_scope>X<cv_ckproto_len_flags>X<cx_popblock>X<cx_popeval>
X<cx_popformat>X<cx_popgiven>X<cx_poploop>X<cx_popsub>X<cx_popsub_args>
X<cx_popsub_common>X<cx_popwhen>X<cx_pushblock>X<cx_pusheval>
X<cx_pushformat>X<cx_pushgiven>X<cx_pushloop_for>X<cx_pushloop_plain>
X<cx_pushsub>X<cx_pushtry>X<cx_pushwhen>X<cx_topblock>X<delete_eval_scope>
X<do_open_raw>X<do_open6>X<emulate_cop_io>X<get_re_arg>X<get_vtbl>
X<gimme_V>X<hv_backreferences_p>X<hv_kill_backrefs>
X<invlist_highest_range_start>X<invlist_lowest>X<newGP>
X<new_warnings_bitfield>X<op_refcnt_dec>X<op_refcnt_inc>X<op_unscope>
X<pop_stackinfo>X<pp_wrap>X<push_stackinfo>X<rpp_free_2_>
X<rpp_obliterate_stack_to>X<rpp_replace_2_1_COMMON>X<runops_wrap>
X<scan_str>X<scan_word>X<scan_word6>X<skipspace_flags>X<sv_free2>
X<sv_kill_backrefs>X<sv_setpv_freshbuf>X<sv_setsv_cow>X<sv_strftime_ints>
X<switch_argstack>X<utf8_to_utf16_base>X<xs_wrap>

 alloc_LOGOP            gimme_V
 av_remove_offset       hv_backreferences_p
 clear_defarray_simple  hv_kill_backrefs
 create_eval_scope      invlist_highest_range_start
 cv_ckproto_len_flags   invlist_lowest
 cx_popblock            newGP
 cx_popeval             new_warnings_bitfield
 cx_popformat           op_refcnt_dec
 cx_popgiven            op_refcnt_inc
 cx_poploop             op_unscope
 cx_popsub              pop_stackinfo
 cx_popsub_args         pp_wrap
 cx_popsub_common       push_stackinfo
 cx_popwhen             rpp_free_2_
 cx_pushblock           rpp_obliterate_stack_to
 cx_pusheval            rpp_replace_2_1_COMMON
 cx_pushformat          runops_wrap
 cx_pushgiven           scan_str
 cx_pushloop_for        scan_word
 cx_pushloop_plain      scan_word6
 cx_pushsub             skipspace_flags
 cx_pushtry             sv_free2
 cx_pushwhen            sv_kill_backrefs
 cx_topblock            sv_setpv_freshbuf
 delete_eval_scope      sv_setsv_cow
 do_open_raw            sv_strftime_ints
 do_open6               switch_argstack
 emulate_cop_io         utf8_to_utf16_base
 get_re_arg             xs_wrap
 get_vtbl               

Finally are the deprecated undocumented elements.
Do not use any for new code; remove all occurrences of all of these from
existing code.


X<get_no_modify>X<get_opargs>X<get_ppaddr>X<uvuni_to_utf8>

 get_no_modify  get_opargs  get_ppaddr  uvuni_to_utf8  


=head1 AUTHORS

The autodocumentation system was originally added to the Perl core by
Benjamin Stuhl.  Documentation is by whoever was kind enough to
document their functions.

=head1 SEE ALSO

F<config.h>, L<perlapi>, L<perlapio>, L<perlcall>, L<perlclib>, L<perlembed>, L<perlfilter>, L<perlguts>, L<perlhacktips>, L<perlinterp>, L<perliol>, L<perlmroapi>, L<perlreapi>, L<perlreguts>, L<perlxs>

=cut

ex: set ro ft=pod:
                                                                                                                                                                                                                                                                                                                                                                 usr/local/lib/perl5/5.40.0/pod/perlinterp.pod                                                       0000644 0000000 0000000 00000111026 14714567415 017161  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =encoding utf8

=for comment
Consistent formatting of this file is achieved with:
  perl ./Porting/podtidy pod/perlinterp.pod

=head1 NAME

perlinterp - An overview of the Perl interpreter

=head1 DESCRIPTION

This document provides an overview of how the Perl interpreter works at
the level of C code, along with pointers to the relevant C source code
files.

=head1 ELEMENTS OF THE INTERPRETER

The work of the interpreter has two main stages: compiling the code
into the internal representation, or bytecode, and then executing it.
L<perlguts/Compiled code> explains exactly how the compilation stage
happens.

Here is a short breakdown of perl's operation:

=head2 Startup

The action begins in F<perlmain.c>. (or F<miniperlmain.c> for miniperl)
This is very high-level code, enough to fit on a single screen, and it
resembles the code found in L<perlembed>; most of the real action takes
place in F<perl.c>

F<perlmain.c> is generated by C<ExtUtils::Miniperl> from
F<miniperlmain.c> at make time, so you should make perl to follow this
along.

First, F<perlmain.c> allocates some memory and constructs a Perl
interpreter, along these lines:

    1 PERL_SYS_INIT3(&argc,&argv,&env);
    2
    3 if (!PL_do_undump) {
    4     my_perl = perl_alloc();
    5     if (!my_perl)
    6         exit(1);
    7     perl_construct(my_perl);
    8     PL_perl_destruct_level = 0;
    9 }

Line 1 is a macro, and its definition is dependent on your operating
system. Line 3 references C<PL_do_undump>, a global variable - all
global variables in Perl start with C<PL_>. This tells you whether the
current running program was created with the C<-u> flag to perl and
then F<undump>, which means it's going to be false in any sane context.

Line 4 calls a function in F<perl.c> to allocate memory for a Perl
interpreter. It's quite a simple function, and the guts of it looks
like this:

 my_perl = (PerlInterpreter*)PerlMem_malloc(sizeof(PerlInterpreter));

Here you see an example of Perl's system abstraction, which we'll see
later: C<PerlMem_malloc> is either your system's C<malloc>, or Perl's
own C<malloc> as defined in F<malloc.c> if you selected that option at
configure time.

Next, in line 7, we construct the interpreter using perl_construct,
also in F<perl.c>; this sets up all the special variables that Perl
needs, the stacks, and so on.

Now we pass Perl the command line options, and tell it to go:

 if (!perl_parse(my_perl, xs_init, argc, argv, (char **)NULL))
     perl_run(my_perl);

 exitstatus = perl_destruct(my_perl);

 perl_free(my_perl);

C<perl_parse> is actually a wrapper around C<S_parse_body>, as defined
in F<perl.c>, which processes the command line options, sets up any
statically linked XS modules, opens the program and calls C<yyparse> to
parse it.

=head2 Parsing

The aim of this stage is to take the Perl source, and turn it into an
op tree. We'll see what one of those looks like later. Strictly
speaking, there's three things going on here.

C<yyparse>, the parser, lives in F<perly.c>, although you're better off
reading the original YACC input in F<perly.y>. (Yes, Virginia, there
B<is> a YACC grammar for Perl!) The job of the parser is to take your
code and "understand" it, splitting it into sentences, deciding which
operands go with which operators and so on.

The parser is nobly assisted by the lexer, which chunks up your input
into tokens, and decides what type of thing each token is: a variable
name, an operator, a bareword, a subroutine, a core function, and so
on. The main point of entry to the lexer is C<yylex>, and that and its
associated routines can be found in F<toke.c>. Perl isn't much like
other computer languages; it's highly context sensitive at times, it
can be tricky to work out what sort of token something is, or where a
token ends. As such, there's a lot of interplay between the tokeniser
and the parser, which can get pretty frightening if you're not used to
it.

As the parser understands a Perl program, it builds up a tree of
operations for the interpreter to perform during execution. The
routines which construct and link together the various operations are
to be found in F<op.c>, and will be examined later.

=head2 Optimization

Now the parsing stage is complete, and the finished tree represents the
operations that the Perl interpreter needs to perform to execute our
program. Next, Perl does a dry run over the tree looking for
optimisations: constant expressions such as C<3 + 4> will be computed
now, and the optimizer will also see if any multiple operations can be
replaced with a single one. For instance, to fetch the variable
C<$foo>, instead of grabbing the glob C<*foo> and looking at the scalar
component, the optimizer fiddles the op tree to use a function which
directly looks up the scalar in question. The main optimizer is C<peep>
in F<op.c>, and many ops have their own optimizing functions.

=head2 Running

Now we're finally ready to go: we have compiled Perl byte code, and all
that's left to do is run it. The actual execution is done by the
C<runops_standard> function in F<run.c>; more specifically, it's done
by these three innocent looking lines:

    while ((PL_op = PL_op->op_ppaddr(aTHX))) {
        PERL_ASYNC_CHECK();
    }

You may be more comfortable with the Perl version of that:

    PERL_ASYNC_CHECK() while $Perl::op = &{$Perl::op->{function}};

Well, maybe not. Anyway, each op contains a function pointer, which
stipulates the function which will actually carry out the operation.
This function will return the next op in the sequence - this allows for
things like C<if> which choose the next op dynamically at run time. The
C<PERL_ASYNC_CHECK> makes sure that things like signals interrupt
execution if required.

=for apidoc_section $embedding
=for apidoc Amh|void|PERL_ASYNC_CHECK

The actual functions called are known as PP code, and they're spread
between four files: F<pp_hot.c> contains the "hot" code, which is most
often used and highly optimized, F<pp_sys.c> contains all the
system-specific functions, F<pp_ctl.c> contains the functions which
implement control structures (C<if>, C<while> and the like) and F<pp.c>
contains everything else. These are, if you like, the C code for Perl's
built-in functions and operators.

Note that each C<pp_> function is expected to return a pointer to the
next op. Calls to perl subs (and eval blocks) are handled within the
same runops loop, and do not consume extra space on the C stack. For
example, C<pp_entersub> and C<pp_entertry> just push a C<CXt_SUB> or
C<CXt_EVAL> block struct onto the context stack, which contain the address
of the op following the sub call or eval. They then return the first op
of that sub or eval block, and so execution continues of that sub or
block. Later, a C<pp_leavesub> or C<pp_leavetry> op pops the C<CXt_SUB>
or C<CXt_EVAL>, retrieves the return op from it, and returns it.

=head2 Exception handing

Perl's exception handing (i.e. C<die> etc.) is built on top of the
low-level C<setjmp()>/C<longjmp()> C-library functions. These basically
provide a way to capture the current PC and SP registers of the CPU and
later restore them: i.e. a C<longjmp()> continues at the point in code
where a previous C<setjmp()> was done, with anything further up on the C
stack being lost. (This is why code should always save values using
C<SAVE_I<FOO>> rather than in auto variables.)

=for apidoc_section $exceptions
=for apidoc Amh|void|JMPENV_PUSH|int v
=for apidoc Amh|void|JMPENV_JUMP|int v
=for apidoc Amnh|OP *|PL_restartop

The perl core wraps C<setjmp()> and C<longjmp()> in the macros
C<JMPENV_PUSH> and C<JMPENV_JUMP>. The push operation, as well as setting
a C<setjump()>, stores some temporary state in a struct local to the
current function (allocated by C<dJMPENV>). In particular, it stores a
pointer to the previous C<JMPENV> struct, and updates C<PL_top_env> to
point to the newest one, forming a chain of C<JMPENV> states. Both the
push and jump can output debugging information under C<perl -Dl>.

A basic rule of the perl internals is that all interpreter exits are
achieved via a C<JMPENV_JUMP()>. In particular:

=over

=item * level 2: perl-level exit() and internals my_exit()

These unwind all stacks, then perform a JMPENV_JUMP(2).

=item * level 3: perl-level die() and internals croak()

If currently within an eval, these pop the context stack back to the
nearest C<CXt_EVAL> frame, set C<$@> as appropriate, set C<PL_restartop>
to the op which follows the eval associated with that frame, then perform
a JMPENV_JUMP(3).

Otherwise, the error message is printed to C<STDERR>, then it is treated
as an exit: unwind all stacks and perform a JMPENV_JUMP(2).

=item * level 1: unused

JMPENV_JUMP(1) is currently unused except in perl_run().

=item * level 0: normal return.

The zero value is for a normal return from JMPENV_PUSH()

=back

So the perl interpreter expects that, at all times, there is a suitable
C<JMPENV_PUSH> set up (and at a suitable location within the CPU call
stack) that can catch and process a 2- or 3-valued jump; and in the case
of a 3, start a new runops loop to execute C<PL_restartop> and all
remaining ops (as will be explained shortly).

The entry points to the perl interpreter all provide such a facility. For
example, perl_parse(),  perl_run() and  C<call_sv(cv, G_EVAL)> all contain
something similar in outline to:

    {
        dJMPENV;
        JMPENV_PUSH(ret);
        switch (ret) {
        case 0:                     /* normal return from JMPENV_PUSH() */
          redo_body:
            CALLRUNOPS(aTHX);
            break;
        case 2:                     /* caught longjmp(2) - exit / die */
            break;
        case 3:                     /* caught longjmp(3) - eval { die } */
            PL_op = PL_restartop;
            goto redo_body;
        }

        JMPENV_POP;
    }

A runops loop such as Perl_runops_standard() (as set up by CALLRUNOPS())
is, at its heart, just a simple:

    while ((PL_op = PL_op->op_ppaddr(aTHX))) { 1; }

which calls the pp() function associated with each op, relying on that to
return a pointer to the next op to be executed.

As well as setting catches at the entry points to the perl interpreter,
you might expect perl to also do a JMPENV_PUSH() in places like
pp_entertry(), just before some trappable ops are executed. In fact perl
doesn't normally do this. The drawback with doing it is that with nested
or recursive code such as:

    sub foo { my ($i) = @_; return if $i < 0; eval { foo(--$i) } }

Then the C stack would quickly overflow with pairs of entries like

    ...
    #N+3 Perl_runops()
    #N+2 Perl_pp_entertry()
    #N+1 Perl_runops()
    #N   Perl_pp_entertry()
    ...

Instead, perl puts its guards at the I<callers> of runops loops. Then as
many nested subroutine calls and evals may be called as you like, all
within the one runops loop. If an exception occurs, control passes back to
the caller of the loop, which just immediately restarts a new loop with
C<PL_restartop> being the next op to call.

So in normal operation where there are several nested evals, there
will be multiple C<CXt_EVAL> context stack entries, but only a single
runops loop, guarded by a single C<JMPENV_PUSH>. Each caught eval will pop
the next C<CXt_EVAL> off the stack, set C<PL_restartop>, then longjmp()
back to perl_run() and continue.

However, ops are sometimes executed within an inner runops loop, such as
in a tie, sort, or overload code. In this case, something like

    sub FETCH { eval { die }; .... }

would, unless handled specially, cause a longjmp() right back to the guard
in perl_run(), popping I<both> the runops loops - which is clearly
incorrect.  One way to avoid this is for the tie code to do a
C<JMPENV_PUSH> before executing C<FETCH> in the inner runops loop, but for
efficiency reasons, perl in fact just temporarily sets a flag using
C<CATCH_SET(TRUE)>. This flag warns any subsequent C<require>,
C<entereval> or C<entertry> ops that the caller is no longer promising to
catch any raised exceptions on their behalf.

These ops check this flag, and if true, they (via docatch()) do a
C<JMPENV_PUSH> and start a new runops loop to execute the code, rather
than doing it with the current loop.

As a consequence, on exit from the eval block in the C<FETCH> above,
execution of the code following the block is still carried on in the
inner loop (i.e. the one established by the pp_entertry()). To avoid
confusion, if a further exception is then raised, docatch() compares the
C<JMPENV> level of the C<CXt_EVAL> with C<PL_top_env> and if they differ,
just re-throws the exception. In this way any inner loops get popped,
and the exception will be dealt with properly by the level which is
expecting it.

Here's an example.

    1: eval { tie @a, 'A' };
    2: sub A::TIEARRAY {
    3:     eval { die };
    4:     die;
    5: }

To run this code, perl_run() is called, which does a JMPENV_PUSH(),
then enters a runops loop. This loop executes the C<entereval> and C<tie>
ops on line 1, with the C<entereval> pushing a C<CXt_EVAL> onto the context
stack.

The pp_tie() does a C<CATCH_SET(TRUE)>, then starts a second runops
loop to execute the body of TIEARRAY(). When the loop executes the
C<entertry> op on line 3, CATCH_GET() is true, so pp_entertry() calls
docatch() which does a C<JMPENV_PUSH> and starts a third runops loop,
which restarts the pp_entertry(), then executes the C<die> op. At this
point the C call stack looks like this:

    #10 Perl_pp_die()
    #9  Perl_runops()      # runops loop 3
    #8  S_docatch()        # JMPENV level 2
    #7  Perl_pp_entertry()
    #6  Perl_runops()      # runops loop 2
    #5  Perl_call_sv()
    #4  Perl_pp_tie()
    #3  Perl_runops()      # runops loop 1
    #2  S_run_body()
    #1  perl_run()         # JMPENV level 1
    #0  main()

and the context and data stacks, as shown by C<perl -Dstv>, look like:

    STACK 0: MAIN
      CX 0: BLOCK  =>
      CX 1: EVAL   => AV()  PV("A"\0)
      retop=leave
    STACK 1: MAGIC
      CX 0: SUB    =>
      retop=(null)
      CX 1: EVAL   => *
    retop=nextstate

The die() pops the first C<CXt_EVAL> off the context stack, sets
C<PL_restartop> from it, does a C<JMPENV_JUMP(3)>, and control returns
to the C<JMPENV> level set in docatch(). This then starts another
third-level runops level, which executes the C<nextstate>, C<pushmark> and
C<die> ops from line 4. At the point that the second pp_die() is called,
the C call stack looks exactly like that above, even though we are no
longer within an inner eval. However, the context stack now looks like
this, i.e. with the top CXt_EVAL popped:

    STACK 0: MAIN
      CX 0: BLOCK  =>
      CX 1: EVAL   => AV()  PV("A"\0)
      retop=leave
    STACK 1: MAGIC
      CX 0: SUB    =>
      retop=(null)

The die() on line 4 pops the context stack back down to the C<CXt_EVAL>,
leaving it as:

    STACK 0: MAIN
      CX 0: BLOCK  =>

As usual, C<PL_restartop> is extracted from the C<CXt_EVAL>, and a
JMPENV_JUMP(3) done, which pops the C stack back to the docatch():

    #8  S_docatch()        # JMPENV level 2
    #7  Perl_pp_entertry()
    #6  Perl_runops()      # runops loop 2
    #5  Perl_call_sv()
    #4  Perl_pp_tie()
    #3  Perl_runops()      # runops loop 1
    #2  S_run_body()
    #1  perl_run()         # JMPENV level 1
    #0  main()

In  this case, because the C<JMPENV> level recorded in the C<CXt_EVAL>
differs from the current one, docatch() just does a JMPENV_JUMP(3)
to re-throw the exception, and the C stack unwinds to:

    #1  perl_run()         # JMPENV level 1
    #0  main()

Because C<PL_restartop> is non-null, run_body() starts a new runops
loop, and execution continues.


=head2 INTERNAL VARIABLE TYPES

You should by now have had a look at L<perlguts>, which tells you about
Perl's internal variable types: SVs, HVs, AVs and the rest. If not, do
that now.

These variables are used not only to represent Perl-space variables,
but also any constants in the code, as well as some structures
completely internal to Perl. The symbol table, for instance, is an
ordinary Perl hash. Your code is represented by an SV as it's read into
the parser; any program files you call are opened via ordinary Perl
filehandles, and so on.

The core L<Devel::Peek|Devel::Peek> module lets us examine SVs from a
Perl program. Let's see, for instance, how Perl treats the constant
C<"hello">.

      % perl -MDevel::Peek -e 'Dump("hello")'
    1 SV = PV(0xa041450) at 0xa04ecbc
    2   REFCNT = 1
    3   FLAGS = (POK,READONLY,pPOK)
    4   PV = 0xa0484e0 "hello"\0
    5   CUR = 5
    6   LEN = 6

Reading C<Devel::Peek> output takes a bit of practise, so let's go
through it line by line.

Line 1 tells us we're looking at an SV which lives at C<0xa04ecbc> in
memory. SVs themselves are very simple structures, but they contain a
pointer to a more complex structure. In this case, it's a PV, a
structure which holds a string value, at location C<0xa041450>. Line 2
is the reference count; there are no other references to this data, so
it's 1.

Line 3 are the flags for this SV - it's OK to use it as a PV, it's a
read-only SV (because it's a constant) and the data is a PV internally.
Next we've got the contents of the string, starting at location
C<0xa0484e0>.

Line 5 gives us the current length of the string - note that this does
B<not> include the null terminator. Line 6 is not the length of the
string, but the length of the currently allocated buffer; as the string
grows, Perl automatically extends the available storage via a routine
called C<SvGROW>.

You can get at any of these quantities from C very easily; just add
C<Sv> to the name of the field shown in the snippet, and you've got a
macro which will return the value: C<SvCUR(sv)> returns the current
length of the string, C<SvREFCOUNT(sv)> returns the reference count,
C<SvPV(sv, len)> returns the string itself with its length, and so on.
More macros to manipulate these properties can be found in L<perlguts>.

Let's take an example of manipulating a PV, from C<sv_catpvn>, in
F<sv.c>

     1  void
     2  Perl_sv_catpvn(pTHX_ SV *sv, const char *ptr, STRLEN len)
     3  {
     4      STRLEN tlen;
     5      char *junk;

     6      junk = SvPV_force(sv, tlen);
     7      SvGROW(sv, tlen + len + 1);
     8      if (ptr == junk)
     9          ptr = SvPVX(sv);
    10      Move(ptr,SvPVX(sv)+tlen,len,char);
    11      SvCUR(sv) += len;
    12      *SvEND(sv) = '\0';
    13      (void)SvPOK_only_UTF8(sv);          /* validate pointer */
    14      SvTAINT(sv);
    15  }

This is a function which adds a string, C<ptr>, of length C<len> onto
the end of the PV stored in C<sv>. The first thing we do in line 6 is
make sure that the SV B<has> a valid PV, by calling the C<SvPV_force>
macro to force a PV. As a side effect, C<tlen> gets set to the current
value of the PV, and the PV itself is returned to C<junk>.

In line 7, we make sure that the SV will have enough room to
accommodate the old string, the new string and the null terminator. If
C<LEN> isn't big enough, C<SvGROW> will reallocate space for us.

Now, if C<junk> is the same as the string we're trying to add, we can
grab the string directly from the SV; C<SvPVX> is the address of the PV
in the SV.

Line 10 does the actual catenation: the C<Move> macro moves a chunk of
memory around: we move the string C<ptr> to the end of the PV - that's
the start of the PV plus its current length. We're moving C<len> bytes
of type C<char>. After doing so, we need to tell Perl we've extended
the string, by altering C<CUR> to reflect the new length. C<SvEND> is a
macro which gives us the end of the string, so that needs to be a
C<"\0">.

Line 13 manipulates the flags; since we've changed the PV, any IV or NV
values will no longer be valid: if we have C<$x=10; $x.="6";> we don't
want to use the old IV of 10. C<SvPOK_only_utf8> is a special
UTF-8-aware version of C<SvPOK_only>, a macro which turns off the IOK
and NOK flags and turns on POK. The final C<SvTAINT> is a macro which
launders tainted data if taint mode is turned on.

AVs and HVs are more complicated, but SVs are by far the most common
variable type being thrown around. Having seen something of how we
manipulate these, let's go on and look at how the op tree is
constructed.

=head1 OP TREES

First, what is the op tree, anyway? The op tree is the parsed
representation of your program, as we saw in our section on parsing,
and it's the sequence of operations that Perl goes through to execute
your program, as we saw in L</Running>.

An op is a fundamental operation that Perl can perform: all the
built-in functions and operators are ops, and there are a series of ops
which deal with concepts the interpreter needs internally - entering
and leaving a block, ending a statement, fetching a variable, and so
on.
