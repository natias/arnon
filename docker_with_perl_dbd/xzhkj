<
						*E848*
The maximum number of clusters is 9767.

==============================================================================
10. Including syntax files				*:syn-include* *E397*

It is often useful for one language's syntax file to include a syntax file for
a related language.  Depending on the exact relationship, this can be done in
two different ways:

	- If top-level syntax items in the included syntax file are to be
	  allowed at the top level in the including syntax, you can simply use
	  the |:runtime| command: >

  " In cpp.vim:
  :runtime! syntax/c.vim
  :unlet b:current_syntax

<	- If top-level syntax items in the included syntax file are to be
	  contained within a region in the including syntax, you can use the
	  ":syntax include" command:

:sy[ntax] include [@{grouplist-name}] {file-name}

	  All syntax items declared in the included file will have the
	  "contained" flag added.  In addition, if a group list is specified,
	  all top-level syntax items in the included file will be added to
	  that list. >

   " In perl.vim:
   :syntax include @Pod <sfile>:p:h/pod.vim
   :syntax region perlPOD start="^=head" end="^=cut" contains=@Pod
<
	  When {file-name} is an absolute path (starts with "/", "c:", "$VAR"
	  or "<sfile>") that file is sourced.  When it is a relative path
	  (e.g., "syntax/pod.vim") the file is searched for in 'runtimepath'.
	  All matching files are loaded.  Using a relative path is
	  recommended, because it allows a user to replace the included file
	  with their own version, without replacing the file that does the
	  ":syn include".

						*E847*
The maximum number of includes is 999.

==============================================================================
11. Synchronizing				*:syn-sync* *E403* *E404*

Vim wants to be able to start redrawing in any position in the document.  To
make this possible it needs to know the syntax state at the position where
redrawing starts.

:sy[ntax] sync [ccomment [group-name] | minlines={N} | ...]

There are four ways to synchronize:
1. Always parse from the start of the file.
   |:syn-sync-first|
2. Based on C-style comments.  Vim understands how C-comments work and can
   figure out if the current line starts inside or outside a comment.
   |:syn-sync-second|
3. Jumping back a certain number of lines and start parsing there.
   |:syn-sync-third|
4. Searching backwards in the text for a pattern to sync on.
   |:syn-sync-fourth|

				*:syn-sync-maxlines* *:syn-sync-minlines*
For the last three methods, the line range where the parsing can start is
limited by "minlines" and "maxlines".

If the "minlines={N}" argument is given, the parsing always starts at least
that many lines backwards.  This can be used if the parsing may take a few
lines before it's correct, or when it's not possible to use syncing.

If the "maxlines={N}" argument is given, the number of lines that are searched
for a comment or syncing pattern is restricted to N lines backwards (after
adding "minlines").  This is useful if you have few things to sync on and a
slow machine.  Example: >
   :syntax sync maxlines=500 ccomment
<
						*:syn-sync-linebreaks*
When using a pattern that matches multiple lines, a change in one line may
cause a pattern to no longer match in a previous line.	This means has to
start above where the change was made.	How many lines can be specified with
the "linebreaks" argument.  For example, when a pattern may include one line
break use this: >
   :syntax sync linebreaks=1
The result is that redrawing always starts at least one line before where a
change was made.  The default value for "linebreaks" is zero.  Usually the
value for "minlines" is bigger than "linebreaks".


First syncing method:			*:syn-sync-first*
>
   :syntax sync fromstart

The file will be parsed from the start.  This makes syntax highlighting
accurate, but can be slow for long files.  Vim caches previously parsed text,
so that it's only slow when parsing the text for the first time.  However,
when making changes some part of the text needs to be parsed again (worst
case: to the end of the file).

Using "fromstart" is equivalent to using "minlines" with a very large number.


Second syncing method:			*:syn-sync-second* *:syn-sync-ccomment*

For the second method, only the "ccomment" argument needs to be given.
Example: >
   :syntax sync ccomment

When Vim finds that the line where displaying starts is inside a C-style
comment, the last region syntax item with the group-name "Comment" will be
used.  This requires that there is a region with the group-name "Comment"!
An alternate group name can be specified, for example: >
   :syntax sync ccomment javaComment
This means that the last item specified with "syn region javaComment" will be
used for the detected C comment region.  This only works properly if that
region does have a start pattern "\/*" and an end pattern "*\/".

The "maxlines" argument can be used to restrict the search to a number of
lines.	The "minlines" argument can be used to at least start a number of
lines back (e.g., for when there is some construct that only takes a few
lines, but it hard to sync on).

Note: Syncing on a C comment doesn't work properly when strings are used
that cross a line and contain a "*/".  Since letting strings cross a line
is a bad programming habit (many compilers give a warning message), and the
chance of a "*/" appearing inside a comment is very small, this restriction
is hardly ever noticed.


Third syncing method:				*:syn-sync-third*

For the third method, only the "minlines={N}" argument needs to be given.
Vim will subtract {N} from the line number and start parsing there.  This
means {N} extra lines need to be parsed, which makes this method a bit slower.
Example: >
   :syntax sync minlines=50

"lines" is equivalent to "minlines" (used by older versions).


Fourth syncing method:				*:syn-sync-fourth*

The idea is to synchronize on the end of a few specific regions, called a
sync pattern.  Only regions can cross lines, so when we find the end of some
region, we might be able to know in which syntax item we are.  The search
starts in the line just above the one where redrawing starts.  From there
the search continues backwards in the file.

This works just like the non-syncing syntax items.  You can use contained
matches, nextgroup, etc.  But there are a few differences:
- Keywords cannot be used.
- The syntax items with the "sync" keyword form a completely separated group
  of syntax items.  You can't mix syncing groups and non-syncing groups.
- The matching works backwards in the buffer (line by line), instead of
  forwards.
- A line continuation pattern can be given.  It is used to decide which group
  of lines need to be searched like they were one line.  This means that the
  search for a match with the specified items starts in the first of the
  consecutive lines that contain the continuation pattern.
- When using "nextgroup" or "contains", this only works within one line (or
  group of continued lines).
- When using a region, it must start and end in the same line (or group of
  continued lines).  Otherwise the end is assumed to be at the end of the
  line (or group of continued lines).
- When a match with a sync pattern is found, the rest of the line (or group of
  continued lines) is searched for another match.  The last match is used.
  This is used when a line can contain both the start end the end of a region
  (e.g., in a C-comment like /* this */, the last "*/" is used).

There are two ways how a match with a sync pattern can be used:
1. Parsing for highlighting starts where redrawing starts (and where the
   search for the sync pattern started).  The syntax group that is expected
   to be valid there must be specified.  This works well when the regions
   that cross lines cannot contain other regions.
2. Parsing for highlighting continues just after the match.  The syntax group
   that is expected to be present just after the match must be specified.
   This can be used when the previous method doesn't work well.  It's much
   slower, because more text needs to be parsed.
Both types of sync patterns can be used at the same time.

Besides the sync patterns, other matches and regions can be specified, to
avoid finding unwanted matches.

[The reason that the sync patterns are given separately, is that mostly the
search for the sync point can be much simpler than figuring out the
highlighting.  The reduced number of patterns means it will go (much)
faster.]

					    *syn-sync-grouphere* *E393* *E394*
    :syntax sync match {sync-group-name} grouphere {group-name} "pattern" ..

	Define a match that is used for syncing.  {group-name} is the
	name of a syntax group that follows just after the match.  Parsing
	of the text for highlighting starts just after the match.  A region
	must exist for this {group-name}.  The first one defined will be used.
	"NONE" can be used for when there is no syntax group after the match.

						*syn-sync-groupthere*
    :syntax sync match {sync-group-name} groupthere {group-name} "pattern" ..

	Like "grouphere", but {group-name} is the name of a syntax group that
	is to be used at the start of the line where searching for the sync
	point started.	The text between the match and the start of the sync
	pattern searching is assumed not to change the syntax highlighting.
	For example, in C you could search backwards for "/*" and "*/".  If
	"/*" is found first, you know that you are inside a comment, so the
	"groupthere" is "cComment".  If "*/" is found first, you know that you
	are not in a comment, so the "groupthere" is "NONE".  (in practice
	it's a bit more complicated, because the "/*" and "*/" could appear
	inside a string.  That's left as an exercise to the reader...).

    :syntax sync match ..
    :syntax sync region ..

	Without a "groupthere" argument.  Define a region or match that is
	skipped while searching for a sync point.

						*syn-sync-linecont*
    :syntax sync linecont {pattern}

	When {pattern} matches in a line, it is considered to continue in
	the next line.	This means that the search for a sync point will
	consider the lines to be concatenated.

If the "maxlines={N}" argument is given too, the number of lines that are
searched for a match is restricted to N.  This is useful if you have very
few things to sync on and a slow machine.  Example: >
   :syntax sync maxlines=100

You can clear all sync settings with: >
   :syntax sync clear

You can clear specific sync patterns with: >
   :syntax sync clear {sync-group-name} ..

==============================================================================
12. Listing syntax items		*:syntax* *:sy* *:syn* *:syn-list*

This command lists all the syntax items: >

    :sy[ntax] [list]

To show the syntax items for one syntax group: >

    :sy[ntax] list {group-name}

To list the syntax groups in one cluster:			*E392*	 >

    :sy[ntax] list @{cluster-name}

See above for other arguments for the ":syntax" command.

Note that the ":syntax" command can be abbreviated to ":sy", although ":syn"
is mostly used, because it looks better.

==============================================================================
13. Colorschemes				*color-schemes*

In the next section you can find information about indivisual highlight groups
and how to specify colors for them.  Most likely you want to just select a set
of colors by using the `:colorscheme` command, for example: >

	    colorscheme pablo
<
						*:colo* *:colorscheme* *E185*
:colo[rscheme]		Output the name of the currently active color scheme.
			This is basically the same as >
				:echo g:colors_name
<			In case g:colors_name has not been defined :colo will
			output "default".  When compiled without the |+eval|
			feature it will output "unknown".

:colo[rscheme] {name}	Load color scheme {name}.  This searches 'runtimepath'
			for the file "colors/{name}.vim".  The first one that
			is found is loaded.
			Also searches all plugins in 'packpath', first below
			"start" and then under "opt".

			Doesn't work recursively, thus you can't use
			":colorscheme" in a color scheme script.

You have two options for customizing a color scheme.  For changing the
appearance of specific colors, you can redefine a color name before loading
the scheme.  The desert scheme uses the khaki color for the cursor.  To use a
darker variation of the same color: >

	let v:colornames['khaki'] = '#bdb76b'
	colorscheme desert
<
For further customization, such as changing |:highlight-link| associations,
use another name, e.g.  "~/.vim/colors/mine.vim", and use `:runtime` to load
the original color scheme: >
	runtime colors/evening.vim
	hi Statement ctermfg=Blue guifg=Blue

Before the color scheme will be loaded all default color list scripts
(`colors/lists/default.vim`) will be executed and then the |ColorSchemePre|
autocommand event is triggered.  After the color scheme has been loaded the
|ColorScheme| autocommand event is triggered.

						*colorscheme-override*
If a color scheme is almost right, you can add modifications on top of it by
using the |ColorScheme| autocommand.  For example, to remove the background
color (can make it transparent in some terminals): >
	augroup my_colorschemes
	  au!
	  au Colorscheme pablo hi Normal ctermbg=NONE
	augroup END

Change a couple more colors: >
	augroup my_colorschemes
	  au!
	  au Colorscheme pablo hi Normal ctermbg=NONE
		      \ | highlight Special ctermfg=63
		      \ | highlight Identifier ctermfg=44
	augroup END

If you make a lot of changes it might be better to copy the distributed
colorscheme to your home directory and change it: >
	:!cp $VIMRUNTIME/colors/pablo.vim ~/.vim/colors
	:edit ~/.vim/colors/pablo.vim

With Vim 9.0 the collection of color schemes was updated and made work in many
different terminals.  One change was to often define the Normal highlight
group to make sure the colors work well.  In case you prefer the old version,
you can find them here:
https://github.com/vim/colorschemes/blob/master/legacy_colors/

For info about writing a color scheme file: >
	:edit $VIMRUNTIME/colors/README.txt


==============================================================================
14. Highlight command			*:highlight* *:hi* *E28* *E411* *E415*

There are three types of highlight groups:
- The ones used for specific languages.  For these the name starts with the
  name of the language.  Many of these don't have any attributes, but are
  linked to a group of the second type.
- The ones used for all syntax languages.
- The ones used for the 'highlight' option.
							*hitest.vim*
You can see all the groups currently active with this command: >
    :so $VIMRUNTIME/syntax/hitest.vim
This will open a new window containing all highlight group names, displayed
in their own color.

:hi[ghlight]		List all the current highlight groups that have
			attributes set.

:hi[ghlight] {group-name}
			List one highlight group.

						*highlight-clear* *:hi-clear*
:hi[ghlight] clear	Reset all highlighting to the defaults.  Removes all
			highlighting for groups added by the user.
			Uses the current value of 'background' to decide which
			default colors to use.
			If there was a default link, restore it. |:hi-link|

:hi[ghlight] clear {group-name}
:hi[ghlight] {group-name} NONE
			Disable the highlighting for one highlight group.  It
			is _not_ set back to the default colors.

:hi[ghlight] [default] {group-name} {key}={arg} ..
			Add a highlight group, or change the highlighting for
			an existing group. If a given color name is not
			recognized, each `colors/lists/default.vim` found on
			|'runtimepath'| will be loaded.
			See |highlight-args| for the {key}={arg} arguments.
			See |:highlight-default| for the optional [default]
			argument.

Normally a highlight group is added once when starting up.  This sets the
default values for the highlighting.  After that, you can use additional
highlight commands to change the arguments that you want to set to non-default
values.  The value "NONE" can be used to switch the value off or go back to
the default value.

A simple way to change colors is with the |:colorscheme| command.  This loads
a file with ":highlight" commands such as this: >

   :hi Comment	gui=bold

Note that all settings that are not included remain the same, only the
specified field is used, and settings are merged with previous ones.  So, the
result is like this single command has been used: >
   :hi Comment	term=bold ctermfg=Cyan guifg=#80a0ff gui=bold
<
							*:highlight-verbose*
When listing a highlight group and 'verbose' is non-zero, the listing will
also tell where it was last set.  Example: >
	:verbose hi Comment
<	Comment        xxx term=bold ctermfg=4 guifg=Blue ~
	   Last set from /home/mool/vim/vim7/runtime/syntax/syncolor.vim ~

When ":hi clear" is used then the script where this command is used will be
mentioned for the default values. See |:verbose-cmd| for more information.

					*highlight-args* *E416* *E417* *E423*
There are three types of terminals for highlighting:
term	a normal terminal (vt100, xterm)
cterm	a color terminal (MS-Windows console, color-xterm, these have the "Co"
	termcap entry)
gui	the GUI

For each type the highlighting can be given.  This makes it possible to use
the same syntax file on all terminals, and use the optimal highlighting.

1. highlight arguments for normal terminals

					*bold* *underline* *undercurl*
					*underdouble* *underdotted*
					*underdashed* *inverse* *italic*
					*standout* *nocombine* *strikethrough*
term={attr-list}			*attr-list* *highlight-term* *E418*
	attr-list is a comma-separated list (without spaces) of the
	following items (in any order):
		bold
		underline
		undercurl	not always available
		underdouble	not always available
		underdotted	not always available
		underdashed	not always available
		strikethrough	not always available
		reverse
		inverse		same as reverse
		italic
		standout
		nocombine	override attributes instead of combining them
		NONE		no attributes used (used to reset it)

	Note that "bold" can be used here and by using a bold font.  They
	have the same effect.
							*underline-codes*
	"undercurl" is a curly underline.  When "undercurl" is not possible
	then "underline" is used.  In general "undercurl" and "strikethrough"
	are only available in the GUI and some terminals.  The color is set
	with |highlight-guisp| or |highlight-ctermul|.  You can try these
	termcap entries to make undercurl work in a terminal: >
	    let &t_Cs = "\e[4:3m"
	    let &t_Ce = "\e[4:0m"

<	"underdouble" is a double underline, "underdotted" is a dotted
	underline and "underdashed" is a dashed underline.  These are only
	supported by some terminals.  If your terminal supports them you may
	have to specify the codes like this: >
	    let &t_Us = "\e[4:2m"
	    let &t_ds = "\e[4:4m"
	    let &t_Ds = "\e[4:5m"
<	They are reset with |t_Ce|, the same as curly underline (undercurl).
	When t_Us, t_ds or t_Ds is not set then underline will be used as a
	fallback.


start={term-list}				*highlight-start* *E422*
stop={term-list}				*term-list* *highlight-stop*
	These lists of terminal codes can be used to get
	non-standard attributes on a terminal.

	The escape sequence specified with the "start" argument
	is written before the characters in the highlighted
	area.  It can be anything that you want to send to the
	terminal to highlight this area.  The escape sequence
	specified with the "stop" argument is written after the
	highlighted area.  This should undo the "start" argument.
	Otherwise the screen will look messed up.

	The {term-list} can have two forms:

	1. A string with escape sequences.
	   This is any string of characters, except that it can't start with
	   "t_" and blanks are not allowed.  The <> notation is recognized
	   here, so you can use things like "<Esc>" and "<Space>".  Example:
		start=<Esc>[27h;<Esc>[<Space>r;

	2. A list of terminal codes.
	   Each terminal code has the form "t_xx", where "xx" is the name of
	   the termcap entry.  The codes have to be separated with commas.
	   White space is not allowed.	Example:
		start=t_C1,t_BL
	   The terminal codes must exist for this to work.


2. highlight arguments for color terminals

cterm={attr-list}					*highlight-cterm*
	See above for the description of {attr-list} |attr-list|.
	The "cterm" argument is likely to be different from "term", when
	colors are used.  For example, in a normal terminal comments could
	be underlined, in a color terminal they can be made Blue.
	Note: Some terminals (e.g., DOS console) can't mix these attributes
	with coloring.	To be portable, use only one of "cterm=" OR "ctermfg="
	OR "ctermbg=".

ctermfg={color-nr}				*highlight-ctermfg* *E421*
ctermbg={color-nr}				*highlight-ctermbg*
ctermul={color-nr}				*highlight-ctermul*
	These give the foreground (ctermfg), background (ctermbg) and
	underline (ctermul) color to use in the terminal.

	The {color-nr} argument is a color number.  Its range is zero to
	(not including) the number given by the termcap entry "Co".
	The actual color with this number depends on the type of terminal
	and its settings.  Sometimes the color also depends on the settings of
	"cterm".  For example, on some systems "cterm=bold ctermfg=3" gives
	another color, on others you just get color 3.

	For an xterm this depends on your resources, and is a bit
	unpredictable.	See your xterm documentation for the defaults.	The
	colors for a color-xterm can be changed from the .Xdefaults file.
	Unfortunately this means that it's not possible to get the same colors
	for each user.	See |xterm-color| for info about color xterms.
							*tmux*
	When using tmux you may want to use this in the tmux config: >
	    # tmux colors
	    set -s default-terminal "tmux-256color"
	    set -as terminal-overrides ",*-256color:Tc"
<	More info at:
	https://github.com/tmux/tmux/wiki/FAQ#how-do-i-use-a-256-colour-terminal
	https://github.com/tmux/tmux/wiki/FAQ#how-do-i-use-rgb-colour

	The MS-Windows standard colors are fixed (in a console window), so
	these have been used for the names.  But the meaning of color names in
	X11 are fixed, so these color settings have been used, to make the
	highlighting settings portable (complicated, isn't it?).  The
	following names are recognized, with the color number used:

							*cterm-colors*
	    NR-16   NR-8    COLOR NAME ~
	    0	    0	    Black
	    1	    4	    DarkBlue
	    2	    2	    DarkGreen
	    3	    6	    DarkCyan
	    4	    1	    DarkRed
	    5	    5	    DarkMagenta
	    6	    3	    Brown, DarkYellow
	    7	    7	    LightGray, LightGrey, Gray, Grey
	    8	    0*	    DarkGray, DarkGrey
	    9	    4*	    Blue, LightBlue
	    10	    2*	    Green, LightGreen
	    11	    6*	    Cyan, LightCyan
	    12	    1*	    Red, LightRed
	    13	    5*	    Magenta, LightMagenta
	    14	    3*	    Yellow, LightYellow
	    15	    7*	    White

	The number under "NR-16" is used for 16-color terminals ('t_Co'
	greater than or equal to 16).  The number under "NR-8" is used for
	8-color terminals ('t_Co' less than 16).  The '*' indicates that the
	bold attribute is set for ctermfg.  In many 8-color terminals (e.g.,
	"linux"), this causes the bright colors to appear.  This doesn't work
	for background colors!	Without the '*' the bold attribute is removed.
	If you want to set the bold attribute in a different way, put a
	"cterm=" argument AFTER the "ctermfg=" or "ctermbg=" argument.	Or use
	a number instead of a color name.

	The case of the color names is ignored.
	Note that for 16 color ansi style terminals (including xterms), the
	numbers in the NR-8 column is used.  Here '*' means 'add 8' so that
	Blue is 12, DarkGray is 8 etc.

	Note that for some color terminals these names may result in the wrong
	colors!

	You can also use "NONE" to remove the color.

							*:hi-normal-cterm*
	When setting the "ctermfg" or "ctermbg" colors for the Normal group,
	these will become the colors used for the non-highlighted text.
	Example: >
		:highlight Normal ctermfg=grey ctermbg=darkblue
<	When setting the "ctermbg" color for the Normal group, the
	'background' option will be adjusted automatically, under the
	condition that the color is recognized and 'background' was not set
	explicitly.  This causes the highlight groups that depend on
	'background' to change!  This means you should set the colors for
	Normal first, before setting other colors.
	When a color scheme is being used, changing 'background' causes it to
	be reloaded, which may reset all colors (including Normal).  First
	delete the "g:colors_name" variable when you don't want this.

	When you have set "ctermfg" or "ctermbg" for the Normal group, Vim
	needs to reset the color when exiting.	This is done with the "op"
	termcap entry |t_op|.  If this doesn't work correctly, try setting the
	't_op' option in your .vimrc.
							*E419* *E420* *E453*
	When Vim knows the normal foreground, background and underline colors,
	"fg", "bg" and "ul" can be used as color names.  This only works after
	setting the colors for the Normal group and for the MS-Windows
	console.  Example, for reverse video: >
	    :highlight Visual ctermfg=bg ctermbg=fg
<	Note that the colors are used that are valid at the moment this
	command is given.  If the Normal group colors are changed later, the
	"fg" and "bg" colors will not be adjusted.


3. highlight arguments for the GUI

gui={attr-list}						*highlight-gui*
	These give the attributes to use in the GUI mode.
	See |attr-list| for a description.
	Note that "bold" can be used here and by using a bold font.  They
	have the same effect.
	Note that the attributes are ignored for the "Normal" group.

font={font-name}					*highlight-font*
	font-name is the name of a font, as it is used on the system Vim
	runs on.  For X11 this is a complicated name, for example: >
   font=-misc-fixed-bold-r-normal--14-130-75-75-c-70-iso8859-1
<
	The font-name "NONE" can be used to revert to the default font.
	When setting the font for the "Normal" group, this becomes the default
	font (until the 'guifont' option is changed; the last one set is
	used).
	The following only works with Motif, not with other GUIs:
	When setting the font for the "Menu" group, the menus will be changed.
	When setting the font for the "Tooltip" group, the tooltips will be
	changed.
	All fonts used, except for Menu and Tooltip, should be of the same
	character size as the default font!  Otherwise redrawing problems will
	occur.
	To use a font name with an embedded space or other special character,
	put it in single quotes.  The single quote cannot be used then.
	Example: >
	    :hi comment font='Monospace 10'

guifg={color-name}					*highlight-guifg*
guibg={color-name}					*highlight-guibg*
guisp={color-name}					*highlight-guisp*
	These give the foreground (guifg), background (guibg) and special
	(guisp) color to use in the GUI.  "guisp" is used for undercurl and
	strikethrough.
	There are a few special names:
		NONE		no color (transparent)		*E1361*
		bg		use normal background color
		background	use normal background color
		fg		use normal foreground color
		foreground	use normal foreground color
	To use a color name with an embedded space or other special character,
	put it in single quotes.  The single quote cannot be used then.
	Example: >
	    :hi comment guifg='salmon pink'
<
							*gui-colors*
	Suggested color names (these are available on most systems):
	    Red		LightRed	DarkRed
	    Green	LightGreen	DarkGreen	SeaGreen
	    Blue	LightBlue	DarkBlue	SlateBlue
	    Cyan	LightCyan	DarkCyan
	    Magenta	LightMagenta	DarkMagenta
	    Yellow	LightYellow	Brown		DarkYellow
	    Gray	LightGray	DarkGray
	    Black	White
	    Orange	Purple		Violet

	In the Win32 GUI version, additional system colors are available.  See
	|win32-colors|.

	You can also specify a color by its Red, Green and Blue values.
	The format is "#rrggbb", where
		"rr"	is the Red value
		"gg"	is the Green value
		"bb"	is the Blue value
	All values are hexadecimal, range from "00" to "ff".  Examples: >
	    :highlight Comment guifg=#11f0c3 guibg=#ff00ff
<
	If you are authoring a color scheme and use the same hexadecimal value
	repeatedly, you can define a name for it in |v:colornames|. For
	example: >

	    # provide a default value for this color but allow the user to
	    # override it.
	    :call extend(v:colornames, {'alt_turquoise': '#11f0c3'}, 'keep')
	    :highlight Comment guifg=alt_turquoise guibg=magenta
<
	If you are using a color scheme that relies on named colors and you
	would like to adjust the precise appearance of those colors, you can
	do so by overriding the values in |v:colornames| prior to loading the
	scheme: >

	    let v:colornames['alt_turquoise'] = '#22f0d3'
	    colorscheme alt
<
	If you want to develop a color list that can be relied on by others,
	it is best to prefix your color names. By convention these color lists
	are placed in the colors/lists directory. You can see an example in
	'$VIMRUNTIME/colors/lists/csscolors.vim'. This list would be sourced
	by a color scheme using: >

	    :runtime colors/lists/csscolors.vim
	    :highlight Comment guifg=css_turquoise
<

					*highlight-groups* *highlight-default*
These are the default highlighting groups.  These groups are used by the
'highlight' option default.  Note that the highlighting depends on the value
of 'background'.  You can see the current settings with the ":highlight"
command.
When possible the name is highlighted in the used colors.  If this makes it
unreadable use Visual selection.

							*hl-ColorColumn*
ColorColumn	Used for the columns set with 'colorcolumn'.
							*hl-Conceal*
Conceal		Placeholder characters substituted for concealed
		text (see 'conceallevel').
						*hl-Cursor* *hl-lCursor*
Cursor		Character under the cursor.
lCursor		Character under the cursor when |language-mapping|
		is used (see 'guicursor').
							*hl-CursorIM*
CursorIM	Like Cursor, but used when in IME mode. |CursorIM|
							*hl-CursorColumn*
CursorColumn	Screen column that the cursor is in when 'cursorcolumn' is set.
							*hl-CursorLine*
CursorLine	Screen line that the cursor is in when 'cursorline' is set.
							*hl-Directory*
Directory	Directory names (and other special names in listings).
							*hl-DiffAdd*
DiffAdd		Diff mode: Added line. |diff.txt|
							*hl-DiffChange*
DiffChange	Diff mode: Changed line. |diff.txt|
							*hl-DiffDelete*
DiffDelete	Diff mode: Deleted line. |diff.txt|
							*hl-DiffText*
DiffText	Diff mode: Changed text within a changed line. |diff.txt|
							*hl-EndOfBuffer*
EndOfBuffer	Filler lines (~) after the last line in the buffer.
		By default, this is highlighted like |hl-NonText|.
							*hl-ErrorMsg*
ErrorMsg	Error messages on the command line.
							*hl-VertSplit*
VertSplit	Column separating vertically split windows.
							*hl-Folded*
Folded		Line used for closed folds.
							*hl-FoldColumn*
FoldColumn	'foldcolumn'
							*hl-SignColumn*
SignColumn	Column where |signs| are displayed.
							*hl-IncSearch*
IncSearch	'incsearch' highlighting; also used for the text replaced with
		":s///c".
							*hl-LineNr*
LineNr		Line number for ":number" and ":#" commands, and when 'number'
		or 'relativenumber' option is set.
							*hl-LineNrAbove*
LineNrAbove	Line number for when the 'relativenumber'
		option is set, above the cursor line.
							*hl-LineNrBelow*
LineNrBelow	Line number for when the 'relativenumber'
		option is set, below the cursor line.
							*hl-CursorLineNr*
CursorLineNr	Like LineNr when 'cursorline' is set and 'cursorlineopt'
		contains "number" or is "both", for the cursor line.
							*hl-CursorLineFold*
CursorLineFold	Like FoldColumn when 'cursorline' is set for the cursor line.
							*hl-CursorLineSign*
CursorLineSign	Like SignColumn when 'cursorline' is set for the cursor line.
							*hl-MatchParen*
MatchParen	Character under the cursor or just before it, if it
		is a paired bracket, and its match. |pi_paren.txt|
							*hl-MessageWindow*
MessageWindow	Messages popup window used by `:echowindow`.  If not defined
		|hl-WarningMsg| is used.
							*hl-ModeMsg*
ModeMsg		'showmode' message (e.g., "-- INSERT --").
							*hl-MoreMsg*
MoreMsg		|more-prompt|
							*hl-NonText*
NonText		'@' at the end of the window, "<<<" at the start of the window
		for 'smoothscroll', characters from 'showbreak' and other
		characters that do not really exist in the text, such as the
		">" displayed when a double-wide character doesn't fit at the
		end of the line.
							*hl-Normal*
Normal		Normal text.
							*hl-Pmenu*
Pmenu		Popup menu: Normal item.
							*hl-PmenuSel*
PmenuSel	Popup menu: Selected item.
							*hl-PmenuSbar*
PmenuSbar	Popup menu: Scrollbar.
							*hl-PmenuThumb*
PmenuThumb	Popup menu: Thumb of the scrollbar.
							*hl-PopupNotification*
PopupNotification
		Popup window created with |popup_notification()|.  If not
		defined |hl-WarningMsg| is used.
							*hl-Question*
Question	|hit-enter| prompt and yes/no questions.
							*hl-QuickFixLine*
QuickFixLine	Current |quickfix| item in the quickfix window.
							*hl-Search*
Search		Last search pattern highlighting (see 'hlsearch').
		Also used for similar items that need to stand out.
							*hl-CurSearch*
CurSearch	Current match for the last search pattern (see 'hlsearch').
		Note: This is correct after a search, but may get outdated if
		changes are made or the screen is redrawn.
							*hl-SpecialKey*
SpecialKey	Meta and special keys listed with ":map", also for text used
		to show unprintable characters in the text, 'listchars'.
		Generally: Text that is displayed differently from what it
		really is.
							*hl-SpellBad*
SpellBad	Word that is not recognized by the spellchecker. |spell|
		This will be combined with the highlighting used otherwise.
							*hl-SpellCap*
SpellCap	Word that should start with a capital. |spell|
		This will be combined with the highlighting used otherwise.
							*hl-SpellLocal*
SpellLocal	Word that is recognized by the spellchecker as one that is
		used in another region. |spell|
		This will be combined with the highlighting used otherwise.
							*hl-SpellRare*
SpellRare	Word that is recognized by the spellchecker as one that is
		hardly ever used. |spell|
		This will be combined with the highlighting used otherwise.
							*hl-StatusLine*
StatusLine	Status line of current window.
							*hl-StatusLineNC*
StatusLineNC	status lines of not-current windows
		Note: If this is equal to "StatusLine", Vim will use "^^^" in
		the status line of the current window.
							*hl-StatusLineTerm*
StatusLineTerm	Status line of current window, if it is a |terminal| window.
							*hl-StatusLineTermNC*
StatusLineTermNC	Status lines of not-current windows that is a
			|terminal| window.
							*hl-TabLine*
TabLine		Tab pages line, not active tab page label.
							*hl-TabLineFill*
TabLineFill	Tab pages line, where there are no labels.
							*hl-TabLineSel*
TabLineSel	Tab pages line, active tab page label.
							*hl-Terminal*
Terminal	|terminal| window (see |terminal-size-color|).
							*hl-Title*
Title		Titles for output from ":set all", ":autocmd" etc.
							*hl-Visual*
Visual		Visual mode selection.
							*hl-VisualNOS*
VisualNOS	Visual mode selection when vim is "Not Owning the Selection".
		Only X11 Gui's |gui-x11| and |xterm-clipboard| supports this.
							*hl-WarningMsg*
WarningMsg	Warning messages.
							*hl-WildMenu*
WildMenu	Current match in 'wildmenu' completion.

					*hl-User1* *hl-User1..9* *hl-User9*
The 'statusline' syntax allows the use of 9 different highlights in the
statusline and ruler (via 'rulerformat').  The names are User1 to User9.

For the GUI you can use the following groups to set the colors for the menu,
scrollbars and tooltips.  They don't have defaults.  This doesn't work for the
Win32 GUI.  Only three highlight arguments have any effect here: font, guibg,
and guifg.

							*hl-Menu*
Menu		Current font, background and foreground colors of the menus.
		Also used for the toolbar.
		Applicable highlight arguments: font, guibg, guifg.

		NOTE: For Motif the font argument actually
		specifies a fontset at all times, no matter if 'guifontset' is
		empty, and as such it is tied to the current |:language| when
		set.

							*hl-Scrollbar*
Scrollbar	Current background and foreground of the main window's
		scrollbars.
		Applicable highlight arguments: guibg, guifg.

							*hl-Tooltip*
Tooltip		Current font, background and foreground of the tooltips.
		Applicable highlight arguments: font, guibg, guifg.

		NOTE: For Motif the font argument actually
		specifies a fontset at all times, no matter if 'guifontset' is
		empty, and as such it is tied to the current |:language| when
		set.

==============================================================================
15. Linking groups		*:hi-link* *:highlight-link* *E412* *E413*

When you want to use the same highlighting for several syntax groups, you
can do this more easily by linking the groups into one common highlight
group, and give the color attributes only for that group.

To set a link:

    :hi[ghlight][!] [default] link {from-group} {to-group}

To remove a link:

    :hi[ghlight][!] [default] link {from-group} NONE

Notes:							*E414*
- If the {from-group} and/or {to-group} doesn't exist, it is created.  You
  don't get an error message for a non-existing group.
- As soon as you use a ":highlight" command for a linked group, the link is
  removed.
- If there are already highlight settings for the {from-group}, the link is
  not made, unless the '!' is given.  For a ":highlight link" command in a
  sourced file, you don't get an error message.  This can be used to skip
  links for groups that already have settings.

					*:hi-default* *:highlight-default*
The [default] argument is used for setting the default highlighting for a
group.	If highlighting has already been specified for the group the command
will be ignored.  Also when there is an existing link.

Using [default] is especially useful to overrule the highlighting of a
specific syntax file.  For example, the C syntax file contains: >
	:highlight default link cComment Comment
If you like Question highlighting for C comments, put this in your vimrc file: >
	:highlight link cComment Question
Without the "default" in the C syntax file, the highlighting would be
overruled when the syntax file is loaded.

To have a link survive `:highlight clear`, which is useful if you have
highlighting for a specific filetype and you want to keep it when selecting
another color scheme, put a command like this in the
"after/syntax/{filetype}.vim" file: >
    highlight! default link cComment Question

==============================================================================
16. Cleaning up						*:syn-clear* *E391*

If you want to clear the syntax stuff for the current buffer, you can use this
command: >
  :syntax clear

This command should be used when you want to switch off syntax highlighting,
or when you want to switch to using another syntax.  It's normally not needed
in a syntax file itself, because syntax is cleared by the autocommands that
load the syntax file.
The command also deletes the "b:current_syntax" variable, since no syntax is
loaded after this command.

To clean up specific syntax groups for the current buffer: >
  :syntax clear {group-name} ..
This removes all patterns and keywords for {group-name}.

To clean up specific syntax group lists for the current buffer: >
  :syntax clear @{grouplist-name} ..
This sets {grouplist-name}'s contents to an empty list.

						*:syntax-off* *:syn-off*
If you want to disable syntax highlighting for all buffers, you need to remove
the autocommands that load the syntax files: >
  :syntax off

What this command actually does, is executing the command >
  :source $VIMRUNTIME/syntax/nosyntax.vim
See the "nosyntax.vim" file for details.  Note that for this to work
$VIMRUNTIME must be valid.  See |$VIMRUNTIME|.

						*:syntax-reset* *:syn-reset*
If you have changed the colors and messed them up, use this command to get the
defaults back: >

  :syntax reset

It is a bit of a wrong name, since it does not reset any syntax items, it only
affects the highlighting.

This doesn't change the colors for the 'highlight' option.

Note that the syntax colors that you set in your vimrc file will also be reset
back to their Vim default.
Note that if you are using a color scheme, the colors defined by the color
scheme for syntax highlighting will be lost.

What this actually does is: >

	let g:syntax_cmd = "reset"
	runtime! syntax/syncolor.vim

Note that this uses the 'runtimepath' option.

							*syncolor*
If you want to use different colors for syntax highlighting, you can add a Vim
script file to set these colors.  Put this file in a directory in
'runtimepath' which comes after $VIMRUNTIME, so that your settings overrule
the default colors.  This way these colors will be used after the ":syntax
reset" command.

For Unix you can use the file ~/.vim/after/syntax/syncolor.vim.  Example: >

	if &background == "light"
	  highlight comment ctermfg=darkgreen guifg=darkgreen
	else
	  highlight comment ctermfg=green guifg=green
	endif
<
