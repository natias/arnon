    default=False,
)
coreconfigitem(
    b'ui',
    b'available-memory',
    default=None,
)

coreconfigitem(
    b'ui',
    b'clonebundlefallback',
    default=False,
)
coreconfigitem(
    b'ui',
    b'clonebundleprefers',
    default=list,
)
coreconfigitem(
    b'ui',
    b'clonebundles',
    default=True,
)
coreconfigitem(
    b'ui',
    b'color',
    default=b'auto',
)
coreconfigitem(
    b'ui',
    b'commitsubrepos',
    default=False,
)
coreconfigitem(
    b'ui',
    b'debug',
    default=False,
)
coreconfigitem(
    b'ui',
    b'debugger',
    default=None,
)
coreconfigitem(
    b'ui',
    b'editor',
    default=dynamicdefault,
)
coreconfigitem(
    b'ui',
    b'detailed-exit-code',
    default=False,
    experimental=True,
)
coreconfigitem(
    b'ui',
    b'fallbackencoding',
    default=None,
)
coreconfigitem(
    b'ui',
    b'forcecwd',
    default=None,
)
coreconfigitem(
    b'ui',
    b'forcemerge',
    default=None,
)
coreconfigitem(
    b'ui',
    b'formatdebug',
    default=False,
)
coreconfigitem(
    b'ui',
    b'formatjson',
    default=False,
)
coreconfigitem(
    b'ui',
    b'formatted',
    default=None,
)
coreconfigitem(
    b'ui',
    b'interactive',
    default=None,
)
coreconfigitem(
    b'ui',
    b'interface',
    default=None,
)
coreconfigitem(
    b'ui',
    b'interface.chunkselector',
    default=None,
)
coreconfigitem(
    b'ui',
    b'large-file-limit',
    default=10 * (2 ** 20),
)
coreconfigitem(
    b'ui',
    b'logblockedtimes',
    default=False,
)
coreconfigitem(
    b'ui',
    b'merge',
    default=None,
)
coreconfigitem(
    b'ui',
    b'mergemarkers',
    default=b'basic',
)
coreconfigitem(
    b'ui',
    b'message-output',
    default=b'stdio',
)
coreconfigitem(
    b'ui',
    b'nontty',
    default=False,
)
coreconfigitem(
    b'ui',
    b'origbackuppath',
    default=None,
)
coreconfigitem(
    b'ui',
    b'paginate',
    default=True,
)
coreconfigitem(
    b'ui',
    b'patch',
    default=None,
)
coreconfigitem(
    b'ui',
    b'portablefilenames',
    default=b'warn',
)
coreconfigitem(
    b'ui',
    b'promptecho',
    default=False,
)
coreconfigitem(
    b'ui',
    b'quiet',
    default=False,
)
coreconfigitem(
    b'ui',
    b'quietbookmarkmove',
    default=False,
)
coreconfigitem(
    b'ui',
    b'relative-paths',
    default=b'legacy',
)
coreconfigitem(
    b'ui',
    b'remotecmd',
    default=b'hg',
)
coreconfigitem(
    b'ui',
    b'report_untrusted',
    default=True,
)
coreconfigitem(
    b'ui',
    b'rollback',
    default=True,
)
coreconfigitem(
    b'ui',
    b'signal-safe-lock',
    default=True,
)
coreconfigitem(
    b'ui',
    b'slash',
    default=False,
)
coreconfigitem(
    b'ui',
    b'ssh',
    default=b'ssh',
)
coreconfigitem(
    b'ui',
    b'ssherrorhint',
    default=None,
)
coreconfigitem(
    b'ui',
    b'statuscopies',
    default=False,
)
coreconfigitem(
    b'ui',
    b'strict',
    default=False,
)
coreconfigitem(
    b'ui',
    b'style',
    default=b'',
)
coreconfigitem(
    b'ui',
    b'supportcontact',
    default=None,
)
coreconfigitem(
    b'ui',
    b'textwidth',
    default=78,
)
coreconfigitem(
    b'ui',
    b'timeout',
    default=b'600',
)
coreconfigitem(
    b'ui',
    b'timeout.warn',
    default=0,
)
coreconfigitem(
    b'ui',
    b'timestamp-output',
    default=False,
)
coreconfigitem(
    b'ui',
    b'traceback',
    default=False,
)
coreconfigitem(
    b'ui',
    b'tweakdefaults',
    default=False,
)
coreconfigitem(b'ui', b'username', alias=[(b'ui', b'user')])
coreconfigitem(
    b'ui',
    b'verbose',
    default=False,
)
coreconfigitem(
    b'verify',
    b'skipflags',
    default=0,
)
coreconfigitem(
    b'web',
    b'allowbz2',
    default=False,
)
coreconfigitem(
    b'web',
    b'allowgz',
    default=False,
)
coreconfigitem(
    b'web',
    b'allow-pull',
    alias=[(b'web', b'allowpull')],
    default=True,
)
coreconfigitem(
    b'web',
    b'allow-push',
    alias=[(b'web', b'allow_push')],
    default=list,
)
coreconfigitem(
    b'web',
    b'allowzip',
    default=False,
)
coreconfigitem(
    b'web',
    b'archivesubrepos',
    default=False,
)
coreconfigitem(
    b'web',
    b'cache',
    default=True,
)
coreconfigitem(
    b'web',
    b'comparisoncontext',
    default=5,
)
coreconfigitem(
    b'web',
    b'contact',
    default=None,
)
coreconfigitem(
    b'web',
    b'deny_push',
    default=list,
)
coreconfigitem(
    b'web',
    b'guessmime',
    default=False,
)
coreconfigitem(
    b'web',
    b'hidden',
    default=False,
)
coreconfigitem(
    b'web',
    b'labels',
    default=list,
)
coreconfigitem(
    b'web',
    b'logoimg',
    default=b'hglogo.png',
)
coreconfigitem(
    b'web',
    b'logourl',
    default=b'https://mercurial-scm.org/',
)
coreconfigitem(
    b'web',
    b'accesslog',
    default=b'-',
)
coreconfigitem(
    b'web',
    b'address',
    default=b'',
)
coreconfigitem(
    b'web',
    b'allow-archive',
    alias=[(b'web', b'allow_archive')],
    default=list,
)
coreconfigitem(
    b'web',
    b'allow_read',
    default=list,
)
coreconfigitem(
    b'web',
    b'baseurl',
    default=None,
)
coreconfigitem(
    b'web',
    b'cacerts',
    default=None,
)
coreconfigitem(
    b'web',
    b'certificate',
    default=None,
)
coreconfigitem(
    b'web',
    b'collapse',
    default=False,
)
coreconfigitem(
    b'web',
    b'csp',
    default=None,
)
coreconfigitem(
    b'web',
    b'deny_read',
    default=list,
)
coreconfigitem(
    b'web',
    b'descend',
    default=True,
)
coreconfigitem(
    b'web',
    b'description',
    default=b"",
)
coreconfigitem(
    b'web',
    b'encoding',
    default=lambda: encoding.encoding,
)
coreconfigitem(
    b'web',
    b'errorlog',
    default=b'-',
)
coreconfigitem(
    b'web',
    b'ipv6',
    default=False,
)
coreconfigitem(
    b'web',
    b'maxchanges',
    default=10,
)
coreconfigitem(
    b'web',
    b'maxfiles',
    default=10,
)
coreconfigitem(
    b'web',
    b'maxshortchanges',
    default=60,
)
coreconfigitem(
    b'web',
    b'motd',
    default=b'',
)
coreconfigitem(
    b'web',
    b'name',
    default=dynamicdefault,
)
coreconfigitem(
    b'web',
    b'port',
    default=8000,
)
coreconfigitem(
    b'web',
    b'prefix',
    default=b'',
)
coreconfigitem(
    b'web',
    b'push_ssl',
    default=True,
)
coreconfigitem(
    b'web',
    b'refreshinterval',
    default=20,
)
coreconfigitem(
    b'web',
    b'server-header',
    default=None,
)
coreconfigitem(
    b'web',
    b'static',
    default=None,
)
coreconfigitem(
    b'web',
    b'staticurl',
    default=None,
)
coreconfigitem(
    b'web',
    b'stripes',
    default=1,
)
coreconfigitem(
    b'web',
    b'style',
    default=b'paper',
)
coreconfigitem(
    b'web',
    b'templates',
    default=None,
)
coreconfigitem(
    b'web',
    b'view',
    default=b'served',
    experimental=True,
)
coreconfigitem(
    b'worker',
    b'backgroundclose',
    default=dynamicdefault,
)
# Windows defaults to a limit of 512 open files. A buffer of 128
# should give us enough headway.
coreconfigitem(
    b'worker',
    b'backgroundclosemaxqueue',
    default=384,
)
coreconfigitem(
    b'worker',
    b'backgroundcloseminfilecount',
    default=2048,
)
coreconfigitem(
    b'worker',
    b'backgroundclosethreadcount',
    default=4,
)
coreconfigitem(
    b'worker',
    b'enabled',
    default=True,
)
coreconfigitem(
    b'worker',
    b'numcpus',
    default=None,
)

# Rebase related configuration moved to core because other extension are doing
# strange things. For example, shelve import the extensions to reuse some bit
# without formally loading it.
coreconfigitem(
    b'commands',
    b'rebase.requiredest',
    default=False,
)
coreconfigitem(
    b'experimental',
    b'rebaseskipobsolete',
    default=True,
)
coreconfigitem(
    b'rebase',
    b'singletransaction',
    default=False,
)
coreconfigitem(
    b'rebase',
    b'experimental.inmemory',
    default=False,
)

# This setting controls creation of a rebase_source extra field
# during rebase. When False, no such field is created. This is
# useful eg for incrementally converting changesets and then
# rebasing them onto an existing repo.
# WARNING: this is an advanced setting reserved for people who know
# exactly what they are doing. Misuse of this setting can easily
# result in obsmarker cycles and a vivid headache.
coreconfigitem(
    b'rebase',
    b'store-source',
    default=True,
    experimental=True,
)
                                                                    usr/lib/python3/dist-packages/mercurial/context.py                                                  0000644 0000000 0000000 00000311614 14355257011 021000  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # context.py - changeset and file context objects for mercurial
#
# Copyright 2006, 2007 Olivia Mackall <olivia@selenic.com>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 2 or any later version.


import filecmp
import os
import stat

from .i18n import _
from .node import (
    hex,
    nullrev,
    short,
)
from .pycompat import (
    getattr,
)
from . import (
    dagop,
    encoding,
    error,
    fileset,
    match as matchmod,
    mergestate as mergestatemod,
    metadata,
    obsolete as obsmod,
    patch,
    pathutil,
    phases,
    repoview,
    scmutil,
    sparse,
    subrepo,
    subrepoutil,
    util,
)
from .utils import (
    dateutil,
    stringutil,
)
from .dirstateutils import (
    timestamp,
)

propertycache = util.propertycache


class basectx:
    """A basectx object represents the common logic for its children:
    changectx: read-only context that is already present in the repo,
    workingctx: a context that represents the working directory and can
                be committed,
    memctx: a context that represents changes in-memory and can also
            be committed."""

    def __init__(self, repo):
        self._repo = repo

    def __bytes__(self):
        return short(self.node())

    __str__ = encoding.strmethod(__bytes__)

    def __repr__(self):
        return "<%s %s>" % (type(self).__name__, str(self))

    def __eq__(self, other):
        try:
            return type(self) == type(other) and self._rev == other._rev
        except AttributeError:
            return False

    def __ne__(self, other):
        return not (self == other)

    def __contains__(self, key):
        return key in self._manifest

    def __getitem__(self, key):
        return self.filectx(key)

    def __iter__(self):
        return iter(self._manifest)

    def _buildstatusmanifest(self, status):
        """Builds a manifest that includes the given status results, if this is
        a working copy context. For non-working copy contexts, it just returns
        the normal manifest."""
        return self.manifest()

    def _matchstatus(self, other, match):
        """This internal method provides a way for child objects to override the
        match operator.
        """
        return match

    def _buildstatus(
        self, other, s, match, listignored, listclean, listunknown
    ):
        """build a status with respect to another context"""
        # Load earliest manifest first for caching reasons. More specifically,
        # if you have revisions 1000 and 1001, 1001 is probably stored as a
        # delta against 1000. Thus, if you read 1000 first, we'll reconstruct
        # 1000 and cache it so that when you read 1001, we just need to apply a
        # delta to what's in the cache. So that's one full reconstruction + one
        # delta application.
        mf2 = None
        if self.rev() is not None and self.rev() < other.rev():
            mf2 = self._buildstatusmanifest(s)
        mf1 = other._buildstatusmanifest(s)
        if mf2 is None:
            mf2 = self._buildstatusmanifest(s)

        modified, added = [], []
        removed = []
        clean = []
        deleted, unknown, ignored = s.deleted, s.unknown, s.ignored
        deletedset = set(deleted)
        d = mf1.diff(mf2, match=match, clean=listclean)
        for fn, value in d.items():
            if fn in deletedset:
                continue
            if value is None:
                clean.append(fn)
                continue
            (node1, flag1), (node2, flag2) = value
            if node1 is None:
                added.append(fn)
            elif node2 is None:
                removed.append(fn)
            elif flag1 != flag2:
                modified.append(fn)
            elif node2 not in self._repo.nodeconstants.wdirfilenodeids:
                # When comparing files between two commits, we save time by
                # not comparing the file contents when the nodeids differ.
                # Note that this means we incorrectly report a reverted change
                # to a file as a modification.
                modified.append(fn)
            elif self[fn].cmp(other[fn]):
                modified.append(fn)
            else:
                clean.append(fn)

        if removed:
            # need to filter files if they are already reported as removed
            unknown = [
                fn
                for fn in unknown
                if fn not in mf1 and (not match or match(fn))
            ]
            ignored = [
                fn
                for fn in ignored
                if fn not in mf1 and (not match or match(fn))
            ]
            # if they're deleted, don't report them as removed
            removed = [fn for fn in removed if fn not in deletedset]

        return scmutil.status(
            modified, added, removed, deleted, unknown, ignored, clean
        )

    @propertycache
    def substate(self):
        return subrepoutil.state(self, self._repo.ui)

    def subrev(self, subpath):
        return self.substate[subpath][1]

    def rev(self):
        return self._rev

    def node(self):
        return self._node

    def hex(self):
        return hex(self.node())

    def manifest(self):
        return self._manifest

    def manifestctx(self):
        return self._manifestctx

    def repo(self):
        return self._repo

    def phasestr(self):
        return phases.phasenames[self.phase()]

    def mutable(self):
        return self.phase() > phases.public

    def matchfileset(self, cwd, expr, badfn=None):
        return fileset.match(self, cwd, expr, badfn=badfn)

    def obsolete(self):
        """True if the changeset is obsolete"""
        return self.rev() in obsmod.getrevs(self._repo, b'obsolete')

    def extinct(self):
        """True if the changeset is extinct"""
        return self.rev() in obsmod.getrevs(self._repo, b'extinct')

    def orphan(self):
        """True if the changeset is not obsolete, but its ancestor is"""
        return self.rev() in obsmod.getrevs(self._repo, b'orphan')

    def phasedivergent(self):
        """True if the changeset tries to be a successor of a public changeset

        Only non-public and non-obsolete changesets may be phase-divergent.
        """
        return self.rev() in obsmod.getrevs(self._repo, b'phasedivergent')

    def contentdivergent(self):
        """Is a successor of a changeset with multiple possible successor sets

        Only non-public and non-obsolete changesets may be content-divergent.
        """
        return self.rev() in obsmod.getrevs(self._repo, b'contentdivergent')

    def isunstable(self):
        """True if the changeset is either orphan, phase-divergent or
        content-divergent"""
        return self.orphan() or self.phasedivergent() or self.contentdivergent()

    def instabilities(self):
        """return the list of instabilities affecting this changeset.

        Instabilities are returned as strings. possible values are:
        - orphan,
        - phase-divergent,
        - content-divergent.
        """
        instabilities = []
        if self.orphan():
            instabilities.append(b'orphan')
        if self.phasedivergent():
            instabilities.append(b'phase-divergent')
        if self.contentdivergent():
            instabilities.append(b'content-divergent')
        return instabilities

    def parents(self):
        """return contexts for each parent changeset"""
        return self._parents

    def p1(self):
        return self._parents[0]

    def p2(self):
        parents = self._parents
        if len(parents) == 2:
            return parents[1]
        return self._repo[nullrev]

    def _fileinfo(self, path):
        if '_manifest' in self.__dict__:
            try:
                return self._manifest.find(path)
            except KeyError:
                raise error.ManifestLookupError(
                    self._node or b'None', path, _(b'not found in manifest')
                )
        if '_manifestdelta' in self.__dict__ or path in self.files():
            if path in self._manifestdelta:
                return (
                    self._manifestdelta[path],
                    self._manifestdelta.flags(path),
                )
        mfl = self._repo.manifestlog
        try:
            node, flag = mfl[self._changeset.manifest].find(path)
        except KeyError:
            raise error.ManifestLookupError(
                self._node or b'None', path, _(b'not found in manifest')
            )

        return node, flag

    def filenode(self, path):
        return self._fileinfo(path)[0]

    def flags(self, path):
        try:
            return self._fileinfo(path)[1]
        except error.LookupError:
            return b''

    @propertycache
    def _copies(self):
        return metadata.computechangesetcopies(self)

    def p1copies(self):
        return self._copies[0]

    def p2copies(self):
        return self._copies[1]

    def sub(self, path, allowcreate=True):
        '''return a subrepo for the stored revision of path, never wdir()'''
        return subrepo.subrepo(self, path, allowcreate=allowcreate)

    def nullsub(self, path, pctx):
        return subrepo.nullsubrepo(self, path, pctx)

    def workingsub(self, path):
        """return a subrepo for the stored revision, or wdir if this is a wdir
        context.
        """
        return subrepo.subrepo(self, path, allowwdir=True)

    def match(
        self,
        pats=None,
        include=None,
        exclude=None,
        default=b'glob',
        listsubrepos=False,
        badfn=None,
        cwd=None,
    ):
        r = self._repo
        if not cwd:
            cwd = r.getcwd()
        return matchmod.match(
            r.root,
            cwd,
            pats,
            include,
            exclude,
            default,
            auditor=r.nofsauditor,
            ctx=self,
            listsubrepos=listsubrepos,
            badfn=badfn,
        )

    def diff(
        self,
        ctx2=None,
        match=None,
        changes=None,
        opts=None,
        losedatafn=None,
        pathfn=None,
        copy=None,
        copysourcematch=None,
        hunksfilterfn=None,
    ):
        """Returns a diff generator for the given contexts and matcher"""
        if ctx2 is None:
            ctx2 = self.p1()
        if ctx2 is not None:
            ctx2 = self._repo[ctx2]
        return patch.diff(
            self._repo,
            ctx2,
            self,
            match=match,
            changes=changes,
            opts=opts,
            losedatafn=losedatafn,
            pathfn=pathfn,
            copy=copy,
            copysourcematch=copysourcematch,
            hunksfilterfn=hunksfilterfn,
        )

    def dirs(self):
        return self._manifest.dirs()

    def hasdir(self, dir):
        return self._manifest.hasdir(dir)

    def status(
        self,
        other=None,
        match=None,
        listignored=False,
        listclean=False,
        listunknown=False,
        listsubrepos=False,
    ):
        """return status of files between two nodes or node and working
        directory.

        If other is None, compare this node with working directory.

        ctx1.status(ctx2) returns the status of change from ctx1 to ctx2

        Returns a mercurial.scmutils.status object.

        Data can be accessed using either tuple notation:

            (modified, added, removed, deleted, unknown, ignored, clean)

        or direct attribute access:

            s.modified, s.added, ...
        """

        ctx1 = self
        ctx2 = self._repo[other]

        # This next code block is, admittedly, fragile logic that tests for
        # reversing the contexts and wouldn't need to exist if it weren't for
        # the fast (and common) code path of comparing the working directory
        # with its first parent.
        #
        # What we're aiming for here is the ability to call:
        #
        # workingctx.status(parentctx)
        #
        # If we always built the manifest for each context and compared those,
        # then we'd be done. But the special case of the above call means we
        # just copy the manifest of the parent.
        reversed = False
        if not isinstance(ctx1, changectx) and isinstance(ctx2, changectx):
            reversed = True
            ctx1, ctx2 = ctx2, ctx1

        match = self._repo.narrowmatch(match)
        match = ctx2._matchstatus(ctx1, match)
        r = scmutil.status([], [], [], [], [], [], [])
        r = ctx2._buildstatus(
