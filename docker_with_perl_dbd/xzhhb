				before inserting the char.
				The |v:char| variable indicates the char typed
				and can be changed during the event to insert
				a different character.  When |v:char| is set
				to more than one character this text is
				inserted literally.
				It is not allowed to change the text |textlock|.
				The event is not triggered when 'paste' is
				set. {only with the +eval feature}
							*InsertEnter*
InsertEnter			Just before starting Insert mode.  Also for
				Replace mode and Virtual Replace mode.  The
				|v:insertmode| variable indicates the mode.
				Be careful not to do anything else that the
				user does not expect.
				The cursor is restored afterwards.  If you do
				not want that set |v:char| to a non-empty
				string.
							*InsertLeavePre*
InsertLeavePre			Just before leaving Insert mode.  Also when
				using CTRL-O |i_CTRL-O|.  Be careful not to
				change mode or use `:normal`, it will likely
				cause trouble.
							*InsertLeave*
InsertLeave			Just after leaving Insert mode.  Also when
				using CTRL-O |i_CTRL-O|.  But not for |i_CTRL-C|.
							*MenuPopup*
MenuPopup			Just before showing the popup menu (under the
				right mouse button).  Useful for adjusting the
				menu for what is under the cursor or mouse
				pointer.
				The pattern is matched against one or two
				characters representing the mode:
					n	Normal
					v	Visual
					o	Operator-pending
					i	Insert
					c	Command line
					tl	Terminal
							*ModeChanged*
ModeChanged			After changing the mode. The pattern is
				matched against `'old_mode:new_mode'`, for
				example match against `*:c*` to simulate
				|CmdlineEnter|.
				The following values of |v:event| are set:
				   old_mode	The mode before it changed.
				   new_mode	The new mode as also returned
						by |mode()| called with a
						non-zero argument.
				When ModeChanged is triggered, old_mode will
				have the value of new_mode when the event was
				last triggered.
				This will be triggered on every minor mode
				change.
				Usage example to use relative line numbers
				when entering Visual mode: >
	:au ModeChanged [vV\x16]*:* let &l:rnu = mode() =~# '^[vV\x16]'
	:au ModeChanged *:[vV\x16]* let &l:rnu = mode() =~# '^[vV\x16]'
	:au WinEnter,WinLeave * let &l:rnu = mode() =~# '^[vV\x16]'
<							*OptionSet*
OptionSet			After setting an option.  The pattern is
				matched against the long option name.
				|<amatch>| indicates what option has been set.

				|v:option_type| indicates whether it's global
				or local scoped.
				|v:option_command| indicates what type of
				set/let command was used (follow the tag to
				see the table).
				|v:option_new| indicates the newly set value.
				|v:option_oldlocal| has the old local value.
				|v:option_oldglobal| has the old global value.
				|v:option_old| indicates the old option value.

				|v:option_oldlocal| is only set when |:set|
				or |:setlocal| or a |modeline| was used to set
				the option. Similarly |v:option_oldglobal| is
				only set when |:set| or |:setglobal| was used.

				Note that when setting a |global-local| string
				option with |:set|, then |v:option_old| is the
				old global value. However, for all other kinds
				of options (local string options, global-local
				number options, ...) it is the old local
				value.

				OptionSet is not triggered on startup and for
				the 'key' option for obvious reasons.

				Usage example: Check for the existence of the
				directory in the 'backupdir' and 'undodir'
				options, create the directory if it doesn't
				exist yet.

				Note: It's a bad idea to reset an option
				during this autocommand, this may break a
				plugin. You can always use `:noa` to prevent
				triggering this autocommand.

				When using |:set| in the autocommand the event
				is not triggered again.
							*QuickFixCmdPre*
QuickFixCmdPre			Before a quickfix command is run (|:make|,
				|:lmake|, |:grep|, |:lgrep|, |:grepadd|,
				|:lgrepadd|, |:vimgrep|, |:lvimgrep|,
				|:vimgrepadd|, |:lvimgrepadd|, |:cscope|,
				|:cfile|, |:cgetfile|, |:caddfile|, |:lfile|,
				|:lgetfile|, |:laddfile|, |:helpgrep|,
				|:lhelpgrep|, |:cexpr|, |:cgetexpr|,
				|:caddexpr|, |:cbuffer|, |:cgetbuffer|,
				|:caddbuffer|).
				The pattern is matched against the command
				being run.  When |:grep| is used but 'grepprg'
				is set to "internal" it still matches "grep".
				This command cannot be used to set the
				'makeprg' and 'grepprg' variables.
				If this command causes an error, the quickfix
				command is not executed.
							*QuickFixCmdPost*
QuickFixCmdPost			Like QuickFixCmdPre, but after a quickfix
				command is run, before jumping to the first
				location. For |:cfile| and |:lfile| commands
				it is run after the error file is read and
				before moving to the first error.
				See |QuickFixCmdPost-example|.
							*QuitPre*
QuitPre				When using `:quit`, `:wq` or `:qall`, before
				deciding whether it closes the current window
				or quits Vim.  For `:wq` the buffer is written
				before QuitPre is triggered.  Can be used to
				close any non-essential window if the current
				window is the last ordinary window.
				Also see |ExitPre|.
							*RemoteReply*
RemoteReply			When a reply from a Vim that functions as
				server was received |server2client()|.  The
				pattern is matched against the {serverid}.
				<amatch> is equal to the {serverid} from which
				the reply was sent, and <afile> is the actual
				reply string.
				Note that even if an autocommand is defined,
				the reply should be read with |remote_read()|
				to consume it.
							*SafeState*
SafeState			When nothing is pending, going to wait for the
				user to type a character.
				This will not be triggered when:
				- an operator is pending
				- a register was entered with "r
				- halfway executing a command
				- executing a mapping
				- there is typeahead
				- Insert mode completion is active
				- Command line completion is active
				You can use `mode()` to find out what state
				Vim is in.  That may be:
				- VIsual mode
				- Normal mode
				- Insert mode
				- Command-line mode
				Depending on what you want to do, you may also
				check more with `state()`, e.g. whether the
				screen was scrolled for messages.
							*SafeStateAgain*
SafeStateAgain			Like SafeState but after processing any
				messages and invoking callbacks. This may be
				triggered often, don't do something that takes
				time.

							*SessionLoadPost*
SessionLoadPost			After loading the session file created using
				the |:mksession| command.
							*ShellCmdPost*
ShellCmdPost			After executing a shell command with |:!cmd|,
				|:shell|, |:make| and |:grep|.  Can be used to
				check for any changed files.
							*ShellFilterPost*
ShellFilterPost			After executing a shell command with
				":{range}!cmd", ":w !cmd" or ":r !cmd".
				Can be used to check for any changed files.
							*SourcePre*
SourcePre			Before sourcing a Vim script. |:source|
				<afile> is the name of the file being sourced.
							*SourcePost*
SourcePost			After sourcing a Vim script. |:source|
				<afile> is the name of the file being sourced.
				Not triggered when sourcing was interrupted.
				Also triggered after a SourceCmd autocommand
				was triggered.
							*SourceCmd*
SourceCmd			When sourcing a Vim script. |:source|
				<afile> is the name of the file being sourced.
				The autocommand must source this file.
				|Cmd-event|
							*SpellFileMissing*
SpellFileMissing		When trying to load a spell checking file and
				it can't be found.  The pattern is matched
				against the language.  <amatch> is the
				language, 'encoding' also matters.  See
				|spell-SpellFileMissing|.
							*StdinReadPost*
StdinReadPost			After reading from the stdin into the buffer,
				before executing the modelines.  Only used
				when the "-" argument was used when Vim was
				started |--|.
							*StdinReadPre*
StdinReadPre			Before reading from stdin into the buffer.
				Only used when the "-" argument was used when
				Vim was started |--|.
							*SwapExists*
SwapExists			Detected an existing swap file when starting
				to edit a file.  Only when it is possible to
				select a way to handle the situation, when Vim
				would ask the user what to do.
				The |v:swapname| variable holds the name of
				the swap file found, <afile> the file being
				edited.  |v:swapcommand| may contain a command
				to be executed in the opened file.
				The commands should set the |v:swapchoice|
				variable to a string with one character to
				tell Vim what should be done next:
					'o'	open read-only
					'e'	edit the file anyway
					'r'	recover
					'd'	delete the swap file
					'q'	quit, don't edit the file
					'a'	abort, like hitting CTRL-C
				When set to an empty string the user will be
				asked, as if there was no SwapExists autocmd.
							*E812*
				It is not allowed to change to another buffer,
				change a buffer name or change directory
				here.
				{only available with the +eval feature}
							*Syntax*
Syntax				When the 'syntax' option has been set.  The
				pattern is matched against the syntax name.
				<afile> can be used for the name of the file
				where this option was set, and <amatch> for
				the new value of 'syntax'.
				See |:syn-on|.
							*TabClosed*
TabClosed			After closing a tab page.
							*TabEnter*
TabEnter			Just after entering a tab page. |tab-page|
				After triggering the WinEnter and before
				triggering the BufEnter event.
							*TabLeave*
TabLeave			Just before leaving a tab page. |tab-page|
				A WinLeave event will have been triggered
				first.
							*TabNew*
TabNew				When a tab page was created. |tab-page|
				A WinEnter event will have been triggered
				first, TabEnter follows.
							*TermChanged*
TermChanged			After the value of 'term' has changed.  Useful
				for re-loading the syntax file to update the
				colors, fonts and other terminal-dependent
				settings.  Executed for all loaded buffers.
							*TerminalOpen*
TerminalOpen			Just after a terminal buffer was created, with
				`:terminal` or |term_start()|. This event is
				triggered even if the buffer is created
				without a window, with the ++hidden option.
							*TerminalWinOpen*
TerminalWinOpen			Just after a terminal buffer was created, with
				`:terminal` or |term_start()|. This event is
				triggered only if the buffer is created
				with a window.  Can be used to set window
				local options for the terminal window.
							*TermResponse*
TermResponse			After the response to |t_RV| is received from
				the terminal.  The value of |v:termresponse|
				can be used to do things depending on the
				terminal version.  Note that this event may be
				triggered halfway executing another event,
				especially if file I/O, a shell command or
				anything else that takes time is involved.
							*TextChanged*
TextChanged			After a change was made to the text in the
				current buffer in Normal mode.  That is after
				|b:changedtick| has changed (also when that
				happened before the TextChanged autocommand
				was defined).
				Not triggered when there is typeahead or when
				an operator is pending.
				Note: This can not be skipped with
				`:noautocmd`.
				Careful: This is triggered very often, don't
				do anything that the user does not expect or
				that is slow.
							*TextChangedI*
TextChangedI			After a change was made to the text in the
				current buffer in Insert mode.
				Not triggered when the popup menu is visible.
				Otherwise the same as TextChanged.
							*TextChangedP*
TextChangedP			After a change was made to the text in the
				current buffer in Insert mode, only when the
				popup menu is visible.  Otherwise the same as
				TextChanged.
							*TextChangedT*
TextChangedT			After a change was made to the text in the
				current buffer in Terminal mode.
				Otherwise the same as TextChanged.
							*TextYankPost*
TextYankPost			After text has been yanked or deleted in the
				current buffer.  The following values of
				|v:event| can be used to determine the operation
				that triggered this autocmd:
				   inclusive	TRUE if the motion is
						|inclusive| else the motion is
						|exclusive|.
				   operator	The operation performed.
				   regcontents	Text that was stored in the
						register, as a list of lines,
						like with: >
						getreg(r, 1, 1)
<				   regname	Name of the register or empty
						string for the unnamed
						register, see |registers|.
				   regtype	Type of the register, see
						|getregtype()|.
				   visual	True if the operation is
						performed on a |Visual| area.
				Not triggered when |quote_| is used nor when
				called recursively.
				It is not allowed to change the buffer text,
				see |textlock|. *E1064*
				{only when compiled with the +eval feature}

							*User*
User				Never executed automatically.  To be used for
				autocommands that are only executed with
				":doautocmd".
				Note that when `:doautocmd User MyEvent` is
				used while there are no matching autocommands,
				you will get an error.  If you don't want
				that, either check whether an autocommand is
				defined using `exists('#User#MyEvent')` or
				define a dummy autocommand yourself.
				Example: >
				    if exists('#User#MyEvent')
					doautocmd User MyEvent
				    endif
<
							*SigUSR1*
SigUSR1				After the SIGUSR1 signal has been detected.
				Could be used if other ways of notifying Vim
				are not feasible.  E.g. to check for the
				result of a build that takes a long time, or
				when a motion sensor is triggered.
				{only on Unix}

							*UserGettingBored*
UserGettingBored		When the user presses the same key 42 times.
				Just kidding! :-)
							*VimEnter*
VimEnter			After doing all the startup stuff, including
				loading .vimrc files, executing the "-c cmd"
				arguments, creating all windows and loading
				the buffers in them.
				Just before this event is triggered the
				|v:vim_did_enter| variable is set, so that you
				can do: >
				   if v:vim_did_enter
				     call s:init()
				   else
				     au VimEnter * call s:init()
				   endif
<							*VimLeave*
VimLeave			Before exiting Vim, just after writing the
				.viminfo file.  Executed only once, like
				VimLeavePre.
				To detect an abnormal exit use |v:dying|.
				When v:dying is 2 or more this event is not
				triggered.
				To get the exit code use |v:exiting|.
							*VimLeavePre*
VimLeavePre			Before exiting Vim, just before writing the
				.viminfo file.  This is executed only once,
				if there is a match with the name of what
				happens to be the current buffer when exiting.
				Mostly useful with a "*" pattern. >
	:autocmd VimLeavePre * call CleanupStuff()
<				To detect an abnormal exit use |v:dying|.
				When v:dying is 2 or more this event is not
				triggered.
				To get the exit code use |v:exiting|.
							*VimResized*
VimResized			After the Vim window was resized, thus 'lines'
				and/or 'columns' changed.  Not when starting
				up though.
							*VimResume*
VimResume			When the Vim instance is resumed after being
				suspended and |VimSuspend| was triggered.
				Useful for triggering |:checktime| and ensure
				the buffers content did not change while Vim
				was suspended: >
	:autocmd VimResume * checktime
<							*VimSuspend*
VimSuspend			When the Vim instance is suspended.  Only when
				CTRL-Z was typed inside Vim, or when the SIGTSTP
				signal was sent to Vim, but not for SIGSTOP.
							*WinClosed*
WinClosed			When closing a window, just before it is
				removed from the window layout.  The pattern
				is matched against the |window-ID|.  Both
				<amatch> and <afile> are set to the
				|window-ID|.  Non-recursive (event cannot
				trigger itself).
							*WinEnter*
WinEnter			After entering another window.  Not done for
				the first window, when Vim has just started.
				Useful for setting the window height.
				If the window is for another buffer, Vim
				executes the BufEnter autocommands after the
				WinEnter autocommands.
				Note: For split and tabpage commands the
				WinEnter event is triggered after the split
				or tab command but before the file is loaded.

							*WinLeave*
WinLeave			Before leaving a window.  If the window to be
				entered next is for a different buffer, Vim
				executes the BufLeave autocommands before the
				WinLeave autocommands (but not for ":new").
				Not used for ":qa" or ":q" when exiting Vim.

							*WinNew*
WinNew				When a new window was created.  Not done for
				the first window, when Vim has just started.
				Before a WinEnter event.

							*WinScrolled*
WinScrolled			After any window in the current tab page
				scrolled the text (horizontally or vertically)
				or changed width or height.  See
				|win-scrolled-resized|.

				The pattern is matched against the |window-ID|
				of the first window that scrolled or resized.
				Both <amatch> and <afile> are set to the
				|window-ID|.

				|v:event| is set with information about size
				and scroll changes. |WinScrolled-event|

				Only starts triggering after startup finished
				and the first screen redraw was done.
				Does not trigger when defining the first
				WinScrolled or WinResized event, but may
				trigger when adding more.

				Non-recursive: the event will not trigger
				while executing commands for the WinScrolled
				event.  However, if the command causes a
				window to scroll or change size, then another
				WinScrolled event will be triggered later.


							*WinResized*
WinResized			After a window in the current tab page changed
				width or height.
				See |win-scrolled-resized|.

				|v:event| is set with information about size
				changes. |WinResized-event|

				Same behavior as |WinScrolled| for the
				pattern, triggering and recursiveness.

==============================================================================
6. Patterns					*autocmd-patterns* *{aupat}*

The {aupat} argument of `:autocmd` can be a comma-separated list.  This works as
if the command was given with each pattern separately.  Thus this command: >
	:autocmd BufRead *.txt,*.info set et
Is equivalent to: >
	:autocmd BufRead *.txt set et
	:autocmd BufRead *.info set et

The file pattern {aupat} is tested for a match against the file name in one of
two ways:
1. When there is no '/' in the pattern, Vim checks for a match against only
   the tail part of the file name (without its leading directory path).
2. When there is a '/' in the pattern, Vim checks for a match against both the
   short file name (as you typed it) and the full file name (after expanding
   it to a full path and resolving symbolic links).

The special pattern <buffer> or <buffer=N> is used for buffer-local
autocommands |autocmd-buflocal|.  This pattern is not matched against the name
of a buffer.

Examples: >
	:autocmd BufRead *.txt		set et
Set the 'et' option for all text files. >

	:autocmd BufRead /vim/src/*.c	set cindent
Set the 'cindent' option for C files in the /vim/src directory. >

	:autocmd BufRead /tmp/*.c	set ts=5
If you have a link from "/tmp/test.c" to "/home/nobody/vim/src/test.c", and
you start editing "/tmp/test.c", this autocommand will match.

Note:  To match part of a path, but not from the root directory, use a '*' as
the first character.  Example: >
	:autocmd BufRead */doc/*.txt	set tw=78
This autocommand will for example be executed for "/tmp/doc/xx.txt" and
"/usr/home/piet/doc/yy.txt".  The number of directories does not matter here.


The file name that the pattern is matched against is after expanding
wildcards.  Thus if you issue this command: >
	:e $ROOTDIR/main.$EXT
The argument is first expanded to: >
	/usr/root/main.py
Before it's matched with the pattern of the autocommand.  Careful with this
when using events like FileReadCmd, the value of <amatch> may not be what you
expect.


Environment variables can be used in a pattern: >
	:autocmd BufRead $VIMRUNTIME/doc/*.txt  set expandtab
And ~ can be used for the home directory (if $HOME is defined): >
	:autocmd BufWritePost ~/.vimrc   so ~/.vimrc
	:autocmd BufRead ~archive/*      set readonly
The environment variable is expanded when the autocommand is defined, not when
the autocommand is executed.  This is different from the command!

							*file-pattern*
The pattern is interpreted like mostly used in file names:
	*	matches any sequence of characters; Unusual: includes path
		separators
	?	matches any single character
	\?	matches a '?'
	.	matches a '.'
	~	matches a '~'
	,	separates patterns
	\,	matches a ','
	{ }	like \( \) in a |pattern|
	,	inside { }: like \| in a |pattern|
	\}	literal }
	\{	literal {
	\\\{n,m\}  like \{n,m} in a |pattern|
	\	special meaning like in a |pattern|
	[ch]	matches 'c' or 'h'
	[^ch]   match any character but 'c' and 'h'

Note that for all systems the '/' character is used for path separator (even
for MS-Windows).  This was done because the backslash is difficult to use in a
pattern and to make the autocommands portable across different systems.

It is possible to use |pattern| items, but they may not work as expected,
because of the translation done for the above.

							*autocmd-changes*
Matching with the pattern is done when an event is triggered.  Changing the
buffer name in one of the autocommands, or even deleting the buffer, does not
change which autocommands will be executed.  Example: >

	au BufEnter *.foo  bdel
	au BufEnter *.foo  set modified

This will delete the current buffer and then set 'modified' in what has become
the current buffer instead.  Vim doesn't take into account that "*.foo"
doesn't match with that buffer name.  It matches "*.foo" with the name of the
buffer at the moment the event was triggered.

However, buffer-local autocommands will not be executed for a buffer that has
been wiped out with |:bwipe|.  After deleting the buffer with |:bdel| the
buffer actually still exists (it becomes unlisted), thus the autocommands are
still executed.

==============================================================================
7. Buffer-local autocommands	*autocmd-buflocal* *autocmd-buffer-local*
					*<buffer=N>* *<buffer=abuf>* *E680*

Buffer-local autocommands are attached to a specific buffer.  They are useful
if the buffer does not have a name and when the name does not match a specific
pattern.  But it also means they must be explicitly added to each buffer.

Instead of a pattern buffer-local autocommands use one of these forms:
	<buffer>	current buffer
	<buffer=99>	buffer number 99
	<buffer=abuf>	using <abuf> (only when executing autocommands)
			|<abuf>|

Examples: >
    :au CursorHold <buffer>  echo 'hold'
    :au CursorHold <buffer=33>  echo 'hold'
    :au BufNewFile * au CursorHold <buffer=abuf>  echo 'hold'

All the commands for autocommands also work with buffer-local autocommands,
simply use the special string instead of the pattern.  Examples: >
    :au! * <buffer>		     " remove buffer-local autocommands for
				     " current buffer
    :au! * <buffer=33>		     " remove buffer-local autocommands for
				     " buffer #33
    :bufdo :au! CursorHold <buffer>  " remove autocmd for given event for all
				     " buffers
    :au * <buffer>		     " list buffer-local autocommands for
				     " current buffer

Note that when an autocommand is defined for the current buffer, it is stored
with the buffer number.  Thus it uses the form "<buffer=12>", where 12 is the
number of the current buffer.  You will see this when listing autocommands,
for example.

To test for presence of buffer-local autocommands use the |exists()| function
as follows: >
    :if exists("#CursorHold#<buffer=12>") | ... | endif
    :if exists("#CursorHold#<buffer>") | ... | endif    " for current buffer

When a buffer is wiped out its buffer-local autocommands are also gone, of
course.  Note that when deleting a buffer, e.g., with ":bdel", it is only
unlisted, the autocommands are still present.  In order to see the removal of
buffer-local autocommands: >
    :set verbose=6

It is not possible to define buffer-local autocommands for a non-existent
buffer.

==============================================================================
8. Groups						*autocmd-groups*

Autocommands can be put together in a group.  This is useful for removing or
executing a group of autocommands.  For example, all the autocommands for
syntax highlighting are put in the "highlight" group, to be able to execute
":doautoall highlight BufRead" when the GUI starts.

When no specific group is selected, Vim uses the default group.  The default
group does not have a name.  You cannot execute the autocommands from the
default group separately; you can execute them only by executing autocommands
for all groups.

Normally, when executing autocommands automatically, Vim uses the autocommands
for all groups.  The group only matters when executing autocommands with
":doautocmd" or ":doautoall", or when defining or deleting autocommands.

The group name can contain any characters except white space.  The group name
"end" is reserved (also in uppercase).

The group name is case sensitive.  Note that this is different from the event
name!

							*:aug* *:augroup*
:aug[roup] {name}		Define the autocmd group name for the
				following ":autocmd" commands.  The name "end"
				or "END" selects the default group.
				To avoid confusion, the name should be
				different from existing {event} names, as this
				most likely will not do what you intended.

					*:augroup-delete* *E367* *W19* *E936*
:aug[roup]! {name}		Delete the autocmd group {name}.  Don't use
				this if there is still an autocommand using
				this group!  You will get a warning if doing
				it anyway.  When the group is the current
				group you will get error E936.

To enter autocommands for a specific group, use this method:
1. Select the group with ":augroup {name}".
2. Delete any old autocommands with ":au!".
3. Define the autocommands.
4. Go back to the default group with "augroup END".

Example: >
	:augroup uncompress
	:  au!
	:  au BufEnter *.gz	%!gunzip
	:augroup END

This prevents having the autocommands defined twice (e.g., after sourcing the
.vimrc file again).

						*FileExplorer*
There is one group that is recognized by Vim: FileExplorer.  If this group
exists Vim assumes that editing a directory is possible and will trigger a
plugin that lists the files in that directory.  This is used by the |netrw|
plugin.  This allows you to do: >
	browse edit

==============================================================================
9. Executing autocommands				*autocmd-execute*

Vim can also execute Autocommands non-automatically.  This is useful if you
have changed autocommands, or when Vim has executed the wrong autocommands
(e.g., the file pattern match was wrong).

Note that the 'eventignore' option applies here too.  Events listed in this
option will not cause any commands to be executed.

				*:do* *:doau* *:doaut* *:doautocmd* *E217*
:do[autocmd] [<nomodeline>] [group] {event} [fname]
			Apply the autocommands matching [fname] (default:
			current file name) for {event} to the current buffer.
			You can use this when the current file name does not
			match the right pattern, after changing settings, or
			to execute autocommands for a certain event.
			It's possible to use this inside an autocommand too,
			so you can base the autocommands for one extension on
			another extension.  Example: >
				:au BufEnter *.cpp so ~/.vimrc_cpp
				:au BufEnter *.cpp doau BufEnter x.c
<			Be careful to avoid endless loops.  See
			|autocmd-nested|.

			When the [group] argument is not given, Vim executes
			the autocommands for all groups.  When the [group]
			argument is included, Vim executes only the matching
			autocommands for that group.  Note: if you use an
			undefined group name, Vim gives you an error message.
							*<nomodeline>*
			After applying the autocommands the modelines are
			processed, so that their settings overrule the
			settings from autocommands, like what happens when
			editing a file. This is skipped when the <nomodeline>
			argument is present. You probably want to use
			<nomodeline> for events that are not used when loading
			a buffer, such as |User|.
			Processing modelines is also skipped when no
			matching autocommands were executed.

						*:doautoa* *:doautoall*
:doautoa[ll] [<nomodeline>] [group] {event} [fname]
			Like ":doautocmd", but apply the autocommands to each
			loaded buffer.  The current buffer is done last.

			Note that [fname] is used to select the autocommands,
			not the buffers to which they are applied. Example: >
				augroup mine
				  autocmd!
				  autocmd FileType * echo expand('<amatch>')
				augroup END
				doautoall mine FileType Loaded-Buffer
<			Sourcing this script, you'll see as many
			"Loaded-Buffer" echoed as there are loaded buffers.

			Careful: Don't use this for autocommands that delete a
			buffer, change to another buffer or change the
			contents of a buffer; the result is unpredictable.
			This command is intended for autocommands that set
			options, change highlighting, and things like that.

==============================================================================
10. Using autocommands					*autocmd-use*

For WRITING FILES there are four possible sets of events.  Vim uses only one
of these sets for a write command:

BufWriteCmd	BufWritePre	BufWritePost	writing the whole buffer
		FilterWritePre	FilterWritePost	writing to filter temp file
FileAppendCmd	FileAppendPre	FileAppendPost	appending to a file
FileWriteCmd	FileWritePre	FileWritePost	any other file write

When there is a matching "*Cmd" autocommand, it is assumed it will do the
writing.  No further writing is done and the other events are not triggered.
|Cmd-event|

Note that the *WritePost commands should undo any changes to the buffer that
were caused by the *WritePre commands; otherwise, writing the file will have
the side effect of changing the buffer.

Before executing the autocommands, the buffer from which the lines are to be
written temporarily becomes the current buffer.  Unless the autocommands
change the current buffer or delete the previously current buffer, the
previously current buffer is made the current buffer again.

The *WritePre and *AppendPre autocommands must not delete the buffer from
which the lines are to be written.

The '[ and '] marks have a special position:
- Before the *ReadPre event the '[ mark is set to the line just above where
  the new lines will be inserted.
- Before the *ReadPost event the '[ mark is set to the first line that was
  just read, the '] mark to the last line.
- Before executing the *WriteCmd, *WritePre and *AppendPre autocommands the '[
  mark is set to the first line that will be written, the '] mark to the last
  line.
Careful: '[ and '] change when using commands that change the buffer.

In commands which expect a file name, you can use "<afile>" for the file name
that is being read |:<afile>| (you can also use "%" for the current file
name).  "<abuf>" can be used for the buffer number of the currently effective
buffer.  This also works for buffers that don't have a name.  But it doesn't
work for files without a buffer (e.g., with ":r file").

							*gzip-example*
Examples for reading and writing compressed files: >
  :augroup gzip
  :  autocmd!
  :  autocmd BufReadPre,FileReadPre	*.gz set bin
  :  autocmd BufReadPost,FileReadPost	*.gz '[,']!gunzip
  :  autocmd BufReadPost,FileReadPost	*.gz set nobin
  :  autocmd BufReadPost,FileReadPost	*.gz execute ":doautocmd BufReadPost " .. expand("%:r")
  :  autocmd BufWritePost,FileWritePost	*.gz !mv <afile> <afile>:r
  :  autocmd BufWritePost,FileWritePost	*.gz !gzip <afile>:r

  :  autocmd FileAppendPre		*.gz !gunzip <afile>
  :  autocmd FileAppendPre		*.gz !mv <afile>:r <afile>
  :  autocmd FileAppendPost		*.gz !mv <afile> <afile>:r
  :  autocmd FileAppendPost		*.gz !gzip <afile>:r
  :augroup END

The "gzip" group is used to be able to delete any existing autocommands with
":autocmd!", for when the file is sourced twice.

("<afile>:r" is the file name without the extension, see |:_%:|)

The commands executed for the BufNewFile, BufRead/BufReadPost, BufWritePost,
FileAppendPost and VimLeave events do not set or reset the changed flag of the
buffer.  When you decompress the buffer with the BufReadPost autocommands, you
can still exit with ":q".  When you use ":undo" in BufWritePost to undo the
changes made by BufWritePre commands, you can still do ":q" (this also makes
"ZZ" work).  If you do want the buffer to be marked as modified, set the
'modified' option.

To execute Normal mode commands from an autocommand, use the ":normal"
command.  Use with care!  If the Normal mode command is not finished, the user
needs to type characters (e.g., after ":normal m" you need to type a mark
name).

If you want the buffer to be unmodified after changing it, reset the
'modified' option.  This makes it possible to exit the buffer with ":q"
instead of ":q!".

							*autocmd-nested* *E218*
By default, autocommands do not nest.  For example, if you use ":e" or ":w" in
an autocommand, Vim does not execute the BufRead and BufWrite autocommands for
those commands.  If you do want this, use the "nested" flag for those commands
in which you want nesting.  For example: >
  :autocmd FileChangedShell *.c ++nested e!
The nesting is limited to 10 levels to get out of recursive loops.

It's possible to use the ":au" command in an autocommand.  This can be a
self-modifying command!  This can be useful for an autocommand that should
execute only once.

If you want to skip autocommands for one command, use the |:noautocmd| command
modifier or the 'eventignore' option.

Note: When reading a file (with ":read file" or with a filter command) and the
last line in the file does not have an <EOL>, Vim remembers this.  At the next
write (with ":write file" or with a filter command), if the same line is
written again as the last line in a file AND 'binary' is set, Vim does not
supply an <EOL>.  This makes a filter command on the just read lines write the
same file as was read, and makes a write command on just filtered lines write
the same file as was read from the filter.  For example, another way to write
a compressed file: >

  :autocmd FileWritePre *.gz   set bin|'[,']!gzip
  :autocmd FileWritePost *.gz  undo|set nobin
<
							*autocommand-pattern*
You can specify multiple patterns, separated by commas.  Here are some
examples: >

  :autocmd BufRead   *		set tw=79 nocin ic infercase fo=2croq
  :autocmd BufRead   .letter	set tw=72 fo=2tcrq
  :autocmd BufEnter  .letter	set dict=/usr/lib/dict/words
  :autocmd BufLeave  .letter	set dict=
  :autocmd BufRead,BufNewFile   *.c,*.h	set tw=0 cin noic
  :autocmd BufEnter  *.c,*.h	abbr FOR for (i = 0; i < 3; ++i)<CR>{<CR>}<Esc>O
  :autocmd BufLeave  *.c,*.h	unabbr FOR

For makefiles (makefile, Makefile, imakefile, makefile.unix, etc.): >

  :autocmd BufEnter  ?akefile*	set include=^s\=include
  :autocmd BufLeave  ?akefile*	set include&

To always start editing C files at the first function: >

  :autocmd BufRead   *.c,*.h	1;/^{

Without the "1;" above, the search would start from wherever the file was
entered, rather than from the start of the file.

						*skeleton* *template*
To read a skeleton (template) file when opening a new file: >

  :autocmd BufNewFile  *.c	0r ~/vim/skeleton.c
  :autocmd BufNewFile  *.h	0r ~/vim/skeleton.h
  :autocmd BufNewFile  *.java	0r ~/vim/skeleton.java

To insert the current date and time in a *.html file when writing it: >

  :autocmd BufWritePre,FileWritePre *.html   ks|call LastMod()|'s
  :fun LastMod()
  :  if line("$") > 20
  :    let l = 20
  :  else
  :    let l = line("$")
  :  endif
  :  exe "1," .. l .. "g/Last modified: /s/Last modified: .*/Last modified: " ..
  :  \ strftime("%Y %b %d")
  :endfun

You need to have a line "Last modified: <date time>" in the first 20 lines
of the file for this to work.  Vim replaces <date time> (and anything in the
same line after it) with the current date and time.  Explanation:
	ks		mark current position with mark 's'
	call LastMod()  call the LastMod() function to do the work
	's		return the cursor to the old position
The LastMod() function checks if the file is shorter than 20 lines, and then
uses the ":g" command to find lines that contain "Last modified: ".  For those
lines the ":s" command is executed to replace the existing date with the
current one.  The ":execute" command is used to be able to use an expression
for the ":g" and ":s" commands.  The date is obtained with the strftime()
function.  You can change its argument to get another date string.

When entering :autocmd on the command-line, completion of events and command
names may be done (with <Tab>, CTRL-D, etc.) where appropriate.

Vim executes all matching autocommands in the order that you specify them.
It is recommended that your first autocommand be used for all files by using
"*" as the file pattern.  This means that you can define defaults you like
here for any settings, and if there is another matching autocommand it will
override these.  But if there is no other matching autocommand, then at least
your default settings are recovered (if entering this file from another for
which autocommands did match).  Note that "*" will also match files starting
with ".", unlike Unix shells.

						    *autocmd-searchpat*
Autocommands do not change the current search patterns.  Vim saves the current
search patterns before executing autocommands then restores them after the
autocommands finish.  This means that autocommands do not affect the strings
highlighted with the 'hlsearch' option.  Within autocommands, you can still
use search patterns normally, e.g., with the "n" command.
If you want an autocommand to set the search pattern, such that it is used
after the autocommand finishes, use the ":let @/ =" command.
The search-highlighting cannot be switched off with ":nohlsearch" in an
autocommand.  Use the 'h' flag in the 'viminfo' option to disable search-
highlighting when starting Vim.

							*Cmd-event*
When using one of the "*Cmd" events, the matching autocommands are expected to
do the file reading, writing or sourcing.  This can be used when working with
a special kind of file, for example on a remote system.
CAREFUL: If you use these events in a wrong way, it may have the effect of
making it impossible to read or write the matching files!  Make sure you test
your autocommands properly.  Best is to use a pattern that will never match a
normal file name, for example "ftp://*".

When defining a BufReadCmd it will be difficult for Vim to recover a crashed
editing session.  When recovering from the original file, Vim reads only those
parts of a file that are not found in the swap file.  Since that is not
possible with a BufReadCmd, use the |:preserve| command to make sure the
original file isn't needed for recovery.  You might want to do this only when
you expect the file to be modified.

For file read and write commands the |v:cmdarg| variable holds the "++enc="
and "++ff=" argument that are effective.  These should be used for the command
that reads/writes the file.  The |v:cmdbang| variable is one when "!" was
used, zero otherwise.

See the $VIMRUNTIME/plugin/netrwPlugin.vim for examples.

==============================================================================
11. Disabling autocommands				*autocmd-disable*

To disable autocommands for some time use the 'eventignore' option.  Note that
this may cause unexpected behavior, make sure you restore 'eventignore'
afterwards, using a |:try| block with |:finally|.

							*:noautocmd* *:noa*
To disable autocommands for just one command use the ":noautocmd" command
modifier.  This will set 'eventignore' to "all" for the duration of the
following command.  Example: >

	:noautocmd w fname.gz

This will write the file without triggering the autocommands defined by the
gzip plugin.

Note that some autocommands are not triggered right away, but only later.
This specifically applies to |CursorMoved| and |TextChanged|.


 vim:tw=78:ts=8:noet:ft=help:norl:
              usr/share/vim/vim90/doc/builtin.txt                                                                 0000644 0000000 0000000 00001460644 14424703754 015723  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        *builtin.txt*	For Vim version 9.0.  Last change: 2023 Feb 27


		  VIM REFERENCE MANUAL	  by Bram Moolenaar


Builtin functions				*builtin-functions*

Note: Expression evaluation can be disabled at compile time, the builtin
functions are not available then.  See |+eval| and |no-eval-feature|.

For functions grouped by what they are used for see |function-list|.

1. Overview				|builtin-function-list|
2. Details				|builtin-function-details|
3. Feature list				|feature-list|
4. Matching a pattern in a String	|string-match|

==============================================================================
