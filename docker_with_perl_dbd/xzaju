AsyncGenerator = _alias(collections.abc.AsyncGenerator, 2)
Type = _alias(type, 1, inst=False, name='Type')
Type.__doc__ = \
    """A special construct usable to annotate class objects.

    For example, suppose we have the following classes::

      class User: ...  # Abstract base for User classes
      class BasicUser(User): ...
      class ProUser(User): ...
      class TeamUser(User): ...

    And a function that takes a class argument that's a subclass of
    User and returns an instance of the corresponding class::

      U = TypeVar('U', bound=User)
      def new_user(user_class: Type[U]) -> U:
          user = user_class()
          # (Here we could write the user object to a database)
          return user

      joe = new_user(BasicUser)

    At this point the type checker knows that joe has type BasicUser.
    """


@runtime_checkable
class SupportsInt(Protocol):
    """An ABC with one abstract method __int__."""
    __slots__ = ()

    @abstractmethod
    def __int__(self) -> int:
        pass


@runtime_checkable
class SupportsFloat(Protocol):
    """An ABC with one abstract method __float__."""
    __slots__ = ()

    @abstractmethod
    def __float__(self) -> float:
        pass


@runtime_checkable
class SupportsComplex(Protocol):
    """An ABC with one abstract method __complex__."""
    __slots__ = ()

    @abstractmethod
    def __complex__(self) -> complex:
        pass


@runtime_checkable
class SupportsBytes(Protocol):
    """An ABC with one abstract method __bytes__."""
    __slots__ = ()

    @abstractmethod
    def __bytes__(self) -> bytes:
        pass


@runtime_checkable
class SupportsIndex(Protocol):
    """An ABC with one abstract method __index__."""
    __slots__ = ()

    @abstractmethod
    def __index__(self) -> int:
        pass


@runtime_checkable
class SupportsAbs(Protocol[T_co]):
    """An ABC with one abstract method __abs__ that is covariant in its return type."""
    __slots__ = ()

    @abstractmethod
    def __abs__(self) -> T_co:
        pass


@runtime_checkable
class SupportsRound(Protocol[T_co]):
    """An ABC with one abstract method __round__ that is covariant in its return type."""
    __slots__ = ()

    @abstractmethod
    def __round__(self, ndigits: int = 0) -> T_co:
        pass


def _make_nmtuple(name, types, module, defaults = ()):
    fields = [n for n, t in types]
    types = {n: _type_check(t, f"field {n} annotation must be a type")
             for n, t in types}
    nm_tpl = collections.namedtuple(name, fields,
                                    defaults=defaults, module=module)
    nm_tpl.__annotations__ = nm_tpl.__new__.__annotations__ = types
    return nm_tpl


# attributes prohibited to set in NamedTuple class syntax
_prohibited = frozenset({'__new__', '__init__', '__slots__', '__getnewargs__',
                         '_fields', '_field_defaults',
                         '_make', '_replace', '_asdict', '_source'})

_special = frozenset({'__module__', '__name__', '__annotations__'})


class NamedTupleMeta(type):

    def __new__(cls, typename, bases, ns):
        assert _NamedTuple in bases
        for base in bases:
            if base is not _NamedTuple and base is not Generic:
                raise TypeError(
                    'can only inherit from a NamedTuple type and Generic')
        bases = tuple(tuple if base is _NamedTuple else base for base in bases)
        types = ns.get('__annotations__', {})
        default_names = []
        for field_name in types:
            if field_name in ns:
                default_names.append(field_name)
            elif default_names:
                raise TypeError(f"Non-default namedtuple field {field_name} "
                                f"cannot follow default field"
                                f"{'s' if len(default_names) > 1 else ''} "
                                f"{', '.join(default_names)}")
        nm_tpl = _make_nmtuple(typename, types.items(),
                               defaults=[ns[n] for n in default_names],
                               module=ns['__module__'])
        nm_tpl.__bases__ = bases
        if Generic in bases:
            class_getitem = Generic.__class_getitem__.__func__
            nm_tpl.__class_getitem__ = classmethod(class_getitem)
        # update from user namespace without overriding special namedtuple attributes
        for key in ns:
            if key in _prohibited:
                raise AttributeError("Cannot overwrite NamedTuple attribute " + key)
            elif key not in _special and key not in nm_tpl._fields:
                setattr(nm_tpl, key, ns[key])
        if Generic in bases:
            nm_tpl.__init_subclass__()
        return nm_tpl


def NamedTuple(typename, fields=None, /, **kwargs):
    """Typed version of namedtuple.

    Usage in Python versions >= 3.6::

        class Employee(NamedTuple):
            name: str
            id: int

    This is equivalent to::

        Employee = collections.namedtuple('Employee', ['name', 'id'])

    The resulting class has an extra __annotations__ attribute, giving a
    dict that maps field names to types.  (The field names are also in
    the _fields attribute, which is part of the namedtuple API.)
    Alternative equivalent keyword syntax is also accepted::

        Employee = NamedTuple('Employee', name=str, id=int)

    In Python versions <= 3.5 use::

        Employee = NamedTuple('Employee', [('name', str), ('id', int)])
    """
    if fields is None:
        fields = kwargs.items()
    elif kwargs:
        raise TypeError("Either list of fields or keywords"
                        " can be provided to NamedTuple, not both")
    return _make_nmtuple(typename, fields, module=_caller())

_NamedTuple = type.__new__(NamedTupleMeta, 'NamedTuple', (), {})

def _namedtuple_mro_entries(bases):
    assert NamedTuple in bases
    return (_NamedTuple,)

NamedTuple.__mro_entries__ = _namedtuple_mro_entries


class _TypedDictMeta(type):
    def __new__(cls, name, bases, ns, total=True):
        """Create new typed dict class object.

        This method is called when TypedDict is subclassed,
        or when TypedDict is instantiated. This way
        TypedDict supports all three syntax forms described in its docstring.
        Subclasses and instances of TypedDict return actual dictionaries.
        """
        for base in bases:
            if type(base) is not _TypedDictMeta and base is not Generic:
                raise TypeError('cannot inherit from both a TypedDict type '
                                'and a non-TypedDict base class')

        if any(issubclass(b, Generic) for b in bases):
            generic_base = (Generic,)
        else:
            generic_base = ()

        tp_dict = type.__new__(_TypedDictMeta, name, (*generic_base, dict), ns)

        annotations = {}
        own_annotations = ns.get('__annotations__', {})
        msg = "TypedDict('Name', {f0: t0, f1: t1, ...}); each t must be a type"
        own_annotations = {
            n: _type_check(tp, msg, module=tp_dict.__module__)
            for n, tp in own_annotations.items()
        }
        required_keys = set()
        optional_keys = set()

        for base in bases:
            annotations.update(base.__dict__.get('__annotations__', {}))
            required_keys.update(base.__dict__.get('__required_keys__', ()))
            optional_keys.update(base.__dict__.get('__optional_keys__', ()))

        annotations.update(own_annotations)
        for annotation_key, annotation_type in own_annotations.items():
            annotation_origin = get_origin(annotation_type)
            if annotation_origin is Annotated:
                annotation_args = get_args(annotation_type)
                if annotation_args:
                    annotation_type = annotation_args[0]
                    annotation_origin = get_origin(annotation_type)

            if annotation_origin is Required:
                required_keys.add(annotation_key)
            elif annotation_origin is NotRequired:
                optional_keys.add(annotation_key)
            elif total:
                required_keys.add(annotation_key)
            else:
                optional_keys.add(annotation_key)

        tp_dict.__annotations__ = annotations
        tp_dict.__required_keys__ = frozenset(required_keys)
        tp_dict.__optional_keys__ = frozenset(optional_keys)
        if not hasattr(tp_dict, '__total__'):
            tp_dict.__total__ = total
        return tp_dict

    __call__ = dict  # static method

    def __subclasscheck__(cls, other):
        # Typed dicts are only for static structural subtyping.
        raise TypeError('TypedDict does not support instance and class checks')

    __instancecheck__ = __subclasscheck__


def TypedDict(typename, fields=None, /, *, total=True, **kwargs):
    """A simple typed namespace. At runtime it is equivalent to a plain dict.

    TypedDict creates a dictionary type that expects all of its
    instances to have a certain set of keys, where each key is
    associated with a value of a consistent type. This expectation
    is not checked at runtime but is only enforced by type checkers.
    Usage::

        class Point2D(TypedDict):
            x: int
            y: int
            label: str

        a: Point2D = {'x': 1, 'y': 2, 'label': 'good'}  # OK
        b: Point2D = {'z': 3, 'label': 'bad'}           # Fails type check

        assert Point2D(x=1, y=2, label='first') == dict(x=1, y=2, label='first')

    The type info can be accessed via the Point2D.__annotations__ dict, and
    the Point2D.__required_keys__ and Point2D.__optional_keys__ frozensets.
    TypedDict supports an additional equivalent form::

        Point2D = TypedDict('Point2D', {'x': int, 'y': int, 'label': str})

    By default, all keys must be present in a TypedDict. It is possible
    to override this by specifying totality.
    Usage::

        class point2D(TypedDict, total=False):
            x: int
            y: int

    This means that a point2D TypedDict can have any of the keys omitted.A type
    checker is only expected to support a literal False or True as the value of
    the total argument. True is the default, and makes all items defined in the
    class body be required.

    The class syntax is only supported in Python 3.6+, while the other
    syntax form works for Python 2.7 and 3.2+
    """
    if fields is None:
        fields = kwargs
    elif kwargs:
        raise TypeError("TypedDict takes either a dict or keyword arguments,"
                        " but not both")
    if kwargs:
        warnings.warn(
            "The kwargs-based syntax for TypedDict definitions is deprecated "
            "in Python 3.11, will be removed in Python 3.13, and may not be "
            "understood by third-party type checkers.",
            DeprecationWarning,
            stacklevel=2,
        )

    ns = {'__annotations__': dict(fields)}
    module = _caller()
    if module is not None:
        # Setting correct module is necessary to make typed dict classes pickleable.
        ns['__module__'] = module

    return _TypedDictMeta(typename, (), ns, total=total)

_TypedDict = type.__new__(_TypedDictMeta, 'TypedDict', (), {})
TypedDict.__mro_entries__ = lambda bases: (_TypedDict,)


@_SpecialForm
def Required(self, parameters):
    """A special typing construct to mark a key of a total=False TypedDict
    as required. For example:

        class Movie(TypedDict, total=False):
            title: Required[str]
            year: int

        m = Movie(
            title='The Matrix',  # typechecker error if key is omitted
            year=1999,
        )

    There is no runtime checking that a required key is actually provided
    when instantiating a related TypedDict.
    """
    item = _type_check(parameters, f'{self._name} accepts only a single type.')
    return _GenericAlias(self, (item,))


@_SpecialForm
def NotRequired(self, parameters):
    """A special typing construct to mark a key of a TypedDict as
    potentially missing. For example:

        class Movie(TypedDict):
            title: str
            year: NotRequired[int]

        m = Movie(
            title='The Matrix',  # typechecker error if key is omitted
            year=1999,
        )
    """
    item = _type_check(parameters, f'{self._name} accepts only a single type.')
    return _GenericAlias(self, (item,))


class NewType:
    """NewType creates simple unique types with almost zero
    runtime overhead. NewType(name, tp) is considered a subtype of tp
    by static type checkers. At runtime, NewType(name, tp) returns
    a dummy callable that simply returns its argument. Usage::

        UserId = NewType('UserId', int)

        def name_by_id(user_id: UserId) -> str:
            ...

        UserId('user')          # Fails type check

        name_by_id(42)          # Fails type check
        name_by_id(UserId(42))  # OK

        num = UserId(5) + 1     # type: int
    """

    __call__ = _idfunc

    def __init__(self, name, tp):
        self.__qualname__ = name
        if '.' in name:
            name = name.rpartition('.')[-1]
        self.__name__ = name
        self.__supertype__ = tp
        def_mod = _caller()
        if def_mod != 'typing':
            self.__module__ = def_mod

    def __mro_entries__(self, bases):
        # We defined __mro_entries__ to get a better error message
        # if a user attempts to subclass a NewType instance. bpo-46170
        superclass_name = self.__name__

        class Dummy:
            def __init_subclass__(cls):
                subclass_name = cls.__name__
                raise TypeError(
                    f"Cannot subclass an instance of NewType. Perhaps you were looking for: "
                    f"`{subclass_name} = NewType({subclass_name!r}, {superclass_name})`"
                )

        return (Dummy,)

    def __repr__(self):
        return f'{self.__module__}.{self.__qualname__}'

    def __reduce__(self):
        return self.__qualname__

    def __or__(self, other):
        return Union[self, other]

    def __ror__(self, other):
        return Union[other, self]


# Python-version-specific alias (Python 2: unicode; Python 3: str)
Text = str


# Constant that's True when type checking, but False here.
TYPE_CHECKING = False


class IO(Generic[AnyStr]):
    """Generic base class for TextIO and BinaryIO.

    This is an abstract, generic version of the return of open().

    NOTE: This does not distinguish between the different possible
    classes (text vs. binary, read vs. write vs. read/write,
    append-only, unbuffered).  The TextIO and BinaryIO subclasses
    below capture the distinctions between text vs. binary, which is
    pervasive in the interface; however we currently do not offer a
    way to track the other distinctions in the type system.
    """

    __slots__ = ()

    @property
    @abstractmethod
    def mode(self) -> str:
        pass

    @property
    @abstractmethod
    def name(self) -> str:
        pass

    @abstractmethod
    def close(self) -> None:
        pass

    @property
    @abstractmethod
    def closed(self) -> bool:
        pass

    @abstractmethod
    def fileno(self) -> int:
        pass

    @abstractmethod
    def flush(self) -> None:
        pass

    @abstractmethod
    def isatty(self) -> bool:
        pass

    @abstractmethod
    def read(self, n: int = -1) -> AnyStr:
        pass

    @abstractmethod
    def readable(self) -> bool:
        pass

    @abstractmethod
    def readline(self, limit: int = -1) -> AnyStr:
        pass

    @abstractmethod
    def readlines(self, hint: int = -1) -> List[AnyStr]:
        pass

    @abstractmethod
    def seek(self, offset: int, whence: int = 0) -> int:
        pass

    @abstractmethod
    def seekable(self) -> bool:
        pass

    @abstractmethod
    def tell(self) -> int:
        pass

    @abstractmethod
    def truncate(self, size: int = None) -> int:
        pass

    @abstractmethod
    def writable(self) -> bool:
        pass

    @abstractmethod
    def write(self, s: AnyStr) -> int:
        pass

    @abstractmethod
    def writelines(self, lines: List[AnyStr]) -> None:
        pass

    @abstractmethod
    def __enter__(self) -> 'IO[AnyStr]':
        pass

    @abstractmethod
    def __exit__(self, type, value, traceback) -> None:
        pass


class BinaryIO(IO[bytes]):
    """Typed version of the return of open() in binary mode."""

    __slots__ = ()

    @abstractmethod
    def write(self, s: Union[bytes, bytearray]) -> int:
        pass

    @abstractmethod
    def __enter__(self) -> 'BinaryIO':
        pass


class TextIO(IO[str]):
    """Typed version of the return of open() in text mode."""

    __slots__ = ()

    @property
    @abstractmethod
    def buffer(self) -> BinaryIO:
        pass

    @property
    @abstractmethod
    def encoding(self) -> str:
        pass

    @property
    @abstractmethod
    def errors(self) -> Optional[str]:
        pass

    @property
    @abstractmethod
    def line_buffering(self) -> bool:
        pass

    @property
    @abstractmethod
    def newlines(self) -> Any:
        pass

    @abstractmethod
    def __enter__(self) -> 'TextIO':
        pass


class _DeprecatedType(type):
    def __getattribute__(cls, name):
        if name not in ("__dict__", "__module__") and name in cls.__dict__:
            warnings.warn(
                f"{cls.__name__} is deprecated, import directly "
                f"from typing instead. {cls.__name__} will be removed "
                "in Python 3.12.",
                DeprecationWarning,
                stacklevel=2,
            )
        return super().__getattribute__(name)


class io(metaclass=_DeprecatedType):
    """Wrapper namespace for IO generic classes."""

    __all__ = ['IO', 'TextIO', 'BinaryIO']
    IO = IO
    TextIO = TextIO
    BinaryIO = BinaryIO


io.__name__ = __name__ + '.io'
sys.modules[io.__name__] = io

Pattern = _alias(stdlib_re.Pattern, 1)
Match = _alias(stdlib_re.Match, 1)

class re(metaclass=_DeprecatedType):
    """Wrapper namespace for re type aliases."""

    __all__ = ['Pattern', 'Match']
    Pattern = Pattern
    Match = Match


re.__name__ = __name__ + '.re'
sys.modules[re.__name__] = re


def reveal_type(obj: T, /) -> T:
    """Reveal the inferred type of a variable.

    When a static type checker encounters a call to ``reveal_type()``,
    it will emit the inferred type of the argument::

        x: int = 1
        reveal_type(x)

    Running a static type checker (e.g., ``mypy``) on this example
    will produce output similar to 'Revealed type is "builtins.int"'.

    At runtime, the function prints the runtime type of the
    argument and returns it unchanged.

    """
    print(f"Runtime type is {type(obj).__name__!r}", file=sys.stderr)
    return obj


def dataclass_transform(
    *,
    eq_default: bool = True,
    order_default: bool = False,
    kw_only_default: bool = False,
    field_specifiers: tuple[type[Any] | Callable[..., Any], ...] = (),
    **kwargs: Any,
) -> Callable[[T], T]:
    """Decorator that marks a function, class, or metaclass as providing
    dataclass-like behavior.

    Example usage with a decorator function:

        T = TypeVar("T")

        @dataclass_transform()
        def create_model(cls: type[T]) -> type[T]:
            ...
            return cls

        @create_model
        class CustomerModel:
            id: int
            name: str

    On a base class:

        @dataclass_transform()
        class ModelBase: ...

        class CustomerModel(ModelBase):
            id: int
            name: str

    On a metaclass:

        @dataclass_transform()
        class ModelMeta(type): ...

        class ModelBase(metaclass=ModelMeta): ...

        class CustomerModel(ModelBase):
            id: int
            name: str

    The ``CustomerModel`` classes defined above will
    be treated by type checkers similarly to classes created with
    ``@dataclasses.dataclass``.
    For example, type checkers will assume these classes have
    ``__init__`` methods that accept ``id`` and ``name``.

    The arguments to this decorator can be used to customize this behavior:
    - ``eq_default`` indicates whether the ``eq`` parameter is assumed to be
        ``True`` or ``False`` if it is omitted by the caller.
    - ``order_default`` indicates whether the ``order`` parameter is
        assumed to be True or False if it is omitted by the caller.
    - ``kw_only_default`` indicates whether the ``kw_only`` parameter is
        assumed to be True or False if it is omitted by the caller.
    - ``field_specifiers`` specifies a static list of supported classes
        or functions that describe fields, similar to ``dataclasses.field()``.
    - Arbitrary other keyword arguments are accepted in order to allow for
        possible future extensions.

    At runtime, this decorator records its arguments in the
    ``__dataclass_transform__`` attribute on the decorated object.
    It has no other runtime effect.

    See PEP 681 for more details.
    """
    def decorator(cls_or_fn):
        cls_or_fn.__dataclass_transform__ = {
            "eq_default": eq_default,
            "order_default": order_default,
            "kw_only_default": kw_only_default,
            "field_specifiers": field_specifiers,
            "kwargs": kwargs,
        }
        return cls_or_fn
    return decorator
                                                                                                                                                              usr/lib/python3.11/unittest/                                                                        0000755 0000000 0000000 00000000000 14714551121 014327  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python3.11/unittest/__init__.py                                                             0000644 0000000 0000000 00000007536 14671176116 016464  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """
Python unit testing framework, based on Erich Gamma's JUnit and Kent Beck's
Smalltalk testing framework (used with permission).

This module contains the core framework classes that form the basis of
specific test cases and suites (TestCase, TestSuite etc.), and also a
text-based utility class for running the tests and reporting the results
 (TextTestRunner).

Simple usage:

    import unittest

    class IntegerArithmeticTestCase(unittest.TestCase):
        def testAdd(self):  # test method names begin with 'test'
            self.assertEqual((1 + 2), 3)
            self.assertEqual(0 + 1, 1)
        def testMultiply(self):
            self.assertEqual((0 * 10), 0)
            self.assertEqual((5 * 8), 40)

    if __name__ == '__main__':
        unittest.main()

Further information is available in the bundled documentation, and from

  http://docs.python.org/library/unittest.html

Copyright (c) 1999-2003 Steve Purcell
Copyright (c) 2003-2010 Python Software Foundation
This module is free software, and you may redistribute it and/or modify
it under the same terms as Python itself, so long as this copyright message
and disclaimer are retained in their original form.

IN NO EVENT SHALL THE AUTHOR BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF
THIS CODE, EVEN IF THE AUTHOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

THE AUTHOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE.  THE CODE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS,
AND THERE IS NO OBLIGATION WHATSOEVER TO PROVIDE MAINTENANCE,
SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
"""

__all__ = ['TestResult', 'TestCase', 'IsolatedAsyncioTestCase', 'TestSuite',
           'TextTestRunner', 'TestLoader', 'FunctionTestCase', 'main',
           'defaultTestLoader', 'SkipTest', 'skip', 'skipIf', 'skipUnless',
           'expectedFailure', 'TextTestResult', 'installHandler',
           'registerResult', 'removeResult', 'removeHandler',
           'addModuleCleanup', 'doModuleCleanups', 'enterModuleContext']

# Expose obsolete functions for backwards compatibility
# bpo-5846: Deprecated in Python 3.11, scheduled for removal in Python 3.13.
__all__.extend(['getTestCaseNames', 'makeSuite', 'findTestCases'])

__unittest = True

from .result import TestResult
from .case import (addModuleCleanup, TestCase, FunctionTestCase, SkipTest, skip,
                   skipIf, skipUnless, expectedFailure, doModuleCleanups,
                   enterModuleContext)
from .suite import BaseTestSuite, TestSuite
from .loader import TestLoader, defaultTestLoader
from .main import TestProgram, main
from .runner import TextTestRunner, TextTestResult
from .signals import installHandler, registerResult, removeResult, removeHandler
# IsolatedAsyncioTestCase will be imported lazily.
from .loader import makeSuite, getTestCaseNames, findTestCases

# deprecated
_TextTestResult = TextTestResult


# There are no tests here, so don't try to run anything discovered from
# introspecting the symbols (e.g. FunctionTestCase). Instead, all our
# tests come from within unittest.test.
def load_tests(loader, tests, pattern):
    import os.path
    # top level directory cached on loader instance
    this_dir = os.path.dirname(__file__)
    return loader.discover(start_dir=this_dir, pattern=pattern)


# Lazy import of IsolatedAsyncioTestCase from .async_case
# It imports asyncio, which is relatively heavy, but most tests
# do not need it.

def __dir__():
    return globals().keys() | {'IsolatedAsyncioTestCase'}

def __getattr__(name):
    if name == 'IsolatedAsyncioTestCase':
        global IsolatedAsyncioTestCase
        from .async_case import IsolatedAsyncioTestCase
        return IsolatedAsyncioTestCase
    raise AttributeError(f"module {__name__!r} has no attribute {name!r}")
                                                                                                                                                                  usr/lib/python3.11/unittest/__main__.py                                                             0000644 0000000 0000000 00000000730 14671176116 016432  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Main entry point"""

import sys
if sys.argv[0].endswith("__main__.py"):
    import os.path
    # We change sys.argv[0] to make help message more useful
    # use executable without path, unquoted
    # (it's just a hint anyway)
    # (if you have spaces in your executable you get what you deserve!)
    executable = os.path.basename(sys.executable)
    sys.argv[0] = executable + " -m unittest"
    del os

__unittest = True

from .main import main

main(module=None)
                                        usr/lib/python3.11/unittest/__pycache__/                                                            0000755 0000000 0000000 00000000000 14714551121 016537  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python3.11/unittest/__pycache__/__init__.cpython-311.pyc                                    0000644 0000000 0000000 00000010206 14714551121 022777  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        §
    Nüäf^  ã                   ó  — d Z g d¢Ze                     g d¢¦  «         dZddlmZ ddlmZmZm	Z	m
Z
mZmZmZmZmZmZ ddlmZmZ ddlmZmZ dd	lmZmZ dd
lmZmZ ddlmZmZmZm Z  ddlm!Z!m"Z"m#Z# eZ$d„ Z%d„ Z&d„ Z'dS )aÍ  
Python unit testing framework, based on Erich Gamma's JUnit and Kent Beck's
Smalltalk testing framework (used with permission).

This module contains the core framework classes that form the basis of
specific test cases and suites (TestCase, TestSuite etc.), and also a
text-based utility class for running the tests and reporting the results
 (TextTestRunner).

Simple usage:

    import unittest

    class IntegerArithmeticTestCase(unittest.TestCase):
        def testAdd(self):  # test method names begin with 'test'
            self.assertEqual((1 + 2), 3)
            self.assertEqual(0 + 1, 1)
        def testMultiply(self):
            self.assertEqual((0 * 10), 0)
            self.assertEqual((5 * 8), 40)

    if __name__ == '__main__':
        unittest.main()

Further information is available in the bundled documentation, and from

  http://docs.python.org/library/unittest.html

Copyright (c) 1999-2003 Steve Purcell
Copyright (c) 2003-2010 Python Software Foundation
This module is free software, and you may redistribute it and/or modify
it under the same terms as Python itself, so long as this copyright message
and disclaimer are retained in their original form.

IN NO EVENT SHALL THE AUTHOR BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF
THIS CODE, EVEN IF THE AUTHOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

THE AUTHOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE.  THE CODE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS,
AND THERE IS NO OBLIGATION WHATSOEVER TO PROVIDE MAINTENANCE,
SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
)Ú
TestResultÚTestCaseÚIsolatedAsyncioTestCaseÚ	TestSuiteÚTextTestRunnerÚ
TestLoaderÚFunctionTestCaseÚmainÚdefaultTestLoaderÚSkipTestÚskipÚskipIfÚ
skipUnlessÚexpectedFailureÚTextTestResultÚinstallHandlerÚregisterResultÚremoveResultÚremoveHandlerÚaddModuleCleanupÚdoModuleCleanupsÚenterModuleContext)ÚgetTestCaseNamesÚ	makeSuiteÚfindTestCasesTé   )r   )
r   r   r   r   r   r   r   r   r   r   )ÚBaseTestSuiter   )r   r
   )ÚTestProgramr	   )r   r   )r   r   r   r   )r   r   r   c                 óv   — dd l }|j                             t          ¦  «        }|                      ||¬¦  «        S )Né    )Ú	start_dirÚpattern)Úos.pathÚpathÚdirnameÚ__file__Údiscover)ÚloaderÚtestsr!   ÚosÚthis_dirs        ú(/usr/lib/python3.11/unittest/__init__.pyÚ
load_testsr,   O   s4   € Ø€N€N€NàŒwŠxÑ(Ô(€HØ?Š? X°wˆ?Ñ?Ô?Ğ?ó    c                  óJ   — t          ¦   «                              ¦   «         dhz  S )Nr   )ÚglobalsÚkeys© r-   r+   Ú__dir__r2   Z   s   € İ‰9Œ9>Š>ÑÔĞ8Ğ9Ñ9Ğ9r-   c                 ó\   — | dk    rddl ma t          S t          dt          ›d| ›¦  «        ‚)Nr   r   )r   zmodule z has no attribute )Ú
async_caser   ÚAttributeErrorÚ__name__)Únames    r+   Ú__getattr__r8   ]   sE   € ØĞ(Ò(Ğ(à7Ğ7Ğ7Ğ7Ğ7Ğ7İ&Ğ&İ
ĞI¥8ĞIĞIÀĞIĞIÑ
JÔ
JĞJr-   N)(Ú__doc__Ú__all__ÚextendÚ
__unittestÚresultr   Úcaser   r   r   r   r   r   r   r   r   r   Úsuiter   r   r'   r   r
   r	   r   Úrunnerr   r   Úsignalsr   r   r   r   r   r   r   Ú_TextTestResultr,   r2   r8   r1   r-   r+   ú<module>rC      s¸  ğğ,ğ ,ğ\Iğ Iğ I€ğ ‡‚ĞAĞAĞAÑ BÔ BĞ Bà€
à Ğ Ğ Ğ Ğ Ğ ğ'ğ 'ğ 'ğ 'ğ 'ğ 'ğ 'ğ 'ğ 'ğ 'ğ 'ğ 'ğ 'ğ 'ğ 'ğ 'ğ 'ğ 'ğ 'ğ 'ğ 'ğ 'ğ 'ğ 'ğ ,Ğ +Ğ +Ğ +Ğ +Ğ +Ğ +Ğ +Ø 1Ğ 1Ğ 1Ğ 1Ğ 1Ğ 1Ğ 1Ğ 1Ø #Ğ #Ğ #Ğ #Ğ #Ğ #Ğ #Ğ #Ø 2Ğ 2Ğ 2Ğ 2Ğ 2Ğ 2Ğ 2Ğ 2Ø PĞ PĞ PĞ PĞ PĞ PĞ PĞ PĞ PĞ PĞ PĞ Pà >Ğ >Ğ >Ğ >Ğ >Ğ >Ğ >Ğ >Ğ >Ğ >ğ !€ğ@ğ @ğ @ğ:ğ :ğ :ğKğ Kğ Kğ Kğ Kr-                                                                                                                                                                                                                                                                                                                                                                                             usr/lib/python3.11/unittest/__pycache__/__main__.cpython-311.pyc                                    0000644 0000000 0000000 00000001220 14714551121 022754  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        §
    NüäfØ  ã                   óÜ   — d Z ddlZej        d                              d¦  «        r1ddlZej                             ej        ¦  «        Zedz   ej        d<   [dZ	ddl
m
Z
  e
d¬¦  «         dS )	zMain entry pointé    Nz__main__.pyz -m unittestTé   )Úmain)Úmodule)Ú__doc__ÚsysÚargvÚendswithÚos.pathÚosÚpathÚbasenameÚ
executableÚ
__unittestr   © ó    ú(/usr/lib/python3.11/unittest/__main__.pyú<module>r      s•   ğØ Ğ à 
€
€
€
Ø„8ˆA„;×Ò˜Ñ&Ô&ğ Ø€N€N€Nğ
 ”×!Ò! #¤.Ñ1Ô1€JØ˜~Ñ-€C„HˆQKØ
à€
à Ğ Ğ Ğ Ğ Ğ à €ˆDĞ Ñ Ô Ğ Ğ Ğ r                                                                                                                                                                                                                                                                                                                                                                                   usr/lib/python3.11/unittest/__pycache__/_log.cpython-311.pyc                                        0000644 0000000 0000000 00000011311 14714551121 022156  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        §
    Nüäfº
  ã                   óŠ   — d dl Z d dlZddlmZ  ej        dddg¦  «        Z G d„ de j        ¦  «        Z G d	„ d
e¦  «        ZdS )é    Né   )Ú_BaseTestCaseContextÚ_LoggingWatcherÚrecordsÚoutputc                   ó$   — e Zd ZdZd„ Zd„ Zd„ ZdS )Ú_CapturingHandlerzM
    A logging handler capturing all (raw and formatted) logging output.
    c                 ón   — t           j                             | ¦  «         t          g g ¦  «        | _        d S ©N)ÚloggingÚHandlerÚ__init__r   Úwatcher©Úselfs    ú$/usr/lib/python3.11/unittest/_log.pyr   z_CapturingHandler.__init__   s-   € İŒ× Ò  Ñ&Ô&Ğ&İ& r¨2Ñ.Ô.ˆŒˆˆó    c                 ó   — d S r   © r   s    r   Úflushz_CapturingHandler.flush   s   € Øˆr   c                 ó¬   — | j         j                             |¦  «         |                      |¦  «        }| j         j                             |¦  «         d S r   )r   r   ÚappendÚformatr   )r   ÚrecordÚmsgs      r   Úemitz_CapturingHandler.emit   sK   € ØŒÔ×#Ò# FÑ+Ô+Ğ+ØkŠk˜&Ñ!Ô!ˆØŒÔ×"Ò" 3Ñ'Ô'Ğ'Ğ'Ğ'r   N)Ú__name__Ú
__module__Ú__qualname__Ú__doc__r   r   r   r   r   r   r	   r	   
   sK   € € € € € ğğ ğ/ğ /ğ /ğğ ğ ğ(ğ (ğ (ğ (ğ (r   r	   c                   ó(   — e Zd ZdZdZd„ Zd„ Zd„ ZdS )Ú_AssertLogsContextz6A context manager for assertLogs() and assertNoLogs() z"%(levelname)s:%(name)s:%(message)sc                 óÌ   — t          j        | |¦  «         || _        |r&t          j                             ||¦  «        | _        nt          j        | _        d | _        || _	        d S r   )
r   r   Úlogger_namer   Ú_nameToLevelÚgetÚlevelÚINFOr   Úno_logs)r   Ú	test_caser$   r'   r)   s        r   r   z_AssertLogsContext.__init__!   s\   € İÔ% d¨IÑ6Ô6Ğ6Ø&ˆÔØğ 	&İ Ô-×1Ò1°%¸Ñ?Ô?ˆDŒJˆJå œˆDŒJØˆŒØˆŒˆˆr   c                 ó,  — t          | j        t          j        ¦  «        r| j        x}| _        n t          j        | j        ¦  «        x}| _        t          j        | j        ¦  «        }t          ¦   «         }| 	                    | j
        ¦  «         |                     |¦  «         |j        | _        |j        d d …         | _        |j
        | _        |j        | _        |g|_        | 	                    | j
        ¦  «         d|_        | j        rd S |j        S )NF)Ú
isinstancer$   r   ÚLoggerÚloggerÚ	getLoggerÚ	FormatterÚLOGGING_FORMATr	   ÚsetLevelr'   ÚsetFormatterr   ÚhandlersÚold_handlersÚ	old_levelÚ	propagateÚold_propagater)   )r   r.   Ú	formatterÚhandlers       r   Ú	__enter__z_AssertLogsContext.__enter__+   sù   € İdÔ&­¬Ñ7Ô7ğ 	GØ#'Ô#3Ğ3ˆFT”[[å#*Ô#4°TÔ5EÑ#FÔ#FĞFˆFT”[İÔ% dÔ&9Ñ:Ô:ˆ	İ#Ñ%Ô%ˆØ×Ò˜œÑ$Ô$Ğ$Ø×Ò˜YÑ'Ô'Ğ'Ø”ˆŒØ"œO¨A¨A¨AÔ.ˆÔØœˆŒØ#Ô-ˆÔØ"˜)ˆŒØŠ˜œ
Ñ#Ô#Ğ#Ø ˆÔØŒ<ğ 	ØˆFØŒĞr   c                 ó  — | j         | j        _        | j        | j        _        | j                             | j        ¦  «         |dS | j        rSt          | j	        j
        ¦  «        dk    r4|                      d                     | j	        j        ¦  «        ¦  «         d S d S t          | j	        j
        ¦  «        dk    rL|                      d                     t          j        | j        ¦  «        | j        j        ¦  «        ¦  «         d S d S )NFr   zUnexpected logs found: {!r}z-no logs of level {} or higher triggered on {})r5   r.   r4   r8   r7   r2   r6   r)   Úlenr   r   Ú_raiseFailurer   r   r   ÚgetLevelNamer'   Úname)r   Úexc_typeÚ	exc_valueÚtbs       r   Ú__exit__z_AssertLogsContext.__exit__?   s  € Ø#Ô0ˆŒÔØ $Ô 2ˆŒÔØŒ×Ò˜Tœ^Ñ,Ô,Ğ,àĞà5àŒ<ğ 	Qå4”<Ô'Ñ(Ô(¨1Ò,Ğ,Ø×"Ò"Ø1×8Ò8ØœÔ+ñô ñô ğ ğ ğ ğ -Ğ,õ 4”<Ô'Ñ(Ô(¨AÒ-Ğ-Ø×"Ò"ØCß’VGÔ0°´Ñ<Ô<¸d¼kÔ>NÑOÔOñQô Qğ Qğ Qğ Qğ .Ğ-r   N)r   r   r   r    r1   r   r;   rD   r   r   r   r"   r"      sQ   € € € € € Ø@Ğ@à9€Nğğ ğ ğğ ğ ğ(Qğ Qğ Qğ Qğ Qr   r"   )	r   ÚcollectionsÚcaser   Ú
namedtupler   r   r	   r"   r   r   r   ú<module>rH      sº   ğØ €€€Ø Ğ Ğ Ğ à &Ğ &Ğ &Ğ &Ğ &Ğ &ğ )+Ô(Ğ):Ø*3°XĞ)>ñ@ô @€ğ(ğ (ğ (ğ (ğ (˜œñ (ô (ğ (ğ$:Qğ :Qğ :Qğ :Qğ :QĞ-ñ :Qô :Qğ :Qğ :Qğ :Qr                                                                                                                                                                                                                                                                                                                          usr/lib/python3.11/unittest/__pycache__/async_case.cpython-311.pyc                                  0000644 0000000 0000000 00000015507 14714551121 023361  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        §
    NüäfY  ã                   óN   — d dl Z d dlZd dlZd dlZddlmZ  G d„ de¦  «        ZdS )é    Né   )ÚTestCasec                   ó„   ‡ — e Zd Zdˆ fd„	Zd„ Zd„ Zd„ Zd„ Zd„ Zd„ Z	d	„ Z
d
„ Zd„ Zd„ Zd„ Zd„ Zdˆ fd„	Zˆ fd„Zd„ Zˆ xZS )ÚIsolatedAsyncioTestCaseÚrunTestc                 óˆ   •— t          ¦   «                              |¦  «         d | _        t          j        ¦   «         | _        d S ©N)ÚsuperÚ__init__Ú_asyncioRunnerÚcontextvarsÚcopy_contextÚ_asyncioTestContext)ÚselfÚ
methodNameÚ	__class__s     €ú*/usr/lib/python3.11/unittest/async_case.pyr   z IsolatedAsyncioTestCase.__init__#   s:   ø€ İ‰Œ×Ò˜Ñ$Ô$Ğ$Ø"ˆÔİ#.Ô#;Ñ#=Ô#=ˆÔ Ğ Ğ ó    c              ƒ   ó
   K  — d S r	   © ©r   s    r   Ú
asyncSetUpz"IsolatedAsyncioTestCase.asyncSetUp(   ó   è è € Øˆr   c              ƒ   ó
   K  — d S r	   r   r   s    r   ÚasyncTearDownz%IsolatedAsyncioTestCase.asyncTearDown+   r   r   c                ó(   —  | j         |g|¢R i |¤ d S r	   )Ú
addCleanup©r   ÚfuncÚargsÚkwargss       r   ÚaddAsyncCleanupz'IsolatedAsyncioTestCase.addAsyncCleanup.   s)   € ğ 	ˆŒ˜$˜ ˜˜Ğ1¨&Ğ1Ğ1Ğ1Ğ1Ğ1r   c              ƒ   óú   K  — t          |¦  «        }	 |j        }|j        }n/# t          $ r" t	          d|j        › d|j        › d¦  «        d‚w xY w ||¦  «        ƒ d{V —†}|                      ||ddd¦  «         |S )zÀEnters the supplied asynchronous context manager.

        If successful, also adds its __aexit__ method as a cleanup
        function and returns the result of the __aenter__ method.
        ú'ú.zC' object does not support the asynchronous context manager protocolN)ÚtypeÚ
__aenter__Ú	__aexit__ÚAttributeErrorÚ	TypeErrorÚ
__module__Ú__qualname__r"   )r   ÚcmÚclsÚenterÚexitÚresults         r   ÚenterAsyncContextz)IsolatedAsyncioTestCase.enterAsyncContext=   sÁ   è è € õ 2‰hŒhˆğ	'Ø”NˆEØ”=ˆDˆDøİğ 	'ğ 	'ğ 	'İğ U ¤ğ Uğ U°Ô1Ağ Uğ Uğ Uñ ô à"&ğ'ğ	'øøøğ u˜R‘y”yˆØ×Ò˜T 2 t¨T°4Ñ8Ô8Ğ8Øˆs	   “" ¢,Ac                 óª   — | j                              ¦   «          | j                             | j        ¦  «         |                      | j        ¦  «         d S r	   )r   Úget_loopr   ÚrunÚsetUpÚ
_callAsyncr   r   s    r   Ú
_callSetUpz"IsolatedAsyncioTestCase._callSetUpQ   sL   € ğ 	Ô×$Ò$Ñ&Ô&Ğ&ØÔ ×$Ò$ T¤ZÑ0Ô0Ğ0ØŠ˜œÑ(Ô(Ğ(Ğ(Ğ(r   c                 ót   — |                       |¦  «        "t          j        d|› dt          d¬¦  «         d S d S )NzFIt is deprecated to return a value that is not None from a test case (ú)é   )Ú
stacklevel)Ú_callMaybeAsyncÚwarningsÚwarnÚDeprecationWarning)r   Úmethods     r   Ú_callTestMethodz'IsolatedAsyncioTestCase._callTestMethodY   sd   € Ø×Ò Ñ'Ô'Ğ3İŒMğ 2Ø(.ğ2ğ 2ğ 2İ3EĞRSğUñ Uô Uğ Uğ Uğ Uğ 4Ğ3r   c                 óx   — |                       | j        ¦  «         | j                             | j        ¦  «         d S r	   )r7   r   r   r5   ÚtearDownr   s    r   Ú_callTearDownz%IsolatedAsyncioTestCase._callTearDown^   s6   € ØŠ˜Ô*Ñ+Ô+Ğ+ØÔ ×$Ò$ T¤]Ñ3Ô3Ğ3Ğ3Ğ3r   c                 ó(   —  | j         |g|¢R i |¤ d S r	   )r=   )r   Úfunctionr    r!   s       r   Ú_callCleanupz$IsolatedAsyncioTestCase._callCleanupb   s+   € ØˆÔ˜XĞ7¨Ğ7Ğ7Ğ7°Ğ7Ğ7Ğ7Ğ7Ğ7r   c                ó´   — | j         €
J d¦   «         ‚t          j        |¦  «        sJ |›d¦   «         ‚| j                               ||i |¤| j        ¬¦  «        S )Nú!asyncio runner is not initializedz is not an async function©Úcontext©r   ÚinspectÚiscoroutinefunctionr5   r   r   s       r   r7   z"IsolatedAsyncioTestCase._callAsynce   sz   € ØÔ"Ğ.Ğ.Ğ0SÑ.Ô.Ğ.İÔ*¨4Ñ0Ô0ĞVĞV°TĞ2VĞ2VĞ2VÑVÔVĞVØÔ"×&Ò&ØˆD$Ğ!˜&Ğ!Ğ!ØÔ,ğ 'ñ 
ô 
ğ 	
r   c                óÆ   — | j         €
J d¦   «         ‚t          j        |¦  «        r'| j                               ||i |¤| j        ¬¦  «        S  | j        j        |g|¢R i |¤S )NrJ   rK   rM   r   s       r   r=   z'IsolatedAsyncioTestCase._callMaybeAsyncm   s   € ØÔ"Ğ.Ğ.Ğ0SÑ.Ô.Ğ.İÔ& tÑ,Ô,ğ 	GØÔ&×*Ò*ØdĞ%˜fĞ%Ğ%ØÔ0ğ +ñ ô ğ ğ
 04Ô+Ô/°ĞF°tĞFĞFĞF¸vĞFĞFĞFr   c                 ó`   — | j         
J d¦   «         ‚t          j        d¬¦  «        }|| _         d S )Nz%asyncio runner is already initializedT)Údebug)r   ÚasyncioÚRunner©r   Úrunners     r   Ú_setupAsyncioRunnerz+IsolatedAsyncioTestCase._setupAsyncioRunnerw   s:   € ØÔ"Ğ*Ğ*Ğ,SÑ*Ô*Ğ*İ” dĞ+Ñ+Ô+ˆØ$ˆÔĞĞr   c                 ó<   — | j         }|                     ¦   «          d S r	   )r   ÚcloserU   s     r   Ú_tearDownAsyncioRunnerz.IsolatedAsyncioTestCase._tearDownAsyncioRunner|   s   € ØÔ$ˆØŠ‰Œˆˆˆr   Nc                 óÊ   •— |                       ¦   «          	 t          ¦   «                              |¦  «        |                      ¦   «          S # |                      ¦   «          w xY wr	   )rW   r
   r5   rZ   )r   r1   r   s     €r   r5   zIsolatedAsyncioTestCase.run€   sZ   ø€ Ø× Ò Ñ"Ô"Ğ"ğ	*İ‘7”7—;’;˜vÑ&Ô&à×'Ò'Ñ)Ô)Ğ)Ğ)øˆD×'Ò'Ñ)Ô)Ğ)Ğ)øøøs   — A ÁA"c                 ó˜   •— |                       ¦   «          t          ¦   «                              ¦   «          |                      ¦   «          d S r	   )rW   r
   rR   rZ   )r   r   s    €r   rR   zIsolatedAsyncioTestCase.debug‡   s>   ø€ Ø× Ò Ñ"Ô"Ğ"İ‰ŒŠ‰ŒˆØ×#Ò#Ñ%Ô%Ğ%Ğ%Ğ%r   c                 ó@   — | j         |                      ¦   «          d S d S r	   )r   rZ   r   s    r   Ú__del__zIsolatedAsyncioTestCase.__del__Œ   s+   € ØÔĞ*Ø×'Ò'Ñ)Ô)Ğ)Ğ)Ğ)ğ +Ğ*r   )r   r	   )Ú__name__r+   r,   r   r   r   r"   r2   r8   rB   rE   rH   r7   r=   rW   rZ   r5   rR   r^   Ú__classcell__)r   s   @r   r   r   	   s=  ø€ € € € € ğ4>ğ >ğ >ğ >ğ >ğ >ğ
ğ ğ ğğ ğ ğ2ğ 2ğ 2ğğ ğ ğ()ğ )ğ )ğUğ Uğ Uğ
4ğ 4ğ 4ğ8ğ 8ğ 8ğ
ğ 
ğ 
ğGğ Gğ Gğ%ğ %ğ %ğ
ğ ğ ğ*ğ *ğ *ğ *ğ *ğ *ğ&ğ &ğ &ğ &ğ &ğ
*ğ *ğ *ğ *ğ *ğ *ğ *r   r   )rS   r   rN   r>   Úcaser   r   r   r   r   ú<module>rb      s|   ğØ €€€Ø Ğ Ğ Ğ Ø €€€Ø €€€à Ğ Ğ Ğ Ğ Ğ ğE*ğ E*ğ E*ğ E*ğ E*˜hñ E*ô E*ğ E*ğ E*ğ E*r                                                                                                                                                                                            usr/lib/python3.11/unittest/__pycache__/case.cpython-311.pyc                                        0000644 0000000 0000000 00000233237 14714551121 022166  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        §
    Nüäf‡ä  ã                   óB  — d Z ddlZddlZddlZddlZddlZddlZddlZddlZddl	Z	ddl
Z
ddlmZ ddlmZmZmZmZmZ dZ e¦   «         ZdZ G d„ d	e¦  «        Z G d
„ de¦  «        Z G d„ de¦  «        Z G d„ de¦  «        Zd„ Zd„ Zd„ Zd„ Zg Z d„ Z!d„ Z"d„ Z#d„ Z$d„ Z%d„ Z&d„ Z'd„ Z( G d„ d¦  «        Z) G d„ de)¦  «        Z* G d „ d!e*¦  «        Z+ G d"„ d#e*¦  «        Z, G d$„ d%ej-        ¦  «        Z. G d&„ d'e¦  «        Z/ G d(„ d)e/¦  «        Z0 G d*„ d+e/¦  «        Z1dS ),zTest case implementationé    Né   )Úresult)ÚstrclassÚ	safe_reprÚ_count_diff_all_purposeÚ_count_diff_hashableÚ_common_shorten_reprTz@
Diff is %s characters long. Set self.maxDiff to None to see it.c                   ó   — e Zd ZdZdS )ÚSkipTestz©
    Raise this exception in a test to skip it.

    Usually you can use TestCase.skipTest() or one of the skipping decorators
    instead of raising this directly.
    N©Ú__name__Ú
__module__Ú__qualname__Ú__doc__© ó    ú$/usr/lib/python3.11/unittest/case.pyr   r      s   € € € € € ğğ ğ ğ r   r   c                   ó   — e Zd ZdZdS )Ú_ShouldStopz
    The test should stop.
    Nr   r   r   r   r   r   !   ó   € € € € € ğğ ğ ğ r   r   c                   ó   — e Zd ZdZdS )Ú_UnexpectedSuccessz7
    The test was supposed to fail, but it didn't!
    Nr   r   r   r   r   r   &   r   r   r   c                   ó8   — e Zd Zdd„Zej        dd„¦   «         ZdS )Ú_OutcomeNc                 óh   — d| _         || _        t          |d¦  «        | _        d| _        d | _        d S )NFÚ
addSubTestT)Úexpecting_failurer   ÚhasattrÚresult_supports_subtestsÚsuccessÚexpectedFailure)Úselfr   s     r   Ú__init__z_Outcome.__init__-   s8   € Ø!&ˆÔØˆŒİ(/°¸Ñ(EÔ(EˆÔ%ØˆŒØ#ˆÔĞĞr   Fc              #   óB  K  — | j         }d| _         	 d V — |r(| j         r!| j                             |j        |d ¦  «         n½# t          $ r ‚ t
          $ r4}d| _         t          | j        |t          |¦  «        ¦  «         Y d }~nzd }~wt          $ r Y nk t          j
        ¦   «         }| j        r|| _        nAd| _         |r"| j                             |j        ||¦  «         nt          | j        ||¦  «         d }Y nxY w| j         o|| _         d S # | j         o|| _         w xY w)NTF)r    r   r   Ú	test_caseÚKeyboardInterruptr   Ú_addSkipÚstrr   ÚsysÚexc_infor   r!   Ú	_addError)r"   r%   ÚsubTestÚold_successÚer*   s         r   ÚtestPartExecutorz_Outcome.testPartExecutor4   sq  è è € à”lˆØˆŒğ	8ØˆEˆEˆEğ, ğ M˜4œ<ğ MØ”×&Ò& yÔ':¸IÀtÑLÔLĞLøøõ- !ğ 	ğ 	ğ 	Øİğ 	5ğ 	5ğ 	5Ø ˆDŒLİT”[ )­S°©V¬VÑ4Ô4Ğ4Ğ4Ğ4Ğ4Ğ4Ğ4øøøøİğ 	ğ 	ğ 	ØˆDğ	İ”|‘~”~ˆHØÔ%ğ @Ø'/Ô$Ğ$à$”Øğ @Ø”K×*Ò*¨9Ô+>À	È8ÑTÔTĞTĞTå˜dœk¨9°hÑ?Ô?Ğ?ğ ˆHˆHˆHøøøğ
  œ<Ğ7¨KˆDŒLˆLˆLø˜4œ<Ğ7¨KˆDŒLĞ7Ğ7Ğ7Ğ7s;   ’A –+D ÁC;Á*BÁ?D ÂC;ÂD ÂA&C;Ã9D ÄD©N)F)r   r   r   r#   Ú
contextlibÚcontextmanagerr/   r   r   r   r   r   ,   sL   € € € € € ğ$ğ $ğ $ğ $ğ Ôğ8ğ 8ğ 8ñ Ôğ8ğ 8ğ 8r   r   c                 ó   — t          | dd ¦  «        }| |||¦  «         d S t          j        dt          d¦  «          | j        |¦  «         d S )NÚaddSkipz4TestResult has no addSkip method, skips not reportedé   )ÚgetattrÚwarningsÚwarnÚRuntimeWarningÚ
addSuccess)r   r%   Úreasonr4   s       r   r'   r'   U   sf   € İf˜i¨Ñ.Ô.€GØĞØˆ	˜6Ñ"Ô"Ğ"Ğ"Ğ"åŒĞLİ$ añ	)ô 	)ğ 	)àˆÔ˜)Ñ$Ô$Ğ$Ğ$Ğ$r   c                 ó”   — | C|Ct          |d         |j        ¦  «        r | j        ||¦  «         d S  | j        ||¦  «         d S d S d S )Nr   )Ú
issubclassÚfailureExceptionÚ
addFailureÚaddError)r   Útestr*   s      r   r+   r+   ^   si   € ØĞ˜hĞ2İh˜q”k 4Ô#8Ñ9Ô9ğ 	,ØˆFÔ˜d HÑ-Ô-Ğ-Ğ-Ğ-àˆFŒO˜D (Ñ+Ô+Ğ+Ğ+Ğ+ğ	 ĞĞ2Ğ2r   c                 ó   — | S r0   r   )Úobjs    r   Ú_idrD   e   s   € Ø€Jr   c                 óÖ   — t          | ¦  «        }	 |j        }|j        }n/# t          $ r" t	          d|j        › d|j        › d¦  «        d ‚w xY w || ¦  «        } ||| d d d ¦  «         |S )Nú'ú.z6' object does not support the context manager protocol)ÚtypeÚ	__enter__Ú__exit__ÚAttributeErrorÚ	TypeErrorr   r   )ÚcmÚ
addcleanupÚclsÚenterÚexitr   s         r   Ú_enter_contextrR   i   sµ   € õ ˆr‰(Œ(€CğOØ”ˆØŒ|ˆˆøİğ Oğ Oğ Oİğ D˜CœNğ Dğ D¨SÔ-=ğ Dğ Dğ Dñ Eô EØJNğ	OğOøøøğ ˆU2‰YŒY€FØ€JˆtR˜˜t TÑ*Ô*Ğ*Ø€Ms	   ‘   ,Ac                ó@   — t                                | ||f¦  «         dS )znSame as addCleanup, except the cleanup items are called even if
    setUpModule fails (unlike tearDownModule).N)Ú_module_cleanupsÚappend)ÚfunctionÚargsÚkwargss      r   ÚaddModuleCleanuprY   y   s%   € õ ×Ò˜X t¨VĞ4Ñ5Ô5Ğ5Ğ5Ğ5r   c                 ó,   — t          | t          ¦  «        S )z&Same as enterContext, but module-wide.)rR   rY   )rM   s    r   ÚenterModuleContextr[   ~   s   € å˜"Õ.Ñ/Ô/Ğ/r   c                  óà   — g } t           rZt                                ¦   «         \  }}}	  ||i |¤ n,# t          $ r}|                      |¦  «         Y d}~nd}~ww xY wt           °Z| r| d         ‚dS )zWExecute all module cleanup functions. Normally called for you after
    tearDownModule.Nr   )rT   ÚpopÚ	ExceptionrU   )Ú
exceptionsrV   rW   rX   Úexcs        r   ÚdoModuleCleanupsra   ƒ   s²   € ğ €Jİ
ğ #İ!1×!5Ò!5Ñ!7Ô!7Ñˆ$˜ğ	#ØˆHdĞ%˜fĞ%Ğ%Ğ%Ğ%øİğ 	#ğ 	#ğ 	#Ø×Ò˜cÑ"Ô"Ğ"Ğ"Ğ"Ğ"Ğ"Ğ"øøøøğ	#øøøõ	 ğ #ğ ğ ğ ˜ŒmĞğğ s   ¨1 ±
A»AÁAc                 ód   ‡ — ˆ fd„}t          ‰ t          j        ¦  «        r‰ }dŠ  ||¦  «        S |S )z&
    Unconditionally skip a test.
    c                 ó   •— t          | t          ¦  «        s!t          j        | ¦  «        ˆfd„¦   «         }|} d| _        ‰| _        | S )Nc                  ó"   •— t          ‰¦  «        ‚r0   ©r   )rW   rX   r;   s     €r   Úskip_wrapperz-skip.<locals>.decorator.<locals>.skip_wrapper™   s   ø€ å˜vÑ&Ô&Ğ&r   T)Ú
isinstancerH   Ú	functoolsÚwrapsÚ__unittest_skip__Ú__unittest_skip_why__)Ú	test_itemrf   r;   s     €r   Ú	decoratorzskip.<locals>.decorator—   s^   ø€ İ˜)¥TÑ*Ô*ğ 	%İŒ_˜YÑ'Ô'ğ'ğ 'ğ 'ğ 'ñ (Ô'ğ'à$ˆIà&*ˆ	Ô#Ø*0ˆ	Ô'ØĞr   Ú )rg   ÚtypesÚFunctionType)r;   rm   rl   s   `  r   Úskiprq   “   sS   ø€ ğ	ğ 	ğ 	ğ 	ğ 	õ &%Ô,Ñ-Ô-ğ $Øˆ	ØˆØˆy˜Ñ#Ô#Ğ#ØĞr   c                 ó2   — | rt          |¦  «        S t          S )z/
    Skip a test if the condition is true.
    ©rq   rD   ©Ú	conditionr;   s     r   ÚskipIfrv   §   s   € ğ ğ İF‰|Œ|Ğİ€Jr   c                 ó2   — | st          |¦  «        S t          S )z3
    Skip a test unless the condition is true.
    rs   rt   s     r   Ú
skipUnlessrx   ¯   s   € ğ ğ İF‰|Œ|Ğİ€Jr   c                 ó   — d| _         | S )NT)Ú__unittest_expecting_failure__)rl   s    r   r!   r!   ·   s   € Ø/3€IÔ,ØĞr   c                 ó®   ‡— t          | t          ¦  «        rt          ˆfd„| D ¦   «         ¦  «        S t          | t          ¦  «        ot	          | ‰¦  «        S )Nc              3   ó8   •K  — | ]}t          |‰¦  «        V — Œd S r0   )Ú_is_subtype)Ú.0r.   Úbasetypes     €r   ú	<genexpr>z_is_subtype.<locals>.<genexpr>½   s-   øè è € Ğ>Ğ>°•;˜q (Ñ+Ô+Ğ>Ğ>Ğ>Ğ>Ğ>Ğ>r   )rg   ÚtupleÚallrH   r=   )Úexpectedr   s    `r   r}   r}   »   sW   ø€ İ(EÑ"Ô"ğ ?İĞ>Ğ>Ğ>Ğ>°XĞ>Ñ>Ô>Ñ>Ô>Ğ>İh¥Ñ%Ô%ĞH­*°X¸xÑ*HÔ*HĞHr   c                   ó   — e Zd Zd„ Zd„ ZdS )Ú_BaseTestCaseContextc                 ó   — || _         d S r0   )r%   )r"   r%   s     r   r#   z_BaseTestCaseContext.__init__Â   s   € Ø"ˆŒˆˆr   c                 óv   — | j                              | j        |¦  «        }| j                              |¦  «        ‚r0   )r%   Ú_formatMessageÚmsgr>   )r"   ÚstandardMsgr‰   s      r   Ú_raiseFailurez"_BaseTestCaseContext._raiseFailureÅ   s1   € ØŒn×+Ò+¨D¬H°kÑBÔBˆØŒn×-Ò-¨cÑ2Ô2Ğ2r   N)r   r   r   r#   r‹   r   r   r   r…   r…   À   s2   € € € € € ğ#ğ #ğ #ğ3ğ 3ğ 3ğ 3ğ 3r   r…   c                   ó   — e Zd Zdd„Zd„ ZdS )Ú_AssertRaisesBaseContextNc                 ó®   — t                                | |¦  «         || _        || _        |t	          j        |¦  «        }|| _        d | _        d | _        d S r0   )	r…   r#   rƒ   r%   ÚreÚcompileÚexpected_regexÚobj_namer‰   )r"   rƒ   r%   r‘   s       r   r#   z!_AssertRaisesBaseContext.__init__Ë   sU   € İ×%Ò% d¨IÑ6Ô6Ğ6Ø ˆŒØ"ˆŒØĞ%İœZ¨Ñ7Ô7ˆNØ,ˆÔØˆŒØˆŒˆˆr   c                 óÎ  — 	 t          | j        | j        ¦  «        st          |›d| j        ›¦  «        ‚|sM|                     dd¦  «        | _        |r,t          t          t          |¦  «        ¦  «        ›d¦  «        ‚| d} S |^}}	 |j	        | _
