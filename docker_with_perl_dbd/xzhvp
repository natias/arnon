an 50.60.300 &Syntax.L.Login\.defs :cal SetSyn("logindefs")<CR>
an 50.60.310 &Syntax.L.Logtalk :cal SetSyn("logtalk")<CR>
an 50.60.320 &Syntax.L.LOTOS :cal SetSyn("lotos")<CR>
an 50.60.330 &Syntax.L.LotusScript :cal SetSyn("lscript")<CR>
an 50.60.340 &Syntax.L.Lout :cal SetSyn("lout")<CR>
an 50.60.350 &Syntax.L.LPC :cal SetSyn("lpc")<CR>
an 50.60.360 &Syntax.L.Lua :cal SetSyn("lua")<CR>
an 50.60.370 &Syntax.L.Lynx\ Style :cal SetSyn("lss")<CR>
an 50.60.380 &Syntax.L.Lynx\ config :cal SetSyn("lynx")<CR>
an 50.70.100 &Syntax.M.M4 :cal SetSyn("m4")<CR>
an 50.70.110 &Syntax.M.MaGic\ Point :cal SetSyn("mgp")<CR>
an 50.70.120 &Syntax.M.Mail :cal SetSyn("mail")<CR>
an 50.70.130 &Syntax.M.Mail\ aliases :cal SetSyn("mailaliases")<CR>
an 50.70.140 &Syntax.M.Mailcap :cal SetSyn("mailcap")<CR>
an 50.70.150 &Syntax.M.Mallard :cal SetSyn("mallard")<CR>
an 50.70.160 &Syntax.M.Makefile :cal SetSyn("make")<CR>
an 50.70.170 &Syntax.M.MakeIndex :cal SetSyn("ist")<CR>
an 50.70.180 &Syntax.M.Man\ page :cal SetSyn("man")<CR>
an 50.70.190 &Syntax.M.Man\.conf :cal SetSyn("manconf")<CR>
an 50.70.200 &Syntax.M.Maple\ V :cal SetSyn("maple")<CR>
an 50.70.210 &Syntax.M.Markdown :cal SetSyn("markdown")<CR>
an 50.70.220 &Syntax.M.Markdown\ with\ R\ statements :cal SetSyn("rmd")<CR>
an 50.70.230 &Syntax.M.Mason :cal SetSyn("mason")<CR>
an 50.70.240 &Syntax.M.Mathematica :cal SetSyn("mma")<CR>
an 50.70.250 &Syntax.M.Matlab :cal SetSyn("matlab")<CR>
an 50.70.260 &Syntax.M.Maxima :cal SetSyn("maxima")<CR>
an 50.70.270 &Syntax.M.MEL\ (for\ Maya) :cal SetSyn("mel")<CR>
an 50.70.280 &Syntax.M.Meson :cal SetSyn("meson")<CR>
an 50.70.290 &Syntax.M.Messages\ (/var/log) :cal SetSyn("messages")<CR>
an 50.70.300 &Syntax.M.Metafont :cal SetSyn("mf")<CR>
an 50.70.310 &Syntax.M.MetaPost :cal SetSyn("mp")<CR>
an 50.70.320 &Syntax.M.MGL :cal SetSyn("mgl")<CR>
an 50.70.330 &Syntax.M.MIX :cal SetSyn("mix")<CR>
an 50.70.340 &Syntax.M.MMIX :cal SetSyn("mmix")<CR>
an 50.70.350 &Syntax.M.Modconf :cal SetSyn("modconf")<CR>
an 50.70.360 &Syntax.M.Model :cal SetSyn("model")<CR>
an 50.70.370 &Syntax.M.Modsim\ III :cal SetSyn("modsim3")<CR>
an 50.70.380 &Syntax.M.Modula\ 2 :cal SetSyn("modula2")<CR>
an 50.70.390 &Syntax.M.Modula\ 3 :cal SetSyn("modula3")<CR>
an 50.70.400 &Syntax.M.Monk :cal SetSyn("monk")<CR>
an 50.70.410 &Syntax.M.Motorola\ S-Record :cal SetSyn("srec")<CR>
an 50.70.420 &Syntax.M.Mplayer\ config :cal SetSyn("mplayerconf")<CR>
an 50.70.430 &Syntax.M.MOO :cal SetSyn("moo")<CR>
an 50.70.440 &Syntax.M.Mrxvtrc :cal SetSyn("mrxvtrc")<CR>
an 50.70.450 &Syntax.M.MS-DOS/Windows.4DOS\ \.bat\ file :cal SetSyn("btm")<CR>
an 50.70.460 &Syntax.M.MS-DOS/Windows.\.bat\/\.cmd\ file :cal SetSyn("dosbatch")<CR>
an 50.70.470 &Syntax.M.MS-DOS/Windows.\.ini\ file :cal SetSyn("dosini")<CR>
an 50.70.480 &Syntax.M.MS-DOS/Windows.Message\ text :cal SetSyn("msmessages")<CR>
an 50.70.490 &Syntax.M.MS-DOS/Windows.Module\ Definition :cal SetSyn("def")<CR>
an 50.70.500 &Syntax.M.MS-DOS/Windows.Registry :cal SetSyn("registry")<CR>
an 50.70.510 &Syntax.M.MS-DOS/Windows.Resource\ file :cal SetSyn("rc")<CR>
an 50.70.520 &Syntax.M.Msql :cal SetSyn("msql")<CR>
an 50.70.530 &Syntax.M.MuPAD :cal SetSyn("mupad")<CR>
an 50.70.540 &Syntax.M.Murphi :cal SetSyn("murphi")<CR>
an 50.70.550 &Syntax.M.MUSHcode :cal SetSyn("mush")<CR>
an 50.70.560 &Syntax.M.Muttrc :cal SetSyn("muttrc")<CR>
an 50.80.100 &Syntax.NO.N1QL :cal SetSyn("n1ql")<CR>
an 50.80.110 &Syntax.NO.Nanorc :cal SetSyn("nanorc")<CR>
an 50.80.120 &Syntax.NO.Nastran\ input/DMAP :cal SetSyn("nastran")<CR>
an 50.80.130 &Syntax.NO.Natural :cal SetSyn("natural")<CR>
an 50.80.140 &Syntax.NO.NeoMutt\ setup\ files :cal SetSyn("neomuttrc")<CR>
an 50.80.150 &Syntax.NO.Netrc :cal SetSyn("netrc")<CR>
an 50.80.160 &Syntax.NO.Ninja :cal SetSyn("ninja")<CR>
an 50.80.170 &Syntax.NO.Novell\ NCF\ batch :cal SetSyn("ncf")<CR>
an 50.80.180 &Syntax.NO.Not\ Quite\ C\ (LEGO) :cal SetSyn("nqc")<CR>
an 50.80.190 &Syntax.NO.Nroff :cal SetSyn("nroff")<CR>
an 50.80.200 &Syntax.NO.NSIS\ script :cal SetSyn("nsis")<CR>
an 50.80.220 &Syntax.NO.Obj\ 3D\ wavefront :cal SetSyn("obj")<CR>
an 50.80.230 &Syntax.NO.Objective\ C :cal SetSyn("objc")<CR>
an 50.80.240 &Syntax.NO.Objective\ C++ :cal SetSyn("objcpp")<CR>
an 50.80.250 &Syntax.NO.OCAML :cal SetSyn("ocaml")<CR>
an 50.80.260 &Syntax.NO.Occam :cal SetSyn("occam")<CR>
an 50.80.270 &Syntax.NO.Omnimark :cal SetSyn("omnimark")<CR>
an 50.80.280 &Syntax.NO.OpenROAD :cal SetSyn("openroad")<CR>
an 50.80.290 &Syntax.NO.Open\ Psion\ Lang :cal SetSyn("opl")<CR>
an 50.80.300 &Syntax.NO.Oracle\ config :cal SetSyn("ora")<CR>
an 50.90.100 &Syntax.PQ.Packet\ filter\ conf :cal SetSyn("pf")<CR>
an 50.90.110 &Syntax.PQ.Palm\ resource\ compiler :cal SetSyn("pilrc")<CR>
an 50.90.120 &Syntax.PQ.Pam\ config :cal SetSyn("pamconf")<CR>
an 50.90.130 &Syntax.PQ.PApp :cal SetSyn("papp")<CR>
an 50.90.140 &Syntax.PQ.Pascal :cal SetSyn("pascal")<CR>
an 50.90.150 &Syntax.PQ.Password\ file :cal SetSyn("passwd")<CR>
an 50.90.160 &Syntax.PQ.PCCTS :cal SetSyn("pccts")<CR>
an 50.90.170 &Syntax.PQ.PDF :cal SetSyn("pdf")<CR>
an 50.90.180 &Syntax.PQ.Perl.Perl :cal SetSyn("perl")<CR>
an 50.90.190 &Syntax.PQ.Perl.Perl\ 6 :cal SetSyn("perl6")<CR>
an 50.90.200 &Syntax.PQ.Perl.Perl\ POD :cal SetSyn("pod")<CR>
an 50.90.210 &Syntax.PQ.Perl.Perl\ XS :cal SetSyn("xs")<CR>
an 50.90.220 &Syntax.PQ.Perl.Template\ toolkit :cal SetSyn("tt2")<CR>
an 50.90.230 &Syntax.PQ.Perl.Template\ toolkit\ Html :cal SetSyn("tt2html")<CR>
an 50.90.240 &Syntax.PQ.Perl.Template\ toolkit\ JS :cal SetSyn("tt2js")<CR>
an 50.90.250 &Syntax.PQ.PHP.PHP\ 3-4 :cal SetSyn("php")<CR>
an 50.90.260 &Syntax.PQ.PHP.Phtml\ (PHP\ 2) :cal SetSyn("phtml")<CR>
an 50.90.270 &Syntax.PQ.Pike :cal SetSyn("pike")<CR>
an 50.90.280 &Syntax.PQ.Pine\ RC :cal SetSyn("pine")<CR>
an 50.90.290 &Syntax.PQ.Pinfo\ RC :cal SetSyn("pinfo")<CR>
an 50.90.300 &Syntax.PQ.PL/M :cal SetSyn("plm")<CR>
an 50.90.310 &Syntax.PQ.PL/SQL :cal SetSyn("plsql")<CR>
an 50.90.320 &Syntax.PQ.Pli :cal SetSyn("pli")<CR>
an 50.90.330 &Syntax.PQ.PLP :cal SetSyn("plp")<CR>
an 50.90.340 &Syntax.PQ.PO\ (GNU\ gettext) :cal SetSyn("po")<CR>
an 50.90.350 &Syntax.PQ.Postfix\ main\ config :cal SetSyn("pfmain")<CR>
an 50.90.360 &Syntax.PQ.PostScript.PostScript :cal SetSyn("postscr")<CR>
an 50.90.370 &Syntax.PQ.PostScript.PostScript\ Printer\ Description :cal SetSyn("ppd")<CR>
an 50.90.380 &Syntax.PQ.Povray.Povray\ scene\ descr :cal SetSyn("pov")<CR>
an 50.90.390 &Syntax.PQ.Povray.Povray\ configuration :cal SetSyn("povini")<CR>
an 50.90.400 &Syntax.PQ.PPWizard :cal SetSyn("ppwiz")<CR>
an 50.90.410 &Syntax.PQ.Prescribe\ (Kyocera) :cal SetSyn("prescribe")<CR>
an 50.90.420 &Syntax.PQ.Printcap :cal SetSyn("pcap")<CR>
an 50.90.430 &Syntax.PQ.Privoxy :cal SetSyn("privoxy")<CR>
an 50.90.440 &Syntax.PQ.Procmail :cal SetSyn("procmail")<CR>
an 50.90.450 &Syntax.PQ.Product\ Spec\ File :cal SetSyn("psf")<CR>
an 50.90.460 &Syntax.PQ.Progress :cal SetSyn("progress")<CR>
an 50.90.470 &Syntax.PQ.Prolog :cal SetSyn("prolog")<CR>
an 50.90.480 &Syntax.PQ.ProMeLa :cal SetSyn("promela")<CR>
an 50.90.490 &Syntax.PQ.Proto :cal SetSyn("proto")<CR>
an 50.90.500 &Syntax.PQ.Protocols :cal SetSyn("protocols")<CR>
an 50.90.510 &Syntax.PQ.Purify\ log :cal SetSyn("purifylog")<CR>
an 50.90.520 &Syntax.PQ.Pyrex :cal SetSyn("pyrex")<CR>
an 50.90.530 &Syntax.PQ.Python :cal SetSyn("python")<CR>
an 50.90.550 &Syntax.PQ.Quake :cal SetSyn("quake")<CR>
an 50.90.560 &Syntax.PQ.Quickfix\ window :cal SetSyn("qf")<CR>
an 50.100.100 &Syntax.R.R.R :cal SetSyn("r")<CR>
an 50.100.110 &Syntax.R.R.R\ help :cal SetSyn("rhelp")<CR>
an 50.100.120 &Syntax.R.R.R\ noweb :cal SetSyn("rnoweb")<CR>
an 50.100.130 &Syntax.R.Racc\ input :cal SetSyn("racc")<CR>
an 50.100.140 &Syntax.R.Radiance :cal SetSyn("radiance")<CR>
an 50.100.150 &Syntax.R.Raml :cal SetSyn("raml")<CR>
an 50.100.160 &Syntax.R.Ratpoison :cal SetSyn("ratpoison")<CR>
an 50.100.170 &Syntax.R.RCS.RCS\ log\ output :cal SetSyn("rcslog")<CR>
an 50.100.180 &Syntax.R.RCS.RCS\ file :cal SetSyn("rcs")<CR>
an 50.100.190 &Syntax.R.Readline\ config :cal SetSyn("readline")<CR>
an 50.100.200 &Syntax.R.Rebol :cal SetSyn("rebol")<CR>
an 50.100.210 &Syntax.R.ReDIF :cal SetSyn("redif")<CR>
an 50.100.220 &Syntax.R.Rego :cal SetSyn("rego")<CR>
an 50.100.230 &Syntax.R.Relax\ NG :cal SetSyn("rng")<CR>
an 50.100.240 &Syntax.R.Remind :cal SetSyn("remind")<CR>
an 50.100.250 &Syntax.R.Relax\ NG\ compact :cal SetSyn("rnc")<CR>
an 50.100.260 &Syntax.R.Renderman.Renderman\ Shader\ Lang :cal SetSyn("sl")<CR>
an 50.100.270 &Syntax.R.Renderman.Renderman\ Interface\ Bytestream :cal SetSyn("rib")<CR>
an 50.100.280 &Syntax.R.Resolv\.conf :cal SetSyn("resolv")<CR>
an 50.100.290 &Syntax.R.Reva\ Forth :cal SetSyn("reva")<CR>
an 50.100.300 &Syntax.R.Rexx :cal SetSyn("rexx")<CR>
an 50.100.310 &Syntax.R.Robots\.txt :cal SetSyn("robots")<CR>
an 50.100.320 &Syntax.R.RockLinux\ package\ desc\. :cal SetSyn("desc")<CR>
an 50.100.330 &Syntax.R.Rpcgen :cal SetSyn("rpcgen")<CR>
an 50.100.340 &Syntax.R.RPL/2 :cal SetSyn("rpl")<CR>
an 50.100.350 &Syntax.R.ReStructuredText :cal SetSyn("rst")<CR>
an 50.110.100 &Syntax.M.ReStructuredText\ with\ R\ statements :cal SetSyn("rrst")<CR>
an 50.120.100 &Syntax.R.RTF :cal SetSyn("rtf")<CR>
an 50.120.110 &Syntax.R.Ruby :cal SetSyn("ruby")<CR>
an 50.120.120 &Syntax.R.Rust :cal SetSyn("rust")<CR>
an 50.130.100 &Syntax.S-Sm.S-Lang :cal SetSyn("slang")<CR>
an 50.130.110 &Syntax.S-Sm.Samba\ config :cal SetSyn("samba")<CR>
an 50.130.120 &Syntax.S-Sm.SAS :cal SetSyn("sas")<CR>
an 50.130.130 &Syntax.S-Sm.Sass :cal SetSyn("sass")<CR>
an 50.130.140 &Syntax.S-Sm.Sather :cal SetSyn("sather")<CR>
an 50.130.150 &Syntax.S-Sm.Sbt :cal SetSyn("sbt")<CR>
an 50.130.160 &Syntax.S-Sm.Scala :cal SetSyn("scala")<CR>
an 50.130.170 &Syntax.S-Sm.Scheme :cal SetSyn("scheme")<CR>
an 50.130.180 &Syntax.S-Sm.Scilab :cal SetSyn("scilab")<CR>
an 50.130.190 &Syntax.S-Sm.Screen\ RC :cal SetSyn("screen")<CR>
an 50.130.200 &Syntax.S-Sm.SCSS :cal SetSyn("scss")<CR>
an 50.130.210 &Syntax.S-Sm.SDC\ Synopsys\ Design\ Constraints :cal SetSyn("sdc")<CR>
an 50.130.220 &Syntax.S-Sm.SDL :cal SetSyn("sdl")<CR>
an 50.130.230 &Syntax.S-Sm.Sed :cal SetSyn("sed")<CR>
an 50.130.240 &Syntax.S-Sm.Sendmail\.cf :cal SetSyn("sm")<CR>
an 50.130.250 &Syntax.S-Sm.Send-pr :cal SetSyn("sendpr")<CR>
an 50.130.260 &Syntax.S-Sm.Sensors\.conf :cal SetSyn("sensors")<CR>
an 50.130.270 &Syntax.S-Sm.Service\ Location\ config :cal SetSyn("slpconf")<CR>
an 50.130.280 &Syntax.S-Sm.Service\ Location\ registration :cal SetSyn("slpreg")<CR>
an 50.130.290 &Syntax.S-Sm.Service\ Location\ SPI :cal SetSyn("slpspi")<CR>
an 50.130.300 &Syntax.S-Sm.Services :cal SetSyn("services")<CR>
an 50.130.310 &Syntax.S-Sm.Setserial\ config :cal SetSyn("setserial")<CR>
an 50.130.320 &Syntax.S-Sm.SGML.SGML\ catalog :cal SetSyn("catalog")<CR>
an 50.130.330 &Syntax.S-Sm.SGML.SGML\ DTD :cal SetSyn("sgml")<CR>
an 50.130.340 &Syntax.S-Sm.SGML.SGML\ Declaration :cal SetSyn("sgmldecl")<CR>
an 50.130.350 &Syntax.S-Sm.SGML.SGML-linuxdoc :cal SetSyn("sgmllnx")<CR>
an 50.130.360 &Syntax.S-Sm.Shell\ script.sh\ and\ ksh :cal SetSyn("sh")<CR>
an 50.130.370 &Syntax.S-Sm.Shell\ script.csh :cal SetSyn("csh")<CR>
an 50.130.380 &Syntax.S-Sm.Shell\ script.tcsh :cal SetSyn("tcsh")<CR>
an 50.130.390 &Syntax.S-Sm.Shell\ script.zsh :cal SetSyn("zsh")<CR>
an 50.130.400 &Syntax.S-Sm.SiCAD :cal SetSyn("sicad")<CR>
an 50.130.410 &Syntax.S-Sm.Sieve :cal SetSyn("sieve")<CR>
an 50.130.420 &Syntax.S-Sm.Simula :cal SetSyn("simula")<CR>
an 50.130.430 &Syntax.S-Sm.Sinda.Sinda\ compare :cal SetSyn("sindacmp")<CR>
an 50.130.440 &Syntax.S-Sm.Sinda.Sinda\ input :cal SetSyn("sinda")<CR>
an 50.130.450 &Syntax.S-Sm.Sinda.Sinda\ output :cal SetSyn("sindaout")<CR>
an 50.130.460 &Syntax.S-Sm.SiSU :cal SetSyn("sisu")<CR>
an 50.130.470 &Syntax.S-Sm.SKILL.SKILL :cal SetSyn("skill")<CR>
an 50.130.480 &Syntax.S-Sm.SKILL.SKILL\ for\ Diva :cal SetSyn("diva")<CR>
an 50.130.490 &Syntax.S-Sm.Slice :cal SetSyn("slice")<CR>
an 50.130.500 &Syntax.S-Sm.SLRN.Slrn\ rc :cal SetSyn("slrnrc")<CR>
an 50.130.510 &Syntax.S-Sm.SLRN.Slrn\ score :cal SetSyn("slrnsc")<CR>
an 50.130.520 &Syntax.S-Sm.SmallTalk :cal SetSyn("st")<CR>
an 50.130.530 &Syntax.S-Sm.Smarty\ Templates :cal SetSyn("smarty")<CR>
an 50.130.540 &Syntax.S-Sm.SMIL :cal SetSyn("smil")<CR>
an 50.130.550 &Syntax.S-Sm.SMITH :cal SetSyn("smith")<CR>
an 50.140.100 &Syntax.Sn-Sy.SNMP\ MIB :cal SetSyn("mib")<CR>
an 50.140.110 &Syntax.Sn-Sy.SNNS.SNNS\ network :cal SetSyn("snnsnet")<CR>
an 50.140.120 &Syntax.Sn-Sy.SNNS.SNNS\ pattern :cal SetSyn("snnspat")<CR>
an 50.140.130 &Syntax.Sn-Sy.SNNS.SNNS\ result :cal SetSyn("snnsres")<CR>
an 50.140.140 &Syntax.Sn-Sy.Snobol4 :cal SetSyn("snobol4")<CR>
an 50.140.150 &Syntax.Sn-Sy.Snort\ Configuration :cal SetSyn("hog")<CR>
an 50.140.160 &Syntax.Sn-Sy.SPEC\ (Linux\ RPM) :cal SetSyn("spec")<CR>
an 50.140.170 &Syntax.Sn-Sy.Specman :cal SetSyn("specman")<CR>
an 50.140.180 &Syntax.Sn-Sy.Spice :cal SetSyn("spice")<CR>
an 50.140.190 &Syntax.Sn-Sy.Spyce :cal SetSyn("spyce")<CR>
an 50.140.200 &Syntax.Sn-Sy.Speedup :cal SetSyn("spup")<CR>
an 50.140.210 &Syntax.Sn-Sy.Splint :cal SetSyn("splint")<CR>
an 50.140.220 &Syntax.Sn-Sy.Squid\ config :cal SetSyn("squid")<CR>
an 50.140.230 &Syntax.Sn-Sy.SQL.SAP\ HANA :cal SetSyn("sqlhana")<CR>
an 50.140.240 &Syntax.Sn-Sy.SQL.ESQL-C :cal SetSyn("esqlc")<CR>
an 50.140.250 &Syntax.Sn-Sy.SQL.MySQL :cal SetSyn("mysql")<CR>
an 50.140.260 &Syntax.Sn-Sy.SQL.PL/SQL :cal SetSyn("plsql")<CR>
an 50.140.270 &Syntax.Sn-Sy.SQL.SQL\ Anywhere :cal SetSyn("sqlanywhere")<CR>
an 50.140.280 &Syntax.Sn-Sy.SQL.SQL\ (automatic) :cal SetSyn("sql")<CR>
an 50.140.290 &Syntax.Sn-Sy.SQL.SQL\ (Oracle) :cal SetSyn("sqloracle")<CR>
an 50.140.300 &Syntax.Sn-Sy.SQL.SQL\ Forms :cal SetSyn("sqlforms")<CR>
an 50.140.310 &Syntax.Sn-Sy.SQL.SQLJ :cal SetSyn("sqlj")<CR>
an 50.140.320 &Syntax.Sn-Sy.SQL.SQL-Informix :cal SetSyn("sqlinformix")<CR>
an 50.140.330 &Syntax.Sn-Sy.SQR :cal SetSyn("sqr")<CR>
an 50.140.340 &Syntax.Sn-Sy.Ssh.ssh_config :cal SetSyn("sshconfig")<CR>
an 50.140.350 &Syntax.Sn-Sy.Ssh.sshd_config :cal SetSyn("sshdconfig")<CR>
an 50.140.360 &Syntax.Sn-Sy.Standard\ ML :cal SetSyn("sml")<CR>
an 50.140.370 &Syntax.Sn-Sy.Stata.SMCL :cal SetSyn("smcl")<CR>
an 50.140.380 &Syntax.Sn-Sy.Stata.Stata :cal SetSyn("stata")<CR>
an 50.140.390 &Syntax.Sn-Sy.Stored\ Procedures :cal SetSyn("stp")<CR>
an 50.140.400 &Syntax.Sn-Sy.Strace :cal SetSyn("strace")<CR>
an 50.140.410 &Syntax.Sn-Sy.Streaming\ descriptor\ file :cal SetSyn("sd")<CR>
an 50.140.420 &Syntax.Sn-Sy.Subversion\ commit :cal SetSyn("svn")<CR>
an 50.140.430 &Syntax.Sn-Sy.Sudoers :cal SetSyn("sudoers")<CR>
an 50.140.440 &Syntax.Sn-Sy.SVG :cal SetSyn("svg")<CR>
an 50.140.450 &Syntax.Sn-Sy.Symbian\ meta-makefile :cal SetSyn("mmp")<CR>
an 50.140.460 &Syntax.Sn-Sy.Sysctl\.conf :cal SetSyn("sysctl")<CR>
an 50.140.470 &Syntax.Sn-Sy.Systemd :cal SetSyn("systemd")<CR>
an 50.140.480 &Syntax.Sn-Sy.SystemVerilog :cal SetSyn("systemverilog")<CR>
an 50.150.100 &Syntax.T.TADS :cal SetSyn("tads")<CR>
an 50.150.110 &Syntax.T.Tags :cal SetSyn("tags")<CR>
an 50.150.120 &Syntax.T.TAK.TAK\ compare :cal SetSyn("takcmp")<CR>
an 50.150.130 &Syntax.T.TAK.TAK\ input :cal SetSyn("tak")<CR>
an 50.150.140 &Syntax.T.TAK.TAK\ output :cal SetSyn("takout")<CR>
an 50.150.150 &Syntax.T.Tar\ listing :cal SetSyn("tar")<CR>
an 50.150.160 &Syntax.T.Task\ data :cal SetSyn("taskdata")<CR>
an 50.150.170 &Syntax.T.Task\ 42\ edit :cal SetSyn("taskedit")<CR>
an 50.150.180 &Syntax.T.Tcl/Tk :cal SetSyn("tcl")<CR>
an 50.150.190 &Syntax.T.TealInfo :cal SetSyn("tli")<CR>
an 50.150.200 &Syntax.T.Telix\ Salt :cal SetSyn("tsalt")<CR>
an 50.150.210 &Syntax.T.Termcap/Printcap :cal SetSyn("ptcap")<CR>
an 50.150.220 &Syntax.T.Terminfo :cal SetSyn("terminfo")<CR>
an 50.150.230 &Syntax.T.Tera\ Term :cal SetSyn("teraterm")<CR>
an 50.150.240 &Syntax.T.TeX.TeX/LaTeX :cal SetSyn("tex")<CR>
an 50.150.250 &Syntax.T.TeX.plain\ TeX :cal SetSyn("plaintex")<CR>
an 50.150.260 &Syntax.T.TeX.Initex :cal SetSyn("initex")<CR>
an 50.150.270 &Syntax.T.TeX.ConTeXt :cal SetSyn("context")<CR>
an 50.150.280 &Syntax.T.TeX.TeX\ configuration :cal SetSyn("texmf")<CR>
an 50.150.290 &Syntax.T.TeX.Texinfo :cal SetSyn("texinfo")<CR>
an 50.150.300 &Syntax.T.TF\ mud\ client :cal SetSyn("tf")<CR>
an 50.150.310 &Syntax.T.Tidy\ configuration :cal SetSyn("tidy")<CR>
an 50.150.320 &Syntax.T.Tilde :cal SetSyn("tilde")<CR>
an 50.150.330 &Syntax.T.Tmux\ configuration :cal SetSyn("tmux")<CR>
an 50.150.340 &Syntax.T.TPP :cal SetSyn("tpp")<CR>
an 50.150.350 &Syntax.T.Trasys\ input :cal SetSyn("trasys")<CR>
an 50.150.360 &Syntax.T.Treetop :cal SetSyn("treetop")<CR>
an 50.150.370 &Syntax.T.Trustees :cal SetSyn("trustees")<CR>
an 50.150.380 &Syntax.T.TSS.Command\ Line :cal SetSyn("tsscl")<CR>
an 50.150.390 &Syntax.T.TSS.Geometry :cal SetSyn("tssgm")<CR>
an 50.150.400 &Syntax.T.TSS.Optics :cal SetSyn("tssop")<CR>
an 50.150.410 &Syntax.T.Typescript :cal SetSyn("typescript")<CR>
an 50.150.420 &Syntax.T.TypescriptReact :cal SetSyn("typescriptreact")<CR>
an 50.160.100 &Syntax.UV.Udev\ config :cal SetSyn("udevconf")<CR>
an 50.160.110 &Syntax.UV.Udev\ permissions :cal SetSyn("udevperm")<CR>
an 50.160.120 &Syntax.UV.Udev\ rules :cal SetSyn("udevrules")<CR>
an 50.160.130 &Syntax.UV.UIT/UIL :cal SetSyn("uil")<CR>
an 50.160.140 &Syntax.UV.UnrealScript :cal SetSyn("uc")<CR>
an 50.160.150 &Syntax.UV.Updatedb\.conf :cal SetSyn("updatedb")<CR>
an 50.160.160 &Syntax.UV.Upstart :cal SetSyn("upstart")<CR>
an 50.160.180 &Syntax.UV.Valgrind :cal SetSyn("valgrind")<CR>
an 50.160.190 &Syntax.UV.Vera :cal SetSyn("vera")<CR>
an 50.160.200 &Syntax.UV.Verbose\ TAP\ Output :cal SetSyn("tap")<CR>
an 50.160.210 &Syntax.UV.Verilog-AMS\ HDL :cal SetSyn("verilogams")<CR>
an 50.160.220 &Syntax.UV.Verilog\ HDL :cal SetSyn("verilog")<CR>
an 50.160.230 &Syntax.UV.Vgrindefs :cal SetSyn("vgrindefs")<CR>
an 50.160.240 &Syntax.UV.VHDL :cal SetSyn("vhdl")<CR>
an 50.160.250 &Syntax.UV.Vim.Vim\ help\ file :cal SetSyn("help")<CR>
an 50.160.260 &Syntax.UV.Vim.Vim\ script :cal SetSyn("vim")<CR>
an 50.160.270 &Syntax.UV.Vim.Viminfo\ file :cal SetSyn("viminfo")<CR>
an 50.160.280 &Syntax.UV.Virata\ config :cal SetSyn("virata")<CR>
an 50.160.290 &Syntax.UV.Visual\ Basic :cal SetSyn("vb")<CR>
an 50.160.300 &Syntax.UV.VOS\ CM\ macro :cal SetSyn("voscm")<CR>
an 50.160.310 &Syntax.UV.VRML :cal SetSyn("vrml")<CR>
an 50.160.320 &Syntax.UV.Vroom :cal SetSyn("vroom")<CR>
an 50.160.330 &Syntax.UV.VSE\ JCL :cal SetSyn("vsejcl")<CR>
an 50.170.100 &Syntax.WXYZ.WEB.CWEB :cal SetSyn("cweb")<CR>
an 50.170.110 &Syntax.WXYZ.WEB.WEB :cal SetSyn("web")<CR>
an 50.170.120 &Syntax.WXYZ.WEB.WEB\ Changes :cal SetSyn("change")<CR>
an 50.170.130 &Syntax.WXYZ.WebAssembly :cal SetSyn("wast")<CR>
an 50.170.140 &Syntax.WXYZ.Webmacro :cal SetSyn("webmacro")<CR>
an 50.170.150 &Syntax.WXYZ.Website\ MetaLanguage :cal SetSyn("wml")<CR>
an 50.170.170 &Syntax.WXYZ.wDiff :cal SetSyn("wdiff")<CR>
an 50.170.190 &Syntax.WXYZ.Wget\ config :cal SetSyn("wget")<CR>
an 50.170.200 &Syntax.WXYZ.Whitespace\ (add) :cal SetSyn("whitespace")<CR>
an 50.170.210 &Syntax.WXYZ.WildPackets\ EtherPeek\ Decoder :cal SetSyn("dcd")<CR>
an 50.170.220 &Syntax.WXYZ.WinBatch/Webbatch :cal SetSyn("winbatch")<CR>
an 50.170.230 &Syntax.WXYZ.Windows\ Scripting\ Host :cal SetSyn("wsh")<CR>
an 50.170.240 &Syntax.WXYZ.WSML :cal SetSyn("wsml")<CR>
an 50.170.250 &Syntax.WXYZ.WvDial :cal SetSyn("wvdial")<CR>
an 50.170.270 &Syntax.WXYZ.X\ Keyboard\ Extension :cal SetSyn("xkb")<CR>
an 50.170.280 &Syntax.WXYZ.X\ Pixmap :cal SetSyn("xpm")<CR>
an 50.170.290 &Syntax.WXYZ.X\ Pixmap\ (2) :cal SetSyn("xpm2")<CR>
an 50.170.300 &Syntax.WXYZ.X\ resources :cal SetSyn("xdefaults")<CR>
an 50.170.310 &Syntax.WXYZ.XBL :cal SetSyn("xbl")<CR>
an 50.170.320 &Syntax.WXYZ.Xinetd\.conf :cal SetSyn("xinetd")<CR>
an 50.170.330 &Syntax.WXYZ.Xmodmap :cal SetSyn("xmodmap")<CR>
an 50.170.340 &Syntax.WXYZ.Xmath :cal SetSyn("xmath")<CR>
an 50.170.350 &Syntax.WXYZ.XML :cal SetSyn("xml")<CR>
an 50.170.360 &Syntax.WXYZ.XML\ Schema\ (XSD) :cal SetSyn("xsd")<CR>
an 50.170.370 &Syntax.WXYZ.XQuery :cal SetSyn("xquery")<CR>
an 50.170.380 &Syntax.WXYZ.Xslt :cal SetSyn("xslt")<CR>
an 50.170.390 &Syntax.WXYZ.XFree86\ Config :cal SetSyn("xf86conf")<CR>
an 50.170.410 &Syntax.WXYZ.YAML :cal SetSyn("yaml")<CR>
an 50.170.420 &Syntax.WXYZ.Yacc :cal SetSyn("yacc")<CR>
an 50.170.440 &Syntax.WXYZ.Zimbu :cal SetSyn("zimbu")<CR>

" The End Of The Syntax Menu


an 50.195 &Syntax.-SEP1-			<Nop>

an <silent> 50.200 &Syntax.Set\ '&syntax'\ Only :call <SID>Setsynonly()<CR>
fun s:Setsynonly()
  let s:syntax_menu_synonly = 1
endfun
an <silent> 50.202 &Syntax.Set\ '&filetype'\ Too :call <SID>Nosynonly()<CR>
fun s:Nosynonly()
  if exists("s:syntax_menu_synonly")
    unlet s:syntax_menu_synonly
  endif
endfun

" Restore 'cpoptions'
let &cpo = s:cpo_save
unlet s:cpo_save
                        usr/share/vim/vim90/syntax/                                                                         0000755 0000000 0000000 00000000000 14723046434 014253  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/vim/vim90/syntax/2html.vim                                                                0000644 0000000 0000000 00000223664 14424703754 016036  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim syntax support file
" Maintainer: Ben Fritz <fritzophrenic@gmail.com>
" Last Change: 2023 Jan 01
"
" Additional contributors:
"
"             Original by Bram Moolenaar <Bram@vim.org>
"             Modified by David Ne\v{c}as (Yeti) <yeti@physics.muni.cz>
"             XHTML support by Panagiotis Issaris <takis@lumumba.luc.ac.be>
"             Made w3 compliant by Edd Barrett <vext01@gmail.com>
"             Added html_font. Edd Barrett <vext01@gmail.com>
"             Progress bar based off code from "progressbar widget" plugin by
"               Andreas Politz, heavily modified:
"               http://www.vim.org/scripts/script.php?script_id=2006
"
"             See Mercurial change logs for more!

" Transform a file into HTML, using the current syntax highlighting.

" this file uses line continuations
let s:cpo_sav = &cpo
let s:ls  = &ls
let s:ei_sav = &eventignore
set cpo&vim

" HTML filetype can take a while to load/highlight if the destination file
" already exists.
set eventignore+=FileType

let s:end=line('$')

" Font
if exists("g:html_font")
  if type(g:html_font) == type([])
    let s:htmlfont = "'". join(g:html_font,"','") . "', monospace"
  else
    let s:htmlfont = "'". g:html_font . "', monospace"
  endif
else
  let s:htmlfont = "monospace"
endif

let s:settings = tohtml#GetUserSettings()

if s:settings.use_xhtml
  let s:html5 = 0
elseif s:settings.use_css && !s:settings.no_pre
  let s:html5 = 1
else
  let s:html5 = 0
endif

if !exists('s:FOLDED_ID')
  let s:FOLDED_ID  = hlID("Folded")     | lockvar s:FOLDED_ID
  let s:FOLD_C_ID  = hlID("FoldColumn") | lockvar s:FOLD_C_ID
  let s:LINENR_ID  = hlID('LineNr')     | lockvar s:LINENR_ID
  let s:DIFF_D_ID  = hlID("DiffDelete") | lockvar s:DIFF_D_ID
  let s:DIFF_A_ID  = hlID("DiffAdd")    | lockvar s:DIFF_A_ID
  let s:DIFF_C_ID  = hlID("DiffChange") | lockvar s:DIFF_C_ID
  let s:DIFF_T_ID  = hlID("DiffText")   | lockvar s:DIFF_T_ID
  let s:CONCEAL_ID = hlID('Conceal')    | lockvar s:CONCEAL_ID
endif

" Whitespace
if s:settings.pre_wrap
  let s:whitespace = "white-space: pre-wrap; "
else
  let s:whitespace = ""
endif

if !empty(s:settings.prevent_copy)
  if s:settings.no_invalid
    " User has decided they don't want invalid markup. Still works in
    " OpenOffice, and for text editors, but when pasting into Microsoft Word the
    " input elements get pasted too and they cannot be deleted (at least not
    " easily).
    let s:unselInputType = ""
  else
    " Prevent from copy-pasting the input elements into Microsoft Word where
    " they cannot be deleted easily by deliberately inserting invalid markup.
    let s:unselInputType = " type='invalid_input_type'"
  endif
endif

" When gui colors are not supported, we can only guess the colors.
" TODO - is this true anymore? Is there a way to ask the terminal what colors
" each number means or read them from some file?
if &termguicolors || has("gui_running")
  let s:whatterm = "gui"
else
  let s:whatterm = "cterm"
  if &t_Co == 8
    let s:cterm_color = {
	    \   0: "#808080", 1: "#ff6060", 2: "#00ff00", 3: "#ffff00",
	    \   4: "#8080ff", 5: "#ff40ff", 6: "#00ffff", 7: "#ffffff"
	    \ }
  else
    let s:cterm_color = {
	    \   0: "#000000", 1: "#c00000", 2: "#008000", 3: "#804000", 
	    \   4: "#0000c0", 5: "#c000c0", 6: "#008080", 7: "#c0c0c0", 
	    \   8: "#808080", 9: "#ff6060", 10: "#00ff00", 11: "#ffff00",
	    \   12: "#8080ff", 13: "#ff40ff", 14: "#00ffff", 15: "#ffffff"
	    \ }

    " Colors for 88 and 256 come from xterm.
    if &t_Co == 88
      call extend(s:cterm_color, {
	    \   16: "#000000", 17: "#00008b", 18: "#0000cd", 19: "#0000ff",
	    \   20: "#008b00", 21: "#008b8b", 22: "#008bcd", 23: "#008bff",
	    \   24: "#00cd00", 25: "#00cd8b", 26: "#00cdcd", 27: "#00cdff",
	    \   28: "#00ff00", 29: "#00ff8b", 30: "#00ffcd", 31: "#00ffff",
	    \   32: "#8b0000", 33: "#8b008b", 34: "#8b00cd", 35: "#8b00ff",
	    \   36: "#8b8b00", 37: "#8b8b8b", 38: "#8b8bcd", 39: "#8b8bff",
	    \   40: "#8bcd00", 41: "#8bcd8b", 42: "#8bcdcd", 43: "#8bcdff",
	    \   44: "#8bff00", 45: "#8bff8b", 46: "#8bffcd", 47: "#8bffff",
	    \   48: "#cd0000", 49: "#cd008b", 50: "#cd00cd", 51: "#cd00ff",
	    \   52: "#cd8b00", 53: "#cd8b8b", 54: "#cd8bcd", 55: "#cd8bff",
	    \   56: "#cdcd00", 57: "#cdcd8b", 58: "#cdcdcd", 59: "#cdcdff",
	    \   60: "#cdff00", 61: "#cdff8b", 62: "#cdffcd", 63: "#cdffff",
	    \   64: "#ff0000"
	    \ })
      call extend(s:cterm_color, {
	    \   65: "#ff008b", 66: "#ff00cd", 67: "#ff00ff", 68: "#ff8b00",
	    \   69: "#ff8b8b", 70: "#ff8bcd", 71: "#ff8bff", 72: "#ffcd00",
	    \   73: "#ffcd8b", 74: "#ffcdcd", 75: "#ffcdff", 76: "#ffff00",
	    \   77: "#ffff8b", 78: "#ffffcd", 79: "#ffffff", 80: "#2e2e2e",
	    \   81: "#5c5c5c", 82: "#737373", 83: "#8b8b8b", 84: "#a2a2a2",
	    \   85: "#b9b9b9", 86: "#d0d0d0", 87: "#e7e7e7"
	    \ })
    elseif &t_Co == 256
      call extend(s:cterm_color, {
	    \   16: "#000000", 17: "#00005f", 18: "#000087", 19: "#0000af",
	    \   20: "#0000d7", 21: "#0000ff", 22: "#005f00", 23: "#005f5f",
	    \   24: "#005f87", 25: "#005faf", 26: "#005fd7", 27: "#005fff",
	    \   28: "#008700", 29: "#00875f", 30: "#008787", 31: "#0087af",
	    \   32: "#0087d7", 33: "#0087ff", 34: "#00af00", 35: "#00af5f",
	    \   36: "#00af87", 37: "#00afaf", 38: "#00afd7", 39: "#00afff",
	    \   40: "#00d700", 41: "#00d75f", 42: "#00d787", 43: "#00d7af",
	    \   44: "#00d7d7", 45: "#00d7ff", 46: "#00ff00", 47: "#00ff5f",
	    \   48: "#00ff87", 49: "#00ffaf", 50: "#00ffd7", 51: "#00ffff",
	    \   52: "#5f0000", 53: "#5f005f", 54: "#5f0087", 55: "#5f00af",
	    \   56: "#5f00d7", 57: "#5f00ff", 58: "#5f5f00", 59: "#5f5f5f",
	    \   60: "#5f5f87", 61: "#5f5faf", 62: "#5f5fd7", 63: "#5f5fff",
	    \   64: "#5f8700"
	    \ })
      call extend(s:cterm_color, {
	    \   65: "#5f875f", 66: "#5f8787", 67: "#5f87af", 68: "#5f87d7",
	    \   69: "#5f87ff", 70: "#5faf00", 71: "#5faf5f", 72: "#5faf87",
	    \   73: "#5fafaf", 74: "#5fafd7", 75: "#5fafff", 76: "#5fd700",
	    \   77: "#5fd75f", 78: "#5fd787", 79: "#5fd7af", 80: "#5fd7d7",
	    \   81: "#5fd7ff", 82: "#5fff00", 83: "#5fff5f", 84: "#5fff87",
	    \   85: "#5fffaf", 86: "#5fffd7", 87: "#5fffff", 88: "#870000",
	    \   89: "#87005f", 90: "#870087", 91: "#8700af", 92: "#8700d7",
	    \   93: "#8700ff", 94: "#875f00", 95: "#875f5f", 96: "#875f87",
	    \   97: "#875faf", 98: "#875fd7", 99: "#875fff", 100: "#878700",
	    \   101: "#87875f", 102: "#878787", 103: "#8787af", 104: "#8787d7",
	    \   105: "#8787ff", 106: "#87af00", 107: "#87af5f", 108: "#87af87",
	    \   109: "#87afaf", 110: "#87afd7", 111: "#87afff", 112: "#87d700"
	    \ })
      call extend(s:cterm_color, {
	    \   113: "#87d75f", 114: "#87d787", 115: "#87d7af", 116: "#87d7d7",
	    \   117: "#87d7ff", 118: "#87ff00", 119: "#87ff5f", 120: "#87ff87",
	    \   121: "#87ffaf", 122: "#87ffd7", 123: "#87ffff", 124: "#af0000",
	    \   125: "#af005f", 126: "#af0087", 127: "#af00af", 128: "#af00d7",
	    \   129: "#af00ff", 130: "#af5f00", 131: "#af5f5f", 132: "#af5f87",
	    \   133: "#af5faf", 134: "#af5fd7", 135: "#af5fff", 136: "#af8700",
	    \   137: "#af875f", 138: "#af8787", 139: "#af87af", 140: "#af87d7",
	    \   141: "#af87ff", 142: "#afaf00", 143: "#afaf5f", 144: "#afaf87",
	    \   145: "#afafaf", 146: "#afafd7", 147: "#afafff", 148: "#afd700",
	    \   149: "#afd75f", 150: "#afd787", 151: "#afd7af", 152: "#afd7d7",
	    \   153: "#afd7ff", 154: "#afff00", 155: "#afff5f", 156: "#afff87",
	    \   157: "#afffaf", 158: "#afffd7"
	    \ })
      call extend(s:cterm_color, {
	    \   159: "#afffff", 160: "#d70000", 161: "#d7005f", 162: "#d70087",
	    \   163: "#d700af", 164: "#d700d7", 165: "#d700ff", 166: "#d75f00",
	    \   167: "#d75f5f", 168: "#d75f87", 169: "#d75faf", 170: "#d75fd7",
	    \   171: "#d75fff", 172: "#d78700", 173: "#d7875f", 174: "#d78787",
	    \   175: "#d787af", 176: "#d787d7", 177: "#d787ff", 178: "#d7af00",
	    \   179: "#d7af5f", 180: "#d7af87", 181: "#d7afaf", 182: "#d7afd7",
	    \   183: "#d7afff", 184: "#d7d700", 185: "#d7d75f", 186: "#d7d787",
	    \   187: "#d7d7af", 188: "#d7d7d7", 189: "#d7d7ff", 190: "#d7ff00",
	    \   191: "#d7ff5f", 192: "#d7ff87", 193: "#d7ffaf", 194: "#d7ffd7",
	    \   195: "#d7ffff", 196: "#ff0000", 197: "#ff005f", 198: "#ff0087",
	    \   199: "#ff00af", 200: "#ff00d7", 201: "#ff00ff", 202: "#ff5f00",
	    \   203: "#ff5f5f", 204: "#ff5f87"
	    \ })
      call extend(s:cterm_color, {
	    \   205: "#ff5faf", 206: "#ff5fd7", 207: "#ff5fff", 208: "#ff8700",
	    \   209: "#ff875f", 210: "#ff8787", 211: "#ff87af", 212: "#ff87d7",
	    \   213: "#ff87ff", 214: "#ffaf00", 215: "#ffaf5f", 216: "#ffaf87",
	    \   217: "#ffafaf", 218: "#ffafd7", 219: "#ffafff", 220: "#ffd700",
	    \   221: "#ffd75f", 222: "#ffd787", 223: "#ffd7af", 224: "#ffd7d7",
	    \   225: "#ffd7ff", 226: "#ffff00", 227: "#ffff5f", 228: "#ffff87",
	    \   229: "#ffffaf", 230: "#ffffd7", 231: "#ffffff", 232: "#080808",
	    \   233: "#121212", 234: "#1c1c1c", 235: "#262626", 236: "#303030",
	    \   237: "#3a3a3a", 238: "#444444", 239: "#4e4e4e", 240: "#585858",
	    \   241: "#626262", 242: "#6c6c6c", 243: "#767676", 244: "#808080",
	    \   245: "#8a8a8a", 246: "#949494", 247: "#9e9e9e", 248: "#a8a8a8",
	    \   249: "#b2b2b2", 250: "#bcbcbc", 251: "#c6c6c6", 252: "#d0d0d0",
	    \   253: "#dadada", 254: "#e4e4e4", 255: "#eeeeee"
	    \ })
    endif
  endif
endif

" Return good color specification: in GUI no transformation is done, in
" terminal return RGB values of known colors and empty string for unknown
if s:whatterm == "gui"
  function! s:HtmlColor(color)
    return a:color
  endfun
else
  function! s:HtmlColor(color)
    if has_key(s:cterm_color, a:color)
      return s:cterm_color[a:color]
    else
      return ""
    endif
  endfun
endif

" Find out the background and foreground color for use later
let s:fgc = s:HtmlColor(synIDattr(hlID("Normal"), "fg#", s:whatterm))
let s:bgc = s:HtmlColor(synIDattr(hlID("Normal"), "bg#", s:whatterm))
if s:fgc == ""
  let s:fgc = ( &background == "dark" ? "#ffffff" : "#000000" )
endif
if s:bgc == ""
  let s:bgc = ( &background == "dark" ? "#000000" : "#ffffff" )
endif

if !s:settings.use_css
  " Return opening HTML tag for given highlight id
  function! s:HtmlOpening(id, extra_attrs)
    let a = ""
    if synIDattr(a:id, "inverse")
      " For inverse, we always must set both colors (and exchange them)
      let x = s:HtmlColor(synIDattr(a:id, "fg#", s:whatterm))
      let a = a . '<span '.a:extra_attrs.'style="background-color: ' . ( x != "" ? x : s:fgc ) . '">'
      let x = s:HtmlColor(synIDattr(a:id, "bg#", s:whatterm))
      let a = a . '<font color="' . ( x != "" ? x : s:bgc ) . '">'
    else
      let x = s:HtmlColor(synIDattr(a:id, "bg#", s:whatterm))
      if x != ""
	let a = a . '<span '.a:extra_attrs.'style="background-color: ' . x . '">'
      elseif !empty(a:extra_attrs)
	let a = a . '<span '.a:extra_attrs.'>'
      endif
      let x = s:HtmlColor(synIDattr(a:id, "fg#", s:whatterm))
      if x != "" | let a = a . '<font color="' . x . '">' | endif
    endif
    if synIDattr(a:id, "bold") | let a = a . "<b>" | endif
    if synIDattr(a:id, "italic") | let a = a . "<i>" | endif
    if synIDattr(a:id, "underline") | let a = a . "<u>" | endif
    return a
  endfun

  " Return closing HTML tag for given highlight id
  function! s:HtmlClosing(id, has_extra_attrs)
    let a = ""
    if synIDattr(a:id, "underline") | let a = a . "</u>" | endif
    if synIDattr(a:id, "italic") | let a = a . "</i>" | endif
    if synIDattr(a:id, "bold") | let a = a . "</b>" | endif
    if synIDattr(a:id, "inverse")
      let a = a . '</font></span>'
    else
      let x = s:HtmlColor(synIDattr(a:id, "fg#", s:whatterm))
      if x != "" | let a = a . '</font>' | endif
      let x = s:HtmlColor(synIDattr(a:id, "bg#", s:whatterm))
      if x != "" || a:has_extra_attrs | let a = a . '</span>' | endif
    endif
    return a
  endfun
endif

" Use a different function for formatting based on user options. This way we
" can avoid a lot of logic during the actual execution.
"
" Build the function line by line containing only what is needed for the options
" in use for maximum code sharing with minimal branch logic for greater speed.
"
" Note, 'exec' commands do not recognize line continuations, so must concatenate
" lines rather than continue them.
if s:settings.use_css
  " save CSS to a list of rules to add to the output at the end of processing

  " first, get the style names we need
  let wrapperfunc_lines = [
	\ 'function! s:BuildStyleWrapper(style_id, diff_style_id, extra_attrs, text, make_unselectable, unformatted)',
	\ '',
	\ '  let l:style_name = synIDattr(a:style_id, "name", s:whatterm)'
	\ ]
  if &diff
    let wrapperfunc_lines += [
	\ '  let l:diff_style_name = synIDattr(a:diff_style_id, "name", s:whatterm)']

  " Add normal groups and diff groups to separate lists so we can order them to
  " allow diff highlight to override normal highlight

  " if primary style IS a diff style, grab it from the diff cache instead
  " (always succeeds because we pre-populate it)
  let wrapperfunc_lines += [
	\ '',
	\ '  if a:style_id == s:DIFF_D_ID || a:style_id == s:DIFF_A_ID ||'.
	\ '          a:style_id == s:DIFF_C_ID || a:style_id == s:DIFF_T_ID',
	\ '    let l:saved_style = get(s:diffstylelist,a:style_id)',
	\ '  else'
	\ ]
  endif

  " get primary style info from cache or build it on the fly if not found
  let wrapperfunc_lines += [
	\ '    let l:saved_style = get(s:stylelist,a:style_id)',
	\ '    if type(l:saved_style) == type(0)',
	\ '      unlet l:saved_style',
	\ '      let l:saved_style = s:CSS1(a:style_id)',
	\ '      if l:saved_style != ""',
	\ '        let l:saved_style = "." . l:style_name . " { " . l:saved_style . "}"',
	\ '      endif',
	\ '      let s:stylelist[a:style_id]= l:saved_style',
	\ '    endif'
	\ ]
  if &diff
    let wrapperfunc_lines += [ '  endif' ]
  endif

  " Build the wrapper tags around the text. It turns out that caching these
  " gives pretty much zero performance gain and adds a lot of logic.

  let wrapperfunc_lines += [
	\ '',
	\ '  if l:saved_style == "" && empty(a:extra_attrs)'
	\ ]
  if &diff
    let wrapperfunc_lines += [
	\ '    if a:diff_style_id <= 0'
	\ ]
  endif
  " no surroundings if neither primary nor diff style has any info
  let wrapperfunc_lines += [
	\ '       return a:text'
	\ ]
  if &diff
    " no primary style, but diff style
    let wrapperfunc_lines += [
	\ '     else',
	\ '       return "<span class=\"" .l:diff_style_name . "\">".a:text."</span>"',
	\ '     endif'
	\ ]
  endif
  " open tag for non-empty primary style
  let wrapperfunc_lines += [
	\ '  else']
  " non-empty primary style. handle either empty or non-empty diff style.
  "
  " separate the two classes by a space to apply them both if there is a diff
  " style name, unless the primary style is empty, then just use the diff style
  " name
  let diffstyle =
	  \ (&diff ? '(a:diff_style_id <= 0 ? "" : " ". l:diff_style_name) .'
	  \        : "")
  if s:settings.prevent_copy == ""
    let wrapperfunc_lines += [
	  \ '    return "<span ".a:extra_attrs."class=\"" . l:style_name .'.diffstyle.'"\">".a:text."</span>"'
	  \ ]
  else

    " New method: use generated content in the CSS. The only thing needed here
    " is a span with no content, with an attribute holding the desired text.
    "
    " Old method: use an <input> element when text is unsectable. This is still
    " used in conditional comments for Internet Explorer, where the new method
    " doesn't work.
    "
    " Wrap the <input> in a <span> to allow fixing the stupid bug in some fonts
    " which cause browsers to display a 1px gap between lines when these
    " <input>s have a background color (maybe not really a bug, this isn't
    " well-defined)
    "
    " use strwidth, because we care only about how many character boxes are
    " needed to size the input, we don't care how many characters (including
    " separately counted composing chars, from strchars()) or bytes (from
    " len())the string contains. strdisplaywidth() is not needed because none of
    " the unselectable groups can contain tab characters (fold column, fold
    " text, line number).
    "
    " Note, if maxlength property needs to be added in the future, it will need
    " to use strchars(), because HTML specifies that the maxlength parameter
    " uses the number of unique codepoints for its limit.
    let wrapperfunc_lines += [
	  \   '    if a:make_unselectable',
	  \   '      return "<span ".a:extra_attrs."class=\"" . l:style_name .'.diffstyle.'"\"'
	  \ ]
    if s:settings.use_input_for_pc !=# 'all'
      let wrapperfunc_lines[-1] .= ' " . "data-" . l:style_name . "-content=\"".a:text."\"'
    endif
    let wrapperfunc_lines[-1] .= '>'
    if s:settings.use_input_for_pc !=# 'none'
      let wrapperfunc_lines[-1] .=
	    \                '<input'.s:unselInputType.' class=\"" . l:style_name .'.diffstyle.'"\"'.
	    \                 ' value=\"".substitute(a:unformatted,''\s\+$'',"","")."\"'.
	    \                 ' onselect=''this.blur(); return false;'''.
	    \                 ' onmousedown=''this.blur(); return false;'''.
	    \                 ' onclick=''this.blur(); return false;'''.
	    \                 ' readonly=''readonly'''.
	    \                 ' size=\"".strwidth(a:unformatted)."\"'.
	    \                 (s:settings.use_xhtml ? '/' : '').'>'
    endif
    let wrapperfunc_lines[-1] .= '</span>"'
    let wrapperfunc_lines += [
	  \ '    else',
	  \ '      return "<span ".a:extra_attrs."class=\"" . l:style_name .'. diffstyle .'"\">".a:text."</span>"'
	  \ ]
  endif
  let wrapperfunc_lines += [
	\ '  endif',
	\ 'endfun'
	\ ]
else
  " Non-CSS method just needs the wrapper.
  "
  " Functions used to get opening/closing automatically return null strings if
  " no styles exist.
  if &diff
    let wrapperfunc_lines = [
	  \ 'function! s:BuildStyleWrapper(style_id, diff_style_id, extra_attrs, text, unusedarg, unusedarg2)',
	  \ '  return s:HtmlOpening(a:style_id, a:extra_attrs).(a:diff_style_id <= 0 ? "" :'.
	  \                                     's:HtmlOpening(a:diff_style_id, "")).a:text.'.
	  \   '(a:diff_style_id <= 0 ? "" : s:HtmlClosing(a:diff_style_id, 0)).s:HtmlClosing(a:style_id, !empty(a:extra_attrs))',
	  \ 'endfun'
	  \ ]
  else
    let wrapperfunc_lines = [
	  \ 'function! s:BuildStyleWrapper(style_id, diff_style_id, extra_attrs, text, unusedarg, unusedarg2)',
	  \ '  return s:HtmlOpening(a:style_id, a:extra_attrs).a:text.s:HtmlClosing(a:style_id, !empty(a:extra_attrs))',
	  \ 'endfun'
	  \ ]
  endif
endif

" create the function we built line by line above
exec join(wrapperfunc_lines, "\n")

let s:diff_mode = &diff

" Return HTML valid characters enclosed in a span of class style_name with
" unprintable characters expanded and double spaces replaced as necessary.
"
" TODO: eliminate unneeded logic like done for BuildStyleWrapper
function! s:HtmlFormat(text, style_id, diff_style_id, extra_attrs, make_unselectable)
  " Replace unprintable characters
  let unformatted = strtrans(a:text)

  let formatted = unformatted

  " Replace the reserved html characters
  let formatted = substitute(formatted, '&', '\&amp;',  'g')
  let formatted = substitute(formatted, '<', '\&lt;',   'g')
  let formatted = substitute(formatted, '>', '\&gt;',   'g')
  let formatted = substitute(formatted, '"', '\&quot;', 'g')
  " &apos; is not valid in HTML but it is in XHTML, so just use the numeric
  " reference for it instead. Needed because it could appear in quotes
  " especially if unselectable regions is turned on.
  let formatted = substitute(formatted, '"', '\&#0039;', 'g')

  " Replace a "form feed" character with HTML to do a page break
  " TODO: need to prevent this in unselectable areas? Probably it should never
  " BE in an unselectable area...
  let formatted = substitute(formatted, "\x0c", '<hr class="PAGE-BREAK">', 'g')

  " Replace double spaces, leading spaces, and trailing spaces if needed
  if ' ' != s:HtmlSpace
    let formatted = substitute(formatted, '  ', s:HtmlSpace . s:HtmlSpace, 'g')
    let formatted = substitute(formatted, '^ ', s:HtmlSpace, 'g')
    let formatted = substitute(formatted, ' \+$', s:HtmlSpace, 'g')
  endif

  " Enclose in the correct format
  return s:BuildStyleWrapper(a:style_id, a:diff_style_id, a:extra_attrs, formatted, a:make_unselectable, unformatted)
endfun

" set up functions to call HtmlFormat in certain ways based on whether the
" element is supposed to be unselectable or not
if s:settings.prevent_copy =~# 'n'
  if s:settings.number_lines
    if s:settings.line_ids
      function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)
	if a:lnr > 0
	  return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, 'id="'.(exists('g:html_diff_win_num') ? 'W'.g:html_diff_win_num : "").'L'.a:lnr.s:settings.id_suffix.'" ', 1)
	else
	  return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, "", 1)
	endif
      endfun
    else
      function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)
	return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, "", 1)
      endfun
    endif
  elseif s:settings.line_ids
    " if lines are not being numbered the only reason this function gets called
    " is to put the line IDs on each line; "text" will be empty but lnr will
    " always be non-zero, however we don't want to use the <input> because that
    " won't work as nice for empty text
    function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)
      return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, 'id="'.(exists('g:html_diff_win_num') ? 'W'.g:html_diff_win_num : "").'L'.a:lnr.s:settings.id_suffix.'" ', 0)
    endfun
  endif
else
  if s:settings.line_ids
    function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)
      if a:lnr > 0
	return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, 'id="'.(exists('g:html_diff_win_num') ? 'W'.g:html_diff_win_num : "").'L'.a:lnr.s:settings.id_suffix.'" ', 0)
      else
	return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, "", 0)
      endif
    endfun
  else
    function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)
      return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, "", 0)
    endfun
  endif
endif
if s:settings.prevent_copy =~# 'd'
  function! s:HtmlFormat_d(text, style_id, diff_style_id)
    return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, "", 1)
  endfun
else
  function! s:HtmlFormat_d(text, style_id, diff_style_id)
    return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, "", 0)
  endfun
endif
if s:settings.prevent_copy =~# 'f'
  if s:settings.use_input_for_pc ==# 'none'
    " Simply space-pad to the desired width inside the generated content (note
    " that the FoldColumn definition includes a whitespace:pre rule)
    function! s:FoldColumn_build(char, len, numfill, char2, class, click)
      return "<a href='#' class='".a:class."' onclick='".a:click."' data-FoldColumn-content='".
	    \ repeat(a:char, a:len).a:char2.repeat(' ', a:numfill).
	    \ "'></a>"
    endfun
    function! s:FoldColumn_fill()
      return s:HtmlFormat(repeat(' ', s:foldcolumn), s:FOLD_C_ID, 0, "", 1)
    endfun
  else
    " Note the <input> elements for fill spaces will have a single space for
    " content, to allow active cursor CSS selection to work.
    "
    " Wrap the whole thing in a span for the 1px padding workaround for gaps.
    "
    " Build the function line by line containing only what is needed for the
    " options in use for maximum code sharing with minimal branch logic for
    " greater speed.
    "
    " Note, 'exec' commands do not recognize line continuations, so must
    " concatenate lines rather than continue them.
    let build_fun_lines = [
	  \ 'function! s:FoldColumn_build(char, len, numfill, char2, class, click)',
	  \ '  let l:input_open = "<input readonly=''readonly''".s:unselInputType.'.
	  \ '          " onselect=''this.blur(); return false;''".'.
	  \ '          " onmousedown=''this.blur(); ".a:click." return false;''".'.
	  \ '          " onclick=''return false;'' size=''".'.
	  \ '          string(a:len + (empty(a:char2) ? 0 : 1) + a:numfill) .'.
	  \ '          "'' "',
	  \ '  let l:common_attrs = "class=''FoldColumn'' value=''"',
	  \ '  let l:input_close = (s:settings.use_xhtml ? "'' />" : "''>")'
	  \ ]
    if s:settings.use_input_for_pc ==# 'fallback'
      let build_fun_lines += [
	    \ '  let l:gen_content_link ='.
	    \ '          "<a href=''#'' class=''FoldColumn'' onclick=''".a:click."'' data-FoldColumn-content=''".'.
	    \ '          repeat(a:char, a:len).a:char2.repeat('' '', a:numfill).'.
	    \ '          "''></a>"'
	    \ ]
    endif
    let build_fun_lines += [
	  \ '  return "<span class=''".a:class."''>".'.
	  \ '          l:input_open.l:common_attrs.repeat(a:char, a:len).(a:char2).'.
	  \ '          l:input_close.'.
	  \ (s:settings.use_input_for_pc ==# 'fallback' ? 'l:gen_content_link.' : "").
	  \ '          "</span>"',
	  \ 'endfun'
	  \ ]
    " create the function we built line by line above
    exec join(build_fun_lines, "\n")

    function! s:FoldColumn_fill()
      return s:FoldColumn_build(' ', s:foldcolumn, 0, '', 'FoldColumn', '')
    endfun
  endif
else
  " For normal fold columns, simply space-pad to the desired width (note that
  " the FoldColumn definition includes a whitespace:pre rule)
  function! s:FoldColumn_build(char, len, numfill, char2, class, click)
    return "<a href='#' class='".a:class."' onclick='".a:click."'>".
	  \ repeat(a:char, a:len).a:char2.repeat(' ', a:numfill).
	  \ "</a>"
  endfun
  function! s:FoldColumn_fill()
    return s:HtmlFormat(repeat(' ', s:foldcolumn), s:FOLD_C_ID, 0, "", 0)
  endfun
endif
if s:settings.prevent_copy =~# 't'
  " put an extra empty span at the end for dynamic folds, so the linebreak can
  " be surrounded. Otherwise do it as normal.
  "
  " TODO: isn't there a better way to do this, than placing it here and using a
  " substitute later?
  if s:settings.dynamic_folds
    function! s:HtmlFormat_t(text, style_id, diff_style_id)
      return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, "", 1) .
	    \ s:HtmlFormat("", a:style_id, 0, "", 0)
    endfun
  else
    function! s:HtmlFormat_t(text, style_id, diff_style_id)
      return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, "", 1)
    endfun
  endif
else
  function! s:HtmlFormat_t(text, style_id, diff_style_id)
    return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, "", 0)
  endfun
endif

" Return CSS style describing given highlight id (can be empty)
function! s:CSS1(id)
  let a = ""
  if synIDattr(a:id, "inverse")
    " For inverse, we always must set both colors (and exchange them)
    let x = s:HtmlColor(synIDattr(a:id, "bg#", s:whatterm))
    let a = a . "color: " . ( x != "" ? x : s:bgc ) . "; "
    let x = s:HtmlColor(synIDattr(a:id, "fg#", s:whatterm))
    let a = a . "background-color: " . ( x != "" ? x : s:fgc ) . "; "
  else
    let x = s:HtmlColor(synIDattr(a:id, "fg#", s:whatterm))
    if x != "" | let a = a . "color: " . x . "; " | endif
    let x = s:HtmlColor(synIDattr(a:id, "bg#", s:whatterm))
    if x != ""
      let a = a . "background-color: " . x . "; "
      " stupid hack because almost every browser seems to have at least one font
      " which shows 1px gaps between lines which have background
      let a = a . "padding-bottom: 1px; "
    elseif (a:id == s:FOLDED_ID || a:id == s:LINENR_ID || a:id == s:FOLD_C_ID) && !empty(s:settings.prevent_copy)
      " input elements default to a different color than the rest of the page
      let a = a . "background-color: " . s:bgc . "; "
    endif
  endif
  if synIDattr(a:id, "bold") | let a = a . "font-weight: bold; " | endif
  if synIDattr(a:id, "italic") | let a = a . "font-style: italic; " | endif
  if synIDattr(a:id, "underline") | let a = a . "text-decoration: underline; " | endif
  return a
endfun

if s:settings.dynamic_folds
  " compares two folds as stored in our list of folds
  " A fold is "less" than another if it starts at an earlier line number,
  " or ends at a later line number, ties broken by fold level
