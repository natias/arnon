        result = Version(self)
        if self.minor is None:
            result.major -= int(other)
            new = result.major
        else:
            result.minor -= int(other)
            new = result.minor
        if new < 0:
            raise ValueError('cannot decrease version further')
        return result

    def __eq__(self, other):
        return self.__cmp(other) == 0

    def __lt__(self, other):
        return self.__cmp(other) < 0

    def __le__(self, other):
        return self.__cmp(other) <= 0

    def __gt__(self, other):
        return self.__cmp(other) > 0

    def __ge__(self, other):
        return self.__cmp(other) >= 0

    def __lshift__(self, other):
        """Compare major.minor or major only (if minor is not set).

        >>> Version('2.6') << Version('2.7')
        True
        >>> Version('2.6') << Version('2.6.6')
        False
        >>> Version('3') << Version('2')
        False
        >>> Version('3.1') << Version('2')
        False
        >>> Version('2') << Version('3.2.1.alpha.3')
        True
        """
        if not isinstance(other, Version):
            other = Version(other)
        if self.minor is None or other.minor is None:
            return self.__cmp(other, ignore='minor') < 0
        else:
            return self.__cmp(other, ignore='micro') < 0

    def __rshift__(self, other):
        """Compare major.minor or major only (if minor is not set).

        >>> Version('2.6') >> Version('2.7')
        False
        >>> Version('2.6.7') >> Version('2.6.6')
        False
        >>> Version('3') >> Version('2')
        True
        >>> Version('3.1') >> Version('2')
        True
        >>> Version('2.1') >> Version('3.2.1.alpha.3')
        False
        """
        if not isinstance(other, Version):
            other = Version(other)
        if self.minor is None or other.minor is None:
            return self.__cmp(other, ignore='minor') > 0
        else:
            return self.__cmp(other, ignore='micro') > 0

    def __cmp(self, other, ignore=None):
        if not isinstance(other, Version):
            other = Version(other)
        for name in ('major', 'minor', 'micro', 'releaselevel', 'serial'):
            if name == ignore:
                break
            value1 = getattr(self, name) or 0
            value2 = getattr(other, name) or 0
            if name == 'releaselevel':
                rmap = {'alpha': -3, 'beta': -2, 'candidate': -1, 'final': 0}
                value1 = rmap.get(value1, 0)
                value2 = rmap.get(value2, 0)
            if value1 == value2:
                continue
            return (value1 > value2) - (value1 < value2)
        return 0


def get_requested_versions(vrange=None, available=None):
    """Return a set of requested and supported Python versions.

    :param available: if set to `True`, return installed versions only,
        if set to `False`, return requested versions that are not installed.
        By default returns all requested versions.
    :type available: bool

    >>> sorted(get_requested_versions([(3, 0), None]))
    [(3, 2), (3, 3)]
    >>> sorted(get_requested_versions('')) == sorted(SUPPORTED)
    True
    >>> sorted(get_requested_versions([None, None])) == sorted(SUPPORTED)
    True
    >>> get_requested_versions([(5, 0), None]) == set()
    True
    """
    if isinstance(vrange, str):
        vrange = parse_vrange(vrange)

    if not vrange or list(vrange) == [None, None]:
        versions = set(SUPPORTED)
    else:
        minv = (0, 0) if vrange[0] is None else vrange[0]
        maxv = (99, 99) if vrange[1] is None else vrange[1]
        if minv == maxv:
            versions = set((minv,) if minv in SUPPORTED else tuple())
        else:
            versions = set(v for v in SUPPORTED if minv <= v < maxv)

    if available:
        versions = set(v for v in versions
                       if exists("/usr/bin/python%d.%d" % v))
    elif available is False:
        versions = set(v for v in versions
                       if not exists("/usr/bin/python%d.%d" % v))

    return versions


def parse_vrange(value):
    """Return minimum and maximum Python version from given range.

    >>> parse_vrange('3.0-')
    ((3, 0), None)
    >>> parse_vrange('3.1-3.3')
    ((3, 1), (3, 3))
    >>> parse_vrange('3.2-4.0')
    ((3, 2), (4, 0))
    >>> parse_vrange('-3.7')
    (None, (3, 7))
    >>> parse_vrange('3.2')
    ((3, 2), (3, 2))
    >>> parse_vrange('') == parse_vrange('-') == (None, None)
    True
    """
    if value in ('', '-'):
        return None, None

    match = RANGE_RE.match(value)
    if not match:
        raise ValueError("version range is invalid: %s" % value)
    groups = match.groups()

    if list(groups).count(None) == 3:  # only one version is allowed
        minv = tuple(int(i) for i in groups[1].split('.'))
        return minv, minv

    minv = maxv = None
    if groups[0]:  # maximum version only
        maxv = groups[1]
    else:
        minv = groups[1]
        maxv = groups[3]

    minv = tuple(int(i) for i in minv.split('.')) if minv else None
    maxv = tuple(int(i) for i in maxv.split('.')) if maxv else None

    if maxv and minv and minv > maxv:
        raise ValueError("version range is invalid: %s" % value)

    return minv, maxv


def parse_pycentral_vrange(value):
    """Parse X-Python3-Version.

    >>> parse_pycentral_vrange('>= 3.1')
    ((3, 1), None)
    >>> parse_pycentral_vrange('<< 4.0')
    (None, (4, 0))
    >>> parse_pycentral_vrange('3.1')
    ((3, 1), (3, 1))
    >>> parse_pycentral_vrange('3.1, 3.2')
    ((3, 1), None)
    """
    #get = lambda x: get_requested_versions(parse_vrange(x))

    minv = maxv = None
    hardcoded = set()

    for item in value.split(','):
        item = item.strip()

        match = re.match(r'>=\s*([\d\.]+)', item)
        if match:
            minv = "%.3s" % match.group(1)
            continue
        match = re.match(r'<<\s*([\d\.]+)', item)
        if match:
            maxv = "%.3s" % match.group(1)
            continue
        match = re.match(r'^[\d\.]+$', item)
        if match:
            hardcoded.add("%.3s" % match.group(0))

    if len(hardcoded) == 1:
        ver = hardcoded.pop()
        return getver(ver), getver(ver)

    if not minv and hardcoded:
        # yeah, no maxv!
        minv = sorted(hardcoded)[0]

    return getver(minv) if minv else None, getver(maxv) if maxv else None


def vrange_str(vrange):
    """Return version range string from given range.

    >>> vrange_str(((3, 4), None))
    '3.4-'
    >>> vrange_str(((3, 4), (3, 6)))
    '3.4-3.6'
    >>> vrange_str(((3, 4), (4, 0)))
    '3.4-4.0'
    >>> vrange_str((None, (3, 7)))
    '-3.7'
    >>> vrange_str(((3, 5), (3, 5)))
    '3.5'
    >>> vrange_str((None, None))
    '-'
    """
    if vrange[0] is vrange[1] is None:
        return '-'
    if vrange[0] == vrange[1]:
        return '.'.join(str(i) for i in vrange[0])
    elif vrange[0] is None:
        return '-' + '.'.join(str(i) for i in vrange[1])
    elif vrange[1] is None:
        return '.'.join(str(i) for i in vrange[0]) + '-'
    else:
        return "%s-%s" % ('.'.join(str(i) for i in vrange[0]),
                          '.'.join(str(i) for i in vrange[1]))


def vrepr(value):
    """
    >>> vrepr(([3, 4], [3, 2]))
    ['3.4', '3.2']
    >>> vrepr(('2.6', '3.1'))
    ['2.6', '3.1']
    >>> vrepr('3.2')
    '3.2'
    >>> vrepr((3, 2))
    '3.2'
    """
    if isinstance(value, str):
        return value
    elif not isinstance(value, (GeneratorType, set)) and isinstance(value[0], int):
        return '.'.join(str(i) for i in value)

    result = []
    for version in value:
        if isinstance(version, str):
            result.append(version)
        else:
            result.append('.'.join(str(i) for i in version))
    return result


def getver(value):
    """Return pair of integers that represent version.

    >>> getver('3.2')
    (3, 2)
    >>> getver('3.1.4')
    (3, 1)
    >>> getver((3, 3, 1))
    (3, 3)
    >>> getver(None)
    ''
    """
    if not value:
        return ''
    if isinstance(value, tuple):
        return value[:2]
    return tuple(int(i) for i in value.split('.', 2))[:2]


def debsorted(versions, return_str=None):
    """Return sorted list of versions starting with default Python
    version (if available) then list of suppored versions greater than default
    one followed by reversed list of older versions.

    List of versions sorted this way can be used in Depends field.

    :param vrepr: return string represenatations of versions, by default the
        same format is used as in :param:`versions`

    >>> debsorted([(2, 6), (3, 1), (3, 2), (3, 3), (2, 7)])[0] == DEFAULT
    True
    >>> debsorted(('2.4', '3.2', '2.6', '2.7'))[-1]
    (2, 4)
    >>> debsorted(set([(2, 1), (2, 2)]))
    [(2, 2), (2, 1)]
    >>> debsorted([(2, 1), (2, 2)], return_str=True)
    ['2.2', '2.1']
    """
    result = []
    old_versions = []
    for version in sorted(versions):
        if isinstance(version, str):
            version = getver(version)
        if version < DEFAULT:
            old_versions.append(version)
        else:
            result.append(version)
    result.extend(reversed(old_versions))
    if return_str and result:
        return vrepr(result)
    return result
                                                                               usr/share/python3/py3versions.py                                                                    0000755 0000000 0000000 00000031020 14414510722 015440  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #! /usr/bin/python3

import os
import re
import sys

_defaults = None
_old_versions = None
_unsupported_versions = None
_supported_versions = ["python%s" % ver.strip() for ver in
                       os.environ.get('DEBPYTHON3_SUPPORTED', '').split(',')
                       if ver.strip()]
#_default_version = "python%s" % os.environ.get('DEBPYTHON3_DEFAULT', '')
#if _default_version == 'python':
#    _default_version = None
_default_version = None


def read_default(name=None):
    global _defaults
    from configparser import ConfigParser, NoOptionError
    if not _defaults:
        if os.path.exists('/usr/share/python3/debian_defaults'):
            config = ConfigParser()
            defaultsfile = open('/usr/share/python3/debian_defaults')
            config.read_file(defaultsfile)
            defaultsfile.close()
            _defaults = config

    if _defaults and name:
        try:
            value = _defaults.get('DEFAULT', name)
        except NoOptionError:
            raise ValueError
        return value
    return None


def version_to_tuple(version):
    return tuple(int(part) for part in version.split('.'))


def parse_versions(vstring):
    if len(vstring.split(',')) > 2:
        raise ValueError('too many arguments provided for X-Python3-Version: min and max only.')
    import operator
    operators = {None: operator.eq, '=': operator.eq,
                 '>=': operator.ge, '<=': operator.le,
                 '<<': operator.lt}
    vinfo = {}
    exact_versions = set()
    version_range = set(supported_versions(version_only=True))
    relop_seen = False
    for field in vstring.split(','):
        field = field.strip()
        if field == 'all':
            continue
        if field in ('current', 'current_ext'):
            continue
        vinfo.setdefault('versions', set())
        ve = re.compile(r'(>=|<=|<<|=)? *(\d\.\d+)$')
        m = ve.match(field)
        try:
            if not m:
                raise ValueError('error parsing Python3-Version attribute')
            op, v = m.group(1), m.group(2)
            vmaj, vmin = v.split('.')
            if int(vmaj) < 3:
                continue
            if op in (None, '='):
                exact_versions.add(v)
            else:
                relop_seen = True
                filtop = operators[op]
                version_range = [av for av in version_range if filtop(
                    version_to_tuple(av), version_to_tuple(v))]
        except Exception:
            raise ValueError('error parsing Python3-Version attribute')
    if 'versions' in vinfo:
        vinfo['versions'] = exact_versions
        if relop_seen:
            vinfo['versions'] = exact_versions.union(version_range)
    return vinfo


def old_versions(version_only=False):
    global _old_versions
    if not _old_versions:
        try:
            value = read_default('old-versions')
            _old_versions = [s.strip() for s in value.split(',')]
        except ValueError:
            _old_versions = []
    if version_only:
        return [v[6:] for v in _old_versions]
    else:
        return _old_versions


def unsupported_versions(version_only=False):
    global _unsupported_versions
    if not _unsupported_versions:
        try:
            value = read_default('unsupported-versions')
            _unsupported_versions = [s.strip() for s in value.split(',')]
        except ValueError:
            _unsupported_versions = []
    if version_only:
        return [v[6:] for v in _unsupported_versions]
    else:
        return _unsupported_versions


def supported_versions(version_only=False):
    global _supported_versions,_default_version
    default_version()
    if not _supported_versions:
        try:
            value = read_default('supported-versions')
            _supported_versions = [s.strip() for s in value.split(',')]
        except ValueError:
            cmd = ['/usr/bin/apt-cache', '--no-all-versions',
                   'show', 'python3-all']
            try:
                import subprocess
                p = subprocess.Popen(cmd, bufsize=1,
                                     shell=False, stdout=subprocess.PIPE)
                fd = p.stdout
            except ImportError:
                fd = os.popen(' '.join(cmd))
            depends = None
            for line in fd:
                if line.startswith('Depends:'):
                    depends = line.split(':', 1)[1].strip().split(',')
            fd.close()
            depends = [re.sub(r'\s*(\S+)[ (]?.*', r'\1', s) for s in depends]
            _supported_versions = depends
    default = _supported_versions.pop(_supported_versions.index(_default_version))
    _supported_versions.sort()
    _supported_versions.append(default)
    if version_only:
        return [v[6:] for v in _supported_versions]
    else:
        return _supported_versions


def default_version(version_only=False):
    global _default_version
    if not _default_version:
        _default_version = os.readlink('/usr/bin/python3')
    # consistency check
    debian_default = read_default('default-version')
    if not _default_version in (debian_default, os.path.join('/usr/bin', debian_default)):
        raise ValueError("the symlink /usr/bin/python3 does not point to the "
                         "python3 default version. It must be reset "
                         "to point to %s" % debian_default)
    _default_version = debian_default
    if version_only:
        return _default_version[6:]
    else:
        return _default_version


def requested_versions(vstring, version_only=False):
    global _default_version
    default_version()
    versions = None
    vinfo = parse_versions(vstring)
    supported = supported_versions(version_only=True)
    if len(vinfo) == 1:
        versions = vinfo['versions'].intersection(supported)
        vl = []
        for version in versions: vl.append(version)
        try:
            default = vl.pop(vl.index(_default_version[6:]))
        except:
            default = ''
        vl.sort()
        if default:
            vl.append(default)
    else:
        raise ValueError('No supported python3 versions in version string')
    if not versions:
        raise ValueError('empty set of versions')
    if version_only:
        return vl
    else:
        return ['python%s' % v for v in vl]


def installed_versions(version_only=False):
    import glob
    supported = supported_versions()
    versions = [os.path.basename(s)
                for s in glob.glob('/usr/bin/python3.[0-9]') + glob.glob('/usr/bin/python3.[0-9][0-9]')
                if os.path.basename(s) in supported]
    versions.sort()
    if version_only:
        return [v[6:] for v in versions]
    else:
        return versions


def minmax_supported_version(minmax, version_only=False):
    supported_versions_list = supported_versions(True)
    version = minmax(version_to_tuple(ver) for ver in supported_versions_list)
    version_str = '%d.%d' % version
    if version_only:
        return version_str
    else:
        return 'python' + version_str


class ControlFileValueError(ValueError):
    pass


class MissingVersionValueError(ValueError):
    pass


def extract_pyversion_attribute(fn, pkg):
    """read the debian/control file, extract the X-Python3-Version
    field."""

    version = None
    sversion = None
    section = None
    with open(fn, encoding='utf-8') as controlfile:
        lines = [line.strip() for line in controlfile]
    for line in lines:
        if line == '' and section != None:
            if pkg == 'Source':
                break
            section = None
        elif line.startswith('Source:'):
            section = 'Source'
        elif line.startswith('Package: ' + pkg):
            section = pkg
        elif line.lower().startswith('x-python3-version:'):
            if section != 'Source':
                raise ValueError('attribute X-Python3-Version not in Source section')
            sversion = line.split(':', 1)[1].strip()
    if section is None:
        raise ControlFileValueError('not a control file')
    if pkg == 'Source':
        if sversion is None:
            raise MissingVersionValueError('no X-Python3-Version in control file')
        return sversion
    return version


'''
def requested_versions_bis(vstring, version_only=False):
    versions = []
    py_supported_short = supported_versions(version_only=True)
    for item in vstring.split(','):
        v=item.split('-')
        if len(v)>1:
            if not v[0]:
                v[0] = py_supported_short[0]
            if not v[1]:
                v[1] = py_supported_short[-1]
            for ver in py_supported_short:
                try:
                    if version_cmp(ver,v[0]) >= 0 \
                           and version_cmp(ver,v[1]) <= 0:
                        versions.append(ver)
                except ValueError:
                    pass
        else:
            if v[0] in py_supported_short:
                versions.append(v[0])
    versions.sort(version_cmp)
    if not versions:
        raise ValueError('empty set of versions')
    if not version_only:
        versions=['python'+i for i in versions]
    return versions
'''


def main():
    from optparse import OptionParser
    usage = '[-v] [-h] [-d|--default] [-s|--supported] [-i|--installed] '
    '[-r|--requested <version string>|<control file>]'
    parser = OptionParser(usage=usage)
    parser.add_option('-d', '--default',
                      help='print the default python3 version',
                      action='store_true', dest='default')
    parser.add_option('-s', '--supported',
                      help='print the supported python3 versions',
                      action='store_true', dest='supported')
    parser.add_option('-r', '--requested',
                      help='print the python3 versions requested by a build; '
                           'the argument is either the name of a control file '
                           'or the value of the X-Python3-Version attribute',
                      action='store_true', dest='requested')
    parser.add_option('-i', '--installed',
                      help='print the installed supported python3 versions',
                      action='store_true', dest='installed')
    parser.add_option('--min-supported',
                      help='print the minimum supported python3 version',
                      action='store_true', dest='minsupported')
    parser.add_option('--max-supported',
                      help='print the maximum supported python3 version',
                      action='store_true', dest='maxsupported')
    parser.add_option('-v', '--version',
                      help='print just the version number(s)',
                      default=False, action='store_true', dest='version_only')
    opts, args = parser.parse_args()
    program = os.path.basename(sys.argv[0])

    if opts.default and len(args) == 0:
        try:
            print(default_version(opts.version_only))
        except ValueError as msg:
            print("%s:" % program, msg)
            sys.exit(1)
    elif opts.supported and len(args) == 0:
        print(' '.join(supported_versions(opts.version_only)))
    elif opts.installed and len(args) == 0:
        print(' '.join(installed_versions(opts.version_only)))
    elif opts.minsupported and len(args) == 0:
        print(minmax_supported_version(min, opts.version_only))
    elif opts.maxsupported and len(args) == 0:
        print(minmax_supported_version(max, opts.version_only))
    elif opts.requested and len(args) <= 1:
        if len(args) == 0:
            versions = 'debian/control'
        else:
            versions = args[0]
        try:
            if os.path.isfile(versions):
                fn = versions
                try:
                    vstring = extract_pyversion_attribute(fn, 'Source')
                    vs = requested_versions(vstring, opts.version_only)
                except ControlFileValueError:
                    sys.stderr.write("%s: not a control file: %s, "
                                     % (program, fn))
                    sys.exit(1)
                except MissingVersionValueError:
                    sys.stderr.write("%s: no X-Python3-Version in control "
                                     "file, using supported versions\n" %
                                     program)
                    vs = supported_versions(opts.version_only)
            else:
                vs = requested_versions(versions, opts.version_only)
            print(' '.join(vs))
        except ValueError as msg:
            sys.stderr.write("%s: %s\n" % (program, msg))
            sys.exit(1)
    else:
        sys.stderr.write("usage: %s %s\n" % (program, usage))
        sys.exit(1)

if __name__ == '__main__':
    main()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                usr/share/python3/python.mk                                                                         0000644 0000000 0000000 00000004273 14414510722 014443  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # some macros useful for packaging python packages

# to include it unconditionally:
# include /usr/share/python3/python.mk
#
# to include it conditionally, and have the packaging working with earlier releases
# and backports:
# -include /usr/share/python/python.mk
# ifeq (,$(py_sitename))
#   py_sitename = site-packages
#   py_libdir = /usr/lib/python$(subst python,,$(1))/site-packages
#   py_sitename_sh = $(py_sitename)
#   py_libdir_sh = $(py_libdir)
# endif

# py_sitename: name of the site-packages/dist-packages directory depending
# on the python version. Call as: $(call py_sitename, <python version>).
# Don't use this in shell snippets inside loops.

py_sitename = $(if $(filter $(subst python,,$(1)), 2.3 2.4 2.5),site,dist)-packages

# py_libdir: absolute path to the default python library for third party
# stuff. Call as: $(call py_libdir, <python version>).
# Don't use this in shell snippets inside loops.

py_libdir = /usr/lib/python$(strip $(if $(findstring 3.,$(subst python,,$(1))),3,$(subst python,,$(1))))/$(py_sitename)

# py_pkgname: package name corresponding to the python version.
# Call as: $(call py_pkgname, <path>, <python version>).

py_pkgname = $(if $(findstring 3.,$(2)),$(subst python-,python3-,$(1)),$(1))

# setuptools' build directory
py_builddir = $(shell python$(strip $(subst python,,$(1))) -c 'import setuptools; from distutils.command.build import build; from distutils.core import Distribution; b = build(Distribution()); b.finalize_options(); print(b.build_platlib)')


# The same macros for use inside loops in shell snippets

py_sitename_sh = $$(basename $$(_py_=$(strip $(1)); python$${_py_\#python*} -c 'import setuptools; from distutils import sysconfig; print(sysconfig.get_python_lib())'))

py_libdir_sh = $$(_py_=$(strip $(1)); python$${_py_\#python*} -c 'import setuptools; from distutils import sysconfig; print(sysconfig.get_python_lib())')

py_builddir_sh = $$(_py_=$(strip $(1)); python$${_py_\#python*} -c 'import setuptools; from distutils.command.build import build; from distutils.core import Distribution; b = build(Distribution()); b.finalize_options(); print(b.build_platlib)')

# Arguments to pass to setup.py install
py_setup_install_args = --install-layout=deb
                                                                                                                                                                                                                                                                                                                                     usr/share/python3/runtime.d/                                                                        0000755 0000000 0000000 00000000000 14714551117 014476  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/python3/runtime.d/public_modules.rtinstall                                                0000755 0000000 0000000 00000000332 14414510722 021435  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #! /bin/sh
set -e

VERSION=${2#python}
if which py3compile >/dev/null 2>&1; then
    py3compile -V $VERSION /usr/lib/python3/dist-packages
else
    echo >&2 "py3compile not found in $(basename $0) hook."
    exit 1
fi
                                                                                                                                                                                                                                                                                                      usr/share/python3/runtime.d/public_modules.rtremove                                                 0000755 0000000 0000000 00000001213 14414510722 021263  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #! /bin/sh
set -e

VERSION=${2#python}
if which py3clean >/dev/null 2>&1; then
	if [ "$VERSION" = 3.1 ]; then
		find /usr/lib/python3.1/dist-packages -name '*.py[co]' -delete
        find /usr/lib/python3/dist-packages -name '*.py[co]' -delete
	else
		py3clean -V $VERSION /usr/lib/python3/dist-packages
	fi
else
	if [ "$VERSION" = 3.1 ]; then
		find /usr/lib/python3.1/dist-packages -name '*.py[co]' -delete
	else
		TAG=`python$VERSION -c "import imp; print(imp.magic_tags[imp.get_magic()])"` \
		find /usr/lib/python3/dist-packages -name "*.$TAG.py[co]" -delete
		find /usr/lib/python3/dist-packages -depth -empty -name '__pycache__' -delete
	fi
fi
                                                                                                                                                                                                                                                                                                                                                                                     usr/share/sensible-utils/                                                                           0000755 0000000 0000000 00000000000 14714551117 014127  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/sensible-utils/bin/                                                                       0000755 0000000 0000000 00000000000 14714551117 014677  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/sensible-utils/bin/gettext                                                                0000755 0000000 0000000 00000000077 14360554072 016315  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/bin/sh
# see #728612 emulate gettext in LANG=C
echo -n "$@"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 usr/share/ucf/                                                                                      0000755 0000000 0000000 00000000000 14714551117 011742  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/ucf/ucf_helper_functions.sh                                                               0000755 0000000 0000000 00000010712 14364750717 016516  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/bin/sh

UCF="ucf --three-way --debconf-ok"

# rename ucf-conffile. This was mostly stolen from cacti.postinst after
# a short discussion on debian-mentors, see
# http://lists.debian.org/debian-mentors/2013/07/msg00027.html
# and the following thread. Thanks to Paul Gevers
rename_ucf_file() {
    local oldname
    local newname

    # override UCF_FORCE_CONFFNEW with an empty local variable
    local UCF_FORCE_CONFFNEW

    oldname="$1"
    newname="$2"
    if [ ! -e "$newname" ] ; then
        if [ -e "$oldname" ]; then
            mv "$oldname" "$newname"
        fi
        # ucf doesn't offer a documented way to do this, so we need to
        # peddle around with undocumented ucf internals.
        sed -i "s|$oldname|$newname|" /var/lib/ucf/hashfile
        ucfr --purge "$PKGNAME" "$oldname"
        ucfr "$PKGNAME" "$newname"
        # else: Don't do anything, leave old file in place
    fi
    ucfr "$PKGNAME" "$newname"
}

generate_directory_structure() {
    local pkgdir
    local locdir
    pkgdir="$1"
    locdir="$2"

    # generate empty directory structure

    (cd "$pkgdir" && find . -type d -print0 ) | \
      (cd "$locdir" && xargs -0 mkdir -p --)
}

# handle a single ucf_conffile by first checking whether the file might be
# accociated with a different package. If so, we keep our hands off the file
# so that a different package can safely hijack our conffiles.
# to hijack a file, simply ucfr it to a package before the ucf processing
# code.
# If the file is either unassociated or already associated with us, call ucf
# proper and register the file as ours.
handle_single_ucf_file()
{
    local pkgfile
    local locfile
    if [ -n "${UCF_HELPER_FUNCTIONS_DEBUG:-}" ]; then
    	set -x
    fi

    pkgfile="$1"
    locfile="$2"
    export DEBIAN_FRONTEND

    PKG="$(ucfq --with-colons "$locdir/$file" | head -n 1 | cut --delimiter=: --fields=2 )"
    # skip conffile if it is associated with a different package.
    # This allows other packages to safely hijack our conffiles.
    if [ -z "$PKG" ] || [ "$PKG" = "$PKGNAME" ]; then
        $UCF "$pkgfile" "$locdir/$file"
        ucfr "$PKGNAME" "$locdir/$file"
    fi
    set +x
}

# checks whether a file was deleted in the package and handle it on the local
# system appropriately: If the local file differs from what we had previously,
# we just unregister it and leave it on the system (preserving local changes),
# otherwise we remove it.
# this also removes conffiles that are zero-size after the
# ucf run, which might happen if the local admin has
# deleted a conffile that has changed in the package.
handle_deleted_ucf_file()
{
    local locfile
    local locdir
    local pkgdir
    if [ -n "${UCF_HELPER_FUNCTIONS_DEBUG:-}" ]; then
    	set -x
    fi
    locfile="$1"
    pkgdir="$2"
    locdir="$3"

    # compute the name of the reference file in $pkgdir
    reffile="$(echo "$locfile" | sed "s|$locdir|$pkgdir|")"
    if ! [ -e "$reffile" ]; then
        # if the reference file does not exist, then it was removed in the package
        # do as if the file was replaced with an empty file
        $UCF /dev/null "$locfile"
        if [ -s "$locfile" ]; then
            # the file has non-zero size after the ucf run. local admin must
            # have decided to keep the file with contents. Done here.
            :
        else
            # the file has zero size and can be removed
            # remove the file itself ('') and all possible backup/reference extensions
            for ext in '' '~' '%' .bak .dpkg-tmp .dpkg-new .dpkg-old .dpkg-dist .ucf-new .ucf-old .ucf-dist;  do
              rm -f "${locfile}$ext"
            done
        fi
        # unregister the file anyhow since the package doesn't know about it any more
        ucf --purge "${locfile}"
        ucfr --purge "$PKGNAME" "${locfile}"
    fi
    set +x
}

handle_all_ucf_files() {
    local pkgdir
    local locdir
    pkgdir="$1"
    locdir="$2"

    generate_directory_structure "$pkgdir" "$locdir"

    # handle regular ucf-conffiles by iterating through all conffiles
    # that come with the package
    for file in $(find "$pkgdir" -type f -printf '%P\n' ); do
        handle_single_ucf_file "$pkgdir/$file" "$locdir/$file"
    done

    # handle ucf-conffiles that were deleted in our package by iterating
    # through all ucf-conffiles that are registered for the package
    for locfile in $(ucfq --with-colons "$PKGNAME" | cut --delimiter=: --fields=1); do
        handle_deleted_ucf_file "$locfile" "$pkgdir" "$locdir"
    done
}

# vim:sw=4:sts=4:et:
                                                      usr/share/zsh/                                                                                      0000755 0000000 0000000 00000000000 14714551120 011763  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/zsh/site-functions/                                                                       0000755 0000000 0000000 00000000000 14714551120 014735  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/zsh/site-functions/_hg                                                                    0000644 0000000 0000000 00000137361 14355257011 015433  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #compdef hg chg

# Zsh completion script for mercurial.  Rename this file to _hg and copy
# it into your zsh function path (/usr/share/zsh/site-functions for
# instance)
#
# If you do not want to install it globally, you can copy it somewhere
# else and add that directory to $fpath. This must be done before
# compinit is called. If the file is copied to ~/.zsh.d, your ~/.zshrc
# file could look like this:
#
# fpath=("$HOME/.zsh.d" $fpath)
# autoload -U compinit
# compinit
#
# Copyright (C) 2005, 2006 Steve Borho <steve@borho.org>
# Copyright (C) 2006-10 Brendan Cully <brendan@kublai.com>
#
# Permission is hereby granted, without written agreement and without
# licence or royalty fees, to use, copy, modify, and distribute this
# software and to distribute modified versions of this software for any
# purpose, provided that the above copyright notice and the following
# two paragraphs appear in all copies of this software.
#
# In no event shall the authors be liable to any party for direct,
# indirect, special, incidental, or consequential damages arising out of
# the use of this software and its documentation, even if the authors
# have been advised of the possibility of such damage.
#
# The authors specifically disclaim any warranties, including, but not
# limited to, the implied warranties of merchantability and fitness for
# a particular purpose.  The software provided hereunder is on an "as
# is" basis, and the authors have no obligation to provide maintenance,
# support, updates, enhancements, or modifications.

emulate -LR zsh
setopt extendedglob

local curcontext="$curcontext" state line
typeset -A _hg_cmd_globals

_hg() {
  local cmd _hg_root
  integer i=2
  _hg_cmd_globals=()

  while (( i < $#words ))
  do
    case "$words[$i]" in
      -R|--repository)
        eval _hg_root="$words[$i+1]"
        _hg_cmd_globals+=("$words[$i]" "$_hg_root")
        (( i += 2 ))
        continue
      ;;
      -R*)
        _hg_cmd_globals+="$words[$i]"
        eval _hg_root="${words[$i]#-R}"
       (( i++ ))
       continue
      ;;
      --cwd|--config)
        # pass along arguments to hg completer
        _hg_cmd_globals+=("$words[$i]" "$words[$i+1]")
        (( i += 2 ))
        continue
      ;;
      -*)
        # skip option
        (( i++ ))
        continue
      ;;
    esac
    if [[ -z "$cmd" ]]
    then
      cmd="$words[$i]"
      words[$i]=()
      (( CURRENT-- ))
    fi
    (( i++ ))
  done

  if [[ -z "$cmd" ]]
  then
    _arguments -s -S : $_hg_global_opts \
    ':mercurial command:_hg_commands'
    return
  fi

  # resolve abbreviations and aliases
  if ! (( $+functions[_hg_cmd_${cmd}] ))
  then
    local cmdexp
    (( $#_hg_cmd_list )) || _hg_get_commands

    cmdexp=$_hg_cmd_list[(r)${cmd}*]
    if [[ $cmdexp == $_hg_cmd_list[(R)${cmd}*] ]]
    then
      # might be nice to rewrite the command line with the expansion
      cmd="$cmdexp"
    fi
    if [[ -n $_hg_alias_list[$cmd] ]]
    then
      cmd=$_hg_alias_list[$cmd]
    fi
  fi

