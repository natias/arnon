                "GObject      *object G_GNUC_UNUSED,\n"
                "  guint         prop_id G_GNUC_UNUSED,\n"
                "  const GValue *value G_GNUC_UNUSED,\n"
            )
        else:
            self.outfile.write(
                "GObject      *object,\n"
                "  guint         prop_id,\n"
                "  const GValue *value,\n"
            )
        self.outfile.write("  GParamSpec   *pspec G_GNUC_UNUSED)\n" "{\n")
        if len(i.properties) > 0:
            self.outfile.write(
                "  const _ExtendedGDBusPropertyInfo *info;\n"
                "  GVariant *variant;\n"
                "  g_assert (prop_id != 0 && prop_id - 1 < %d);\n"
                "  info = (const _ExtendedGDBusPropertyInfo *) _%s_property_info_pointers[prop_id - 1];\n"
                "  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));\n"
                "  g_dbus_proxy_call (G_DBUS_PROXY (object),\n"
                '    "org.freedesktop.DBus.Properties.Set",\n'
                '    g_variant_new ("(ssv)", "%s", info->parent_struct.name, variant),\n'
                "    G_DBUS_CALL_FLAGS_NONE,\n"
                "    -1,\n"
                "    NULL, (GAsyncReadyCallback) %s_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);\n"
                "  g_variant_unref (variant);\n"
                % (len(i.properties), i.name_lower, i.name, i.name_lower)
            )
        self.outfile.write("}\n" "\n")

        # signal received
        self.outfile.write(
            "static void\n"
            "%s_proxy_g_signal (GDBusProxy *proxy,\n"
            "  const gchar *sender_name G_GNUC_UNUSED,\n"
            "  const gchar *signal_name,\n"
            "  GVariant *parameters)\n"
            "{\n" % (i.name_lower)
        )
        self.outfile.write(
            "  _ExtendedGDBusSignalInfo *info;\n"
            "  GVariantIter iter;\n"
            "  GVariant *child;\n"
            "  GValue *paramv;\n"
            "  gsize num_params;\n"
            "  gsize n;\n"
            "  guint signal_id;\n"
        )
        # Note: info could be NULL if we are talking to a newer version of the interface
        self.outfile.write(
            "  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_%s_interface_info.parent_struct, signal_name);\n"
            "  if (info == NULL)\n"
            "    return;\n" % (i.name_lower)
        )
        self.outfile.write(
            "  num_params = g_variant_n_children (parameters);\n"
            "  paramv = g_new0 (GValue, num_params + 1);\n"
            "  g_value_init (&paramv[0], %sTYPE_%s);\n"
            "  g_value_set_object (&paramv[0], proxy);\n" % (i.ns_upper, i.name_upper)
        )
        self.outfile.write(
            "  g_variant_iter_init (&iter, parameters);\n"
            "  n = 1;\n"
            "  while ((child = g_variant_iter_next_value (&iter)) != NULL)\n"
            "    {\n"
            "      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];\n"
            "      if (arg_info->use_gvariant)\n"
            "        {\n"
            "          g_value_init (&paramv[n], G_TYPE_VARIANT);\n"
            "          g_value_set_variant (&paramv[n], child);\n"
            "          n++;\n"
            "        }\n"
            "      else\n"
            "        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);\n"
            "      g_variant_unref (child);\n"
            "    }\n"
        )
        self.outfile.write(
            "  signal_id = g_signal_lookup (info->signal_name, %sTYPE_%s);\n"
            % (i.ns_upper, i.name_upper)
        )
        self.outfile.write("  g_signal_emitv (paramv, signal_id, 0, NULL);\n")
        self.outfile.write(
            "  for (n = 0; n < num_params + 1; n++)\n"
            "    g_value_unset (&paramv[n]);\n"
            "  g_free (paramv);\n"
        )
        self.outfile.write("}\n" "\n")

        # property changed
        self.outfile.write(
            "static void\n"
            "%s_proxy_g_properties_changed (GDBusProxy *_proxy,\n"
            "  GVariant *changed_properties,\n"
            "  const gchar *const *invalidated_properties)\n"
            "{\n" % (i.name_lower)
        )
        # Note: info could be NULL if we are talking to a newer version of the interface
        self.outfile.write(
            "  %sProxy *proxy = %s%s_PROXY (_proxy);\n"
            "  guint n;\n"
            "  const gchar *key;\n"
            "  GVariantIter *iter;\n"
            "  _ExtendedGDBusPropertyInfo *info;\n"
            '  g_variant_get (changed_properties, "a{sv}", &iter);\n'
            '  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))\n'
            "    {\n"
            "      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_%s_interface_info.parent_struct, key);\n"
            "      g_datalist_remove_data (&proxy->priv->qdata, key);\n"
            "      if (info != NULL)\n"
            "        g_object_notify (G_OBJECT (proxy), info->hyphen_name);\n"
            "    }\n"
            "  g_variant_iter_free (iter);\n"
            "  for (n = 0; invalidated_properties[n] != NULL; n++)\n"
            "    {\n"
            "      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_%s_interface_info.parent_struct, invalidated_properties[n]);\n"
            "      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);\n"
            "      if (info != NULL)\n"
            "        g_object_notify (G_OBJECT (proxy), info->hyphen_name);\n"
            "    }\n"
            "}\n"
            "\n" % (i.camel_name, i.ns_upper, i.name_upper, i.name_lower, i.name_lower)
        )

        # property vfuncs
        for p in i.properties:
            nul_value = "0"
            if p.arg.free_func is not None:
                nul_value = "NULL"
            self.outfile.write(
                "static %s\n"
                "%s_proxy_get_%s (%s *object)\n"
                "{\n"
                "  %sProxy *proxy = %s%s_PROXY (object);\n"
                "  GVariant *variant;\n"
                "  %svalue = %s;\n"
                % (
                    p.arg.ctype_in,
                    i.name_lower,
                    p.name_lower,
                    i.camel_name,
                    i.camel_name,
                    i.ns_upper,
                    i.name_upper,
                    p.arg.ctype_in,
                    nul_value,
                )
            )
            # For some property types, we have to free the returned
            # value (or part of it, e.g. the container) because of how
            # GVariant works.. see https://bugzilla.gnome.org/show_bug.cgi?id=657100
            # for details
            #
            free_container = False
            if (
                p.arg.gvariant_get == "g_variant_get_strv"
                or p.arg.gvariant_get == "g_variant_get_objv"
                or p.arg.gvariant_get == "g_variant_get_bytestring_array"
            ):
                free_container = True
            # If already using an old value for strv, objv, bytestring_array (see below),
            # then just return that... that way the result from multiple consecutive calls
            # to the getter are valid as long as they're freed
            #
            if free_container:
                self.outfile.write(
                    '  value = g_datalist_get_data (&proxy->priv->qdata, "%s");\n'
                    "  if (value != NULL)\n"
                    "    return value;\n" % (p.name)
                )
            self.outfile.write(
                '  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "%s");\n'
                % (p.name)
            )
            if p.arg.gtype == "G_TYPE_VARIANT":
                self.outfile.write("  value = variant;\n")
                self.outfile.write("  if (variant != NULL)\n")
                self.outfile.write("    g_variant_unref (variant);\n")
            else:
                self.outfile.write("  if (variant != NULL)\n" "    {\n")
                extra_len = ""
                if (
                    p.arg.gvariant_get == "g_variant_get_string"
                    or p.arg.gvariant_get == "g_variant_get_strv"
                    or p.arg.gvariant_get == "g_variant_get_objv"
                    or p.arg.gvariant_get == "g_variant_get_bytestring_array"
                ):
                    extra_len = ", NULL"
                self.outfile.write(
                    "      value = %s (variant%s);\n" % (p.arg.gvariant_get, extra_len)
                )
                if free_container:
                    self.outfile.write(
                        '      g_datalist_set_data_full (&proxy->priv->qdata, "%s", (gpointer) value, g_free);\n'
                        % (p.name)
                    )
                self.outfile.write("      g_variant_unref (variant);\n")
                self.outfile.write("    }\n")
            self.outfile.write("  return value;\n")
            self.outfile.write("}\n")
            self.outfile.write("\n")

        # class boilerplate
        self.outfile.write(
            "static void\n"
            "%s_proxy_init (%sProxy *proxy)\n"
            "{\n"
            "#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38\n"
            "  proxy->priv = %s_proxy_get_instance_private (proxy);\n"
            "#else\n"
            "  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, %sTYPE_%s_PROXY, %sProxyPrivate);\n"
            "#endif\n\n"
            "  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), %s_interface_info ());\n"
            "}\n"
            "\n"
            % (
                i.name_lower,
                i.camel_name,
                i.name_lower,
                i.ns_upper,
                i.name_upper,
                i.camel_name,
                i.name_lower,
            )
        )
        self.outfile.write(
            "static void\n"
            "%s_proxy_class_init (%sProxyClass *klass)\n"
            "{\n"
            "  GObjectClass *gobject_class;\n"
            "  GDBusProxyClass *proxy_class;\n"
            "\n"
            "  gobject_class = G_OBJECT_CLASS (klass);\n"
            "  gobject_class->finalize     = %s_proxy_finalize;\n"
            "  gobject_class->get_property = %s_proxy_get_property;\n"
            "  gobject_class->set_property = %s_proxy_set_property;\n"
            "\n"
            "  proxy_class = G_DBUS_PROXY_CLASS (klass);\n"
            "  proxy_class->g_signal = %s_proxy_g_signal;\n"
            "  proxy_class->g_properties_changed = %s_proxy_g_properties_changed;\n"
            "\n"
            % (
                i.name_lower,
                i.camel_name,
                i.name_lower,
                i.name_lower,
                i.name_lower,
                i.name_lower,
                i.name_lower,
            )
        )
        if len(i.properties) > 0:
            self.outfile.write(
                "  %s_override_properties (gobject_class, 1);\n\n" % (i.name_lower)
            )
        self.outfile.write(
            "#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38\n"
            "  g_type_class_add_private (klass, sizeof (%sProxyPrivate));\n"
            "#endif\n" % (i.camel_name)
        )
        self.outfile.write("}\n" "\n")

        self.outfile.write(
            "static void\n"
            "%s_proxy_iface_init (%sIface *iface" % (i.name_lower, i.camel_name)
        )
        if len(i.properties) == 0:
            self.outfile.write(" G_GNUC_UNUSED)\n")
        else:
            self.outfile.write(")\n")
        self.outfile.write("{\n")
        for p in i.properties:
            self.outfile.write(
                "  iface->get_%s = %s_proxy_get_%s;\n"
                % (p.name_lower, i.name_lower, p.name_lower)
            )
        self.outfile.write("}\n" "\n")

        # constructors
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %s_proxy_new:\n"
                " * @connection: A #GDBusConnection.\n"
                " * @flags: Flags from the #GDBusProxyFlags enumeration.\n"
                " * @name: (nullable): A bus name (well-known or unique) or %%NULL if @connection is not a message bus connection.\n"
                " * @object_path: An object path.\n"
                " * @cancellable: (nullable): A #GCancellable or %%NULL.\n"
                " * @callback: A #GAsyncReadyCallback to call when the request is satisfied.\n"
                " * @user_data: User data to pass to @callback.\n"
                " *\n"
                " * Asynchronously creates a proxy for the D-Bus interface #%s. See g_dbus_proxy_new() for more details.\n"
                " *\n"
                " * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).\n"
                " * You can then call %s_proxy_new_finish() to get the result of the operation.\n"
                " *\n"
                " * See %s_proxy_new_sync() for the synchronous, blocking version of this constructor.\n"
                % (i.name_lower, i.name, i.name_lower, i.name_lower),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write(
            "void\n"
            "%s_proxy_new (\n"
            "    GDBusConnection     *connection,\n"
            "    GDBusProxyFlags      flags,\n"
            "    const gchar         *name,\n"
            "    const gchar         *object_path,\n"
            "    GCancellable        *cancellable,\n"
            "    GAsyncReadyCallback  callback,\n"
            "    gpointer             user_data)\n"
            "{\n"
            '  g_async_initable_new_async (%sTYPE_%s_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "%s", NULL);\n'
            "}\n"
            "\n" % (i.name_lower, i.ns_upper, i.name_upper, i.name)
        )
        self.outfile.write(
            "/**\n"
            " * %s_proxy_new_finish:\n"
            " * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to %s_proxy_new().\n"
            " * @error: Return location for error or %%NULL\n"
            " *\n"
            " * Finishes an operation started with %s_proxy_new().\n"
            " *\n"
            " * Returns: (transfer full) (type %sProxy): The constructed proxy object or %%NULL if @error is set.\n"
            % (i.name_lower, i.name_lower, i.name_lower, i.camel_name)
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write(
            "%s *\n"
            "%s_proxy_new_finish (\n"
            "    GAsyncResult        *res,\n"
            "    GError             **error)\n"
            "{\n"
            "  GObject *ret;\n"
            "  GObject *source_object;\n"
            "  source_object = g_async_result_get_source_object (res);\n"
            "  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);\n"
            "  g_object_unref (source_object);\n"
            "  if (ret != NULL)\n"
            "    return %s%s (ret);\n"
            "  else\n"
            "    return NULL;\n"
            "}\n"
            "\n" % (i.camel_name, i.name_lower, i.ns_upper, i.name_upper)
        )
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %s_proxy_new_sync:\n"
                " * @connection: A #GDBusConnection.\n"
                " * @flags: Flags from the #GDBusProxyFlags enumeration.\n"
                " * @name: (nullable): A bus name (well-known or unique) or %%NULL if @connection is not a message bus connection.\n"
                " * @object_path: An object path.\n"
                " * @cancellable: (nullable): A #GCancellable or %%NULL.\n"
                " * @error: Return location for error or %%NULL\n"
                " *\n"
                " * Synchronously creates a proxy for the D-Bus interface #%s. See g_dbus_proxy_new_sync() for more details.\n"
                " *\n"
                " * The calling thread is blocked until a reply is received.\n"
                " *\n"
                " * See %s_proxy_new() for the asynchronous version of this constructor.\n"
                " *\n"
                " * Returns: (transfer full) (type %sProxy): The constructed proxy object or %%NULL if @error is set.\n"
                % (i.name_lower, i.name, i.name_lower, i.camel_name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write(
            "%s *\n"
            "%s_proxy_new_sync (\n"
            "    GDBusConnection     *connection,\n"
            "    GDBusProxyFlags      flags,\n"
            "    const gchar         *name,\n"
            "    const gchar         *object_path,\n"
            "    GCancellable        *cancellable,\n"
            "    GError             **error)\n"
            "{\n"
            "  GInitable *ret;\n"
            '  ret = g_initable_new (%sTYPE_%s_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "%s", NULL);\n'
            "  if (ret != NULL)\n"
            "    return %s%s (ret);\n"
            "  else\n"
            "    return NULL;\n"
            "}\n"
            "\n"
            % (
                i.camel_name,
                i.name_lower,
                i.ns_upper,
                i.name_upper,
                i.name,
                i.ns_upper,
                i.name_upper,
            )
        )
        self.outfile.write("\n")
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %s_proxy_new_for_bus:\n"
                " * @bus_type: A #GBusType.\n"
                " * @flags: Flags from the #GDBusProxyFlags enumeration.\n"
                " * @name: A bus name (well-known or unique).\n"
                " * @object_path: An object path.\n"
                " * @cancellable: (nullable): A #GCancellable or %%NULL.\n"
                " * @callback: A #GAsyncReadyCallback to call when the request is satisfied.\n"
                " * @user_data: User data to pass to @callback.\n"
                " *\n"
                " * Like %s_proxy_new() but takes a #GBusType instead of a #GDBusConnection.\n"
                " *\n"
                " * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).\n"
                " * You can then call %s_proxy_new_for_bus_finish() to get the result of the operation.\n"
                " *\n"
                " * See %s_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.\n"
                % (i.name_lower, i.name_lower, i.name_lower, i.name_lower),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write(
            "void\n"
            "%s_proxy_new_for_bus (\n"
            "    GBusType             bus_type,\n"
            "    GDBusProxyFlags      flags,\n"
            "    const gchar         *name,\n"
            "    const gchar         *object_path,\n"
            "    GCancellable        *cancellable,\n"
            "    GAsyncReadyCallback  callback,\n"
            "    gpointer             user_data)\n"
            "{\n"
            '  g_async_initable_new_async (%sTYPE_%s_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "%s", NULL);\n'
            "}\n"
            "\n" % (i.name_lower, i.ns_upper, i.name_upper, i.name)
        )
        self.outfile.write(
            "/**\n"
            " * %s_proxy_new_for_bus_finish:\n"
            " * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to %s_proxy_new_for_bus().\n"
            " * @error: Return location for error or %%NULL\n"
            " *\n"
            " * Finishes an operation started with %s_proxy_new_for_bus().\n"
            " *\n"
            " * Returns: (transfer full) (type %sProxy): The constructed proxy object or %%NULL if @error is set.\n"
            % (i.name_lower, i.name_lower, i.name_lower, i.camel_name)
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write(
            "%s *\n"
            "%s_proxy_new_for_bus_finish (\n"
            "    GAsyncResult        *res,\n"
            "    GError             **error)\n"
            "{\n"
            "  GObject *ret;\n"
            "  GObject *source_object;\n"
            "  source_object = g_async_result_get_source_object (res);\n"
            "  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);\n"
            "  g_object_unref (source_object);\n"
            "  if (ret != NULL)\n"
            "    return %s%s (ret);\n"
            "  else\n"
            "    return NULL;\n"
            "}\n"
            "\n" % (i.camel_name, i.name_lower, i.ns_upper, i.name_upper)
        )
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %s_proxy_new_for_bus_sync:\n"
                " * @bus_type: A #GBusType.\n"
                " * @flags: Flags from the #GDBusProxyFlags enumeration.\n"
                " * @name: A bus name (well-known or unique).\n"
                " * @object_path: An object path.\n"
                " * @cancellable: (nullable): A #GCancellable or %%NULL.\n"
                " * @error: Return location for error or %%NULL\n"
                " *\n"
                " * Like %s_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.\n"
                " *\n"
                " * The calling thread is blocked until a reply is received.\n"
                " *\n"
                " * See %s_proxy_new_for_bus() for the asynchronous version of this constructor.\n"
                " *\n"
                " * Returns: (transfer full) (type %sProxy): The constructed proxy object or %%NULL if @error is set.\n"
                % (i.name_lower, i.name_lower, i.name_lower, i.camel_name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write(
            "%s *\n"
            "%s_proxy_new_for_bus_sync (\n"
            "    GBusType             bus_type,\n"
            "    GDBusProxyFlags      flags,\n"
            "    const gchar         *name,\n"
            "    const gchar         *object_path,\n"
            "    GCancellable        *cancellable,\n"
            "    GError             **error)\n"
            "{\n"
            "  GInitable *ret;\n"
            '  ret = g_initable_new (%sTYPE_%s_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "%s", NULL);\n'
            "  if (ret != NULL)\n"
            "    return %s%s (ret);\n"
            "  else\n"
            "    return NULL;\n"
            "}\n"
            "\n"
            % (
                i.camel_name,
                i.name_lower,
                i.ns_upper,
                i.name_upper,
                i.name,
                i.ns_upper,
                i.name_upper,
            )
        )
        self.outfile.write("\n")

    # ---------------------------------------------------------------------------------------------------

    def generate_skeleton(self, i):
        # class boilerplate
        self.outfile.write(
            "/* ------------------------------------------------------------------------ */\n"
            "\n"
        )

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sSkeleton:\n"
                " *\n"
                " * The #%sSkeleton structure contains only private data and should only be accessed using the provided API.\n"
                % (i.camel_name, i.camel_name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write("\n")

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sSkeletonClass:\n"
                " * @parent_class: The parent class.\n"
                " *\n"
                " * Class structure for #%sSkeleton.\n" % (i.camel_name, i.camel_name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write("\n")

        self.outfile.write(
            "struct _%sSkeletonPrivate\n"
            "{\n"
            "  GValue *properties;\n"
            "  GList *changed_properties;\n"
            "  GSource *changed_properties_idle_source;\n"
            "  GMainContext *context;\n"
            "  GMutex lock;\n"
            "};\n"
            "\n" % i.camel_name
        )

        self.outfile.write(
            "static void\n"
            "_%s_skeleton_handle_method_call (\n"
            "  GDBusConnection *connection G_GNUC_UNUSED,\n"
            "  const gchar *sender G_GNUC_UNUSED,\n"
            "  const gchar *object_path G_GNUC_UNUSED,\n"
            "  const gchar *interface_name,\n"
            "  const gchar *method_name,\n"
            "  GVariant *parameters,\n"
            "  GDBusMethodInvocation *invocation,\n"
            "  gpointer user_data)\n"
            "{\n"
            "  %sSkeleton *skeleton = %s%s_SKELETON (user_data);\n"
            "  _ExtendedGDBusMethodInfo *info;\n"
            "  GVariantIter iter;\n"
            "  GVariant *child;\n"
            "  GValue *paramv;\n"
            "  gsize num_params;\n"
            "  guint num_extra;\n"
            "  gsize n;\n"
            "  guint signal_id;\n"
            "  GValue return_value = G_VALUE_INIT;\n"
            % (i.name_lower, i.camel_name, i.ns_upper, i.name_upper)
        )
        self.outfile.write(
            "  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);\n"
            "  g_assert (info != NULL);\n"
        )
        self.outfile.write(
            "  num_params = g_variant_n_children (parameters);\n"
            "  num_extra = info->pass_fdlist ? 3 : 2;"
            "  paramv = g_new0 (GValue, num_params + num_extra);\n"
            "  n = 0;\n"
            "  g_value_init (&paramv[n], %sTYPE_%s);\n"
            "  g_value_set_object (&paramv[n++], skeleton);\n"
            "  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);\n"
            "  g_value_set_object (&paramv[n++], invocation);\n"
            "  if (info->pass_fdlist)\n"
            "    {\n"
            "#ifdef G_OS_UNIX\n"
            "      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);\n"
            "      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));\n"
            "#else\n"
            "      g_assert_not_reached ();\n"
            "#endif\n"
            "    }\n" % (i.ns_upper, i.name_upper)
        )
        self.outfile.write(
            "  g_variant_iter_init (&iter, parameters);\n"
            "  while ((child = g_variant_iter_next_value (&iter)) != NULL)\n"
            "    {\n"
            "      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];\n"
            "      if (arg_info->use_gvariant)\n"
            "        {\n"
            "          g_value_init (&paramv[n], G_TYPE_VARIANT);\n"
            "          g_value_set_variant (&paramv[n], child);\n"
            "          n++;\n"
            "        }\n"
            "      else\n"
            "        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);\n"
            "      g_variant_unref (child);\n"
            "    }\n"
        )
        self.outfile.write(
            "  signal_id = g_signal_lookup (info->signal_name, %sTYPE_%s);\n"
            % (i.ns_upper, i.name_upper)
        )
        self.outfile.write(
            "  g_value_init (&return_value, G_TYPE_BOOLEAN);\n"
            "  g_signal_emitv (paramv, signal_id, 0, &return_value);\n"
            "  if (!g_value_get_boolean (&return_value))\n"
            '    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);\n'
            "  g_value_unset (&return_value);\n"
        )
        self.outfile.write(
            "  for (n = 0; n < num_params + num_extra; n++)\n"
            "    g_value_unset (&paramv[n]);\n"
            "  g_free (paramv);\n"
        )
        self.outfile.write("}\n" "\n")

        self.outfile.write(
            "static GVariant *\n"
            "_%s_skeleton_handle_get_property (\n"
            "  GDBusConnection *connection G_GNUC_UNUSED,\n"
            "  const gchar *sender G_GNUC_UNUSED,\n"
            "  const gchar *object_path G_GNUC_UNUSED,\n"
            "  const gchar *interface_name G_GNUC_UNUSED,\n"
            "  const gchar *property_name,\n"
            "  GError **error,\n"
            "  gpointer user_data)\n"
            "{\n"
            "  %sSkeleton *skeleton = %s%s_SKELETON (user_data);\n"
            "  GValue value = G_VALUE_INIT;\n"
            "  GParamSpec *pspec;\n"
            "  _ExtendedGDBusPropertyInfo *info;\n"
            "  GVariant *ret;\n"
            % (i.name_lower, i.camel_name, i.ns_upper, i.name_upper)
        )
        self.outfile.write(
            "  ret = NULL;\n"
            "  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_%s_interface_info.parent_struct, property_name);\n"
            "  g_assert (info != NULL);\n"
            "  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);\n"
            "  if (pspec == NULL)\n"
            "    {\n"
            '      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %%s", property_name);\n'
            "    }\n"
            "  else\n"
            "    {\n"
            "      g_value_init (&value, pspec->value_type);\n"
            "      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);\n"
            "      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));\n"
            "      g_value_unset (&value);\n"
            "    }\n"
            "  return ret;\n"
            "}\n"
            "\n" % (i.name_lower)
        )

        self.outfile.write(
            "static gboolean\n"
            "_%s_skeleton_handle_set_property (\n"
            "  GDBusConnection *connection G_GNUC_UNUSED,\n"
            "  const gchar *sender G_GNUC_UNUSED,\n"
            "  const gchar *object_path G_GNUC_UNUSED,\n"
            "  const gchar *interface_name G_GNUC_UNUSED,\n"
            "  const gchar *property_name,\n"
            "  GVariant *variant,\n"
            "  GError **error,\n"
            "  gpointer user_data)\n"
            "{\n"
            "  %sSkeleton *skeleton = %s%s_SKELETON (user_data);\n"
            "  GValue value = G_VALUE_INIT;\n"
            "  GParamSpec *pspec;\n"
            "  _ExtendedGDBusPropertyInfo *info;\n"
            "  gboolean ret;\n" % (i.name_lower, i.camel_name, i.ns_upper, i.name_upper)
        )
        self.outfile.write(
            "  ret = FALSE;\n"
            "  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_%s_interface_info.parent_struct, property_name);\n"
            "  g_assert (info != NULL);\n"
            "  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);\n"
            "  if (pspec == NULL)\n"
            "    {\n"
            '      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %%s", property_name);\n'
            "    }\n"
            "  else\n"
            "    {\n"
            "      if (info->use_gvariant)\n"
            "        g_value_set_variant (&value, variant);\n"
            "      else\n"
            "        g_dbus_gvariant_to_gvalue (variant, &value);\n"
            "      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);\n"
            "      g_value_unset (&value);\n"
            "      ret = TRUE;\n"
            "    }\n"
            "  return ret;\n"
            "}\n"
            "\n" % (i.name_lower)
        )

        self.outfile.write(
            "static const GDBusInterfaceVTable _%s_skeleton_vtable =\n"
            "{\n"
            "  _%s_skeleton_handle_method_call,\n"
            "  _%s_skeleton_handle_get_property,\n"
            "  _%s_skeleton_handle_set_property,\n"
            "  {NULL}\n"
            "};\n"
            "\n" % (i.name_lower, i.name_lower, i.name_lower, i.name_lower)
        )

        self.outfile.write(
            "static GDBusInterfaceInfo *\n"
            "%s_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)\n"
            "{\n"
            "  return %s_interface_info ();\n" % (i.name_lower, i.name_lower)
        )
        self.outfile.write("}\n" "\n")

        self.outfile.write(
            "static GDBusInterfaceVTable *\n"
            "%s_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)\n"
            "{\n"
            "  return (GDBusInterfaceVTable *) &_%s_skeleton_vtable;\n"
            % (i.name_lower, i.name_lower)
        )
        self.outfile.write("}\n" "\n")

        self.outfile.write(
            "static GVariant *\n"
            "%s_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)\n"
            "{\n"
            "  %sSkeleton *skeleton = %s%s_SKELETON (_skeleton);\n"
            % (i.name_lower, i.camel_name, i.ns_upper, i.name_upper)
        )
        self.outfile.write(
            "\n"
            "  GVariantBuilder builder;\n"
            "  guint n;\n"
            '  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));\n'
            "  if (_%s_interface_info.parent_struct.properties == NULL)\n"
            "    goto out;\n"
            "  for (n = 0; _%s_interface_info.parent_struct.properties[n] != NULL; n++)\n"
            "    {\n"
            "      GDBusPropertyInfo *info = _%s_interface_info.parent_struct.properties[n];\n"
            "      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)\n"
            "        {\n"
            "          GVariant *value;\n"
            '          value = _%s_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "%s", info->name, NULL, skeleton);\n'
            "          if (value != NULL)\n"
            "            {\n"
            "              g_variant_take_ref (value);\n"
            '              g_variant_builder_add (&builder, "{sv}", info->name, value);\n'
            "              g_variant_unref (value);\n"
            "            }\n"
            "        }\n"
            "    }\n"
            "out:\n"
            "  return g_variant_builder_end (&builder);\n"
            "}\n"
            "\n" % (i.name_lower, i.name_lower, i.name_lower, i.name_lower, i.name)
        )

        if len(i.properties) > 0:
            self.outfile.write(
                "static gboolean _%s_emit_changed (gpointer user_data);\n"
                "\n" % (i.name_lower)
            )

        self.outfile.write(
            "static void\n"
            "%s_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton"
            % (i.name_lower)
        )
        if len(i.properties) == 0:
            self.outfile.write(" G_GNUC_UNUSED)\n")
        else:
            self.outfile.write(")\n")
        self.outfile.write("{\n")
        if len(i.properties) > 0:
            self.outfile.write(
                "  %sSkeleton *skeleton = %s%s_SKELETON (_skeleton);\n"
                "  gboolean emit_changed = FALSE;\n"
                "\n"
                "  g_mutex_lock (&skeleton->priv->lock);\n"
                "  if (skeleton->priv->changed_properties_idle_source != NULL)\n"
                "    {\n"
                "      g_source_destroy (skeleton->priv->changed_properties_idle_source);\n"
                "      skeleton->priv->changed_properties_idle_source = NULL;\n"
                "      emit_changed = TRUE;\n"
                "    }\n"
                "  g_mutex_unlock (&skeleton->priv->lock);\n"
                "\n"
                "  if (emit_changed)\n"
                "    _%s_emit_changed (skeleton);\n"
                % (i.camel_name, i.ns_upper, i.name_upper, i.name_lower)
            )
        self.outfile.write("}\n" "\n")

        for s in i.signals:
            self.outfile.write(
                "static void\n"
                "_%s_on_signal_%s (\n"
                "    %s *object" % (i.name_lower, s.name_lower, i.camel_name)
            )
            for a in s.args:
                self.outfile.write(",\n    %sarg_%s" % (a.ctype_in, a.name))
            self.outfile.write(
                ")\n"
                "{\n"
                "  %sSkeleton *skeleton = %s%s_SKELETON (object);\n\n"
                "  GList      *connections, *l;\n"
                "  GVariant   *signal_variant;\n"
                "  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));\n"
                % (i.camel_name, i.ns_upper, i.name_upper)
            )
            self.outfile.write(
                "\n" '  signal_variant = g_variant_ref_sink (g_variant_new ("('
            )
            for a in s.args:
                self.outfile.write("%s" % (a.format_in))
            self.outfile.write(')"')
            for a in s.args:
                self.outfile.write(",\n                   arg_%s" % (a.name))
            self.outfile.write("));\n")

            self.outfile.write(
                "  for (l = connections; l != NULL; l = l->next)\n"
                "    {\n"
                "      GDBusConnection *connection = l->data;\n"
                "      g_dbus_connection_emit_signal (connection,\n"
                '        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "%s", "%s",\n'
                "        signal_variant, NULL);\n"
                "    }\n" % (i.name, s.name)
            )
            self.outfile.write("  g_variant_unref (signal_variant);\n")
            self.outfile.write("  g_list_free_full (connections, g_object_unref);\n")
            self.outfile.write("}\n" "\n")

        self.outfile.write(
            "static void %s_skeleton_iface_init (%sIface *iface);\n"
            % (i.name_lower, i.camel_name)
        )

        self.outfile.write("#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38\n")
        self.outfile.write(
            "G_DEFINE_TYPE_WITH_CODE (%sSkeleton, %s_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,\n"
            % (i.camel_name, i.name_lower)
        )
        self.outfile.write(
            "                         G_ADD_PRIVATE (%sSkeleton)\n" % (i.camel_name)
        )
        self.outfile.write(
            "                         G_IMPLEMENT_INTERFACE (%sTYPE_%s, %s_skeleton_iface_init))\n\n"
            % (i.ns_upper, i.name_upper, i.name_lower)
        )
        self.outfile.write("#else\n")
        self.outfile.write(
            "G_DEFINE_TYPE_WITH_CODE (%sSkeleton, %s_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,\n"
            % (i.camel_name, i.name_lower)
        )
        self.outfile.write(
            "                         G_IMPLEMENT_INTERFACE (%sTYPE_%s, %s_skeleton_iface_init))\n\n"
            % (i.ns_upper, i.name_upper, i.name_lower)
        )
        self.outfile.write("#endif\n")

        # finalize
        self.outfile.write(
            "static void\n"
            "%s_skeleton_finalize (GObject *object)\n"
            "{\n" % (i.name_lower)
        )
        self.outfile.write(
            "  %sSkeleton *skeleton = %s%s_SKELETON (object);\n"
            % (i.camel_name, i.ns_upper, i.name_upper)
        )
        if len(i.properties) > 0:
            self.outfile.write(
                "  guint n;\n"
                "  for (n = 0; n < %d; n++)\n"
                "    g_value_unset (&skeleton->priv->properties[n]);\n"
                % (len(i.properties))
            )
            self.outfile.write("  g_free (skeleton->priv->properties);\n")
        self.outfile.write(
            "  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);\n"
        )
        self.outfile.write(
            "  if (skeleton->priv->changed_properties_idle_source != NULL)\n"
        )
        self.outfile.write(
            "    g_source_destroy (skeleton->priv->changed_properties_idle_source);\n"
        )
        self.outfile.write("  g_main_context_unref (skeleton->priv->context);\n")
        self.outfile.write("  g_mutex_clear (&skeleton->priv->lock);\n")
        self.outfile.write(
            "  G_OBJECT_CLASS (%s_skeleton_parent_class)->finalize (object);\n"
            "}\n"
            "\n" % (i.name_lower)
        )

        # property accessors (TODO: generate PropertiesChanged signals in setter)
        if len(i.properties) > 0:
            self.outfile.write(
                "static void\n"
                "%s_skeleton_get_property (GObject      *object,\n"
                "  guint         prop_id,\n"
                "  GValue       *value,\n"
                "  GParamSpec   *pspec G_GNUC_UNUSED)\n"
                "{\n" % (i.name_lower)
            )
            self.outfile.write(
                "  %sSkeleton *skeleton = %s%s_SKELETON (object);\n"
                "  g_assert (prop_id != 0 && prop_id - 1 < %d);\n"
                "  g_mutex_lock (&skeleton->priv->lock);\n"
                "  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);\n"
                "  g_mutex_unlock (&skeleton->priv->lock);\n"
                % (i.camel_name, i.ns_upper, i.name_upper, len(i.properties))
            )
            self.outfile.write("}\n" "\n")

            # if property is already scheduled then re-use entry.. though it could be
            # that the user did
            #
            #  foo_set_prop_bar (object, "");
            #  foo_set_prop_bar (object, "blah");
            #
            # say, every update... In this case, where nothing happens, we obviously
            # don't want a PropertiesChanged() event. We can easily check for this
            # by comparing against the _original value_ recorded before the first
            # change event. If the latest value is not different from the original
            # one, we can simply ignore the ChangedProperty
            #
            self.outfile.write(
                "static gboolean\n"
                "_%s_emit_changed (gpointer user_data)\n"
                "{\n"
                "  %sSkeleton *skeleton = %s%s_SKELETON (user_data);\n"
                % (i.name_lower, i.camel_name, i.ns_upper, i.name_upper)
            )
            self.outfile.write(
                "  GList *l;\n"
                "  GVariantBuilder builder;\n"
                "  GVariantBuilder invalidated_builder;\n"
                "  guint num_changes;\n"
                "\n"
                "  g_mutex_lock (&skeleton->priv->lock);\n"
                '  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));\n'
                '  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));\n'
                "  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)\n"
                "    {\n"
                "      ChangedProperty *cp = l->data;\n"
                "      GVariant *variant;\n"
                "      const GValue *cur_value;\n"
                "\n"
                "      cur_value = &skeleton->priv->properties[cp->prop_id - 1];\n"
                "      if (!_g_value_equal (cur_value, &cp->orig_value))\n"
                "        {\n"
                "          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));\n"
                '          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);\n'
                "          g_variant_unref (variant);\n"
                "          num_changes++;\n"
                "        }\n"
                "    }\n"
                "  if (num_changes > 0)\n"
                "    {\n"
                "      GList *connections, *ll;\n"
                "      GVariant *signal_variant;"
                "\n"
                '      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "%s",\n'
                "                                           &builder, &invalidated_builder));\n"
