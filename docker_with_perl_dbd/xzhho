			Using the mouse only works when 'mouse' contains 'n'
			or 'a'.

["x]zp		    or					*zp* *zP*
["x]zP			Like "p" and "P", except without adding trailing spaces
			when pasting a block.  Thus the inserted text will not
			always be a rectangle.  Especially useful in
			combination with |v_zy|.

You can use these commands to copy text from one place to another.  Do this
by first getting the text into a register with a yank, delete or change
command, then inserting the register contents with a put command.  You can
also use these commands to move text from one file to another, because Vim
preserves all registers when changing buffers (the CTRL-^ command is a quick
way to toggle between two files).

				*linewise-register* *characterwise-register*
You can repeat the put commands with "." (except for :put) and undo them.  If
the command that was used to get the text into the register was |linewise|,
Vim inserts the text below ("p") or above ("P") the line where the cursor is.
Otherwise Vim inserts the text after ("p") or before ("P") the cursor.  With
the ":put" command, Vim always inserts the text in the next line.  You can
exchange two characters with the command sequence "xp".  You can exchange two
lines with the command sequence "ddp".  You can exchange two words with the
command sequence "deep" (start with the cursor in the blank space before the
first word).  You can use the "']" or "`]" command after the put command to
move the cursor to the end of the inserted text, or use "'[" or "`[" to move
the cursor to the start.

						*put-Visual-mode* *v_p* *v_P*
When using a put command like |p| or |P| in Visual mode, Vim will try to
replace the selected text with the contents of the register.  Whether this
works well depends on the type of selection and the type of the text in the
register.  With blockwise selection it also depends on the size of the block
and whether the corners are on an existing character.  (Implementation detail:
it actually works by first putting the register after the selection and then
deleting the selection.)
With |p| the previously selected text is put in the unnamed register (and
possibly the selection and/or clipboard).  This is useful if you want to put
that text somewhere else.  But you cannot repeat the same change.
With |P| the unnamed register is not changed (and neither the selection or
clipboard), you can repeat the same change. But the deleted text cannot be
used.  If you do need it you can use |p| with another register.  E.g., yank
the text to copy, Visually select the text to replace and use "0p .  You can
repeat this as many times as you like, and the unnamed register will be
changed each time.
							*blockwise-put*
When a register contains text from one line (characterwise), using a
blockwise Visual selection, putting that register will paste that text
repeatedly in each of the selected lines, thus replacing the blockwise
selected region by multiple copies of the register text.  For example:
	- yank the word "TEXT" into a register with `yw`
	- select a visual block, marked with "v" in this text:
	    aaavvaaa
	    bbbvvbbb
	    cccvvccc
	- press `p`, results in:
	    aaaTEXTaaa
	    bbbTEXTbbb
	    cccTEXTccc

							*blockwise-register*
If you use a blockwise Visual mode command to get the text into the register,
the block of text will be inserted before ("P") or after ("p") the cursor
column in the current and next lines.  Vim makes the whole block of text start
in the same column.  Thus the inserted text looks the same as when it was
yanked or deleted.  Vim may replace some <Tab> characters with spaces to make
this happen.  However, if the width of the block is not a multiple of a <Tab>
width and the text after the inserted block contains <Tab>s, that text may be
misaligned.

Use |zP|/|zp| to paste a blockwise yanked register without appending trailing
spaces.

Note that after a characterwise yank command, Vim leaves the cursor on the
first yanked character that is closest to the start of the buffer.  This means
that "yl" doesn't move the cursor, but "yh" moves the cursor one character
left.
Rationale:	In Vi the "y" command followed by a backwards motion would
		sometimes not move the cursor to the first yanked character,
		because redisplaying was skipped.  In Vim it always moves to
		the first character, as specified by Posix.
With a linewise yank command the cursor is put in the first line, but the
column is unmodified, thus it may not be on the first yanked character.

There are ten types of registers:		*registers* *{register}* *E354*
1. The unnamed register ""
2. 10 numbered registers "0 to "9
3. The small delete register "-
4. 26 named registers "a to "z or "A to "Z
5. Three read-only registers ":, "., "%
6. Alternate buffer register "#
7. The expression register "=
8. The selection and drop registers "*, "+ and "~ 
9. The black hole register "_
10. Last search pattern register "/

1. Unnamed register ""				*quote_quote* *quotequote*
Vim fills this register with text deleted with the "d", "c", "s", "x" commands
or copied with the yank "y" command, regardless of whether or not a specific
register was used (e.g.  "xdd).  This is like the unnamed register is pointing
to the last used register.  Thus when appending using an uppercase register
name, the unnamed register contains the same text as the named register.
An exception is the '_' register: "_dd does not store the deleted text in any
register.
Vim uses the contents of the unnamed register for any put command (p or P)
which does not specify a register.  Additionally you can access it with the
name '"'.  This means you have to type two double quotes.  Writing to the ""
register writes to register "0.
{Vi: register contents are lost when changing files, no '"'}

2. Numbered registers "0 to "9		*quote_number* *quote0* *quote1*
					*quote2* *quote3* *quote4* *quote9*
Vim fills these registers with text from yank and delete commands.
   Numbered register 0 contains the text from the most recent yank command,
unless the command specified another register with ["x].
   Numbered register 1 contains the text deleted by the most recent delete or
change command, unless the command specified another register or the text is
less than one line (the small delete register is used then).  An exception is
made for the delete operator with these movement commands: |%|, |(|, |)|, |`|,
|/|, |?|, |n|, |N|, |{| and |}|.  Register "1 is always used then (this is Vi
compatible).  The "- register is used as well if the delete is within a line.
Note that these characters may be mapped.  E.g. |%| is mapped by the matchit
plugin.
   With each successive deletion or change, Vim shifts the previous contents
of register 1 into register 2, 2 into 3, and so forth, losing the previous
contents of register 9.
{Vi: numbered register contents are lost when changing files; register 0 does
not exist}

3. Small delete register "-				*quote_-* *quote-*
This register contains text from commands that delete less than one line,
except when the command specifies a register with ["x].

4. Named registers "a to "z or "A to "Z			*quote_alpha* *quotea*
Vim fills these registers only when you say so.  Specify them as lowercase
letters to replace their previous contents or as uppercase letters to append
to their previous contents.  When the '>' flag is present in 'cpoptions' then
a line break is inserted before the appended text.

5. Read-only registers ":, ". and "%
These are '%', ':' and '.'.  You can use them only with the "p", "P",
and ":put" commands and with CTRL-R.
						*quote_.* *quote.* *E29*
	".	Contains the last inserted text (the same as what is inserted
		with the insert mode commands CTRL-A and CTRL-@).  Note: this
		doesn't work with CTRL-R on the command-line.  It works a bit
		differently, like inserting the text instead of putting it
		('textwidth' and other options affect what is inserted).
							*quote_%* *quote%*
	"%	Contains the name of the current file.
						*quote_:* *quote:* *E30*
	":	Contains the most recent executed command-line.  Example: Use
		"@:" to repeat the previous command-line command.
		The command-line is only stored in this register when at least
		one character of it was typed.  Thus it remains unchanged if
		the command was completely from a mapping.
		{not available when compiled without the |+cmdline_hist|
		feature}
							*quote_#* *quote#*
6. Alternate file register "#
Contains the name of the alternate file for the current window.  It will
change how the |CTRL-^| command works.
This register is writable, mainly to allow for restoring it after a plugin has
changed it.  It accepts buffer number: >
    let altbuf = bufnr(@#)
    ...
    let @# = altbuf
It will give error |E86| if you pass buffer number and this buffer does not
exist.
It can also accept a match with an existing buffer name: >
    let @# = 'buffer_name'
Error |E93| if there is more than one buffer matching the given name or |E94|
if none of buffers matches the given name.

7. Expression register "=			*quote_=* *quote=* *@=*
This is not really a register that stores text, but is a way to use an
expression in commands which use a register.  The expression register is
read-write.

When typing the '=' after " or CTRL-R the cursor moves to the command-line,
where you can enter any expression (see |expression|).  All normal
command-line editing commands are available, including a special history for
expressions.  When you end the command-line by typing <CR>, Vim computes the
result of the expression.  If you end it with <Esc>, Vim abandons the
expression.  If you do not enter an expression, Vim uses the previous
expression (like with the "/" command).

The expression must evaluate to a String.  A Number is always automatically
converted to a String.  For the "p" and ":put" command, if the result is a
Float it's converted into a String.  If the result is a List each element is
turned into a String and used as a line.  A Dictionary or FuncRef results in
an error message (use string() to convert).

If the "= register is used for the "p" command, the String is split up at <NL>
characters.  If the String ends in a <NL>, it is regarded as a linewise
register.

8. Selection and drop registers "*, "+ and "~ 
Use these registers for storing and retrieving the selected text for the GUI.
See |quotestar| and |quoteplus|.  When the clipboard is not available or not
working, the unnamed register is used instead.  For Unix systems the clipboard
is only available when the |+xterm_clipboard| feature is present.

Note that there is only a distinction between "* and "+ for X11 systems.  For
an explanation of the difference, see |x11-selection|.  Under MS-Windows, use
of "* and "+ is actually synonymous and refers to the |gui-clipboard|.

						*quote_~* *quote~* *<Drop>*
The read-only "~ register stores the dropped text from the last drag'n'drop
operation.  When something has been dropped onto Vim, the "~ register is
filled in and the <Drop> pseudo key is sent for notification.  You can remap
this key if you want; the default action (for all modes) is to insert the
contents of the "~ register at the cursor position.
{only available when compiled with the |+dnd| feature, currently only with the
GTK GUI}

Note: The "~ register is only used when dropping plain text onto Vim.
Drag'n'drop of URI lists is handled internally.

9. Black hole register "_				*quote_*
When writing to this register, nothing happens.  This can be used to delete
text without affecting the normal registers.  When reading from this register,
nothing is returned.

10. Last search pattern register	"/		*quote_/* *quote/*
Contains the most recent search-pattern.  This is used for "n" and 'hlsearch'.
It is writable with `:let`, you can change it to have 'hlsearch' highlight
other matches without actually searching.  You can't yank or delete into this
register.  The search direction is available in |v:searchforward|.
Note that the value is restored when returning from a function
|function-search-undo|.

							*@/*
You can write to a register with a `:let` command |:let-@|.  Example: >
	:let @/ = "the"

If you use a put command without specifying a register, Vim uses the register
that was last filled (this is also the contents of the unnamed register).  If
you are confused, use the `:dis` command to find out what Vim will put (this
command displays all named and numbered registers; the unnamed register is
labelled '"').

The next three commands always work on whole lines.

:[range]co[py] {address}				*:co* *:copy*
			Copy the lines given by [range] to below the line
			given by {address}.

							*:t*
:t			Synonym for copy.
			This command is not supported in |Vim9| script,
			because it is too easily confused with a variable
			name.

:[range]m[ove] {address}			*:m* *:mo* *:move* *E134*
			Move the lines given by [range] to below the line
			given by {address}.

==============================================================================
6. Formatting text					*formatting*

:[range]ce[nter] [width]				*:ce* *:center*
			Center lines in [range] between [width] columns
			(default 'textwidth' or 80 when 'textwidth' is 0).

:[range]ri[ght] [width]					*:ri* *:right*
			Right-align lines in [range] at [width] columns
			(default 'textwidth' or 80 when 'textwidth' is 0).

							*:le* *:left*
:[range]le[ft] [indent]
			Left-align lines in [range].  Sets the indent in the
			lines to [indent] (default 0).

							*gq*
gq{motion}		Format the lines that {motion} moves over.
			Formatting is done with one of three methods:
			1. If 'formatexpr' is not empty the expression is
			   evaluated.  This can differ for each buffer.
			2. If 'formatprg' is not empty an external program
			   is used.
			3. Otherwise formatting is done internally.

			In the third case the 'textwidth' option controls the
			length of each formatted line (see below).
			If the 'textwidth' option is 0, the formatted line
			length is the screen width (with a maximum width of
			79).
			The 'formatoptions' option controls the type of
			formatting |fo-table|.
			The cursor is left on the first non-blank of the last
			formatted line.
			NOTE: The "Q" command formerly performed this
			function.  If you still want to use "Q" for
			formatting, use this mapping: >
				:nnoremap Q gq

gqgq							*gqgq* *gqq*
gqq			Format the current line.  With a count format that
			many lines.

							*v_gq*
{Visual}gq		Format the highlighted text.  (for {Visual} see
			|Visual-mode|).

							*gw*
gw{motion}		Format the lines that {motion} moves over.  Similar to
			|gq| but puts the cursor back at the same position in
			the text.  However, 'formatprg' and 'formatexpr' are
			not used.

gwgw							*gwgw* *gww*
gww			Format the current line as with "gw".

							*v_gw*
{Visual}gw		Format the highlighted text as with "gw".  (for
			{Visual} see |Visual-mode|).

Example: To format the current paragraph use:			*gqap*  >
	gqap

The "gq" command leaves the cursor in the line where the motion command takes
the cursor.  This allows you to repeat formatting repeated with ".".  This
works well with "gqj" (format current and next line) and "gq}" (format until
end of paragraph).  Note: When 'formatprg' is set, "gq" leaves the cursor on
the first formatted line (as with using a filter command).

If you want to format the current paragraph and continue where you were, use: >
	gwap
If you always want to keep paragraphs formatted you may want to add the 'a'
flag to 'formatoptions'.  See |auto-format|.

If the 'autoindent' option is on, Vim uses the indent of the first line for
the following lines.

Formatting does not change empty lines (but it does change lines with only
white space!).

The 'joinspaces' option is used when lines are joined together.

You can set the 'formatexpr' option to an expression or the 'formatprg' option
to the name of an external program for Vim to use for text formatting.  The
'textwidth' and other options have no effect on formatting by an external
program.

                                                        *format-formatexpr*
The 'formatexpr' option can be set to a Vim script function that performs
reformatting of the buffer.  This should usually happen in an |ftplugin|,
since formatting is highly dependent on the type of file.  It makes
sense to use an |autoload| script, so the corresponding script is only loaded
when actually needed and the script should be called <filetype>format.vim.

For example, the XML filetype plugin distributed with Vim in the $VIMRUNTIME
directory, sets the 'formatexpr' option to: >

   setlocal formatexpr=xmlformat#Format()

That means, you will find the corresponding script, defining the
xmlformat#Format() function, in the directory:
`$VIMRUNTIME/autoload/xmlformat.vim`

Here is an example script that removes trailing whitespace from the selected
text.  Put it in your autoload directory, e.g. ~/.vim/autoload/format.vim: >

  func! format#Format()
    " only reformat on explicit gq command
    if mode() != 'n'
      " fall back to Vim's internal reformatting
      return 1
    endif
    let lines = getline(v:lnum, v:lnum + v:count - 1)
    call map(lines, {key, val -> substitute(val, '\s\+$', '', 'g')})
    call setline('.', lines)

    " do not run internal formatter!
    return 0
  endfunc

You can then enable the formatting by executing: >
  setlocal formatexpr=format#Format()

Note: this function explicitly returns non-zero when called from insert mode
(which basically means, text is inserted beyond the 'textwidth' limit).  This
causes Vim to fall back to reformat the text by using the internal formatter.

However, if the |gq| command is used to reformat the text, the function
will receive the selected lines, trim trailing whitespace from those lines and
put them back in place.  If you are going to split single lines into multiple
lines, be careful not to overwrite anything.

If you want to allow reformatting of text from insert or replace mode, one has
to be very careful, because the function might be called recursively.  For
debugging it helps to set the 'debug' option.

							*right-justify*
There is no command in Vim to right justify text.  You can do it with
an external command, like "par" (e.g.: "!}par" to format until the end of the
paragraph) or set 'formatprg' to "par".

							*format-comments*
An overview of comment formatting is in section |30.6| of the user manual.

Vim can automatically insert and format comments in a special way.  Vim
recognizes a comment by a specific string at the start of the line (ignoring
white space).  Three types of comments can be used:

- A comment string that repeats at the start of each line.  An example is the
  type of comment used in shell scripts, starting with "#".
- A comment string that occurs only in the first line, not in the following
  lines.  An example is this list with dashes.
- Three-piece comments that have a start string, an end string, and optional
  lines in between.  The strings for the start, middle and end are different.
  An example is the C style comment:
	/*
	 * this is a C comment
	 */

The 'comments' option is a comma-separated list of parts.  Each part defines a
type of comment string.  A part consists of:
	{flags}:{string}

{string} is the literal text that must appear.

{flags}:
  n	Nested comment.  Nesting with mixed parts is allowed.  If 'comments'
	is "n:),n:>" a line starting with "> ) >" is a comment.

  b	Blank (<Space>, <Tab> or <EOL>) required after {string}.

  f	Only the first line has the comment string.  Do not repeat comment on
	the next line, but preserve indentation (e.g., a bullet-list).

  s	Start of three-piece comment

  m	Middle of a three-piece comment

  e	End of a three-piece comment

  l	Left align. Used together with 's' or 'e', the leftmost character of
	start or end will line up with the leftmost character from the middle.
	This is the default and can be omitted. See below for more details.

  r	Right align. Same as above but rightmost instead of leftmost. See
	below for more details.

  O	Don't consider this comment for the "O" command.

  x	Allows three-piece comments to be ended by just typing the last
	character of the end-comment string as the first action on a new
	line when the middle-comment string has been inserted automatically.
	See below for more details.

  {digits}
	When together with 's' or 'e': add {digit} amount of offset to an
	automatically inserted middle or end comment leader. The offset begins
	from a left alignment. See below for more details.

  -{digits}
	Like {digits} but reduce the indent.  This only works when there is
	some indent for the start or end part that can be removed.

When a string has none of the 'f', 's', 'm' or 'e' flags, Vim assumes the
comment string repeats at the start of each line.  The flags field may be
empty.

Any blank space in the text before and after the {string} is part of the
{string}, so do not include leading or trailing blanks unless the blanks are a
required part of the comment string.

When one comment leader is part of another, specify the part after the whole.
For example, to include both "-" and "->", use >
	:set comments=f:->,f:-

A three-piece comment must always be given as start,middle,end, with no other
parts in between.  An example of a three-piece comment is >
	sr:/*,mb:*,ex:*/
for C-comments.  To avoid recognizing "*ptr" as a comment, the middle string
includes the 'b' flag.  For three-piece comments, Vim checks the text after
the start and middle strings for the end string.  If Vim finds the end string,
the comment does not continue on the next line.  Three-piece comments must
have a middle string because otherwise Vim can't recognize the middle lines.

Notice the use of the "x" flag in the above three-piece comment definition.
When you hit Return in a C-comment, Vim will insert the middle comment leader
for the new line: " * ".  To close this comment you just have to type "/"
before typing anything else on the new line.  This will replace the
middle-comment leader with the end-comment leader and apply any specified
alignment, leaving just " */".  There is no need to hit Backspace first.

When there is a match with a middle part, but there also is a matching end
part which is longer, the end part is used.  This makes a C style comment work
without requiring the middle part to end with a space.

Here is an example of alignment flags at work to make a comment stand out
(kind of looks like a 1 too). Consider comment string: >
	:set comments=sr:/***,m:**,ex-2:******/
<
                                   /*** ~
                                     **<--right aligned from "r" flag ~
                                     ** ~
offset 2 spaces for the "-2" flag--->** ~
                                   ******/ ~
In this case, the first comment was typed, then return was pressed 4 times,
then "/" was pressed to end the comment.

Here are some finer points of three part comments. There are three times when
alignment and offset flags are taken into consideration: opening a new line
after a start-comment, opening a new line before an end-comment, and
automatically ending a three-piece comment.  The end alignment flag has a
backwards perspective; the result is that the same alignment flag used with
"s" and "e" will result in the same indent for the starting and ending pieces.
Only one alignment per comment part is meant to be used, but an offset number
will override the "r" and "l" flag.

Enabling 'cindent' will override the alignment flags in many cases.
Reindenting using a different method like |gq| or |=| will not consult
alignment flags either. The same behaviour can be defined in those other
formatting options. One consideration is that 'cindent' has additional options
for context based indenting of comments but cannot replicate many three piece
indent alignments.  However, 'indentexpr' has the ability to work better with
three piece comments.

Other examples: >
   "b:*"	Includes lines starting with "*", but not if the "*" is
		followed by a non-blank.  This avoids a pointer dereference
		like "*str" to be recognized as a comment.
   "n:>"	Includes a line starting with ">", ">>", ">>>", etc.
   "fb:-"	Format a list that starts with "- ".

By default, "b:#" is included.  This means that a line that starts with
"#include" is not recognized as a comment line.  But a line that starts with
"# define" is recognized.  This is a compromise.

							*fo-table*
You can use the 'formatoptions' option  to influence how Vim formats text.
'formatoptions' is a string that can contain any of the letters below.  The
default setting is "tcq".  You can separate the option letters with commas for
readability.

letter	 meaning when present in 'formatoptions'    ~
							*fo-t*
t	Auto-wrap text using 'textwidth'
							*fo-c*
c	Auto-wrap comments using 'textwidth', inserting the current comment
	leader automatically.
							*fo-r*
r	Automatically insert the current comment leader after hitting
	<Enter> in Insert mode.
							*fo-o*
o	Automatically insert the current comment leader after hitting 'o' or
	'O' in Normal mode.  In case comment is unwanted in a specific place
	use CTRL-U to quickly delete it. |i_CTRL-U|
							*fo-/*
/	When 'o' is included: do not insert the comment leader for a //
	comment after a statement, only when // is at the start of the line.
							*fo-q*
q	Allow formatting of comments with "gq".
	Note that formatting will not change blank lines or lines containing
	only the comment leader.  A new paragraph starts after such a line,
	or when the comment leader changes.
							*fo-w*
w	Trailing white space indicates a paragraph continues in the next line.
	A line that ends in a non-white character ends a paragraph.
							*fo-a*
a	Automatic formatting of paragraphs.  Every time text is inserted or
	deleted the paragraph will be reformatted.  See |auto-format|.
	When the 'c' flag is present this only happens for recognized
	comments.
							*fo-n*
n	When formatting text, recognize numbered lists.  This actually uses
	the 'formatlistpat' option, thus any kind of list can be used.  The
	indent of the text after the number is used for the next line.  The
	default is to find a number, optionally followed by '.', ':', ')',
	']' or '}'.  Note that 'autoindent' must be set too.  Doesn't work
	well together with "2".
	Example: >
		1. the first item
		   wraps
		2. the second item
<							*fo-2*
2	When formatting text, use the indent of the second line of a paragraph
	for the rest of the paragraph, instead of the indent of the first
	line.  This supports paragraphs in which the first line has a
	different indent than the rest.  Note that 'autoindent' must be set
	too.  Example: >
			first line of a paragraph
		second line of the same paragraph
		third line.
<	This also works inside comments, ignoring the comment leader.
							*fo-v*
v	Vi-compatible auto-wrapping in insert mode: Only break a line at a
	blank that you have entered during the current insert command.  (Note:
	this is not 100% Vi compatible.  Vi has some "unexpected features" or
	bugs in this area.  It uses the screen column instead of the line
	column.)
							*fo-b*
b	Like 'v', but only auto-wrap if you enter a blank at or before
	the wrap margin.  If the line was longer than 'textwidth' when you
	started the insert, or you do not enter a blank in the insert before
	reaching 'textwidth', Vim does not perform auto-wrapping.
							*fo-l*
l	Long lines are not broken in insert mode: When a line was longer than
	'textwidth' when the insert command started, Vim does not
	automatically format it.
							*fo-m*
m	Also break at a multibyte character above 255.  This is useful for
	Asian text where every character is a word on its own.
							*fo-M*
M	When joining lines, don't insert a space before or after a multibyte
	character.  Overrules the 'B' flag.
							*fo-B*
B	When joining lines, don't insert a space between two multibyte
	characters.  Overruled by the 'M' flag.
							*fo-1*
1	Don't break a line after a one-letter word.  It's broken before it
	instead (if possible).
							*fo-]*
]	Respect 'textwidth' rigorously. With this flag set, no line can be
	longer than 'textwidth', unless line-break-prohibition rules make this
	impossible.  Mainly for CJK scripts and works only if 'encoding' is
	"utf-8".
							*fo-j*
j	Where it makes sense, remove a comment leader when joining lines.  For
	example, joining:
		int i;   // the index ~
		         // in the list ~
	Becomes:
		int i;   // the index in the list ~
							*fo-p*
p	Don't break lines at single spaces that follow periods.  This is
	intended to complement 'joinspaces' and |cpo-J|, for prose with
	sentences separated by two spaces.  For example, with 'textwidth' set
	to 28: >
		Surely you're joking, Mr. Feynman!
<	Becomes: >
		Surely you're joking,
		Mr. Feynman!
<	Instead of: >
		Surely you're joking, Mr.
		Feynman!


With 't' and 'c' you can specify when Vim performs auto-wrapping:
value	action	~
""	no automatic formatting (you can use "gq" for manual formatting)
"t"	automatic formatting of text, but not comments
"c"	automatic formatting for comments, but not text (good for C code)
"tc"	automatic formatting for text and comments

Note that when 'textwidth' is 0, Vim does no automatic formatting anyway (but
does insert comment leaders according to the 'comments' option).  An exception
is when the 'a' flag is present. |auto-format|

Note that when 'paste' is on, Vim does no formatting at all.

Note that 'textwidth' can be non-zero even if Vim never performs auto-wrapping;
'textwidth' is still useful for formatting with "gq".

If the 'comments' option includes "/*", "*" and/or "*/", then Vim has some
built in stuff to treat these types of comments a bit more cleverly.
Opening a new line before or after "/*" or "*/" (with 'r' or 'o' present in
'formatoptions') gives the correct start of the line automatically.  The same
happens with formatting and auto-wrapping.  Opening a line after a line
starting with "/*" or "*" and containing "*/", will cause no comment leader to
be inserted, and the indent of the new line is taken from the line containing
the start of the comment.
E.g.:
    /* ~
     * Your typical comment. ~
     */ ~
    The indent on this line is the same as the start of the above
    comment.

All of this should be really cool, especially in conjunction with the new
:autocmd command to prepare different settings for different types of file.

Some examples:
  for C code (only format comments): >
	:set fo=croq
< for Mail/news	(format all, don't start comment with "o" command): >
	:set fo=tcrq
<

Automatic formatting				*auto-format* *autoformat*

When the 'a' flag is present in 'formatoptions' text is formatted
automatically when inserting text or deleting text.  This works nicely for
editing text paragraphs.  A few hints on how to use this:

- You need to properly define paragraphs.  The simplest is paragraphs that are
  separated by a blank line.  When there is no separating blank line, consider
  using the 'w' flag and adding a space at the end of each line in the
  paragraphs except the last one.

- You can set the 'formatoptions' based on the type of file |filetype| or
  specifically for one file with a |modeline|.

- Set 'formatoptions' to "aw2tq" to make text with indents like this:

	    bla bla foobar bla 
	bla foobar bla foobar bla
	    bla bla foobar bla 
	bla foobar bla bla foobar

- Add the 'c' flag to only auto-format comments.  Useful in source code.

- Set 'textwidth' to the desired width.  If it is zero then 79 is used, or the
  width of the screen if this is smaller.

And a few warnings:

- When part of the text is not properly separated in paragraphs, making
  changes in this text will cause it to be formatted anyway.  Consider doing >

	:set fo-=a

- When using the 'w' flag (trailing space means paragraph continues) and
  deleting the last line of a paragraph with |dd|, the paragraph will be
  joined with the next one.

- Changed text is saved for undo.  Formatting is also a change.  Thus each
  format action saves text for undo.  This may consume quite a lot of memory.

- Formatting a long paragraph and/or with complicated indenting may be slow.

==============================================================================
7. Sorting text						*sorting*

Vim has a sorting function and a sorting command.  The sorting function can be
found here: |sort()|, |uniq()|.

							*:sor* *:sort*
:[range]sor[t][!] [b][f][i][l][n][o][r][u][x] [/{pattern}/]
			Sort lines in [range].  When no range is given all
			lines are sorted.

			With [!] the order is reversed.

			With [i] case is ignored.

			With [l] sort uses the current collation locale.
			Implementation details: strcoll() is used to compare
			strings. See |:language| to check or set the collation
			locale. Example: >
				:language collate en_US.UTF-8
				:%sort l
<			|v:collate| can also used to check the current locale.
			Sorting using the locale typically ignores case.
			This does not work properly on Mac.

			Options [n][f][x][o][b] are mutually exclusive.

			With [n] sorting is done on the first decimal number
			in the line (after or inside a {pattern} match).
			One leading '-' is included in the number.

			With [f] sorting is done on the Float in the line.
			The value of Float is determined similar to passing
			the text (after or inside a {pattern} match) to
			str2float() function. This option is available only
			if Vim was compiled with Floating point support.

			With [x] sorting is done on the first hexadecimal
			number in the line (after or inside a {pattern}
			match).  A leading "0x" or "0X" is ignored.
			One leading '-' is included in the number.

			With [o] sorting is done on the first octal number in
			the line (after or inside a {pattern} match).

			With [b] sorting is done on the first binary number in
			the line (after or inside a {pattern} match).

			With [u] (u stands for unique) only keep the first of
			a sequence of identical lines (ignoring case when [i]
			is used).  Without this flag, a sequence of identical
			lines will be kept in their original order.
			Note that leading and trailing white space may cause
			lines to be different.

			When /{pattern}/ is specified and there is no [r] flag
			the text matched with {pattern} is skipped, so that
			you sort on what comes after the match.
			'ignorecase' applies to the pattern, but 'smartcase'
			is not used.
			Instead of the slash any non-letter can be used.
			For example, to sort on the second comma-separated
			field: >
				:sort /[^,]*,/
<			To sort on the text at virtual column 10 (thus
			ignoring the difference between tabs and spaces): >
				:sort /.*\%10v/
<			To sort on the first number in the line, no matter
			what is in front of it: >
				:sort /.\{-}\ze\d/
<			(Explanation: ".\{-}" matches any text, "\ze" sets the
			end of the match and \d matches a digit.)
			With [r] sorting is done on the matching {pattern}
			instead of skipping past it as described above.
			For example, to sort on only the first three letters
			of each line: >
				:sort /\a\a\a/ r

<			If a {pattern} is used, any lines which don't have a
			match for {pattern} are kept in their current order,
			but separate from the lines which do match {pattern}.
			If you sorted in reverse, they will be in reverse
			order after the sorted lines, otherwise they will be
			in their original order, right before the sorted
			lines.

			If {pattern} is empty (e.g. // is specified), the
			last search pattern is used.  This allows trying out
			a pattern first.

Note that using `:sort` with `:global` doesn't sort the matching lines, it's
quite useless.

`:sort` does not use the current locale unless the l flag is used.
Vim does do a "stable" sort.

The sorting can be interrupted, but if you interrupt it too late in the
process you may end up with duplicated lines.  This also depends on the system
library function used.

 vim:tw=78:ts=8:noet:ft=help:norl:
                                                                                                                                                                                                                                                                               usr/share/vim/vim90/doc/channel.txt                                                                 0000644 0000000 0000000 00000163333 14424703754 015657  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        *channel.txt*      For Vim version 9.0.  Last change: 2022 Dec 01


		  VIM REFERENCE MANUAL	  by Bram Moolenaar


		      Inter-process communication		*channel*

Vim uses channels to communicate with other processes.
A channel uses a socket or pipes.			*socket-interface*
Jobs can be used to start processes and communicate with them.
The Netbeans interface also uses a channel. |netbeans|

1. Overview				|job-channel-overview|
2. Channel demo				|channel-demo|
3. Opening a channel			|channel-open|
4. Using a JSON or JS channel		|channel-use|
5. Channel commands			|channel-commands|
6. Using a RAW or NL channel		|channel-raw|
7. More channel functions		|channel-more|
8. Channel functions details		|channel-functions-details|
9. Starting a job with a channel	|job-start|
10. Starting a job without a channel	|job-start-nochannel|
11. Job functions			|job-functions-details|
12. Job options				|job-options|
13. Controlling a job			|job-control|
14. Using a prompt buffer		|prompt-buffer|
15. Language Server Protocol		|language-server-protocol|

							*E1277*
{only when compiled with the |+channel| feature for channel stuff}
	You can check this with: `has('channel')`
{only when compiled with the |+job| feature for job stuff}
	You can check this with: `has('job')`

==============================================================================
1. Overview						*job-channel-overview*

There are four main types of jobs:
1. A daemon, serving several Vim instances.
   Vim connects to it with a socket.
2. One job working with one Vim instance, asynchronously.
   Uses a socket or pipes.
3. A job performing some work for a short time, asynchronously.
   Uses a socket or pipes.
4. Running a filter, synchronously.
   Uses pipes.

For when using sockets See |job-start|, |job-start-nochannel| and
|channel-open|.  For 2 and 3, one or more jobs using pipes, see |job-start|.
For 4 use the ":{range}!cmd" command, see |filter|.

Over the socket and pipes these protocols are available:
RAW	nothing known, Vim cannot tell where a message ends
NL	every message ends in a NL (newline) character
JSON	JSON encoding |json_encode()|
JS	JavaScript style JSON-like encoding |js_encode()|
LSP	Language Server Protocol encoding |language-server-protocol|

Common combination are:
- Using a job connected through pipes in NL mode.  E.g., to run a style
  checker and receive errors and warnings.
- Using a daemon, connecting over a socket in JSON mode.  E.g. to lookup
  cross-references in a database.

==============================================================================
2. Channel demo				*channel-demo* *demoserver.py*

This requires Python.  The demo program can be found in
$VIMRUNTIME/tools/demoserver.py
Run it in one terminal.  We will call this T1.

Run Vim in another terminal.  Connect to the demo server with: >
	let channel = ch_open('localhost:8765')

In T1 you should see:
	=== socket opened === ~

You can now send a message to the server: >
	echo ch_evalexpr(channel, 'hello!')

The message is received in T1 and a response is sent back to Vim.
You can see the raw messages in T1.  What Vim sends is:
	[1,"hello!"] ~
And the response is:
	[1,"got it"] ~
The number will increase every time you send a message.

The server can send a command to Vim.  Type this on T1 (literally, including
the quotes):
	["ex","echo 'hi there'"] ~
And you should see the message in Vim. You can move the cursor a word forward:
	["normal","w"] ~

To handle asynchronous communication a callback needs to be used: >
	func MyHandler(channel, msg)
	  echo "from the handler: " .. a:msg
	endfunc
	call ch_sendexpr(channel, 'hello!', {'callback': "MyHandler"})
Vim will not wait for a response.  Now the server can send the response later
and MyHandler will be invoked.

Instead of giving a callback with every send call, it can also be specified
when opening the channel: >
	call ch_close(channel)
	let channel = ch_open('localhost:8765', {'callback': "MyHandler"})
	call ch_sendexpr(channel, 'hello channel!')

When trying out channels it's useful to see what is going on.  You can tell
Vim to write lines in log file: >
	call ch_logfile('channellog', 'w')
See |ch_logfile()|.

==============================================================================
3. Opening a channel					*channel-open*

To open a channel: >
    let channel = ch_open({address} [, {options}])
    if ch_status(channel) == "open"
      " use the channel

Use |ch_status()| to see if the channel could be opened.

					*channel-address*
{address} can be a domain name or an IP address, followed by a port number, or
a Unix-domain socket path prefixed by "unix:".  E.g. >
    www.example.com:80   " domain + port
    127.0.0.1:1234       " IPv4 + port
    [2001:db8::1]:8765   " IPv6 + port
    unix:/tmp/my-socket  " Unix-domain socket path

{options} is a dictionary with optional entries:	*channel-open-options*

"mode" can be:						*channel-mode*
	"json" - Use JSON, see below; most convenient way. Default.
	"js"   - Use JS (JavaScript) encoding, more efficient than JSON.
	"nl"   - Use messages that end in a NL character
	"raw"  - Use raw messages
	"lsp"  - Use language server protocol encoding
						*channel-callback* *E921*
"callback"	A function that is called when a message is received that is
		not handled otherwise (e.g. a JSON message with ID zero).  It
		gets two arguments: the channel and the received message.
		Example: >
	func Handle(channel, msg)
	  echo 'Received: ' .. a:msg
	endfunc
	let channel = ch_open("localhost:8765", {"callback": "Handle"})
<
		When "mode" is "json" or "js" or "lsp" the "msg" argument is
		the body of the received message, converted to Vim types.
		When "mode" is "nl" the "msg" argument is one message,
		excluding the NL.
		When "mode" is "raw" the "msg" argument is the whole message
		as a string.

		For all callbacks: Use |function()| to bind it to arguments
		and/or a Dictionary.  Or use the form "dict.function" to bind
		the Dictionary.

		Callbacks are only called at a "safe" moment, usually when Vim
		is waiting for the user to type a character.  Vim does not use
		multi-threading.

							*close_cb*
"close_cb"	A function that is called when the channel gets closed, other
		than by calling ch_close().  It should be defined like this: >
	func MyCloseHandler(channel)
<		Vim will invoke callbacks that handle data before invoking
		close_cb, thus when this function is called no more data will
		be passed to the callbacks.  However, if a callback causes Vim
		to check for messages, the close_cb may be invoked while still
		in the callback.  The plugin must handle this somehow, it can
