 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, see <http://www.gnu.org/licenses/>.
 */

/*
 * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
 * file for a list of people on the GLib Team.  See the ChangeLog
 * files for a list of changes.  These files are distributed with
 * GLib at ftp://ftp.gtk.org/pub/gtk/.
 */

#ifndef __G_DEPRECATED_THREAD_H__
#define __G_DEPRECATED_THREAD_H__

#if !defined (__GLIB_H_INSIDE__) && !defined (GLIB_COMPILATION)
#error "Only <glib.h> can be included directly."
#endif

#include <glib/gthread.h>

G_BEGIN_DECLS

G_GNUC_BEGIN_IGNORE_DEPRECATIONS

typedef enum
{
  G_THREAD_PRIORITY_LOW,
  G_THREAD_PRIORITY_NORMAL,
  G_THREAD_PRIORITY_HIGH,
  G_THREAD_PRIORITY_URGENT
} GThreadPriority GLIB_DEPRECATED_TYPE_IN_2_32;

struct  _GThread
{
  /*< private >*/
  GThreadFunc func;
  gpointer data;
  gboolean joinable;
  GThreadPriority priority;
};

typedef struct _GThreadFunctions GThreadFunctions GLIB_DEPRECATED_TYPE_IN_2_32;
struct _GThreadFunctions
{
  GMutex*  (*mutex_new)           (void);
  void     (*mutex_lock)          (GMutex               *mutex);
  gboolean (*mutex_trylock)       (GMutex               *mutex);
  void     (*mutex_unlock)        (GMutex               *mutex);
  void     (*mutex_free)          (GMutex               *mutex);
  GCond*   (*cond_new)            (void);
  void     (*cond_signal)         (GCond                *cond);
  void     (*cond_broadcast)      (GCond                *cond);
  void     (*cond_wait)           (GCond                *cond,
                                   GMutex               *mutex);
  gboolean (*cond_timed_wait)     (GCond                *cond,
                                   GMutex               *mutex,
                                   GTimeVal             *end_time);
  void      (*cond_free)          (GCond                *cond);
  GPrivate* (*private_new)        (GDestroyNotify        destructor);
  gpointer  (*private_get)        (GPrivate             *private_key);
  void      (*private_set)        (GPrivate             *private_key,
                                   gpointer              data);
  void      (*thread_create)      (GThreadFunc           func,
                                   gpointer              data,
                                   gulong                stack_size,
                                   gboolean              joinable,
                                   gboolean              bound,
                                   GThreadPriority       priority,
                                   gpointer              thread,
                                   GError              **error);
  void      (*thread_yield)       (void);
  void      (*thread_join)        (gpointer              thread);
  void      (*thread_exit)        (void);
  void      (*thread_set_priority)(gpointer              thread,
                                   GThreadPriority       priority);
  void      (*thread_self)        (gpointer              thread);
  gboolean  (*thread_equal)       (gpointer              thread1,
                                   gpointer              thread2);
} GLIB_DEPRECATED_TYPE_IN_2_32;

GLIB_VAR GThreadFunctions       g_thread_functions_for_glib_use;
GLIB_VAR gboolean               g_thread_use_default_impl;

GLIB_VAR guint64   (*g_thread_gettime) (void);

GLIB_DEPRECATED_IN_2_32_FOR(g_thread_new)
GThread *g_thread_create       (GThreadFunc       func,
                                gpointer          data,
                                gboolean          joinable,
                                GError          **error);

GLIB_DEPRECATED_IN_2_32_FOR(g_thread_new)
GThread *g_thread_create_full  (GThreadFunc       func,
                                gpointer          data,
                                gulong            stack_size,
                                gboolean          joinable,
                                gboolean          bound,
                                GThreadPriority   priority,
                                GError          **error);

GLIB_DEPRECATED_IN_2_32
void     g_thread_set_priority (GThread          *thread,
                                GThreadPriority   priority);

GLIB_DEPRECATED_IN_2_32
void     g_thread_foreach      (GFunc             thread_func,
                                gpointer          user_data);

#ifndef G_OS_WIN32
#include <sys/types.h>
#include <pthread.h>
#endif

#define g_static_mutex_get_mutex g_static_mutex_get_mutex_impl GLIB_DEPRECATED_MACRO_IN_2_32
#ifndef G_OS_WIN32
#define G_STATIC_MUTEX_INIT { NULL, PTHREAD_MUTEX_INITIALIZER } GLIB_DEPRECATED_MACRO_IN_2_32_FOR(g_mutex_init)
#else
#define G_STATIC_MUTEX_INIT { NULL } GLIB_DEPRECATED_MACRO_IN_2_32_FOR(g_mutex_init)
#endif
typedef struct
{
  GMutex *mutex;
#ifndef G_OS_WIN32
  /* only for ABI compatibility reasons */
  pthread_mutex_t unused;
#endif
} GStaticMutex GLIB_DEPRECATED_TYPE_IN_2_32_FOR(GMutex);

#define g_static_mutex_lock(mutex) \
    g_mutex_lock (g_static_mutex_get_mutex (mutex)) GLIB_DEPRECATED_MACRO_IN_2_32_FOR(g_mutex_lock)
#define g_static_mutex_trylock(mutex) \
    g_mutex_trylock (g_static_mutex_get_mutex (mutex)) GLIB_DEPRECATED_MACRO_IN_2_32_FOR(g_mutex_trylock)
#define g_static_mutex_unlock(mutex) \
    g_mutex_unlock (g_static_mutex_get_mutex (mutex)) GLIB_DEPRECATED_MACRO_IN_2_32_FOR(g_mutex_unlock)

GLIB_DEPRECATED_IN_2_32_FOR(g_mutex_init)
void    g_static_mutex_init           (GStaticMutex *mutex);
GLIB_DEPRECATED_IN_2_32_FOR(g_mutex_clear)
void    g_static_mutex_free           (GStaticMutex *mutex);
GLIB_DEPRECATED_IN_2_32_FOR(GMutex)
GMutex *g_static_mutex_get_mutex_impl (GStaticMutex *mutex);

typedef struct _GStaticRecMutex GStaticRecMutex GLIB_DEPRECATED_TYPE_IN_2_32_FOR(GRecMutex);
struct _GStaticRecMutex
{
  /*< private >*/
  GStaticMutex mutex;
  guint depth;

  /* ABI compat only */
  union {
#ifdef G_OS_WIN32
    void *owner;
#else
    pthread_t owner;
#endif
    gdouble dummy;
  } unused;
} GLIB_DEPRECATED_TYPE_IN_2_32_FOR(GRecMutex);

#define G_STATIC_REC_MUTEX_INIT { G_STATIC_MUTEX_INIT, 0, { 0 } } GLIB_DEPRECATED_MACRO_IN_2_32_FOR(g_rec_mutex_init)
GLIB_DEPRECATED_IN_2_32_FOR(g_rec_mutex_init)
void     g_static_rec_mutex_init        (GStaticRecMutex *mutex);

GLIB_DEPRECATED_IN_2_32_FOR(g_rec_mutex_lock)
void     g_static_rec_mutex_lock        (GStaticRecMutex *mutex);

GLIB_DEPRECATED_IN_2_32_FOR(g_rec_mutex_try_lock)
gboolean g_static_rec_mutex_trylock     (GStaticRecMutex *mutex);

GLIB_DEPRECATED_IN_2_32_FOR(g_rec_mutex_unlock)
void     g_static_rec_mutex_unlock      (GStaticRecMutex *mutex);

GLIB_DEPRECATED_IN_2_32
void     g_static_rec_mutex_lock_full   (GStaticRecMutex *mutex,
                                         guint            depth);

GLIB_DEPRECATED_IN_2_32
guint    g_static_rec_mutex_unlock_full (GStaticRecMutex *mutex);

GLIB_DEPRECATED_IN_2_32_FOR(g_rec_mutex_free)
void     g_static_rec_mutex_free        (GStaticRecMutex *mutex);

typedef struct _GStaticRWLock GStaticRWLock GLIB_DEPRECATED_TYPE_IN_2_32_FOR(GRWLock);
struct _GStaticRWLock
{
  /*< private >*/
  GStaticMutex mutex;
  GCond *read_cond;
  GCond *write_cond;
  guint read_counter;
  gboolean have_writer;
  guint want_to_read;
  guint want_to_write;
} GLIB_DEPRECATED_TYPE_IN_2_32_FOR(GRWLock);

#define G_STATIC_RW_LOCK_INIT { G_STATIC_MUTEX_INIT, NULL, NULL, 0, FALSE, 0, 0 } GLIB_DEPRECATED_MACRO_IN_2_32_FOR(g_rw_lock_init)

GLIB_DEPRECATED_IN_2_32_FOR(g_rw_lock_init)
void      g_static_rw_lock_init           (GStaticRWLock *lock);

GLIB_DEPRECATED_IN_2_32_FOR(g_rw_lock_reader_lock)
void      g_static_rw_lock_reader_lock    (GStaticRWLock *lock);

GLIB_DEPRECATED_IN_2_32_FOR(g_rw_lock_reader_trylock)
gboolean  g_static_rw_lock_reader_trylock (GStaticRWLock *lock);

GLIB_DEPRECATED_IN_2_32_FOR(g_rw_lock_reader_unlock)
void      g_static_rw_lock_reader_unlock  (GStaticRWLock *lock);

GLIB_DEPRECATED_IN_2_32_FOR(g_rw_lock_writer_lock)
void      g_static_rw_lock_writer_lock    (GStaticRWLock *lock);

GLIB_DEPRECATED_IN_2_32_FOR(g_rw_lock_writer_trylock)
gboolean  g_static_rw_lock_writer_trylock (GStaticRWLock *lock);

GLIB_DEPRECATED_IN_2_32_FOR(g_rw_lock_writer_unlock)
void      g_static_rw_lock_writer_unlock  (GStaticRWLock *lock);

GLIB_DEPRECATED_IN_2_32_FOR(g_rw_lock_free)
void      g_static_rw_lock_free           (GStaticRWLock *lock);

GLIB_DEPRECATED_IN_2_32
GPrivate *      g_private_new             (GDestroyNotify notify);

typedef struct _GStaticPrivate  GStaticPrivate GLIB_DEPRECATED_TYPE_IN_2_32_FOR(GPrivate);
struct _GStaticPrivate
{
  /*< private >*/
  guint index;
} GLIB_DEPRECATED_TYPE_IN_2_32_FOR(GPrivate);

#define G_STATIC_PRIVATE_INIT { 0 } GLIB_DEPRECATED_MACRO_IN_2_32_FOR(G_PRIVATE_INIT)
GLIB_DEPRECATED_IN_2_32
void     g_static_private_init           (GStaticPrivate *private_key);

GLIB_DEPRECATED_IN_2_32_FOR(g_private_get)
gpointer g_static_private_get            (GStaticPrivate *private_key);

GLIB_DEPRECATED_IN_2_32_FOR(g_private_set)
void     g_static_private_set            (GStaticPrivate *private_key,
                                          gpointer        data,
                                          GDestroyNotify  notify);

GLIB_DEPRECATED_IN_2_32
void     g_static_private_free           (GStaticPrivate *private_key);

GLIB_DEPRECATED_IN_2_32
gboolean g_once_init_enter_impl          (volatile gsize *location);

GLIB_DEPRECATED_IN_2_32
void     g_thread_init                   (gpointer vtable);
GLIB_DEPRECATED_IN_2_32
void    g_thread_init_with_errorcheck_mutexes (gpointer vtable);

GLIB_DEPRECATED_IN_2_32
gboolean g_thread_get_initialized        (void);

GLIB_VAR gboolean g_threads_got_initialized;

#define g_thread_supported()     (1) GLIB_DEPRECATED_MACRO_IN_2_32

GLIB_DEPRECATED_IN_2_32
GMutex *        g_mutex_new             (void);
GLIB_DEPRECATED_IN_2_32
void            g_mutex_free            (GMutex *mutex);
GLIB_DEPRECATED_IN_2_32
GCond *         g_cond_new              (void);
GLIB_DEPRECATED_IN_2_32
void            g_cond_free             (GCond  *cond);
GLIB_DEPRECATED_IN_2_32
gboolean        g_cond_timed_wait       (GCond          *cond,
                                         GMutex         *mutex,
                                         GTimeVal       *timeval);

G_GNUC_END_IGNORE_DEPRECATIONS

G_END_DECLS

#endif /* __G_DEPRECATED_THREAD_H__ */
                                                                                                                                     usr/include/glib-2.0/glib/galloca.h                                                                 0000644 0000000 0000000 00000012473 14375670023 015420  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* GLIB - Library of useful routines for C programming
 * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
 *
 * SPDX-License-Identifier: LGPL-2.1-or-later
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, see <http://www.gnu.org/licenses/>.
 */

/*
 * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
 * file for a list of people on the GLib Team.  See the ChangeLog
 * files for a list of changes.  These files are distributed with
 * GLib at ftp://ftp.gtk.org/pub/gtk/.
 */

#ifndef __G_ALLOCA_H__
#define __G_ALLOCA_H__

#if !defined (__GLIB_H_INSIDE__) && !defined (GLIB_COMPILATION)
#error "Only <glib.h> can be included directly."
#endif

#include <glib/gtypes.h>
#include <string.h>

#if defined(__BIONIC__) && defined (GLIB_HAVE_ALLOCA_H)
# include <alloca.h>
#elif defined(__GNUC__)
/* GCC does the right thing */
# undef alloca
# define alloca(size)   __builtin_alloca (size)
#elif defined (GLIB_HAVE_ALLOCA_H)
/* a native and working alloca.h is there */ 
# include <alloca.h>
#else /* !__GNUC__ && !GLIB_HAVE_ALLOCA_H */
# if defined(_MSC_VER) || defined(__DMC__)
#  include <malloc.h>
#  define alloca _alloca
# else /* !_MSC_VER && !__DMC__ */
#  ifdef _AIX
#   pragma alloca
#  else /* !_AIX */
#   ifndef alloca /* predefined by HP cc +Olibcalls */
G_BEGIN_DECLS
char *alloca ();
G_END_DECLS
#   endif /* !alloca */
#  endif /* !_AIX */
# endif /* !_MSC_VER && !__DMC__ */
#endif /* !__GNUC__ && !GLIB_HAVE_ALLOCA_H */

/**
 * g_alloca:
 * @size: number of bytes to allocate.
 * 
 * Allocates @size bytes on the stack; these bytes will be freed when the current
 * stack frame is cleaned up. This macro essentially just wraps the alloca()
 * function present on most UNIX variants.
 * Thus it provides the same advantages and pitfalls as alloca():
 *
 * - alloca() is very fast, as on most systems it's implemented by just adjusting
 *   the stack pointer register.
 *
 * - It doesn't cause any memory fragmentation, within its scope, separate alloca()
 *   blocks just build up and are released together at function end.
 *
 * - Allocation sizes have to fit into the current stack frame. For instance in a
 *   threaded environment on Linux, the per-thread stack size is limited to 2 Megabytes,
 *   so be sparse with alloca() uses.
 *
 * - Allocation failure due to insufficient stack space is not indicated with a %NULL
 *   return like e.g. with malloc(). Instead, most systems probably handle it the same
 *   way as out of stack space situations from infinite function recursion, i.e.
 *   with a segmentation fault.
 *
 * - Allowing @size to be specified by an untrusted party would allow for them
 *   to trigger a segmentation fault by specifying a large size, leading to a
 *   denial of service vulnerability. @size must always be entirely under the
 *   control of the program.
 *
 * - Special care has to be taken when mixing alloca() with GNU C variable sized arrays.
 *   Stack space allocated with alloca() in the same scope as a variable sized array
 *   will be freed together with the variable sized array upon exit of that scope, and
 *   not upon exit of the enclosing function scope.
 * 
 * Returns: space for @size bytes, allocated on the stack
 */
#define g_alloca(size)		 alloca (size)

/**
 * g_alloca0:
 * @size: number of bytes to allocate.
 *
 * Wraps g_alloca() and initializes allocated memory to zeroes.
 * If @size is `0` it returns %NULL.
 *
 * Note that the @size argument will be evaluated multiple times.
 *
 * Returns: (nullable) (transfer full): space for @size bytes, allocated on the stack
 *
 * Since: 2.72
 */
#define g_alloca0(size)  ((size) == 0 ? NULL : memset (g_alloca (size), 0, (size)))

/**
 * g_newa:
 * @struct_type: Type of memory chunks to be allocated
 * @n_structs: Number of chunks to be allocated
 * 
 * Wraps g_alloca() in a more typesafe manner.
 * 
 * As mentioned in the documentation for g_alloca(), @n_structs must always be
 * entirely under the control of the program, or you may introduce a denial of
 * service vulnerability. In addition, the multiplication of @struct_type by
 * @n_structs is not checked, so an overflow may lead to a remote code execution
 * vulnerability.
 *
 * Returns: Pointer to stack space for @n_structs chunks of type @struct_type
 */
#define g_newa(struct_type, n_structs)	((struct_type*) g_alloca (sizeof (struct_type) * (gsize) (n_structs)))

/**
 * g_newa0:
 * @struct_type: the type of the elements to allocate.
 * @n_structs: the number of elements to allocate.
 *
 * Wraps g_alloca0() in a more typesafe manner.
 *
 * Returns: (nullable) (transfer full): Pointer to stack space for @n_structs
 *   chunks of type @struct_type
 *
 * Since: 2.72
 */
#define g_newa0(struct_type, n_structs)  ((struct_type*) g_alloca0 (sizeof (struct_type) * (gsize) (n_structs)))

#endif /* __G_ALLOCA_H__ */
                                                                                                                                                                                                     usr/include/glib-2.0/glib/garray.h                                                                  0000644 0000000 0000000 00000026773 14375670023 015313  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* GLIB - Library of useful routines for C programming
 * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
 *
 * SPDX-License-Identifier: LGPL-2.1-or-later
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, see <http://www.gnu.org/licenses/>.
 */

/*
 * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
 * file for a list of people on the GLib Team.  See the ChangeLog
 * files for a list of changes.  These files are distributed with
 * GLib at ftp://ftp.gtk.org/pub/gtk/.
 */

#ifndef __G_ARRAY_H__
#define __G_ARRAY_H__

#if !defined (__GLIB_H_INSIDE__) && !defined (GLIB_COMPILATION)
#error "Only <glib.h> can be included directly."
#endif

#include <glib/gtypes.h>

G_BEGIN_DECLS

typedef struct _GBytes          GBytes;
typedef struct _GArray		GArray;
typedef struct _GByteArray	GByteArray;
typedef struct _GPtrArray	GPtrArray;

struct _GArray
{
  gchar *data;
  guint len;
};

struct _GByteArray
{
  guint8 *data;
  guint	  len;
};

struct _GPtrArray
{
  gpointer *pdata;
  guint	    len;
};

/* Resizable arrays. remove fills any cleared spot and shortens the
 * array, while preserving the order. remove_fast will distort the
 * order by moving the last element to the position of the removed.
 */

#define g_array_append_val(a,v)	  g_array_append_vals (a, &(v), 1)
#define g_array_prepend_val(a,v)  g_array_prepend_vals (a, &(v), 1)
#define g_array_insert_val(a,i,v) g_array_insert_vals (a, i, &(v), 1)
#define g_array_index(a,t,i)      (((t*) (void *) (a)->data) [(i)])

GLIB_AVAILABLE_IN_ALL
GArray* g_array_new               (gboolean          zero_terminated,
				   gboolean          clear_,
				   guint             element_size);
GLIB_AVAILABLE_IN_2_64
gpointer g_array_steal            (GArray           *array,
                                   gsize            *len);
GLIB_AVAILABLE_IN_ALL
GArray* g_array_sized_new         (gboolean          zero_terminated,
				   gboolean          clear_,
				   guint             element_size,
				   guint             reserved_size);
GLIB_AVAILABLE_IN_2_62
GArray* g_array_copy              (GArray           *array);
GLIB_AVAILABLE_IN_ALL
gchar*  g_array_free              (GArray           *array,
				   gboolean          free_segment);
GLIB_AVAILABLE_IN_ALL
GArray *g_array_ref               (GArray           *array);
GLIB_AVAILABLE_IN_ALL
void    g_array_unref             (GArray           *array);
GLIB_AVAILABLE_IN_ALL
guint   g_array_get_element_size  (GArray           *array);
GLIB_AVAILABLE_IN_ALL
GArray* g_array_append_vals       (GArray           *array,
				   gconstpointer     data,
				   guint             len);
GLIB_AVAILABLE_IN_ALL
GArray* g_array_prepend_vals      (GArray           *array,
				   gconstpointer     data,
				   guint             len);
GLIB_AVAILABLE_IN_ALL
GArray* g_array_insert_vals       (GArray           *array,
				   guint             index_,
				   gconstpointer     data,
				   guint             len);
GLIB_AVAILABLE_IN_ALL
GArray* g_array_set_size          (GArray           *array,
				   guint             length);
GLIB_AVAILABLE_IN_ALL
GArray* g_array_remove_index      (GArray           *array,
				   guint             index_);
GLIB_AVAILABLE_IN_ALL
GArray* g_array_remove_index_fast (GArray           *array,
				   guint             index_);
GLIB_AVAILABLE_IN_ALL
GArray* g_array_remove_range      (GArray           *array,
				   guint             index_,
				   guint             length);
GLIB_AVAILABLE_IN_ALL
void    g_array_sort              (GArray           *array,
				   GCompareFunc      compare_func);
GLIB_AVAILABLE_IN_ALL
void    g_array_sort_with_data    (GArray           *array,
				   GCompareDataFunc  compare_func,
				   gpointer          user_data);
GLIB_AVAILABLE_IN_2_62
gboolean g_array_binary_search    (GArray           *array,
                                   gconstpointer     target,
                                   GCompareFunc      compare_func,
                                   guint            *out_match_index);
GLIB_AVAILABLE_IN_ALL
void    g_array_set_clear_func    (GArray           *array,
                                   GDestroyNotify    clear_func);

/* Resizable pointer array.  This interface is much less complicated
 * than the above.  Add appends a pointer.  Remove fills any cleared 
 * spot and shortens the array. remove_fast will again distort order.  
 */
#define    g_ptr_array_index(array,index_) ((array)->pdata)[index_]
GLIB_AVAILABLE_IN_ALL
GPtrArray* g_ptr_array_new                (void);
GLIB_AVAILABLE_IN_ALL
GPtrArray* g_ptr_array_new_with_free_func (GDestroyNotify    element_free_func);
GLIB_AVAILABLE_IN_2_64
gpointer*   g_ptr_array_steal              (GPtrArray        *array,
                                            gsize            *len);
GLIB_AVAILABLE_IN_2_62
GPtrArray *g_ptr_array_copy               (GPtrArray        *array,
                                           GCopyFunc         func,
                                           gpointer          user_data);
GLIB_AVAILABLE_IN_ALL
GPtrArray* g_ptr_array_sized_new          (guint             reserved_size);
GLIB_AVAILABLE_IN_ALL
GPtrArray* g_ptr_array_new_full           (guint             reserved_size,
					   GDestroyNotify    element_free_func);
GLIB_AVAILABLE_IN_2_74
GPtrArray* g_ptr_array_new_null_terminated (guint          reserved_size,
                                            GDestroyNotify element_free_func,
                                            gboolean       null_terminated);
GLIB_AVAILABLE_IN_ALL
gpointer*  g_ptr_array_free               (GPtrArray        *array,
					   gboolean          free_seg);
GLIB_AVAILABLE_IN_ALL
GPtrArray* g_ptr_array_ref                (GPtrArray        *array);
GLIB_AVAILABLE_IN_ALL
void       g_ptr_array_unref              (GPtrArray        *array);
GLIB_AVAILABLE_IN_ALL
void       g_ptr_array_set_free_func      (GPtrArray        *array,
                                           GDestroyNotify    element_free_func);
GLIB_AVAILABLE_IN_ALL
void       g_ptr_array_set_size           (GPtrArray        *array,
					   gint              length);
GLIB_AVAILABLE_IN_ALL
gpointer   g_ptr_array_remove_index       (GPtrArray        *array,
					   guint             index_);
GLIB_AVAILABLE_IN_ALL
gpointer   g_ptr_array_remove_index_fast  (GPtrArray        *array,
					   guint             index_);
GLIB_AVAILABLE_IN_2_58
gpointer   g_ptr_array_steal_index        (GPtrArray        *array,
                                           guint             index_);
GLIB_AVAILABLE_IN_2_58
gpointer   g_ptr_array_steal_index_fast   (GPtrArray        *array,
                                           guint             index_);
GLIB_AVAILABLE_IN_ALL
gboolean   g_ptr_array_remove             (GPtrArray        *array,
					   gpointer          data);
GLIB_AVAILABLE_IN_ALL
gboolean   g_ptr_array_remove_fast        (GPtrArray        *array,
					   gpointer          data);
GLIB_AVAILABLE_IN_ALL
GPtrArray *g_ptr_array_remove_range       (GPtrArray        *array,
					   guint             index_,
					   guint             length);
GLIB_AVAILABLE_IN_ALL
void       g_ptr_array_add                (GPtrArray        *array,
					   gpointer          data);
GLIB_AVAILABLE_IN_2_62
void g_ptr_array_extend                   (GPtrArray        *array_to_extend,
                                           GPtrArray        *array,
                                           GCopyFunc         func,
                                           gpointer          user_data);
GLIB_AVAILABLE_IN_2_62
void g_ptr_array_extend_and_steal         (GPtrArray        *array_to_extend,
                                           GPtrArray        *array);
GLIB_AVAILABLE_IN_2_40
void       g_ptr_array_insert             (GPtrArray        *array,
                                           gint              index_,
                                           gpointer          data);
GLIB_AVAILABLE_IN_ALL
void       g_ptr_array_sort               (GPtrArray        *array,
					   GCompareFunc      compare_func);
GLIB_AVAILABLE_IN_ALL
void       g_ptr_array_sort_with_data     (GPtrArray        *array,
					   GCompareDataFunc  compare_func,
					   gpointer          user_data);
GLIB_AVAILABLE_IN_ALL
void       g_ptr_array_foreach            (GPtrArray        *array,
					   GFunc             func,
					   gpointer          user_data);
GLIB_AVAILABLE_IN_2_54
gboolean   g_ptr_array_find               (GPtrArray        *haystack,
                                           gconstpointer     needle,
                                           guint            *index_);
GLIB_AVAILABLE_IN_2_54
gboolean   g_ptr_array_find_with_equal_func (GPtrArray     *haystack,
                                             gconstpointer  needle,
                                             GEqualFunc     equal_func,
                                             guint         *index_);

GLIB_AVAILABLE_IN_2_74
gboolean   g_ptr_array_is_null_terminated (GPtrArray *array);

/* Byte arrays, an array of guint8.  Implemented as a GArray,
 * but type-safe.
 */

GLIB_AVAILABLE_IN_ALL
GByteArray* g_byte_array_new               (void);
GLIB_AVAILABLE_IN_ALL
GByteArray* g_byte_array_new_take          (guint8           *data,
                                            gsize             len);
GLIB_AVAILABLE_IN_2_64
guint8*     g_byte_array_steal             (GByteArray       *array,
                                            gsize            *len);
GLIB_AVAILABLE_IN_ALL
GByteArray* g_byte_array_sized_new         (guint             reserved_size);
GLIB_AVAILABLE_IN_ALL
guint8*     g_byte_array_free              (GByteArray       *array,
					    gboolean          free_segment);
GLIB_AVAILABLE_IN_ALL
GBytes*     g_byte_array_free_to_bytes     (GByteArray       *array);
GLIB_AVAILABLE_IN_ALL
GByteArray *g_byte_array_ref               (GByteArray       *array);
GLIB_AVAILABLE_IN_ALL
void        g_byte_array_unref             (GByteArray       *array);
GLIB_AVAILABLE_IN_ALL
GByteArray* g_byte_array_append            (GByteArray       *array,
					    const guint8     *data,
					    guint             len);
GLIB_AVAILABLE_IN_ALL
GByteArray* g_byte_array_prepend           (GByteArray       *array,
					    const guint8     *data,
					    guint             len);
GLIB_AVAILABLE_IN_ALL
GByteArray* g_byte_array_set_size          (GByteArray       *array,
					    guint             length);
GLIB_AVAILABLE_IN_ALL
GByteArray* g_byte_array_remove_index      (GByteArray       *array,
					    guint             index_);
GLIB_AVAILABLE_IN_ALL
GByteArray* g_byte_array_remove_index_fast (GByteArray       *array,
					    guint             index_);
GLIB_AVAILABLE_IN_ALL
GByteArray* g_byte_array_remove_range      (GByteArray       *array,
					    guint             index_,
					    guint             length);
GLIB_AVAILABLE_IN_ALL
void        g_byte_array_sort              (GByteArray       *array,
					    GCompareFunc      compare_func);
GLIB_AVAILABLE_IN_ALL
void        g_byte_array_sort_with_data    (GByteArray       *array,
					    GCompareDataFunc  compare_func,
					    gpointer          user_data);

G_END_DECLS

#endif /* __G_ARRAY_H__ */
     usr/include/glib-2.0/glib/gasyncqueue.h                                                             0000644 0000000 0000000 00000013217 14375670023 016344  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* GLIB - Library of useful routines for C programming
 * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
 *
 * SPDX-License-Identifier: LGPL-2.1-or-later
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, see <http://www.gnu.org/licenses/>.
 */

/*
 * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
 * file for a list of people on the GLib Team.  See the ChangeLog
 * files for a list of changes.  These files are distributed with
 * GLib at ftp://ftp.gtk.org/pub/gtk/.
 */

#ifndef __G_ASYNCQUEUE_H__
#define __G_ASYNCQUEUE_H__

#if !defined (__GLIB_H_INSIDE__) && !defined (GLIB_COMPILATION)
#error "Only <glib.h> can be included directly."
#endif

#include <glib/gthread.h>

G_BEGIN_DECLS

typedef struct _GAsyncQueue GAsyncQueue;

GLIB_AVAILABLE_IN_ALL
GAsyncQueue *g_async_queue_new                  (void);
GLIB_AVAILABLE_IN_ALL
GAsyncQueue *g_async_queue_new_full             (GDestroyNotify item_free_func);
GLIB_AVAILABLE_IN_ALL
void         g_async_queue_lock                 (GAsyncQueue      *queue);
GLIB_AVAILABLE_IN_ALL
void         g_async_queue_unlock               (GAsyncQueue      *queue);
GLIB_AVAILABLE_IN_ALL
GAsyncQueue *g_async_queue_ref                  (GAsyncQueue      *queue);
GLIB_AVAILABLE_IN_ALL
void         g_async_queue_unref                (GAsyncQueue      *queue);

GLIB_DEPRECATED_FOR(g_async_queue_ref)
void         g_async_queue_ref_unlocked         (GAsyncQueue      *queue);

GLIB_DEPRECATED_FOR(g_async_queue_unref)
void         g_async_queue_unref_and_unlock     (GAsyncQueue      *queue);

GLIB_AVAILABLE_IN_ALL
void         g_async_queue_push                 (GAsyncQueue      *queue,
                                                 gpointer          data);
GLIB_AVAILABLE_IN_ALL
void         g_async_queue_push_unlocked        (GAsyncQueue      *queue,
                                                 gpointer          data);
GLIB_AVAILABLE_IN_ALL
void         g_async_queue_push_sorted          (GAsyncQueue      *queue,
                                                 gpointer          data,
                                                 GCompareDataFunc  func,
                                                 gpointer          user_data);
GLIB_AVAILABLE_IN_ALL
void         g_async_queue_push_sorted_unlocked (GAsyncQueue      *queue,
                                                 gpointer          data,
                                                 GCompareDataFunc  func,
                                                 gpointer          user_data);
GLIB_AVAILABLE_IN_ALL
gpointer     g_async_queue_pop                  (GAsyncQueue      *queue);
GLIB_AVAILABLE_IN_ALL
gpointer     g_async_queue_pop_unlocked         (GAsyncQueue      *queue);
GLIB_AVAILABLE_IN_ALL
gpointer     g_async_queue_try_pop              (GAsyncQueue      *queue);
GLIB_AVAILABLE_IN_ALL
gpointer     g_async_queue_try_pop_unlocked     (GAsyncQueue      *queue);
GLIB_AVAILABLE_IN_ALL
gpointer     g_async_queue_timeout_pop          (GAsyncQueue      *queue,
                                                 guint64           timeout);
GLIB_AVAILABLE_IN_ALL
gpointer     g_async_queue_timeout_pop_unlocked (GAsyncQueue      *queue,
                                                 guint64           timeout);
GLIB_AVAILABLE_IN_ALL
gint         g_async_queue_length               (GAsyncQueue      *queue);
GLIB_AVAILABLE_IN_ALL
gint         g_async_queue_length_unlocked      (GAsyncQueue      *queue);
GLIB_AVAILABLE_IN_ALL
void         g_async_queue_sort                 (GAsyncQueue      *queue,
                                                 GCompareDataFunc  func,
                                                 gpointer          user_data);
GLIB_AVAILABLE_IN_ALL
void         g_async_queue_sort_unlocked        (GAsyncQueue      *queue,
                                                 GCompareDataFunc  func,
                                                 gpointer          user_data);

GLIB_AVAILABLE_IN_2_46
gboolean     g_async_queue_remove               (GAsyncQueue      *queue,
                                                 gpointer          item);
GLIB_AVAILABLE_IN_2_46
gboolean     g_async_queue_remove_unlocked      (GAsyncQueue      *queue,
                                                 gpointer          item);
GLIB_AVAILABLE_IN_2_46
void         g_async_queue_push_front           (GAsyncQueue      *queue,
                                                 gpointer          item);
GLIB_AVAILABLE_IN_2_46
void         g_async_queue_push_front_unlocked  (GAsyncQueue      *queue,
                                                 gpointer          item);

G_GNUC_BEGIN_IGNORE_DEPRECATIONS
GLIB_DEPRECATED_FOR(g_async_queue_timeout_pop)
gpointer     g_async_queue_timed_pop            (GAsyncQueue      *queue,
                                                 GTimeVal         *end_time);
GLIB_DEPRECATED_FOR(g_async_queue_timeout_pop_unlocked)
gpointer     g_async_queue_timed_pop_unlocked   (GAsyncQueue      *queue,
                                                 GTimeVal         *end_time);
G_GNUC_END_IGNORE_DEPRECATIONS

G_END_DECLS

#endif /* __G_ASYNCQUEUE_H__ */
                                                                                                                                                                                                                                                                                                                                                                                 usr/include/glib-2.0/glib/gatomic.h                                                                 0000644 0000000 0000000 00000104437 14375670023 015443  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright © 2011 Ryan Lortie
 *
 * SPDX-License-Identifier: LGPL-2.1-or-later
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Ryan Lortie <desrt@desrt.ca>
 */

#ifndef __G_ATOMIC_H__
#define __G_ATOMIC_H__

#if !defined (__GLIB_H_INSIDE__) && !defined (GLIB_COMPILATION)
#error "Only <glib.h> can be included directly."
#endif

#include <glib/gtypes.h>
#include <glib/glib-typeof.h>

G_BEGIN_DECLS

GLIB_AVAILABLE_IN_ALL
gint                    g_atomic_int_get                      (const volatile gint *atomic);
GLIB_AVAILABLE_IN_ALL
void                    g_atomic_int_set                      (volatile gint  *atomic,
                                                               gint            newval);
GLIB_AVAILABLE_IN_ALL
void                    g_atomic_int_inc                      (volatile gint  *atomic);
GLIB_AVAILABLE_IN_ALL
gboolean                g_atomic_int_dec_and_test             (volatile gint  *atomic);
GLIB_AVAILABLE_IN_ALL
gboolean                g_atomic_int_compare_and_exchange     (volatile gint  *atomic,
                                                               gint            oldval,
                                                               gint            newval);
GLIB_AVAILABLE_IN_2_74
gboolean                g_atomic_int_compare_and_exchange_full (gint         *atomic,
                                                                gint          oldval,
                                                                gint          newval,
                                                                gint         *preval);
GLIB_AVAILABLE_IN_2_74
gint                    g_atomic_int_exchange                 (gint           *atomic,
                                                               gint            newval);
GLIB_AVAILABLE_IN_ALL
gint                    g_atomic_int_add                      (volatile gint  *atomic,
                                                               gint            val);
GLIB_AVAILABLE_IN_2_30
guint                   g_atomic_int_and                      (volatile guint *atomic,
                                                               guint           val);
GLIB_AVAILABLE_IN_2_30
guint                   g_atomic_int_or                       (volatile guint *atomic,
                                                               guint           val);
GLIB_AVAILABLE_IN_ALL
guint                   g_atomic_int_xor                      (volatile guint *atomic,
                                                               guint           val);

GLIB_AVAILABLE_IN_ALL
gpointer                g_atomic_pointer_get                  (const volatile void *atomic);
GLIB_AVAILABLE_IN_ALL
void                    g_atomic_pointer_set                  (volatile void  *atomic,
                                                               gpointer        newval);
GLIB_AVAILABLE_IN_ALL
gboolean                g_atomic_pointer_compare_and_exchange (volatile void  *atomic,
                                                               gpointer        oldval,
                                                               gpointer        newval);
GLIB_AVAILABLE_IN_2_74
gboolean                g_atomic_pointer_compare_and_exchange_full (void     *atomic,
                                                                    gpointer  oldval,
                                                                    gpointer  newval,
                                                                    void     *preval);
GLIB_AVAILABLE_IN_2_74
gpointer                g_atomic_pointer_exchange             (void           *atomic,
                                                               gpointer        newval);
GLIB_AVAILABLE_IN_ALL
gssize                  g_atomic_pointer_add                  (volatile void  *atomic,
                                                               gssize          val);
GLIB_AVAILABLE_IN_2_30
gsize                   g_atomic_pointer_and                  (volatile void  *atomic,
                                                               gsize           val);
GLIB_AVAILABLE_IN_2_30
gsize                   g_atomic_pointer_or                   (volatile void  *atomic,
                                                               gsize           val);
GLIB_AVAILABLE_IN_ALL
gsize                   g_atomic_pointer_xor                  (volatile void  *atomic,
                                                               gsize           val);

GLIB_DEPRECATED_IN_2_30_FOR(g_atomic_int_add)
gint                    g_atomic_int_exchange_and_add         (volatile gint  *atomic,
                                                               gint            val);

G_END_DECLS

#if defined(G_ATOMIC_LOCK_FREE) && defined(__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4)

/* We prefer the new C11-style atomic extension of GCC if available */
#if defined(__ATOMIC_SEQ_CST)

#define g_atomic_int_get(atomic) \
  (G_GNUC_EXTENSION ({                                                       \
    G_STATIC_ASSERT (sizeof *(atomic) == sizeof (gint));                     \
    gint gaig_temp;                                                          \
    (void) (0 ? *(atomic) ^ *(atomic) : 1);                                  \
    __atomic_load ((gint *)(atomic), &gaig_temp, __ATOMIC_SEQ_CST);          \
    (gint) gaig_temp;                                                        \
  }))
#define g_atomic_int_set(atomic, newval) \
  (G_GNUC_EXTENSION ({                                                       \
    G_STATIC_ASSERT (sizeof *(atomic) == sizeof (gint));                     \
    gint gais_temp = (gint) (newval);                                        \
    (void) (0 ? *(atomic) ^ (newval) : 1);                                   \
    __atomic_store ((gint *)(atomic), &gais_temp, __ATOMIC_SEQ_CST);         \
  }))

#if defined(glib_typeof)
#define g_atomic_pointer_get(atomic)                                       \
  (G_GNUC_EXTENSION ({                                                     \
    G_STATIC_ASSERT (sizeof *(atomic) == sizeof (gpointer));               \
    glib_typeof (*(atomic)) gapg_temp_newval;                              \
    glib_typeof ((atomic)) gapg_temp_atomic = (atomic);                    \
    __atomic_load (gapg_temp_atomic, &gapg_temp_newval, __ATOMIC_SEQ_CST); \
    gapg_temp_newval;                                                      \
  }))
#define g_atomic_pointer_set(atomic, newval)                                \
  (G_GNUC_EXTENSION ({                                                      \
    G_STATIC_ASSERT (sizeof *(atomic) == sizeof (gpointer));                \
    glib_typeof ((atomic)) gaps_temp_atomic = (atomic);                     \
    glib_typeof (*(atomic)) gaps_temp_newval = (newval);                    \
    (void) (0 ? (gpointer) * (atomic) : NULL);                              \
    __atomic_store (gaps_temp_atomic, &gaps_temp_newval, __ATOMIC_SEQ_CST); \
  }))
#else /* if !(defined(glib_typeof) */
#define g_atomic_pointer_get(atomic) \
  (G_GNUC_EXTENSION ({                                                       \
    G_STATIC_ASSERT (sizeof *(atomic) == sizeof (gpointer));                 \
    gpointer gapg_temp_newval;                                               \
    gpointer *gapg_temp_atomic = (gpointer *)(atomic);                       \
    __atomic_load (gapg_temp_atomic, &gapg_temp_newval, __ATOMIC_SEQ_CST);   \
    gapg_temp_newval;                                                        \
  }))
#define g_atomic_pointer_set(atomic, newval) \
  (G_GNUC_EXTENSION ({                                                       \
