	  Hiding  dot-files.............................|netrw-gh|
	Listing Style
	  Select listing style (thin/long/wide/tree)....|netrw-i|
	  Associated setting variable...................|g:netrw_liststyle|
	  Shell command used to perform listing.........|g:netrw_list_cmd|
	  Quick file info...............................|netrw-qf|
	Sorted by
	  Select sorting style (name/time/size).........|netrw-s|
	  Editing the sorting sequence..................|netrw-S|
	  Sorting options...............................|g:netrw_sort_options|
	  Associated setting variable...................|g:netrw_sort_sequence|
	  Reverse sorting order.........................|netrw-r|


				*netrw-quickmap*  *netrw-quickmaps*
QUICK REFERENCE: MAPS				*netrw-browse-maps* {{{2
>
	  ---			-----------------			----
	  Map			Quick Explanation			Link
	  ---			-----------------			----
<	 <F1>	Causes Netrw to issue help
	 <cr>	Netrw will enter the directory or read the file      |netrw-cr|
	 <del>	Netrw will attempt to remove the file/directory      |netrw-del|
	 <c-h>	Edit file hiding list                                |netrw-ctrl-h|
	 <c-l>	Causes Netrw to refresh the directory listing        |netrw-ctrl-l|
	 <c-r>	Browse using a gvim server                           |netrw-ctrl-r|
	 <c-tab> Shrink/expand a netrw/explore window                |netrw-c-tab|
	   -	Makes Netrw go up one directory                      |netrw--|
	   a	Cycles between normal display,                       |netrw-a|
		hiding (suppress display of files matching g:netrw_list_hide)
		and showing (display only files which match g:netrw_list_hide)
	   cd	Make browsing directory the current directory        |netrw-cd|
	   C	Setting the editing window                           |netrw-C|
	   d	Make a directory                                     |netrw-d|
	   D	Attempt to remove the file(s)/directory(ies)         |netrw-D|
	   gb	Go to previous bookmarked directory                  |netrw-gb|
	   gd	Force treatment as directory                         |netrw-gd|
	   gf	Force treatment as file                              |netrw-gf|
	   gh	Quick hide/unhide of dot-files                       |netrw-gh|
	   gn	Make top of tree the directory below the cursor      |netrw-gn|
	   gp	Change local-only file permissions                   |netrw-gp|
	   i	Cycle between thin, long, wide, and tree listings    |netrw-i|
	   I	Toggle the displaying of the banner                  |netrw-I|
	   mb	Bookmark current directory                           |netrw-mb|
	   mc	Copy marked files to marked-file target directory    |netrw-mc|
	   md	Apply diff to marked files (up to 3)                 |netrw-md|
	   me	Place marked files on arg list and edit them         |netrw-me|
	   mf	Mark a file                                          |netrw-mf|
	   mF	Unmark files                                         |netrw-mF|
	   mg	Apply vimgrep to marked files                        |netrw-mg|
	   mh	Toggle marked file suffices' presence on hiding list |netrw-mh|
	   mm	Move marked files to marked-file target directory    |netrw-mm|
	   mp	Print marked files                                   |netrw-mp|
	   mr	Mark files using a shell-style |regexp|                |netrw-mr|
	   mt	Current browsing directory becomes markfile target   |netrw-mt|
	   mT	Apply ctags to marked files                          |netrw-mT|
	   mu	Unmark all marked files                              |netrw-mu|
	   mv	Apply arbitrary vim   command to marked files        |netrw-mv|
	   mx	Apply arbitrary shell command to marked files        |netrw-mx|
	   mX	Apply arbitrary shell command to marked files en bloc|netrw-mX|
	   mz	Compress/decompress marked files                     |netrw-mz|
	   o	Enter the file/directory under the cursor in a new   |netrw-o|
		browser window.  A horizontal split is used.
	   O	Obtain a file specified by cursor                    |netrw-O|
	   p	Preview the file                                     |netrw-p|
	   P	Browse in the previously used window                 |netrw-P|
	   qb	List bookmarked directories and history              |netrw-qb|
	   qf	Display information on file                          |netrw-qf|
	   qF	Mark files using a quickfix list                     |netrw-qF|
	   qL	Mark files using a |location-list|                     |netrw-qL|
	   r	Reverse sorting order                                |netrw-r|
	   R	Rename the designated file(s)/directory(ies)         |netrw-R|
	   s	Select sorting style: by name, time, or file size    |netrw-s|
	   S	Specify suffix priority for name-sorting             |netrw-S|
	   t	Enter the file/directory under the cursor in a new tab|netrw-t|
	   u	Change to recently-visited directory                 |netrw-u|
	   U	Change to subsequently-visited directory             |netrw-U|
	   v	Enter the file/directory under the cursor in a new   |netrw-v|
		browser window.  A vertical split is used.
	   x	View file with an associated program                 |netrw-x|
	   X	Execute filename under cursor via |system()|           |netrw-X|

	   %	Open a new file in netrw's current directory         |netrw-%|

	*netrw-mouse* *netrw-leftmouse* *netrw-middlemouse* *netrw-rightmouse*
	<leftmouse>	(gvim only) selects word under mouse as if a <cr>
			had been pressed (ie. edit file, change directory)
	<middlemouse>	(gvim only) same as P selecting word under mouse;
			see |netrw-P|
	<rightmouse>	(gvim only) delete file/directory using word under
			mouse
	<2-leftmouse>	(gvim only) when:
			 * in a netrw-selected file, AND
			 * |g:netrw_retmap| == 1       AND
			 * the user doesn't already have a <2-leftmouse>
			   mapping defined before netrw is autoloaded,
			then a double clicked leftmouse button will return
			to the netrw browser window.  See |g:netrw_retmap|.
	<s-leftmouse>	(gvim only) like mf, will mark files.  Dragging
			the shifted leftmouse will mark multiple files.
			(see |netrw-mf|)

	(to disable mouse buttons while browsing: |g:netrw_mousemaps|)

				*netrw-quickcom* *netrw-quickcoms*
QUICK REFERENCE: COMMANDS	*netrw-explore-cmds* *netrw-browse-cmds* {{{2
     :NetrwClean[!]............................................|netrw-clean|
     :NetrwSettings............................................|netrw-settings|
     :Ntree....................................................|netrw-ntree|
     :Explore[!]  [dir] Explore directory of current file......|netrw-explore|
     :Hexplore[!] [dir] Horizontal Split & Explore.............|netrw-explore|
     :Lexplore[!] [dir] Left Explorer Toggle...................|netrw-explore|
     :Nexplore[!] [dir] Vertical Split & Explore...............|netrw-explore|
     :Pexplore[!] [dir] Vertical Split & Explore...............|netrw-explore|
     :Rexplore          Return to Explorer.....................|netrw-explore|
     :Sexplore[!] [dir] Split & Explore directory .............|netrw-explore|
     :Texplore[!] [dir] Tab & Explore..........................|netrw-explore|
     :Vexplore[!] [dir] Vertical Split & Explore...............|netrw-explore|


BANNER DISPLAY						*netrw-I*

One may toggle the displaying of the banner by pressing "I".

Also See: |g:netrw_banner|


BOOKMARKING A DIRECTORY		*netrw-mb* *netrw-bookmark* *netrw-bookmarks* {{{2

One may easily "bookmark" the currently browsed directory by using >

	mb
<
								*.netrwbook*
Bookmarks are retained in between sessions of vim in a file called .netrwbook
as a |List|, which is typically stored in the first directory on the user's
'runtimepath'; entries are kept in sorted order.

If there are marked files and/or directories, mb will add them to the bookmark
list.

								*netrw-:NetrwMB*
Additionally, one may use :NetrwMB to bookmark files or directories. >

	:NetrwMB[!] [files/directories]

< No bang: enters files/directories into Netrw's bookmark system

   No argument and in netrw buffer:
     if there are marked files        : bookmark marked files
     otherwise                        : bookmark file/directory under cursor
   No argument and not in netrw buffer: bookmarks current open file
   Has arguments                      : |glob()|s each arg and bookmarks them

 With bang: deletes files/directories from Netrw's bookmark system

The :NetrwMB command is available outside of netrw buffers (once netrw has been
invoked in the session).

The file ".netrwbook" holds bookmarks when netrw (and vim) is not active.  By
default, its stored on the first directory on the user's |'runtimepath'|.

Related Topics:
	|netrw-gb| how to return (go) to a bookmark
	|netrw-mB| how to delete bookmarks
	|netrw-qb| how to list bookmarks
	|g:netrw_home| controls where .netrwbook is kept


BROWSING					*netrw-enter*	*netrw-cr* {{{2

Browsing is simple: move the cursor onto a file or directory of interest.
Hitting the <cr> (the return key) will select the file or directory.
Directories will themselves be listed, and files will be opened using the
protocol given in the original read request.

  CAVEAT: There are four forms of listing (see |netrw-i|).  Netrw assumes that
  two or more spaces delimit filenames and directory names for the long and
  wide listing formats.  Thus, if your filename or directory name has two or
  more sequential spaces embedded in it, or any trailing spaces, then you'll
  need to use the "thin" format to select it.

The |g:netrw_browse_split| option, which is zero by default, may be used to
cause the opening of files to be done in a new window or tab instead of the
default.  When the option is one or two, the splitting will be taken
horizontally or vertically, respectively.  When the option is set to three, a
<cr> will cause the file to appear in a new tab.


When using the gui (gvim), one may select a file by pressing the <leftmouse>
button.  In addition, if

 * |g:netrw_retmap| == 1       AND   (its default value is 0)
 * in a netrw-selected file, AND
 * the user doesn't already have a <2-leftmouse> mapping defined before
   netrw is loaded

then a doubly-clicked leftmouse button will return to the netrw browser
window.

Netrw attempts to speed up browsing, especially for remote browsing where one
may have to enter passwords, by keeping and re-using previously obtained
directory listing buffers.  The |g:netrw_fastbrowse| variable is used to
control this behavior; one may have slow browsing (no buffer re-use), medium
speed browsing (re-use directory buffer listings only for remote directories),
and fast browsing (re-use directory buffer listings as often as possible).
The price for such re-use is that when changes are made (such as new files
are introduced into a directory), the listing may become out-of-date.  One may
always refresh directory listing buffers by pressing ctrl-L (see
|netrw-ctrl-l|).

								*netrw-s-cr*
Squeezing the Current Tree-Listing Directory~

When the tree listing style is enabled (see |netrw-i|) and one is using
gvim, then the <s-cr> mapping may be used to squeeze (close) the
directory currently containing the cursor.

Otherwise, one may remap a key combination of one's own choice to get
this effect: >

    nmap <buffer> <silent> <nowait> YOURKEYCOMBO  <Plug>NetrwTreeSqueeze
<
Put this line in $HOME/ftplugin/netrw/netrw.vim; it needs to be generated
for netrw buffers only.

Related topics:
	|netrw-ctrl-r|	|netrw-o|	|netrw-p|
	|netrw-P|	|netrw-t|	|netrw-v|
Associated setting variables:
   |g:netrw_browse_split|	|g:netrw_fastbrowse|
   |g:netrw_ftp_list_cmd|	|g:netrw_ftp_sizelist_cmd|
   |g:netrw_ftp_timelist_cmd|	|g:netrw_ssh_browse_reject|
   |g:netrw_ssh_cmd|		|g:netrw_use_noswf|


BROWSING WITH A HORIZONTALLY SPLIT WINDOW	*netrw-o* *netrw-horiz* {{{2

Normally one enters a file or directory using the <cr>.  However, the "o" map
allows one to open a new window to hold the new directory listing or file.  A
horizontal split is used.  (for vertical splitting, see |netrw-v|)

Normally, the o key splits the window horizontally with the new window and
cursor at the top.

Associated setting variables: |g:netrw_alto| |g:netrw_winsize|

Related topics:
	|netrw-ctrl-r|	|netrw-o|	|netrw-p|
	|netrw-P|	|netrw-t|	|netrw-v|
Associated setting variables:
   |g:netrw_alto|    control above/below splitting
   |g:netrw_winsize| control initial sizing

BROWSING WITH A NEW TAB				*netrw-t* {{{2

Normally one enters a file or directory using the <cr>.  The "t" map
allows one to open a new window holding the new directory listing or file in
a new tab.

If you'd like to have the new listing in a background tab, use |gT|.

Related topics:
	|netrw-ctrl-r|	|netrw-o|	|netrw-p|
	|netrw-P|	|netrw-t|	|netrw-v|
Associated setting variables:
   |g:netrw_winsize| control initial sizing

BROWSING WITH A VERTICALLY SPLIT WINDOW			*netrw-v* {{{2

Normally one enters a file or directory using the <cr>.  However, the "v" map
allows one to open a new window to hold the new directory listing or file.  A
vertical split is used.  (for horizontal splitting, see |netrw-o|)

Normally, the v key splits the window vertically with the new window and
cursor at the left.

There is only one tree listing buffer; using "v" on a displayed subdirectory
will split the screen, but the same buffer will be shown twice.

Related topics:
	|netrw-ctrl-r|	|netrw-o|	|netrw-p|
	|netrw-P|	|netrw-t|	|netrw-v|
Associated setting variables:
   |g:netrw_altv|    control right/left splitting
   |g:netrw_winsize| control initial sizing


BROWSING USING A GVIM SERVER			*netrw-ctrl-r* {{{2

One may keep a browsing gvim separate from the gvim being used to edit.
Use the <c-r> map on a file (not a directory) in the netrw browser, and it
will use a gvim server (see |g:netrw_servername|).  Subsequent use of <cr>
(see |netrw-cr|) will re-use that server for editing files.

Related topics:
	|netrw-ctrl-r|	|netrw-o|	|netrw-p|
	|netrw-P|	|netrw-t|	|netrw-v|
Associated setting variables:
	|g:netrw_servername|   : sets name of server
	|g:netrw_browse_split| : controls how <cr> will open files


CHANGE LISTING STYLE  (THIN LONG WIDE TREE)			*netrw-i* {{{2

The "i" map cycles between the thin, long, wide, and tree listing formats.

The thin listing format gives just the files' and directories' names.

The long listing is either based on the "ls" command via ssh for remote
directories or displays the filename, file size (in bytes), and the time and
date of last modification for local directories.  With the long listing
format, netrw is not able to recognize filenames which have trailing spaces.
Use the thin listing format for such files.

The wide listing format uses two or more contiguous spaces to delineate
filenames; when using that format, netrw won't be able to recognize or use
filenames which have two or more contiguous spaces embedded in the name or any
trailing spaces.  The thin listing format will, however, work with such files.
The wide listing format is the most compact.

The tree listing format has a top directory followed by files and directories
preceded by one or more "|"s, which indicate the directory depth.  One may
open and close directories by pressing the <cr> key while atop the directory
name.

One may make a preferred listing style your default; see |g:netrw_liststyle|.
As an example, by putting the following line in your .vimrc, >
	let g:netrw_liststyle= 3
the tree style will become your default listing style.

One typical way to use the netrw tree display is to: >

	vim .
	(use i until a tree display shows)
	navigate to a file
	v  (edit as desired in vertically split window)
	ctrl-w h  (to return to the netrw listing)
	P (edit newly selected file in the previous window)
	ctrl-w h  (to return to the netrw listing)
	P (edit newly selected file in the previous window)
	...etc...
<
Associated setting variables: |g:netrw_liststyle| |g:netrw_maxfilenamelen|
                              |g:netrw_timefmt|   |g:netrw_list_cmd|

CHANGE FILE PERMISSION						*netrw-gp* {{{2

"gp" will ask you for a new permission for the file named under the cursor.
Currently, this only works for local files.

Associated setting variables: |g:netrw_chgperm|


CHANGING TO A BOOKMARKED DIRECTORY			*netrw-gb*  {{{2

To change directory back to a bookmarked directory, use

	{cnt}gb

Any count may be used to reference any of the bookmarks.
Note that |netrw-qb| shows both bookmarks and history; to go
to a location stored in the history see |netrw-u| and |netrw-U|.

Related Topics:
	|netrw-mB| how to delete bookmarks
	|netrw-mb| how to make a bookmark
	|netrw-qb| how to list bookmarks


CHANGING TO A PREDECESSOR DIRECTORY		*netrw-u* *netrw-updir* {{{2

Every time you change to a new directory (new for the current session), netrw
will save the directory in a recently-visited directory history list (unless
|g:netrw_dirhistmax| is zero; by default, it holds ten entries).  With the "u"
map, one can change to an earlier directory (predecessor).  To do the
opposite, see |netrw-U|.

The "u" map also accepts counts to go back in the history several slots.  For
your convenience, qb (see |netrw-qb|) lists the history number which may be
used in that count.

						*.netrwhist*
See |g:netrw_dirhistmax| for how to control the quantity of history stack
slots.  The file ".netrwhist" holds history when netrw (and vim) is not
active.  By default, its stored on the first directory on the user's
|'runtimepath'|.

Related Topics:
	|netrw-U| changing to a successor directory
	|g:netrw_home| controls where .netrwhist is kept


CHANGING TO A SUCCESSOR DIRECTORY		*netrw-U* *netrw-downdir* {{{2

With the "U" map, one can change to a later directory (successor).
This map is the opposite of the "u" map. (see |netrw-u|)  Use the
qb map to list both the bookmarks and history. (see |netrw-qb|)

The "U" map also accepts counts to go forward in the history several slots.

See |g:netrw_dirhistmax| for how to control the quantity of history stack
slots.


CHANGING TREE TOP			*netrw-ntree*  *:Ntree*  *netrw-gn* {{{2

One may specify a new tree top for tree listings using >

	:Ntree [dirname]

Without a "dirname", the current line is used (and any leading depth
information is elided).
With a "dirname", the specified directory name is used.

The "gn" map will take the word below the cursor and use that for
changing the top of the tree listing.


NETRW CLEAN					*netrw-clean* *:NetrwClean* {{{2

With :NetrwClean one may easily remove netrw from one's home directory;
more precisely, from the first directory on your |'runtimepath'|.

With :NetrwClean!, netrw will attempt to remove netrw from all directories on
your |'runtimepath'|.  Of course, you have to have write/delete permissions
correct to do this.

With either form of the command, netrw will first ask for confirmation
that the removal is in fact what you want to do.  If netrw doesn't have
permission to remove a file, it will issue an error message.

						*netrw-gx*
CUSTOMIZING BROWSING WITH A SPECIAL HANDLER	*netrw-x* *netrw-handler* {{{2
						(also see |netrw_filehandler|)

Certain files, such as html, gif, jpeg, (word/office) doc, etc, files, are
best seen with a special handler (ie. a tool provided with your computer's
operating system).  Netrw allows one to invoke such special handlers by: >

	* when Exploring, hit the "x" key
	* when editing, hit gx with the cursor atop the special filename
<	  (latter not available if the |g:netrw_nogx| variable exists)

Netrw determines which special handler by the following method:

  * if |g:netrw_browsex_viewer| exists, then it will be used to attempt to
    view files.  Examples of useful settings (place into your <.vimrc>): >

	:let g:netrw_browsex_viewer= "kfmclient exec"
<   or >
	:let g:netrw_browsex_viewer= "xdg-open"
<
    If g:netrw_browsex_viewer == '-', then netrwFileHandlers#Invoke() will be
    used instead (see |netrw_filehandler|).

    If the viewer you wish to use does not support handling of a remote URL
    directory, set |g:netrw_browsex_support_remote| to 0.
  * for Windows 32 or 64, the URL and FileProtocolHandler dlls are used.
  * for Gnome (with gnome-open): gnome-open is used.
  * for KDE (with kfmclient)   : kfmclient is used
  * for Mac OS X               : open is used.
  * otherwise the netrwFileHandler plugin is used.

The file's suffix is used by these various approaches to determine an
appropriate application to use to "handle" these files.  Such things as
OpenOffice (*.sfx), visualization (*.jpg, *.gif, etc), and PostScript (*.ps,
*.eps) can be handled.

The gx mapping extends to all buffers; apply "gx" while atop a word and netrw
will apply a special handler to it (like "x" works when in a netrw buffer).
One may also use visual mode (see |visual-start|) to select the text that the
special handler will use.  Normally gx uses expand("<cfile>") to pick up the
text under the cursor; one may change what |expand()| uses via the
|g:netrw_gx| variable (options include "<cword>", "<cWORD>").  Note that
expand("<cfile>") depends on the |'isfname'| setting.  Alternatively, one may
select the text to be used by gx by making a visual selection (see
|visual-block|) and then pressing gx.

Associated setting variables:
	|g:netrw_gx|	control how gx picks up the text under the cursor
	|g:netrw_nogx|	prevent gx map while editing
	|g:netrw_suppress_gx_mesg| controls gx's suppression of browser messages

							*netrw_filehandler*

When |g:netrw_browsex_viewer| exists and is "-", then netrw will attempt to
handle the special file with a vim function.  The "x" map applies a function
to a file, based on its extension.  Of course, the handler function must exist
for it to be called!
>
 Ex. mypgm.html   x -> NFH_html("scp://user@host/some/path/mypgm.html")

<	Users may write their own netrw File Handler functions to
	support more suffixes with special handling.  See
	<autoload/netrwFileHandlers.vim> for examples on how to make
	file handler functions.   As an example: >

	" NFH_suffix(filename)
	fun! NFH_suffix(filename)
	..do something special with filename..
	endfun
<
These functions need to be defined in some file in your .vim/plugin
(vimfiles\plugin) directory.  Vim's function names may not have punctuation
characters (except for the underscore) in them.  To support suffices that
contain such characters, netrw will first convert the suffix using the
following table: >

    @ -> AT       ! -> EXCLAMATION    % -> PERCENT
    : -> COLON    = -> EQUAL          ? -> QUESTION
    , -> COMMA    - -> MINUS          ; -> SEMICOLON
    $ -> DOLLAR   + -> PLUS           ~ -> TILDE
<
So, for example: >

	file.rcs,v  ->  NFH_rcsCOMMAv()
<
If more such translations are necessary, please send me email: >
		NcampObell@SdrPchip.AorgM-NOSPAM
with a request.  (remove the embedded NOSPAM first)

Associated setting variable: |g:netrw_browsex_viewer|

							*netrw-curdir*
DELETING BOOKMARKS					*netrw-mB* {{{2

To delete a bookmark, use >

	{cnt}mB

If there are marked files, then mB will remove them from the
bookmark list.

Alternatively, one may use :NetrwMB! (see |netrw-:NetrwMB|). >

	:NetrwMB! [files/directories]

Related Topics:
	|netrw-gb| how to return (go) to a bookmark
	|netrw-mb| how to make a bookmark
	|netrw-qb| how to list bookmarks


DELETING FILES OR DIRECTORIES	*netrw-delete* *netrw-D* *netrw-del* {{{2

If files have not been marked with |netrw-mf|:   (local marked file list)

    Deleting/removing files and directories involves moving the cursor to the
    file/directory to be deleted and pressing "D".  Directories must be empty
    first before they can be successfully removed.  If the directory is a
    softlink to a directory, then netrw will make two requests to remove the
    directory before succeeding.  Netrw will ask for confirmation before doing
    the removal(s).  You may select a range of lines with the "V" command
    (visual selection), and then pressing "D".

If files have been marked with |netrw-mf|:   (local marked file list)

    Marked files (and empty directories) will be deleted; again, you'll be
    asked to confirm the deletion before it actually takes place.

A further approach is to delete files which match a pattern.

    * use  :MF pattern  (see |netrw-:MF|); then press "D".

    * use mr (see |netrw-mr|) which will prompt you for pattern.
      This will cause the matching files to be marked.  Then,
      press "D".

If your vim has 7.4 with patch#1107, then |g:netrw_localrmdir| no longer
is used to remove directories; instead, vim's |delete()| is used with
the "d" option.  Please note that only empty directories may be deleted
with the "D" mapping.  Regular files are deleted with |delete()|, too.

The |g:netrw_rm_cmd|, |g:netrw_rmf_cmd|, and |g:netrw_rmdir_cmd| variables are
used to control the attempts to remove remote files and directories.  The
g:netrw_rm_cmd is used with files, and its default value is:

	g:netrw_rm_cmd: ssh HOSTNAME rm

The g:netrw_rmdir_cmd variable is used to support the removal of directories.
Its default value is:

	|g:netrw_rmdir_cmd|: ssh HOSTNAME rmdir

If removing a directory fails with g:netrw_rmdir_cmd, netrw then will attempt
to remove it again using the g:netrw_rmf_cmd variable.  Its default value is:

	|g:netrw_rmf_cmd|: ssh HOSTNAME rm -f

Related topics: |netrw-d|
Associated setting variable: |g:netrw_localrmdir| |g:netrw_rm_cmd|
                             |g:netrw_rmdir_cmd|   |g:netrw_ssh_cmd|


*netrw-explore*  *netrw-hexplore* *netrw-nexplore* *netrw-pexplore*
*netrw-rexplore* *netrw-sexplore* *netrw-texplore* *netrw-vexplore* *netrw-lexplore*
DIRECTORY EXPLORATION COMMANDS  {{{2

     :[N]Explore[!]  [dir]... Explore directory of current file      *:Explore*
     :[N]Hexplore[!] [dir]... Horizontal Split & Explore             *:Hexplore*
     :[N]Lexplore[!] [dir]... Left Explorer Toggle                   *:Lexplore*
     :[N]Sexplore[!] [dir]... Split&Explore current file's directory *:Sexplore*
     :[N]Vexplore[!] [dir]... Vertical   Split & Explore             *:Vexplore*
     :Texplore       [dir]... Tab & Explore                          *:Texplore*
     :Rexplore            ... Return to/from Explorer                *:Rexplore*

     Used with :Explore **/pattern : (also see |netrw-starstar|)
     :Nexplore............. go to next matching file                *:Nexplore*
     :Pexplore............. go to previous matching file            *:Pexplore*

						*netrw-:Explore*
:Explore  will open the local-directory browser on the current file's
          directory (or on directory [dir] if specified).  The window will be
	  split only if the file has been modified and |'hidden'| is not set,
	  otherwise the browsing window will take over that window.  Normally
	  the splitting is taken horizontally.
	  Also see: |netrw-:Rexplore|
:Explore! is like :Explore, but will use vertical splitting.

						*netrw-:Hexplore*
:Hexplore  [dir] does an :Explore with |:belowright| horizontal splitting.
:Hexplore! [dir] does an :Explore with |:aboveleft|  horizontal splitting.

						*netrw-:Lexplore*
:[N]Lexplore [dir] toggles a full height Explorer window on the left hand side
	  of the current tab.  It will open a netrw window on the current
	  directory if [dir] is omitted; a :Lexplore [dir] will show the
	  specified directory in the left-hand side browser display no matter
	  from which window the command is issued.

	  By default, :Lexplore will change an uninitialized |g:netrw_chgwin|
	  to 2; edits will thus preferentially be made in window#2.

	  The [N] specifies a |g:netrw_winsize| just for the new :Lexplore
	  window.

	  Those who like this method often also like tree style displays;
	  see |g:netrw_liststyle|.

:[N]Lexplore! [dir] is similar to :Lexplore, except that the full-height
	  Explorer window will open on the right hand side and an
	  uninitialized |g:netrw_chgwin| will be set to 1 (eg. edits will
	  preferentially occur in the leftmost window).

	  Also see: |netrw-C|           |g:netrw_browse_split|   |g:netrw_wiw|
		    |netrw-p| |netrw-P|   |g:netrw_chgwin|
		    |netrw-c-tab|       |g:netrw_winsize|

						*netrw-:Sexplore*
:[N]Sexplore will always split the window before invoking the local-directory
	  browser.  As with Explore, the splitting is normally done
	  horizontally.
:[N]Sexplore! [dir] is like :Sexplore, but the splitting will be done vertically.

						*netrw-:Texplore*
:Texplore  [dir] does a |:tabnew| before generating the browser window

						*netrw-:Vexplore*
:[N]Vexplore  [dir] does an :Explore with |:leftabove|  vertical splitting.
:[N]Vexplore! [dir] does an :Explore with |:rightbelow| vertical splitting.

The optional parameters are:

 [N]: This parameter will override |g:netrw_winsize| to specify the quantity of
      rows and/or columns the new explorer window should have.
      Otherwise, the |g:netrw_winsize| variable, if it has been specified by the
      user, is used to control the quantity of rows and/or columns new
      explorer windows should have.

 [dir]: By default, these explorer commands use the current file's directory.
        However, one may explicitly provide a directory (path) to use instead;
	ie. >

	:Explore /some/path
<
						*netrw-:Rexplore*
:Rexplore  This command is a little different from the other Explore commands
	   as it doesn't necessarily open an Explorer window.

	   Return to Explorer~
	   When one edits a file using netrw which can occur, for example,
	   when pressing <cr> while the cursor is atop a filename in a netrw
	   browser window, a :Rexplore issued while editing that file will
	   return the display to that of the last netrw browser display in
	   that window.

	   Return from Explorer~
	   Conversely, when one is editing a directory, issuing a :Rexplore
	   will return to editing the file that was last edited in that
	   window.

	   The <2-leftmouse> map (which is only available under gvim and
	   cooperative terms) does the same as :Rexplore.

Also see: |g:netrw_alto| |g:netrw_altv| |g:netrw_winsize|


*netrw-star* *netrw-starpat* *netrw-starstar* *netrw-starstarpat* *netrw-grep*
EXPLORING WITH STARS AND PATTERNS {{{2

When Explore, Sexplore, Hexplore, or Vexplore are used with one of the
following four patterns Explore generates a list of files which satisfy the
request for the local file system.  These exploration patterns will not work
with remote file browsing.

    */filepat	files in current directory which satisfy filepat
    **/filepat	files in current directory or below which satisfy the
		file pattern
    *//pattern	files in the current directory which contain the
		pattern (vimgrep is used)
    **//pattern	files in the current directory or below which contain
		the pattern (vimgrep is used)
<
The cursor will be placed on the first file in the list.  One may then
continue to go to subsequent files on that list via |:Nexplore| or to
preceding files on that list with |:Pexplore|.  Explore will update the
directory and place the cursor appropriately.

A plain >
	:Explore
will clear the explore list.

If your console or gui produces recognizable shift-up or shift-down sequences,
then you'll likely find using shift-downarrow and shift-uparrow convenient.
They're mapped by netrw as follows:

	<s-down>  == Nexplore, and
	<s-up>    == Pexplore.

As an example, consider
>
	:Explore */*.c
	:Nexplore
	:Nexplore
	:Pexplore
<
The status line will show, on the right hand side of the status line, a
message like "Match 3 of 20".

Associated setting variables:
	|g:netrw_keepdir|          |g:netrw_browse_split|
	|g:netrw_fastbrowse|       |g:netrw_ftp_browse_reject|
	|g:netrw_ftp_list_cmd|     |g:netrw_ftp_sizelist_cmd|
	|g:netrw_ftp_timelist_cmd| |g:netrw_list_cmd|
	|g:netrw_liststyle|


DISPLAYING INFORMATION ABOUT FILE				*netrw-qf* {{{2

With the cursor atop a filename, pressing "qf" will reveal the file's size
and last modification timestamp.  Currently this capability is only available
for local files.


EDIT FILE OR DIRECTORY HIDING LIST	*netrw-ctrl-h* *netrw-edithide* {{{2

The "<ctrl-h>" map brings up a requestor allowing the user to change the
file/directory hiding list contained in |g:netrw_list_hide|.  The hiding list
consists of one or more patterns delimited by commas.  Files and/or
directories satisfying these patterns will either be hidden (ie. not shown) or
be the only ones displayed (see |netrw-a|).

The "gh" mapping (see |netrw-gh|) quickly alternates between the usual
hiding list and the hiding of files or directories that begin with ".".

As an example, >
	let g:netrw_list_hide= '\(^\|\s\s\)\zs\.\S\+'
Effectively, this makes the effect of a |netrw-gh| command the initial setting.
What it means:

	\(^\|\s\s\)   : if the line begins with the following, -or-
	                two consecutive spaces are encountered
	\zs           : start the hiding match now
	\.            : if it now begins with a dot
	\S\+          : and is followed by one or more non-whitespace
	                characters

Associated setting variables: |g:netrw_hide| |g:netrw_list_hide|
Associated topics: |netrw-a| |netrw-gh| |netrw-mh|

					*netrw-sort-sequence*
EDITING THE SORTING SEQUENCE		*netrw-S* *netrw-sortsequence* {{{2

When "Sorted by" is name, one may specify priority via the sorting sequence
(g:netrw_sort_sequence).  The sorting sequence typically prioritizes the
name-listing by suffix, although any pattern will do.  Patterns are delimited
by commas.  The default sorting sequence is (all one line):

For Unix: >
	'[\/]$,\<core\%(\.\d\+\)\=,\.[a-np-z]$,\.h$,\.c$,\.cpp$,*,\.o$,\.obj$,
	\.info$,\.swp$,\.bak$,\~$'
<
Otherwise: >
	'[\/]$,\.[a-np-z]$,\.h$,\.c$,\.cpp$,*,\.o$,\.obj$,\.info$,
	\.swp$,\.bak$,\~$'
<
The lone * is where all filenames not covered by one of the other patterns
will end up.  One may change the sorting sequence by modifying the
g:netrw_sort_sequence variable (either manually or in your <.vimrc>) or by
using the "S" map.

Related topics:               |netrw-s|               |netrw-S|
Associated setting variables: |g:netrw_sort_sequence| |g:netrw_sort_options|


EXECUTING FILE UNDER CURSOR VIA SYSTEM()			*netrw-X* {{{2

Pressing X while the cursor is atop an executable file will yield a prompt
using the filename asking for any arguments.  Upon pressing a [return], netrw
will then call |system()| with that command and arguments.  The result will be
displayed by |:echomsg|, and so |:messages| will repeat display of the result.
Ansi escape sequences will be stripped out.

See |cmdline-window| for directions for more on how to edit the arguments.


FORCING TREATMENT AS A FILE OR DIRECTORY	*netrw-gd* *netrw-gf* {{{2

Remote symbolic links (ie. those listed via ssh or ftp) are problematic
in that it is difficult to tell whether they link to a file or to a
directory.

To force treatment as a file: use >
	gf
<
To force treatment as a directory: use >
	gd
<

GOING UP							*netrw--* {{{2

To go up a directory, press "-" or press the <cr> when atop the ../ directory
entry in the listing.

Netrw will use the command in |g:netrw_list_cmd| to perform the directory
listing operation after changing HOSTNAME to the host specified by the
user-prpvided url.  By default netrw provides the command as: >

	ssh HOSTNAME ls -FLa
<
where the HOSTNAME becomes the [user@]hostname as requested by the attempt to
read.  Naturally, the user may override this command with whatever is
preferred.  The NetList function which implements remote browsing
expects that directories will be flagged by a trailing slash.


HIDING FILES OR DIRECTORIES			*netrw-a* *netrw-hiding* {{{2

Netrw's browsing facility allows one to use the hiding list in one of three
ways: ignore it, hide files which match, and show only those files which
match.

If no files have been marked via |netrw-mf|:

The "a" map allows the user to cycle through the three hiding modes.

The |g:netrw_list_hide| variable holds a comma delimited list of patterns
based on regular expressions (ex. ^.*\.obj$,^\.) which specify the hiding list.
(also see |netrw-ctrl-h|)  To set the hiding list, use the <c-h> map.  As an
example, to hide files which begin with a ".", one may use the <c-h> map to
set the hiding list to '^\..*' (or one may put let g:netrw_list_hide= '^\..*'
in one's <.vimrc>).  One may then use the "a" key to show all files, hide
matching files, or to show only the matching files.

	Example: \.[ch]$
		This hiding list command will hide/show all *.c and *.h files.

	Example: \.c$,\.h$
		This hiding list command will also hide/show all *.c and *.h
		files.

Don't forget to use the "a" map to select the mode (normal/hiding/show) you
want!

If files have been marked using |netrw-mf|, then this command will:

  if showing all files or non-hidden files:
   modify the g:netrw_list_hide list by appending the marked files to it
   and showing only non-hidden files.

  else if showing hidden files only:
   modify the g:netrw_list_hide list by removing the marked files from it
   and showing only non-hidden files.
  endif

					*netrw-gh* *netrw-hide*
As a quick shortcut, one may press >
	gh
to toggle between hiding files which begin with a period (dot) and not hiding
them.

Associated setting variables: |g:netrw_list_hide|  |g:netrw_hide|
Associated topics: |netrw-a| |netrw-ctrl-h| |netrw-mh|

					*netrw-gitignore*
Netrw provides a helper function 'netrw_gitignore#Hide()' that, when used with
|g:netrw_list_hide| automatically hides all git-ignored files.

'netrw_gitignore#Hide' searches for patterns in the following files: >

	'./.gitignore'
	'./.git/info/exclude'
	global gitignore file: `git config --global core.excludesfile`
	system gitignore file: `git config --system core.excludesfile`
<
Files that do not exist, are ignored.
Git-ignore patterns are taken from existing files, and converted to patterns for
hiding files. For example, if you had '*.log' in your '.gitignore' file, it
would be converted to '.*\.log'.

To use this function, simply assign its output to |g:netrw_list_hide| option.  >

	Example: let g:netrw_list_hide= netrw_gitignore#Hide()
		Git-ignored files are hidden in Netrw.

	Example: let g:netrw_list_hide= netrw_gitignore#Hide('my_gitignore_file')
		Function can take additional files with git-ignore patterns.

	Example: let g:netrw_list_hide= netrw_gitignore#Hide() .. '.*\.swp$'
		Combining 'netrw_gitignore#Hide' with custom patterns.
<

IMPROVING BROWSING			*netrw-listhack* *netrw-ssh-hack* {{{2

Especially with the remote directory browser, constantly entering the password
is tedious.

For Linux/Unix systems, the book "Linux Server Hacks - 100 industrial strength
tips & tools" by Rob Flickenger (O'Reilly, ISBN 0-596-00461-3) gives a tip
for setting up no-password ssh and scp and discusses associated security
issues.  It used to be available at http://hacks.oreilly.com/pub/h/66 ,
but apparently that address is now being redirected to some "hackzine".
I'll attempt a summary based on that article and on a communication from
Ben Schmidt:

	1. Generate a public/private key pair on the local machine
	   (ssh client): >
		ssh-keygen -t rsa
		(saving the file in ~/.ssh/id_rsa as prompted)
<
	2. Just hit the <CR> when asked for passphrase (twice) for no
	   passphrase.  If you do use a passphrase, you will also need to use
	   ssh-agent so you only have to type the passphrase once per session.
	   If you don't use a passphrase, simply logging onto your local
	   computer or getting access to the keyfile in any way will suffice
	   to access any ssh servers which have that key authorized for login.

	3. This creates two files: >
		~/.ssh/id_rsa
		~/.ssh/id_rsa.pub
<
	4. On the target machine (ssh server): >
		cd
		mkdir -p .ssh
		chmod 0700 .ssh
<
	5. On your local machine (ssh client): (one line) >
		ssh {serverhostname}
		  cat '>>' '~/.ssh/authorized_keys2' < ~/.ssh/id_rsa.pub
<
	   or, for OpenSSH, (one line) >
		ssh {serverhostname}
		  cat '>>' '~/.ssh/authorized_keys' < ~/.ssh/id_rsa.pub
<
You can test it out with >
	ssh {serverhostname}
and you should be log onto the server machine without further need to type
anything.

If you decided to use a passphrase, do: >
	ssh-agent $SHELL
	ssh-add
	ssh {serverhostname}
You will be prompted for your key passphrase when you use ssh-add, but not
subsequently when you use ssh.  For use with vim, you can use >
	ssh-agent vim
and, when next within vim, use >
	:!ssh-add
Alternatively, you can apply ssh-agent to the terminal you're planning on
running vim in: >
	ssh-agent xterm &
and do ssh-add whenever you need.

For Windows, folks on the vim mailing list have mentioned that Pageant helps
with avoiding the constant need to enter the password.

Kingston Fung wrote about another way to avoid constantly needing to enter
passwords:

    In order to avoid the need to type in the password for scp each time, you
    provide a hack in the docs to set up a non password ssh account. I found a
    better way to do that: I can use a regular ssh account which uses a
    password to access the material without the need to key-in the password
    each time. It's good for security and convenience. I tried ssh public key
    authorization + ssh-agent, implementing this, and it works! Here are two
    links with instructions:

    http://www.ibm.com/developerworks/library/l-keyc2/
    http://sial.org/howto/openssh/publickey-auth/
