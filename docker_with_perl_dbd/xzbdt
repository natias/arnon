 *	This symbol, if defined, indicates that the random_r routine
 *	is available to random re-entrantly.
 */
/* RANDOM_R_PROTO:
 *	This symbol encodes the prototype of random_r.
 *	It is zero if d_random_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_random_r
 *	is defined.
 */
#define HAS_RANDOM_R	/**/
#define RANDOM_R_PROTO REENTRANT_PROTO_I_St	/**/

/* HAS_READDIR64_R:
 *	This symbol, if defined, indicates that the readdir64_r routine
 *	is available to readdir64 re-entrantly.
 */
/* READDIR64_R_PROTO:
 *	This symbol encodes the prototype of readdir64_r.
 *	It is zero if d_readdir64_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_readdir64_r
 *	is defined.
 */
#define HAS_READDIR64_R	/**/
#define READDIR64_R_PROTO REENTRANT_PROTO_I_TSR	/**/

/* HAS_READDIR_R:
 *	This symbol, if defined, indicates that the readdir_r routine
 *	is available to readdir re-entrantly.
 */
/* READDIR_R_PROTO:
 *	This symbol encodes the prototype of readdir_r.
 *	It is zero if d_readdir_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_readdir_r
 *	is defined.
 */
#define HAS_READDIR_R	/**/
#define READDIR_R_PROTO REENTRANT_PROTO_I_TSR	/**/

/* HAS_SETGRENT_R:
 *	This symbol, if defined, indicates that the setgrent_r routine
 *	is available to setgrent re-entrantly.
 */
/* SETGRENT_R_PROTO:
 *	This symbol encodes the prototype of setgrent_r.
 *	It is zero if d_setgrent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setgrent_r
 *	is defined.
 */
/*#define HAS_SETGRENT_R	/ **/
#define SETGRENT_R_PROTO 0	/**/

/* HAS_SETHOSTENT_R:
 *	This symbol, if defined, indicates that the sethostent_r routine
 *	is available to sethostent re-entrantly.
 */
/* SETHOSTENT_R_PROTO:
 *	This symbol encodes the prototype of sethostent_r.
 *	It is zero if d_sethostent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_sethostent_r
 *	is defined.
 */
/*#define HAS_SETHOSTENT_R	/ **/
#define SETHOSTENT_R_PROTO 0	/**/

/* HAS_SETLOCALE_R:
 *	This symbol, if defined, indicates that the setlocale_r routine
 *	is available to setlocale re-entrantly.
 */
/* SETLOCALE_R_PROTO:
 *	This symbol encodes the prototype of setlocale_r.
 *	It is zero if d_setlocale_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setlocale_r
 *	is defined.
 */
/*#define HAS_SETLOCALE_R	/ **/
#define SETLOCALE_R_PROTO 0	/**/

/* HAS_SETNETENT_R:
 *	This symbol, if defined, indicates that the setnetent_r routine
 *	is available to setnetent re-entrantly.
 */
/* SETNETENT_R_PROTO:
 *	This symbol encodes the prototype of setnetent_r.
 *	It is zero if d_setnetent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setnetent_r
 *	is defined.
 */
/*#define HAS_SETNETENT_R	/ **/
#define SETNETENT_R_PROTO 0	/**/

/* HAS_SETPROTOENT_R:
 *	This symbol, if defined, indicates that the setprotoent_r routine
 *	is available to setprotoent re-entrantly.
 */
/* SETPROTOENT_R_PROTO:
 *	This symbol encodes the prototype of setprotoent_r.
 *	It is zero if d_setprotoent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setprotoent_r
 *	is defined.
 */
/*#define HAS_SETPROTOENT_R	/ **/
#define SETPROTOENT_R_PROTO 0	/**/

/* HAS_SETPWENT_R:
 *	This symbol, if defined, indicates that the setpwent_r routine
 *	is available to setpwent re-entrantly.
 */
/* SETPWENT_R_PROTO:
 *	This symbol encodes the prototype of setpwent_r.
 *	It is zero if d_setpwent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setpwent_r
 *	is defined.
 */
/*#define HAS_SETPWENT_R	/ **/
#define SETPWENT_R_PROTO 0	/**/

/* HAS_SETSERVENT_R:
 *	This symbol, if defined, indicates that the setservent_r routine
 *	is available to setservent re-entrantly.
 */
/* SETSERVENT_R_PROTO:
 *	This symbol encodes the prototype of setservent_r.
 *	It is zero if d_setservent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setservent_r
 *	is defined.
 */
/*#define HAS_SETSERVENT_R	/ **/
#define SETSERVENT_R_PROTO 0	/**/

/* HAS_SRAND48_R:
 *	This symbol, if defined, indicates that the srand48_r routine
 *	is available to srand48 re-entrantly.
 */
/* SRAND48_R_PROTO:
 *	This symbol encodes the prototype of srand48_r.
 *	It is zero if d_srand48_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_srand48_r
 *	is defined.
 */
#define HAS_SRAND48_R	/**/
#define SRAND48_R_PROTO REENTRANT_PROTO_I_LS	/**/

/* HAS_SRANDOM_R:
 *	This symbol, if defined, indicates that the srandom_r routine
 *	is available to srandom re-entrantly.
 */
/* SRANDOM_R_PROTO:
 *	This symbol encodes the prototype of srandom_r.
 *	It is zero if d_srandom_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_srandom_r
 *	is defined.
 */
#define HAS_SRANDOM_R	/**/
#define SRANDOM_R_PROTO REENTRANT_PROTO_I_TS	/**/

/* HAS_STRERROR_R:
 *	This symbol, if defined, indicates that the strerror_r routine
 *	is available to strerror re-entrantly.
 */
/* STRERROR_R_PROTO:
 *	This symbol encodes the prototype of strerror_r.
 *	It is zero if d_strerror_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_strerror_r
 *	is defined.
 */
#define HAS_STRERROR_R	/**/
#define STRERROR_R_PROTO REENTRANT_PROTO_B_IBW	/**/

/* HAS_STRTOD_L:
 *	This symbol, if defined, indicates that the strtod_l routine is
 *	available to convert strings to long doubles.
 */
#define HAS_STRTOD_L		/**/

/* HAS_STRTOLD_L:
 *	This symbol, if defined, indicates that the strtold_l routine is
 *	available to convert strings to long doubles.
 */
#define HAS_STRTOLD_L		/**/

/* PERL_THREAD_LOCAL:
 *	This symbol, if defined, gives a linkage specification for thread-local
 *	storage. For example, for a C11 compiler this will be _Thread_local.
 *	Beware, some compilers are sensitive to the C language standard they are
 *	told to parse. For example, suncc defaults to C11, so our probe will
 *	report that _Thread_local can be used. However, if the -std=c99 is later
 *	added to the compiler flags, then _Thread_local will become a syntax
 *	error. Hence it is important for these flags to be consistent between
 *	probing and use.
 */
#define PERL_THREAD_LOCAL _Thread_local	/**/

/* HAS_TMPNAM_R:
 *	This symbol, if defined, indicates that the tmpnam_r routine
 *	is available to tmpnam re-entrantly.
 */
/* TMPNAM_R_PROTO:
 *	This symbol encodes the prototype of tmpnam_r.
 *	It is zero if d_tmpnam_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_tmpnam_r
 *	is defined.
 */
#define HAS_TMPNAM_R	/**/
#define TMPNAM_R_PROTO REENTRANT_PROTO_B_B	/**/

/* HAS_TTYNAME_R:
 *	This symbol, if defined, indicates that the ttyname_r routine
 *	is available to ttyname re-entrantly.
 */
/* TTYNAME_R_PROTO:
 *	This symbol encodes the prototype of ttyname_r.
 *	It is zero if d_ttyname_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_ttyname_r
 *	is defined.
 */
#define HAS_TTYNAME_R	/**/
#define TTYNAME_R_PROTO REENTRANT_PROTO_I_IBW	/**/

/* HAS_WCRTOMB:
 *	This symbol, if defined, indicates that the wcrtomb routine is
 *	available to convert a wide character into a multi-byte character.
 */
#define HAS_WCRTOMB	/**/

/* I_MACH_CTHREADS:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <mach/cthreads.h>.
 */
/*#define   I_MACH_CTHREADS	/ **/

/* I_PTHREAD:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <pthread.h>.
 */
#define   I_PTHREAD	/**/

/* USE_ITHREADS:
 *	This symbol, if defined, indicates that Perl should be built to
 *	use the interpreter-based threading implementation.
 */
/* USE_THREADS:
 *	This symbol, if defined, indicates that Perl should
 *	be built to use threads.  At present, it is a synonym for
 *	and USE_ITHREADS, but eventually the source ought to be
 *	changed to use this to mean _any_ threading implementation.
 */
/* OLD_PTHREADS_API:
 *	This symbol, if defined, indicates that Perl should
 *	be built to use the old draft POSIX threads API.
 */
/* USE_REENTRANT_API:
 *	This symbol, if defined, indicates that Perl should
 *	try to use the various _r versions of library functions.
 *	This is extremely experimental.
 */
#define	USE_ITHREADS		/**/
#define		USE_THREADS		/**/
/*#define	OLD_PTHREADS_API		/ **/
/*#define	USE_REENTRANT_API	/ **/

/* HAS_TIME:
 *	This symbol, if defined, indicates that the time() routine exists.
 */
/* Time_t:
 *	This symbol holds the type returned by time(). It can be long,
 *	or time_t on BSD sites (in which case <sys/types.h> should be
 *	included).
 */
#define HAS_TIME		/**/
#define Time_t time_t		/* Time type */

/* HAS_TIMES:
 *	This symbol, if defined, indicates that the times() routine exists.
 *	Note that this became obsolete on some systems (SUNOS), which now
 *	use getrusage(). It may be necessary to include <sys/times.h>.
 */
#define HAS_TIMES		/**/

/* Fpos_t:
 *	This symbol holds the type used to declare file positions in libc.
 *	It can be fpos_t, long, uint, etc... It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Fpos_t fpos_t		/* File position type */

/* Gid_t_f:
 *	This symbol defines the format string used for printing a Gid_t.
 */
#define	Gid_t_f		"u"		/**/

/* Gid_t_sign:
 *	This symbol holds the signedness of a Gid_t.
 *	1 for unsigned, -1 for signed.
 */
#define Gid_t_sign	1		/* GID sign */

/* Gid_t_size:
 *	This symbol holds the size of a Gid_t in bytes.
 */
#define Gid_t_size 4		/* GID size */

/* Gid_t:
 *	This symbol holds the return type of getgid() and the type of
 *	argument to setrgid() and related functions.  Typically,
 *	it is the type of group ids in the kernel. It can be int, ushort,
 *	gid_t, etc... It may be necessary to include <sys/types.h> to get
 *	any typedef'ed information.
 */
#define Gid_t gid_t		/* Type for getgid(), etc... */

/* Off_t:
 *	This symbol holds the type used to declare offsets in the kernel.
 *	It can be int, long, off_t, etc... It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
/* LSEEKSIZE:
 *	This symbol holds the number of bytes used by the Off_t.
 */
/* Off_t_size:
 *	This symbol holds the number of bytes used by the Off_t.
 */
#define Off_t off_t		/* <offset> type */
#define LSEEKSIZE 8		/* <offset> size */
#define Off_t_size 8	/* <offset> size */

/* Mode_t:
 *	This symbol holds the type used to declare file modes
 *	for systems calls.  It is usually mode_t, but may be
 *	int or unsigned short.  It may be necessary to include <sys/types.h>
 *	to get any typedef'ed information.
 */
#define Mode_t mode_t	 /* file mode parameter for system calls */

/* Pid_t:
 *	This symbol holds the type used to declare process ids in the kernel.
 *	It can be int, uint, pid_t, etc... It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Pid_t pid_t		/* PID type */

/* Size_t_size:
 *	This symbol holds the size of a Size_t in bytes.
 */
#define Size_t_size 8		/**/

/* Size_t:
 *	This symbol holds the type used to declare length parameters
 *	for string functions.  It is usually size_t, but may be
 *	unsigned long, int, etc.  It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Size_t size_t	 /* length parameter for string functions */

/* Uid_t_f:
 *	This symbol defines the format string used for printing a Uid_t.
 */
#define	Uid_t_f		"u"		/**/

/* Uid_t_sign:
 *	This symbol holds the signedness of a Uid_t.
 *	1 for unsigned, -1 for signed.
 */
#define Uid_t_sign	1		/* UID sign */

/* Uid_t_size:
 *	This symbol holds the size of a Uid_t in bytes.
 */
#define Uid_t_size 4		/* UID size */

/* Uid_t:
 *	This symbol holds the type used to declare user ids in the kernel.
 *	It can be int, ushort, uid_t, etc... It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Uid_t uid_t		/* UID type */

#define PERL_BUILD_DATE "Nov 25 2023 20:59:54"
#endif
                                                                                                                                                                                                   usr/lib/x86_64-linux-gnu/perl/5.36.0/CORE/cop.h                                                     0000644 0000000 0000000 00000144333 14530460112 016666  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*    cop.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * Control ops (cops) are one of the two ops OP_NEXTSTATE and OP_DBSTATE,
 * that (loosely speaking) are statement separators.
 * They hold information important for lexical state and error reporting.
 * At run time, PL_curcop is set to point to the most recently executed cop,
 * and thus can be used to determine our current state.
 */

/* A jmpenv packages the state required to perform a proper non-local jump.
 * Note that there is a PL_start_env initialized when perl starts, and
 * PL_top_env points to this initially, so PL_top_env should always be
 * non-null.
 *
 * Existence of a non-null PL_top_env->je_prev implies it is valid to call
 * longjmp() at that runlevel (we make sure PL_start_env.je_prev is always
 * null to ensure this).
 *
 * je_mustcatch, when set at any runlevel to TRUE, means eval ops must
 * establish a local jmpenv to handle exception traps.  Care must be taken
 * to restore the previous value of je_mustcatch before exiting the
 * stack frame iff JMPENV_PUSH was not called in that stack frame.
 * GSAR 97-03-27
 */

struct jmpenv {
    struct jmpenv *	je_prev;
    Sigjmp_buf		je_buf;		/* uninit if je_prev is NULL */
    int			je_ret;		/* last exception thrown */
    bool		je_mustcatch;	/* need to call longjmp()? */
    U16                 je_old_delaymagic; /* saved PL_delaymagic */
    SSize_t             je_old_stack_hwm;
};

typedef struct jmpenv JMPENV;

#if defined DEBUGGING && !defined DEBUGGING_RE_ONLY
#  define JE_OLD_STACK_HWM_zero      PL_start_env.je_old_stack_hwm = 0
#  define JE_OLD_STACK_HWM_save(je)  \
        (je).je_old_stack_hwm = PL_curstackinfo->si_stack_hwm
#  define JE_OLD_STACK_HWM_restore(je)  \
        if (PL_curstackinfo->si_stack_hwm < (je).je_old_stack_hwm) \
            PL_curstackinfo->si_stack_hwm = (je).je_old_stack_hwm
#else
#  define JE_OLD_STACK_HWM_zero        NOOP
#  define JE_OLD_STACK_HWM_save(je)    NOOP
#  define JE_OLD_STACK_HWM_restore(je) NOOP
#endif

/*
 * How to build the first jmpenv.
 *
 * top_env needs to be non-zero. It points to an area
 * in which longjmp() stuff is stored, as C callstack
 * info there at least is thread specific this has to
 * be per-thread. Otherwise a 'die' in a thread gives
 * that thread the C stack of last thread to do an eval {}!
 */

#define JMPENV_BOOTSTRAP \
    STMT_START {				\
        PERL_POISON_EXPR(PoisonNew(&PL_start_env, 1, JMPENV));\
        PL_top_env = &PL_start_env;		\
        PL_start_env.je_prev = NULL;		\
        PL_start_env.je_ret = -1;		\
        PL_start_env.je_mustcatch = TRUE;	\
        PL_start_env.je_old_delaymagic = 0;	\
        JE_OLD_STACK_HWM_zero;                  \
    } STMT_END

/*
 *   PERL_FLEXIBLE_EXCEPTIONS
 *
 * All the flexible exceptions code has been removed.
 * See the following threads for details:
 *
 *   Message-Id: 20040713143217.GB1424@plum.flirble.org
 *   https://www.nntp.perl.org/group/perl.perl5.porters/2004/07/msg93041.html
 *
 * Joshua's original patches (which weren't applied) and discussion:
 *
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg01396.html
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg01489.html
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg01491.html
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg01608.html
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg02144.html
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg02998.html
 *
 * Chip's reworked patch and discussion:
 *
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1999-03/msg00520.html
 *
 * The flaw in these patches (which went unnoticed at the time) was
 * that they moved some code that could potentially die() out of the
 * region protected by the setjmp()s.  This caused exceptions within
 * END blocks and such to not be handled by the correct setjmp().
 *
 * The original patches that introduces flexible exceptions were:
 *
 * https://github.com/Perl/perl5/commit/312caa8e97f1c7ee342a9895c2f0e749625b4929
 * https://github.com/Perl/perl5/commit/14dd3ad8c9bf82cf09798a22cc89a9862dfd6d1a
 *
 */

#define dJMPENV		JMPENV cur_env

#define JMPENV_PUSH(v) \
    STMT_START {							\
        DEBUG_l({							\
            int i = 0; JMPENV *p = PL_top_env;				\
            while (p) { i++; p = p->je_prev; }				\
            Perl_deb(aTHX_ "JUMPENV_PUSH level=%d at %s:%d\n",		\
                         i,  __FILE__, __LINE__);})			\
        cur_env.je_prev = PL_top_env;					\
        JE_OLD_STACK_HWM_save(cur_env);                                 \
        cur_env.je_ret = PerlProc_setjmp(cur_env.je_buf, SCOPE_SAVES_SIGNAL_MASK);		\
        JE_OLD_STACK_HWM_restore(cur_env);                              \
        PL_top_env = &cur_env;						\
        cur_env.je_mustcatch = FALSE;					\
        cur_env.je_old_delaymagic = PL_delaymagic;			\
        (v) = cur_env.je_ret;						\
    } STMT_END

#define JMPENV_POP \
    STMT_START {							\
        DEBUG_l({							\
            int i = -1; JMPENV *p = PL_top_env;				\
            while (p) { i++; p = p->je_prev; }				\
            Perl_deb(aTHX_ "JUMPENV_POP level=%d at %s:%d\n",		\
                         i, __FILE__, __LINE__);})			\
        assert(PL_top_env == &cur_env);					\
        PL_delaymagic = cur_env.je_old_delaymagic;			\
        PL_top_env = cur_env.je_prev;					\
    } STMT_END

#define JMPENV_JUMP(v) \
    STMT_START {						\
        DEBUG_l({						\
            int i = -1; JMPENV *p = PL_top_env;			\
            while (p) { i++; p = p->je_prev; }			\
            Perl_deb(aTHX_ "JUMPENV_JUMP(%d) level=%d at %s:%d\n", \
                         (int)v, i, __FILE__, __LINE__);})	\
        if (PL_top_env->je_prev)				\
            PerlProc_longjmp(PL_top_env->je_buf, (v));		\
        if ((v) == 2)						\
            PerlProc_exit(STATUS_EXIT);		                \
        PerlIO_printf(PerlIO_stderr(), "panic: top_env, v=%d\n", (int)v); \
        PerlProc_exit(1);					\
    } STMT_END

#define CATCH_GET		(PL_top_env->je_mustcatch)
#define CATCH_SET(v) \
    STMT_START {							\
        DEBUG_l(							\
            Perl_deb(aTHX_						\
                "JUMPLEVEL set catch %d => %d (for %p) at %s:%d\n",	\
                 PL_top_env->je_mustcatch, v, (void*)PL_top_env,	\
                 __FILE__, __LINE__);)					\
        PL_top_env->je_mustcatch = (v);					\
    } STMT_END

/*
=for apidoc_section $COP
*/

typedef struct refcounted_he COPHH;

#define COPHH_KEY_UTF8 REFCOUNTED_HE_KEY_UTF8
#define COPHH_EXISTS REFCOUNTED_HE_EXISTS

/*
=for apidoc  Amx|SV *|cophh_fetch_pvn|const COPHH *cophh|const char *key|STRLEN keylen|U32 hash|U32 flags
=for apidoc_item|SV *|cophh_fetch_pv |const COPHH *cophh|const char *key              |U32 hash|U32 flags
=for apidoc_item|SV *|cophh_fetch_pvs|const COPHH *cophh|           "key"                      |U32 flags
=for apidoc_item|SV *|cophh_fetch_sv |const COPHH *cophh|        SV *key              |U32 hash|U32 flags

These look up the entry in the cop hints hash C<cophh> with the key specified by
C<key> (and C<keylen> in the C<pvn> form), returning that value as a mortal
scalar copy, or C<&PL_sv_placeholder> if there is no value associated with the
key.

The forms differ in how the key is specified.
In the plain C<pv> form, the key is a C language NUL-terminated string.
In the C<pvs> form, the key is a C language string literal.
In the C<pvn> form, an additional parameter, C<keylen>, specifies the length of
the string, which hence, may contain embedded-NUL characters.
In the C<sv> form, C<*key> is an SV, and the key is the PV extracted from that.
using C<L</SvPV_const>>.

C<hash> is a precomputed hash of the key string, or zero if it has not been
precomputed.  This parameter is omitted from the C<pvs> form, as it is computed
automatically at compile time.

The only flag currently used from the C<flags> parameter is C<COPHH_KEY_UTF8>.
It is illegal to set this in the C<sv> form.  In the C<pv*> forms, it specifies
whether the key octets are interpreted as UTF-8 (if set) or as Latin-1 (if
cleared).  The C<sv> form uses the underlying SV to determine the UTF-8ness of
the octets.

=for apidoc Amnh||COPHH_KEY_UTF8

=cut
*/

#define cophh_fetch_pvn(cophh, key, keylen, hash, flags) \
    Perl_refcounted_he_fetch_pvn(aTHX_ cophh, key, keylen, hash, flags)

#define cophh_fetch_pvs(cophh, key, flags) \
    Perl_refcounted_he_fetch_pvn(aTHX_ cophh, STR_WITH_LEN(key), 0, flags)

#define cophh_fetch_pv(cophh, key, hash, flags) \
    Perl_refcounted_he_fetch_pv(aTHX_ cophh, key, hash, flags)

#define cophh_fetch_sv(cophh, key, hash, flags) \
    Perl_refcounted_he_fetch_sv(aTHX_ cophh, key, hash, flags)

/*
=for apidoc Amx|bool|cophh_exists_pvn|const COPHH *cophh|const char *key|STRLEN keylen|U32 hash|U32 flags

These look up the hint entry in the cop C<cop> with the key specified by
C<key> (and C<keylen> in the C<pvn> form), returning true if a value exists,
and false otherwise.

The forms differ in how the key is specified.
In the plain C<pv> form, the key is a C language NUL-terminated string.
In the C<pvs> form, the key is a C language string literal.
In the C<pvn> form, an additional parameter, C<keylen>, specifies the length of
the string, which hence, may contain embedded-NUL characters.
In the C<sv> form, C<*key> is an SV, and the key is the PV extracted from that.
using C<L</SvPV_const>>.

C<hash> is a precomputed hash of the key string, or zero if it has not been
precomputed.  This parameter is omitted from the C<pvs> form, as it is computed
automatically at compile time.

The only flag currently used from the C<flags> parameter is C<COPHH_KEY_UTF8>.
It is illegal to set this in the C<sv> form.  In the C<pv*> forms, it specifies
whether the key octets are interpreted as UTF-8 (if set) or as Latin-1 (if
cleared).  The C<sv> form uses the underlying SV to determine the UTF-8ness of
the octets.

=cut
*/

#define cophh_exists_pvn(cophh, key, keylen, hash, flags) \
    cBOOL(Perl_refcounted_he_fetch_pvn(aTHX_ cophh, key, keylen, hash, flags | COPHH_EXISTS))

#define cophh_exists_pvs(cophh, key, flags) \
    cBOOL(Perl_refcounted_he_fetch_pvn(aTHX_ cophh, STR_WITH_LEN(key), 0, flags | COPHH_EXISTS))

#define cophh_exists_pv(cophh, key, hash, flags) \
    cBOOL(Perl_refcounted_he_fetch_pv(aTHX_ cophh, key, hash, flags | COPHH_EXISTS))

#define cophh_exists_sv(cophh, key, hash, flags) \
    cBOOL(Perl_refcounted_he_fetch_sv(aTHX_ cophh, key, hash, flags | COPHH_EXISTS))

/*
=for apidoc Amx|HV *|cophh_2hv|const COPHH *cophh|U32 flags

Generates and returns a standard Perl hash representing the full set of
key/value pairs in the cop hints hash C<cophh>.  C<flags> is currently
unused and must be zero.

=cut
*/

#define cophh_2hv(cophh, flags) \
    Perl_refcounted_he_chain_2hv(aTHX_ cophh, flags)

/*
=for apidoc Amx|COPHH *|cophh_copy|COPHH *cophh

Make and return a complete copy of the cop hints hash C<cophh>.

=cut
*/

#define cophh_copy(cophh) Perl_refcounted_he_inc(aTHX_ cophh)

/*
=for apidoc Amx|void|cophh_free|COPHH *cophh

Discard the cop hints hash C<cophh>, freeing all resources associated
with it.

=cut
*/

#define cophh_free(cophh) Perl_refcounted_he_free(aTHX_ cophh)

/*
=for apidoc Amx|COPHH *|cophh_new_empty

Generate and return a fresh cop hints hash containing no entries.

=cut
*/

#define cophh_new_empty() ((COPHH *)NULL)

/*
=for apidoc  Amx|COPHH *|cophh_store_pvn|COPHH *cophh|const char *key|STRLEN keylen|U32 hash|SV *value|U32 flags
=for apidoc_item|COPHH *|cophh_store_pv |COPHH *cophh|const char *key              |U32 hash|SV *value|U32 flags
=for apidoc_item|COPHH *|cophh_store_pvs|COPHH *cophh|           "key"                      |SV *value|U32 flags
=for apidoc_item|COPHH *|cophh_store_sv |COPHH *cophh|        SV *key              |U32 hash|SV *value|U32 flags

These store a value, associated with a key, in the cop hints hash C<cophh>,
and return the modified hash.  The returned hash pointer is in general
not the same as the hash pointer that was passed in.  The input hash is
consumed by the function, and the pointer to it must not be subsequently
used.  Use L</cophh_copy> if you need both hashes.

C<value> is the scalar value to store for this key.  C<value> is copied
by these functions, which thus do not take ownership of any reference
to it, and hence later changes to the scalar will not be reflected in the value
visible in the cop hints hash.  Complex types of scalar will not be stored with
referential integrity, but will be coerced to strings.

The forms differ in how the key is specified.  In all forms, the key is pointed
to by C<key>.
In the plain C<pv> form, the key is a C language NUL-terminated string.
In the C<pvs> form, the key is a C language string literal.
In the C<pvn> form, an additional parameter, C<keylen>, specifies the length of
the string, which hence, may contain embedded-NUL characters.
In the C<sv> form, C<*key> is an SV, and the key is the PV extracted from that.
using C<L</SvPV_const>>.

C<hash> is a precomputed hash of the key string, or zero if it has not been
precomputed.  This parameter is omitted from the C<pvs> form, as it is computed
automatically at compile time.

The only flag currently used from the C<flags> parameter is C<COPHH_KEY_UTF8>.
It is illegal to set this in the C<sv> form.  In the C<pv*> forms, it specifies
whether the key octets are interpreted as UTF-8 (if set) or as Latin-1 (if
cleared).  The C<sv> form uses the underlying SV to determine the UTF-8ness of
the octets.

=cut
*/

#define cophh_store_pvn(cophh, key, keylen, hash, value, flags) \
    Perl_refcounted_he_new_pvn(aTHX_ cophh, key, keylen, hash, value, flags)

#define cophh_store_pvs(cophh, key, value, flags) \
    Perl_refcounted_he_new_pvn(aTHX_ cophh, STR_WITH_LEN(key), 0, value, flags)

#define cophh_store_pv(cophh, key, hash, value, flags) \
    Perl_refcounted_he_new_pv(aTHX_ cophh, key, hash, value, flags)

#define cophh_store_sv(cophh, key, hash, value, flags) \
    Perl_refcounted_he_new_sv(aTHX_ cophh, key, hash, value, flags)

/*
=for apidoc  Amx|COPHH *|cophh_delete_pvn|COPHH *cophh|const char *key|STRLEN keylen|U32 hash|U32 flags
=for apidoc_item|COPHH *|cophh_delete_pv |COPHH *cophh|const char *key              |U32 hash|U32 flags
=for apidoc_item|COPHH *|cophh_delete_pvs|COPHH *cophh|           "key"                      |U32 flags
=for apidoc_item|COPHH *|cophh_delete_sv |COPHH *cophh|        SV *key              |U32 hash|U32 flags

These delete a key and its associated value from the cop hints hash C<cophh>,
and return the modified hash.  The returned hash pointer is in general
not the same as the hash pointer that was passed in.  The input hash is
consumed by the function, and the pointer to it must not be subsequently
used.  Use L</cophh_copy> if you need both hashes.

The forms differ in how the key is specified.  In all forms, the key is pointed
to by C<key>.
In the plain C<pv> form, the key is a C language NUL-terminated string.
In the C<pvs> form, the key is a C language string literal.
In the C<pvn> form, an additional parameter, C<keylen>, specifies the length of
the string, which hence, may contain embedded-NUL characters.
In the C<sv> form, C<*key> is an SV, and the key is the PV extracted from that.
using C<L</SvPV_const>>.

C<hash> is a precomputed hash of the key string, or zero if it has not been
precomputed.  This parameter is omitted from the C<pvs> form, as it is computed
automatically at compile time.

The only flag currently used from the C<flags> parameter is C<COPHH_KEY_UTF8>.
It is illegal to set this in the C<sv> form.  In the C<pv*> forms, it specifies
whether the key octets are interpreted as UTF-8 (if set) or as Latin-1 (if
cleared).  The C<sv> form uses the underlying SV to determine the UTF-8ness of
the octets.

=cut
*/

#define cophh_delete_pvn(cophh, key, keylen, hash, flags) \
    Perl_refcounted_he_new_pvn(aTHX_ cophh, key, keylen, hash, \
        (SV *)NULL, flags)

#define cophh_delete_pvs(cophh, key, flags) \
    Perl_refcounted_he_new_pvn(aTHX_ cophh, STR_WITH_LEN(key), 0, \
        (SV *)NULL, flags)

#define cophh_delete_pv(cophh, key, hash, flags) \
    Perl_refcounted_he_new_pv(aTHX_ cophh, key, hash, (SV *)NULL, flags)

#define cophh_delete_sv(cophh, key, hash, flags) \
    Perl_refcounted_he_new_sv(aTHX_ cophh, key, hash, (SV *)NULL, flags)

#include "mydtrace.h"

struct cop {
    BASEOP
    /* On LP64 putting this here takes advantage of the fact that BASEOP isn't
       an exact multiple of 8 bytes to save structure padding.  */
    line_t      cop_line;       /* line # of this command */
    /* label for this construct is now stored in cop_hints_hash */
#ifdef USE_ITHREADS
    PADOFFSET	cop_stashoff;	/* offset into PL_stashpad, for the
                                   package the line was compiled in */
    char *	cop_file;	/* name of file this command is from */
#else
    HV *	cop_stash;	/* package line was compiled in */
    GV *	cop_filegv;	/* name of GV file this command is from */
#endif
    U32		cop_hints;	/* hints bits from pragmata */
    U32		cop_seq;	/* parse sequence number */
    /* Beware. mg.c and warnings.pl assume the type of this is STRLEN *:  */
    STRLEN *	cop_warnings;	/* lexical warnings bitmask */
    /* compile time state of %^H.  See the comment in op.c for how this is
       used to recreate a hash to return from caller.  */
    COPHH *	cop_hints_hash;
    /* for now just a bitmask stored here.
       If we get sufficient features this may become a pointer.
       How these flags are stored is subject to change without
       notice.  Use the macros to test for features.
    */
    U32		cop_features;
};

/*
=for apidoc Am|const char *|CopFILE|const COP * c
Returns the name of the file associated with the C<COP> C<c>

=for apidoc Am|STRLEN|CopLINE|const COP * c
Returns the line number in the source code associated with the C<COP> C<c>

=for apidoc Am|AV *|CopFILEAV|const COP * c
Returns the AV associated with the C<COP> C<c>, creating it if necessary.

=for apidoc Am|AV *|CopFILEAVn|const COP * c
Returns the AV associated with the C<COP> C<c>, returning NULL if it
doesn't already exist.

=for apidoc Am|SV *|CopFILESV|const COP * c
Returns the SV associated with the C<COP> C<c>

=for apidoc Am|void|CopFILE_set|COP * c|const char * pv
Makes C<pv> the name of the file associated with the C<COP> C<c>

=for apidoc Am|GV *|CopFILEGV|const COP * c
Returns the GV associated with the C<COP> C<c>

=for apidoc CopFILEGV_set
Available only on unthreaded perls.  Makes C<pv> the name of the file
associated with the C<COP> C<c>

=for apidoc Am|HV *|CopSTASH|const COP * c
Returns the stash associated with C<c>.

=for apidoc Am|bool|CopSTASH_eq|const COP * c|const HV * hv
Returns a boolean as to whether or not C<hv> is the stash associated with C<c>.

=for apidoc Am|bool|CopSTASH_set|COP * c|HV * hv
Set the stash associated with C<c> to C<hv>.

=for apidoc Am|char *|CopSTASHPV|const COP * c
Returns the package name of the stash associated with C<c>, or C<NULL> if no
associated stash

=for apidoc Am|void|CopSTASHPV_set|COP * c|const char * pv
Set the package name of the stash associated with C<c>, to the NUL-terminated C
string C<p>, creating the package if necessary.

=cut
*/

#ifdef USE_ITHREADS

#  define CopFILE(c)		((c)->cop_file)
#  define CopFILEGV(c)		(CopFILE(c) \
                                 ? gv_fetchfile(CopFILE(c)) : NULL)

#  define CopFILE_set(c,pv)	((c)->cop_file = savesharedpv(pv))
#  define CopFILE_setn(c,pv,l)  ((c)->cop_file = savesharedpvn((pv),(l)))

#  define CopFILESV(c)		(CopFILE(c) \
                                 ? GvSV(gv_fetchfile(CopFILE(c))) : NULL)
#  define CopFILEAV(c)		(CopFILE(c) \
                                 ? GvAV(gv_fetchfile(CopFILE(c))) : NULL)
#  define CopFILEAVx(c)		(assert_(CopFILE(c)) \
                                   GvAV(gv_fetchfile(CopFILE(c))))
#  define CopFILEAVn(c)         (cop_file_avn(c))
#  define CopSTASH(c)           PL_stashpad[(c)->cop_stashoff]
#  define CopSTASH_set(c,hv)	((c)->cop_stashoff = (hv)		\
                                    ? alloccopstash(hv)			\
                                    : 0)
#  define CopFILE_free(c)	(PerlMemShared_free(CopFILE(c)),(CopFILE(c) = NULL))

#else /* Above: yes threads; Below no threads */

#  define CopFILEGV(c)		((c)->cop_filegv)
#  define CopFILEGV_set(c,gv)	((c)->cop_filegv = (GV*)SvREFCNT_inc(gv))
#  define CopFILE_set(c,pv)	CopFILEGV_set((c), gv_fetchfile(pv))
#  define CopFILE_setn(c,pv,l)	CopFILEGV_set((c), gv_fetchfile_flags((pv),(l),0))
#  define CopFILESV(c)		(CopFILEGV(c) ? GvSV(CopFILEGV(c)) : NULL)
#  define CopFILEAV(c)		(CopFILEGV(c) ? GvAV(CopFILEGV(c)) : NULL)
#  ifdef DEBUGGING
#    define CopFILEAVx(c)	(assert(CopFILEGV(c)), GvAV(CopFILEGV(c)))
#  else
#    define CopFILEAVx(c)	(GvAV(CopFILEGV(c)))
# endif
#  define CopFILEAVn(c)         (CopFILEGV(c) ? GvAVn(CopFILEGV(c)) : NULL)
#  define CopFILE(c)		(CopFILEGV(c) /* +2 for '_<' */         \
                                    ? GvNAME(CopFILEGV(c))+2 : NULL)
#  define CopSTASH(c)		((c)->cop_stash)
#  define CopSTASH_set(c,hv)	((c)->cop_stash = (hv))
#  define CopFILE_free(c)	(SvREFCNT_dec(CopFILEGV(c)),(CopFILEGV(c) = NULL))

#endif /* USE_ITHREADS */

#define CopSTASHPV(c)		(CopSTASH(c) ? HvNAME_get(CopSTASH(c)) : NULL)
   /* cop_stash is not refcounted */
#define CopSTASHPV_set(c,pv)	CopSTASH_set((c), gv_stashpv(pv,GV_ADD))
#define CopSTASH_eq(c,hv)	(CopSTASH(c) == (hv))

#define CopHINTHASH_get(c)	((COPHH*)((c)->cop_hints_hash))
#define CopHINTHASH_set(c,h)	((c)->cop_hints_hash = (h))

/*
=for apidoc   Am|SV *|cop_hints_fetch_pvn|const COP *cop|const char *key|STRLEN keylen|U32 hash|U32 flags
=for apidoc_item|SV *|cop_hints_fetch_pv |const COP *cop|const char *key              |U32 hash|U32 flags
=for apidoc_item|SV *|cop_hints_fetch_pvs|const COP *cop|           "key"                      |U32 flags
=for apidoc_item|SV *|cop_hints_fetch_sv |const COP *cop|        SV *key              |U32 hash|U32 flags

These look up the hint entry in the cop C<cop> with the key specified by
C<key> (and C<keylen> in the C<pvn> form), returning that value as a mortal
scalar copy, or C<&PL_sv_placeholder> if there is no value associated with the
key.

The forms differ in how the key is specified.
In the plain C<pv> form, the key is a C language NUL-terminated string.
In the C<pvs> form, the key is a C language string literal.
In the C<pvn> form, an additional parameter, C<keylen>, specifies the length of
the string, which hence, may contain embedded-NUL characters.
In the C<sv> form, C<*key> is an SV, and the key is the PV extracted from that.
using C<L</SvPV_const>>.

C<hash> is a precomputed hash of the key string, or zero if it has not been
precomputed.  This parameter is omitted from the C<pvs> form, as it is computed
automatically at compile time.

The only flag currently used from the C<flags> parameter is C<COPHH_KEY_UTF8>.
It is illegal to set this in the C<sv> form.  In the C<pv*> forms, it specifies
whether the key octets are interpreted as UTF-8 (if set) or as Latin-1 (if
cleared).  The C<sv> form uses the underlying SV to determine the UTF-8ness of
the octets.

=cut
*/

#define cop_hints_fetch_pvn(cop, key, keylen, hash, flags) \
    cophh_fetch_pvn(CopHINTHASH_get(cop), key, keylen, hash, flags)

#define cop_hints_fetch_pvs(cop, key, flags) \
    cophh_fetch_pvs(CopHINTHASH_get(cop), key, flags)

#define cop_hints_fetch_pv(cop, key, hash, flags) \
    cophh_fetch_pv(CopHINTHASH_get(cop), key, hash, flags)

#define cop_hints_fetch_sv(cop, key, hash, flags) \
    cophh_fetch_sv(CopHINTHASH_get(cop), key, hash, flags)

/*
=for apidoc   Am|bool|cop_hints_exists_pvn|const COP *cop|const char *key|STRLEN keylen|U32 hash|U32 flags
=for apidoc_item|bool|cop_hints_exists_pv |const COP *cop|const char *key              |U32 hash|U32 flags
=for apidoc_item|bool|cop_hints_exists_pvs|const COP *cop|           "key"                      |U32 flags
=for apidoc_item|bool|cop_hints_exists_sv |const COP *cop|        SV *key              |U32 hash|U32 flags

These look up the hint entry in the cop C<cop> with the key specified by
C<key> (and C<keylen> in the C<pvn> form), returning true if a value exists,
and false otherwise.

The forms differ in how the key is specified.  In all forms, the key is pointed
to by C<key>.
In the plain C<pv> form, the key is a C language NUL-terminated string.
In the C<pvs> form, the key is a C language string literal.
In the C<pvn> form, an additional parameter, C<keylen>, specifies the length of
the string, which hence, may contain embedded-NUL characters.
In the C<sv> form, C<*key> is an SV, and the key is the PV extracted from that.
using C<L</SvPV_const>>.

C<hash> is a precomputed hash of the key string, or zero if it has not been
precomputed.  This parameter is omitted from the C<pvs> form, as it is computed
automatically at compile time.

The only flag currently used from the C<flags> parameter is C<COPHH_KEY_UTF8>.
It is illegal to set this in the C<sv> form.  In the C<pv*> forms, it specifies
whether the key octets are interpreted as UTF-8 (if set) or as Latin-1 (if
cleared).  The C<sv> form uses the underlying SV to determine the UTF-8ness of
the octets.

=cut
*/

#define cop_hints_exists_pvn(cop, key, keylen, hash, flags) \
    cophh_exists_pvn(CopHINTHASH_get(cop), key, keylen, hash, flags)

#define cop_hints_exists_pvs(cop, key, flags) \
    cophh_exists_pvs(CopHINTHASH_get(cop), key, flags)

#define cop_hints_exists_pv(cop, key, hash, flags) \
    cophh_exists_pv(CopHINTHASH_get(cop), key, hash, flags)

#define cop_hints_exists_sv(cop, key, hash, flags) \
