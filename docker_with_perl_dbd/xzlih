    ...

    SP **mark = PL_stack_base + markoff;

=head2 Temporaries Stack

As noted above, xV references on the main value stack do not contribute to the
reference count of an xV, and so another mechanism is used to track when
temporary values which live on the stack must be released. This is the job of
the temporaries stack.

The temporaries stack stores pointers to xVs whose reference counts will be
decremented soon.

The base of this stack is pointed to by the interpreter variable
C<PL_tmps_stack>, of type C<SV **>.

=for apidoc_section $stack
=for apidoc Amnh||PL_tmps_stack

The head of the stack is indexed by C<PL_tmps_ix>, an integer which stores the
index in the array of the most recently-pushed item.

=for apidoc Amnh||PL_tmps_ix

There is no public API to directly push items to the temporaries stack. Instead,
the API function C<sv_2mortal()> is used to mortalize an xV, adding its
address to the temporaries stack.

Likewise, there is no public API to read values from the temporaries stack.
Instead, the macros C<SAVETMPS> and C<FREETMPS> are used. The C<SAVETMPS>
macro establishes the base levels of the temporaries stack, by capturing the
current value of C<PL_tmps_ix> into C<PL_tmps_floor> and saving the previous
value to the save stack. Thereafter, whenever C<FREETMPS> is invoked all of
the temporaries that have been pushed since that level are reclaimed.

=for apidoc_section $stack
=for apidoc Amnh||PL_tmps_floor

While it is common to see these two macros in pairs within an C<ENTER>/
C<LEAVE> pair, it is not necessary to match them. It is permitted to invoke
C<FREETMPS> multiple times since the most recent C<SAVETMPS>; for example in a
loop iterating over elements of a list. While you can invoke C<SAVETMPS>
multiple times within a scope pair, it is unlikely to be useful. Subsequent
invocations will move the temporaries floor further up, thus effectively
trapping the existing temporaries to only be released at the end of the scope.

=head2 Save Stack

The save stack is used by perl to implement the C<local> keyword and other
similar behaviours; any cleanup operations that need to be performed when
leaving the current scope. Items pushed to this stack generally capture the
current value of some internal variable or state, which will be restored when
the scope is unwound due to leaving, C<return>, C<die>, C<goto> or other
reasons.

Whereas other perl internal stacks store individual items all of the same type
(usually SV pointers or integers), the items pushed to the save stack are
formed of many different types, having multiple fields to them. For example,
the C<SAVEt_INT> type needs to store both the address of the C<int> variable
to restore, and the value to restore it to. This information could have been
stored using fields of a C<struct>, but would have to be large enough to store
three pointers in the largest case, which would waste a lot of space in most
of the smaller cases.

=for apidoc_section $stack
=for apidoc Amnh||SAVEt_INT

Instead, the stack stores information in a variable-length encoding of C<ANY>
structures. The final value pushed is stored in the C<UV> field which encodes
the kind of item held by the preceding items; the count and types of which
will depend on what kind of item is being stored. The kind field is pushed
last because that will be the first field to be popped when unwinding items
from the stack.

The base of this stack is pointed to by the interpreter variable
C<PL_savestack>, of type C<ANY *>.

=for apidoc_section $stack
=for apidoc Amnh||PL_savestack

The head of the stack is indexed by C<PL_savestack_ix>, an integer which
stores the index in the array at which the next item should be pushed. (Note
that this is different to most other stacks, which reference the most
recently-pushed item).

=for apidoc_section $stack
=for apidoc Amnh||PL_savestack_ix

Items are pushed to the save stack by using the various C<SAVE...()> macros.
Many of these macros take a variable and store both its address and current
value on the save stack, ensuring that value gets restored on scope exit.

    SAVEI8(i8)
    SAVEI16(i16)
    SAVEI32(i32)
    SAVEINT(i)
    ...

There are also a variety of other special-purpose macros which save particular
types or values of interest. C<SAVETMPS> has already been mentioned above.
Others include C<SAVEFREEPV> which arranges for a PV (i.e. a string buffer) to
be freed, or C<SAVEDESTRUCTOR> which arranges for a given function pointer to
be invoked on scope exit. A full list of such macros can be found in
F<scope.h>.

There is no public API for popping individual values or items from the save
stack. Instead, via the scope stack, the C<ENTER> and C<LEAVE> pair form a way
to start and stop nested scopes. Leaving a nested scope via C<LEAVE> will
restore all of the saved values that had been pushed since the most recent
C<ENTER>.

=head2 Scope Stack

As with the mark stack to the value stack, the scope stack forms a pair with
the save stack. The scope stack stores the height of the save stack at which
nested scopes begin, and allows the save stack to be unwound back to that
point when the scope is left.

When perl is built with debugging enabled, there is a second part to this
stack storing human-readable string names describing the type of stack
context. Each push operation saves the name as well as the height of the save
stack, and each pop operation checks the topmost name with what is expected,
causing an assertion failure if the name does not match.

The base of this stack is pointed to by the interpreter variable
C<PL_scopestack>, of type C<I32 *>. If enabled, the scope stack names are
stored in a separate array pointed to by C<PL_scopestack_name>, of type
C<const char **>.

=for apidoc_section $stack
=for apidoc Amnh||PL_scopestack
=for apidoc Amnh||PL_scopestack_name

The head of the stack is indexed by C<PL_scopestack_ix>, an integer which
stores the index of the array or arrays at which the next item should be
pushed. (Note that this is different to most other stacks, which reference the
most recently-pushed item).

=for apidoc_section $stack
=for apidoc Amnh||PL_scopestack_ix

Values are pushed to the scope stack using the C<ENTER> macro, which begins a
new nested scope. Any items pushed to the save stack are then restored at the
next nested invocation of the C<LEAVE> macro.

=head1 Dynamic Scope and the Context Stack

B<Note:> this section describes a non-public internal API that is subject
to change without notice.

=head2 Introduction to the context stack

In Perl, dynamic scoping refers to the runtime nesting of things like
subroutine calls, evals etc, as well as the entering and exiting of block
scopes. For example, the restoring of a C<local>ised variable is
determined by the dynamic scope.

Perl tracks the dynamic scope by a data structure called the context
stack, which is an array of C<PERL_CONTEXT> structures, and which is
itself a big union for all the types of context. Whenever a new scope is
entered (such as a block, a C<for> loop, or a subroutine call), a new
context entry is pushed onto the stack. Similarly when leaving a block or
returning from a subroutine call etc. a context is popped. Since the
context stack represents the current dynamic scope, it can be searched.
For example, C<next LABEL> searches back through the stack looking for a
loop context that matches the label; C<return> pops contexts until it
finds a sub or eval context or similar; C<caller> examines sub contexts on
the stack.

=for apidoc_section $concurrency
=for apidoc Cyh||PERL_CONTEXT

Each context entry is labelled with a context type, C<cx_type>. Typical
context types are C<CXt_SUB>, C<CXt_EVAL> etc., as well as C<CXt_BLOCK>
and C<CXt_NULL> which represent a basic scope (as pushed by C<pp_enter>)
and a sort block. The type determines which part of the context union are
valid.

=for apidoc  Cyh ||cx_type

=for apidoc  Cmnh||CXt_BLOCK
=for apidoc_item ||CXt_EVAL
=for apidoc_item ||CXt_FORMAT
=for apidoc_item ||CXt_GIVEN
=for apidoc_item ||CXt_LOOP_ARY
=for apidoc_item ||CXt_LOOP_LAZYIV
=for apidoc_item ||CXt_LOOP_LAZYSV
=for apidoc_item ||CXt_LOOP_LIST
=for apidoc_item ||CXt_LOOP_PLAIN
=for apidoc_item ||CXt_NULL
=for apidoc_item ||CXt_SUB
=for apidoc_item ||CXt_SUBST
=for apidoc_item ||CXt_WHEN

The main division in the context struct is between a substitution scope
(C<CXt_SUBST>) and block scopes, which are everything else. The former is
just used while executing C<s///e>, and won't be discussed further
here.

All the block scope types share a common base, which corresponds to
C<CXt_BLOCK>. This stores the old values of various scope-related
variables like C<PL_curpm>, as well as information about the current
scope, such as C<gimme>. On scope exit, the old variables are restored.

Particular block scope types store extra per-type information. For
example, C<CXt_SUB> stores the currently executing CV, while the various
for loop types might hold the original loop variable SV. On scope exit,
the per-type data is processed; for example the CV has its reference count
decremented, and the original loop variable is restored.

The macro C<cxstack> returns the base of the current context stack, while
C<cxstack_ix> is the index of the current frame within that stack.

=for apidoc_section $concurrency
=for apidoc Cmnh|PERL_CONTEXT *|cxstack
=for apidoc Cmnh|I32|cxstack_ix

In fact, the context stack is actually part of a stack-of-stacks system;
whenever something unusual is done such as calling a C<DESTROY> or tie
handler, a new stack is pushed, then popped at the end.

Note that the API described here changed considerably in perl 5.24; prior
to that, big macros like C<PUSHBLOCK> and C<POPSUB> were used; in 5.24
they were replaced by the inline static functions described below. In
addition, the ordering and detail of how these macros/function work
changed in many ways, often subtly. In particular they didn't handle
saving the savestack and temps stack positions, and required additional
C<ENTER>, C<SAVETMPS> and C<LEAVE> compared to the new functions. The
old-style macros will not be described further.


=head2 Pushing contexts

For pushing a new context, the two basic functions are
C<cx = cx_pushblock()>, which pushes a new basic context block and returns
its address, and a family of similar functions with names like
C<cx_pushsub(cx)> which populate the additional type-dependent fields in
the C<cx> struct. Note that C<CXt_NULL> and C<CXt_BLOCK> don't have their
own push functions, as they don't store any data beyond that pushed by
C<cx_pushblock>.

The fields of the context struct and the arguments to the C<cx_*>
functions are subject to change between perl releases, representing
whatever is convenient or efficient for that release.

A typical context stack pushing can be found in C<pp_entersub>; the
following shows a simplified and stripped-down example of a non-XS call,
along with comments showing roughly what each function does.

 dMARK;
 U8 gimme      = GIMME_V;
 bool hasargs  = cBOOL(PL_op->op_flags & OPf_STACKED);
 OP *retop     = PL_op->op_next;
 I32 old_ss_ix = PL_savestack_ix;
 CV *cv        = ....;

 /* ... make mortal copies of stack args which are PADTMPs here ... */

 /* ... do any additional savestack pushes here ... */

 /* Now push a new context entry of type 'CXt_SUB'; initially just
  * doing the actions common to all block types: */

 cx = cx_pushblock(CXt_SUB, gimme, MARK, old_ss_ix);

     /* this does (approximately):
         CXINC;              /* cxstack_ix++ (grow if necessary) */
         cx = CX_CUR();      /* and get the address of new frame */
         cx->cx_type        = CXt_SUB;
         cx->blk_gimme      = gimme;
         cx->blk_oldsp      = MARK - PL_stack_base;
         cx->blk_oldsaveix  = old_ss_ix;
         cx->blk_oldcop     = PL_curcop;
         cx->blk_oldmarksp  = PL_markstack_ptr - PL_markstack;
         cx->blk_oldscopesp = PL_scopestack_ix;
         cx->blk_oldpm      = PL_curpm;
         cx->blk_old_tmpsfloor = PL_tmps_floor;

         PL_tmps_floor        = PL_tmps_ix;
     */


 /* then update the new context frame with subroutine-specific info,
  * such as the CV about to be executed: */

 cx_pushsub(cx, cv, retop, hasargs);

     /* this does (approximately):
         cx->blk_sub.cv          = cv;
         cx->blk_sub.olddepth    = CvDEPTH(cv);
         cx->blk_sub.prevcomppad = PL_comppad;
         cx->cx_type            |= (hasargs) ? CXp_HASARGS : 0;
         cx->blk_sub.retop       = retop;
         SvREFCNT_inc_simple_void_NN(cv);
     */

=for apidoc_section $concurrency
=for apidoc Cmnh||CXINC

Note that C<cx_pushblock()> sets two new floors: for the args stack (to
C<MARK>) and the temps stack (to C<PL_tmps_ix>). While executing at this
scope level, every C<nextstate> (amongst others) will reset the args and
tmps stack levels to these floors. Note that since C<cx_pushblock> uses
the current value of C<PL_tmps_ix> rather than it being passed as an arg,
this dictates at what point C<cx_pushblock> should be called. In
particular, any new mortals which should be freed only on scope exit
(rather than at the next C<nextstate>) should be created first.

Most callers of C<cx_pushblock> simply set the new args stack floor to the
top of the previous stack frame, but for C<CXt_LOOP_LIST> it stores the
items being iterated over on the stack, and so sets C<blk_oldsp> to the
top of these items instead. Note that, contrary to its name, C<blk_oldsp>
doesn't always represent the value to restore C<PL_stack_sp> to on scope
exit.

Note the early capture of C<PL_savestack_ix> to C<old_ss_ix>, which is
later passed as an arg to C<cx_pushblock>. In the case of C<pp_entersub>,
this is because, although most values needing saving are stored in fields
of the context struct, an extra value needs saving only when the debugger
is running, and it doesn't make sense to bloat the struct for this rare
case. So instead it is saved on the savestack. Since this value gets
calculated and saved before the context is pushed, it is necessary to pass
the old value of C<PL_savestack_ix> to C<cx_pushblock>, to ensure that the
saved value gets freed during scope exit.  For most users of
C<cx_pushblock>, where nothing needs pushing on the save stack,
C<PL_savestack_ix> is just passed directly as an arg to C<cx_pushblock>.

Note that where possible, values should be saved in the context struct
rather than on the save stack; it's much faster that way.

Normally C<cx_pushblock> should be immediately followed by the appropriate
C<cx_pushfoo>, with nothing between them; this is because if code
in-between could die (e.g. a warning upgraded to fatal), then the context
stack unwinding code in C<dounwind> would see (in the example above) a
C<CXt_SUB> context frame, but without all the subroutine-specific fields
set, and crashes would soon ensue.

=for apidoc dounwind

Where the two must be separate, initially set the type to C<CXt_NULL> or
C<CXt_BLOCK>, and later change it to C<CXt_foo> when doing the
C<cx_pushfoo>. This is exactly what C<pp_enteriter> does, once it's
determined which type of loop it's pushing.

=head2 Popping contexts

Contexts are popped using C<cx_popsub()> etc. and C<cx_popblock()>. Note
however, that unlike C<cx_pushblock>, neither of these functions actually
decrement the current context stack index; this is done separately using
C<CX_POP()>.

=for apidoc_section $concurrency
=for apidoc Cmh|void|CX_POP|PERL_CONTEXT* cx

There are two main ways that contexts are popped. During normal execution
as scopes are exited, functions like C<pp_leave>, C<pp_leaveloop> and
C<pp_leavesub> process and pop just one context using C<cx_popfoo> and
C<cx_popblock>. On the other hand, things like C<pp_return> and C<next>
may have to pop back several scopes until a sub or loop context is found,
and exceptions (such as C<die>) need to pop back contexts until an eval
context is found. Both of these are accomplished by C<dounwind()>, which
is capable of processing and popping all contexts above the target one.

Here is a typical example of context popping, as found in C<pp_leavesub>
(simplified slightly):

 U8 gimme;
 PERL_CONTEXT *cx;
 SV **oldsp;
 OP *retop;

 cx = CX_CUR();

 gimme = cx->blk_gimme;
 oldsp = PL_stack_base + cx->blk_oldsp; /* last arg of previous frame */

 if (gimme == G_VOID)
     PL_stack_sp = oldsp;
 else
     leave_adjust_stacks(oldsp, oldsp, gimme, 0);

 CX_LEAVE_SCOPE(cx);
 cx_popsub(cx);
 cx_popblock(cx);
 retop = cx->blk_sub.retop;
 CX_POP(cx);

 return retop;

=for apidoc_section $concurrency
=for apidoc Cmh||CX_CUR

The steps above are in a very specific order, designed to be the reverse
order of when the context was pushed. The first thing to do is to copy
and/or protect any return arguments and free any temps in the current
scope. Scope exits like an rvalue sub normally return a mortal copy of
their return args (as opposed to lvalue subs). It is important to make
this copy before the save stack is popped or variables are restored, or
bad things like the following can happen:

    sub f { my $x =...; $x }  # $x freed before we get to copy it
    sub f { /(...)/;    $1 }  # PL_curpm restored before $1 copied

Although we wish to free any temps at the same time, we have to be careful
not to free any temps which are keeping return args alive; nor to free the
temps we have just created while mortal copying return args. Fortunately,
C<leave_adjust_stacks()> is capable of making mortal copies of return args,
shifting args down the stack, and only processing those entries on the
temps stack that are safe to do so.

In void context no args are returned, so it's more efficient to skip
calling C<leave_adjust_stacks()>. Also in void context, a C<nextstate> op
is likely to be imminently called which will do a C<FREETMPS>, so there's
no need to do that either.

The next step is to pop savestack entries: C<CX_LEAVE_SCOPE(cx)> is just
defined as C<< LEAVE_SCOPE(cx->blk_oldsaveix) >>. Note that during the
popping, it's possible for perl to call destructors, call C<STORE> to undo
localisations of tied vars, and so on. Any of these can die or call
C<exit()>. In this case, C<dounwind()> will be called, and the current
context stack frame will be re-processed. Thus it is vital that all steps
in popping a context are done in such a way to support reentrancy.  The
other alternative, of decrementing C<cxstack_ix> I<before> processing the
frame, would lead to leaks and the like if something died halfway through,
or overwriting of the current frame.

=for apidoc_section $concurrency
=for apidoc Cmh|void|CX_LEAVE_SCOPE|PERL_CONTEXT* cx

C<CX_LEAVE_SCOPE> itself is safely re-entrant: if only half the savestack
items have been popped before dying and getting trapped by eval, then the
C<CX_LEAVE_SCOPE>s in C<dounwind> or C<pp_leaveeval> will continue where
the first one left off.

The next step is the type-specific context processing; in this case
C<cx_popsub>. In part, this looks like:

    cv = cx->blk_sub.cv;
    CvDEPTH(cv) = cx->blk_sub.olddepth;
    cx->blk_sub.cv = NULL;
    SvREFCNT_dec(cv);

where its processing the just-executed CV. Note that before it decrements
the CV's reference count, it nulls the C<blk_sub.cv>. This means that if
it re-enters, the CV won't be freed twice. It also means that you can't
rely on such type-specific fields having useful values after the return
from C<cx_popfoo>.

Next, C<cx_popblock> restores all the various interpreter vars to their
previous values or previous high water marks; it expands to:

    PL_markstack_ptr = PL_markstack + cx->blk_oldmarksp;
    PL_scopestack_ix = cx->blk_oldscopesp;
    PL_curpm         = cx->blk_oldpm;
    PL_curcop        = cx->blk_oldcop;
    PL_tmps_floor    = cx->blk_old_tmpsfloor;

Note that it I<doesn't> restore C<PL_stack_sp>; as mentioned earlier,
which value to restore it to depends on the context type (specifically
C<for (list) {}>), and what args (if any) it returns; and that will
already have been sorted out earlier by C<leave_adjust_stacks()>.

Finally, the context stack pointer is actually decremented by C<CX_POP(cx)>.
After this point, it's possible that that the current context frame could
be overwritten by other contexts being pushed. Although things like ties
and C<DESTROY> are supposed to work within a new context stack, it's best
not to assume this. Indeed on debugging builds, C<CX_POP(cx)> deliberately
sets C<cx> to null to detect code that is still relying on the field
values in that context frame. Note in the C<pp_leavesub()> example above,
we grab C<blk_sub.retop> I<before> calling C<CX_POP>.

=head2 Redoing contexts

Finally, there is C<cx_topblock(cx)>, which acts like a super-C<nextstate>
as regards to resetting various vars to their base values. It is used in
places like C<pp_next>, C<pp_redo> and C<pp_goto> where rather than
exiting a scope, we want to re-initialise the scope. As well as resetting
C<PL_stack_sp> like C<nextstate>, it also resets C<PL_markstack_ptr>,
C<PL_scopestack_ix> and C<PL_curpm>. Note that it doesn't do a
C<FREETMPS>.


=head1 Reference-counted argument stack

=head2 Introduction

As of perl 5.40, there is a build option, C<PERL_RC_STACK>, not enabled by
default, which requires that items pushed onto, or popped off the argument
stack have their reference counts adjusted. It is intended that eventually
this will be the default way (and finally the only way) to configure perl.

The macros which manipulate the stack such as PUSHs() and POPs() don't
adjust the reference count of the SV. Most of the time this is fine, since
something else is keeping the SV alive while on the argument stack,  such
a pointer from the TEMPs stack, or from the pad (e.g. a lexical variable
or a C<PADTMP>). Occasionally this can go horribly wrong. For example,
this code:

    my @a = (1,2,3);
    sub f { @a = (); print "(@_)\n" };
    f(@a, 4);

may print undefined or random freed values, since some of the elements of
@_, which have been aliased to the elements of @a, have been freed.
C<PERL_RC_STACK> is intended to fix this by making each SV pointer on the
argument stack increment the reference count (RC) of the SV  by one.

In this new environment, unmodified existing PP and XS functions, which
have been written assuming a non reference-counted stack (non-RC for
short), are called via special wrapper functions which adjust the stack
before and after. At the moment there is no API to write an RC XS
function, so all XS code will continue to be called via a wrapper (which
makes them slightly slower), but means that in general, CPAN distributions
containing XS code code continue to work without modification.

However, PP functions, either in perl core, or those in XS functions used
to implement custom ops or to override the PP functions for built-in ops,
need dealing with specially. For the latter, they can just be wrapped;
this involves the least work, but has a performance impact. In the longer
term, and for core PP functions, they need unwrapping and rewriting using
a new API. With this, the old macros such as PUSHs() have been replaced
with a new set of (mostly inline) functions with a common prefix, such as
rpp_push_1(). "RPP" stands for "reference-counted push and pop functions".
The new functions modify the reference count on C<PERL_RC_STACK> builds,
while leaving them unadjusted otherwise. Thus in core they generally work
in both cases, while in XS code they are portable to older perl versions
via C<PPPort> (XXX assuming that they get been added to C<PPPort>).

The rest of this section is mainly concerned with how to convert existing
PP functions, and how to write new PP functions to use the new C<rpp_>
API.

A reference-counted perl can be built using the PERL_RC_STACK define.
For development and debugging purposes, it is best to enable leaking
scalar debugging too, as that displays extra information about scalars
that have leaked or been prematurely freed.

    Configure -DDEBUGGING \
      -Accflags='-DPERL_RC_STACK -DDEBUG_LEAKING_SCALARS'

=head2 Reference counted stack states

In the new regime, the current argument stack can be in one of three
states, which can be determined by the shown expression.

=over

=item * not reference-counted

    !AvREAL(PL_curstack)

In this case, perl will assume when emptying the stack (such as during a
croak()) that the items on it don't need freeing. This is the traditional
perl behaviour. On C<PERL_RC_STACK> builds, such stacks will be rarely
encountered.

=item * fully reference-counted

    AvREAL(PL_curstack) && !PL_curstackinfo->si_stack_nonrc_base

All the items on the stack are reference counted, and will be freed by
functions like rpp_popfree_1() or if perl croak()s. This is the normal
state of the stack in C<PERL_RC_STACK> builds.

=item * partially reference-counted (split)

    AvREAL(PL_curstack) && PL_curstackinfo->si_stack_nonrc_base > 0

In this case, items on the stack from the index C<si_stack_nonrc_base>
upwards are non-RC; those below are RC. This state occurs when a PP or XS
function has been wrapped. In this case, the wrapper function pushes a
non-RC copy of the arg pointers above the cut then calls the real
function. When that returns, the wrapper function bumps up the RC of any
returned args. See below for more details.

=back

Note that perl uses a stack-of-stacks, and the AvREAL() and
C<si_stack_nonrc_base> states are per stack. When perl starts up, the main
stack is RC, but by default, new stacks pushed in XS code via PUSHSTACKi()
are non-RC, so it is quite possible to get a mixture. The perl core itself
uses the new push_stackinfo() function which replaces PUSHSTACKi() and
allows you to specify that the new stack should be RC by default.
(XXX core mostly hasn't actually been updated yet to use push_stackinfo())

Most places in the core assume a particular RC environment. In particular,
it is assumed that within a runops loop, all the PP functions are
RC-aware, either because they have been (re)written to be aware, or
because they have been wrapped. Whenever a runops loop is entered via
CALLRUNOPS(), it will check the current state of the stack, and if it's
not fully RC, will temporarily update its contents to be fully RC before
entering the main runops loop. Then if necessary it will restore the stack
to its old state on return. This means that functions like call_sv(),
which can be called from any environment (e.g. RC core or wrapped and
temporarily non-RC XS code) will always do the Right Thing when invoking
the runops loop, no matter what the current stack state is.

Similarly, croaks and the like (which can occur anywhere) have to be able
to handle both stack types. So there are a few places in core - call_sv(),
eval_sv() etc, Perl_die_unwind() and S_my_exit_jump() - which have been
specially crafted to handle both cases; everything else can assume a fixed
environment.

=head2 Wrapping

Normally a core PP function is declared like this:

    PP(pp_foo)
    {
        ...
    }

This expands to something like:

    OP* Perl_pp_foo(pTHX)
    {
        ...
    }

When such a function needs to be wrapped, it is instead declared as:

    PP_wrapped(pp_foo, nargs, nlists)
    {
        ...
    }

which on non-RC builds, expands to the same as PP() (the extra args are
ignored). On RC builds it expands to something like

    OP* Perl_pp_foo(pTHX)
    {
        return Perl_pp_wrap(aTHX_ S_Perl_pp_foo_norc, nargs, nlists);
    }

    STATIC OP* S_Perl_pp_foo_norc(pTHX)
    {
        ...
    }

Here the externally visible PP function calls pp_wrap(), which adjusts
the stack contents, then calls the hidden real body of the PP function,
then on return, adjusts the stack back.

There is an API macro, XSPP_wrapped(), intended for use on PP functions
declared in XS code, It is identical to PP_wrapped(), except that it
doesn't prepend a C<Perl_> prefix to the function name.

The C<nargs> and C<nlists> parameters to the macro are numeric constants
or simple expressions which specify how many arguments the PP function
expects, or how many lists it expects. For example,

    PP_wrapped(pp_add, 2, 0);     /* consumes two args off the stack */

    PP_wrapped(pp_readline,       /* consumes one or two args */
            ((PL_op->op_flags & OPf_STACKED) ? 2 : 1), 0);

    PP_wrapped(pp_push, 0, 1);    /* consumes one list */

    PP_wrapped(pp_aassign, 0, 2); /* consumes two lists */

To understand what pp_wrap() does, consider calling Perl_pp_foo() which
expects three arguments. On entry the stack may look like:

    ... A+ B+ C+

(where the C<+> indicates that the pointers to A, B and C are each
reference counted). The wrapper function pp_wrap() marks a cut at the
current stack position using C<si_stack_nonrc_base>, then, based on the
value of C<nargs>, pushes a copy of those three pointers above the cut:

    ... A+ B+ C+ | A0 B0 C0

(where the C<0> indicates that the pointers aren't RC), then calls the
real PP function, S_Perl_pp_foo_norc(). That function processes A, B and C,
pops them off the stack, and pushes some result SVs. None of this
manipulation adjusts any RCs. On return to pp_wrap(), the stack may look
something like:

    ... A+ B+ C+ | X0 Y0

The wrapper function bumps up the RCs of X and Y, decrements A B C,
shifts the results down and sets C<si_stack_nonrc_base> to zero, leaving
the stack as:

    ... X+ Y+

In places like pp_entersub(), a similar wrapping (via the functions
rpp_invoke_xs() and then xs_wrap()) is done when calling XS subs.

When C<nlists> is positive, a similar action takes place, except that the
mark stack is examined (and adjusted) in order to determine the number of
args that need copying.

A complex calling environment might have multiple nested stacks with
different RC states. Perl starts off with an RC stack. Then for example,
pp_entersub() is called, which (via xs_wrap()) splits the stack and
executes the XS function in a non-RC environment. That function may call
PUSHSTACKi(), which creates a new non-RC stack, then calls call_sv(), which
does CALLRUNOPS(), which causes the new stack to temporarily become RC.
Then a tied method is called, which pushes a new RC stack, and so on. (XXX
currently tied methods actually push a non-RC stack. To be fixed soon).

=head2 (Re)writing a PP function using the rpp_() API

Wrapping a PP function has a performance overhead, and is there mainly as
a temporary crutch. Eventually, PP functions should be updated to use
rpp_() functions, and any new PP functions should be written this way from
scratch and thus not ever need wrapping.

A couple examples of core PP functions being converted can be seen in the
commits C<v5.39.1-304-g205fcd8410> and C<v5.39.1-303-g2fe263a83a>, which
demonstrate a unary and a binary op being converted (pp_not() and
pp_and()).

The traditional PP stack API consisted of a C<dSP> declaration, plus a
number of macros to push, pop and extend the stack. A I<very simplified>
pp_add() function might look something like:

    PP(pp_add)
    {
        dSP;
        dTARGET;
        IV right = SvIV(POPs);
        IV left  = SvIV(POPs);
        TARGi(left + right, 1);
        PUSHs(TARG);
        PUTBACK;
        return NORMAL;
    }

which expands to something like:

    {
        SV **sp = PL_stack_sp;
        SV *targ = PAD_SV(PL_op->op_targ);
        IV right = SvIV(*sp--);
        IV left  = SvIV(*sp--);
        sv_setiv(targ, left + right);
        *++sp = targ;
        PL_stack_sp = sp;
        return PL_op->op_next;
    }

The whole C<dSP> thing harks back to the days before decent optimising
compilers. It was always error-prone, e.g. if you forgot a C<PUTBACK> or
C<SPAGAIN>. The new API always just accesses C<PL_stack_sp> directly. In
fact the first step of upgrading a PP function is always to remove the
C<dSP> declaration. This has the happy side effect that any old-style
macros left in the pp function which implicitly use C<sp> will become
compile errors. The existence of a C<dSP> somewhere in core is a good sign
that that function still needs updating.

An obvious question is: why not just modify the definitions of the PUSHs()
etc macros to modify reference counts on RC builds? The basic problem is
that an SV may now be kept alive only by a single reference count from
the stack (formerly, they tended to be on the TEMPs stack too). So in code
like:

    SV *sv = POPs;
    IV i = SvIV(sv);

including an SvREFCNT_dec() in the C<POPs> macro definition would cause
C<sv> to be freed immediately, before its integer value can be read.

A potential issue with the new regime is that perl can croak at basically
any point in execution (e.g. the SvIV() above might call FETCH() on a tied
variable which then croaks). Thus at all times, the RC of each SV must be
properly accounted for. In the example above, a naive approach to avoiding
a premature free of C<sv> might be:

    SV *sv = *PL_stack_sp--;
    IV i = SvIV(sv);
    SvREFCNT_dec(sv); // got i, so ok to free sv now

but that means that C<sv> leaks if SvIV() triggers a croak.

To avoid that, the new regime has the general outline that arguments are
left on the stack I<until they are finished with>, then removed and their
reference count adjusted at that point. With the new API, the pp_add()
function looks something like:

    {
        dTARGET;
        IV right = SvIV(PL_stack_sp[ 0]); // NB: arguments left on stack
        IV left  = SvIV(PL_stack_sp[-1]);
        TARGi(left + right, 1);
        rpp_replace_2_1(targ);
        return NORMAL;
    }

The rpp_replace_2_1() function pops two values off the stack and pushes
one new value on, while adjusting reference counts as appropriate
(depending on whether built with C<PERL_RC_STACK> or not).

The rpp_() functions in the new API will be described in detail below, but
in summary:

 new function            approximate old equivant
 ------------            -----------------------

 rpp_extend(n)           EXTEND(SP, n)

 rpp_push_1(sv)          PUSHs(sv)
 rpp_push_2(sv1, sv2))   PUSHs(sv1); PUSHs(sv2)
 rpp_xpush_1(sv)         XPUSHs(sv)
 rpp_xpush_2(sv1, sv2))  EXTEND(SP,2); PUSHs(sv1); PUSHs(sv2);

 rpp_push_1_norc(sv)     mPUSHs(sv)     // on RC bulds, skips RC++;
                                        // on non-RC builds, mortalises
 rpp_popfree_1()         (void)POPs;
 rpp_popfree_2()         (void)POPs; (void)POPs;
 rpp_popfree_to(svp)     PL_stack_sp = svp;
 rpp_obliterate_stack_to(ix)           // see description below

 sv = rpp_pop_1_norc()   sv = SvREFCNT_inc(POPs)

 rpp_replace_1_1(sv)     (void)POPs; PUSHs(sv);
 rpp_replace_2_1(sv)     (void)POPs; (void)POPs; PUSHs(sv);
 rpp_replace_at(sp, sv)  *sp = sv;
 rpp_replace_at_norc(sp, sv) *sp = sv_2mortal(sv);

 rpp_context(mark, gimme,
             extra)      SP -= extra;
                         // impose void/scalar/list context on return args
                         SP = (gimme == G_VOID) ? mark : ....

 rpp_try_AMAGIC_1()      tryAMAGICun_MG()
 rpp_try_AMAGIC_2()      tryAMAGICbin_MG()

 rpp_is_lone(sv)         SvTEMP(sv) && SvREFCNT(sv) == 1
 rpp_stack_is_rc()       no equivalent

 rpp_invoke_xs(cv)       CvXSUB(cv)(aTHX_ cv);


 (no replacement)        dATARGET   // just write the macro body in full

There are also some C<_NN> variants which assume that any items being
removed from the stack are non-NULL, and so are slightly more efficient:

 rpp_popfree_1_NN()
 rpp_popfree_2_NN()
 rpp_popfree_to_NN(svp)

 rpp_replace_1_1_NN(sv)
 rpp_replace_2_1_NN(sv)
 rpp_replace_at_NN(sp, sv)
 rpp_replace_at_norc_NN(sp, sv)

There are also a few C<_IMM> variants, which expect the single pushed or
replacement value to be an immortal, such as C<&PL_sv_undef> - this skips
incrementing the ref count of the immortal SV. It doesn't matter if the
ref count of the SV prematurely reaches zero, as sv_free2() will just
resurrect it. Not every variant is provided; if a suitable one
doesn't exist, just using a standard C<_1> version is fine, albeit
slightly slower.

 rpp_push_IMM(&PL_sv_undef)
 rpp_xpush_IMM(&PL_sv_zero)
 rpp_replace_1_IMM_NN(&PL_sv_yes)
 rpp_replace_2_IMM_NN(&PL_sv_no)

Other new C and perl functions related to reference-counted stacks are:

 push_stackinfo(type,rc) PUSHSTACKi(type)
 pop_stackinfo()         POPSTACK()
 switch_argstack(to)     SWITCHSTACK(from,to)

 (Internals::stack_refcounted() & 1) # perl built with PERL_RC_STACK

Some of these new functions are trivial, but should be used in preference
to writing direct code because they will work on both RC and non-RC
builds, and may do extra checks and assertions on C<DEBUGGING> builds.

Note that rpp_popfree_1() etc aren't direct replacements for C<POPs>. The
rpp_() variants don't return a value and are intended to be called when
the SV is finished with. So

    SV *sv = POPs;
    ... do stuff with sv ...

becomes

    SV *sv = *PL_stack_sp;
    ... do stuff with sv ...
    rpp_popfree_1(); /* does SvREFCNT_dec(*PL_stack_sp--) */

The rpp_replace_M_N() functions are shortcuts for popping and freeing C<M>
items then pushing and bumping up the RCs of C<N> items. Note that they
handle edge cases such as an old and new SV being the same.

rpp_replace_at(sp, sv) is similar to rpp_replace_1_1(), except that
it replaces an SV at an address in the stack rather than at the top.

rpp_replace_at_norc(sp, sv) is similar to rpp_replace_at(), except that
it assumes that C<sv> already has a bumped reference count. So, a bit
like rpp_push_1_norc() (see below), it doesn't bother increasing C<sv>'s
reference count, or on non-RC builds it mortalises it instead.

rpp_popfree_to(svp) is designed to replace code like

    PL_stack_sp = PL_stack_base + cx->blk_oldsp;

which typically appears in list ops or scope exits when the arguments are
finished with. Left unaltered, all the SVs above C<oldsp> would leak. The
new approach is

    rpp_popfree_to(PL_stack_base + cx->blk_oldsp);

There is a rarely-used variant of this, rpp_obliterate_stack_to(), which
pops the stack back to the specified index regardless of the current RC
state of the stack. So for example if the stack is split, it will only
adjust the RCs of any SVs which are below the split point, while
rpp_popfree_to() would mindlessly free I<all> SVs (on RC builds anyway).
For normal PP functions you should only ever use rpp_popfree_to(), which
is faster.

There are no new equivalents for all the convenience macros like POPi()
and (shudder) dPOPPOPiirl(). These should be replaced with the rpp_()
functions above and with the conversions and variable declarations being
made explicit, e.g. dPOPPOPiirl() becomes:

    IV right = SvIV(PL_stack_sp[ 0]);
    IV left  = SvIV(PL_stack_sp[-1]);
    rpp_popfree_2();

A couple of the rpp_() functions with C<norc> in their names don't adjust
the reference count on RC builds (but, conversely, do on non-RC builds).

rpp_push_1_norc(sv) does a simple C<*++PL_stack_sp = sv> on RC builds. It
is typically used to "root" a newly-created SV, which already has an RC of
1. On non-RC builds it mortalises the SV instead. So for example, code
which used to look like

    mPUSHs(newSViv(i));

and which expanded to the equivalent of:

    PUSHs(sv_2mortal(newSViv(i));

should be rewritten as:

    rpp_push_1_norc(newSViv(i));

This is because newSViv() and similar create a new SV with a reference
count one too high (1 rather than 0). This count is then "donated" to the
stack by pushing it. Conversely on non-RC builds, the count is donated to
the TEMPs stack.

Similarly, on RC builds, C<sv = rpp_pop_1_norc()> does a simple
C<sv = *PL_stack_sv--> without adjusting the reference count, while on
non-RC builds it actually increments the SV's reference count. It is
intended for cases where you immediately want to increment the reference
count again after popping, e.g. where the SV is to be immediately embedded
somewhere. For example this code:

    SV *sv = PL_stack_sp[0];
    SvREFCNT_inc(sv);
    av_store(av, i, sv); /* in real life should check return value */
    rpp_popfree_1();

can be more efficiently written as

    av_store(av, i, rpp_pop_1_norc());

By using this function, the code works correctly on both RC and non-RC
builds.

A common operation on list ops is to impose void, scalar or list context
on the return arguments, possibly discarding all, or all except one, of
them. rpp_context(mark, gimme, extra) does this. As a first step (for
convenience and efficiency) it notionally pops C<extra> args off the
stack. Then for list context, leaves things as is. For void context, the
stack pointer is reset to mark, and everything above is popped. For
scalar, the top argument (or &PL_sv_undef) is moved from the top to
mark+1 and everything above is discarded.

The macros which appear at the start of many PP functions to check for
unary or binary op overloading (among other things) have been replaced
with rpp_try_AMAGIC_1() and _2() inline functions, which now rely on the
calling PP function to choose whether to return immediately rather than
the return being hidden away in the macro.

The rpp_invoke_xs() function calls the XS function associated with the CV,
but may do so via a wrapper function to adjust the stack as necessary.

In the spirit of hiding away less in macros, C<dATARGET> hasn't been given
a replacement; where its effect is needed, it is now written out in full;
see pp_add() for an example.

Finally, a couple of rpp() functions provide information rather than
manipulate the stack.

rpp_is_lone(sv) indicates whether C<sv>, assumed to be still on the stack,
it kept alive only by a single reference-counted pointer from the argument
and/or temps stacks, and thus is a candidate for some optimisations (like
skipping the copying of return arguments from a subroutine call).

rpp_stack_is_rc() indicates whether the current stack is currently
