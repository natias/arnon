   8, 6, 6, 6, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /*F0-FF*/

/* The second part is a transition table that maps a combination
 * of a state of the automaton and a character class to a new state, called a
 * node.  The nodes are:
 * N0     The initial state, and final accepting one.
 * N1     Any one continuation byte (80-BF) left.  This is transitioned to
 *        immediately when the start byte indicates a two-byte sequence
 * N2     Any two continuation bytes left.
 * N3     Start byte is E0.  Continuation bytes 80-9F are illegal (overlong);
 *        the other continuations transition to state N1
 * N4     Start byte is EF.  Continuation byte B7 transitions to N8; BF to N9;
 *        the other continuations transitions to N1
 * N5     Start byte is F0.  Continuation bytes 80-8F are illegal (overlong);
 *        [9AB]F transition to N10; the other continuations to N2.
 * N6     Start byte is F[123].  Continuation bytes [89AB]F transition
 *        to N10; the other continuations to N2.
 * N7     Start byte is F4.  Continuation bytes 90-BF are illegal
 *        (non-unicode); 8F transitions to N10; the other continuations to N2
 * N8     Initial sequence is EF B7.  Continuation bytes 90-AF are illegal
 *        (non-characters); the other continuations transition to N0.
 * N9     Initial sequence is EF BF.  Continuation bytes BE and BF are illegal
 *        (non-characters); the other continuations transition to N0.
 * N10    Initial sequence is one of: F0 [9-B]F; F[123] [8-B]F; or F4 8F.
 *        Continuation byte BF transitions to N11; the other continuations to
 *        N1
 * N11    Initial sequence is the two bytes given in N10 followed by BF.
 *        Continuation bytes BE and BF are illegal (non-characters); the other
 *        continuations transition to N0.
 * 1      Reject.  All transitions not mentioned above (except the single
 *        byte ones (as they are always legal) are to this state.
 */

#      undef N0
#      undef N1
#      undef N2
#      undef N3
#      undef N4
#      undef N5
#      undef N6
#      undef N7
#      undef N8
#      undef N9
#      undef NUM_CLASSES
#      define NUM_CLASSES 19
#      define N0 0
#      define N1  ((N0)  + NUM_CLASSES)
#      define N2  ((N1)  + NUM_CLASSES)
#      define N3  ((N2)  + NUM_CLASSES)
#      define N4  ((N3)  + NUM_CLASSES)
#      define N5  ((N4)  + NUM_CLASSES)
#      define N6  ((N5)  + NUM_CLASSES)
#      define N7  ((N6)  + NUM_CLASSES)
#      define N8  ((N7)  + NUM_CLASSES)
#      define N9  ((N8)  + NUM_CLASSES)
#      define N10 ((N9)  + NUM_CLASSES)
#      define N11 ((N10) + NUM_CLASSES)

/*Class: 0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18 */
/*N0*/   0,  1, N1, N2, N4, N7, N6, N3, N5,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
/*N1*/   1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
/*N2*/   1,  1,  1,  1,  1,  1,  1,  1,  1, N1, N1, N1, N1, N1, N1, N1, N1, N1, N1,

/*N3*/   1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, N1, N1, N1, N1, N1, N1,
/*N4*/   1,  1,  1,  1,  1,  1,  1,  1,  1, N1, N1, N1, N1, N1, N1, N1, N8, N1, N9,
/*N5*/   1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, N2,N10, N2,N10, N2, N2, N2,N10,
/*N6*/   1,  1,  1,  1,  1,  1,  1,  1,  1, N2,N10, N2,N10, N2,N10, N2, N2, N2,N10,
/*N7*/   1,  1,  1,  1,  1,  1,  1,  1,  1, N2,N10,  1,  1,  1,  1,  1,  1,  1,  1,
/*N8*/   1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  1,  1,  0,  0,  0,  0,
/*N9*/   1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,
/*N10*/  1,  1,  1,  1,  1,  1,  1,  1,  1, N1, N1, N1, N1, N1, N1, N1, N1, N1,N11,
/*N11*/  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,
};

/* And below is yet another version of the above tables that accepts only UTF-8
 * as defined by Corregidum #9.  Hence no surrogates nor non-Unicode, but
 * it allows non-characters.  This is isomorphic to the original table
 * in https://bjoern.hoehrmann.de/utf-8/decoder/dfa/
 *
 * The classes are
 *      00-7F           0
 *      80-8F           9
 *      90-9F          10
 *      A0-BF          11
 *      C0,C1           1
 *      C2-DF           2
 *      E0              7
 *      E1-EC           3
 *      ED              4
 *      EE-EF           3
 *      F0              8
 *      F1-F3           6  (6 bits can be stripped)
 *      F4              5  (only 5 can be stripped)
 *      F5-FF           1
 */

EXTCONST U8 PL_c9_utf8_dfa_tab[] = {
    /* The first part of the table maps bytes to character classes to reduce
     * the size of the transition table and create bitmasks. */
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /*00-0F*/
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /*10-1F*/
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /*20-2F*/
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /*30-3F*/
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /*40-4F*/
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /*50-5F*/
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /*60-6F*/
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /*70-7F*/
   9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, /*80-8F*/
  10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10, /*90-9F*/
  11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11, /*A0-AF*/
  11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11, /*B0-BF*/
   1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, /*C0-CF*/
   2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, /*D0-DF*/
   7, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 3, /*E0-EF*/
   8, 6, 6, 6, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /*F0-FF*/

/* The second part is a transition table that maps a combination
 * of a state of the automaton and a character class to a new state, called a
 * node.  The nodes are:
 * N0     The initial state, and final accepting one.
 * N1     Any one continuation byte (80-BF) left.  This is transitioned to
 *        immediately when the start byte indicates a two-byte sequence
 * N2     Any two continuation bytes left.
 * N3     Any three continuation bytes left.
 * N4     Start byte is E0.  Continuation bytes 80-9F are illegal (overlong);
 *        the other continuations transition to state N1
 * N5     Start byte is ED.  Continuation bytes A0-BF all lead to surrogates,
 *        so are illegal.  The other continuations transition to state N1.
 * N6     Start byte is F0.  Continuation bytes 80-8F are illegal (overlong);
 *        the other continuations transition to N2
 * N7     Start byte is F4.  Continuation bytes 90-BF are illegal
 *        (non-unicode); the other continuations transition to N2
 * 1      Reject.  All transitions not mentioned above (except the single
 *        byte ones (as they are always legal) are to this state.
 */

#      undef N0
#      undef N1
#      undef N2
#      undef N3
#      undef N4
#      undef N5
#      undef N6
#      undef N7
#      undef NUM_CLASSES
#      define NUM_CLASSES 12
#      define N0 0
#      define N1  ((N0)  + NUM_CLASSES)
#      define N2  ((N1)  + NUM_CLASSES)
#      define N3  ((N2)  + NUM_CLASSES)
#      define N4  ((N3)  + NUM_CLASSES)
#      define N5  ((N4)  + NUM_CLASSES)
#      define N6  ((N5)  + NUM_CLASSES)
#      define N7  ((N6)  + NUM_CLASSES)

/*Class: 0   1   2   3   4   5   6   7   8   9  10  11 */
/*N0*/   0,  1, N1, N2, N5, N7, N3, N4, N6,  1,  1,  1,
/*N1*/   1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,
/*N2*/   1,  1,  1,  1,  1,  1,  1,  1,  1, N1, N1, N1,
/*N3*/   1,  1,  1,  1,  1,  1,  1,  1,  1, N2, N2, N2,

/*N4*/   1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, N1,
/*N5*/   1,  1,  1,  1,  1,  1,  1,  1,  1, N1, N1,  1,
/*N6*/   1,  1,  1,  1,  1,  1,  1,  1,  1,  1, N2, N2,
/*N7*/   1,  1,  1,  1,  1,  1,  1,  1,  1, N2,  1,  1,
};

#    endif /* defined(PERL_CORE) */
#  else     /* End of is DOINIT */

EXTCONST U8 PL_extended_utf8_dfa_tab[];
EXTCONST U8 PL_strict_utf8_dfa_tab[];
EXTCONST U8 PL_c9_utf8_dfa_tab[];

#  endif
#endif    /* end of isn't EBCDIC */

#include "overload.h"

END_EXTERN_C

struct am_table {
  U8 flags;
  U8 fallback;
  U16 spare;
  U32 was_ok_sub;
  CV* table[NofAMmeth];
};
struct am_table_short {
  U8 flags;
  U8 fallback;
  U16 spare;
  U32 was_ok_sub;
};
typedef struct am_table AMT;
typedef struct am_table_short AMTS;

#define AMGfallNEVER	1
#define AMGfallNO	2
#define AMGfallYES	3

#define AMTf_AMAGIC		1
#define AMT_AMAGIC(amt)		((amt)->flags & AMTf_AMAGIC)
#define AMT_AMAGIC_on(amt)	((amt)->flags |= AMTf_AMAGIC)
#define AMT_AMAGIC_off(amt)	((amt)->flags &= ~AMTf_AMAGIC)

#define StashHANDLER(stash,meth)	gv_handler((stash),CAT2(meth,_amg))

/*
 * some compilers like to redefine cos et alia as faster
 * (and less accurate?) versions called F_cos et cetera (Quidquid
 * latine dictum sit, altum viditur.)  This trick collides with
 * the Perl overloading (amg).  The following #defines fool both.
 */

#ifdef _FASTMATH
#   ifdef atan2
#       define F_atan2_amg  atan2_amg
#   endif
#   ifdef cos
#       define F_cos_amg    cos_amg
#   endif
#   ifdef exp
#       define F_exp_amg    exp_amg
#   endif
#   ifdef log
#       define F_log_amg    log_amg
#   endif
#   ifdef pow
#       define F_pow_amg    pow_amg
#   endif
#   ifdef sin
#       define F_sin_amg    sin_amg
#   endif
#   ifdef sqrt
#       define F_sqrt_amg   sqrt_amg
#   endif
#endif /* _FASTMATH */

#define PERLDB_ALL		(PERLDBf_SUB	| PERLDBf_LINE	|	\
                                 PERLDBf_NOOPT	| PERLDBf_INTER	|	\
                                 PERLDBf_SUBLINE| PERLDBf_SINGLE|	\
                                 PERLDBf_NAMEEVAL| PERLDBf_NAMEANON |   \
                                 PERLDBf_SAVESRC)
                                        /* No _NONAME, _GOTO */
#define PERLDBf_SUB		0x01	/* Debug sub enter/exit */
#define PERLDBf_LINE		0x02	/* Keep line # */
#define PERLDBf_NOOPT		0x04	/* Switch off optimizations */
#define PERLDBf_INTER		0x08	/* Preserve more data for
                                           later inspections  */
#define PERLDBf_SUBLINE		0x10	/* Keep subr source lines */
#define PERLDBf_SINGLE		0x20	/* Start with single-step on */
#define PERLDBf_NONAME		0x40	/* For _SUB: no name of the subr */
#define PERLDBf_GOTO		0x80	/* Report goto: call DB::goto */
#define PERLDBf_NAMEEVAL	0x100	/* Informative names for evals */
#define PERLDBf_NAMEANON	0x200	/* Informative names for anon subs */
#define PERLDBf_SAVESRC  	0x400	/* Save source lines into @{"_<$filename"} */
#define PERLDBf_SAVESRC_NOSUBS	0x800	/* Including evals that generate no subroutines */
#define PERLDBf_SAVESRC_INVALID	0x1000	/* Save source that did not compile */

#define PERLDB_SUB		(PL_perldb & PERLDBf_SUB)
#define PERLDB_LINE		(PL_perldb & PERLDBf_LINE)
#define PERLDB_NOOPT		(PL_perldb & PERLDBf_NOOPT)
#define PERLDB_INTER		(PL_perldb & PERLDBf_INTER)
#define PERLDB_SUBLINE		(PL_perldb & PERLDBf_SUBLINE)
#define PERLDB_SINGLE		(PL_perldb & PERLDBf_SINGLE)
#define PERLDB_SUB_NN		(PL_perldb & PERLDBf_NONAME)
#define PERLDB_GOTO		(PL_perldb & PERLDBf_GOTO)
#define PERLDB_NAMEEVAL 	(PL_perldb & PERLDBf_NAMEEVAL)
#define PERLDB_NAMEANON 	(PL_perldb & PERLDBf_NAMEANON)
#define PERLDB_SAVESRC  	(PL_perldb & PERLDBf_SAVESRC)
#define PERLDB_SAVESRC_NOSUBS	(PL_perldb & PERLDBf_SAVESRC_NOSUBS)
#define PERLDB_SAVESRC_INVALID	(PL_perldb & PERLDBf_SAVESRC_INVALID)

#define PERLDB_LINE_OR_SAVESRC (PL_perldb & (PERLDBf_LINE | PERLDBf_SAVESRC))

#ifdef USE_ITHREADS
#  define KEYWORD_PLUGIN_MUTEX_INIT    MUTEX_INIT(&PL_keyword_plugin_mutex)
#  define KEYWORD_PLUGIN_MUTEX_LOCK    MUTEX_LOCK(&PL_keyword_plugin_mutex)
#  define KEYWORD_PLUGIN_MUTEX_UNLOCK  MUTEX_UNLOCK(&PL_keyword_plugin_mutex)
#  define KEYWORD_PLUGIN_MUTEX_TERM    MUTEX_DESTROY(&PL_keyword_plugin_mutex)
#  define USER_PROP_MUTEX_INIT    MUTEX_INIT(&PL_user_prop_mutex)
#  define USER_PROP_MUTEX_LOCK    MUTEX_LOCK(&PL_user_prop_mutex)
#  define USER_PROP_MUTEX_UNLOCK  MUTEX_UNLOCK(&PL_user_prop_mutex)
#  define USER_PROP_MUTEX_TERM    MUTEX_DESTROY(&PL_user_prop_mutex)
#else
#  define KEYWORD_PLUGIN_MUTEX_INIT    NOOP
#  define KEYWORD_PLUGIN_MUTEX_LOCK    NOOP
#  define KEYWORD_PLUGIN_MUTEX_UNLOCK  NOOP
#  define KEYWORD_PLUGIN_MUTEX_TERM    NOOP
#  define USER_PROP_MUTEX_INIT    NOOP
#  define USER_PROP_MUTEX_LOCK    NOOP
#  define USER_PROP_MUTEX_UNLOCK  NOOP
#  define USER_PROP_MUTEX_TERM    NOOP
#endif

#ifdef USE_LOCALE /* These locale things are all subject to change */

   /* Returns TRUE if the plain locale pragma without a parameter is in effect.
    * */
#  define IN_LOCALE_RUNTIME	(PL_curcop                                  \
                              && CopHINTS_get(PL_curcop) & HINT_LOCALE)

   /* Returns TRUE if either form of the locale pragma is in effect */
#  define IN_SOME_LOCALE_FORM_RUNTIME                                       \
        cBOOL(CopHINTS_get(PL_curcop) & (HINT_LOCALE|HINT_LOCALE_PARTIAL))

#  define IN_LOCALE_COMPILETIME	cBOOL(PL_hints & HINT_LOCALE)
#  define IN_SOME_LOCALE_FORM_COMPILETIME                                   \
                        cBOOL(PL_hints & (HINT_LOCALE|HINT_LOCALE_PARTIAL))

/*
=for apidoc_section $locale

=for apidoc Amn|bool|IN_LOCALE

Evaluates to TRUE if the plain locale pragma without a parameter (S<C<use
locale>>) is in effect.

=for apidoc Amn|bool|IN_LOCALE_COMPILETIME

Evaluates to TRUE if, when compiling a perl program (including an C<eval>) if
the plain locale pragma without a parameter (S<C<use locale>>) is in effect.

=for apidoc Amn|bool|IN_LOCALE_RUNTIME

Evaluates to TRUE if, when executing a perl program (including an C<eval>) if
the plain locale pragma without a parameter (S<C<use locale>>) is in effect.

=cut
*/

#  define IN_LOCALE                                                         \
        (IN_PERL_COMPILETIME ? IN_LOCALE_COMPILETIME : IN_LOCALE_RUNTIME)
#  define IN_SOME_LOCALE_FORM                                               \
                    (IN_PERL_COMPILETIME ? IN_SOME_LOCALE_FORM_COMPILETIME  \
                                         : IN_SOME_LOCALE_FORM_RUNTIME)

#  define IN_LC_ALL_COMPILETIME   IN_LOCALE_COMPILETIME
#  define IN_LC_ALL_RUNTIME       IN_LOCALE_RUNTIME

#  define IN_LC_PARTIAL_COMPILETIME   cBOOL(PL_hints & HINT_LOCALE_PARTIAL)
#  define IN_LC_PARTIAL_RUNTIME                                             \
              (PL_curcop && CopHINTS_get(PL_curcop) & HINT_LOCALE_PARTIAL)

#  define IN_LC_COMPILETIME(category)                                       \
       (       IN_LC_ALL_COMPILETIME                                        \
        || (   IN_LC_PARTIAL_COMPILETIME                                    \
            && Perl__is_in_locale_category(aTHX_ TRUE, (category))))
#  define IN_LC_RUNTIME(category)                                           \
      (IN_LC_ALL_RUNTIME || (IN_LC_PARTIAL_RUNTIME                          \
                 && Perl__is_in_locale_category(aTHX_ FALSE, (category))))
#  define IN_LC(category)  \
                    (IN_LC_COMPILETIME(category) || IN_LC_RUNTIME(category))

#  if defined (PERL_CORE) || defined (PERL_IN_XSUB_RE)

     /* This internal macro should be called from places that operate under
      * locale rules.  If there is a problem with the current locale that
      * hasn't been raised yet, it will output a warning this time.  Because
      * this will so rarely  be true, there is no point to optimize for time;
      * instead it makes sense to minimize space used and do all the work in
      * the rarely called function */
#    ifdef USE_LOCALE_CTYPE
#      define _CHECK_AND_WARN_PROBLEMATIC_LOCALE                              \
                STMT_START {                                                  \
                    if (UNLIKELY(PL_warn_locale)) {                           \
                        Perl__warn_problematic_locale();                      \
                    }                                                         \
                }  STMT_END
#    else
#      define _CHECK_AND_WARN_PROBLEMATIC_LOCALE
#    endif


     /* These two internal macros are called when a warning should be raised,
      * and will do so if enabled.  The first takes a single code point
      * argument; the 2nd, is a pointer to the first byte of the UTF-8 encoded
      * string, and an end position which it won't try to read past */
#    define _CHECK_AND_OUTPUT_WIDE_LOCALE_CP_MSG(cp)                        \
        STMT_START {                                                        \
            if (! PL_in_utf8_CTYPE_locale && ckWARN(WARN_LOCALE)) {         \
                Perl_warner(aTHX_ packWARN(WARN_LOCALE),                    \
                                       "Wide character (U+%" UVXf ") in %s",\
                                       (UV) cp, OP_DESC(PL_op));            \
            }                                                               \
        }  STMT_END

#    define _CHECK_AND_OUTPUT_WIDE_LOCALE_UTF8_MSG(s, send)                 \
        STMT_START { /* Check if to warn before doing the conversion work */\
            if (! PL_in_utf8_CTYPE_locale && ckWARN(WARN_LOCALE)) {         \
                UV cp = utf8_to_uvchr_buf((U8 *) (s), (U8 *) (send), NULL); \
                Perl_warner(aTHX_ packWARN(WARN_LOCALE),                    \
                    "Wide character (U+%" UVXf ") in %s",                   \
                    (cp == 0)                                               \
                     ? UNICODE_REPLACEMENT                                  \
                     : (UV) cp,                                             \
                    OP_DESC(PL_op));                                        \
            }                                                               \
        }  STMT_END

#  endif   /* PERL_CORE or PERL_IN_XSUB_RE */
#else   /* No locale usage */
#  define IN_LOCALE_RUNTIME                0
#  define IN_SOME_LOCALE_FORM_RUNTIME      0
#  define IN_LOCALE_COMPILETIME            0
#  define IN_SOME_LOCALE_FORM_COMPILETIME  0
#  define IN_LOCALE                        0
#  define IN_SOME_LOCALE_FORM              0
#  define IN_LC_ALL_COMPILETIME            0
#  define IN_LC_ALL_RUNTIME                0
#  define IN_LC_PARTIAL_COMPILETIME        0
#  define IN_LC_PARTIAL_RUNTIME            0
#  define IN_LC_COMPILETIME(category)      0
#  define IN_LC_RUNTIME(category)          0
#  define IN_LC(category)                  0
#  define _CHECK_AND_WARN_PROBLEMATIC_LOCALE
#  define _CHECK_AND_OUTPUT_WIDE_LOCALE_UTF8_MSG(s, send)
#  define _CHECK_AND_OUTPUT_WIDE_LOCALE_CP_MSG(c)
#endif


/* Locale/thread synchronization macros. */
#if ! (   defined(USE_LOCALE)                                               \
       &&    defined(USE_ITHREADS)                                          \
       && (  ! defined(USE_THREAD_SAFE_LOCALE)                              \
           || (   defined(HAS_LOCALECONV)                                   \
               && (  ! defined(HAS_LOCALECONV_L)                            \
                   ||  defined(TS_W32_BROKEN_LOCALECONV)))                  \
           || (   defined(HAS_NL_LANGINFO)                                  \
               && ! defined(HAS_THREAD_SAFE_NL_LANGINFO_L))                 \
           || (defined(HAS_MBLEN)  && ! defined(HAS_MBRLEN))                \
           || (defined(HAS_MBTOWC) && ! defined(HAS_MBRTOWC))               \
           || (defined(HAS_WCTOMB) && ! defined(HAS_WCRTOMB))))

/* The whole expression just above was complemented, so here we have no need
 * for thread synchronization, most likely it would be that this isn't a
 * threaded build. */
#  define LOCALE_INIT
#  define LOCALE_TERM
#  define LC_NUMERIC_LOCK(cond)     NOOP
#  define LC_NUMERIC_UNLOCK         NOOP
#  define LOCALECONV_LOCK           NOOP
#  define LOCALECONV_UNLOCK         NOOP
#  define LOCALE_READ_LOCK          NOOP
#  define LOCALE_READ_UNLOCK        NOOP
#  define MBLEN_LOCK                NOOP
#  define MBLEN_UNLOCK              NOOP
#  define MBTOWC_LOCK               NOOP
#  define MBTOWC_UNLOCK             NOOP
#  define NL_LANGINFO_LOCK          NOOP
#  define NL_LANGINFO_UNLOCK        NOOP
#  define SETLOCALE_LOCK            NOOP
#  define SETLOCALE_UNLOCK          NOOP
#  define WCTOMB_LOCK               NOOP
#  define WCTOMB_UNLOCK             NOOP
#else

   /* Here, we will need critical sections in locale handling, because one or
    * more of the above conditions are true.  This could be because the
    * platform doesn't have thread-safe locales, or that at least one of the
    * locale-dependent functions in the core isn't thread-safe.  The latter
    * case is generally because they return a pointer to a static buffer, which
    * may be per-process instead of per-thread.  There are supposedly
    * re-entrant, safe versions for all of them Perl currently uses (which the
    * #if above checks for), but most platforms don't have all the needed ones
    * available, and the Posix standard doesn't require nl_langinfo_l() to be
    * fully thread-safe, so a Configure probe was written.  localeconv_l() is
    * uncommon, and judging by bug reports on the web, some earlier library
    * localeconv_l versions were broken, so perhaps a probe is in order for
    * that, but it would be a pain to write.
    *
    * On non-thread-safe systems, some of the above functions are vulnerable to
    * races should another thread get control and change the locale in the
    * middle of their execution.
    *
    * We currently use a single mutex for all these cases.  This solves both
    * the problem of another thread changing the locale, and the buffer being
    * overwritten (the code copies the results to a safe place before releasing
    * the mutex).  Ideally, for locale thread-safe platforms where the only
    * issue is another thread clobbering the function's static buffer, there
    * would be a separate mutex for each such buffer.  Otherwise, things get
    * locked that don't need to.  But, it is not expected that any of these
    * will be called frequently, and the locked interval should be short, and
    * modern platforms will have reentrant versions (which don't lock) for
    * almost all of them, so khw thinks a single mutex should suffice. */
#  define LOCALE_LOCK_                                                      \
        STMT_START {                                                        \
            DEBUG_Lv(PerlIO_printf(Perl_debug_log,                          \
                    "%s: %d: locking locale\n", __FILE__, __LINE__));       \
            MUTEX_LOCK(&PL_locale_mutex);                                   \
        } STMT_END
#  define LOCALE_UNLOCK_                                                    \
        STMT_START {                                                        \
            DEBUG_Lv(PerlIO_printf(Perl_debug_log,                          \
                   "%s: %d: unlocking locale\n", __FILE__, __LINE__));      \
            MUTEX_UNLOCK(&PL_locale_mutex);                                 \
        } STMT_END

   /* We do define a different macro for each case; then if we want to have
    * separate mutexes for some of them, the only changes needed are here.
    * Define just the necessary macros.  The compiler should then croak if the
    * #ifdef's in the code are incorrect */
#  if defined(HAS_LOCALECONV) && (  ! defined(HAS_POSIX_2008_LOCALE)        \
                                 || ! defined(HAS_LOCALECONV_L)             \
                                 ||   defined(TS_W32_BROKEN_LOCALECONV))
#    define LOCALECONV_LOCK   LOCALE_LOCK_
#    define LOCALECONV_UNLOCK LOCALE_UNLOCK_
#  endif
#  if defined(HAS_NL_LANGINFO) && (   ! defined(HAS_THREAD_SAFE_NL_LANGINFO_L) \
                                   || ! defined(HAS_POSIX_2008_LOCALE))
#    define NL_LANGINFO_LOCK   LOCALE_LOCK_
#    define NL_LANGINFO_UNLOCK LOCALE_UNLOCK_
#  endif
#  if defined(HAS_MBLEN) && ! defined(HAS_MBRLEN)
#    define MBLEN_LOCK   LOCALE_LOCK_
#    define MBLEN_UNLOCK LOCALE_UNLOCK_
#  endif
#  if defined(HAS_MBTOWC) && ! defined(HAS_MBRTOWC)
#    define MBTOWC_LOCK   LOCALE_LOCK_
#    define MBTOWC_UNLOCK LOCALE_UNLOCK_
#  endif
#  if defined(HAS_WCTOMB) && ! defined(HAS_WCRTOMB)
#    define WCTOMB_LOCK   LOCALE_LOCK_
#    define WCTOMB_UNLOCK LOCALE_UNLOCK_
#  endif
#  if defined(USE_THREAD_SAFE_LOCALE)
     /* On locale thread-safe systems, we don't need these workarounds */
#    define LOCALE_TERM_LC_NUMERIC_   NOOP
#    define LOCALE_INIT_LC_NUMERIC_   NOOP
#    define LC_NUMERIC_LOCK(cond)   NOOP
#    define LC_NUMERIC_UNLOCK       NOOP
#    define LOCALE_INIT_LC_NUMERIC_ NOOP
#    define LOCALE_TERM_LC_NUMERIC_ NOOP

     /* There may be instance core where we this is invoked yet should do
      * nothing.  Rather than have #ifdef's around them, define it here */
#    define SETLOCALE_LOCK    NOOP
#    define SETLOCALE_UNLOCK  NOOP
#  else
#    define SETLOCALE_LOCK   LOCALE_LOCK_
#    define SETLOCALE_UNLOCK LOCALE_UNLOCK_

    /* On platforms without per-thread locales, when another thread can switch
     * our locale, we need another mutex to create critical sections where we
     * want the LC_NUMERIC locale to be locked into either the C (standard)
     * locale, or the underlying locale, so that other threads interrupting
     * this one don't change it to the wrong state before we've had a chance to
     * complete our operation.  It can stay locked over an entire printf
     * operation, for example.  And so is made distinct from the LOCALE_LOCK
     * mutex.
     *
     * This simulates kind of a general semaphore.  The current thread will
     * lock the mutex if the per-thread variable is zero, and then increments
     * that variable.  Each corresponding UNLOCK decrements the variable until
     * it is 0, at which point it actually unlocks the mutex.  Since the
     * variable is per-thread, there is no race with other threads.
     *
     * The single argument is a condition to test for, and if true, to panic,
     * as this would be an attempt to complement the LC_NUMERIC state, and
     * we're not supposed to because it's locked.
     *
     * Clang improperly gives warnings for this, if not silenced:
     * https://clang.llvm.org/docs/ThreadSafetyAnalysis.html#conditional-locks
     *
     * If LC_NUMERIC_LOCK is combined with one of the LOCKs above, calls to
     * that and its corresponding unlock should be contained entirely within
     * the locked portion of LC_NUMERIC.  Those mutexes should be used only in
     * very short sections of code, while LC_NUMERIC_LOCK may span more
     * operations.  By always following this convention, deadlock should be
     * impossible.  But if necessary, the two mutexes could be combined. */
#    define LC_NUMERIC_LOCK(cond_to_panic_if_already_locked)                \
        CLANG_DIAG_IGNORE(-Wthread-safety)	     	                    \
        STMT_START {                                                        \
            if (PL_lc_numeric_mutex_depth <= 0) {                           \
                MUTEX_LOCK(&PL_lc_numeric_mutex);                           \
                PL_lc_numeric_mutex_depth = 1;                              \
                DEBUG_Lv(PerlIO_printf(Perl_debug_log,                      \
                         "%s: %d: locking lc_numeric; depth=1\n",           \
                         __FILE__, __LINE__));                              \
            }                                                               \
            else {                                                          \
                PL_lc_numeric_mutex_depth++;                                \
                DEBUG_Lv(PerlIO_printf(Perl_debug_log,                      \
                        "%s: %d: avoided lc_numeric_lock; new depth=%d\n",  \
                        __FILE__, __LINE__, PL_lc_numeric_mutex_depth));    \
                if (cond_to_panic_if_already_locked) {                      \
                    Perl_croak_nocontext("panic: %s: %d: Trying to change"  \
                                         " LC_NUMERIC incompatibly",        \
                                         __FILE__, __LINE__);               \
                }                                                           \
            }                                                               \
        } STMT_END

#    define LC_NUMERIC_UNLOCK                                               \
        STMT_START {                                                        \
            if (PL_lc_numeric_mutex_depth <= 1) {                           \
                MUTEX_UNLOCK(&PL_lc_numeric_mutex);                         \
                PL_lc_numeric_mutex_depth = 0;                              \
                DEBUG_Lv(PerlIO_printf(Perl_debug_log,                      \
                         "%s: %d: unlocking lc_numeric; depth=0\n",         \
                         __FILE__, __LINE__));                              \
            }                                                               \
            else {                                                          \
                PL_lc_numeric_mutex_depth--;                                \
                DEBUG_Lv(PerlIO_printf(Perl_debug_log,                      \
                        "%s: %d: avoided lc_numeric_unlock; new depth=%d\n",\
                        __FILE__, __LINE__, PL_lc_numeric_mutex_depth));    \
            }                                                               \
        } STMT_END                                                          \
        CLANG_DIAG_RESTORE

#    define LOCALE_INIT_LC_NUMERIC_   MUTEX_INIT(&PL_lc_numeric_mutex)
#    define LOCALE_TERM_LC_NUMERIC_   MUTEX_DESTROY(&PL_lc_numeric_mutex)
#  endif

#  ifdef USE_POSIX_2008_LOCALE
     /* We have a locale object holding the 'C' locale for Posix 2008 */
#    define LOCALE_TERM_POSIX_2008_                                         \
                    STMT_START {                                            \
                        if (PL_C_locale_obj) {                              \
                            /* Make sure we aren't using the locale         \
                             * space we are about to free */                \
                            uselocale(LC_GLOBAL_LOCALE);                    \
                            freelocale(PL_C_locale_obj);                    \
                            PL_C_locale_obj = (locale_t) NULL;              \
                        }                                                   \
                    } STMT_END
#  else
#    define LOCALE_TERM_POSIX_2008_  NOOP
#  endif

#  define LOCALE_INIT           STMT_START {                                \
                                    MUTEX_INIT(&PL_locale_mutex);           \
                                    LOCALE_INIT_LC_NUMERIC_;                \
                                } STMT_END

#  define LOCALE_TERM           STMT_START {                                \
                                    MUTEX_DESTROY(&PL_locale_mutex);        \
                                    LOCALE_TERM_LC_NUMERIC_;                \
                                    LOCALE_TERM_POSIX_2008_;                \
                                } STMT_END
#endif

#ifdef USE_LOCALE_NUMERIC

/* These macros are for toggling between the underlying locale (UNDERLYING or
 * LOCAL) and the C locale (STANDARD).  (Actually we don't have to use the C
 * locale if the underlying locale is indistinguishable from it in the numeric
 * operations used by Perl, namely the decimal point, and even the thousands
 * separator.)

=for apidoc_section $locale

=for apidoc Amn|void|DECLARATION_FOR_LC_NUMERIC_MANIPULATION

This macro should be used as a statement.  It declares a private variable
(whose name begins with an underscore) that is needed by the other macros in
this section.  Failing to include this correctly should lead to a syntax error.
For compatibility with C89 C compilers it should be placed in a block before
any executable statements.

=for apidoc Am|void|STORE_LC_NUMERIC_FORCE_TO_UNDERLYING

This is used by XS code that is C<LC_NUMERIC> locale-aware to force the
locale for category C<LC_NUMERIC> to be what perl thinks is the current
underlying locale.  (The perl interpreter could be wrong about what the
underlying locale actually is if some C or XS code has called the C library
function L<setlocale(3)> behind its back; calling L</sync_locale> before calling
this macro will update perl's records.)

A call to L</DECLARATION_FOR_LC_NUMERIC_MANIPULATION> must have been made to
declare at compile time a private variable used by this macro.  This macro
should be called as a single statement, not an expression, but with an empty
argument list, like this:

 {
    DECLARATION_FOR_LC_NUMERIC_MANIPULATION;
     ...
    STORE_LC_NUMERIC_FORCE_TO_UNDERLYING();
     ...
    RESTORE_LC_NUMERIC();
     ...
 }

The private variable is used to save the current locale state, so
that the requisite matching call to L</RESTORE_LC_NUMERIC> can restore it.

On threaded perls not operating with thread-safe functionality, this macro uses
a mutex to force a critical section.  Therefore the matching RESTORE should be
close by, and guaranteed to be called.

=for apidoc Am|void|STORE_LC_NUMERIC_SET_TO_NEEDED

This is used to help wrap XS or C code that is C<LC_NUMERIC> locale-aware.
This locale category is generally kept set to a locale where the decimal radix
character is a dot, and the separator between groups of digits is empty.  This
is because most XS code that reads floating point numbers is expecting them to
have this syntax.

This macro makes sure the current C<LC_NUMERIC> state is set properly, to be
aware of locale if the call to the XS or C code from the Perl program is
from within the scope of a S<C<use locale>>; or to ignore locale if the call is
instead from outside such scope.

This macro is the start of wrapping the C or XS code; the wrap ending is done
by calling the L</RESTORE_LC_NUMERIC> macro after the operation.  Otherwise
the state can be changed that will adversely affect other XS code.

A call to L</DECLARATION_FOR_LC_NUMERIC_MANIPULATION> must have been made to
declare at compile time a private variable used by this macro.  This macro
should be called as a single statement, not an expression, but with an empty
argument list, like this:

 {
    DECLARATION_FOR_LC_NUMERIC_MANIPULATION;
     ...
    STORE_LC_NUMERIC_SET_TO_NEEDED();
     ...
    RESTORE_LC_NUMERIC();
     ...
 }

On threaded perls not operating with thread-safe functionality, this macro uses
a mutex to force a critical section.  Therefore the matching RESTORE should be
close by, and guaranteed to be called; see L</WITH_LC_NUMERIC_SET_TO_NEEDED>
for a more contained way to ensure that.

=for apidoc Am|void|STORE_LC_NUMERIC_SET_TO_NEEDED_IN|bool in_lc_numeric

Same as L</STORE_LC_NUMERIC_SET_TO_NEEDED> with in_lc_numeric provided
as the precalculated value of C<IN_LC(LC_NUMERIC)>. It is the caller's
responsibility to ensure that the status of C<PL_compiling> and C<PL_hints>
cannot have changed since the precalculation.

=for apidoc Am|void|RESTORE_LC_NUMERIC

This is used in conjunction with one of the macros
L</STORE_LC_NUMERIC_SET_TO_NEEDED>
and L</STORE_LC_NUMERIC_FORCE_TO_UNDERLYING> to properly restore the
C<LC_NUMERIC> state.

A call to L</DECLARATION_FOR_LC_NUMERIC_MANIPULATION> must have been made to
declare at compile time a private variable used by this macro and the two
C<STORE> ones.  This macro should be called as a single statement, not an
expression, but with an empty argument list, like this:

 {
    DECLARATION_FOR_LC_NUMERIC_MANIPULATION;
     ...
    RESTORE_LC_NUMERIC();
     ...
 }

=for apidoc Am|void|WITH_LC_NUMERIC_SET_TO_NEEDED|block

This macro invokes the supplied statement or block within the context
of a L</STORE_LC_NUMERIC_SET_TO_NEEDED> .. L</RESTORE_LC_NUMERIC> pair
if required, so eg:

  WITH_LC_NUMERIC_SET_TO_NEEDED(
    SNPRINTF_G(fv, ebuf, sizeof(ebuf), precis)
  );

is equivalent to:

  {
#ifdef USE_LOCALE_NUMERIC
    DECLARATION_FOR_LC_NUMERIC_MANIPULATION;
    STORE_LC_NUMERIC_SET_TO_NEEDED();
#endif
    SNPRINTF_G(fv, ebuf, sizeof(ebuf), precis);
#ifdef USE_LOCALE_NUMERIC
    RESTORE_LC_NUMERIC();
#endif
  }

=for apidoc Am|void|WITH_LC_NUMERIC_SET_TO_NEEDED_IN|bool in_lc_numeric|block

Same as L</WITH_LC_NUMERIC_SET_TO_NEEDED> with in_lc_numeric provided
as the precalculated value of C<IN_LC(LC_NUMERIC)>. It is the caller's
responsibility to ensure that the status of C<PL_compiling> and C<PL_hints>
cannot have changed since the precalculation.

=cut

*/

/* If the underlying numeric locale has a non-dot decimal point or has a
 * non-empty floating point thousands separator, the current locale is instead
 * generally kept in the C locale instead of that underlying locale.  The
 * current status is known by looking at two words.  One is non-zero if the
 * current numeric locale is the standard C/POSIX one or is indistinguishable
 * from C.  The other is non-zero if the current locale is the underlying
 * locale.  Both can be non-zero if, as often happens, the underlying locale is
 * C or indistinguishable from it.
 *
 * khw believes the reason for the variables instead of the bits in a single
 * word is to avoid having to have masking instructions. */

#  define _NOT_IN_NUMERIC_STANDARD (! PL_numeric_standard)

/* We can lock the category to stay in the C locale, making requests to the
 * contrary be noops, in the dynamic scope by setting PL_numeric_standard to 2.
 * */
#  define _NOT_IN_NUMERIC_UNDERLYING                                        \
                    (! PL_numeric_underlying && PL_numeric_standard < 2)

#  define DECLARATION_FOR_LC_NUMERIC_MANIPULATION                           \
    void (*_restore_LC_NUMERIC_function)(pTHX) = NULL

#  define STORE_LC_NUMERIC_SET_TO_NEEDED_IN(in)                             \
        STMT_START {                                                        \
            bool _in_lc_numeric = (in);                                     \
            LC_NUMERIC_LOCK(                                                \
                    (   (  _in_lc_numeric && _NOT_IN_NUMERIC_UNDERLYING)    \
                     || (! _in_lc_numeric && _NOT_IN_NUMERIC_STANDARD)));   \
            if (_in_lc_numeric) {                                           \
                if (_NOT_IN_NUMERIC_UNDERLYING) {                           \
                    Perl_set_numeric_underlying(aTHX);                      \
                    _restore_LC_NUMERIC_function                            \
                                            = &Perl_set_numeric_standard;   \
                }                                                           \
            }                                                               \
            else {                                                          \
                if (_NOT_IN_NUMERIC_STANDARD) {                             \
                    Perl_set_numeric_standard(aTHX);                        \
                    _restore_LC_NUMERIC_function                            \
                                            = &Perl_set_numeric_underlying; \
                }                                                           \
            }                                                               \
        } STMT_END

#  define STORE_LC_NUMERIC_SET_TO_NEEDED() \
        STORE_LC_NUMERIC_SET_TO_NEEDED_IN(IN_LC(LC_NUMERIC))

#  define RESTORE_LC_NUMERIC()                                              \
        STMT_START {                                                        \
            if (_restore_LC_NUMERIC_function) {                             \
                _restore_LC_NUMERIC_function(aTHX);                         \
            }                                                               \
            LC_NUMERIC_UNLOCK;                                              \
        } STMT_END

/* The next two macros set unconditionally.  These should be rarely used, and
 * only after being sure that this is what is needed */
#  define SET_NUMERIC_STANDARD()                                            \
        STMT_START {                                                        \
            DEBUG_Lv(PerlIO_printf(Perl_debug_log,                          \
                               "%s: %d: lc_numeric standard=%d\n",          \
                                __FILE__, __LINE__, PL_numeric_standard));  \
            Perl_set_numeric_standard(aTHX);                                \
            DEBUG_Lv(PerlIO_printf(Perl_debug_log,                          \
                                 "%s: %d: lc_numeric standard=%d\n",        \
                                 __FILE__, __LINE__, PL_numeric_standard)); \
        } STMT_END

#  define SET_NUMERIC_UNDERLYING()                                          \
        STMT_START {                                                        \
            if (_NOT_IN_NUMERIC_UNDERLYING) {                               \
                Perl_set_numeric_underlying(aTHX);                          \
            }                                                               \
        } STMT_END

/* The rest of these LC_NUMERIC macros toggle to one or the other state, with
 * the RESTORE_foo ones called to switch back, but only if need be */
#  define STORE_LC_NUMERIC_SET_STANDARD()                                   \
        STMT_START {                                                        \
            LC_NUMERIC_LOCK(_NOT_IN_NUMERIC_STANDARD);                      \
            if (_NOT_IN_NUMERIC_STANDARD) {                                 \
                _restore_LC_NUMERIC_function = &Perl_set_numeric_underlying;\
                Perl_set_numeric_standard(aTHX);                            \
            }                                                               \
        } STMT_END

/* Rarely, we want to change to the underlying locale even outside of 'use
 * locale'.  This is principally in the POSIX:: functions */
#  define STORE_LC_NUMERIC_FORCE_TO_UNDERLYING()                            \
        STMT_START {                                                        \
            LC_NUMERIC_LOCK(_NOT_IN_NUMERIC_UNDERLYING);                    \
            if (_NOT_IN_NUMERIC_UNDERLYING) {                               \
                Perl_set_numeric_underlying(aTHX);                          \
                _restore_LC_NUMERIC_function = &Perl_set_numeric_standard;  \
            }                                                               \
        } STMT_END

/* Lock/unlock to the C locale until unlock is called.  This needs to be
 * recursively callable.  [perl #128207] */
#  define LOCK_LC_NUMERIC_STANDARD()                                        \
        STMT_START {                                                        \
            DEBUG_Lv(PerlIO_printf(Perl_debug_log,                          \
                    "%s: %d: lc_numeric_standard now locked to depth %d\n", \
                    __FILE__, __LINE__, PL_numeric_standard));              \
            __ASSERT_(PL_numeric_standard)                                  \
            PL_numeric_standard++;                                          \
        } STMT_END

#  define UNLOCK_LC_NUMERIC_STANDARD()                                      \
        STMT_START {                                                        \
            if (PL_numeric_standard > 1) {                                  \
                PL_numeric_standard--;                                      \
            }                                                               \
            else {                                                          \
                assert(0);                                                  \
            }                                                               \
            DEBUG_Lv(PerlIO_printf(Perl_debug_log,                          \
                                   "%s: %d: ",  __FILE__, __LINE__);        \
                    if (PL_numeric_standard <= 1)                           \
                        PerlIO_printf(Perl_debug_log,                       \
                                      "lc_numeric_standard now unlocked\n");\
                    else PerlIO_printf(Perl_debug_log,                      \
                     "lc_numeric_standard lock decremented to depth %d\n",  \
                                                     PL_numeric_standard););\
        } STMT_END

#  define WITH_LC_NUMERIC_SET_TO_NEEDED_IN(in_lc_numeric, block)            \
        STMT_START {                                                        \
            DECLARATION_FOR_LC_NUMERIC_MANIPULATION;                        \
            STORE_LC_NUMERIC_SET_TO_NEEDED_IN(in_lc_numeric);               \
            block;                                                          \
            RESTORE_LC_NUMERIC();                                           \
        } STMT_END;

#  define WITH_LC_NUMERIC_SET_TO_NEEDED(block) \
        WITH_LC_NUMERIC_SET_TO_NEEDED_IN(IN_LC(LC_NUMERIC), block)

#else /* !USE_LOCALE_NUMERIC */

#  define SET_NUMERIC_STANDARD()
#  define SET_NUMERIC_UNDERLYING()
#  define IS_NUMERIC_RADIX(a, b)		(0)
#  define DECLARATION_FOR_LC_NUMERIC_MANIPULATION  dNOOP
#  define STORE_LC_NUMERIC_SET_STANDARD()
#  define STORE_LC_NUMERIC_FORCE_TO_UNDERLYING()
#  define STORE_LC_NUMERIC_SET_TO_NEEDED_IN(in_lc_numeric)
#  define STORE_LC_NUMERIC_SET_TO_NEEDED()
#  define RESTORE_LC_NUMERIC()
#  define LOCK_LC_NUMERIC_STANDARD()
#  define UNLOCK_LC_NUMERIC_STANDARD()
#  define WITH_LC_NUMERIC_SET_TO_NEEDED_IN(in_lc_numeric, block) \
    STMT_START { block; } STMT_END
#  define WITH_LC_NUMERIC_SET_TO_NEEDED(block) \
    STMT_START { block; } STMT_END

#endif /* !USE_LOCALE_NUMERIC */

#ifdef USE_ITHREADS
#  define ENV_LOCK            PERL_WRITE_LOCK(&PL_env_mutex)
#  define ENV_UNLOCK          PERL_WRITE_UNLOCK(&PL_env_mutex)
#  define ENV_READ_LOCK       PERL_READ_LOCK(&PL_env_mutex)
#  define ENV_READ_UNLOCK     PERL_READ_UNLOCK(&PL_env_mutex)
#  define ENV_INIT            PERL_RW_MUTEX_INIT(&PL_env_mutex)
#  define ENV_TERM            PERL_RW_MUTEX_DESTROY(&PL_env_mutex)

   /* On platforms where the static buffer contained in getenv() is per-thread
    * rather than process-wide, another thread executing a getenv() at the same
    * time won't destroy ours before we have copied the result safely away and
    * unlocked the mutex.  On such platforms (which is most), we can have many
    * readers of the environment at the same time. */
#  ifdef GETENV_PRESERVES_OTHER_THREAD
#    define GETENV_LOCK    ENV_READ_LOCK
#    define GETENV_UNLOCK  ENV_READ_UNLOCK
#  else
     /* If, on the other hand, another thread could zap our getenv() return, we
      * need to keep them from executing until we are done */
#    define GETENV_LOCK    ENV_LOCK
#    define GETENV_UNLOCK  ENV_UNLOCK
#  endif
#else
#  define ENV_LOCK        NOOP
#  define ENV_UNLOCK      NOOP
#  define ENV_READ_LOCK   NOOP
#  define ENV_READ_UNLOCK NOOP
#  define ENV_INIT        NOOP
#  define ENV_TERM        NOOP
#  define GETENV_LOCK     NOOP
#  define GETENV_UNLOCK   NOOP
#endif

#ifndef PERL_NO_INLINE_FUNCTIONS
/* Static inline funcs that depend on includes and declarations above.
   Some of these reference functions in the perl object files, and some
   compilers aren't smart enough to eliminate unused static inline
   functions, so including this file in source code can cause link errors
   even if the source code uses none of the functions. Hence including these
   can be suppressed by setting PERL_NO_INLINE_FUNCTIONS. Doing this will
   (obviously) result in unworkable XS code, but allows simple probing code
   to continue to work, because it permits tests to include the perl headers
   for definitions without creating a link dependency on the perl library
   (which may not exist yet).
*/

START_EXTERN_C

#  include "inline.h"
#  include "sv_inline.h"

END_EXTERN_C

#endif
