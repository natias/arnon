          my ($cp, $n) = ($codepoints->[$i], $names->[$i]);
          # If $n is a ref, the same codepoint has multiple names
          foreach my $name (ref $n ? @$n : $n) {
              $name{$cp} //= $name;
              $cp{$name} //= $cp;
          }
      }
  }
  # Named sequences
  {   my %ns = namedseq();
      foreach my $name (sort { $ns{$a} cmp $ns{$b} } keys %ns) {
          $cp{$name} //= [ map { ord } split "" => $ns{$name} ];
      }
  }

=cut

# User-defined properties could be handled with some changes to SWASHNEW;
# if done, consideration should be given to the fact that the user subroutine
# could return different results with each call, which could lead to some
# security issues.

# One could store things in memory so they don't have to be recalculated, but
# it is unlikely this will be called often, and some properties would take up
# significant memory.

# These are created by mktables for this routine and stored in unicore/UCD.pl
# where their structures are described.
our @algorithmic_named_code_points;
our $HANGUL_BEGIN;
our $HANGUL_COUNT;

sub prop_invmap ($;$) {

    croak __PACKAGE__, "::prop_invmap: must be called in list context" unless wantarray;

    my $prop = $_[0];
    return unless defined $prop;

    # Undocumented way to get at Perl internal properties; it may be changed
    # or removed without notice at any time.  It currently also changes the
    # output to use the format specified in the file rather than the one we
    # normally compute and return
    my $internal_ok = defined $_[1] && $_[1] eq '_perl_core_internal_ok';

    # Fail internal properties
    return if $prop =~ /^_/ && ! $internal_ok;

    # The values returned by this function.
    my (@invlist, @invmap, $format, $missing);

    # The swash has two components we look at, the base list, and a hash,
    # named 'SPECIALS', containing any additional members whose mappings don't
    # fit into the base list scheme of things.  These generally 'override'
    # any value in the base list for the same code point.
    my $overrides;

    require "unicore/UCD.pl";

RETRY:

    # If there are multiple entries for a single code point
    my $has_multiples = 0;

    # Try to get the map swash for the property.  They have 'To' prepended to
    # the property name, and 32 means we will accept 32 bit return values.
    # The 0 means we aren't calling this from tr///.
    my $swash = SWASHNEW(__PACKAGE__, "To$prop", undef, 32, 0);

    # If didn't find it, could be because needs a proxy.  And if was the
    # 'Block' or 'Name' property, use a proxy even if did find it.  Finding it
    # in these cases would be the result of the installation changing mktables
    # to output the Block or Name tables.  The Block table gives block names
    # in the new-style, and this routine is supposed to return old-style block
    # names.  The Name table is valid, but we need to execute the special code
    # below to add in the algorithmic-defined name entries.
    # And NFKCCF needs conversion, so handle that here too.
    if (ref $swash eq ""
        || $swash->{'TYPE'} =~ / ^ To (?: Blk | Na | NFKCCF ) $ /x)
    {

        # Get the short name of the input property, in standard form
        my ($second_try) = prop_aliases($prop);
        return unless $second_try;
        $second_try = loose_name(lc $second_try);

        if ($second_try eq "in") {

            # This property is identical to age for inversion map purposes
            $prop = "age";
            goto RETRY;
        }
        elsif ($second_try =~ / ^ s ( cf | fc | [ltu] c ) $ /x) {

            # These properties use just the LIST part of the full mapping,
            # which includes the simple maps that are otherwise overridden by
            # the SPECIALS.  So all we need do is to not look at the SPECIALS;
            # set $overrides to indicate that
            $overrides = -1;

            # The full name is the simple name stripped of its initial 's'
            $prop = $1;

            # .. except for this case
            $prop = 'cf' if $prop eq 'fc';

            goto RETRY;
        }
        elsif ($second_try eq "blk") {

            # We use the old block names.  Just create a fake swash from its
            # data.
            _charblocks();
            my %blocks;
            $blocks{'LIST'} = "";
            $blocks{'TYPE'} = "ToBlk";
            $SwashInfo{ToBlk}{'missing'} = "No_Block";
            $SwashInfo{ToBlk}{'format'} = "s";

            foreach my $block (@BLOCKS) {
                $blocks{'LIST'} .= sprintf "%x\t%x\t%s\n",
                                           $block->[0],
                                           $block->[1],
                                           $block->[2];
            }
            $swash = \%blocks;
        }
        elsif ($second_try eq "na") {

            # Use the combo file that has all the Name-type properties in it,
            # extracting just the ones that are for the actual 'Name'
            # property.  And create a fake swash from it.
            my %names;
            $names{'LIST'} = "";
            my $original = do "unicore/Name.pl";

            # Change the double \n format of the file back to single lines
            # with a tab
            $original =~ s/\n\n/\e/g;   # Use a control that shouldn't occur
                                        #in the file
            $original =~ s/\n/\t/g;
            $original =~ s/\e/\n/g;

            my $algorithm_names = \@algorithmic_named_code_points;

            # We need to remove the names from it that are aliases.  For that
            # we need to also read in that table.  Create a hash with the keys
            # being the code points, and the values being a list of the
            # aliases for the code point key.
            my ($aliases_code_points, $aliases_maps, undef, undef)
                  = &prop_invmap("_Perl_Name_Alias", '_perl_core_internal_ok');
            my %aliases;
            for (my $i = 0; $i < @$aliases_code_points; $i++) {
                my $code_point = $aliases_code_points->[$i];
                $aliases{$code_point} = $aliases_maps->[$i];

                # If not already a list, make it into one, so that later we
                # can treat things uniformly
                if (! ref $aliases{$code_point}) {
                    $aliases{$code_point} = [ $aliases{$code_point} ];
                }

                # Remove the alias type from the entry, retaining just the
                # name.
                map { s/:.*// } @{$aliases{$code_point}};
            }

            my $i = 0;
            foreach my $line (split "\n", $original) {
                my ($hex_code_point, $name) = split "\t", $line;

                # Weeds out any comments, blank lines, and named sequences
                next if $hex_code_point =~ /[^[:xdigit:]]/a;

                my $code_point = hex $hex_code_point;

                # The name of all controls is the default: the empty string.
                # The set of controls is immutable
                next if chr($code_point) =~ /[[:cntrl:]]/u;

                # If this is a name_alias, it isn't a name
                next if grep { $_ eq $name } @{$aliases{$code_point}};

                # If we are beyond where one of the special lines needs to
                # be inserted ...
                while ($i < @$algorithm_names
                    && $code_point > $algorithm_names->[$i]->{'low'})
                {

                    # ... then insert it, ahead of what we were about to
                    # output
                    $names{'LIST'} .= sprintf "%x\t%x\t%s\n",
                                            $algorithm_names->[$i]->{'low'},
                                            $algorithm_names->[$i]->{'high'},
                                            $algorithm_names->[$i]->{'name'};

                    # Done with this range.
                    $i++;

                    # We loop until all special lines that precede the next
                    # regular one are output.
                }

                # Here, is a normal name.
                $names{'LIST'} .= sprintf "%x\t\t%s\n", $code_point, $name;
            } # End of loop through all the names

            $names{'TYPE'} = "ToNa";
            $SwashInfo{ToNa}{'missing'} = "";
            $SwashInfo{ToNa}{'format'} = "n";
            $swash = \%names;
        }
        elsif ($second_try =~ / ^ ( d [mt] ) $ /x) {

            # The file is a combination of dt and dm properties.  Create a
            # fake swash from the portion that we want.
            my $original = do "unicore/Decomposition.pl";
            my %decomps;

            if ($second_try eq 'dt') {
                $decomps{'TYPE'} = "ToDt";
                $SwashInfo{'ToDt'}{'missing'} = "None";
                $SwashInfo{'ToDt'}{'format'} = "s";
            }   # 'dm' is handled below, with 'nfkccf'

            $decomps{'LIST'} = "";

            # This property has one special range not in the file: for the
            # hangul syllables.  But not in Unicode version 1.
            UnicodeVersion() unless defined $v_unicode_version;
            my $done_hangul = ($v_unicode_version lt v2.0.0)
                              ? 1
                              : 0;    # Have we done the hangul range ?
            foreach my $line (split "\n", $original) {
                my ($hex_lower, $hex_upper, $type_and_map) = split "\t", $line;
                my $code_point = hex $hex_lower;
                my $value;
                my $redo = 0;

                # The type, enclosed in <...>, precedes the mapping separated
                # by blanks
                if ($type_and_map =~ / ^ < ( .* ) > \s+ (.*) $ /x) {
                    $value = ($second_try eq 'dt') ? $1 : $2
                }
                else {  # If there is no type specified, it's canonical
                    $value = ($second_try eq 'dt')
                             ? "Canonical" :
                             $type_and_map;
                }

                # Insert the hangul range at the appropriate spot.
                if (! $done_hangul && $code_point > $HANGUL_BEGIN) {
                    $done_hangul = 1;
                    $decomps{'LIST'} .=
                                sprintf "%x\t%x\t%s\n",
                                        $HANGUL_BEGIN,
                                        $HANGUL_BEGIN + $HANGUL_COUNT - 1,
                                        ($second_try eq 'dt')
                                        ? "Canonical"
                                        : "<hangul syllable>";
                }

                if ($value =~ / / && $hex_upper ne "" && $hex_upper ne $hex_lower) {
                    $line = sprintf("%04X\t%s\t%s", hex($hex_lower) + 1, $hex_upper, $value);
                    $hex_upper = "";
                    $redo = 1;
                }

                # And append this to our constructed LIST.
                $decomps{'LIST'} .= "$hex_lower\t$hex_upper\t$value\n";

                redo if $redo;
            }
            $swash = \%decomps;
        }
        elsif ($second_try ne 'nfkccf') { # Don't know this property. Fail.
            return;
        }

        if ($second_try eq 'nfkccf' || $second_try eq 'dm') {

            # The 'nfkccf' property is stored in the old format for backwards
            # compatibility for any applications that has read its file
            # directly before prop_invmap() existed.
            # And the code above has extracted the 'dm' property from its file
            # yielding the same format.  So here we convert them to adjusted
            # format for compatibility with the other properties similar to
            # them.
            my %revised_swash;

            # We construct a new converted list.
            my $list = "";

            my @ranges = split "\n", $swash->{'LIST'};
            for (my $i = 0; $i < @ranges; $i++) {
                my ($hex_begin, $hex_end, $map) = split "\t", $ranges[$i];

                # The dm property has maps that are space separated sequences
                # of code points, as well as the special entry "<hangul
                # syllable>, which also contains a blank.
                my @map = split " ", $map;
                if (@map > 1) {

                    # If it's just the special entry, append as-is.
                    if ($map eq '<hangul syllable>') {
                        $list .= "$ranges[$i]\n";
                    }
                    else {

                        # These should all be single-element ranges.
                        croak __PACKAGE__, "::prop_invmap: Not expecting a mapping with multiple code points in a multi-element range, $ranges[$i]" if $hex_end ne "" && $hex_end ne $hex_begin;

                        # Convert them to decimal, as that's what's expected.
                        $list .= "$hex_begin\t\t"
                            . join(" ", map { hex } @map)
                            . "\n";
                    }
                    next;
                }

                # Here, the mapping doesn't have a blank, is for a single code
                # point.
                my $begin = hex $hex_begin;
                my $end = (defined $hex_end && $hex_end ne "")
                        ? hex $hex_end
                        : $begin;

                # Again, the output is to be in decimal.
                my $decimal_map = hex $map;

                # We know that multi-element ranges with the same mapping
                # should not be adjusted, as after the adjustment
                # multi-element ranges are for consecutive increasing code
                # points.  Further, the final element in the list won't be
                # adjusted, as there is nothing after it to include in the
                # adjustment
                if ($begin != $end || $i == @ranges -1) {

                    # So just convert these to single-element ranges
                    foreach my $code_point ($begin .. $end) {
                        $list .= sprintf("%04X\t\t%d\n",
                                        $code_point, $decimal_map);
                    }
                }
                else {

                    # Here, we have a candidate for adjusting.  What we do is
                    # look through the subsequent adjacent elements in the
                    # input.  If the map to the next one differs by 1 from the
                    # one before, then we combine into a larger range with the
                    # initial map.  Loop doing this until we find one that
                    # can't be combined.

                    my $offset = 0;     # How far away are we from the initial
                                        # map
                    my $squished = 0;   # ? Did we squish at least two
                                        # elements together into one range
                    for ( ; $i < @ranges; $i++) {
                        my ($next_hex_begin, $next_hex_end, $next_map)
                                                = split "\t", $ranges[$i+1];

                        # In the case of 'dm', the map may be a sequence of
                        # multiple code points, which are never combined with
                        # another range
                        last if $next_map =~ / /;

                        $offset++;
                        my $next_decimal_map = hex $next_map;

                        # If the next map is not next in sequence, it
                        # shouldn't be combined.
                        last if $next_decimal_map != $decimal_map + $offset;

                        my $next_begin = hex $next_hex_begin;

                        # Likewise, if the next element isn't adjacent to the
                        # previous one, it shouldn't be combined.
                        last if $next_begin != $begin + $offset;

                        my $next_end = (defined $next_hex_end
                                        && $next_hex_end ne "")
                                            ? hex $next_hex_end
                                            : $next_begin;

                        # And finally, if the next element is a multi-element
                        # range, it shouldn't be combined.
                        last if $next_end != $next_begin;

                        # Here, we will combine.  Loop to see if we should
                        # combine the next element too.
                        $squished = 1;
                    }

                    if ($squished) {

                        # Here, 'i' is the element number of the last element to
                        # be combined, and the range is single-element, or we
                        # wouldn't be combining.  Get it's code point.
                        my ($hex_end, undef, undef) = split "\t", $ranges[$i];
                        $list .= "$hex_begin\t$hex_end\t$decimal_map\n";
                    } else {

                        # Here, no combining done.  Just append the initial
                        # (and current) values.
                        $list .= "$hex_begin\t\t$decimal_map\n";
                    }
                }
            } # End of loop constructing the converted list

            # Finish up the data structure for our converted swash
            my $type = ($second_try eq 'nfkccf') ? 'ToNFKCCF' : 'ToDm';
            $revised_swash{'LIST'} = $list;
            $revised_swash{'TYPE'} = $type;
            $revised_swash{'SPECIALS'} = $swash->{'SPECIALS'};
            $swash = \%revised_swash;

            $SwashInfo{$type}{'missing'} = 0;
            $SwashInfo{$type}{'format'} = 'a';
        }
    }

    if ($swash->{'EXTRAS'}) {
        carp __PACKAGE__, "::prop_invmap: swash returned for $prop unexpectedly has EXTRAS magic";
        return;
    }

    # Here, have a valid swash return.  Examine it.
    my $returned_prop = $swash->{'TYPE'};

    # All properties but binary ones should have 'missing' and 'format'
    # entries
    $missing = $SwashInfo{$returned_prop}{'missing'};
    $missing = 'N' unless defined $missing;

    $format = $SwashInfo{$returned_prop}{'format'};
    $format = 'b' unless defined $format;

    my $requires_adjustment = $format =~ /^a/;

    if ($swash->{'LIST'} =~ /^V/) {
        @invlist = split "\n", $swash->{'LIST'} =~ s/ \s* (?: \# .* )? $ //xmgr;

        shift @invlist;     # Get rid of 'V';

        # Could need to be inverted: add or subtract a 0 at the beginning of
        # the list.
        if ($swash->{'INVERT_IT'}) {
            if (@invlist && $invlist[0] == 0) {
                shift @invlist;
            }
            else {
                unshift @invlist, 0;
            }
        }

        if (@invlist) {
            foreach my $i (0 .. @invlist - 1) {
                $invmap[$i] = ($i % 2 == 0) ? 'Y' : 'N'
            }

            # The map includes lines for all code points; add one for the range
            # from 0 to the first Y.
            if ($invlist[0] != 0) {
                unshift @invlist, 0;
                unshift @invmap, 'N';
            }
        }
    }
    else {
        if ($swash->{'INVERT_IT'}) {
            croak __PACKAGE__, ":prop_invmap: Don't know how to deal with inverted";
        }

        # The LIST input lines look like:
        # ...
        # 0374\t\tCommon
        # 0375\t0377\tGreek   # [3]
        # 037A\t037D\tGreek   # [4]
        # 037E\t\tCommon
        # 0384\t\tGreek
        # ...
        #
        # Convert them to like
        # 0374 => Common
        # 0375 => Greek
        # 0378 => $missing
        # 037A => Greek
        # 037E => Common
        # 037F => $missing
        # 0384 => Greek
        #
        # For binary properties, the final non-comment column is absent, and
        # assumed to be 'Y'.

        foreach my $range (split "\n", $swash->{'LIST'}) {
            $range =~ s/ \s* (?: \# .* )? $ //xg; # rmv trailing space, comments

            # Find the beginning and end of the range on the line
            my ($hex_begin, $hex_end, $map) = split "\t", $range;
            my $begin = hex $hex_begin;
            no warnings 'portable';
            my $end = (defined $hex_end && $hex_end ne "")
                    ? hex $hex_end
                    : $begin;

            # Each time through the loop (after the first):
            # $invlist[-2] contains the beginning of the previous range processed
            # $invlist[-1] contains the end+1 of the previous range processed
            # $invmap[-2] contains the value of the previous range processed
            # $invmap[-1] contains the default value for missing ranges
            #                                                       ($missing)
            #
            # Thus, things are set up for the typical case of a new
            # non-adjacent range of non-missings to be added.  But, if the new
            # range is adjacent, it needs to replace the [-1] element; and if
            # the new range is a multiple value of the previous one, it needs
            # to be added to the [-2] map element.

            # The first time through, everything will be empty.  If the
            # property doesn't have a range that begins at 0, add one that
            # maps to $missing
            if (! @invlist) {
                if ($begin != 0) {
                    push @invlist, 0;
                    push @invmap, $missing;
                }
            }
            elsif (@invlist > 1 && $invlist[-2] == $begin) {

                # Here we handle the case where the input has multiple entries
                # for each code point.  mktables should have made sure that
                # each such range contains only one code point.  At this
                # point, $invlist[-1] is the $missing that was added at the
                # end of the last loop iteration, and [-2] is the last real
                # input code point, and that code point is the same as the one
                # we are adding now, making the new one a multiple entry.  Add
                # it to the existing entry, either by pushing it to the
                # existing list of multiple entries, or converting the single
                # current entry into a list with both on it.  This is all we
                # need do for this iteration.

                if ($end != $begin) {
                    croak __PACKAGE__, ":prop_invmap: Multiple maps per code point in '$prop' require single-element ranges: begin=$begin, end=$end, map=$map";
                }
                if (! ref $invmap[-2]) {
                    $invmap[-2] = [ $invmap[-2], $map ];
                }
                else {
                    push @{$invmap[-2]}, $map;
                }
                $has_multiples = 1;
                next;
            }
            elsif ($invlist[-1] == $begin) {

                # If the input isn't in the most compact form, so that there
                # are two adjacent ranges that map to the same thing, they
                # should be combined (EXCEPT where the arrays require
                # adjustments, in which case everything is already set up
                # correctly).  This happens in our constructed dt mapping, as
                # Element [-2] is the map for the latest range so far
                # processed.  Just set the beginning point of the map to
                # $missing (in invlist[-1]) to 1 beyond where this range ends.
                # For example, in
                # 12\t13\tXYZ
                # 14\t17\tXYZ
                # we have set it up so that it looks like
                # 12 => XYZ
                # 14 => $missing
                #
                # We now see that it should be
                # 12 => XYZ
                # 18 => $missing
                if (! $requires_adjustment && @invlist > 1 && ( (defined $map)
                                    ? $invmap[-2] eq $map
                                    : $invmap[-2] eq 'Y'))
                {
                    $invlist[-1] = $end + 1;
                    next;
                }

                # Here, the range started in the previous iteration that maps
                # to $missing starts at the same code point as this range.
                # That means there is no gap to fill that that range was
                # intended for, so we just pop it off the parallel arrays.
                pop @invlist;
                pop @invmap;
            }

            # Add the range beginning, and the range's map.
            push @invlist, $begin;
            if ($returned_prop eq 'ToDm') {

                # The decomposition maps are either a line like <hangul
                # syllable> which are to be taken as is; or a sequence of code
                # points in hex and separated by blanks.  Convert them to
                # decimal, and if there is more than one, use an anonymous
                # array as the map.
                if ($map =~ /^ < /x) {
                    push @invmap, $map;
                }
                else {
                    my @map = split " ", $map;
                    if (@map == 1) {
                        push @invmap, $map[0];
                    }
                    else {
                        push @invmap, \@map;
                    }
                }
            }
            else {

                # Otherwise, convert hex formatted list entries to decimal;
                # add a 'Y' map for the missing value in binary properties, or
                # otherwise, use the input map unchanged.
                $map = ($format eq 'x' || $format eq 'ax')
                    ? hex $map
                    : $format eq 'b'
                    ? 'Y'
                    : $map;
                push @invmap, $map;
            }

            # We just started a range.  It ends with $end.  The gap between it
            # and the next element in the list must be filled with a range
            # that maps to the default value.  If there is no gap, the next
            # iteration will pop this, unless there is no next iteration, and
            # we have filled all of the Unicode code space, so check for that
            # and skip.
            if ($end < $MAX_CP) {
                push @invlist, $end + 1;
                push @invmap, $missing;
            }
        }
    }

    # If the property is empty, make all code points use the value for missing
    # ones.
    if (! @invlist) {
        push @invlist, 0;
        push @invmap, $missing;
    }

    # The final element is always for just the above-Unicode code points.  If
    # not already there, add it.  It merely splits the current final range
    # that extends to infinity into two elements, each with the same map.
    # (This is to conform with the API that says the final element is for
    # $MAX_UNICODE_CODEPOINT + 1 .. INFINITY.)
    if ($invlist[-1] != $MAX_UNICODE_CODEPOINT + 1) {
        push @invmap, $invmap[-1];
        push @invlist, $MAX_UNICODE_CODEPOINT + 1;
    }

    # The second component of the map are those values that require
    # non-standard specification, stored in SPECIALS.  These override any
    # duplicate code points in LIST.  If we are using a proxy, we may have
    # already set $overrides based on the proxy.
    $overrides = $swash->{'SPECIALS'} unless defined $overrides;
    if ($overrides) {

        # A negative $overrides implies that the SPECIALS should be ignored,
        # and a simple 'a' list is the value.
        if ($overrides < 0) {
            $format = 'a';
        }
        else {

            # Currently, all overrides are for properties that normally map to
            # single code points, but now some will map to lists of code
            # points (but there is an exception case handled below).
            $format = 'al';

            # Look through the overrides.
            foreach my $cp_maybe_utf8 (keys %$overrides) {
                my $cp;
                my @map;

                # If the overrides came from SPECIALS, the code point keys are
                # packed UTF-8.
                if ($overrides == $swash->{'SPECIALS'}) {
                    $cp = $cp_maybe_utf8;
                    if (! utf8::decode($cp)) {
                        croak __PACKAGE__, "::prop_invmap: Malformed UTF-8: ",
                              map { sprintf("\\x{%02X}", unpack("C", $_)) }
                                                                split "", $cp;
                    }

                    $cp = unpack("W", $cp);
                    @map = unpack "W*", $swash->{'SPECIALS'}{$cp_maybe_utf8};

                    # The empty string will show up unpacked as an empty
                    # array.
                    $format = 'ale' if @map == 0;
                }
                else {

                    # But if we generated the overrides, we didn't bother to
                    # pack them, and we, so far, do this only for properties
                    # that are 'a' ones.
                    $cp = $cp_maybe_utf8;
                    @map = hex $overrides->{$cp};
                    $format = 'a';
                }

                # Find the range that the override applies to.
                my $i = search_invlist(\@invlist, $cp);
                if ($cp < $invlist[$i] || $cp >= $invlist[$i + 1]) {
                    croak __PACKAGE__, "::prop_invmap: wrong_range, cp=$cp; i=$i, current=$invlist[$i]; next=$invlist[$i + 1]"
                }

                # And what that range currently maps to
                my $cur_map = $invmap[$i];

                # If there is a gap between the next range and the code point
                # we are overriding, we have to add elements to both arrays to
                # fill that gap, using the map that applies to it, which is
                # $cur_map, since it is part of the current range.
                if ($invlist[$i + 1] > $cp + 1) {
                    #use feature 'say';
                    #say "Before splice:";
                    #say 'i-2=[', $i-2, ']', sprintf("%04X maps to %s", $invlist[$i-2], $invmap[$i-2]) if $i >= 2;
                    #say 'i-1=[', $i-1, ']', sprintf("%04X maps to %s", $invlist[$i-1], $invmap[$i-1]) if $i >= 1;
                    #say 'i  =[', $i, ']', sprintf("%04X maps to %s", $invlist[$i], $invmap[$i]);
                    #say 'i+1=[', $i+1, ']', sprintf("%04X maps to %s", $invlist[$i+1], $invmap[$i+1]) if $i < @invlist + 1;
                    #say 'i+2=[', $i+2, ']', sprintf("%04X maps to %s", $invlist[$i+2], $invmap[$i+2]) if $i < @invlist + 2;

                    splice @invlist, $i + 1, 0, $cp + 1;
                    splice @invmap, $i + 1, 0, $cur_map;

                    #say "After splice:";
                    #say 'i-2=[', $i-2, ']', sprintf("%04X maps to %s", $invlist[$i-2], $invmap[$i-2]) if $i >= 2;
                    #say 'i-1=[', $i-1, ']', sprintf("%04X maps to %s", $invlist[$i-1], $invmap[$i-1]) if $i >= 1;
                    #say 'i  =[', $i, ']', sprintf("%04X maps to %s", $invlist[$i], $invmap[$i]);
                    #say 'i+1=[', $i+1, ']', sprintf("%04X maps to %s", $invlist[$i+1], $invmap[$i+1]) if $i < @invlist + 1;
                    #say 'i+2=[', $i+2, ']', sprintf("%04X maps to %s", $invlist[$i+2], $invmap[$i+2]) if $i < @invlist + 2;
                }

                # If the remaining portion of the range is multiple code
                # points (ending with the one we are replacing, guaranteed by
                # the earlier splice).  We must split it into two
                if ($invlist[$i] < $cp) {
                    $i++;   # Compensate for the new element

                    #use feature 'say';
                    #say "Before splice:";
                    #say 'i-2=[', $i-2, ']', sprintf("%04X maps to %s", $invlist[$i-2], $invmap[$i-2]) if $i >= 2;
                    #say 'i-1=[', $i-1, ']', sprintf("%04X maps to %s", $invlist[$i-1], $invmap[$i-1]) if $i >= 1;
                    #say 'i  =[', $i, ']', sprintf("%04X maps to %s", $invlist[$i], $invmap[$i]);
                    #say 'i+1=[', $i+1, ']', sprintf("%04X maps to %s", $invlist[$i+1], $invmap[$i+1]) if $i < @invlist + 1;
                    #say 'i+2=[', $i+2, ']', sprintf("%04X maps to %s", $invlist[$i+2], $invmap[$i+2]) if $i < @invlist + 2;

                    splice @invlist, $i, 0, $cp;
                    splice @invmap, $i, 0, 'dummy';

                    #say "After splice:";
                    #say 'i-2=[', $i-2, ']', sprintf("%04X maps to %s", $invlist[$i-2], $invmap[$i-2]) if $i >= 2;
                    #say 'i-1=[', $i-1, ']', sprintf("%04X maps to %s", $invlist[$i-1], $invmap[$i-1]) if $i >= 1;
                    #say 'i  =[', $i, ']', sprintf("%04X maps to %s", $invlist[$i], $invmap[$i]);
                    #say 'i+1=[', $i+1, ']', sprintf("%04X maps to %s", $invlist[$i+1], $invmap[$i+1]) if $i < @invlist + 1;
                    #say 'i+2=[', $i+2, ']', sprintf("%04X maps to %s", $invlist[$i+2], $invmap[$i+2]) if $i < @invlist + 2;
                }

                # Here, the range we are overriding contains a single code
                # point.  The result could be the empty string, a single
                # value, or a list.  If the last case, we use an anonymous
                # array.
                $invmap[$i] = (scalar @map == 0)
                               ? ""
                               : (scalar @map > 1)
                                  ? \@map
                                  : $map[0];
            }
        }
    }
    elsif ($format eq 'x') {

        # All hex-valued properties are really to code points, and have been
        # converted to decimal.
        $format = 's';
    }
    elsif ($returned_prop eq 'ToDm') {
        $format = 'ad';
    }
    elsif ($format eq 'sw') { # blank-separated elements to form a list.
        map { $_ = [ split " ", $_  ] if $_ =~ / / } @invmap;
        $format = 'sl';
    }
    elsif ($returned_prop =~ / To ( _Perl )? NameAlias/x) {

        # This property currently doesn't have any lists, but theoretically
        # could
        $format = 'sl';
    }
    elsif ($returned_prop eq 'ToPerlDecimalDigit') {
        $format = 'ae';
    }
    elsif ($returned_prop eq 'ToNv') {

        # The one property that has this format is stored as a delta, so needs
        # to indicate that need to add code point to it.
        $format = 'ar';
    }
    elsif ($format eq 'ax') {

        # Normally 'ax' properties have overrides, and will have been handled
        # above, but if not, they still need adjustment, and the hex values
        # have already been converted to decimal
        $format = 'a';
    }
    elsif ($format ne 'n' && $format !~ / ^ a /x) {

        # All others are simple scalars
        $format = 's';
    }
    if ($has_multiples &&  $format !~ /l/) {
	croak __PACKAGE__, "::prop_invmap: Wrong format '$format' for prop_invmap('$prop'); should indicate has lists";
    }

    return (\@invlist, \@invmap, $format, $missing);
}

sub search_invlist {

=pod

=head2 B<search_invlist()>

 use Unicode::UCD qw(prop_invmap prop_invlist);
 use Unicode::UCD 'search_invlist';

 my @invlist = prop_invlist($property_name);
 print $code_point, ((search_invlist(\@invlist, $code_point) // -1) % 2)
                     ? " isn't"
                     : " is",
     " in $property_name\n";

 my ($blocks_ranges_ref, $blocks_map_ref) = prop_invmap("Block");
 my $index = search_invlist($blocks_ranges_ref, $code_point);
 print "$code_point is in block ", $blocks_map_ref->[$index], "\n";

C<search_invlist> is used to search an inversion list returned by
C<prop_invlist> or C<prop_invmap> for a particular L</code point argument>.
C<undef> is returned if the code point is not found in the inversion list
(this happens only when it is not a legal L</code point argument>, or is less
than the list's first element).  A warning is raised in the first instance.

Otherwise, it returns the index into the list of the range that contains the
code point.; that is, find C<i> such that

    list[i]<= code_point < list[i+1].

As explained in L</prop_invlist()>, whether a code point is in the list or not
depends on if the index is even (in) or odd (not in).  And as explained in
L</prop_invmap()>, the index is used with the returned parallel array to find
the mapping.

=cut


    my $list_ref = shift;
    my $input_code_point = shift;
    my $code_point = _getcode($input_code_point);

    if (! defined $code_point) {
        carp __PACKAGE__, "::search_invlist: unknown code '$input_code_point'";
        return;
    }

    my $max_element = @$list_ref - 1;

    # Return undef if list is empty or requested item is before the first element.
    return if $max_element < 0;
    return if $code_point < $list_ref->[0];

    # Short cut something at the far-end of the table.  This also allows us to
    # refer to element [$i+1] without fear of being out-of-bounds in the loop
    # below.
    return $max_element if $code_point >= $list_ref->[$max_element];

    use integer;        # want integer division

    my $i = $max_element / 2;

    my $lower = 0;
    my $upper = $max_element;
    while (1) {

        if ($code_point >= $list_ref->[$i]) {

            # Here we have met the lower constraint.  We can quit if we
            # also meet the upper one.
            last if $code_point < $list_ref->[$i+1];

            $lower = $i;        # Still too low.

        }
        else {

            # Here, $code_point < $list_ref[$i], so look lower down.
            $upper = $i;
        }

        # Split search domain in half to try again.
        my $temp = ($upper + $lower) / 2;

        # No point in continuing unless $i changes for next time
        # in the loop.
        return $i if $temp == $i;
        $i = $temp;
    } # End of while loop

    # Here we have found the offset
    return $i;
}

=head2 Unicode::UCD::UnicodeVersion

This returns the version of the Unicode Character Database, in other words, the
version of the Unicode standard the database implements.  The version is a
string of numbers delimited by dots (C<'.'>).

=cut

my $UNICODEVERSION;

sub UnicodeVersion {
    unless (defined $UNICODEVERSION) {
	my $versionfh = openunicode("version");
	local $/ = "\n";
	chomp($UNICODEVERSION = <$versionfh>);
	croak __PACKAGE__, "::VERSION: strange version '$UNICODEVERSION'"
	    unless $UNICODEVERSION =~ /^\d+(?:\.\d+)+$/;
    }
    $v_unicode_version = pack "C*", split /\./, $UNICODEVERSION;
    return $UNICODEVERSION;
}

=head2 B<Blocks versus Scripts>

The difference between a block and a script is that scripts are closer
to the linguistic notion of a set of code points required to represent
languages, while block is more of an artifact of the Unicode code point
numbering and separation into blocks of consecutive code points (so far the
size of a block is some multiple of 16, like 128 or 256).

For example the Latin B<script> is spread over several B<blocks>, such
as C<Basic Latin>, C<Latin 1 Supplement>, C<Latin Extended-A>, and
C<Latin Extended-B>.  On the other hand, the Latin script does not
contain all the characters of the C<Basic Latin> block (also known as
ASCII): it includes only the letters, and not, for example, the digits
nor the punctuation.

For blocks see L<http://www.unicode.org/Public/UNIDATA/Blocks.txt>

For scripts see UTR #24: L<http://www.unicode.org/reports/tr24/>

=head2 B<Matching Scripts and Blocks>

Scripts are matched with the regular-expression construct
C<\p{...}> (e.g. C<\p{Tibetan}> matches characters of the Tibetan script),
while C<\p{Blk=...}> is used for blocks (e.g. C<\p{Blk=Tibetan}> matches
any of the 256 code points in the Tibetan block).

=head2 Old-style versus new-style block names

Unicode publishes the names of blocks in two different styles, though the two
are equivalent under Unicode's loose matching rules.

The original style uses blanks and hyphens in the block names (except for
C<No_Block>), like so:

 Miscellaneous Mathematical Symbols-B

The newer style replaces these with underscores, like this:

 Miscellaneous_Mathematical_Symbols_B

This newer style is consistent with the values of other Unicode properties.
To preserve backward compatibility, all the functions in Unicode::UCD that
return block names (except as noted) return the old-style ones.
L</prop_value_aliases()> returns the new-style and can be used to convert from
old-style to new-style:

 my $new_style = prop_values_aliases("block", $old_style);

Perl also has single-form extensions that refer to blocks, C<In_Cyrillic>,
meaning C<Block=Cyrillic>.  These have always been written in the new style.

To convert from new-style to old-style, follow this recipe:

 $old_style = charblock((prop_invlist("block=$new_style"))[0]);

(which finds the range of code points in the block using C<prop_invlist>,
gets the lower end of the range (0th element) and then looks up the old name
for its block using C<charblock>).

Note that starting in Unicode 6.1, many of the block names have shorter
synonyms.  These are always given in the new style.

