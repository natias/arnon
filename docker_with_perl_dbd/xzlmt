perl internals it requires have been removed with perl 5.26.

=item C<use utf8> still needed to enable L<UTF-8|/Unicode Encodings> in scripts

If your Perl script is itself encoded in L<UTF-8|/Unicode Encodings>,
the S<C<use utf8>> pragma must be explicitly included to enable
recognition of that (in string or regular expression literals, or in
identifier names).  B<This is the only time when an explicit S<C<use
utf8>> is needed.>  (See L<utf8>).

If a Perl script begins with the bytes that form the UTF-8 encoding of
the Unicode BYTE ORDER MARK (C<BOM>, see L</Unicode Encodings>), those
bytes are completely ignored.

=item L<UTF-16|/Unicode Encodings> scripts autodetected

If a Perl script begins with the Unicode C<BOM> (UTF-16LE,
UTF16-BE), or if the script looks like non-C<BOM>-marked
UTF-16 of either endianness, Perl will correctly read in the script as
the appropriate Unicode encoding.

=back

=head2 Byte and Character Semantics

Before Unicode, most encodings used 8 bits (a single byte) to encode
each character.  Thus a character was a byte, and a byte was a
character, and there could be only 256 or fewer possible characters.
"Byte Semantics" in the title of this section refers to
this behavior.  There was no need to distinguish between "Byte" and
"Character".

Then along comes Unicode which has room for over a million characters
(and Perl allows for even more).  This means that a character may
require more than a single byte to represent it, and so the two terms
are no longer equivalent.  What matter are the characters as whole
entities, and not usually the bytes that comprise them.  That's what the
term "Character Semantics" in the title of this section refers to.

Perl had to change internally to decouple "bytes" from "characters".
It is important that you too change your ideas, if you haven't already,
so that "byte" and "character" no longer mean the same thing in your
mind.

The basic building block of Perl strings has always been a "character".
The changes basically come down to that the implementation no longer
thinks that a character is always just a single byte.

There are various things to note:

=over 4

=item *

String handling functions, for the most part, continue to operate in
terms of characters.  C<length()>, for example, returns the number of
characters in a string, just as before.  But that number no longer is
necessarily the same as the number of bytes in the string (there may be
more bytes than characters).  The other such functions include
C<chop()>, C<chomp()>, C<substr()>, C<pos()>, C<index()>, C<rindex()>,
C<sort()>, C<sprintf()>, and C<write()>.

The exceptions are:

=over 4

=item *

the bit-oriented C<vec>

E<nbsp>

=item *

the byte-oriented C<pack>/C<unpack> C<"C"> format

However, the C<W> specifier does operate on whole characters, as does the
C<U> specifier.

=item *

some operators that interact with the platform's operating system

Operators dealing with filenames are examples.

=item *

when the functions are called from within the scope of the
S<C<L<use bytes|bytes>>> pragma

Likely, you should use this only for debugging anyway.

=back

=item *

Strings--including hash keys--and regular expression patterns may
contain characters that have ordinal values larger than 255.

If you use a Unicode editor to edit your program, Unicode characters may
occur directly within the literal strings in UTF-8 encoding, or UTF-16.
(The former requires a C<use utf8>, the latter may require a C<BOM>.)

L<perluniintro/Creating Unicode> gives other ways to place non-ASCII
characters in your strings.

=item *

The C<chr()> and C<ord()> functions work on whole characters.

=item *

Regular expressions match whole characters.  For example, C<"."> matches
a whole character instead of only a single byte.

=item *

The C<tr///> operator translates whole characters.  (Note that the
C<tr///CU> functionality has been removed.  For similar functionality to
that, see S<C<pack('U0', ...)>> and S<C<pack('C0', ...)>>).

=item *

C<scalar reverse()> reverses by character rather than by byte.

=item *

The bit string operators, C<& | ^ ~> and (starting in v5.22)
C<&. |. ^.  ~.> can operate on bit strings encoded in UTF-8, but this
can give unexpected results if any of the strings contain code points
above 0xFF.  Starting in v5.28, it is a fatal error to have such an
operand.  Otherwise, the operation is performed on a non-UTF-8 copy of
the operand.  If you're not sure about the encoding of a string,
downgrade it before using any of these operators; you can use
L<C<utf8::utf8_downgrade()>|utf8/Utility functions>.

=back

The bottom line is that Perl has always practiced "Character Semantics",
but with the advent of Unicode, that is now different than "Byte
Semantics".

=head2 ASCII Rules versus Unicode Rules

Before Unicode, when a character was a byte was a character,
Perl knew only about the 128 characters defined by ASCII, code points 0
through 127 (except for under L<S<C<use locale>>|perllocale>).  That
left the code
points 128 to 255 as unassigned, and available for whatever use a
program might want.  The only semantics they have is their ordinal
numbers, and that they are members of none of the non-negative character
classes.  None are considered to match C<\w> for example, but all match
C<\W>.

Unicode, of course, assigns each of those code points a particular
meaning (along with ones above 255).  To preserve backward
compatibility, Perl only uses the Unicode meanings when there is some
indication that Unicode is what is intended; otherwise the non-ASCII
code points remain treated as if they are unassigned.

Here are the ways that Perl knows that a string should be treated as
Unicode:

=over

=item *

Within the scope of S<C<use utf8>>

If the whole program is Unicode (signified by using 8-bit B<U>nicode
B<T>ransformation B<F>ormat), then all literal strings within it must be
Unicode.

=item *

Within the scope of
L<S<C<use feature 'unicode_strings'>>|feature/The 'unicode_strings' feature>

This pragma was created so you can explicitly tell Perl that operations
executed within its scope are to use Unicode rules.  More operations are
affected with newer perls.  See L</The "Unicode Bug">.

=item *

Within the scope of S<C<use v5.12>> or higher

This implicitly turns on S<C<use feature 'unicode_strings'>>.

=item *

Within the scope of
L<S<C<use locale 'not_characters'>>|perllocale/Unicode and UTF-8>,
or L<S<C<use locale>>|perllocale> and the current
locale is a UTF-8 locale.

The former is defined to imply Unicode handling; and the latter
indicates a Unicode locale, hence a Unicode interpretation of all
strings within it.

=item *

When the string contains a Unicode-only code point

Perl has never accepted code points above 255 without them being
Unicode, so their use implies Unicode for the whole string.

=item *

When the string contains a Unicode named code point C<\N{...}>

The C<\N{...}> construct explicitly refers to a Unicode code point,
even if it is one that is also in ASCII.  Therefore the string
containing it must be Unicode.

=item *

When the string has come from an external source marked as
Unicode

The L<C<-C>|perlrun/-C [numberE<sol>list]> command line option can
specify that certain inputs to the program are Unicode, and the values
of this can be read by your Perl code, see L<perlvar/"${^UNICODE}">.

=item * When the string has been upgraded to UTF-8

The function L<C<utf8::utf8_upgrade()>|utf8/Utility functions>
can be explicitly used to permanently (unless a subsequent
C<utf8::utf8_downgrade()> is called) cause a string to be treated as
Unicode.

=item * There are additional methods for regular expression patterns

A pattern that is compiled with the C<< /u >> or C<< /a >> modifiers is
treated as Unicode (though there are some restrictions with C<< /a >>).
Under the C<< /d >> and C<< /l >> modifiers, there are several other
indications for Unicode; see L<perlre/Character set modifiers>.

=back

Note that all of the above are overridden within the scope of
C<L<use bytes|bytes>>; but you should be using this pragma only for
debugging.

Note also that some interactions with the platform's operating system
never use Unicode rules.

When Unicode rules are in effect:

=over 4

=item *

Case translation operators use the Unicode case translation tables.

Note that C<uc()>, or C<\U> in interpolated strings, translates to
uppercase, while C<ucfirst>, or C<\u> in interpolated strings,
translates to titlecase in languages that make the distinction (which is
equivalent to uppercase in languages without the distinction).

There is a CPAN module, C<L<Unicode::Casing>>, which allows you to
define your own mappings to be used in C<lc()>, C<lcfirst()>, C<uc()>,
C<ucfirst()>, and C<fc> (or their double-quoted string inlined versions
such as C<\U>).  (Prior to Perl 5.16, this functionality was partially
provided in the Perl core, but suffered from a number of insurmountable
drawbacks, so the CPAN module was written instead.)

=item *

Character classes in regular expressions match based on the character
properties specified in the Unicode properties database.

C<\w> can be used to match a Japanese ideograph, for instance; and
C<[[:digit:]]> a Bengali number.

=item *

Named Unicode properties, scripts, and block ranges may be used (like
bracketed character classes) by using the C<\p{}> "matches property"
construct and the C<\P{}> negation, "doesn't match property".

See L</"Unicode Character Properties"> for more details.

You can define your own character properties and use them
in the regular expression with the C<\p{}> or C<\P{}> construct.
See L</"User-Defined Character Properties"> for more details.

=back

=head2 Extended Grapheme Clusters (Logical characters)

Consider a character, say C<H>.  It could appear with various marks around it,
such as an acute accent, or a circumflex, or various hooks, circles, arrows,
I<etc.>, above, below, to one side or the other, I<etc>.  There are many
possibilities among the world's languages.  The number of combinations is
astronomical, and if there were a character for each combination, it would
soon exhaust Unicode's more than a million possible characters.  So Unicode
took a different approach: there is a character for the base C<H>, and a
character for each of the possible marks, and these can be variously combined
to get a final logical character.  So a logical character--what appears to be a
single character--can be a sequence of more than one individual characters.
The Unicode standard calls these "extended grapheme clusters" (which
is an improved version of the no-longer much used "grapheme cluster");
Perl furnishes the C<\X> regular expression construct to match such
sequences in their entirety.

But Unicode's intent is to unify the existing character set standards and
practices, and several pre-existing standards have single characters that
mean the same thing as some of these combinations, like ISO-8859-1,
which has quite a few of them. For example, C<"LATIN CAPITAL LETTER E
WITH ACUTE"> was already in this standard when Unicode came along.
Unicode therefore added it to its repertoire as that single character.
But this character is considered by Unicode to be equivalent to the
sequence consisting of the character C<"LATIN CAPITAL LETTER E">
followed by the character C<"COMBINING ACUTE ACCENT">.

C<"LATIN CAPITAL LETTER E WITH ACUTE"> is called a "pre-composed"
character, and its equivalence with the "E" and the "COMBINING ACCENT"
sequence is called canonical equivalence.  All pre-composed characters
are said to have a decomposition (into the equivalent sequence), and the
decomposition type is also called canonical.  A string may consist
as much as possible of precomposed characters, or it may consist of
entirely decomposed characters.  Unicode calls these respectively,
"Normalization Form Composed" (NFC) and "Normalization Form Decomposed".
The C<L<Unicode::Normalize>> module contains functions that convert
between the two.  A string may also have both composed characters and
decomposed characters; this module can be used to make it all one or the
other.

You may be presented with strings in any of these equivalent forms.
There is currently nothing in Perl 5 that ignores the differences.  So
you'll have to specially handle it.  The usual advice is to convert your
inputs to C<NFD> before processing further.

For more detailed information, see L<http://unicode.org/reports/tr15/>.

=head2 Unicode Character Properties

(The only time that Perl considers a sequence of individual code
points as a single logical character is in the C<\X> construct, already
mentioned above.   Therefore "character" in this discussion means a single
Unicode code point.)

Very nearly all Unicode character properties are accessible through
regular expressions by using the C<\p{}> "matches property" construct
and the C<\P{}> "doesn't match property" for its negation.

For instance, C<\p{Uppercase}> matches any single character with the Unicode
C<"Uppercase"> property, while C<\p{L}> matches any character with a
C<General_Category> of C<"L"> (letter) property (see
L</General_Category> below).  Brackets are not
required for single letter property names, so C<\p{L}> is equivalent to C<\pL>.

More formally, C<\p{Uppercase}> matches any single character whose Unicode
C<Uppercase> property value is C<True>, and C<\P{Uppercase}> matches any character
whose C<Uppercase> property value is C<False>, and they could have been written as
C<\p{Uppercase=True}> and C<\p{Uppercase=False}>, respectively.

This formality is needed when properties are not binary; that is, if they can
take on more values than just C<True> and C<False>.  For example, the
C<Bidi_Class> property (see L</"Bidirectional Character Types"> below),
can take on several different
values, such as C<Left>, C<Right>, C<Whitespace>, and others.  To match these, one needs
to specify both the property name (C<Bidi_Class>), AND the value being
matched against
(C<Left>, C<Right>, I<etc.>).  This is done, as in the examples above, by having the
two components separated by an equal sign (or interchangeably, a colon), like
C<\p{Bidi_Class: Left}>.

All Unicode-defined character properties may be written in these compound forms
of C<\p{I<property>=I<value>}> or C<\p{I<property>:I<value>}>, but Perl provides some
additional properties that are written only in the single form, as well as
single-form short-cuts for all binary properties and certain others described
below, in which you may omit the property name and the equals or colon
separator.

Most Unicode character properties have at least two synonyms (or aliases if you
prefer): a short one that is easier to type and a longer one that is more
descriptive and hence easier to understand.  Thus the C<"L"> and
C<"Letter"> properties above are equivalent and can be used
interchangeably.  Likewise, C<"Upper"> is a synonym for C<"Uppercase">,
and we could have written C<\p{Uppercase}> equivalently as C<\p{Upper}>.
Also, there are typically various synonyms for the values the property
can be.   For binary properties, C<"True"> has 3 synonyms: C<"T">,
C<"Yes">, and C<"Y">; and C<"False"> has correspondingly C<"F">,
C<"No">, and C<"N">.  But be careful.  A short form of a value for one
property may not mean the same thing as the short form spelled the same
for another.
Thus, for the C<L</General_Category>> property, C<"L"> means
C<"Letter">, but for the L<C<Bidi_Class>|/Bidirectional Character Types>
property, C<"L"> means C<"Left">.  A complete list of properties and
synonyms is in L<perluniprops>.

Upper/lower case differences in property names and values are irrelevant;
thus C<\p{Upper}> means the same thing as C<\p{upper}> or even C<\p{UpPeR}>.
Similarly, you can add or subtract underscores anywhere in the middle of a
word, so that these are also equivalent to C<\p{U_p_p_e_r}>.  And white space
is generally irrelevant adjacent to non-word characters, such as the
braces and the equals or colon separators, so C<\p{   Upper  }> and
C<\p{ Upper_case : Y }> are equivalent to these as well.  In fact, white
space and even hyphens can usually be added or deleted anywhere.  So
even C<\p{ Up-per case = Yes}> is equivalent.  All this is called
"loose-matching" by Unicode.  The "name" property has some restrictions
on this due to a few outlier names.  Full details are given in
L<https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2>.

The few places where stricter matching is
used is in the middle of numbers, the "name" property, and in the Perl
extension properties that begin or end with an underscore.  Stricter
matching cares about white space (except adjacent to non-word
characters), hyphens, and non-interior underscores.

You can also use negation in both C<\p{}> and C<\P{}> by introducing a caret
(C<^>) between the first brace and the property name: C<\p{^Tamil}> is
equal to C<\P{Tamil}>.

Almost all properties are immune to case-insensitive matching.  That is,
adding a C</i> regular expression modifier does not change what they
match.  There are two sets that are affected.
The first set is
C<Uppercase_Letter>,
C<Lowercase_Letter>,
and C<Titlecase_Letter>,
all of which match C<Cased_Letter> under C</i> matching.
And the second set is
C<Uppercase>,
C<Lowercase>,
and C<Titlecase>,
all of which match C<Cased> under C</i> matching.
This set also includes its subsets C<PosixUpper> and C<PosixLower> both
of which under C</i> match C<PosixAlpha>.
(The difference between these sets is that some things, such as Roman
numerals, come in both upper and lower case so they are C<Cased>, but
aren't considered letters, so they aren't C<Cased_Letter>'s.)

See L</Beyond Unicode code points> for special considerations when
matching Unicode properties against non-Unicode code points.

=head3 B<General_Category>

Every Unicode character is assigned a general category, which is the "most
usual categorization of a character" (from
L<https://www.unicode.org/reports/tr44>).

The compound way of writing these is like C<\p{General_Category=Number}>
(short: C<\p{gc:n}>).  But Perl furnishes shortcuts in which everything up
through the equal or colon separator is omitted.  So you can instead just write
C<\pN>.

Here are the short and long forms of the values the C<General Category> property
can have:

    Short       Long

    L           Letter
    LC, L&      Cased_Letter (that is: [\p{Ll}\p{Lu}\p{Lt}])
    Lu          Uppercase_Letter
    Ll          Lowercase_Letter
    Lt          Titlecase_Letter
    Lm          Modifier_Letter
    Lo          Other_Letter

    M           Mark
    Mn          Nonspacing_Mark
    Mc          Spacing_Mark
    Me          Enclosing_Mark

    N           Number
    Nd          Decimal_Number (also Digit)
    Nl          Letter_Number
    No          Other_Number

    P           Punctuation (also Punct)
    Pc          Connector_Punctuation
    Pd          Dash_Punctuation
    Ps          Open_Punctuation
    Pe          Close_Punctuation
    Pi          Initial_Punctuation
                (may behave like Ps or Pe depending on usage)
    Pf          Final_Punctuation
                (may behave like Ps or Pe depending on usage)
    Po          Other_Punctuation

    S           Symbol
    Sm          Math_Symbol
    Sc          Currency_Symbol
    Sk          Modifier_Symbol
    So          Other_Symbol

    Z           Separator
    Zs          Space_Separator
    Zl          Line_Separator
    Zp          Paragraph_Separator

    C           Other
    Cc          Control (also Cntrl)
    Cf          Format
    Cs          Surrogate
    Co          Private_Use
    Cn          Unassigned

Single-letter properties match all characters in any of the
two-letter sub-properties starting with the same letter.
C<LC> and C<L&> are special: both are aliases for the set consisting of everything matched by C<Ll>, C<Lu>, and C<Lt>.

=head3 B<Bidirectional Character Types>

Because scripts differ in their directionality (Hebrew and Arabic are
written right to left, for example) Unicode supplies a C<Bidi_Class> property.
Some of the values this property can have are:

    Value       Meaning

    L           Left-to-Right
    LRE         Left-to-Right Embedding
    LRO         Left-to-Right Override
    R           Right-to-Left
    AL          Arabic Letter
    RLE         Right-to-Left Embedding
    RLO         Right-to-Left Override
    PDF         Pop Directional Format
    EN          European Number
    ES          European Separator
    ET          European Terminator
    AN          Arabic Number
    CS          Common Separator
    NSM         Non-Spacing Mark
    BN          Boundary Neutral
    B           Paragraph Separator
    S           Segment Separator
    WS          Whitespace
    ON          Other Neutrals

This property is always written in the compound form.
For example, C<\p{Bidi_Class:R}> matches characters that are normally
written right to left.  Unlike the
C<L</General_Category>> property, this
property can have more values added in a future Unicode release.  Those
listed above comprised the complete set for many Unicode releases, but
others were added in Unicode 6.3; you can always find what the
current ones are in L<perluniprops>.  And
L<https://www.unicode.org/reports/tr9/> describes how to use them.

=head3 B<Scripts>

The world's languages are written in many different scripts.  This sentence
(unless you're reading it in translation) is written in Latin, while Russian is
written in Cyrillic, and Greek is written in, well, Greek; Japanese mainly in
Hiragana or Katakana.  There are many more.

The Unicode C<Script> and C<Script_Extensions> properties give what
script a given character is in.  The C<Script_Extensions> property is an
improved version of C<Script>, as demonstrated below.  Either property
can be specified with the compound form like
C<\p{Script=Hebrew}> (short: C<\p{sc=hebr}>), or
C<\p{Script_Extensions=Javanese}> (short: C<\p{scx=java}>).
In addition, Perl furnishes shortcuts for all
C<Script_Extensions> property names.  You can omit everything up through
the equals (or colon), and simply write C<\p{Latin}> or C<\P{Cyrillic}>.
(This is not true for C<Script>, which is required to be
written in the compound form.  Prior to Perl v5.26, the single form
returned the plain old C<Script> version, but was changed because
C<Script_Extensions> gives better results.)

The difference between these two properties involves characters that are
used in multiple scripts.  For example the digits '0' through '9' are
used in many parts of the world.  These are placed in a script named
C<Common>.  Other characters are used in just a few scripts.  For
example, the C<"KATAKANA-HIRAGANA DOUBLE HYPHEN"> is used in both Japanese
scripts, Katakana and Hiragana, but nowhere else.  The C<Script>
property places all characters that are used in multiple scripts in the
C<Common> script, while the C<Script_Extensions> property places those
that are used in only a few scripts into each of those scripts; while
still using C<Common> for those used in many scripts.  Thus both these
match:

 "0" =~ /\p{sc=Common}/     # Matches
 "0" =~ /\p{scx=Common}/    # Matches

and only the first of these match:

 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{sc=Common}  # Matches
 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{scx=Common} # No match

And only the last two of these match:

 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{sc=Hiragana}  # No match
 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{sc=Katakana}  # No match
 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{scx=Hiragana} # Matches
 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{scx=Katakana} # Matches

C<Script_Extensions> is thus an improved C<Script>, in which there are
fewer characters in the C<Common> script, and correspondingly more in
other scripts.  It is new in Unicode version 6.0, and its data are likely
to change significantly in later releases, as things get sorted out.
New code should probably be using C<Script_Extensions> and not plain
C<Script>.  If you compile perl with a Unicode release that doesn't have
C<Script_Extensions>, the single form Perl extensions will instead refer
to the plain C<Script> property.  If you compile with a version of
Unicode that doesn't have the C<Script> property, these extensions will
not be defined at all.

(Actually, besides C<Common>, the C<Inherited> script, contains
characters that are used in multiple scripts.  These are modifier
characters which inherit the script value
of the controlling character.  Some of these are used in many scripts,
and so go into C<Inherited> in both C<Script> and C<Script_Extensions>.
Others are used in just a few scripts, so are in C<Inherited> in
C<Script>, but not in C<Script_Extensions>.)

It is worth stressing that there are several different sets of digits in
Unicode that are equivalent to 0-9 and are matchable by C<\d> in a
regular expression.  If they are used in a single language only, they
are in that language's C<Script> and C<Script_Extensions>.  If they are
used in more than one script, they will be in C<sc=Common>, but only
if they are used in many scripts should they be in C<scx=Common>.

The explanation above has omitted some detail; refer to UAX#24 "Unicode
Script Property": L<https://www.unicode.org/reports/tr24>.

A complete list of scripts and their shortcuts is in L<perluniprops>.

=head3 B<Use of the C<"Is"> Prefix>

For backward compatibility (with ancient Perl 5.6), all properties writable
without using the compound form mentioned
so far may have C<Is> or C<Is_> prepended to their name, so C<\P{Is_Lu}>, for
example, is equal to C<\P{Lu}>, and C<\p{IsScript:Arabic}> is equal to
C<\p{Arabic}>.

=head3 B<Blocks>

In addition to B<scripts>, Unicode also defines B<blocks> of
characters.  The difference between scripts and blocks is that the
concept of scripts is closer to natural languages, while the concept
of blocks is more of an artificial grouping based on groups of Unicode
characters with consecutive ordinal values. For example, the C<"Basic Latin">
block is all the characters whose ordinals are between 0 and 127, inclusive; in
other words, the ASCII characters.  The C<"Latin"> script contains some letters
from this as well as several other blocks, like C<"Latin-1 Supplement">,
C<"Latin Extended-A">, I<etc.>, but it does not contain all the characters from
those blocks. It does not, for example, contain the digits 0-9, because
those digits are shared across many scripts, and hence are in the
C<Common> script.

For more about scripts versus blocks, see UAX#24 "Unicode Script Property":
L<https://www.unicode.org/reports/tr24>

The C<Script_Extensions> or C<Script> properties are likely to be the
ones you want to use when processing
natural language; the C<Block> property may occasionally be useful in working
with the nuts and bolts of Unicode.

Block names are matched in the compound form, like C<\p{Block: Arrows}> or
C<\p{Blk=Hebrew}>.  Unlike most other properties, only a few block names have a
Unicode-defined short name.

Perl also defines single form synonyms for the block property in cases
where these do not conflict with something else.  But don't use any of
these, because they are unstable.  Since these are Perl extensions, they
are subordinate to official Unicode property names; Unicode doesn't know
nor care about Perl's extensions.  It may happen that a name that
currently means the Perl extension will later be changed without warning
to mean a different Unicode property in a future version of the perl
interpreter that uses a later Unicode release, and your code would no
longer work.  The extensions are mentioned here for completeness:  Take
the block name and prefix it with one of: C<In> (for example
C<\p{Blk=Arrows}> can currently be written as C<\p{In_Arrows}>); or
sometimes C<Is> (like C<\p{Is_Arrows}>); or sometimes no prefix at all
(C<\p{Arrows}>).  As of this writing (Unicode 9.0) there are no
conflicts with using the C<In_> prefix, but there are plenty with the
other two forms.  For example, C<\p{Is_Hebrew}> and C<\p{Hebrew}> mean
C<\p{Script_Extensions=Hebrew}> which is NOT the same thing as
C<\p{Blk=Hebrew}>.  Our
advice used to be to use the C<In_> prefix as a single form way of
specifying a block.  But Unicode 8.0 added properties whose names begin
with C<In>, and it's now clear that it's only luck that's so far
prevented a conflict.  Using C<In> is only marginally less typing than
C<Blk:>, and the latter's meaning is clearer anyway, and guaranteed to
never conflict.  So don't take chances.  Use C<\p{Blk=foo}> for new
code.  And be sure that block is what you really really want to do.  In
most cases scripts are what you want instead.

A complete list of blocks is in L<perluniprops>.

=head3 B<Other Properties>

There are many more properties than the very basic ones described here.
A complete list is in L<perluniprops>.

Unicode defines all its properties in the compound form, so all single-form
properties are Perl extensions.  Most of these are just synonyms for the
Unicode ones, but some are genuine extensions, including several that are in
the compound form.  And quite a few of these are actually recommended by Unicode
(in L<https://www.unicode.org/reports/tr18>).

This section gives some details on all extensions that aren't just
synonyms for compound-form Unicode properties
(for those properties, you'll have to refer to the
L<Unicode Standard|https://www.unicode.org/reports/tr44>.

=over

=item B<C<\p{All}>>

This matches every possible code point.  It is equivalent to C<qr/./s>.
Unlike all the other non-user-defined C<\p{}> property matches, no
warning is ever generated if this is property is matched against a
non-Unicode code point (see L</Beyond Unicode code points> below).

=item B<C<\p{Alnum}>>

This matches any C<\p{Alphabetic}> or C<\p{Decimal_Number}> character.

=item B<C<\p{Any}>>

This matches any of the 1_114_112 Unicode code points.  It is a synonym
for C<\p{Unicode}>.

=item B<C<\p{ASCII}>>

This matches any of the 128 characters in the US-ASCII character set,
which is a subset of Unicode.

=item B<C<\p{Assigned}>>

This matches any assigned code point; that is, any code point whose L<general
category|/General_Category> is not C<Unassigned> (or equivalently, not C<Cn>).

=item B<C<\p{Blank}>>

This is the same as C<\h> and C<\p{HorizSpace}>:  A character that changes the
spacing horizontally.

=item B<C<\p{Decomposition_Type: Non_Canonical}>>    (Short: C<\p{Dt=NonCanon}>)

Matches a character that has any of the non-canonical decomposition
types.  Canonical decompositions are introduced in the
L</Extended Grapheme Clusters (Logical characters)> section above.
However, many more characters have a different type of decomposition,
generically called "compatible" decompositions, or "non-canonical".  The
sequences that form these decompositions are not considered canonically
equivalent to the pre-composed character.  An example is the
C<"SUPERSCRIPT ONE">.  It is somewhat like a regular digit 1, but not
exactly; its decomposition into the digit 1 is called a "compatible"
decomposition, specifically a "super" (for "superscript") decomposition.
There are several such compatibility decompositions (see
L<https://www.unicode.org/reports/tr44>).  S<C<\p{Dt: Non_Canon}>> is a
Perl extension that uses just one name to refer to the union of all of
them.

Most Unicode characters don't have a decomposition, so their
decomposition type is C<"None">.  Hence, C<Non_Canonical> is equivalent
to

 qr/(?[ \P{DT=Canonical} - \p{DT=None} ])/

(Note that one of the non-canonical decompositions is named "compat",
which could perhaps have been better named "miscellaneous".  It includes
just the things that Unicode couldn't figure out a better generic name
for.)

=item B<C<\p{Graph}>>

Matches any character that is graphic.  Theoretically, this means a character
that on a printer would cause ink to be used.

=item B<C<\p{HorizSpace}>>

This is the same as C<\h> and C<\p{Blank}>:  a character that changes the
spacing horizontally.

=item B<C<\p{In=*}>>

This is a synonym for C<\p{Present_In=*}>

=item B<C<\p{PerlSpace}>>

This is the same as C<\s>, restricted to ASCII, namely C<S<[ \f\n\r\t]>>
and starting in Perl v5.18, a vertical tab.

Mnemonic: Perl's (original) space

=item B<C<\p{PerlWord}>>

This is the same as C<\w>, restricted to ASCII, namely C<[A-Za-z0-9_]>

Mnemonic: Perl's (original) word.

=item B<C<\p{Posix...}>>

There are several of these, which are equivalents, using the C<\p{}>
notation, for Posix classes and are described in
L<perlrecharclass/POSIX Character Classes>.

=item B<C<\p{Present_In: *}>>    (Short: C<\p{In=*}>)

This property is used when you need to know in what Unicode version(s) a
character is.

The "*" above stands for some Unicode version number, such as
C<1.1> or C<12.0>; or the "*" can also be C<Unassigned>.  This property will
match the code points whose final disposition has been settled as of the
Unicode release given by the version number; C<\p{Present_In: Unassigned}>
will match those code points whose meaning has yet to be assigned.

For example, C<U+0041> C<"LATIN CAPITAL LETTER A"> was present in the very first
Unicode release available, which is C<1.1>, so this property is true for all
valid "*" versions.  On the other hand, C<U+1EFF> was not assigned until version
5.1 when it became C<"LATIN SMALL LETTER Y WITH LOOP">, so the only "*" that
would match it are 5.1, 5.2, and later.

Unicode furnishes the C<Age> property from which this is derived.  The problem
with Age is that a strict interpretation of it (which Perl takes) has it
matching the precise release a code point's meaning is introduced in.  Thus
C<U+0041> would match only 1.1; and C<U+1EFF> only 5.1.  This is not usually what
you want.

Some non-Perl implementations of the Age property may change its meaning to be
the same as the Perl C<Present_In> property; just be aware of that.

Another confusion with both these properties is that the definition is not
that the code point has been I<assigned>, but that the meaning of the code point
has been I<determined>.  This is because 66 code points will always be
unassigned, and so the C<Age> for them is the Unicode version in which the decision
to make them so was made.  For example, C<U+FDD0> is to be permanently
unassigned to a character, and the decision to do that was made in version 3.1,
so C<\p{Age=3.1}> matches this character, as also does C<\p{Present_In: 3.1}> and up.

=item B<C<\p{Print}>>

This matches any character that is graphical or blank, except controls.

=item B<C<\p{SpacePerl}>>

This is the same as C<\s>, including beyond ASCII.

Mnemonic: Space, as modified by Perl.  (It doesn't include the vertical tab
until v5.18, which both the Posix standard and Unicode consider white space.)

=item B<C<\p{Title}>> and  B<C<\p{Titlecase}>>

Under case-sensitive matching, these both match the same code points as
C<\p{General Category=Titlecase_Letter}> (C<\p{gc=lt}>).  The difference
is that under C</i> caseless matching, these match the same as
C<\p{Cased}>, whereas C<\p{gc=lt}> matches C<\p{Cased_Letter>).

=item B<C<\p{Unicode}>>

This matches any of the 1_114_112 Unicode code points.
C<\p{Any}>.

=item B<C<\p{VertSpace}>>

This is the same as C<\v>:  A character that changes the spacing vertically.

=item B<C<\p{Word}>>

This is the same as C<\w>, including over 100_000 characters beyond ASCII.

=item B<C<\p{XPosix...}>>

There are several of these, which are the standard Posix classes
extended to the full Unicode range.  They are described in
L<perlrecharclass/POSIX Character Classes>.

=back

=head2 Comparison of C<\N{...}> and C<\p{name=...}>

Starting in Perl 5.32, you can specify a character by its name in
regular expression patterns using C<\p{name=...}>.  This is in addition
to the longstanding method of using C<\N{...}>.  The following
summarizes the differences between these two:

                       \N{...}       \p{Name=...}
 can interpolate    only with eval       yes            [1]
 custom names            yes             no             [2]
 name aliases            yes             yes            [3]
 named sequences         yes             yes            [4]
 name value parsing     exact       Unicode loose       [5]

=over

=item [1]

The ability to interpolate means you can do something like

 qr/\p{na=latin capital letter $which}/

and specify C<$which> elsewhere.

=item [2]

You can create your own names for characters, and override official
ones when using C<\N{...}>.  See L<charnames/CUSTOM ALIASES>.

=item [3]

Some characters have multiple names (synonyms).

=item [4]

Some particular sequences of characters are given a single name, in
addition to their individual ones.

=item [5]

Exact name value matching means you have to specify case, hyphens,
underscores, and spaces precisely in the name you want.  Loose matching
follows the Unicode rules
L<https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2>,
where these are mostly irrelevant.  Except for a few outlier character
names, these are the same rules as are already used for any other
C<\p{...}> property.

=back

=head2 Wildcards in Property Values

Starting in Perl 5.30, it is possible to do something like this:

 qr!\p{numeric_value=/\A[0-5]\z/}!

or, by abbreviating and adding C</x>,

 qr! \p{nv= /(?x) \A [0-5] \z / }!

This matches all code points whose numeric value is one of 0, 1, 2, 3,
4, or 5.  This particular example could instead have been written as

 qr! \A [ \p{nv=0}\p{nv=1}\p{nv=2}\p{nv=3}\p{nv=4}\p{nv=5} ] \z !xx

in earlier perls, so in this case this feature just makes things easier
and shorter to write.  If we hadn't included the C<\A> and C<\z>, these
would have matched things like C<1E<sol>2> because that contains a 1 (as
well as a 2).  As written, it matches things like subscripts that have
these numeric values.  If we only wanted the decimal digits with those
numeric values, we could say,

 qr! (?[ \d & \p{nv=/[0-5]/ ]) }!x

The C<\d> gets rid of needing to anchor the pattern, since it forces the
result to only match C<[0-9]>, and the C<[0-5]> further restricts it.

The text in the above examples enclosed between the C<"E<sol>">
characters can be just about any regular expression.  It is independent
of the main pattern, so doesn't share any capturing groups, I<etc>.  The
delimiters for it must be ASCII punctuation, but it may NOT be
delimited by C<"{">, nor C<"}"> nor contain a literal C<"}">, as that
delimits the end of the enclosing C<\p{}>.  Like any pattern, certain
other delimiters are terminated by their mirror images.  These are
C<"(">, C<"[>", and C<"E<lt>">.  If the delimiter is any of C<"-">,
C<"_">, C<"+">, or C<"\">, or is the same delimiter as is used for the
enclosing pattern, it must be preceded by a backslash escape, both
fore and aft.

Beware of using C<"$"> to indicate to match the end of the string.  It
can too easily be interpreted as being a punctuation variable, like
C<$/>.

No modifiers may follow the final delimiter.  Instead, use
L<perlre/(?adlupimnsx-imnsx)> and/or
L<perlre/(?adluimnsx-imnsx:pattern)> to specify modifiers.
However, certain modifiers are illegal in your wildcard subpattern.
The only character set modifier specifiable is C</aa>;
any other character set, and C<-m>, and C<p>, and C<s> are all illegal.
Specifying modifiers like C<qr/.../gc> that aren't legal in the
C<(?...)> notation normally raise a warning, but with wildcard
subpatterns, their use is an error.  The C<m> modifier is ineffective;
everything that matches will be a single line.

By default, your pattern is matched case-insensitively, as if C</i> had
been specified.  You can change this by saying C<(?-i)> in your pattern.

There are also certain operations that are illegal.  You can't nest
C<\p{...}> and C<\P{...}> calls within a wildcard subpattern, and C<\G>
doesn't make sense, so is also prohibited.

And the C<*> quantifier (or its equivalent C<(0,}>) is illegal.

This feature is not available when the left-hand side is prefixed by
C<Is_>, nor for any form that is marked as "Discouraged" in
L<perluniprops/Discouraged>.

This experimental feature has been added to begin to implement
L<https://www.unicode.org/reports/tr18/#Wildcard_Properties>.  Using it
will raise a (default-on) warning in the
C<experimental::uniprop_wildcards> category.  We reserve the right to
change its operation as we gain experience.

Your subpattern can be just about anything, but for it to have some
utility, it should match when called with either or both of
a) the full name of the property value with underscores (and/or spaces
in the Block property) and some things uppercase; or b) the property
value in all lowercase with spaces and underscores squeezed out.  For
example,

 qr!\p{Blk=/Old I.*/}!
 qr!\p{Blk=/oldi.*/}!

