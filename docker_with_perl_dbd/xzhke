   'sessionoptions' contains "buffers" then all buffers are restored,
   including hidden and unloaded buffers.  Otherwise only buffers in windows
   are restored.
8. Restores all windows with the same layout.  If 'sessionoptions' contains
   "help", help windows are restored.  If 'sessionoptions' contains "blank",
   windows editing a buffer without a name will be restored.
   If 'sessionoptions' contains "winsize" and no (help/blank) windows were
   left out, the window sizes are restored (relative to the screen size).
   Otherwise, the windows are just given sensible sizes.
9. Restores the Views for all the windows, as with |:mkview|.  But
   'sessionoptions' is used instead of 'viewoptions'.
10. If a file exists with the same name as the Session file, but ending in
   "x.vim" (for eXtra), executes that as well.  You can use *x.vim files to
   specify additional settings and actions associated with a given Session,
   such as creating menu items in the GUI version.

After restoring the Session, the full filename of your current Session is
available in the internal variable "v:this_session" |this_session-variable|.
An example mapping: >
  :nmap <F2> :wa<Bar>exe "mksession! " .. v:this_session<CR>:so ~/sessions/
This saves the current Session, and starts off the command to load another.

A session includes all tab pages, unless "tabpages" was removed from
'sessionoptions'. |tab-page|

The |SessionLoadPost| autocmd event is triggered after a session file is
loaded/sourced.
						*SessionLoad-variable*
While the session file is loading the SessionLoad global variable is set to 1.
Plugins can use this to postpone some work until the SessionLoadPost event is
triggered.

							*:mkvie* *:mkview*
:mkvie[w][!] [file]	Write a Vim script that restores the contents of the
			current window.
			When [!] is included an existing file is overwritten.
			When [file] is omitted or is a number from 1 to 9, a
			name is generated and 'viewdir' prepended.  When the
			last path part of 'viewdir' does not exist, this
			directory is created.  E.g., when 'viewdir' is
			"$VIM/vimfiles/view" then "view" is created in
			"$VIM/vimfiles".
			An existing file is always overwritten then.  Use
			|:loadview| to load this view again.
			When [file] is the name of a file ('viewdir' is not
			used), a command to edit the file is added to the
			generated file.

The output of ":mkview" contains these items:
1. The argument list used in the window.  When the global argument list is
   used it is reset to the global list.
   The index in the argument list is also restored.
2. The file being edited in the window.  If there is no file, the window is
   made empty.
3. Restore mappings, abbreviations and options local to the window if
   'viewoptions' contains "options" or "localoptions".  For the options it
   restores only values that are local to the current buffer and values local
   to the window.
   When storing the view as part of a session and "options" is in
   'sessionoptions', global values for local options will be stored too.
4. Restore folds when using manual folding and 'viewoptions' contains
   "folds".  Restore manually opened and closed folds.
5. The scroll position and the cursor position in the file.  Doesn't work very
   well when there are closed folds.
6. The local current directory, if it is different from the global current
   directory and 'viewoptions' contains "curdir".

Note that Views and Sessions are not perfect:
- They don't restore everything.  For example, defined functions, autocommands
  and ":syntax on" are not included.  Things like register contents and
  command line history are in viminfo, not in Sessions or Views.
- Global option values are only set when they differ from the default value.
  When the current value is not the default value, loading a Session will not
  set it back to the default value.  Local options will be set back to the
  default value though.
- Existing mappings will be overwritten without warning.  An existing mapping
  may cause an error for ambiguity.
- When storing manual folds and when storing manually opened/closed folds,
  changes in the file between saving and loading the view will mess it up.
- The Vim script is not very efficient.  But still faster than typing the
  commands yourself!

							*:lo* *:loadview*
:lo[adview] [nr]	Load the view for the current file.  When [nr] is
			omitted, the view stored with ":mkview" is loaded.
			When [nr] is specified, the view stored with ":mkview
			[nr]" is loaded.

The combination of ":mkview" and ":loadview" can be used to store up to ten
different views of a file.  These are remembered in the directory specified
with the 'viewdir' option.  The views are stored using the file name.  If a
file is renamed or accessed through a (symbolic) link the view will not be
found.

You might want to clean up your 'viewdir' directory now and then.

To automatically save and restore views for *.c files: >
	au BufWinLeave *.c mkview
	au BufWinEnter *.c silent loadview

==============================================================================
10. The viminfo file				*viminfo* *viminfo-file* *E136*
						*E575* *E576* *E577*
If you exit Vim and later start it again, you would normally lose a lot of
information.  The viminfo file can be used to remember that information, which
enables you to continue where you left off.

This is introduced in section |21.3| of the user manual.

The viminfo file is used to store:
- The command line history.
- The search string history.
- The input-line history.
- Contents of non-empty registers.
- Marks for several files.
- File marks, pointing to locations in files.
- Last search/substitute pattern (for 'n' and '&').
- The buffer list.
- Global variables.

The viminfo file is not supported when the |+viminfo| feature has been
disabled at compile time.

You could also use a Session file.  The difference is that the viminfo file
does not depend on what you are working on.  There normally is only one
viminfo file.  Session files are used to save the state of a specific editing
Session.  You could have several Session files, one for each project you are
working on.  Viminfo and Session files together can be used to effectively
enter Vim and directly start working in your desired setup. |session-file|

							*viminfo-read*
When Vim is started and the 'viminfo' option is non-empty, the contents of
the viminfo file are read and the info can be used in the appropriate places.
The |v:oldfiles| variable is filled.  The marks are not read in at startup
(but file marks are).  See |initialization| for how to set the 'viminfo'
option upon startup.

							*viminfo-write*
When Vim exits and 'viminfo' is non-empty, the info is stored in the viminfo
file (it's actually merged with the existing one, if one exists).  The
'viminfo' option is a string containing information about what info should be
stored, and contains limits on how much should be stored (see 'viminfo').

Merging happens in two ways.  Most items that have been changed or set in the
current Vim session are stored, and what was not changed is filled from what
is currently in the viminfo file.  For example:
- Vim session A reads the viminfo, which contains variable START.
- Vim session B does the same
- Vim session A sets the variables AAA and BOTH and exits
- Vim session B sets the variables BBB and BOTH and exits
Now the viminfo will have:
   START - it was in the viminfo and wasn't changed in session A or B
   AAA   - value from session A, session B kept it
   BBB   - value from session B
   BOTH  - value from session B, value from session A is lost

							*viminfo-timestamp*
For some items a timestamp is used to keep the last changed version.  Here it
doesn't matter in which sequence Vim sessions exit, the newest item(s) are
always kept.  This is used for:
- The command line history.
- The search string history.
- The input-line history.
- Contents of non-empty registers.
- The jump list
- File marks
The timestamp feature was added before Vim 8.0.  Older versions of Vim,
starting with 7.4.1131, will keep the items with timestamp, but not use them.
Thus when using both an older and a newer version of Vim the most recent data
will be kept.

Notes for Unix:
- The file protection for the viminfo file will be set to prevent other users
  from being able to read it, because it may contain any text or commands that
  you have worked with.
- If you want to share the viminfo file with other users (e.g. when you "su"
  to another user), you can make the file writable for the group or everybody.
  Vim will preserve this when replacing the viminfo file.  Be careful, don't
  allow just anybody to read and write your viminfo file!
- Vim will not overwrite a viminfo file that is not writable by the current
  "real" user.  This helps for when you did "su" to become root, but your
  $HOME is still set to a normal user's home directory.  Otherwise Vim would
  create a viminfo file owned by root that nobody else can read.
- The viminfo file cannot be a symbolic link.  This is to avoid security
  issues.

Marks are stored for each file separately.  When a file is read and 'viminfo'
is non-empty, the marks for that file are read from the viminfo file.  NOTE:
The marks are only written when exiting Vim, which is fine because marks are
remembered for all the files you have opened in the current editing session,
unless ":bdel" is used.  If you want to save the marks for a file that you are
about to abandon with ":bdel", use ":wv".  The '[' and ']' marks are not
stored, but the '"' mark is.  The '"' mark is very useful for jumping to the
cursor position when the file was last exited.  No marks are saved for files
that start with any string given with the "r" flag in 'viminfo'.  This can be
used to avoid saving marks for files on removable media (for MS-Windows you
would use "ra:,rb:", for Amiga "rdf0:,rdf1:,rdf2:").
The |v:oldfiles| variable is filled with the file names that the viminfo file
has marks for.

							*viminfo-file-marks*
Uppercase marks ('A to 'Z) are stored when writing the viminfo file.  The
numbered marks ('0 to '9) are a bit special.  When the viminfo file is written
(when exiting or with the ":wviminfo" command), '0 is set to the current cursor
position and file.  The old '0 is moved to '1, '1 to '2, etc.  This
resembles what happens with the "1 to "9 delete registers.  If the current
cursor position is already present in '0 to '9, it is moved to '0, to avoid
having the same position twice.  The result is that with "'0", you can jump
back to the file and line where you exited Vim.  To do that right away, try
using this command: >

	vim -c "normal '0"

In a csh compatible shell you could make an alias for it: >

	alias lvim vim -c '"'normal "'"0'"'

For a bash-like shell: >

	alias lvim='vim -c "normal '\''0"'

Use the "r" flag in 'viminfo' to specify for which files no marks should be
remembered.


VIMINFO FILE NAME					*viminfo-file-name*

- The default name of the viminfo file is "$HOME/.viminfo" for Unix,
  "s:.viminfo" for Amiga, "$HOME\_viminfo" for Win32.  For Win32, when $HOME
  is not set, "$VIM\_viminfo" is used.  When $VIM is also not set,
  "c:\_viminfo" is used.
- The 'n' flag in the 'viminfo' option can be used to specify another viminfo
  file name |'viminfo'|.
- The "-i" Vim argument can be used to set another file name, |-i|.  When the
  file name given is "NONE" (all uppercase), no viminfo file is ever read or
  written.  Also not for the commands below!
- The 'viminfofile' option can be used like the "-i" argument.  In fact, the
  value from the "-i" argument is stored in the 'viminfofile' option.
- For the commands below, another file name can be given, overriding the
  default and the name given with 'viminfo' or "-i" (unless it's NONE).


CHARACTER ENCODING					*viminfo-encoding*

The text in the viminfo file is encoded as specified with the 'encoding'
option.  Normally you will always work with the same 'encoding' value, and
this works just fine.  However, if you read the viminfo file with another
value for 'encoding' than what it was written with, some of the text
(non-ASCII characters) may be invalid.  If this is unacceptable, add the 'c'
flag to the 'viminfo' option: >
	:set viminfo+=c
Vim will then attempt to convert the text in the viminfo file from the
'encoding' value it was written with to the current 'encoding' value.  This
requires Vim to be compiled with the |+iconv| feature.  Filenames are not
converted.


MANUALLY READING AND WRITING				*viminfo-read-write*

Two commands can be used to read and write the viminfo file manually.  This
can be used to exchange registers between two running Vim programs: First
type ":wv" in one and then ":rv" in the other.  Note that if the register
already contained something, then ":rv!" would be required.  Also note
however that this means everything will be overwritten with information from
the first Vim, including the command line history, etc.

The viminfo file itself can be edited by hand too, although we suggest you
start with an existing one to get the format right.  It is reasonably
self-explanatory once you're in there.  This can be useful in order to
create a second file, say "~/.my_viminfo" which could contain certain
settings that you always want when you first start Vim.  For example, you
can preload registers with particular data, or put certain commands in the
command line history.  A line in your .vimrc file like >
	:rviminfo! ~/.my_viminfo
can be used to load this information.  You could even have different viminfos
for different types of files (e.g., C code) and load them based on the file
name, using the ":autocmd" command (see |:autocmd|).

							*viminfo-errors*
When Vim detects an error while reading a viminfo file, it will not overwrite
that file.  If there are more than 10 errors, Vim stops reading the viminfo
file.  This was done to avoid accidentally destroying a file when the file
name of the viminfo file is wrong.  This could happen when accidentally typing
"vim -i file" when you wanted "vim -R file" (yes, somebody accidentally did
that!).  If you want to overwrite a viminfo file with an error in it, you will
either have to fix the error, or delete the file (while Vim is running, so
most of the information will be restored).

						   *:rv* *:rviminfo* *E195*
:rv[iminfo][!] [file]	Read from viminfo file [file] (default: see
			|viminfo-file-name| above).
			If [!] is given, then any information that is
			already set (registers, marks, |v:oldfiles|, etc.)
			will be overwritten

			*:wv* *:wviminfo* *E137* *E138* *E574* *E886* *E929*
:wv[iminfo][!] [file]	Write to viminfo file [file] (default: see
			|viminfo-file-name| above).
			This command has no effect when 'viminfofile' has been
			set to "NONE".
			The information in the file is first read in to make
			a merge between old and new info.  When [!] is used,
			the old information is not read first, only the
			internal info is written.  If 'viminfo' is empty, marks
			for up to 100 files will be written.
			When you get error "E929: Too many viminfo temp files"
			check that no old temp files were left behind (e.g.
			~/.viminf*) and that you can write in the directory of
			the .viminfo file.

						*:ol* *:oldfiles*
:ol[dfiles]		List the files that have marks stored in the viminfo
			file.  This list is read on startup and only changes
			afterwards with `:rviminfo!`.  Also see |v:oldfiles|.
			The number can be used with |c_#<|.
			The output can be filtered with |:filter|, e.g.: >
				filter /\.vim/ oldfiles
<			The filtering happens on the file name.
			{only when compiled with the |+eval| feature}

:bro[wse] ol[dfiles][!]
			List file names as with |:oldfiles|, and then prompt
			for a number.  When the number is valid that file from
			the list is edited.
			If you get the |press-enter| prompt you can press "q"
			and still get the prompt to enter a file number.
			Use ! to abandon a modified buffer. |abandon|
			{not when compiled with tiny or small features}

 vim:tw=78:ts=8:noet:ft=help:norl:
                                                                                                                                                                                                                                                                                    usr/share/vim/vim90/doc/syntax.txt                                                                  0000644 0000000 0000000 00000715532 14424703754 015601  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        *syntax.txt*	For Vim version 9.0.  Last change: 2023 Feb 26


		  VIM REFERENCE MANUAL	  by Bram Moolenaar


Syntax highlighting		*syntax* *syntax-highlighting* *coloring*

Syntax highlighting enables Vim to show parts of the text in another font or
color.	Those parts can be specific keywords or text matching a pattern.  Vim
doesn't parse the whole file (to keep it fast), so the highlighting has its
limitations.  Lexical highlighting might be a better name, but since everybody
calls it syntax highlighting we'll stick with that.

Vim supports syntax highlighting on all terminals.  But since most ordinary
terminals have very limited highlighting possibilities, it works best in the
GUI version, gvim.

In the User Manual:
|usr_06.txt| introduces syntax highlighting.
|usr_44.txt| introduces writing a syntax file.

1.  Quick start			|:syn-qstart|
2.  Syntax files		|:syn-files|
3.  Syntax loading procedure	|syntax-loading|
4.  Converting to HTML		|2html.vim|
5.  Syntax file remarks		|:syn-file-remarks|
6.  Defining a syntax		|:syn-define|
7.  :syntax arguments		|:syn-arguments|
8.  Syntax patterns		|:syn-pattern|
9.  Syntax clusters		|:syn-cluster|
10. Including syntax files	|:syn-include|
11. Synchronizing		|:syn-sync|
12. Listing syntax items	|:syntax|
13. Colorschemes		|color-schemes|
14. Highlight command		|:highlight|
15. Linking groups		|:highlight-link|
16. Cleaning up			|:syn-clear|
17. Highlighting tags		|tag-highlight|
18. Window-local syntax		|:ownsyntax|
19. Color xterms		|xterm-color|
20. When syntax is slow		|:syntime|

{Vi does not have any of these commands}

Syntax highlighting is not available when the |+syntax| feature has been
disabled at compile time.

==============================================================================
1. Quick start						*:syn-qstart*

						*:syn-enable* *:syntax-enable*
This command switches on syntax highlighting: >

	:syntax enable

What this command actually does is to execute the command >
	:source $VIMRUNTIME/syntax/syntax.vim

If the VIM environment variable is not set, Vim will try to find
the path in another way (see |$VIMRUNTIME|).  Usually this works just
fine.  If it doesn't, try setting the VIM environment variable to the
directory where the Vim stuff is located.  For example, if your syntax files
are in the "/usr/vim/vim82/syntax" directory, set $VIMRUNTIME to
"/usr/vim/vim82".  You must do this in the shell, before starting Vim.
This command also sources the |menu.vim| script when the GUI is running or
will start soon.  See |'go-M'| about avoiding that.

							*:syn-on* *:syntax-on*
The `:syntax enable` command will keep most of your current color settings.
This allows using `:highlight` commands to set your preferred colors before or
after using this command.  If you want Vim to overrule your settings with the
defaults, use: >
	:syntax on
<
					*:hi-normal* *:highlight-normal*
If you are running in the GUI, you can get white text on a black background
with: >
	:highlight Normal guibg=Black guifg=White
For a color terminal see |:hi-normal-cterm|.
For setting up your own colors syntax highlighting see |syncolor|.

NOTE: The syntax files on MS-Windows have lines that end in <CR><NL>.
The files for Unix end in <NL>.  This means you should use the right type of
file for your system.  Although on MS-Windows the right format is
automatically selected if the 'fileformats' option is not empty.

NOTE: When using reverse video ("gvim -fg white -bg black"), the default value
of 'background' will not be set until the GUI window is opened, which is after
reading the |gvimrc|.  This will cause the wrong default highlighting to be
used.  To set the default value of 'background' before switching on
highlighting, include the ":gui" command in the |gvimrc|: >

   :gui		" open window and set default for 'background'
   :syntax on	" start highlighting, use 'background' to set colors

NOTE: Using ":gui" in the |gvimrc| means that "gvim -f" won't start in the
foreground!  Use ":gui -f" then.

							*g:syntax_on*
You can toggle the syntax on/off with this command: >
   :if exists("g:syntax_on") | syntax off | else | syntax enable | endif

To put this into a mapping, you can use: >
   :map <F7> :if exists("g:syntax_on") <Bar>
	\   syntax off <Bar>
	\ else <Bar>
	\   syntax enable <Bar>
	\ endif <CR>
[using the |<>| notation, type this literally]

Details:
The ":syntax" commands are implemented by sourcing a file.  To see exactly how
this works, look in the file:
    command		file ~
    :syntax enable	$VIMRUNTIME/syntax/syntax.vim
    :syntax on		$VIMRUNTIME/syntax/syntax.vim
    :syntax manual	$VIMRUNTIME/syntax/manual.vim
    :syntax off		$VIMRUNTIME/syntax/nosyntax.vim
Also see |syntax-loading|.

NOTE: If displaying long lines is slow and switching off syntax highlighting
makes it fast, consider setting the 'synmaxcol' option to a lower value.

==============================================================================
2. Syntax files						*:syn-files*

The syntax and highlighting commands for one language are normally stored in
a syntax file.	The name convention is: "{name}.vim".  Where {name} is the
name of the language, or an abbreviation (to fit the name in 8.3 characters,
a requirement in case the file is used on a DOS filesystem).
Examples:
	c.vim		perl.vim	java.vim	html.vim
	cpp.vim		sh.vim		csh.vim

The syntax file can contain any Ex commands, just like a vimrc file.  But
the idea is that only commands for a specific language are included.  When a
language is a superset of another language, it may include the other one,
for example, the cpp.vim file could include the c.vim file: >
   :so $VIMRUNTIME/syntax/c.vim

The .vim files are normally loaded with an autocommand.  For example: >
   :au Syntax c	    runtime! syntax/c.vim
   :au Syntax cpp   runtime! syntax/cpp.vim
These commands are normally in the file $VIMRUNTIME/syntax/synload.vim.


MAKING YOUR OWN SYNTAX FILES				*mysyntaxfile*

When you create your own syntax files, and you want to have Vim use these
automatically with ":syntax enable", do this:

1. Create your user runtime directory.	You would normally use the first item
   of the 'runtimepath' option.  Example for Unix: >
	mkdir ~/.vim

2. Create a directory in there called "syntax".  For Unix: >
	mkdir ~/.vim/syntax

3. Write the Vim syntax file.  Or download one from the internet.  Then write
   it in your syntax directory.  For example, for the "mine" syntax: >
	:w ~/.vim/syntax/mine.vim

Now you can start using your syntax file manually: >
	:set syntax=mine
You don't have to exit Vim to use this.

If you also want Vim to detect the type of file, see |new-filetype|.

If you are setting up a system with many users and you don't want each user
to add the same syntax file, you can use another directory from 'runtimepath'.


ADDING TO AN EXISTING SYNTAX FILE		*mysyntaxfile-add*

If you are mostly satisfied with an existing syntax file, but would like to
add a few items or change the highlighting, follow these steps:

1. Create your user directory from 'runtimepath', see above.

2. Create a directory in there called "after/syntax".  For Unix: >
	mkdir ~/.vim/after
	mkdir ~/.vim/after/syntax

3. Write a Vim script that contains the commands you want to use.  For
   example, to change the colors for the C syntax: >
	highlight cComment ctermfg=Green guifg=Green

4. Write that file in the "after/syntax" directory.  Use the name of the
   syntax, with ".vim" added.  For our C syntax: >
	:w ~/.vim/after/syntax/c.vim

That's it.  The next time you edit a C file the Comment color will be
different.  You don't even have to restart Vim.

If you have multiple files, you can use the filetype as the directory name.
All the "*.vim" files in this directory will be used, for example:
	~/.vim/after/syntax/c/one.vim
	~/.vim/after/syntax/c/two.vim


REPLACING AN EXISTING SYNTAX FILE			*mysyntaxfile-replace*

If you don't like a distributed syntax file, or you have downloaded a new
version, follow the same steps as for |mysyntaxfile| above.  Just make sure
that you write the syntax file in a directory that is early in 'runtimepath'.
Vim will only load the first syntax file found, assuming that it sets
b:current_syntax.


NAMING CONVENTIONS		    *group-name* *{group-name}* *E669* *W18*

A syntax group name is to be used for syntax items that match the same kind of
thing.  These are then linked to a highlight group that specifies the color.
A syntax group name doesn't specify any color or attributes itself.

The name for a highlight or syntax group must consist of ASCII letters, digits
and the underscore.  As a regexp: "[a-zA-Z0-9_]*".  However, Vim does not give
an error when using other characters.  The maximum length of a group name is
about 200 bytes.  *E1249*

To be able to allow each user to pick their favorite set of colors, there must
be preferred names for highlight groups that are common for many languages.
These are the suggested group names (if syntax highlighting works properly
you can see the actual color, except for "Ignore"):

	*Comment	any comment

	*Constant	any constant
	 String		a string constant: "this is a string"
	 Character	a character constant: 'c', '\n'
	 Number		a number constant: 234, 0xff
	 Boolean	a boolean constant: TRUE, false
	 Float		a floating point constant: 2.3e10

	*Identifier	any variable name
	 Function	function name (also: methods for classes)

	*Statement	any statement
	 Conditional	if, then, else, endif, switch, etc.
	 Repeat		for, do, while, etc.
	 Label		case, default, etc.
	 Operator	"sizeof", "+", "*", etc.
	 Keyword	any other keyword
	 Exception	try, catch, throw

	*PreProc	generic Preprocessor
	 Include	preprocessor #include
	 Define		preprocessor #define
	 Macro		same as Define
	 PreCondit	preprocessor #if, #else, #endif, etc.

	*Type		int, long, char, etc.
	 StorageClass	static, register, volatile, etc.
	 Structure	struct, union, enum, etc.
	 Typedef	A typedef

	*Special	any special symbol
	 SpecialChar	special character in a constant
	 Tag		you can use CTRL-] on this
	 Delimiter	character that needs attention
	 SpecialComment	special things inside a comment
	 Debug		debugging statements

	*Underlined	text that stands out, HTML links

	*Ignore		left blank, hidden  |hl-Ignore|

	*Error		any erroneous construct

	*Todo		anything that needs extra attention; mostly the
			keywords TODO FIXME and XXX

The names marked with * are the preferred groups; the others are minor groups.
For the preferred groups, the "syntax.vim" file contains default highlighting.
The minor groups are linked to the preferred groups, so they get the same
highlighting.  You can override these defaults by using ":highlight" commands
after sourcing the "syntax.vim" file.

Note that highlight group names are not case sensitive.  "String" and "string"
can be used for the same group.

The following names are reserved and cannot be used as a group name:
	NONE   ALL   ALLBUT   contains	 contained

							*hl-Ignore*
When using the Ignore group, you may also consider using the conceal
mechanism.  See |conceal|.

==============================================================================
3. Syntax loading procedure				*syntax-loading*

This explains the details that happen when the command ":syntax enable" is
issued.  When Vim initializes itself, it finds out where the runtime files are
located.  This is used here as the variable |$VIMRUNTIME|.

":syntax enable" and ":syntax on" do the following:

    Source $VIMRUNTIME/syntax/syntax.vim
    |
    +-	Clear out any old syntax by sourcing $VIMRUNTIME/syntax/nosyntax.vim
    |
    +-	Source first syntax/synload.vim in 'runtimepath'
    |	|
    |	+-  Setup the colors for syntax highlighting.  If a color scheme is
    |	|   defined it is loaded again with ":colors {name}".  Otherwise
    |	|   ":runtime! syntax/syncolor.vim" is used.  ":syntax on" overrules
    |	|   existing colors, ":syntax enable" only sets groups that weren't
    |	|   set yet.
    |	|
    |	+-  Set up syntax autocmds to load the appropriate syntax file when
    |	|   the 'syntax' option is set. *synload-1*
    |	|
    |	+-  Source the user's optional file, from the |mysyntaxfile| variable.
    |	    This is for backwards compatibility with Vim 5.x only. *synload-2*
    |
    +-	Do ":filetype on", which does ":runtime! filetype.vim".  It loads any
    |	filetype.vim files found.  It should always Source
    |	$VIMRUNTIME/filetype.vim, which does the following.
    |	|
    |	+-  Install autocmds based on suffix to set the 'filetype' option
    |	|   This is where the connection between file name and file type is
    |	|   made for known file types. *synload-3*
    |	|
    |	+-  Source the user's optional file, from the *myfiletypefile*
    |	|   variable.  This is for backwards compatibility with Vim 5.x only.
    |	|   *synload-4*
    |	|
    |	+-  Install one autocommand which sources scripts.vim when no file
    |	|   type was detected yet. *synload-5*
    |	|
    |	+-  Source $VIMRUNTIME/menu.vim, to setup the Syntax menu. |menu.vim|
    |
    +-	Install a FileType autocommand to set the 'syntax' option when a file
    |	type has been detected. *synload-6*
    |
    +-	Execute syntax autocommands to start syntax highlighting for each
	already loaded buffer.


Upon loading a file, Vim finds the relevant syntax file as follows:

    Loading the file triggers the BufReadPost autocommands.
    |
    +-	If there is a match with one of the autocommands from |synload-3|
    |	(known file types) or |synload-4| (user's file types), the 'filetype'
    |	option is set to the file type.
    |
    +-	The autocommand at |synload-5| is triggered.  If the file type was not
    |	found yet, then scripts.vim is searched for in 'runtimepath'.  This
    |	should always load $VIMRUNTIME/scripts.vim, which does the following.
    |	|
    |	+-  Source the user's optional file, from the *myscriptsfile*
    |	|   variable.  This is for backwards compatibility with Vim 5.x only.
    |	|
    |	+-  If the file type is still unknown, check the contents of the file,
    |	    again with checks like "getline(1) =~ pattern" as to whether the
    |	    file type can be recognized, and set 'filetype'.
    |
    +-	When the file type was determined and 'filetype' was set, this
    |	triggers the FileType autocommand |synload-6| above.  It sets
    |	'syntax' to the determined file type.
    |
    +-	When the 'syntax' option was set above, this triggers an autocommand
    |	from |synload-1| (and |synload-2|).  This find the main syntax file in
    |	'runtimepath', with this command:
    |		runtime! syntax/<name>.vim
    |
    +-	Any other user installed FileType or Syntax autocommands are
	triggered.  This can be used to change the highlighting for a specific
	syntax.

==============================================================================
4. Conversion to HTML				*2html.vim* *convert-to-HTML*

2html is not a syntax file itself, but a script that converts the current
window into HTML. Vim opens a new window in which it builds the HTML file.

After you save the resulting file, you can view it with any browser. The
colors should be exactly the same as you see them in Vim.  With
|g:html_line_ids| you can jump to specific lines by adding (for example) #L123
or #123 to the end of the URL in your browser's address bar. And with
|g:html_dynamic_folds| enabled, you can show or hide the text that is folded
in Vim.

You are not supposed to set the 'filetype' or 'syntax' option to "2html"!
Source the script to convert the current file: >

	:runtime! syntax/2html.vim
<
Many variables affect the output of 2html.vim; see below. Any of the on/off
options listed below can be enabled or disabled by setting them explicitly to
the desired value, or restored to their default by removing the variable using
|:unlet|.

Remarks:
- Some truly ancient browsers may not show the background colors.
- From most browsers you can also print the file (in color)!
- The latest TOhtml may actually work with older versions of Vim, but some
  features such as conceal support will not function, and the colors may be
  incorrect for an old Vim without GUI support compiled in.

Here is an example how to run the script over all .c and .h files from a
Unix shell: >
   for f in *.[ch]; do gvim -f +"syn on" +"run! syntax/2html.vim" +"wq" +"q" $f; done
<
					*g:html_start_line* *g:html_end_line*
To restrict the conversion to a range of lines, use a range with the |:TOhtml|
command below, or set "g:html_start_line" and "g:html_end_line" to the first
and last line to be converted.  Example, using the last set Visual area: >

	:let g:html_start_line = line("'<")
	:let g:html_end_line = line("'>")
	:runtime! syntax/2html.vim
<
							*:TOhtml*
:[range]TOhtml		The ":TOhtml" command is defined in a standard plugin.
			This command will source |2html.vim| for you. When a
			range is given, this command sets |g:html_start_line|
			and |g:html_end_line| to the start and end of the
			range, respectively. Default range is the entire
			buffer.

			If the current window is part of a |diff|, unless
			|g:html_diff_one_file| is set, :TOhtml will convert
			all windows which are part of the diff in the current
			tab and place them side-by-side in a <table> element
			in the generated HTML. With |g:html_line_ids| you can
			jump to lines in specific windows with (for example)
			#W1L42 for line 42 in the first diffed window, or
			#W3L87 for line 87 in the third.

			Examples: >

	:10,40TOhtml " convert lines 10-40 to html
	:'<,'>TOhtml " convert current/last visual selection
	:TOhtml      " convert entire buffer
<
							*g:html_diff_one_file*
Default: 0.
When 0, and using |:TOhtml| all windows involved in a |diff| in the current tab
page are converted to HTML and placed side-by-side in a <table> element. When
1, only the current buffer is converted.
Example: >

	let g:html_diff_one_file = 1
<
							 *g:html_whole_filler*
Default: 0.
When 0, if |g:html_diff_one_file| is 1, a sequence of more than 3 filler lines
is displayed as three lines with the middle line mentioning the total number
of inserted lines.
When 1, always display all inserted lines as if |g:html_diff_one_file| were
not set.
>
    :let g:html_whole_filler = 1
<
				     *TOhtml-performance* *g:html_no_progress*
Default: 0.
When 0, display a progress bar in the statusline for each major step in the
2html.vim conversion process.
When 1, do not display the progress bar. This offers a minor speed improvement
but you won't have any idea how much longer the conversion might take; for big
files it can take a long time!
Example: >

	let g:html_no_progress = 1
<
You can obtain better performance improvements by also instructing Vim to not
run interactively, so that too much time is not taken to redraw as the script
moves through the buffer, switches windows, and the like: >

  vim -E -s -c "let g:html_no_progress=1" -c "syntax on" -c "set ft=c" -c "runtime syntax/2html.vim" -cwqa myfile.c
<
Note that the -s flag prevents loading your .vimrc and any plugins, so you
need to explicitly source/enable anything that will affect the HTML
conversion. See |-E| and |-s-ex| for details. It is probably best to create a
script to replace all the -c commands and use it with the -u flag instead of
specifying each command separately.

				    *hl-TOhtmlProgress* *TOhtml-progress-color*
When displayed, the progress bar will show colored boxes along the statusline
as the HTML conversion proceeds. By default, the background color as the
current "DiffDelete" highlight group is used. If "DiffDelete" and "StatusLine"
have the same background color, TOhtml will automatically adjust the color to
differ. If you do not like the automatically selected colors, you can define
your own highlight colors for the progress bar. Example: >

	hi TOhtmlProgress guifg=#c0ffee ctermbg=7
<
							 *g:html_number_lines*
Default: Current 'number' setting.
When 0, buffer text is displayed in the generated HTML without line numbering.
When 1, a column of line numbers is added to the generated HTML with the same
highlighting as the line number column in Vim (|hl-LineNr|).
Force line numbers even if 'number' is not set: >
   :let g:html_number_lines = 1
Force to omit the line numbers: >
   :let g:html_number_lines = 0
Go back to the default to use 'number' by deleting the variable: >
   :unlet g:html_number_lines
<
							*g:html_line_ids*
Default: 1 if |g:html_number_lines| is set, 0 otherwise.
When 1, adds an HTML id attribute to each line number, or to an empty <span>
inserted for that purpose if no line numbers are shown. This ID attribute
takes the form of L123 for single-buffer HTML pages, or W2L123 for diff-view
pages, and is used to jump to a specific line (in a specific window of a diff
view). Javascript is inserted to open any closed dynamic folds
(|g:html_dynamic_folds|) containing the specified line before jumping. The
javascript also allows omitting the window ID in the url, and the leading L.
For example: >

	page.html#L123	jumps to line 123 in a single-buffer file
	page.html#123	does the same

	diff.html#W1L42	jumps to line 42 in the first window in a diff
	diff.html#42	does the same
<
							      *g:html_use_css*
Default: 1.
When 1, generate valid HTML 5 markup with CSS styling, supported in all modern
browsers and many old browsers.
When 0, generate <font> tags and similar outdated markup. This is not
recommended but it may work better in really old browsers, email clients,
forum posts, and similar situations where basic CSS support is unavailable.
Example: >
   :let g:html_use_css = 0
<
						       *g:html_ignore_conceal*
Default: 0.
When 0, concealed text is removed from the HTML and replaced with a character
from |:syn-cchar| or 'listchars' as appropriate, depending on the current
value of 'conceallevel'.
When 1, include all text from the buffer in the generated HTML, even if it is
|conceal|ed.

Either of the following commands will ensure that all text in the buffer is
included in the generated HTML (unless it is folded): >
   :let g:html_ignore_conceal = 1
   :setl conceallevel=0
<
						       *g:html_ignore_folding*
Default: 0.
When 0, text in a closed fold is replaced by the text shown for the fold in
Vim (|fold-foldtext|). See |g:html_dynamic_folds| if you also want to allow
the user to expand the fold as in Vim to see the text inside.
When 1, include all text from the buffer in the generated HTML; whether the
text is in a fold has no impact at all. |g:html_dynamic_folds| has no effect.

Either of these commands will ensure that all text in the buffer is included
in the generated HTML (unless it is concealed): >
   zR
   :let g:html_ignore_folding = 1
<
							*g:html_dynamic_folds*
Default: 0.
When 0, text in a closed fold is not included at all in the generated HTML.
When 1, generate javascript to open a fold and show the text within, just like
in Vim.

Setting this variable to 1 causes 2html.vim to always use CSS for styling,
regardless of what |g:html_use_css| is set to.

This variable is ignored when |g:html_ignore_folding| is set.
>
   :let g:html_dynamic_folds = 1
<
							*g:html_no_foldcolumn*
Default: 0.
When 0, if |g:html_dynamic_folds| is 1, generate a column of text similar to
Vim's foldcolumn (|fold-foldcolumn|) the user can click on to toggle folds
open or closed. The minimum width of the generated text column is the current
'foldcolumn' setting.
When 1, do not generate this column; instead, hovering the mouse cursor over
folded text will open the fold as if |g:html_hover_unfold| were set.
>
   :let g:html_no_foldcolumn = 1
<
				*TOhtml-uncopyable-text* *g:html_prevent_copy*
Default: Empty string.
This option prevents certain regions of the generated HTML from being copied,
when you select all text in document rendered in a browser and copy it. Useful
for allowing users to copy-paste only the source text even if a fold column or
line numbers are shown in the generated content. Specify regions to be
affected in this way as follows:
	f:	fold column
	n:	line numbers (also within fold text)
	t:	fold text
	d:	diff filler

Example, to make the fold column and line numbers uncopyable: >
	:let g:html_prevent_copy = "fn"
<
The method used to prevent copying in the generated page depends on the value
of |g:html_use_input_for_pc|.

						    *g:html_use_input_for_pc*
Default: "fallback"
If |g:html_prevent_copy| is non-empty, then:

When "all", read-only <input> elements are used in place of normal text for
uncopyable regions. In some browsers, especially older browsers, after
selecting an entire page and copying the selection, the <input> tags are not
pasted with the page text. If |g:html_no_invalid| is 0, the <input> tags have
invalid type; this works in more browsers, but the page will not validate.
Note: This method does NOT work in recent versions of Chrome and equivalent
browsers; the <input> tags get pasted with the text.

When "fallback" (default value), the same <input> elements are generated for
older browsers, but newer browsers (detected by CSS feature query) hide the
<input> elements and instead use generated content in an ::before pseudoelement
to display the uncopyable text. This method should work with the largest
number of browsers, both old and new.

When "none", the <input> elements are not generated at all. Only the
generated-content method is used. This means that old browsers, notably
Internet Explorer, will either copy the text intended not to be copyable, or
the non-copyable text may not appear at all. However, this is the most
standards-based method, and there will be much less markup.

							   *g:html_no_invalid*
Default: 0.
When 0, if |g:html_prevent_copy| is non-empty and |g:html_use_input_for_pc| is
not "none", an invalid attribute is intentionally inserted into the <input>
element for the uncopyable areas. This prevents pasting the <input> elements
in some applications. Specifically, some versions of Microsoft Word will not
paste the <input> elements if they contain this invalid attribute. When 1, no
invalid markup is inserted, and the generated page should validate. However,
<input> elements may be pasted into some applications and can be difficult to
remove afterward.

							 *g:html_hover_unfold*
Default: 0.
When 0, the only way to open a fold generated by 2html.vim with
|g:html_dynamic_folds| set, is to click on the generated fold column.
When 1, use CSS 2.0 to allow the user to open a fold by moving the mouse
cursor over the displayed fold text. This is useful to allow users with
disabled javascript to view the folded text.

Note that old browsers (notably Internet Explorer 6) will not support this
feature.  Browser-specific markup for IE6 is included to fall back to the
normal CSS1 styling so that the folds show up correctly for this browser, but
they will not be openable without a foldcolumn.
>
   :let g:html_hover_unfold = 1
<
							      *g:html_id_expr*
Default: ""
Dynamic folding and jumping to line IDs rely on unique IDs within the document
to work. If generated HTML is copied into a larger document, these IDs are no
longer guaranteed to be unique. Set g:html_id_expr to an expression Vim can
evaluate to get a unique string to append to each ID used in a given document,
so that the full IDs will be unique even when combined with other content in a
larger HTML document. Example, to append _ and the buffer number to each ID: >

	:let g:html_id_expr = '"_" .. bufnr("%")'
<
To append a string "_mystring" to the end of each ID: >

	:let g:html_id_expr = '"_mystring"'
<
Note: When converting a diff view to HTML, the expression will only be
evaluated for the first window in the diff, and the result used for all the
windows.

					  *TOhtml-wrap-text* *g:html_pre_wrap*
Default: Current 'wrap' setting.
When 0, if |g:html_no_pre| is 0 or unset, the text in the generated HTML does
not wrap at the edge of the browser window.
