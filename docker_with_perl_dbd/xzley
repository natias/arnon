
This symbol contains the C<sizeof(U32)>.

=back

=for hackers
Found in file config.h

=over 4

=item C<U64SIZE>
X<U64SIZE>

This symbol contains the C<sizeof(U64)>.

=back

=for hackers
Found in file config.h

=over 4

=item C<U8TYPE>
X<U8TYPE>

This symbol defines the C type used for Perl's U8.

=back

=for hackers
Found in file config.h

=over 4

=item C<U16TYPE>
X<U16TYPE>

This symbol defines the C type used for Perl's U16.

=back

=for hackers
Found in file config.h

=over 4

=item C<U32TYPE>
X<U32TYPE>

This symbol defines the C type used for Perl's U32.

=back

=for hackers
Found in file config.h

=over 4

=item C<U64TYPE>
X<U64TYPE>

This symbol defines the C type used for Perl's U64.

=back

=for hackers
Found in file config.h

=over 4

=item C<U32uf>
X<U32uf>

This symbol defines the format string used for printing a Perl U32
as an unsigned decimal integer.

=back

=for hackers
Found in file config.h

=over 4

=item C<UV>

=item C<U8>

=item C<U16>

=item C<U32>

=item C<U64>

Described in L<perlguts>.

=back

=for hackers
Found in file pod/perlguts.pod

=over 4

=item C<UV_MAX>
X<UV_MAX>

The largest unsigned integer that fits in a UV on this platform.

=over 3

 UV  UV_MAX

=back

=back

=for hackers
Found in file perl.h

=over 4

=item C<UV_MIN>
X<UV_MIN>

The smallest unsigned integer that fits in a UV on this platform.  It should
equal zero.

=over 3

 UV  UV_MIN

=back

=back

=for hackers
Found in file perl.h

=over 4

=item C<UVSIZE>
X<UVSIZE>

This symbol contains the C<sizeof(UV)>.

=back

=for hackers
Found in file config.h

=over 4

=item C<UVTYPE>
X<UVTYPE>

This symbol defines the C type used for Perl's UV.

=back

=for hackers
Found in file config.h

=over 4

=item C<U32Xf>
X<U32Xf>

This symbol defines the format string used for printing a Perl U32
as an unsigned hexadecimal integer in uppercase C<ABCDEF>.

=back

=for hackers
Found in file config.h

=over 4

=item C<U32xf>
X<U32xf>

This symbol defines the format string used for printing a Perl U32
as an unsigned hexadecimal integer in lowercase abcdef.

=back

=for hackers
Found in file config.h

=over 4

=item C<WIDEST_UTYPE>
X<WIDEST_UTYPE>

Yields the widest unsigned integer type on the platform, currently either
C<U32> or C<U64>.  This can be used in declarations such as

 WIDEST_UTYPE my_uv;

or casts

 my_uv = (WIDEST_UTYPE) val;

=back

=for hackers
Found in file handy.h

=head1 I/O Formats

These are used for formatting the corresponding type For example,
instead of saying

 Perl_newSVpvf(pTHX_ "Create an SV with a %d in it\n", iv);

use

 Perl_newSVpvf(pTHX_ "Create an SV with a " IVdf " in it\n", iv);

This keeps you from having to know if, say an IV, needs to be
printed as C<%d>, C<%ld>, or something else.


=over 4

=item C<HvNAMEf>

Described in L<perlguts>.

=back

=for hackers
Found in file pod/perlguts.pod

=over 4

=item C<HvNAMEf_QUOTEDPREFIX>

Described in L<perlguts>.

=back

=for hackers
Found in file pod/perlguts.pod

=over 4

=item C<IVdf>
X<IVdf>

This symbol defines the format string used for printing a Perl IV
as a signed decimal integer.

=back

=for hackers
Found in file config.h

=over 4

=item C<NVef>
X<NVef>

This symbol defines the format string used for printing a Perl NV
using %e-ish floating point format.

=back

=for hackers
Found in file config.h

=over 4

=item C<NVff>
X<NVff>

This symbol defines the format string used for printing a Perl NV
using %f-ish floating point format.

=back

=for hackers
Found in file config.h

=over 4

=item C<NVgf>
X<NVgf>

This symbol defines the format string used for printing a Perl NV
using %g-ish floating point format.

=back

=for hackers
Found in file config.h

=over 4

=item C<PERL_PRIeldbl>
X<PERL_PRIeldbl>

This symbol, if defined, contains the string used by stdio to
format long doubles (format 'e') for output.

=back

=for hackers
Found in file config.h

=over 4

=item C<PERL_PRIfldbl>
X<PERL_PRIfldbl>

This symbol, if defined, contains the string used by stdio to
format long doubles (format 'f') for output.

=back

=for hackers
Found in file config.h

=over 4

=item C<PERL_PRIgldbl>
X<PERL_PRIgldbl>

This symbol, if defined, contains the string used by stdio to
format long doubles (format 'g') for output.

=back

=for hackers
Found in file config.h

=over 4

=item C<PERL_SCNfldbl>
X<PERL_SCNfldbl>

This symbol, if defined, contains the string used by stdio to
format long doubles (format 'f') for input.

=back

=for hackers
Found in file config.h

=over 4

=item C<PRINTF_FORMAT_NULL_OK>
X<PRINTF_FORMAT_NULL_OK>

Allows C<__printf__> format to be null when checking printf-style

=back

=for hackers
Found in file config.h

=over 4

=item C<SVf>

Described in L<perlguts>.

=back

=for hackers
Found in file pod/perlguts.pod

=over 4

=item C<SVfARG>

Described in L<perlguts>.

=over 3

   SVfARG(SV *sv)

=back

=back

=for hackers
Found in file pod/perlguts.pod

=over 4

=item C<SVf_QUOTEDPREFIX>

Described in L<perlguts>.

=back

=for hackers
Found in file pod/perlguts.pod

=over 4

=item C<UTF8f>

Described in L<perlguts>.

=back

=for hackers
Found in file pod/perlguts.pod

=over 4

=item C<UTF8fARG>

Described in L<perlguts>.

=over 3

   UTF8fARG(bool is_utf8, Size_t byte_len, char *str)

=back

=back

=for hackers
Found in file pod/perlguts.pod

=over 4

=item C<UTF8f_QUOTEDPREFIX>

Described in L<perlguts>.

=back

=for hackers
Found in file pod/perlguts.pod

=over 4

=item C<UVf>
X<UVf>

C<B<DEPRECATED!>>  It is planned to remove C<UVf>
from a future release of Perl.  Do not use it for
new code; remove it from existing code.

Obsolete form of C<UVuf>, which you should convert to instead use

=over 3

 const char *  UVf

=back

=back

=for hackers
Found in file perl.h

=over 4

=item C<UVof>
X<UVof>

This symbol defines the format string used for printing a Perl UV
as an unsigned octal integer.

=back

=for hackers
Found in file config.h

=over 4

=item C<UVuf>
X<UVuf>

This symbol defines the format string used for printing a Perl UV
as an unsigned decimal integer.

=back

=for hackers
Found in file config.h

=over 4

=item C<UVXf>
X<UVXf>

This symbol defines the format string used for printing a Perl UV
as an unsigned hexadecimal integer in uppercase C<ABCDEF>.

=back

=for hackers
Found in file config.h

=over 4

=item C<UVxf>
X<UVxf>

This symbol defines the format string used for printing a Perl UV
as an unsigned hexadecimal integer in lowercase abcdef.

=back

=for hackers
Found in file config.h

=head1 Lexer interface
X<LEX_KEEP_PREVIOUS>X<LEX_STUFF_UTF8>X<PARSE_OPTIONAL>


This is the lower layer of the Perl parser, managing characters and tokens.


=over 4

=item C<BHK>

Described in L<perlguts>.

=back

=for hackers
Found in file pod/perlguts.pod

=over 4

=item C<lex_bufutf8>
X<lex_bufutf8>

NOTE: C<lex_bufutf8> is B<experimental> and may change or be
removed without notice.

Indicates whether the octets in the lexer buffer
(L</PL_parser-E<gt>linestr>) should be interpreted as the UTF-8 encoding
of Unicode characters.  If not, they should be interpreted as Latin-1
characters.  This is analogous to the C<SvUTF8> flag for scalars.

In UTF-8 mode, it is not guaranteed that the lexer buffer actually
contains valid UTF-8.  Lexing code must be robust in the face of invalid
encoding.

The actual C<SvUTF8> flag of the L</PL_parser-E<gt>linestr> scalar
is significant, but not the whole story regarding the input character
encoding.  Normally, when a file is being read, the scalar contains octets
and its C<SvUTF8> flag is off, but the octets should be interpreted as
UTF-8 if the C<use utf8> pragma is in effect.  During a string eval,
however, the scalar may have the C<SvUTF8> flag on, and in this case its
octets should be interpreted as UTF-8 unless the C<use bytes> pragma
is in effect.  This logic may change in the future; use this function
instead of implementing the logic yourself.

=over 3

 bool  lex_bufutf8()

=back

=back

=for hackers
Found in file toke.c

=over 4

=item C<lex_discard_to>
X<lex_discard_to>

NOTE: C<lex_discard_to> is B<experimental> and may change or be
removed without notice.

Discards the first part of the L</PL_parser-E<gt>linestr> buffer,
up to C<ptr>.  The remaining content of the buffer will be moved, and
all pointers into the buffer updated appropriately.  C<ptr> must not
be later in the buffer than the position of L</PL_parser-E<gt>bufptr>:
it is not permitted to discard text that has yet to be lexed.

Normally it is not necessarily to do this directly, because it suffices to
use the implicit discarding behaviour of L</lex_next_chunk> and things
based on it.  However, if a token stretches across multiple lines,
and the lexing code has kept multiple lines of text in the buffer for
that purpose, then after completion of the token it would be wise to
explicitly discard the now-unneeded earlier lines, to avoid future
multi-line tokens growing the buffer without bound.

=over 3

 void  lex_discard_to(char *ptr)

=back

=back

=for hackers
Found in file toke.c

=over 4

=item C<lex_grow_linestr>
X<lex_grow_linestr>

NOTE: C<lex_grow_linestr> is B<experimental> and may change or be
removed without notice.

Reallocates the lexer buffer (L</PL_parser-E<gt>linestr>) to accommodate
at least C<len> octets (including terminating C<NUL>).  Returns a
pointer to the reallocated buffer.  This is necessary before making
any direct modification of the buffer that would increase its length.
L</lex_stuff_pvn> provides a more convenient way to insert text into
the buffer.

Do not use C<SvGROW> or C<sv_grow> directly on C<PL_parser-E<gt>linestr>;
this function updates all of the lexer's variables that point directly
into the buffer.

=over 3

 char *  lex_grow_linestr(STRLEN len)

=back

=back

=for hackers
Found in file toke.c

=over 4

=item C<lex_next_chunk>
X<lex_next_chunk>

NOTE: C<lex_next_chunk> is B<experimental> and may change or be
removed without notice.

Reads in the next chunk of text to be lexed, appending it to
L</PL_parser-E<gt>linestr>.  This should be called when lexing code has
looked to the end of the current chunk and wants to know more.  It is
usual, but not necessary, for lexing to have consumed the entirety of
the current chunk at this time.

If L</PL_parser-E<gt>bufptr> is pointing to the very end of the current
chunk (i.e., the current chunk has been entirely consumed), normally the
current chunk will be discarded at the same time that the new chunk is
read in.  If C<flags> has the C<LEX_KEEP_PREVIOUS> bit set, the current chunk
will not be discarded.  If the current chunk has not been entirely
consumed, then it will not be discarded regardless of the flag.

Returns true if some new text was added to the buffer, or false if the
buffer has reached the end of the input text.

=over 3

 bool  lex_next_chunk(U32 flags)

=back

=back

=for hackers
Found in file toke.c

=over 4

=item C<lex_peek_unichar>
X<lex_peek_unichar>

NOTE: C<lex_peek_unichar> is B<experimental> and may change or be
removed without notice.

Looks ahead one (Unicode) character in the text currently being lexed.
Returns the codepoint (unsigned integer value) of the next character,
or -1 if lexing has reached the end of the input text.  To consume the
peeked character, use L</lex_read_unichar>.

If the next character is in (or extends into) the next chunk of input
text, the next chunk will be read in.  Normally the current chunk will be
discarded at the same time, but if C<flags> has the C<LEX_KEEP_PREVIOUS>
bit set, then the current chunk will not be discarded.

If the input is being interpreted as UTF-8 and a UTF-8 encoding error
is encountered, an exception is generated.

=over 3

 I32  lex_peek_unichar(U32 flags)

=back

=back

=for hackers
Found in file toke.c

=over 4

=item C<lex_read_space>
X<lex_read_space>

NOTE: C<lex_read_space> is B<experimental> and may change or be
removed without notice.

Reads optional spaces, in Perl style, in the text currently being
lexed.  The spaces may include ordinary whitespace characters and
Perl-style comments.  C<#line> directives are processed if encountered.
L</PL_parser-E<gt>bufptr> is moved past the spaces, so that it points
at a non-space character (or the end of the input text).

If spaces extend into the next chunk of input text, the next chunk will
be read in.  Normally the current chunk will be discarded at the same
time, but if C<flags> has the C<LEX_KEEP_PREVIOUS> bit set, then the current
chunk will not be discarded.

=over 3

 void  lex_read_space(U32 flags)

=back

=back

=for hackers
Found in file toke.c

=over 4

=item C<lex_read_to>
X<lex_read_to>

NOTE: C<lex_read_to> is B<experimental> and may change or be
removed without notice.

Consume text in the lexer buffer, from L</PL_parser-E<gt>bufptr> up
to C<ptr>.  This advances L</PL_parser-E<gt>bufptr> to match C<ptr>,
performing the correct bookkeeping whenever a newline character is passed.
This is the normal way to consume lexed text.

Interpretation of the buffer's octets can be abstracted out by
using the slightly higher-level functions L</lex_peek_unichar> and
L</lex_read_unichar>.

=over 3

 void  lex_read_to(char *ptr)

=back

=back

=for hackers
Found in file toke.c

=over 4

=item C<lex_read_unichar>
X<lex_read_unichar>

NOTE: C<lex_read_unichar> is B<experimental> and may change or be
removed without notice.

Reads the next (Unicode) character in the text currently being lexed.
Returns the codepoint (unsigned integer value) of the character read,
and moves L</PL_parser-E<gt>bufptr> past the character, or returns -1
if lexing has reached the end of the input text.  To non-destructively
examine the next character, use L</lex_peek_unichar> instead.

If the next character is in (or extends into) the next chunk of input
text, the next chunk will be read in.  Normally the current chunk will be
discarded at the same time, but if C<flags> has the C<LEX_KEEP_PREVIOUS>
bit set, then the current chunk will not be discarded.

If the input is being interpreted as UTF-8 and a UTF-8 encoding error
is encountered, an exception is generated.

=over 3

 I32  lex_read_unichar(U32 flags)

=back

=back

=for hackers
Found in file toke.c

=over 4

=item C<lex_start>
X<lex_start>

NOTE: C<lex_start> is B<experimental> and may change or be
removed without notice.

Creates and initialises a new lexer/parser state object, supplying
a context in which to lex and parse from a new source of Perl code.
A pointer to the new state object is placed in L</PL_parser>.  An entry
is made on the save stack so that upon unwinding, the new state object
will be destroyed and the former value of L</PL_parser> will be restored.
Nothing else need be done to clean up the parsing context.

The code to be parsed comes from C<line> and C<rsfp>.  C<line>, if
non-null, provides a string (in SV form) containing code to be parsed.
A copy of the string is made, so subsequent modification of C<line>
does not affect parsing.  C<rsfp>, if non-null, provides an input stream
from which code will be read to be parsed.  If both are non-null, the
code in C<line> comes first and must consist of complete lines of input,
and C<rsfp> supplies the remainder of the source.

The C<flags> parameter is reserved for future use.  Currently it is only
used by perl internally, so extensions should always pass zero.

=over 3

 void  lex_start(SV *line, PerlIO *rsfp, U32 flags)

=back

=back

=for hackers
Found in file toke.c

=over 4

=item C<lex_stuff_pv>
X<lex_stuff_pv>

NOTE: C<lex_stuff_pv> is B<experimental> and may change or be
removed without notice.

Insert characters into the lexer buffer (L</PL_parser-E<gt>linestr>),
immediately after the current lexing point (L</PL_parser-E<gt>bufptr>),
reallocating the buffer if necessary.  This means that lexing code that
runs later will see the characters as if they had appeared in the input.
It is not recommended to do this as part of normal parsing, and most
uses of this facility run the risk of the inserted characters being
interpreted in an unintended manner.

The string to be inserted is represented by octets starting at C<pv>
and continuing to the first nul.  These octets are interpreted as either
UTF-8 or Latin-1, according to whether the C<LEX_STUFF_UTF8> flag is set
in C<flags>.  The characters are recoded for the lexer buffer, according
to how the buffer is currently being interpreted (L</lex_bufutf8>).
If it is not convenient to nul-terminate a string to be inserted, the
L</lex_stuff_pvn> function is more appropriate.

=over 3

 void  lex_stuff_pv(const char *pv, U32 flags)

=back

=back

=for hackers
Found in file toke.c

=over 4

=item C<lex_stuff_pvn>
X<lex_stuff_pvn>

NOTE: C<lex_stuff_pvn> is B<experimental> and may change or be
removed without notice.

Insert characters into the lexer buffer (L</PL_parser-E<gt>linestr>),
immediately after the current lexing point (L</PL_parser-E<gt>bufptr>),
reallocating the buffer if necessary.  This means that lexing code that
runs later will see the characters as if they had appeared in the input.
It is not recommended to do this as part of normal parsing, and most
uses of this facility run the risk of the inserted characters being
interpreted in an unintended manner.

The string to be inserted is represented by C<len> octets starting
at C<pv>.  These octets are interpreted as either UTF-8 or Latin-1,
according to whether the C<LEX_STUFF_UTF8> flag is set in C<flags>.
The characters are recoded for the lexer buffer, according to how the
buffer is currently being interpreted (L</lex_bufutf8>).  If a string
to be inserted is available as a Perl scalar, the L</lex_stuff_sv>
function is more convenient.

=over 3

 void  lex_stuff_pvn(const char *pv, STRLEN len, U32 flags)

=back

=back

=for hackers
Found in file toke.c

=over 4

=item C<lex_stuff_pvs>
X<lex_stuff_pvs>

NOTE: C<lex_stuff_pvs> is B<experimental> and may change or be
removed without notice.

Like L</lex_stuff_pvn>, but takes a literal string instead of
a string/length pair.

=over 3

 void  lex_stuff_pvs("pv", U32 flags)

=back

=back

=for hackers
Found in file handy.h

=over 4

=item C<lex_stuff_sv>
X<lex_stuff_sv>

NOTE: C<lex_stuff_sv> is B<experimental> and may change or be
removed without notice.

Insert characters into the lexer buffer (L</PL_parser-E<gt>linestr>),
immediately after the current lexing point (L</PL_parser-E<gt>bufptr>),
reallocating the buffer if necessary.  This means that lexing code that
runs later will see the characters as if they had appeared in the input.
It is not recommended to do this as part of normal parsing, and most
uses of this facility run the risk of the inserted characters being
interpreted in an unintended manner.

The string to be inserted is the string value of C<sv>.  The characters
are recoded for the lexer buffer, according to how the buffer is currently
being interpreted (L</lex_bufutf8>).  If a string to be inserted is
not already a Perl scalar, the L</lex_stuff_pvn> function avoids the
need to construct a scalar.

=over 3

 void  lex_stuff_sv(SV *sv, U32 flags)

=back

=back

=for hackers
Found in file toke.c

=over 4

=item C<lex_unstuff>
X<lex_unstuff>

NOTE: C<lex_unstuff> is B<experimental> and may change or be
removed without notice.

Discards text about to be lexed, from L</PL_parser-E<gt>bufptr> up to
C<ptr>.  Text following C<ptr> will be moved, and the buffer shortened.
This hides the discarded text from any lexing code that runs later,
as if the text had never appeared.

This is not the normal way to consume lexed text.  For that, use
L</lex_read_to>.

=over 3

 void  lex_unstuff(char *ptr)

=back

=back

=for hackers
Found in file toke.c

=over 4

=item C<parse_arithexpr>
X<parse_arithexpr>

NOTE: C<parse_arithexpr> is B<experimental> and may change or be
removed without notice.

Parse a Perl arithmetic expression.  This may contain operators of precedence
down to the bit shift operators.  The expression must be followed (and thus
terminated) either by a comparison or lower-precedence operator or by
something that would normally terminate an expression such as semicolon.
If C<flags> has the C<PARSE_OPTIONAL> bit set, then the expression is optional,
otherwise it is mandatory.  It is up to the caller to ensure that the
dynamic parser state (L</PL_parser> et al) is correctly set to reflect
the source of the code to be parsed and the lexical context for the
expression.

The op tree representing the expression is returned.  If an optional
expression is absent, a null pointer is returned, otherwise the pointer
will be non-null.

If an error occurs in parsing or compilation, in most cases a valid op
