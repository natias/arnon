
    use feature 'signatures';
    sub foo ($=1) {}           # legal
    sub foo ($x = 1) {}        # legal
    sub foo ($x += 1) {}       # illegal
    sub foo ($x == 1) {}       # illegal

=item Illegal pattern in regex; marked by S<<-- HERE> in m/%s/

(F) You wrote something like

 (?+foo)

The C<"+"> is valid only when followed by digits, indicating a
capturing group.  See
L<C<(?I<PARNO>)>|perlre/(?PARNO) (?-PARNO) (?+PARNO) (?R) (?0)>.

=item Illegal suidscript

(F) The script run under suidperl was somehow illegal.

=item Illegal switch in PERL5OPT: -%c

(X) The PERL5OPT environment variable may only be used to set the
following switches: B<-[CDIMUdmtw]>.

=item Illegal user-defined property name

(F) You specified a Unicode-like property name in a regular expression
pattern (using C<\p{}> or C<\P{}>) that Perl knows isn't an official
Unicode property, and was likely meant to be a user-defined property
name, but it can't be one of those, as they must begin with either C<In>
or C<Is>.  Check the spelling.  See also
L</Can't find Unicode property definition "%s">.

=item Ill-formed CRTL environ value "%s"

(W internal) A warning peculiar to VMS.  Perl tried to read the CRTL's
internal environ array, and encountered an element without the C<=>
delimiter used to separate keys from values.  The element is ignored.

=item Ill-formed message in prime_env_iter: |%s|

(W internal) A warning peculiar to VMS.  Perl tried to read a logical
name or CLI symbol definition when preparing to iterate over %ENV, and
didn't see the expected delimiter between key and value, so the line was
ignored.

=item (in cleanup) %s

(W misc) This prefix usually indicates that a DESTROY() method raised
the indicated exception.  Since destructors are usually called by the
system at arbitrary points during execution, and often a vast number of
times, the warning is issued only once for any number of failures that
would otherwise result in the same message being repeated.

Failure of user callbacks dispatched using the C<G_KEEPERR> flag could
also result in this warning.  See L<perlcall/G_KEEPERR>.

=item Implicit use of @_ in %s with signatured subroutine is experimental

(S experimental::args_array_with_signatures) An expression that implicitly
involves the C<@_> arguments array was found in a subroutine that uses a
signature.  This is experimental because the interaction between the
arguments array and parameter handling via signatures is not guaranteed
to remain stable in any future version of Perl, and such code should be
avoided.

=item Incomplete expression within '(?[ ])' in regex; marked by S<<-- HERE>
in m/%s/

(F) There was a syntax error within the C<(?[ ])>.  This can happen if the
expression inside the construct was completely empty, or if there are
too many or few operands for the number of operators.  Perl is not smart
enough to give you a more precise indication as to what is wrong.

=item Inconsistent hierarchy during C3 merge of class '%s': merging failed on 
parent '%s'

(F) The method resolution order (MRO) of the given class is not
C3-consistent, and you have enabled the C3 MRO for this class.  See the C3
documentation in L<mro> for more information.

=item Indentation on line %d of here-doc doesn't match delimiter

(F) You have an indented here-document where one or more of its lines
have whitespace at the beginning that does not match the closing
delimiter.

For example, line 2 below is wrong because it does not have at least
2 spaces, but lines 1 and 3 are fine because they have at least 2:

    if ($something) {
      print <<~EOF;
        Line 1
       Line 2 not
          Line 3
        EOF
    }

Note that tabs and spaces are compared strictly, meaning 1 tab will
not match 8 spaces.

=item Infinite recursion in regex

(F) You used a pattern that references itself without consuming any input
text.  You should check the pattern to ensure that recursive patterns
either consume text or fail.

=item Infinite recursion in user-defined property

(F) A user-defined property (L<perlunicode/User-Defined Character
Properties>) can depend on the definitions of other user-defined
properties.  If the chain of dependencies leads back to this property,
infinite recursion would occur, were it not for the check that raised
this error.

Restructure your property definitions to avoid this.

=item Infinite recursion via empty pattern

(F) You tried to use the empty pattern inside of a regex code block,
for instance C</(?{ s!!! })/>, which resulted in re-executing
the same pattern, which is an infinite loop which is broken by
throwing an exception.

=item Initialization of state variables in list currently forbidden

(F) C<state> only permits initializing a single variable, specified
without parentheses.  So C<state $x = 42> and C<state @x = qw(a b c)> are
allowed, but not C<state ($x) = 42> or C<(state $x) = 42>.  To initialize
more than one C<state> variable, initialize them one at a time.

=item %%s[%s] in scalar context better written as $%s[%s]

(W syntax) In scalar context, you've used an array index/value slice
(indicated by %) to select a single element of an array.  Generally
it's better to ask for a scalar value (indicated by $).  The difference
is that C<$foo[&bar]> always behaves like a scalar, both in the value it
returns and when evaluating its argument, while C<%foo[&bar]> provides
a list context to its subscript, which can do weird things if you're
expecting only one subscript.  When called in list context, it also
returns the index (what C<&bar> returns) in addition to the value.

=item %%s{%s} in scalar context better written as $%s{%s}

(W syntax) In scalar context, you've used a hash key/value slice
(indicated by %) to select a single element of a hash.  Generally it's
better to ask for a scalar value (indicated by $).  The difference
is that C<$foo{&bar}> always behaves like a scalar, both in the value
it returns and when evaluating its argument, while C<@foo{&bar}> and
provides a list context to its subscript, which can do weird things
if you're expecting only one subscript.  When called in list context,
it also returns the key in addition to the value.

=item Insecure dependency in %s

(F) You tried to do something that the tainting mechanism didn't like.
The tainting mechanism is turned on when you're running setuid or
setgid, or when you specify B<-T> to turn it on explicitly.  The
tainting mechanism labels all data that's derived directly or indirectly
from the user, who is considered to be unworthy of your trust.  If any
such data is used in a "dangerous" operation, you get this error.  See
L<perlsec> for more information.

=item Insecure directory in %s

(F) You can't use system(), exec(), or a piped open in a setuid or
setgid script if C<$ENV{PATH}> contains a directory that is writable by
the world.  Also, the PATH must not contain any relative directory.
See L<perlsec>.

=item Insecure $ENV{%s} while running %s

(F) You can't use system(), exec(), or a piped open in a setuid or
setgid script if any of C<$ENV{PATH}>, C<$ENV{IFS}>, C<$ENV{CDPATH}>,
C<$ENV{ENV}>, C<$ENV{BASH_ENV}> or C<$ENV{TERM}> are derived from data
supplied (or potentially supplied) by the user.  The script must set
the path to a known value, using trustworthy data.  See L<perlsec>.

=item Insecure user-defined property %s

(F) Perl detected tainted data when trying to compile a regular
expression that contains a call to a user-defined character property
function, i.e. C<\p{IsFoo}> or C<\p{InFoo}>.
See L<perlunicode/User-Defined Character Properties> and L<perlsec>.

=item Integer overflow in format string for %s

(F) The indexes and widths specified in the format string of C<printf()>
or C<sprintf()> are too large.  The numbers must not overflow the size of
integers for your architecture.

=item Integer overflow in %s number

(S overflow) The hexadecimal, octal or binary number you have specified
either as a literal or as an argument to hex() or oct() is too big for
your architecture, and has been converted to a floating point number.
On a 32-bit architecture the largest hexadecimal, octal or binary number
representable without overflow is 0xFFFFFFFF, 037777777777, or
0b11111111111111111111111111111111 respectively.  Note that Perl
transparently promotes all numbers to a floating point representation
internally--subject to loss of precision errors in subsequent
operations.

=item Integer overflow in srand

(S overflow) The number you have passed to srand is too big to fit
in your architecture's integer representation.  The number has been
replaced with the largest integer supported (0xFFFFFFFF on 32-bit
architectures).  This means you may be getting less randomness than
you expect, because different random seeds above the maximum will
return the same sequence of random numbers.

=item Integer overflow in version

=item Integer overflow in version %d

(W overflow) Some portion of a version initialization is too large for
the size of integers for your architecture.  This is not a warning
because there is no rational reason for a version to try and use an
element larger than typically 2**32.  This is usually caused by trying
to use some odd mathematical operation as a version, like 100/9.

=item Internal disaster in regex; marked by S<<-- HERE> in m/%s/

(P) Something went badly wrong in the regular expression parser.
The S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.

=item Internal inconsistency in tracking vforks

(S) A warning peculiar to VMS.  Perl keeps track of the number of times
you've called C<fork> and C<exec>, to determine whether the current call
to C<exec> should affect the current script or a subprocess (see
L<perlvms/"exec LIST">).  Somehow, this count has become scrambled, so
Perl is making a guess and treating this C<exec> as a request to
terminate the Perl script and execute the specified command.

=item internal %<num>p might conflict with future printf extensions

(S internal) Perl's internal routine that handles C<printf> and C<sprintf>
formatting follows a slightly different set of rules when called from
C or XS code.  Specifically, formats consisting of digits followed
by "p" (e.g., "%7p") are reserved for future use.  If you see this
message, then an XS module tried to call that routine with one such
reserved format.

=item Internal urp in regex; marked by S<<-- HERE> in m/%s/

(P) Something went badly awry in the regular expression parser.  The
S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.

=item %s (...) interpreted as function

(W syntax) You've run afoul of the rule that says that any list operator
followed by parentheses turns into a function, with all the list
operators arguments found inside the parentheses.  See
L<perlop/Terms and List Operators (Leftward)>.

=item In '(?...)', the '(' and '?' must be adjacent in regex;
marked by S<<-- HERE> in m/%s/

(F) The two-character sequence C<"(?"> in this context in a regular
expression pattern should be an indivisible token, with nothing
intervening between the C<"("> and the C<"?">, but you separated them
with whitespace.

=item In '(*...)', the '(' and '*' must be adjacent in regex;
marked by S<<-- HERE> in m/%s/

(F) The two-character sequence C<"(*"> in this context in a regular
expression pattern should be an indivisible token, with nothing
intervening between the C<"("> and the C<"*">, but you separated them.
Fix the pattern and retry.

=item Invalid %s attribute: %s

(F) The indicated attribute for a subroutine or variable was not recognized
by Perl or by a user-supplied handler.  See L<attributes>.

=item Invalid %s attributes: %s

(F) The indicated attributes for a subroutine or variable were not
recognized by Perl or by a user-supplied handler.  See L<attributes>.

=item Invalid character in charnames alias definition; marked by
S<<-- HERE> in '%s

(F) You tried to create a custom alias for a character name, with
the C<:alias> option to C<use charnames> and the specified character in
the indicated name isn't valid.  See L<charnames/CUSTOM ALIASES>.

=item Invalid \0 character in %s for %s: %s\0%s

(W syscalls) Embedded \0 characters in pathnames or other system call
arguments produce a warning as of 5.20.  The parts after the \0 were
formerly ignored by system calls.

=item Invalid character in \N{...}; marked by S<<-- HERE> in \N{%s}

(F) Only certain characters are valid for character names.  The
indicated one isn't.  See L<charnames/CUSTOM ALIASES>.

=item Invalid conversion in %s: "%s"

(W printf) Perl does not understand the given format conversion.  See
L<perlfunc/sprintf>.

=item Invalid escape in the specified encoding in regex; marked by
S<<-- HERE> in m/%s/

(W regexp)(F) The numeric escape (for example C<\xHH>) of value < 256
didn't correspond to a single character through the conversion
from the encoding specified by the encoding pragma.
The escape was replaced with REPLACEMENT CHARACTER (U+FFFD)
instead, except within S<C<(?[   ])>>, where it is a fatal error.
The S<<-- HERE> shows whereabouts in the regular expression the
escape was discovered.

=item Invalid hexadecimal number in \N{U+...}

=item Invalid hexadecimal number in \N{U+...} in regex; marked by
S<<-- HERE> in m/%s/

(F) The character constant represented by C<...> is not a valid hexadecimal
number.  Either it is empty, or you tried to use a character other than
0 - 9 or A - F, a - f in a hexadecimal number.

=item Invalid module name %s with -%c option: contains single ':'

(F) The module argument to perl's B<-m> and B<-M> command-line options
cannot contain single colons in the module name, but only in the
arguments after "=".  In other words, B<-MFoo::Bar=:baz> is ok, but
B<-MFoo:Bar=baz> is not.

=item Invalid mro name: '%s'

(F) You tried to C<mro::set_mro("classname", "foo")> or C<use mro 'foo'>,
where C<foo> is not a valid method resolution order (MRO).  Currently,
the only valid ones supported are C<dfs> and C<c3>, unless you have loaded
a module that is a MRO plugin.  See L<mro> and L<perlmroapi>.

=item Invalid negative number (%s) in chr

(W utf8) You passed a negative number to C<chr>.  Negative numbers are
not valid character numbers, so it returns the Unicode replacement
character (U+FFFD).

=item Invalid number '%s' for -C option.

(F) You supplied a number to the -C option that either has extra leading
zeroes or overflows perl's unsigned integer representation.

=item invalid option -D%c, use -D'' to see choices

(S debugging) Perl was called with invalid debugger flags.  Call perl
with the B<-D> option with no flags to see the list of acceptable values.
See also L<perlrun/-Dletters>.

=item Invalid quantifier in {,} in regex; marked by S<<-- HERE> in m/%s/

(F) The pattern looks like a {min,max} quantifier, but the min or max
could not be parsed as a valid number - either it has leading zeroes,
or it represents too big a number to cope with.  The S<<-- HERE> shows
where in the regular expression the problem was discovered.  See L<perlre>.

=item Invalid [] range "%s" in regex; marked by S<<-- HERE> in m/%s/

(F) The range specified in a character class had a minimum character
greater than the maximum character.  One possibility is that you forgot the
C<{}> from your ending C<\x{}> - C<\x> without the curly braces can go only
up to C<ff>.  The S<<-- HERE> shows whereabouts in the regular expression the
problem was discovered.  See L<perlre>.

=item Invalid range "%s" in transliteration operator

(F) The range specified in the tr/// or y/// operator had a minimum
character greater than the maximum character.  See L<perlop>.

=item Invalid reference to group in regex; marked by S<<-- HERE> in m/%s/

(F) The capture group you specified can't possibly exist because the
number you used is not within the legal range of possible values for
this machine.

=item Invalid separator character %s in attribute list

(F) Something other than a colon or whitespace was seen between the
elements of an attribute list.  If the previous attribute had a
parenthesised parameter list, perhaps that list was terminated too soon.
See L<attributes>.

=item Invalid separator character %s in PerlIO layer specification %s

(W layer) When pushing layers onto the Perl I/O system, something other
than a colon or whitespace was seen between the elements of a layer list.
If the previous attribute had a parenthesised parameter list, perhaps that
list was terminated too soon.

=item Invalid strict version format (%s)

(F) A version number did not meet the "strict" criteria for versions.
A "strict" version number is a positive decimal number (integer or
decimal-fraction) without exponentiation or else a dotted-decimal
v-string with a leading 'v' character and at least three components.
The parenthesized text indicates which criteria were not met.
See the L<version> module for more details on allowed version formats.

=item Invalid type '%s' in %s

(F) The given character is not a valid pack or unpack type.
See L<perlfunc/pack>.

(W) The given character is not a valid pack or unpack type but used to be
silently ignored.

=item Invalid version bundle "%s"

(F) A version number that is used to specify an import bundle during a
C<use builtin ...> statement must be formatted as C<:MAJOR.MINOR> with an
optional third component, which is ignored.  Each component must be a number
of 1 to 3 digits. No other characters are permitted.  The value that was
specified does not conform to these rules.

=item Invalid version format (%s)

(F) A version number did not meet the "lax" criteria for versions.
A "lax" version number is a positive decimal number (integer or
decimal-fraction) without exponentiation or else a dotted-decimal
v-string.  If the v-string has fewer than three components, it
must have a leading 'v' character.  Otherwise, the leading 'v' is
optional.  Both decimal and dotted-decimal versions may have a
trailing "alpha" component separated by an underscore character
after a fractional or dotted-decimal component.  The parenthesized
text indicates which criteria were not met.  See the L<version> module
for more details on allowed version formats.

=item Invalid version object

(F) The internal structure of the version object was invalid.
Perhaps the internals were modified directly in some way or
an arbitrary reference was blessed into the "version" class.

=item In '(*VERB...)', the '(' and '*' must be adjacent in regex;
marked by S<<-- HERE> in m/%s/

=item Inverting a character class which contains a multi-character
sequence is illegal in regex; marked by <-- HERE in m/%s/

(F) You wrote something like

 qr/\P{name=KATAKANA LETTER AINU P}/
 qr/[^\p{name=KATAKANA LETTER AINU P}]/

This name actually evaluates to a sequence of two Katakana characters,
not just a single one, and it is illegal to try to take the complement
of a sequence.  (Mathematically it would mean any sequence of characters
from 0 to infinity in length that weren't these two in a row, and that
is likely not of any real use.)

(F) The two-character sequence C<"(*"> in this context in a regular
expression pattern should be an indivisible token, with nothing
intervening between the C<"("> and the C<"*">, but you separated them.

=item ioctl is not implemented

(F) Your machine apparently doesn't implement ioctl(), which is pretty
strange for a machine that supports C.

=item ioctl() on unopened %s

(W unopened) You tried ioctl() on a filehandle that was never opened.
Check your control flow and number of arguments.

=item IO layers (like '%s') unavailable

(F) Your Perl has not been configured to have PerlIO, and therefore
you cannot use IO layers.  To have PerlIO, Perl must be configured
with 'useperlio'.

=item IO::Socket::atmark not implemented on this architecture

(F) Your machine doesn't implement the sockatmark() functionality,
neither as a system call nor an ioctl call (SIOCATMARK).

=item '%s' is an unknown bound type in regex; marked by S<<-- HERE> in m/%s/

(F) You used C<\b{...}> or C<\B{...}> and the C<...> is not known to
Perl.  The current valid ones are given in
L<perlrebackslash/\b{}, \b, \B{}, \B>.

=item %s() isn't allowed on :utf8 handles

(F) The sysread(), recv(), syswrite() and send() operators are
not allowed on handles that have the C<:utf8> layer, either explicitly, or
implicitly, eg., with the C<:encoding(UTF-16LE)> layer.

Previously sysread() and recv() currently use only the C<:utf8> flag for the stream,
ignoring the actual layers.  Since sysread() and recv() did no UTF-8
validation they can end up creating invalidly encoded scalars.

Similarly, syswrite() and send() used only the C<:utf8> flag, otherwise ignoring
any layers.  If the flag is set, both wrote the value UTF-8 encoded, even if
the layer is some different encoding, such as the example above.

Ideally, all of these operators would completely ignore the C<:utf8> state,
working only with bytes, but this would result in silently breaking existing
code.

=item "%s" is more clearly written simply as "%s" in regex; marked by S<<-- HERE> in m/%s/

(W regexp) (only under C<S<use re 'strict'>> or within C<(?[...])>)

You specified a character that has the given plainer way of writing it, and
which is also portable to platforms running with different character sets.

=item $* is no longer supported as of Perl 5.30

(F) The special variable C<$*>, deprecated in older perls, was removed in
5.10.0, is no longer supported and is a fatal error as of Perl 5.30.  In
previous versions of perl the use of C<$*> enabled or disabled multi-line
matching within a string.

Instead of using C<$*> you should use the C</m> (and maybe C</s>) regexp
modifiers.  You can enable C</m> for a lexical scope (even a whole file)
with C<use re '/m'>.  (In older versions: when C<$*> was set to a true value
then all regular expressions behaved as if they were written using C</m>.)

Use of this variable will be a fatal error in Perl 5.30.

=item $# is no longer supported as of Perl 5.30

(F) The special variable C<$#>, deprecated in older perls, was removed as of
5.10.0, is no longer supported and is a fatal error as of Perl 5.30.  You
should use the printf/sprintf functions instead.

=item '%s' is not a code reference

(W overload) The second (fourth, sixth, ...) argument of
overload::constant needs to be a code reference.  Either
an anonymous subroutine, or a reference to a subroutine.

=item '%s' is not an overloadable type

(W overload) You tried to overload a constant type the overload package is
unaware of.

=item '%s' is not recognised as a builtin function

(F) An attempt was made to C<use> the L<builtin> pragma module to create
a lexical alias for an unknown function name.

=item -i used with no filenames on the command line, reading from STDIN

(S inplace) The C<-i> option was passed on the command line, indicating
that the script is intended to edit files in place, but no files were
given.  This is usually a mistake, since editing STDIN in place doesn't
make sense, and can be confusing because it can make perl look like
it is hanging when it is really just trying to read from STDIN.  You
should either pass a filename to edit, or remove C<-i> from the command
line.  See L<perlrun|perlrun/-i[extension]> for more details.

=item Junk on end of regexp in regex m/%s/

(P) The regular expression parser is confused.

=item \K not permitted in lookahead/lookbehind in regex; marked by <-- HERE in m/%s/

(F) Your regular expression used C<\K> in a lookahead or lookbehind
assertion, which currently isn't permitted.

This may change in the future, see L<Support \K in
lookarounds|https://github.com/Perl/perl5/issues/18134>.

=item Label not found for "last %s"

(F) You named a loop to break out of, but you're not currently in a loop
of that name, not even if you count where you were called from.  See
L<perlfunc/last>.

=item Label not found for "next %s"

(F) You named a loop to continue, but you're not currently in a loop of
that name, not even if you count where you were called from.  See
L<perlfunc/last>.

=item Label not found for "redo %s"

(F) You named a loop to restart, but you're not currently in a loop of
that name, not even if you count where you were called from.  See
L<perlfunc/last>.

=item leaving effective %s failed

(F) While under the C<use filetest> pragma, switching the real and
effective uids or gids failed.

=item length/code after end of string in unpack

(F) While unpacking, the string buffer was already used up when an unpack
length/code combination tried to obtain more data.  This results in
an undefined value for the length.  See L<perlfunc/pack>.

=item length() used on %s (did you mean "scalar(%s)"?)

(W syntax) You used length() on either an array or a hash when you
probably wanted a count of the items.

Array size can be obtained by doing:

    scalar(@array);

The number of items in a hash can be obtained by doing:

    scalar(keys %hash);

=item Lexing code attempted to stuff non-Latin-1 character into Latin-1 input

(F) An extension is attempting to insert text into the current parse
(using L<lex_stuff_pvn|perlapi/lex_stuff_pvn> or similar), but tried to insert a character that
couldn't be part of the current input.  This is an inherent pitfall
of the stuffing mechanism, and one of the reasons to avoid it.  Where
it is necessary to stuff, stuffing only plain ASCII is recommended.

=item Lexing code internal error (%s)

(F) Lexing code supplied by an extension violated the lexer's API in a
detectable way.

=item listen() on closed socket %s

(W closed) You tried to do a listen on a closed socket.  Did you forget
to check the return value of your socket() call?  See
L<perlfunc/listen>.

=item List form of piped open not implemented

(F) On some platforms, notably Windows, the three-or-more-arguments
form of C<open> does not support pipes, such as C<open($pipe, '|-', @args)>.
Use the two-argument C<open($pipe, '|prog arg1 arg2...')> form instead.

=item Literal vertical space in [] is illegal except under /x in regex;
marked by S<<-- HERE> in m/%s/

(F) (only under C<S<use re 'strict'>> or within C<(?[...])>)

Likely you forgot the C</x> modifier or there was a typo in the pattern.
For example, did you really mean to match a form-feed?  If so, all the
ASCII vertical space control characters are representable by escape
sequences which won't present such a jarring appearance as your pattern
does when displayed.

  \r    carriage return
  \f    form feed
  \n    line feed
  \cK   vertical tab

=item %s: loadable library and perl binaries are mismatched (got %s handshake key %p, needed %p)

(P) A dynamic loading library C<.so> or C<.dll> was being loaded into the
process that was built against a different build of perl than the
said library was compiled against.  Reinstalling the XS module will
likely fix this error.

=item Locale '%s' contains (at least) the following characters which
have unexpected meanings: %s  The Perl program will use the expected
meanings

(W locale) You are using the named UTF-8 locale.  UTF-8 locales are
expected to have very particular behavior, which most do.  This message
arises when perl found some departures from the expectations, and is
notifying you that the expected behavior overrides these differences.
In some cases the differences are caused by the locale definition being
defective, but the most common causes of this warning are when there are
ambiguities and conflicts in following the Standard, and the locale has
chosen an approach that differs from Perl's.

One of these is because that, contrary to the claims, Unicode is not
completely locale insensitive.  Turkish and some related languages
have two types of C<"I"> characters.  One is dotted in both upper- and
lowercase, and the other is dotless in both cases.  Unicode allows a
locale to use either the Turkish rules, or the rules used in all other
instances, where there is only one type of C<"I">, which is dotless in
the uppercase, and dotted in the lower.  The perl core does not (yet)
handle the Turkish case, and this message warns you of that.  Instead,
the L<Unicode::Casing> module allows you to mostly implement the Turkish
casing rules.

The other common cause is for the characters

 $ + < = > ^ ` | ~

These are problematic.  The C standard says that these should be
considered punctuation in the C locale (and the POSIX standard defers to
the C standard), and Unicode is generally considered a superset of
the C locale.  But Unicode has added an extra category, "Symbol", and
classifies these particular characters as being symbols.  Most UTF-8
locales have them treated as punctuation, so that L<ispunct(3)> returns
non-zero for them.  But a few locales have it return 0.   Perl takes
the first approach, not using C<ispunct()> at all (see L<Note [5] in
perlrecharclass|perlrecharclass/[5]>), and this message is raised to notify you that you
are getting Perl's approach, not the locale's.

=item Locale '%s' is unsupported, and may crash the interpreter

(S locale) The named locale is not supported by Perl, and using it leads
to undefined behavior, including potentially crashing the computer.

Currently the only locales that generate this severe warning are
non-UTF-8 ones which have characters that require more than one byte to
represent (common in older East Asian language locales).  See
L<perllocale>.

=item Locale '%s' may not work well.%s

(W locale) You are using the named locale, which is a non-UTF-8 one, and
which perl has determined is not fully compatible with what it can
handle.  The second C<%s> gives a reason.

By far the most common reason is that the locale has characters in it
that are represented by more than one byte.  The only such locales that
Perl can handle are the UTF-8 locales.  Most likely the specified locale
is a non-UTF-8 one for an East Asian language such as Chinese or
Japanese.  If the locale is a superset of ASCII, the ASCII portion of it
may work in Perl.

Some essentially obsolete locales that aren't supersets of ASCII, mainly
those in ISO 646 or other 7-bit locales, such as ASMO 449, can also have
problems, depending on what portions of the ASCII character set get
changed by the locale and are also used by the program.
The warning message lists the determinable conflicting characters.

Note that not all incompatibilities are found.

If this happens to you, there's not much you can do except switch to use a
different locale or use L<Encode> to translate from the locale into
UTF-8; if that's impracticable, you have been warned that some things
may break.

This message is output once each time a bad locale is switched into
within the scope of C<S<use locale>>, or on the first possibly-affected
operation if the C<S<use locale>> inherits a bad one.  It is not raised
for any operations from the L<POSIX> module.

=item localtime(%f) failed

(W overflow) You called C<localtime> with a number that it could not handle:
too large, too small, or NaN.  The returned value is C<undef>.

=item localtime(%f) too large

(W overflow) You called C<localtime> with a number that was larger
than it can reliably handle and C<localtime> probably returned the
wrong date.  This warning is also triggered with NaN (the special
not-a-number value).

=item localtime(%f) too small

(W overflow) You called C<localtime> with a number that was smaller
than it can reliably handle and C<localtime> probably returned the
wrong date.

=item Lookbehind longer than %d not implemented in regex m/%s/

(F) There is currently a limit on the length of string which lookbehind can
handle.  This restriction may be eased in a future release. 

=item Lost precision when %s %f by 1

(W imprecision) You attempted to increment or decrement a value by one,
but the result is too large for the underlying floating point
representation to store accurately. Hence, the target of C<++> or C<-->
is increased or decreased by quite different value than one, such as
zero (I<i.e.> the target is unchanged) or two, due to rounding.
Perl issues this
warning because it has already switched from integers to floating point
when values are too large for integers, and now even floating point is
insufficient.  You may wish to switch to using L<Math::BigInt> explicitly.

=item lstat() on filehandle%s

(W io) You tried to do an lstat on a filehandle.  What did you mean
by that?  lstat() makes sense only on filenames.  (Perl did a fstat()
instead on the filehandle.)

=item lvalue attribute %s already-defined subroutine

(W misc) Although L<attributes.pm|attributes> allows this, turning the lvalue
attribute on or off on a Perl subroutine that is already defined
does not always work properly.  It may or may not do what you
want, depending on what code is inside the subroutine, with exact
details subject to change between Perl versions.  Only do this
if you really know what you are doing.

=item lvalue attribute ignored after the subroutine has been defined

(W misc) Using the C<:lvalue> declarative syntax to make a Perl
subroutine an lvalue subroutine after it has been defined is
not permitted.  To make the subroutine an lvalue subroutine,
add the lvalue attribute to the definition, or put the C<sub
foo :lvalue;> declaration before the definition.

See also L<attributes.pm|attributes>.

=item Magical list constants are not supported

(F) You assigned a magical array to a stash element, and then tried
to use the subroutine from the same slot.  You are asking Perl to do
something it cannot do, details subject to change between Perl versions.

=item Malformed integer in [] in pack

(F) Between the brackets enclosing a numeric repeat count only digits
are permitted.  See L<perlfunc/pack>.

=item Malformed integer in [] in unpack

(F) Between the brackets enclosing a numeric repeat count only digits
are permitted.  See L<perlfunc/pack>.

=item Malformed PERLLIB_PREFIX

(F) An error peculiar to OS/2.  PERLLIB_PREFIX should be of the form

    prefix1;prefix2

or
    prefix1 prefix2

with nonempty prefix1 and prefix2.  If C<prefix1> is indeed a prefix of
a builtin library search path, prefix2 is substituted.  The error may
appear if components are not found, or are too long.  See
"PERLLIB_PREFIX" in L<perlos2>.

=item Malformed prototype for %s: %s

(F) You tried to use a function with a malformed prototype.  The
syntax of function prototypes is given a brief compile-time check for
obvious errors like invalid characters.  A more rigorous check is run
when the function is called.
Perhaps the function's author was trying to write a subroutine signature
but didn't enable that feature first (C<use feature 'signatures'>),
so the signature was instead interpreted as a bad prototype.

=item Malformed UTF-8 character%s

(S utf8)(F) Perl detected a string that should be UTF-8, but didn't
comply with UTF-8 encoding rules, or represents a code point whose
ordinal integer value doesn't fit into the word size of the current
platform (overflows).  Details as to the exact malformation are given in
the variable, C<%s>, part of the message.

One possible cause is that you set the UTF8 flag yourself for data that
you thought to be in UTF-8 but it wasn't (it was for example legacy 8-bit
data).  To guard against this, you can use C<Encode::decode('UTF-8', ...)>.

If you use the C<:encoding(UTF-8)> PerlIO layer for input, invalid byte
sequences are handled gracefully, but if you use C<:utf8>, the flag is set
without validating the data, possibly resulting in this error message.

See also L<Encode/"Handling Malformed Data">.

=item Malformed UTF-8 returned by \N{%s} immediately after '%s'

(F) The charnames handler returned malformed UTF-8.

=item Malformed UTF-8 string in "%s"

(F) This message indicates a bug either in the Perl core or in XS
code. Such code was trying to find out if a character, allegedly
stored internally encoded as UTF-8, was of a given type, such as
being punctuation or a digit.  But the character was not encoded
in legal UTF-8.  The C<%s> is replaced by a string that can be used
by knowledgeable people to determine what the type being checked
against was.

Passing malformed strings was deprecated in Perl 5.18, and
became fatal in Perl 5.26.

=item Malformed UTF-8 string in '%c' format in unpack

(F) You tried to unpack something that didn't comply with UTF-8 encoding
rules and perl was unable to guess how to make more progress.

=item Malformed UTF-8 string in pack

(F) You tried to pack something that didn't comply with UTF-8 encoding
rules and perl was unable to guess how to make more progress.

=item Malformed UTF-8 string in unpack

(F) You tried to unpack something that didn't comply with UTF-8 encoding
rules and perl was unable to guess how to make more progress.

=item Malformed UTF-16 surrogate

(F) Perl thought it was reading UTF-16 encoded character data but while
doing it Perl met a malformed Unicode surrogate.

=item Mandatory parameter follows optional parameter

(F) In a subroutine signature, you wrote something like "$x = undef,
$y", making an earlier parameter optional and a later one mandatory.
Parameters are filled from left to right, so it's impossible for the
caller to omit an earlier one and pass a later one.  If you want to act
as if the parameters are filled from right to left, declare the rightmost
optional and then shuffle the parameters around in the subroutine's body.

=item Matched non-Unicode code point 0x%X against Unicode property; may
not be portable

(S non_unicode) Perl allows strings to contain a superset of
Unicode code points; each code point may be as large as what is storable
in a signed integer on your system, but these may not be accepted by
other languages/systems.  This message occurs when you matched a string
containing such a code point against a regular expression pattern, and
the code point was matched against a Unicode property, C<\p{...}> or
C<\P{...}>.  Unicode properties are only defined on Unicode code points,
so the result of this match is undefined by Unicode, but Perl (starting
in v5.20) treats non-Unicode code points as if they were typical
unassigned Unicode ones, and matched this one accordingly.  Whether a
given property matches these code points or not is specified in
L<perluniprops/Properties accessible through \p{} and \P{}>.

This message is suppressed (unless it has been made fatal) if it is
immaterial to the results of the match if the code point is Unicode or
not.  For example, the property C<\p{ASCII_Hex_Digit}> only can match
the 22 characters C<[0-9A-Fa-f]>, so obviously all other code points,
Unicode or not, won't match it.  (And C<\P{ASCII_Hex_Digit}> will match
every code point except these 22.)

Getting this message indicates that the outcome of the match arguably
should have been the opposite of what actually happened.  If you think
that is the case, you may wish to make the C<non_unicode> warnings
category fatal; if you agree with Perl's decision, you may wish to turn
off this category.

See L<perlunicode/Beyond Unicode code points> for more information.

=item %s matches null string many times in regex; marked by S<<-- HERE> in
m/%s/

(W regexp) The pattern you've specified would be an infinite loop if the
regular expression engine didn't specifically check for that.  The S<<-- HERE>
shows whereabouts in the regular expression the problem was discovered.
See L<perlre>.

=item Maximal count of pending signals (%u) exceeded

(F) Perl aborted due to too high a number of signals pending.  This
usually indicates that your operating system tried to deliver signals
too fast (with a very high priority), starving the perl process from
resources it would need to reach a point where it can process signals
safely.  (See L<perlipc/"Deferred Signals (Safe Signals)">.)

=item "%s" may clash with future reserved word

(W) This warning may be due to running a perl5 script through a perl4
interpreter, especially if the word that is being warned about is
"use" or "my".

=item '%' may not be used in pack

(F) You can't pack a string by supplying a checksum, because the
checksumming process loses information, and you can't go the other way.
See L<perlfunc/unpack>.

=item Method for operation %s not found in package %s during blessing

(F) An attempt was made to specify an entry in an overloading table that
doesn't resolve to a valid subroutine.  See L<overload>.

=item method is experimental

(S experimental::class) This warning is emitted if you use the C<method>
keyword of C<use feature 'class'>.  This keyword is currently
experimental and its behaviour may change in future releases of Perl.

=item Method %s not permitted

See L</500 Server error>.

=item Method %s redefined

(W redefine) You redefined a method.  To suppress this warning, say

    {
	no warnings 'redefine';
	*name = method { ... };
    }

=item Might be a runaway multi-line %s string starting on line %d

(S) An advisory indicating that the previous error may have been caused
by a missing delimiter on a string or pattern, because it eventually
ended earlier on the current line.

=item Mismatched brackets in template
