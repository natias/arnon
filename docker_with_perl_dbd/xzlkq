privileges.  Perl doesn't prevent you from
opening tainted filenames for reading,
so be careful what you print out.  The tainting mechanism is intended to
prevent stupid mistakes, not to remove the need for thought.

Perl does not call the shell to expand wild cards when you pass C<system>
and C<exec> explicit parameter lists instead of strings with possible shell
wildcards in them.  Unfortunately, the C<open>, C<glob>, and
backtick functions provide no such alternate calling convention, so more
subterfuge will be required.

Perl provides a reasonably safe way to open a file or pipe from a setuid
or setgid program: just create a child process with reduced privilege who
does the dirty work for you.  First, fork a child using the special
C<open> syntax that connects the parent and child by a pipe.  Now the
child resets its ID set and any other per-process attributes, like
environment variables, umasks, current working directories, back to the
originals or known safe values.  Then the child process, which no longer
has any special permissions, does the C<open> or other system call.
Finally, the child passes the data it managed to access back to the
parent.  Because the file or pipe was opened in the child while running
under less privilege than the parent, it's not apt to be tricked into
doing something it shouldn't.

Here's a way to do backticks reasonably safely.  Notice how the C<exec> is
not called with a string that the shell could expand.  This is by far the
best way to call something that might be subjected to shell escapes: just
never call the shell at all.  

        use English;
        die "Can't fork: $!" unless defined($pid = open(KID, "-|"));
        if ($pid) {           # parent
            while (<KID>) {
                # do something
            }
            close KID;
        } else {
            my @temp     = ($EUID, $EGID);
            my $orig_uid = $UID;
            my $orig_gid = $GID;
            $EUID = $UID;
            $EGID = $GID;
            # Drop privileges
            $UID  = $orig_uid;
            $GID  = $orig_gid;
            # Make sure privs are really gone
            ($EUID, $EGID) = @temp;
            die "Can't drop privileges"
                unless $UID == $EUID  && $GID eq $EGID;
            $ENV{PATH} = "/bin:/usr/bin"; # Minimal PATH.
	    # Consider sanitizing the environment even more.
            exec 'myprog', 'arg1', 'arg2'
                or die "can't exec myprog: $!";
        }

A similar strategy would work for wildcard expansion via C<glob>, although
you can use C<readdir> instead.

Taint checking is most useful when although you trust yourself not to have
written a program to give away the farm, you don't necessarily trust those
who end up using it not to try to trick it into doing something bad.  This
is the kind of security checking that's useful for set-id programs and
programs launched on someone else's behalf, like CGI programs.

This is quite different, however, from not even trusting the writer of the
code not to try to do something evil.  That's the kind of trust needed
when someone hands you a program you've never seen before and says, "Here,
run this."  For that kind of safety, you might want to check out the Safe
module, included standard in the Perl distribution.  This module allows the
programmer to set up special compartments in which all system operations
are trapped and namespace access is carefully controlled.  Safe should
not be considered bullet-proof, though: it will not prevent the foreign
code to set up infinite loops, allocate gigabytes of memory, or even
abusing perl bugs to make the host interpreter crash or behave in
unpredictable ways.  In any case it's better avoided completely if you're
really concerned about security.

=head2 Shebang Race Condition

Beyond the obvious problems that stem from giving special privileges to
systems as flexible as scripts, on many versions of Unix, set-id scripts
are inherently insecure right from the start.  The problem is a race
condition in the kernel.  Between the time the kernel opens the file to
see which interpreter to run and when the (now-set-id) interpreter turns
around and reopens the file to interpret it, the file in question may have
changed, especially if you have symbolic links on your system.

Some Unixes, especially more recent ones, are free of this
inherent security bug.  On such systems, when the kernel passes the name
of the set-id script to open to the interpreter, rather than using a
pathname subject to meddling, it instead passes I</dev/fd/3>.  This is a
special file already opened on the script, so that there can be no race
condition for evil scripts to exploit.  On these systems, Perl should be
compiled with C<-DSETUID_SCRIPTS_ARE_SECURE_NOW>.  The F<Configure>
program that builds Perl tries to figure this out for itself, so you
should never have to specify this yourself.  Most modern releases of
SysVr4 and BSD 4.4 use this approach to avoid the kernel race condition.

If you don't have the safe version of set-id scripts, all is not lost.
Sometimes this kernel "feature" can be disabled, so that the kernel
either doesn't run set-id scripts with the set-id or doesn't run them
at all.  Either way avoids the exploitability of the race condition,
but doesn't help in actually running scripts set-id.

If the kernel set-id script feature isn't disabled, then any set-id
script provides an exploitable vulnerability.  Perl can't avoid being
exploitable, but will point out vulnerable scripts where it can.  If Perl
detects that it is being applied to a set-id script then it will complain
loudly that your set-id script is insecure, and won't run it.  When Perl
complains, you need to remove the set-id bit from the script to eliminate
the vulnerability.  Refusing to run the script doesn't in itself close
the vulnerability; it is just Perl's way of encouraging you to do this.

To actually run a script set-id, if you don't have the safe version of
set-id scripts, you'll need to put a C wrapper around
the script.  A C wrapper is just a compiled program that does nothing
except call your Perl program.   Compiled programs are not subject to the
kernel bug that plagues set-id scripts.  Here's a simple wrapper, written
in C:

    #include <unistd.h>
    #include <stdio.h>
    #include <string.h>
    #include <errno.h>

    #define REAL_PATH "/path/to/script"

    int main(int argc, char **argv)
    {
        execv(REAL_PATH, argv);
        fprintf(stderr, "%s: %s: %s\n",
                        argv[0], REAL_PATH, strerror(errno));
        return 127;
    }

Compile this wrapper into a binary executable and then make I<it> rather
than your script setuid or setgid.  Note that this wrapper isn't doing
anything to sanitise the execution environment other than ensuring
that a safe path to the script is used.  It only avoids the shebang
race condition.  It relies on Perl's own features, and on the script
itself being careful, to make it safe enough to run the script set-id.

=head2 Protecting Your Programs

There are a number of ways to hide the source to your Perl programs,
with varying levels of "security".

First of all, however, you I<can't> take away read permission, because
the source code has to be readable in order to be compiled and
interpreted.  (That doesn't mean that a CGI script's source is
readable by people on the web, though.)  So you have to leave the
permissions at the socially friendly 0755 level.  This lets 
people on your local system only see your source.

Some people mistakenly regard this as a security problem.  If your program does
insecure things, and relies on people not knowing how to exploit those
insecurities, it is not secure.  It is often possible for someone to
determine the insecure things and exploit them without viewing the
source.  Security through obscurity, the name for hiding your bugs
instead of fixing them, is little security indeed.

You can try using encryption via source filters (Filter::* from CPAN,
or Filter::Util::Call and Filter::Simple since Perl 5.8).
But crackers might be able to decrypt it.  You can try using the byte
code compiler and interpreter described below, but crackers might be
able to de-compile it.  You can try using the native-code compiler
described below, but crackers might be able to disassemble it.  These
pose varying degrees of difficulty to people wanting to get at your
code, but none can definitively conceal it (this is true of every
language, not just Perl).

If you're concerned about people profiting from your code, then the
bottom line is that nothing but a restrictive license will give you
legal security.  License your software and pepper it with threatening
statements like "This is unpublished proprietary software of XYZ Corp.
Your access to it does not give you permission to use it blah blah
blah."  You should see a lawyer to be sure your license's wording will
stand up in court.

=head2 Unicode

Unicode is a new and complex technology and one may easily overlook
certain security pitfalls.  See L<perluniintro> for an overview and
L<perlunicode> for details, and L<perlunicode/"Security Implications
of Unicode"> for security implications in particular.

=head2 Algorithmic Complexity Attacks

Certain internal algorithms used in the implementation of Perl can
be attacked by choosing the input carefully to consume large amounts
of either time or space or both.  This can lead into the so-called
I<Denial of Service> (DoS) attacks.

=over 4

=item *

Hash Algorithm - Hash algorithms like the one used in Perl are well
known to be vulnerable to collision attacks on their hash function.
Such attacks involve constructing a set of keys which collide into
the same bucket producing inefficient behavior.  Such attacks often
depend on discovering the seed of the hash function used to map the
keys to buckets.  That seed is then used to brute-force a key set which
can be used to mount a denial of service attack.  In Perl 5.8.1 changes
were introduced to harden Perl to such attacks, and then later in
Perl 5.18.0 these features were enhanced and additional protections
added.

At the time of this writing, Perl 5.18.0 is considered to be
well-hardened against algorithmic complexity attacks on its hash
implementation.  This is largely owed to the following measures
mitigate attacks:

=over 4

=item Hash Seed Randomization

In order to make it impossible to know what seed to generate an attack
key set for, this seed is randomly initialized at process start.  This
may be overridden by using the PERL_HASH_SEED environment variable, see
L<perlrun/PERL_HASH_SEED>.  This environment variable controls how
items are actually stored, not how they are presented via
C<keys>, C<values> and C<each>.

=item Hash Traversal Randomization

Independent of which seed is used in the hash function, C<keys>,
C<values>, and C<each> return items in a per-hash randomized order.
Modifying a hash by insertion will change the iteration order of that hash.
This behavior can be overridden by using C<hash_traversal_mask()> from
L<Hash::Util> or by using the PERL_PERTURB_KEYS environment variable,
see L<perlrun/PERL_PERTURB_KEYS>.  Note that this feature controls the
"visible" order of the keys, and not the actual order they are stored in.

=item Bucket Order Perturbance

When items collide into a given hash bucket the order they are stored in
the chain is no longer predictable in Perl 5.18.  This
has the intention to make it harder to observe a
collision.  This behavior can be overridden by using
the PERL_PERTURB_KEYS environment variable, see L<perlrun/PERL_PERTURB_KEYS>.

=item New Default Hash Function

The default hash function has been modified with the intention of making
it harder to infer the hash seed.

=item Alternative Hash Functions

The source code includes multiple hash algorithms to choose from.  While we
believe that the default perl hash is robust to attack, we have included the
hash function Siphash as a fall-back option.  At the time of release of
Perl 5.18.0 Siphash is believed to be of cryptographic strength.  This is
not the default as it is much slower than the default hash.

=back

Without compiling a special Perl, there is no way to get the exact same
behavior of any versions prior to Perl 5.18.0.  The closest one can get
is by setting PERL_PERTURB_KEYS to 0 and setting the PERL_HASH_SEED
to a known value.  We do not advise those settings for production use
due to the above security considerations.

B<Perl has never guaranteed any ordering of the hash keys>, and
the ordering has already changed several times during the lifetime of
Perl 5.  Also, the ordering of hash keys has always been, and continues
to be, affected by the insertion order and the history of changes made
to the hash over its lifetime.

Also note that while the order of the hash elements might be
randomized, this "pseudo-ordering" should B<not> be used for
applications like shuffling a list randomly (use C<List::Util::shuffle()>
for that, see L<List::Util>, a standard core module since Perl 5.8.0;
or the CPAN module C<Algorithm::Numerical::Shuffle>), or for generating
permutations (use e.g. the CPAN modules C<Algorithm::Permute> or
C<Algorithm::FastPermute>), or for any cryptographic applications.

Tied hashes may have their own ordering and algorithmic complexity
attacks.

=item *

Regular expressions - Perl's regular expression engine is so called NFA
(Non-deterministic Finite Automaton), which among other things means that
it can rather easily consume large amounts of both time and space if the
regular expression may match in several ways.  Careful crafting of the
regular expressions can help but quite often there really isn't much
one can do (the book "Mastering Regular Expressions" is required
reading, see L<perlfaq2>).  Running out of space manifests itself by
Perl running out of memory.

=item *

Sorting - the quicksort algorithm used in Perls before 5.8.0 to
implement the sort() function was very easy to trick into misbehaving
so that it consumes a lot of time.  Starting from Perl 5.8.0 a different
sorting algorithm, mergesort, is used by default.  Mergesort cannot
misbehave on any input.

=back

See L<https://www.usenix.org/legacy/events/sec03/tech/full_papers/crosby/crosby.pdf> for more information,
and any computer science textbook on algorithmic complexity.

=head2 Using Sudo

The popular tool C<sudo> provides a controlled way for users to be able
to run programs as other users.  It sanitises the execution environment
to some extent, and will avoid the L<shebang race condition|/"Shebang
Race Condition">.  If you don't have the safe version of set-id scripts,
then C<sudo> may be a more convenient way of executing a script as
another user than writing a C wrapper would be.

However, C<sudo> sets the real user or group ID to that of the target
identity, not just the effective ID as set-id bits do.  As a result, Perl
can't detect that it is running under C<sudo>, and so won't automatically
take its own security precautions such as turning on taint mode.  Where
C<sudo> configuration dictates exactly which command can be run, the
approved command may include a C<-T> option to perl to enable taint mode.

In general, it is necessary to evaluate the suitability of a script to
run under C<sudo> specifically with that kind of execution environment
in mind.  It is neither necessary nor sufficient for the same script to
be suitable to run in a traditional set-id arrangement, though many of
the issues overlap.

=head1 SEE ALSO

L<perlrun/ENVIRONMENT> for its description of cleaning up environment
variables.
                                                                                                                                                                                                                                                                                      usr/local/lib/perl5/5.40.0/pod/perlsecpolicy.pod                                                    0000644 0000000 0000000 00000045362 14714567415 017663  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =encoding utf-8

=for stopwords
CVE perlsecpolicy SV perl Perl SDBM HackerOne Mitre

=head1 NAME

perlsecpolicy - Perl security report handling policy

=head1 DESCRIPTION

The Perl project takes security issues seriously.

The responsibility for handling security reports in a timely and
effective manner has been delegated to a security team composed
of a subset of the Perl core developers.

This document describes how the Perl security team operates and
how the team evaluates new security reports.

=head1 REPORTING SECURITY ISSUES IN PERL

If you believe you have found a security vulnerability in the Perl
interpreter or modules maintained in the core Perl codebase,
email the details to
L<perl-security@perl.org|mailto:perl-security@perl.org>.
This address is a closed membership mailing list monitored by the Perl
security team.

You should receive an initial response to your report within 72 hours.
If you do not receive a response in that time, please contact
the L<Perl Steering Council|mailto:steering-council@perl.org>.

When members of the security team reply to your messages, they will
generally include the perl-security@perl.org address in the "To" or "CC"
fields of the response. This allows all of the security team to follow
the discussion and chime in as needed. Use the "Reply-all" functionality
of your email client when you send subsequent responses so that the
entire security team receives the message.

The security team will evaluate your report and make an initial
determination of whether it is likely to fit the scope of issues the
team handles. General guidelines about how this is determined are
detailed in the L</WHAT ARE SECURITY ISSUES> section.

If your report meets the team's criteria, an issue will be opened in the
team's private issue tracker and you will be provided the issue's ID number.
Issue identifiers have the form perl-security#NNN. Include this identifier
with any subsequent messages you send.

The security team will send periodic updates about the status of your
issue and guide you through any further action that is required to complete
the vulnerability remediation process. The stages vulnerabilities typically
go through are explained in the L</HOW WE DEAL WITH SECURITY ISSUES>
section.

=head1 WHAT ARE SECURITY ISSUES

A vulnerability is a behavior of a software system that compromises the
system's expected confidentiality, integrity or availability protections.

A security issue is a bug in one or more specific components of a software
system that creates a vulnerability.

Software written in the Perl programming language is typically composed
of many layers of software written by many different groups. It can be
very complicated to determine which specific layer of a complex real-world
application was responsible for preventing a vulnerable behavior, but this
is an essential part of fixing the vulnerability.

=head2 Software covered by the Perl security team

The Perl security team handles security issues in:

=over

=item *

The Perl interpreter

=item *

The Perl modules shipped with the interpreter that are developed in the core
Perl repository

=item *

The command line tools shipped with the interpreter that are developed in the
core Perl repository

=back

Files under the F<cpan/> directory in Perl's repository and release tarballs are
developed and maintained independently. The Perl security team does not
directly handle security issues for these modules, but since this code is
bundled with Perl, we will assist in forwarding the issue to the relevant
maintainer(s) and you can still report these issues to us in secrecy.

=head2 Bugs that may qualify as security issues in Perl

Perl is designed to be a fast and flexible general purpose programming
language. The Perl interpreter and Perl modules make writing safe and
secure applications easy, but they do have limitations.

As a general rule, a bug in Perl needs to meet all of the following
criteria to be considered a security issue:

=over

=item *

The vulnerable behavior is not mentioned in Perl's documentation
or public issue tracker.

=item *

The vulnerable behavior is not implied by an expected behavior.

=item *

The vulnerable behavior is not a generally accepted limitation of
the implementation.

=item *

The vulnerable behavior is likely to be exposed to attack in
otherwise secure applications written in Perl.

=item *

The vulnerable behavior provides a specific tangible benefit
to an attacker that triggers the behavior.

=back

=head2 Bugs that do not qualify as security issues in Perl

There are certain categories of bugs that are frequently reported to
the security team that do not meet the criteria listed above.

The following is a list of commonly reported bugs that are not
handled as security issues.

=head3 Feeding untrusted code to the interpreter

The Perl parser is not designed to evaluate untrusted code.
If your application requires the evaluation of untrusted code, it
should rely on an operating system level sandbox for its security.

=head3 Stack overflows due to excessive recursion

Excessive recursion is often caused by code that does
not enforce limits on inputs. The Perl interpreter assumes limits
on recursion will be enforced by the application.

=head3 Out of memory errors

Common Perl constructs such as C<pack>, the C<x> operator,
and regular expressions accept numeric quantifiers that control how
much memory will be allocated to store intermediate values or results.
If you allow an attacker to supply these quantifiers and consume all
available memory, the Perl interpreter will not prevent it.

=head3 Escape from a L<Safe> compartment

L<Opcode> restrictions and L<Safe> compartments are not supported as
security mechanisms. The Perl parser is not designed to evaluate
untrusted code.

=head3 Use of the C<p> and C<P> pack templates

These templates are unsafe by design.

=head3 Stack not reference-counted issues

These bugs typically present as use-after-free errors or as assertion
failures on the type of a C<SV>. Stack not reference-counted
crashes usually occur because code is both modifying a reference or
glob and using the values referenced by that glob or reference.

This type of bug is a long standing issue with the Perl interpreter
that seldom occurs in normal code. Examples of this type of bug
generally assume that attacker-supplied code will be evaluated by
the Perl interpreter.

=head3 Thawing attacker-supplied data with L<Storable>

L<Storable> is designed to be a very fast serialization format.
It is not designed to be safe for deserializing untrusted inputs.

=head3 Using attacker supplied L<SDBM_File> databases

The L<SDBM_File> module is not intended for use with untrusted SDBM
databases.

=head3 Badly encoded UTF-8 flagged scalars

This type of bug occurs when the C<:utf8> PerlIO layer is used to
read badly encoded data, or other mechanisms are used to directly
manipulate the UTF-8 flag on an SV.

A badly encoded UTF-8 flagged SV is not a valid SV. Code that
creates SV's in this fashion is corrupting Perl's internal state.

=head3 Issues that exist only in blead, or in a release candidate

The blead branch and Perl release candidates do not receive security
support. Security defects that are present only in pre-release
versions of Perl are handled through the normal bug reporting and
resolution process.

=head3 CPAN modules or other Perl project resources

The Perl security team is focused on the Perl interpreter and modules
maintained in the core Perl codebase. The team has no special access
to fix CPAN modules, applications written in Perl, Perl project websites,
Perl mailing lists or the Perl IRC servers.

=head3 Emulated POSIX behaviors on Windows systems

The Perl interpreter attempts to emulate C<fork>, C<system>, C<exec>
and other POSIX behaviors on Windows systems. This emulation has many
quirks that are extensively documented in Perl's public issue tracker.
Changing these behaviors would cause significant disruption for existing
users on Windows.

=head2 Bugs that require special categorization

Some bugs in the Perl interpreter occur in areas of the codebase that are
both security sensitive and prone to failure during normal usage.

=head3 Regular expressions

Untrusted regular expressions are generally safe to compile and match against
with several caveats. The following behaviors of Perl's regular expression
engine are the developer's responsibility to constrain.

The evaluation of untrusted regular expressions while C<use re 'eval';> is
in effect is never safe.

Regular expressions are not guaranteed to compile or evaluate in any specific
finite time frame.

Regular expressions may consume all available system memory when they are
compiled or evaluated.

Regular expressions may cause excessive recursion that halts the perl
interpreter.

As a general rule, do not expect Perl's regular expression engine to
be resistant to denial of service attacks.

=head3 L<DB_File>, L<ODBM_File>, or L<GDBM_File> databases

These modules rely on external libraries to interact with database files.

Bugs caused by reading and writing these file formats are generally caused
by the underlying library implementation and are not security issues in
Perl.

Bugs where Perl mishandles unexpected valid return values from the underlying
libraries may qualify as security issues in Perl.

=head3 Algorithmic complexity attacks

The perl interpreter is reasonably robust to algorithmic complexity
attacks. It is not immune to them.

Algorithmic complexity bugs that depend on the interpreter processing
extremely large amounts of attacker supplied data are not generally handled
as security issues.

See L<perlsec/Algorithmic Complexity Attacks> for additional information.

=head1 HOW WE DEAL WITH SECURITY ISSUES

The Perl security team follows responsible disclosure practices. Security issues
are kept secret until a fix is readily available for most users. This minimizes
inherent risks users face from vulnerabilities in Perl.

Hiding problems from the users temporarily is a necessary trade-off to keep
them safe. Hiding problems from users permanently is not the goal.

When you report a security issue privately to the
L<perl-security@perl.org|mailto:perl-security@perl.org> contact address, we
normally expect you to follow responsible disclosure practices in the handling
of the report. If you are unable or unwilling to keep the issue secret until
a fix is available to users you should state this clearly in the initial
report.

The security team's vulnerability remediation workflow is intended to be as
open and transparent as possible about the state of your security report.

=head2 Perl's vulnerability remediation workflow

=head3 Initial contact

New vulnerability reports will receive an initial reply within 72 hours
from the time they arrive at the security team's mailing list. If you do
not receive any response in that time, contact the
L<Perl Steering Council|mailto:steering-council@perl.org>.

The initial response sent by the security team will confirm your message was
received and provide an estimated time frame for the security team's
triage analysis.

=head3 Initial triage

The security team will evaluate the report and determine whether or not
it is likely to meet the criteria for handling as a security issue.

The security team aims to complete the initial report triage within
two weeks' time. Complex issues that require significant discussion or
research may take longer.

If the security report cannot be reproduced or does not meet the team's
criteria for handling as a security issue, you will be notified by email
and given an opportunity to respond.

=head3 Issue ID assignment

Security reports that pass initial triage analysis are turned into issues
in the security team's private issue tracker. When a report progresses to
this point you will be provided the issue ID for future reference. These
identifiers have the format perl-security#NNN or Perl/perl-security#NNN.

The assignment of an issue ID does not confirm that a security report
represents a vulnerability in Perl. Many reports require further analysis
to reach that determination.

Issues in the security team's private tracker are used to collect details
about the problem and track progress towards a resolution. These notes and
other details are not made public when the issue is resolved. Keeping the
issue notes private allows the security team to freely discuss attack
methods, attack tools, and other related private issues.

=head3 Development of patches

Members of the security team will inspect the report and related code in
detail to produce fixes for supported versions of Perl.

If the team discovers that the reported issue does not meet the team's
criteria at this stage, you will be notified by email and given an
opportunity to respond before the issue is closed.

The team may discuss potential fixes with you or provide you with
patches for testing purposes during this time frame. No information
should be shared publicly at this stage.

=head3 CVE ID assignment

Once an issue is fully confirmed and a potential fix has been found,
the security team will request a CVE identifier for the issue to use
in public announcements.

Details like the range of vulnerable Perl versions and identities
of the people that discovered the flaw need to be collected to submit
the CVE ID request.

The security team may ask you to clarify the exact name we should use
when crediting discovery of the issue. The
L</Vulnerability credit and bounties> section of this document
explains our preferred format for this credit.

Once a CVE ID has been assigned, you will be notified by email.
The vulnerability should not be discussed publicly at this stage.

=head3 Pre-release notifications

When the security team is satisfied that the fix for a security issue
is ready to release publicly, a pre-release notification
announcement is sent to the major redistributors of Perl.

This pre-release announcement includes a list of Perl versions that
are affected by the flaw, an analysis of the risks to users, patches
the security team has produced, and any information about mitigations
or backporting fixes to older versions of Perl that the security team
has available.

The pre-release announcement will include a specific target date
when the issue will be announced publicly. The time frame between
the pre-release announcement and the release date allows redistributors
to prepare and test their own updates and announcements. During this
period the vulnerability details and fixes are embargoed and should not
be shared publicly. This embargo period may be extended further if
problems are discovered during testing.

You will be sent the portions of pre-release announcements that are
relevant to the specific issue you reported. This email will include
the target release date. Additional updates will be sent if the
target release date changes.

=head3 Pre-release testing

The Perl security team does not directly produce official Perl
releases. The team releases security fixes by placing commits
in Perl's public git repository and sending announcements.

Many users and redistributors prefer using official Perl releases
rather than applying patches to an older release. The security
team works with Perl's release managers to make this possible.

New official releases of Perl are generally produced and tested
on private systems during the pre-release embargo period.

=head3 Release of fixes and announcements

At the end of the embargo period the security fixes will be
committed to Perl's public git repository and announcements will be
sent to the L<perl5-porters|https://lists.perl.org/list/perl5-porters.html>
and L<oss-security|https://oss-security.openwall.org/wiki/mailing-lists/oss-security>
mailing lists.

If official Perl releases are ready, they will be published at this time
and announced on the L<perl5-porters|https://lists.perl.org/list/perl5-porters.html>
mailing list.

The security team will send a follow-up notification to everyone that
participated in the pre-release embargo period once the release process is
finished. Vulnerability reporters and Perl redistributors should not publish
their own announcements or fixes until the Perl security team's release process
is complete.

=head2 Publicly known and zero-day security issues

The security team's vulnerability remediation workflow assumes that issues
are reported privately and kept secret until they are resolved. This isn't
always the case and information occasionally leaks out before a fix is ready.

In these situations the team must decide whether operating in secret increases
or decreases the risk to users of Perl. In some cases being open about
the risk a security issue creates will allow users to defend against it,
in other cases calling attention to an unresolved security issue will
make it more likely to be misused.

=head3 Zero-day security issues

If an unresolved critical security issue in Perl is being actively abused to
attack systems the security team will send out announcements as rapidly as
possible with any mitigations the team has available.

Perl's public defect tracker will be used to handle the issue so that additional
information, fixes, and CVE IDs are visible to affected users as rapidly as
possible.

=head3 Other leaks of security issue information

Depending on the prominence of the information revealed about a security
issue and the issue's risk of becoming a zero-day attack, the security team may
skip all or part of its normal remediation workflow.

If the security team learns of a significant security issue after it has been
identified and resolved in Perl's public issue tracker, the team will
request a CVE ID and send an announcement to inform users.

=head2 Vulnerability credit and bounties

The Perl project appreciates the effort security researchers
invest in making Perl safe and secure.

Since much of this work is hidden from the public, crediting
researchers publicly is an important part of the vulnerability
remediation process.

=head3 Credits in vulnerability announcements

When security issues are fixed we will attempt to credit the specific
researcher(s) that discovered the flaw in our announcements.

Credits are announced using the researcher's preferred full name.

If the researcher's contributions were funded by a specific company or
part of an organized vulnerability research project, we will include
a short name for this group at the researcher's request.

Perl's announcements are written in the English language using the 7bit
ASCII character set to be reproducible in a variety of formats. We
do not include hyperlinks, domain names or marketing material with these
acknowledgments.

In the event that proper credit for vulnerability discovery cannot be
established or there is a disagreement between the Perl security team
and the researcher about how the credit should be given, it will be
omitted from announcements.

=head3 Bounties for Perl vulnerabilities

The Perl project is a non-profit volunteer effort. We do not provide
any monetary rewards for reporting security issues in Perl.

=cut
                                                                                                                                                                                                                                                                              usr/local/lib/perl5/5.40.0/pod/perlsolaris.pod                                                      0000644 0000000 0000000 00000072224 14714567415 017342  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # vim: syntax=pod

If you read this file _as_is_, just ignore the funny characters you
see.  It is written in the POD format (see pod/perlpod.pod) which is
specifically designed to be readable as is.

=head1 NAME

perlsolaris - Perl version 5 on Solaris systems

=head1 DESCRIPTION

This document describes various features of Sun's Solaris operating system
that will affect how Perl version 5 (hereafter just perl) is
compiled and/or runs.  Some issues relating to the older SunOS 4.x are
also discussed, though they may be out of date.

For the most part, everything should just work.

Starting with Solaris 8, perl5.00503 (or higher) is supplied with the
operating system, so you might not even need to build a newer version
of perl at all.  The Sun-supplied version is installed in /usr/perl5
with F</usr/bin/perl> pointing to F</usr/perl5/bin/perl>.  Do not disturb
that installation unless you really know what you are doing.  If you
remove the perl supplied with the OS, you will render some bits of
your system inoperable.  If you wish to install a newer version of perl,
install it under a different prefix from /usr/perl5.  Common prefixes
to use are /usr/local and /opt/perl.

You may wish to put your version of perl in the PATH of all users by
changing the link F</usr/bin/perl>.  This is probably OK, as most perl
scripts shipped with Solaris use an explicit path.  (There are a few
exceptions, such as F</usr/bin/rpm2cpio> and F</etc/rcm/scripts/README>, but
these are also sufficiently generic that the actual version of perl
probably doesn't matter too much.)

Solaris ships with a range of Solaris-specific modules.  If you choose
to install your own version of perl you will find the source of many of
these modules is available on CPAN under the Sun::Solaris:: namespace.

Solaris may include two versions of perl, e.g. Solaris 9 includes
both 5.005_03 and 5.6.1.  This is to provide stability across Solaris
releases, in cases where a later perl version has incompatibilities
with the version included in the preceding Solaris release.  The
default perl version will always be the most recent, and in general
the old version will only be retained for one Solaris release.  Note
also that the default perl will NOT be configured to search for modules
in the older version, again due to compatibility/stability concerns.
As a consequence if you upgrade Solaris, you will have to
rebuild/reinstall any additional CPAN modules that you installed for
the previous Solaris version.  See the CPAN manpage under 'autobundle'
for a quick way of doing this.

As an interim measure, you may either change the #! line of your
scripts to specifically refer to the old perl version, e.g. on
Solaris 9 use #!/usr/perl5/5.00503/bin/perl to use the perl version
that was the default for Solaris 8, or if you have a large number of
scripts it may be more convenient to make the old version of perl the
default on your system.  You can do this by changing the appropriate
symlinks under /usr/perl5 as follows (example for Solaris 9):

 # cd /usr/perl5
 # rm bin man pod
 # ln -s ./5.00503/bin
 # ln -s ./5.00503/man
 # ln -s ./5.00503/lib/pod
 # rm /usr/bin/perl
 # ln -s ../perl5/5.00503/bin/perl /usr/bin/perl

In both cases this should only be considered to be a temporary
measure - you should upgrade to the later version of perl as soon as
is practicable.

Note also that the perl command-line utilities (e.g. perldoc) and any
that are added by modules that you install will be under
/usr/perl5/bin, so that directory should be added to your PATH.

=head2 Solaris Version Numbers

For consistency with common usage, perl's Configure script performs
some minor manipulations on the operating system name and version
number as reported by uname.  Here's a partial translation table:

          Sun:                      perl's Configure:
 uname    uname -r   Name           osname     osvers
 SunOS    4.1.3     Solaris 1.1     sunos      4.1.3
 SunOS    5.6       Solaris 2.6     solaris    2.6
 SunOS    5.8       Solaris 8       solaris    2.8
 SunOS    5.9       Solaris 9       solaris    2.9
 SunOS    5.10      Solaris 10      solaris    2.10

The complete table can be found in the Sun Managers' FAQ
L<ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq> under
"9.1) Which Sun models run which versions of SunOS?".

=head1 RESOURCES

There are many, many sources for Solaris information.  A few of the
important ones for perl:

=over 4

=item Solaris FAQ

The Solaris FAQ is available at
L<http://www.science.uva.nl/pub/solaris/solaris2.html>.

The Sun Managers' FAQ is available at
L<ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq>

=item Precompiled Binaries

Precompiled binaries, links to many sites, and much, much more are
available at L<http://www.sunfreeware.com/> and
L<http://www.blastwave.org/>.

=item Solaris Documentation

All Solaris documentation is available on-line at L<http://docs.sun.com/>.

=back

=head1 SETTING UP

=head2 File Extraction Problems on Solaris

Be sure to use a tar program compiled under Solaris (not SunOS 4.x)
to extract the perl-5.x.x.tar.gz file.  Do not use GNU tar compiled
for SunOS4 on Solaris.  (GNU tar compiled for Solaris should be fine.)
When you run SunOS4 binaries on Solaris, the run-time system magically
alters pathnames matching m#lib/locale# so that when tar tries to create
lib/locale.pm, a file named lib/oldlocale.pm gets created instead.
If you found this advice too late and used a SunOS4-compiled tar
anyway, you must find the incorrectly renamed file and move it back
to lib/locale.pm.

=head2 Compiler and Related Tools on Solaris

You must use an ANSI C compiler to build perl.  Perl can be compiled
with either Sun's add-on C compiler or with gcc.  The C compiler that
shipped with SunOS4 will not do.

=head3 Include /usr/ccs/bin/ in your PATH

Several tools needed to build perl are located in /usr/ccs/bin/:  ar,
as, ld, and make.  Make sure that /usr/ccs/bin/ is in your PATH.


On all the released versions of Solaris (8, 9 and 10) you need to make sure the following packages are installed (this info is extracted from the Solaris FAQ):

for tools (sccs, lex, yacc, make, nm, truss, ld, as): SUNWbtool,
SUNWsprot, SUNWtoo

for libraries & headers: SUNWhea, SUNWarc, SUNWlibm, SUNWlibms, SUNWdfbh,
SUNWcg6h, SUNWxwinc

Additionally, on Solaris 8 and 9 you also need:

for 64 bit development: SUNWarcx, SUNWbtoox, SUNWdplx, SUNWscpux,
SUNWsprox, SUNWtoox, SUNWlmsx, SUNWlmx, SUNWlibCx

And only on Solaris 8 you also need:

for libraries & headers: SUNWolinc


If you are in doubt which package contains a file you are missing,
try to find an installation that has that file. Then do a

 $ grep /my/missing/file /var/sadm/install/contents

This will display a line like this:

/usr/include/sys/errno.h f none 0644 root bin 7471 37605 956241356 SUNWhea

The last item listed (SUNWhea in this example) is the package you need.

=head3 Avoid /usr/ucb/cc

