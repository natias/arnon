BLOCK

A curly-braced code block, or a subroutine reference.

=item *

LIST

Any number of values, stored across any number of variables or
expressions, which the function will "flatten" and treat as a single
list. (And because it can contain any number of variables, it must be
the I<last> argument, when present.)

=back

When possible, give scalar arguments names that suggest their purpose
among the arguments. See, for example, L<C<substr>'s
documentation|perlfunc/substr>, whose
listed arguments include C<EXPR>, C<OFFSET>, C<LENGTH>, and C<REPLACEMENT>.

=head3 Apostrophes, quotes, and dashes

In Pod source, use straight quotes, and not "curly quotes":  "Like
 this", not “like this”. The same goes for apostrophes:  Here's a
 positive example, and here’s a negative one.

Render em dashes as two hyphens--like this:

    Render em dashes as two hyphens--like this.

Leave it up to formatters to reformat and reshape these punctuation
marks as best fits their respective target media.

=head3 Unix programs and C functions

When referring to a Unix program or C function with its own man page
(outside of Perl's documentation), include its manual section number in
parentheses. For example: C<malloc(3)>, or C<mkdir(1)>.

If mentioning this program for the first time within a man page or
section, make it a cross reference, e.g. C<LE<lt>malloc(3)E<gt>>.

Do not otherwise style this text.

=head3 Cross-references and hyperlinks

Make generous use of Pod's C<LE<lt>...E<gt>> syntax to create hyperlinks
to other parts of the current man page, or to other documents entirely
-- whether elsewhere on the reader's computer, or somewhere on the
internet, via URL.

Use C<LE<lt>...E<gt>> to link to another section of the current man page
when mentioning it, and make use of its page-and-section syntax to link to
the most specific section of a separate page within Perl's
documentation. Generally, the first time you refer to a specific
function, program, or concept within a certain page or section, consider
linking to its full documentation.

Hyperlinks do not supersede other formatting required by this guide; Pod
allows nested text formats, and you should use this feature as needed.

Here is an example sentence that mentions Perl's C<say> function, with a
link to its documentation section within the C<perlfunc> man page:

    In version 5.10, Perl added support for the 
    L<C<say>|perlfunc/say FILEHANDLE LIST> function.

Note the use of the vertical pipe ("C<|>") to separate how the link will
appear to readers ("C<CE<lt>sayE<gt>>") from the full page-and-section specifier
that the formatter links to.

=head3 Tables and diagrams

Pod does not officially support tables. To best present tabular data,
include the table as both HTML and plain-text representations--the
latter as an indented code block. Use C<=begin> / C<=end> directives to
target these tables at C<html> and C<text> Pod formatters, respectively.
For example:

    =head2 Table of fruits

    =begin text

     Name           Shape           Color
     =====================================
     Apple          Round           Red
     Banana         Long            Yellow
     Pear           Pear-shaped     Green

    =end text

    =begin html

    <table>
    <tr><th>Name</th><th>Shape</th><th>Color</th></tr>
    <tr><td>Apple</td><td>Round</td><td>Red</td></tr>
    <tr><td>Banana</td><td>Long</td><td>Yellow</td></tr>
    <tr><td>Pear</td><td>Pear-shaped</td><td>Green</td></tr>
    </table>

    =end html

The same holds true for figures and graphical illustrations. Pod does
not natively support inline graphics, but you can mix HTML C<<< <img> >>> tags
with monospaced text-art representations of those images' content.

Due in part to these limitations, most Perl man pages use neither tables
nor diagrams. Like any other tool in your documentation toolkit,
however, you may consider their inclusion when they would improve an
explanation's clarity without adding to its complexity.

=head2 Adding comments

Like any other kind of source code, Pod lets you insert comments visible
only to other people reading the source directly, and ignored by the
formatting programs that transform Pod into various human-friendly
output formats (such as HTML or PDF). 

To comment Pod text, use the C<=for> and C<=begin> / C<=end> Pod
directives, aiming them at a (notional) formatter called "C<comment>". A
couple of examples:

    =for comment Using "=for comment" like this is good for short,
    single-paragraph comments.

    =begin comment

    If you need to comment out more than one paragraph, use a
    =begin/=end block, like this.

    None of the text or markup in this whole example would be visible to
    someone reading the documentation through normal means, so it's
    great for leaving notes, explanations, or suggestions for your
    fellow documentation writers.

    =end comment

In the tradition of any good open-source project, you should make free
but judicious use of comments to leave in-line "meta-documentation" as
needed for other Perl documentation writers (including your future
self).

=head2 Perlfunc has special rules

The L<C<perlfunc> man page|perlfunc>, an exhaustive reference of every
Perl built-in function, has a handful of formatting rules not seen
elsewhere in Perl's documentation.

Software used during Perl's build process
(L<Pod::Functions|Pod::Functions>) parses this page according to certain
rules, in order to build separate man pages for each of Perl's
functions, as well as achieve other indexing effects. As such,
contributors to perlfunc must know about and adhere to its particular
rules.

Most of the perfunc man page comprises a single list, found under the
header L<"Alphabetical Listing of Perl Functions"|perlfunc/Alphabetical
Listing of Perl Functions>. Each function reference is an entry on that
list, made of three parts, in order:

=over

=item 1.

A list of C<=item> lines which each demonstrate, in template format, a
way to call this function. One line should exist for every combination
of arguments that the function accepts (including no arguments at all,
if applicable).

If modern best practices prefer certain ways to invoke the function
over others, then those ways should lead the list.

The first item of the list should be immediately followed by one or
more C<XE<lt>...E<gt>> terms listing index-worthy topics; if nothing
else, then the name of the function, with no arguments.

=item 2.

A C<=for> line, directed at C<Pod::Functions>, containing a one-line
description of what the function does. This is written as a phrase, led
with an imperative verb, with neither leading capitalization nor ending
punctuation. Examples include "quote a list of words" and "change a
filename".

=item 3.

The function's definition and reference material, including all
explanatory text and code examples.

=back

Complex functions that need their text divided into subsections (under
the principles of L<"Apply section-breaks and examples
generously"|/Apply section-breaks and examples generously>) may do so by
using sublists, with C<=item> elements as header text.

A fictional function "C<myfunc>", which takes a list as an optional
argument, might have an entry in perlfunc shaped like this:

    =item myfunc LIST
    X<myfunc>

    =item myfunc

    =for Pod::Functions demonstrate a function's perlfunc section 

    [ Main part of function definition goes here, with examples ]

    =over

    =item Legacy uses

    [ Examples of deprecated syntax still worth documenting ]

    =item Security considerations

    [ And so on... ]

    =back

=head1 TONE AND STYLE

=head2 Apply one of the four documentation modes

Aside from "meta" documentation such as C<perlhist> or C<perlartistic>,
each of Perl's man pages should conform to one of the four documentation
"modes" suggested by L<I<The Documentation System> by Daniele
Procida|https://documentation.divio.com>. These include tutorials,
cookbooks, explainers, and references--terms that we define in further
detail below.

Each mode of documentation speaks to a different audience--not just
people of different backgrounds and skill levels, but individual readers
whose needs from language documentation can shift depending upon
context. For example, a programmer with plenty of time to learn a new
concept about Perl can ease into a tutorial about it, and later expand
their knowledge further by studying an explainer. Later, that same
programmer, wading knee-deep in live code and needing only to look up
some function's exact syntax, will want to reach for a reference page
instead.

Perl's documentation must strive to meet these different situational
expectations by limiting each man page to a single mode. This helps
writers ensure they provide readers with the documentation needed or
expected, despite ever-evolving situations.

=head3 Tutorial

A tutorial man page focuses on B<learning>, ideally by I<doing>. It
presents the reader with small, interesting examples that allow them to
follow along themselves using their own Perl interpreter. The tutorial
inspires comprehension by letting its readers immediately experience
(and experiment on) the concept in question. Examples include
C<perlxstut>, C<perlpacktut>, and
C<perlretut>.

Tutorial man pages must strive for a welcoming and reassuring tone from
their outset; they may very well be the first things that a newcomer to
Perl reads, playing a significant role in whether they choose
to stick around. Even an experienced programmer can benefit from the
sense of courage imparted by a strong tutorial about a more advanced
topic. After completing a tutorial, a reader should feel like they've
been led from zero knowledge of its topic to having an invigorating
spark of basic understanding, excited to learn more and experiment
further.

Tutorials can certainly use real-world examples when that helps make for
clear, relatable demonstrations, so long as they keep the focus on
teaching--more practical problem-solving should be left to the realm
of cookbooks (as described below). Tutorials also needn't concern
themselves with explanations into why or how things work beneath the
surface, or explorations of alternate syntaxes and solutions; these are
better handled by explainers and reference pages.

=head3 Cookbook

A cookbook man page focuses on B<results>. Just like its name suggests,
it presents succinct, step-by-step solutions to a variety of real-world
problems around some topic. A cookbook's code examples serve less to
enlighten and more to provide quick, paste-ready solutions that the
reader can apply immediately to the situation facing them.

A Perl cookbook demonstrates ways that all the tools and techniques
explained elsewhere can work together in order to achieve practical
results. Any explanation deeper than that belongs in explainers and
reference pages, instead. (Certainly, a cookbook can cross-reference
other man pages in order to satisfy the curiosity of readers who, with
their immediate problems solved, wish to learn more.)

The most prominent cookbook pages that ship with Perl itself are its
many FAQ pages, in particular C<perlfaq4> and up, which provide short
solutions to practical questions in question-and-answer style.
C<perlunicook> shows another example, containing a bevy of practical code
snippets for a variety of internationally minded text manipulations.

(An aside: I<The Documentation System> calls this mode "how-to", but
Perl's history of creative cuisine prefers the more kitchen-ready term
that we employ here.)

=head3 Reference

A reference page focuses on B<description>. Austere, uniform, and
succinct, reference pages--often arranged into a whole section of
mutually similar subpages--lend themselves well to "random access" by
a reader who knows precisely what knowledge they need, requiring only
the minimum amount of information before returning to the task at hand.

Perl's own best example of a reference work is C<perlfunc>, the
sprawling man page that details the operation of every function built
into Perl, with each function's documentation presenting the same kinds
of information in the same order as every other. For an example of a
shorter reference on a single topic, look at C<perlreref>.

Module documentation--including that of all the modules listed in
L<C<perlmodlib>|perlmodlib>--also counts as reference. They follow
precepts similar to those laid down by the C<perlpodstyle> man page, such
as opening with an example-laden "SYNOPSIS" section, or featuring a
"METHODS" section that succinctly lists and defines an object-oriented
module's public interface.

=head3 Explainer

Explainer pages focus on B<discussion>. Each explainer dives as deep as
needed into some Perl-relevant topic, taking all the time and space
needed to give the reader a thorough understanding of it. Explainers
mean to impart knowledge through study. They don't assume that the
student has a Perl interpreter fired up and hungry for immediate examples
(as with a tutorial), or specific Perl problems that they need quick
answers for (which cookbooks and reference pages can help with).

Outside of its reference pages, most of Perl's manual belongs to this
mode. This includes the majority of the man pages whose names start with
"C<perl>". A fine example is C<perlsyn>, the Perl Syntax page, which
explores the whys and wherefores of Perl's unique syntax in a
wide-ranging discussion laden with many references to the language's
history, culture, and driving philosophies.

Perl's explainer pages give authors a chance to explore Perl's penchant
for L<TMTOWTDI|perlglossary/TMTOWTDI>, illustrating alternate and even
obscure ways to use the language feature under discussion. However, as
the remainder of this guide discusses, the ideal Perl documentation
manages to deliver its message clearly and concisely, and not confuse
mere wordiness for completeness.

=head3 Further notes on documentation modes

Keep in mind that the purpose of this categorization is not to dictate
content--a very thorough explainer might contain short reference
sections of its own, for example, or a reference page about a very
complex function might resemble an explainer in places (e.g.
L<C<open>|perlfunc/open FILEHANDLE,MODE,EXPR>). Rather, it makes sure
that the authors and contributors of any given man page agree on what
sort of audience that page addresses.

If a new or otherwise uncategorized man page presents itself as
resistant to fitting into only one of the four modes, consider breaking
it up into separate pages. That may mean creating a new "C<perl[...]>"
man page, or (in the case of module documentation) making new packages
underneath that module's namespace that serve only to hold additional
documentation. For instance, C<Example::Module>'s reference documentation
might include a see-also link to C<Example::Module::Cookbook>.

Perl's several man pages about Unicode--comprising a short tutorial, a
thorough explainer, a cookbook, and a FAQ--provide a fine example of
spreading a complicated topic across several man pages with different
and clearly indicated purposes.

=head2 Assume readers' intelligence, but not their knowledge

Perl has grown a great deal from its humble beginnings as a tool for
people already well versed in C programming and various Unix utilities.
Today, a person learning Perl might come from any social or
technological background, with a range of possible motivations
stretching far beyond system administration.

Perl's core documentation must recognize this by making as few
assumptions as possible about the reader's prior knowledge. While you
should assume that readers of Perl's documentation are smart, curious,
and eager to learn, you should not confuse this for pre-existing
knowledge about any other technology, or even programming in
general--especially in tutorial or introductory material.

=head3 Keep Perl's documentation about Perl

Outside of pages tasked specifically with exploring Perl's relationship
with other programming languages, the documentation should keep the
focus on Perl. Avoid drawing analogies to other technologies that the
reader may not have familiarity with.

For example, when documenting one of Perl's built-in functions, write as
if the reader is now learning about that function for the first time, in
any programming language.

Choosing to instead compare it to an equivalent or underlying C function
will probably not illuminate much understanding in a contemporary
reader. Worse, this can risk leaving readers unfamiliar with C feeling
locked out from fully understanding of the topic--to say nothing of
readers new to computer programming altogether.

If, however, that function's ties to its C roots can lead to deeper
understanding with practical applications for a Perl programmer, you may
mention that link after its more immediately useful documentation.
Otherwise, omit this information entirely, leaving it for other
documentation or external articles more concerned with examining Perl's
underlying implementation details.

=head3 Deploy jargon when needed, but define it as well

Domain-specific jargon has its place, especially within documentation.
However, if a man page makes use of jargon that a typical reader might
not already know, then that page should make an effort to define the
term in question early-on--either explicitly, or via cross reference.

For example, Perl loves working with filehandles, and as such that word
appears throughout its documentation. A new Perl programmer arriving at
a man page for the first time is quite likely to have no idea what a
"filehandle" is, though. Any Perl man page mentioning filehandles
should, at the very least, hyperlink that term to an explanation
elsewhere in Perl's documentation. If appropriate--for example, in the
lead-in to L<C<open> function's detailed reference|perlfunc/open
FILEHANDLE,MODE,EXPR>--it can also include a very short in-place
definition of the concept for the reader's convenience.

=head2 Use meaningful variable and symbol names in examples

When quickly sketching out examples, English-speaking programmers have a
long tradition of using short nonsense words as placeholders for
variables and other symbols--such as the venerable C<foo>, C<bar>, and
C<baz>. Example code found in a programming language's official,
permanent documentation, however, can and should make an effort to
provide a little more clarity through specificity.

Whenever possible, code examples should give variables, classes, and
other programmer-defined symbols names that clearly demonstrate their
function and their relationship to one another. For example, if an
example requires that one class show an "is-a" relationship with
another, consider naming them something like C<Apple> and C<Fruit>, rather
than C<Foo> and C<Bar>. Similarly, sample code creating an instance of
that class would do better to name it C<$apple>, rather than C<$baz>.

Even the simplest examples benefit from clear language using concrete
words. Prefer a construct like C<for my $item (@items) { ... }> over
C<for my $blah (@blah) { ... }>.

=head2 Write in English, but not just for English-speakers

While this style guide does specify American English as the
documentation's language for the sake of internal consistency, authors
should avoid cultural or idiomatic references available only to
English-speaking Americans (or any other specific culture or society).
As much as possible, the language employed by Perl's core documentation
should strive towards cultural universality, if not neutrality. Regional
turns of phrase, examples drawing on popular-culture knowledge, and
other rhetorical techniques of that nature should appear sparingly, if
at all.

Authors should feel free to let more freewheeling language flourish in
"second-order" documentation about Perl, like books, blog entries, and
magazine articles, published elsewhere and with a narrower readership in
mind. But Perl's own docs should use language as accessible and
welcoming to as wide an audience as possible.

=head2 Omit placeholder text or commentary

Placeholder text does not belong in the documentation that ships with
Perl. No section header should be followed by text reading only "Watch
this space", "To be included later", or the like. While Perl's source
files may shift and alter as much as any other actively maintained
technology, each released iteration of its technology should feel
complete and self-contained, with no such future promises or other loose
ends visible.

Take advantage of Perl's regular release cycle. Instead of cluttering
the docs with flags promising more information later--the presence of
which do not help readers at all today--the documentation's
maintenance team should treat any known documentation absences as an
issue to address like any other in the Perl project. Let Perl's
contributors, testers, and release engineers address that need, and
resist the temptation to insert apologies, which have all the utility in
documentation as undeleted debug messages do in production code.

=head2 Apply section-breaks and examples generously

No matter how accessible their tone, the sight of monolithic blocks of
text in technical documentation can present a will-weakening challenge
for the reader. Authors can improve this situation through breaking long
passages up into subsections with short, meaningful headers.

Since every section-header in Pod also acts as a potential end-point for
a cross-reference (made via Pod's C<LE<lt>...E<gt>> syntax), putting
plenty of subsections in your documentation lets other man pages more
precisely link to a particular topic. This creates hyperlinks directly
to the most appropriate section rather than to the whole page in
general, and helps create a more cohesive sense of a rich, consistent,
and interrelated manual for readers.

Among the four documentation modes, sections belong more naturally in
tutorials and explainers. The step-by-step instructions of cookbooks, or
the austere definitions of reference pages, usually have no room for
them. But authors can always make exceptions for unusually complex
concepts that require further breakdown for clarity's sake.

Example code, on the other hand, can be a welcome addition to any mode
of documentation. Code blocks help break up a man page visually,
reassuring the reader that no matter how deep the textual explanation
gets, they are never far from another practical example showing how it
all comes together using a small, easy-to-read snippet of tested Perl
code.

=head2 Lead with common cases and best practices

Perl famously gives programmers more than one way to do things. Like any
other long-lived programming language, Perl has also built up a large,
community-held notion of best practices, blessing some ways to do things
as better than others, usually for the sake of more maintainable code.

=head3 Show the better ways first

Whenever it needs to show the rules for a technique which Perl provides
many avenues for, the documentation should always lead with best
practices. And when discussing some part of the Perl toolkit with many
applications, the docs should begin with a demonstration of its
application to the most common cases.

The C<open> function, for example, has myriad potential uses within Perl
programs, but I<most of the time> programmers--and especially those new
to Perl--turn to this reference because they simply wish to open a
file for reading or writing. For this reason, C<open>'s documentation
begins there, and only descends into the function's more obscure uses
after thoroughly documenting and demonstrating how it works in the
common case. Furthermore, while engaging in this demonstration, the
C<open> documentation does not burden the reader right away with detailed
explanations about calling C<open> via any route other than the
best-practice, three-argument style. 

=head3 Show the lesser ways when needed

Sometimes, thoroughness demands documentation of deprecated techniques.
For example, a certain Perl function might have an alternate syntax now
considered outmoded and no longer best-practice, but which a maintainer
of a legacy project might quite reasonably encounter when exploring old
code. In this case, these features deserve documentation, but couched in
clarity that modern Perl avoids such structures, and does not recommend
their use in new projects.

Another way to look at this philosophy (and one L<borrowed from our
friends|https://devguide.python.org/documenting/#affirmative-tone> on
Python's documentation team) involves writing while sympathizing with a
programmer new to Perl, who may feel uncertain about learning a complex
concept. By leading that concept's main documentation with clear,
positive examples, we can immediately give these readers a simple and
true picture of how it works in Perl, and boost their own confidence to
start making use of this new knowledge. Certainly we should include
alternate routes and admonitions as reasonably required, but we needn't
emphasize them. Trust the reader to understand the basics quickly, and
to keep reading for a deeper understanding if they feel so driven.

=head2 Document Perl's present

Perl's documentation should stay focused on Perl's present behavior,
with a nod to future directions.

=head3 Recount the past only when necessary

=for comment
The principles of this section caused a lot of lively discussion and
debate among p5p when first proposed in October 2020. I am keeping the
recommendations nonspecific, and expect this section to receive a lot of
further refinement as we start to apply it to core docs.

When some Perl feature changes its behavior, documentation about
that feature should change too, and just as definitively. The docs have
no obligation to keep descriptions of past behavior hanging around, even if
attaching clauses like "Prior to version 5.10, [...]".

Since Perl's core documentation is part of Perl's source distribution,
it enjoys the same benefits of versioning and version-control as the
source code of Perl itself. Take advantage of this, and update the text
boldly when needed. Perl's history remains safe, even when you delete or
replace outdated information from the current version's docs.

Perl's docs can acknowledge or discuss former behavior when warranted,
including notes that some feature appeared in the language as of some
specific version number. Authors should consider applying principles
similar to those for deprecated techniques, L<as described above|/Show
the lesser ways when needed>: make the information present, but not
prominent.

Otherwise, keep the past in the past. A manual uncluttered with
outdated instruction stays more succinct and relevant.

=head3 Describe the uncertain future with care

Perl features marked as "experimental"--those that generate warnings
when used in code not invoking the L<C<experimental>|experimental>
pragma--deserve documentation, but only in certain contexts, and even
then with caveats. These features represent possible new directions for
Perl, but they have unstable interfaces and uncertain future presence.

The documentation should take both implications of "experimental"
literally. It should not discourage these features' use by programmers
who wish to try out new features in projects that can risk their
inherent instability; this experimentation can help Perl grow and
improve. By the same token, the docs should downplay these features' use
in just about every other context.

Introductory or overview material should omit coverage of experimental
features altogether.

More thorough reference materials or explanatory articles can include
experimental features, but needs to clearly mark them as such, and not
treat them with the same prominence as Perl's stable features. Using
unstable features seldom coincides with best practices, and
documentation that L<puts best practices first|/Lead with common cases
and best practices> should reflect this.

=head2 The documentation speaks with one voice

Even though it comes from many hands and minds, criss-crossing through
the many years of Perl's lifetime, the language's documentation should
speak with a single, consistent voice. With few exceptions, the docs
should avoid explicit first-person-singular statements, or similar
self-reference to any individual's contributor's philosophies or
experiences.

Perl did begin life as a deeply personal expression by a single
individual, and this famously carried through the first revisions of its
documentation as well. Today, Perl's community understands that the
language's continued development and support comes from many people
working in concert, rather than any one person's vision or effort. Its
documentation should not pretend otherwise.

The documentation should, however, carry forward the best tradition that
Larry Wall set forth in the language's earliest days: Write both
economically and with a humble, subtle wit, resulting in a technical
manual that mixes concision with a friendly approachability. It avoids
the dryness that one might expect from technical documentation, while
not leaning so hard into overt comedy as to distract and confuse from
the nonetheless-technical topics at hand.

Like the best written works, Perl's documentation has a soul. Get
familiar with it as a reader to internalize its voice, and then find
your own way to express it in your own contributions. Writing clearly,
succinctly, and with knowledge of your audience's expectations will get
you most of the way there, in the meantime.

Every line in the docs--whether English sentence or Perl
statement--should serve the purpose of bringing understanding to the
reader. Should a sentence exist mainly to make a wry joke that doesn't
further the reader's knowledge of Perl, set it aside, and consider
recasting it into a personal blog post or other article instead.

Write with a light heart, and a miserly hand. 

=head1 INDEX OF PREFERRED TERMS

L<As noted above|/Choice of underlying style guide: CMOS>, this guide
"inherits" all the preferred terms listed in the Chicago Manual of
Style, 17th edition, and adds the following terms of particular interest
to Perl documentation.

=over

=item built-in function

Not "builtin".

=item Darwin

See L<macOS|/macOS>.

=item macOS

Use this term for Apple's operating system instead of "Mac OS X" or
variants thereof.

This term is also preferable to "Darwin", unless one needs to refer
to macOS's Unix layer specifically.

=item man page

One unit of Unix-style documentation. Not "manpage". Preferable to "manual page".

=item Perl; perl

The name of the programming language is Perl, with a leading capital
"P", and the remainder in lowercase. (Never "PERL".)

The interpreter program that reads and executes Perl code is named
"C<perl>", in lowercase and in monospace (as with any other command
name).

Generally, unless you are specifically writing about the
command-line C<perl> program (as, for example, L<C<perlrun>|perlrun>
does), use "Perl" instead.

=item Perl 5

Documentation need not follow Perl's name with a "5", or any other
number, except during discussions of Perl's history, future plans,
or explicit comparisons between major Perl versions.

Before 2019, specifying "Perl 5" was sometimes needed to distinguish
the language from Perl 6. With the latter's renaming to "Raku", this
practice became unnecessary.

=item Perl 6

See L<Raku|/Raku>.

=item Perl 5 Porters, the; porters, the; p5p

The full name of the team responsible for Perl's ongoing maintenance
and development is "the Perl 5 Porters", and this sobriquet should
be spelled out in the first mention within any one document. It may
thereafter call the team "the porters" or "p5p".

Not "Perl5 Porters".

=item program

The most general descriptor for a stand-alone work made out of
executable Perl code. Synonymous with, and preferable to, "script".

=item Raku

Perl's "sister language", whose homepage is L<https://raku.org>.

Previously known as "Perl 6". In 2019, its design team renamed the
language to better reflect its identity as a project independent from
Perl. As such, Perl's documentation should always refer to this language
as "Raku" and not "Perl 6".

=item script

See L<program|/program>.

=item semicolon

Perl code's frequently overlooked punctuation mark. Not "semi-colon".

=item Unix

Not "UNIX", "*nix", or "Un*x". Applicable to both the original operating
system from the 1970s as well as all its conceptual descendants. You may
simply write "Unix" and not "a Unix-like operating system" when
referring to a Unix-like operating system.

=back

=head1 SEE ALSO

=over

=item *

L<perlpod|perlpod>

=item *

L<perlpodstyle|perlpodstyle>

=back

=head1 AUTHOR

This guide was initially drafted by Jason McIntosh
(jmac@jmac.org), under a grant from The Perl Foundation.

=for comment Additional contributors can get listed here (and this
comment deleted), when there are some.
                                                                                                                                                                                                                                                                                   usr/local/lib/perl5/5.40.0/pod/perldsc.pod                                                          0000644 0000000 0000000 00000064506 14714567415 016443  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =head1 NAME
X<data structure> X<complex data structure> X<struct>

perldsc - Perl Data Structures Cookbook

=head1 DESCRIPTION

Perl lets us have complex data structures.  You can write something like
this and all of a sudden, you'd have an array with three dimensions!

    for my $x (1 .. 10) {
        for my $y (1 .. 10) {
            for my $z (1 .. 10) {
                $AoA[$x][$y][$z] =
                    $x ** $y + $z;
            }
        }
    }

Alas, however simple this may appear, underneath it's a much more
elaborate construct than meets the eye!

How do you print it out?  Why can't you say just C<print @AoA>?  How do
you sort it?  How can you pass it to a function or get one of these back
from a function?  Is it an object?  Can you save it to disk to read
back later?  How do you access whole rows or columns of that matrix?  Do
all the values have to be numeric?

As you see, it's quite easy to become confused.  While some small portion
of the blame for this can be attributed to the reference-based
implementation, it's really more due to a lack of existing documentation with
examples designed for the beginner.

This document is meant to be a detailed but understandable treatment of the
many different sorts of data structures you might want to develop.  It
should also serve as a cookbook of examples.  That way, when you need to
create one of these complex data structures, you can just pinch, pilfer, or
purloin a drop-in example from here.

Let's look at each of these possible constructs in detail.  There are separate
sections on each of the following:

=over 5

=item * arrays of arrays

=item * hashes of arrays

=item * arrays of hashes

=item * hashes of hashes

=item * more elaborate constructs

=back

But for now, let's look at general issues common to all
these types of data structures.

=head1 REFERENCES
X<reference> X<dereference> X<dereferencing> X<pointer>

The most important thing to understand about all data structures in
Perl--including multidimensional arrays--is that even though they might
appear otherwise, Perl C<@ARRAY>s and C<%HASH>es are all internally
one-dimensional.  They can hold only scalar values (meaning a string,
number, or a reference).  They cannot directly contain other arrays or
hashes, but instead contain I<references> to other arrays or hashes.
X<multidimensional array> X<array, multidimensional>

You can't use a reference to an array or hash in quite the same way that you
would a real array or hash.  For C or C++ programmers unused to
distinguishing between arrays and pointers to the same, this can be
confusing.  If so, just think of it as the difference between a structure
and a pointer to a structure.

You can (and should) read more about references in L<perlref>.
Briefly, references are rather like pointers that know what they
point to.  (Objects are also a kind of reference, but we won't be needing
them right away--if ever.)  This means that when you have something which
looks to you like an access to a two-or-more-dimensional array and/or hash,
what's really going on is that the base type is
merely a one-dimensional entity that contains references to the next
level.  It's just that you can I<use> it as though it were a
two-dimensional one.  This is actually the way almost all C
multidimensional arrays work as well.

    $array[7][12]                       # array of arrays
    $array[7]{string}                   # array of hashes
    $hash{string}[7]                    # hash of arrays
    $hash{string}{'another string'}     # hash of hashes

Now, because the top level contains only references, if you try to print
out your array in with a simple print() function, you'll get something
that doesn't look very nice, like this:

    my @AoA = ( [2, 3], [4, 5, 7], [0] );
    print $AoA[1][2];
  7
    print @AoA;
  ARRAY(0x83c38)ARRAY(0x8b194)ARRAY(0x8b1d0)


That's because Perl doesn't (ever) implicitly dereference your variables.
If you want to get at the thing a reference is referring to, then you have
to do this yourself using either prefix typing indicators, like
C<${$blah}>, C<@{$blah}>, C<@{$blah[$i]}>, or else postfix pointer arrows,
like C<< $arr->[3] >>, C<< $hash->{fred} >>, or even C<< $obj->method()->[3] >>.

=head1 COMMON MISTAKES

The two most common mistakes made in constructing something like
an array of arrays is either accidentally counting the number of
elements or else taking a reference to the same memory location
repeatedly.  Here's the case where you just get the count instead
of a nested array:

    for my $i (1..10) {
        my @array = somefunc($i);
        $AoA[$i] = @array;      # WRONG!
    }

That's just the simple case of assigning an array to a scalar and getting
its element count.  If that's what you really and truly want, then you
might do well to consider being a tad more explicit about it, like this:

    for my $i (1..10) {
        my @array = somefunc($i);
        $counts[$i] = scalar @array;
    }

Here's the case of taking a reference to the same memory location
again and again:

    # Either without strict or having an outer-scope my @array;
    # declaration.

    for my $i (1..10) {
        @array = somefunc($i);
        $AoA[$i] = \@array;     # WRONG!
    }

So, what's the big problem with that?  It looks right, doesn't it?
After all, I just told you that you need an array of references, so by
golly, you've made me one!

Unfortunately, while this is true, it's still broken.  All the references
in @AoA refer to the I<very same place>, and they will therefore all hold
whatever was last in @array!  It's similar to the problem demonstrated in
the following C program:

    #include <pwd.h>
    main() {
        struct passwd *getpwnam(), *rp, *dp;
        rp = getpwnam("root");
        dp = getpwnam("daemon");

        printf("daemon name is %s\nroot name is %s\n",
                dp->pw_name, rp->pw_name);
    }

Which will print

    daemon name is daemon
    root name is daemon

The problem is that both C<rp> and C<dp> are pointers to the same location
in memory!  In C, you'd have to remember to malloc() yourself some new
memory.  In Perl, you'll want to use the array constructor C<[]> or the
hash constructor C<{}> instead.   Here's the right way to do the preceding
broken code fragments:
X<[]> X<{}>

    # Either without strict or having an outer-scope my @array;
    # declaration.

    for my $i (1..10) {
        @array = somefunc($i);
        $AoA[$i] = [ @array ];
    }

The square brackets make a reference to a new array with a I<copy>
of what's in @array at the time of the assignment.  This is what
you want.

Note that this will produce something similar:

    # Either without strict or having an outer-scope my @array;
    # declaration.
    for my $i (1..10) {
        @array = 0 .. $i;
        $AoA[$i]->@* = @array;
    }

Is it the same?  Well, maybe so--and maybe not.  The subtle difference
is that when you assign something in square brackets, you know for sure
it's always a brand new reference with a new I<copy> of the data.
Something else could be going on in this new case with the
C<< $AoA[$i]->@* >> dereference on the left-hand-side of the assignment.
It all depends on whether C<$AoA[$i]> had been undefined to start with,
or whether it already contained a reference.  If you had already
populated @AoA with references, as in

    $AoA[3] = \@another_array;

Then the assignment with the indirection on the left-hand-side would
use the existing reference that was already there:

    $AoA[3]->@* = @array;

Of course, this I<would> have the "interesting" effect of clobbering
@another_array.  (Have you ever noticed how when a programmer says
something is "interesting", that rather than meaning "intriguing",
they're disturbingly more apt to mean that it's "annoying",
"difficult", or both?  :-)

So just remember always to use the array or hash constructors with C<[]>
or C<{}>, and you'll be fine, although it's not always optimally
efficient.

Surprisingly, the following dangerous-looking construct will
actually work out fine:

    for my $i (1..10) {
        my @array = somefunc($i);
        $AoA[$i] = \@array;
    }

That's because my() is more of a run-time statement than it is a
