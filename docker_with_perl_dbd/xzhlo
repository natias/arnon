
CAREFUL: The ! must follow the ":write" command immediately, without white
space.  Otherwise it becomes a filter command, which is explained later in
this chapter.


APPENDING TO A FILE

In the first section of this chapter was explained how to collect a number of
lines into a register.  The same can be done to collect lines in a file.
Write the first line with this command: >

	:.write collection

Now move the cursor to the second line you want to collect, and type this: >

	:.write >>collection

The ">>" tells Vim the "collection" file is not to be written as a new file,
but the line must be appended at the end.   You can repeat this as many times
as you like.

==============================================================================
*10.7*	Formatting text

When you are typing plain text, it's nice if the length of each line is
automatically trimmed to fit in the window.  To make this happen while
inserting text, set the 'textwidth' option: >

	:set textwidth=72

You might remember that in the example vimrc file this command was used for
every text file.  Thus if you are using that vimrc file, you were already
using it.  To check the current value of 'textwidth': >

	:set textwidth

Now lines will be broken to take only up to 72 characters.  But when you
insert text halfway through a line, or when you delete a few words, the lines
will get too long or too short.  Vim doesn't automatically reformat the text.
   To tell Vim to format the current paragraph: >

	gqap

This starts with the "gq" command, which is an operator.  Following is "ap",
the text object that stands for "a paragraph".  A paragraph is separated from
the next paragraph by an empty line.

	Note:
	A blank line, which contains white space, does NOT separate
	paragraphs.  This is hard to notice!

Instead of "ap" you could use any motion or text object.  If your paragraphs
are properly separated, you can use this command to format the whole file: >

	gggqG

"gg" takes you to the first line, "gq" is the format operator and "G" the
motion that jumps to the last line.

In case your paragraphs aren't clearly defined, you can format just the lines
you manually select.  Move the cursor to the first line you want to format.
Start with the command "gqj".  This formats the current line and the one below
it.  If the first line was short, words from the next line will be appended.
If it was too long, words will be moved to the next line.  The cursor moves to
the second line.  Now you can use "." to repeat the command.  Keep doing this
until you are at the end of the text you want to format.

==============================================================================
*10.8*	Changing case

You have text with section headers in lowercase.  You want to make the word
"section" all uppercase.  Do this with the "gU" operator.  Start with the
cursor in the first column: >

			     gUw
<	section header	    ---->      SECTION header

The "gu" operator does exactly the opposite: >

			     guw
<	SECTION header	    ---->      section header

You can also use "g~" to swap case.  All these are operators, thus they work
with any motion command, with text objects and in Visual mode.
   To make an operator work on lines you double it.  The delete operator is
"d", thus to delete a line you use "dd".  Similarly, "gugu" makes a whole line
lowercase.  This can be shortened to "guu".  "gUgU" is shortened to "gUU" and
"g~g~" to "g~~".  Example: >

				g~~
<	Some GIRLS have Fun    ---->   sOME girls HAVE fUN ~

==============================================================================
*10.9*	Using an external program

Vim has a very powerful set of commands, it can do anything.  But there may
still be something that an external command can do better or faster.
   The command "!{motion}{program}" takes a block of text and filters it
through an external program.  In other words, it runs the system command
represented by {program}, giving it the block of text represented by {motion}
as input.  The output of this command then replaces the selected block.
   Because this summarizes badly if you are unfamiliar with UNIX filters, take
a look at an example.  The sort command sorts a file.  If you execute the
following command, the unsorted file input.txt will be sorted and written to
output.txt.  (This works on both UNIX and Microsoft Windows.) >

	sort <input.txt >output.txt

Now do the same thing in Vim.  You want to sort lines 1 through 5 of a file.
You start by putting the cursor on line 1.  Next you execute the following
command: >

	!5G

The "!" tells Vim that you are performing a filter operation.  The Vim editor
expects a motion command to follow, indicating which part of the file to
filter.  The "5G" command tells Vim to go to line 5, so it now knows that it
is to filter lines 1 (the current line) through 5.
   In anticipation of the filtering, the cursor drops to the bottom of the
screen and a ! prompt displays.  You can now type in the name of the filter
program, in this case "sort".  Therefore, your full command is as follows: >

	!5Gsort<Enter>

The result is that the sort program is run on the first 5 lines.  The output
of the program replaces these lines.

	line 55			      line 11
	line 33			      line 22
	line 11		-->	      line 33
	line 22			      line 44
	line 44			      line 55
	last line		      last line

The "!!" command filters the current line through a filter.  In Unix the "date"
command prints the current time and date.  "!!date<Enter>" replaces the current
line with the output of "date".  This is useful to add a timestamp to a file.


WHEN IT DOESN'T WORK

Starting a shell, sending it text and capturing the output requires that Vim
knows how the shell works exactly.  When you have problems with filtering,
check the values of these options:

	'shell'		specifies the program that Vim uses to execute
			external programs.
	'shellcmdflag'	argument to pass a command to the shell
	'shellquote'	quote to be used around the command
	'shellxquote'	quote to be used around the command and redirection
	'shelltype'	kind of shell (only for the Amiga)
	'shellslash'	use forward slashes in the command (only for
			MS-Windows and alikes)
	'shellredir'	string used to write the command output into a file

On Unix this is hardly ever a problem, because there are two kinds of shells:
"sh" like and "csh" like.  Vim checks the 'shell' option and sets related
options automatically, depending on whether it sees "csh" somewhere in
'shell'.
   On MS-Windows, however, there are many different shells and you might have
to tune the options to make filtering work.  Check the help for the options
for more information.


READING COMMAND OUTPUT

To read the contents of the current directory into the file, use this:

on Unix: >
	:read !ls
on MS-Windows: >
	:read !dir

The output of the "ls" or "dir" command is captured and inserted in the text,
below the cursor.  This is similar to reading a file, except that the "!" is
used to tell Vim that a command follows.
   The command may have arguments.  And a range can be used to tell where Vim
should put the lines: >

	:0read !date -u

This inserts the current time and date in UTC format at the top of the file.
(Well, if you have a date command that accepts the "-u" argument.)  Note the
difference with using "!!date": that replaced a line, while ":read !date" will
insert a line.


WRITING TEXT TO A COMMAND

The Unix command "wc" counts words.  To count the words in the current file: >

	:write !wc

This is the same write command as before, but instead of a file name the "!"
character is used and the name of an external command.  The written text will
be passed to the specified command as its standard input.  The output could
look like this:

       4      47     249 ~

The "wc" command isn't verbose.  This means you have 4 lines, 47 words and 249
characters.

Watch out for this mistake: >

	:write! wc

This will write the file "wc" in the current directory, with force.  White
space is important here!


REDRAWING THE SCREEN

If the external command produced an error message, the display may have been
messed up.  Vim is very efficient and only redraws those parts of the screen
that it knows need redrawing.  But it can't know about what another program
has written.  To tell Vim to redraw the screen: >

	CTRL-L

==============================================================================

Next chapter: |usr_11.txt|  Recovering from a crash

Copyright: see |manual-copyright|  vim:tw=78:ts=8:noet:ft=help:norl:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                usr/share/vim/vim90/doc/usr_11.txt                                                                  0000644 0000000 0000000 00000031341 14424703754 015352  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        *usr_11.txt*	For Vim version 9.0.  Last change: 2020 Oct 25

		     VIM USER MANUAL - by Bram Moolenaar

			   Recovering from a crash


Did your computer crash?  And you just spent hours editing?  Don't panic!  Vim
stores enough information to be able to restore most of your work.  This
chapter shows you how to get your work back and explains how the swap file is
used.

|11.1|	Basic recovery
|11.2|	Where is the swap file?
|11.3|	Crashed or not?
|11.4|	Further reading

     Next chapter: |usr_12.txt|  Clever tricks
 Previous chapter: |usr_10.txt|  Making big changes
Table of contents: |usr_toc.txt|

==============================================================================
*11.1*	Basic recovery

In most cases recovering a file is quite simple, assuming you know which file
you were editing (and the harddisk is still working).  Start Vim on the file,
with the "-r" argument added: >

	vim -r help.txt

Vim will read the swap file (used to store text you were editing) and may read
bits and pieces of the original file.  If Vim recovered your changes you will
see these messages (with different file names, of course):

	Using swap file ".help.txt.swp" ~
	Original file "~/vim/runtime/doc/help.txt" ~
	Recovery completed. You should check if everything is OK. ~
	(You might want to write out this file under another name ~
	and run diff with the original file to check for changes) ~
	You may want to delete the .swp file now. ~

To be on the safe side, write this file under another name: >

	:write help.txt.recovered

Compare the file with the original file to check if you ended up with what you
expected.  Vimdiff is very useful for this |08.7|.  For example: >

	:write help.txt.recovered
	:edit #
	:diffsp help.txt

Watch out for the original file to contain a more recent version (you saved
the file just before the computer crashed).  And check that no lines are
missing (something went wrong that Vim could not recover).
   If Vim produces warning messages when recovering, read them carefully.
This is rare though.

If the recovery resulted in text that is exactly the same as the file
contents, you will get this message:

	Using swap file ".help.txt.swp" ~
	Original file "~/vim/runtime/doc/help.txt" ~
	Recovery completed. Buffer contents equals file contents. ~
	You may want to delete the .swp file now. ~

This usually happens if you already recovered your changes, or you wrote the
file after making changes.  It is safe to delete the swap file now.

It is normal that the last few changes can not be recovered.  Vim flushes the
changes to disk when you don't type for about four seconds, or after typing
about two hundred characters.  This is set with the 'updatetime' and
'updatecount' options.  Thus when Vim didn't get a chance to save itself when
the system went down, the changes after the last flush will be lost.

If you were editing without a file name, give an empty string as argument: >

	vim -r ""

You must be in the right directory, otherwise Vim can't find the swap file.

==============================================================================
*11.2*	Where is the swap file?

Vim can store the swap file in several places.  Normally it is in the same
directory as the original file.  To find it, change to the directory of the
file, and use: >

	vim -r

Vim will list the swap files that it can find.  It will also look in other
directories where the swap file for files in the current directory may be
located.  It will not find swap files in any other directories though, it
doesn't search the directory tree.
   The output could look like this:

	Swap files found: ~
	   In current directory: ~
	1.    .main.c.swp ~
		  owned by: mool   dated: Tue May 29 21:00:25 2001 ~
		 file name: ~mool/vim/vim6/src/main.c ~
		  modified: YES ~
		 user name: mool   host name: masaka.moolenaar.net ~
		process ID: 12525 ~
	   In directory ~/tmp: ~
	      -- none -- ~
	   In directory /var/tmp: ~
	      -- none -- ~
	   In directory /tmp: ~
	      -- none -- ~

If there are several swap files that look like they may be the one you want to
use, a list is given of these swap files and you are requested to enter the
number of the one you want to use.  Carefully look at the dates to decide
which one you want to use.
   In case you don't know which one to use, just try them one by one and check
the resulting files if they are what you expected.


USING A SPECIFIC SWAP FILE

If you know which swap file needs to be used, you can recover by giving the
swap file name.  Vim will then find out the name of the original file from
the swap file.

Example: >
	vim -r .help.txt.swo

This is also handy when the swap file is in another directory than expected.
Vim recognizes files with the pattern *.s[uvw][a-z] as swap files.

If this still does not work, see what file names Vim reports and rename the
files accordingly.  Check the 'directory' option to see where Vim may have
put the swap file.

	Note:
	Vim tries to find the swap file by searching the directories in the
	'dir' option, looking for files that match "filename.sw?".  If
	wildcard expansion doesn't work (e.g., when the 'shell' option is
	invalid), Vim does a desperate try to find the file "filename.swp".
	If that fails too, you will have to give the name of the swapfile
	itself to be able to recover the file.

==============================================================================
*11.3*	Crashed or not?					*ATTENTION* *E325*

Vim tries to protect you from doing stupid things.  Suppose you innocently
start editing a file, expecting the contents of the file to show up.  Instead,
Vim produces a very long message:

		E325: ATTENTION ~
	Found a swap file by the name ".main.c.swp" ~
		  owned by: mool   dated: Tue May 29 21:09:28 2001 ~
		 file name: ~mool/vim/vim6/src/main.c ~
		  modified: no ~
		 user name: mool   host name: masaka.moolenaar.net ~
		process ID: 12559 (still running) ~
	While opening file "main.c" ~
		     dated: Tue May 29 19:46:12 2001 ~
 ~
	(1) Another program may be editing the same file. ~
	    If this is the case, be careful not to end up with two ~
	    different instances of the same file when making changes. ~
	    Quit, or continue with caution. ~
 ~
	(2) An edit session for this file crashed. ~
	    If this is the case, use ":recover" or "vim -r main.c" ~
	    to recover the changes (see ":help recovery"). ~
	    If you did this already, delete the swap file ".main.c.swp" ~
	    to avoid this message. ~

You get this message, because, when starting to edit a file, Vim checks if a
swap file already exists for that file.  If there is one, there must be
something wrong.  It may be one of these two situations.

1. Another edit session is active on this file.  Look in the message for the
   line with "process ID".  It might look like this:

		process ID: 12559 (still running) ~

   The text "(still running)" indicates that the process editing this file
   runs on the same computer.  When working on a non-Unix system you will not
   get this extra hint.  When editing a file over a network, you may not see
   the hint, because the process might be running on another computer.  In
   those two cases you must find out what the situation is yourself.
      If there is another Vim editing the same file, continuing to edit will
   result in two versions of the same file.  The one that is written last will
   overwrite the other one, resulting in loss of changes.  You better quit
   this Vim.

2. The swap file might be the result from a previous crash of Vim or the
   computer.  Check the dates mentioned in the message.  If the date of the
   swap file is newer than the file you were editing, and this line appears:

		modified: YES ~

   Then you very likely have a crashed edit session that is worth recovering.
      If the date of the file is newer than the date of the swap file, then
   either it was changed after the crash (perhaps you recovered it earlier,
   but didn't delete the swap file?), or else the file was saved before the
   crash but after the last write of the swap file (then you're lucky: you
   don't even need that old swap file).  Vim will warn you for this with this
   extra line:

      NEWER than swap file! ~


NOTE that in the following situation Vim knows the swap file is not useful and
will automatically delete it:
- The file is a valid swap file (Magic number is correct).
- The flag that the file was modified is not set.
- The process is not running.

You can programmatically deal with this situation with the |FileChangedShell|
autocommand event.


UNREADABLE SWAP FILE ~

Sometimes the line

	[cannot be read] ~

will appear under the name of the swap file.  This can be good or bad,
depending on circumstances.

It is good if a previous editing session crashed without having made any
changes to the file.  Then a directory listing of the swap file will show
that it has zero bytes.  You may delete it and proceed.

It is slightly bad if you don't have read permission for the swap file.  You
may want to view the file read-only, or quit.  On multi-user systems, if you
yourself did the last changes under a different login name, a logout
followed by a login under that other name might cure the "read error".  Or
else you might want to find out who last edited (or is editing) the file and
have a talk with them.

It is very bad if it means there is a physical read error on the disk
containing the swap file.  Fortunately, this almost never happens.
You may want to view the file read-only at first (if you can), to see the
extent of the changes that were "forgotten".  If you are the one in charge of
that file, be prepared to redo your last changes.


WHAT TO DO?					*swap-exists-choices*

If dialogs are supported you will be asked to select one of six choices:

  Swap file ".main.c.swp" already exists! ~
  [O]pen Read-Only, (E)dit anyway, (R)ecover, (Q)uit, (A)bort, (D)elete it: ~

O  Open the file readonly.  Use this when you just want to view the file and
   don't need to recover it.  You might want to use this when you know someone
   else is editing the file, but you just want to look in it and not make
   changes.

E  Edit the file anyway.  Use this with caution!  If the file is being edited
   in another Vim, you might end up with two versions of the file.  Vim will
   try to warn you when this happens, but better be safe than sorry.

R  Recover the file from the swap file.  Use this if you know that the swap
   file contains changes that you want to recover.

Q  Quit.  This avoids starting to edit the file.  Use this if there is another
   Vim editing the same file.
      When you just started Vim, this will exit Vim.  When starting Vim with
   files in several windows, Vim quits only if there is a swap file for the
   first one.  When using an edit command, the file will not be loaded and you
   are taken back to the previously edited file.

A  Abort.  Like Quit, but also abort further commands.  This is useful when
   loading a script that edits several files, such as a session with multiple
   windows.

D  Delete the swap file.  Use this when you are sure you no longer need it.
   For example, when it doesn't contain changes, or when the file itself is
   newer than the swap file.
      On Unix this choice is only offered when the process that created the
   swap file does not appear to be running.

If you do not get the dialog (you are running a version of Vim that does not
support it), you will have to do it manually.  To recover the file, use this
command: >

	:recover


Vim cannot always detect that a swap file already exists for a file.  This is
the case when the other edit session puts the swap files in another directory
or when the path name for the file is different when editing it on different
machines.  Therefore, don't rely on Vim always warning you.

If you really don't want to see this message, you can add the 'A' flag to the
'shortmess' option.  But it's very unusual that you need this.

For remarks about encryption and the swap file, see |:recover-crypt|.
For programmatic access to the swap file, see |swapinfo()|.

==============================================================================
*11.4*	Further reading

|swap-file|	An explanation about where the swap file will be created and
		what its name is.
|:preserve|	Manually flushing the swap file to disk.
|:swapname|	See the name of the swap file for the current file.
'updatecount'	Number of key strokes after which the swap file is flushed to
		disk.
'updatetime'	Timeout after which the swap file is flushed to disk.
'swapsync'	Whether the disk is synced when the swap file is flushed.
'directory'	List of directory names where to store the swap file.
'maxmem'	Limit for memory usage before writing text to the swap file.
'maxmemtot'	Same, but for all files in total.

==============================================================================

Next chapter: |usr_12.txt|  Clever tricks

Copyright: see |manual-copyright|  vim:tw=78:ts=8:noet:ft=help:norl:
                                                                                                                                                                                                                                                                                               usr/share/vim/vim90/doc/usr_12.txt                                                                  0000644 0000000 0000000 00000032171 14424703754 015355  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        *usr_12.txt*	For Vim version 9.0.  Last change: 2022 Nov 19

		     VIM USER MANUAL - by Bram Moolenaar

				Clever tricks


By combining several commands you can make Vim do nearly everything.  In this
chapter a number of useful combinations will be presented.  This uses the
commands introduced in the previous chapters and a few more.

|12.1|	Replace a word
|12.2|	Change "Last, First" to "First Last"
|12.3|	Sort a list
|12.4|	Reverse line order
|12.5|	Count words
|12.6|	Find a man page
|12.7|	Trim blanks
|12.8|	Find where a word is used

     Next chapter: |usr_20.txt|  Typing command-line commands quickly
 Previous chapter: |usr_11.txt|  Recovering from a crash
Table of contents: |usr_toc.txt|

==============================================================================
*12.1*	Replace a word

The substitute command can be used to replace all occurrences of a word with
another word: >

	:%s/four/4/g

The "%" range means to replace in all lines.  The "g" flag at the end causes
all words in a line to be replaced.
   This will not do the right thing if your file also contains "thirtyfour".
It would be replaced with "thirty4".  To avoid this, use the "\<" item to
match the start of a word: >

	:%s/\<four/4/g

Obviously, this still goes wrong on "fourteen".  Use "\>" to match the end of
a word: >

	:%s/\<four\>/4/g

If you are programming, you might want to replace "four" in comments, but not
in the code.  Since this is difficult to specify, add the "c" flag to have the
substitute command prompt you for each replacement: >


	:%s/\<four\>/4/gc


REPLACING IN SEVERAL FILES

Suppose you want to replace a word in more than one file.  You could edit each
file and type the command manually.  It's a lot faster to use record and
playback.
   Let's assume you have a directory with C++ files, all ending in ".cpp".
There is a function called "GetResp" that you want to rename to "GetAnswer".

	vim *.cpp		Start Vim, defining the argument list to
				contain all the C++ files.  You are now in the
				first file.
	qq			Start recording into the q register
	:%s/\<GetResp\>/GetAnswer/g
				Do the replacements in the first file.
	:wnext			Write this file and move to the next one.
	q			Stop recording.
	@q			Execute the q register.  This will replay the
				substitution and ":wnext".  You can verify
				that this doesn't produce an error message.
	999@q			Execute the q register on the remaining files.

At the last file you will get an error message, because ":wnext" cannot move
to the next file.  This stops the execution, and everything is done.

	Note:
	When playing back a recorded sequence, an error stops the execution.
	Therefore, make sure you don't get an error message when recording.

There is one catch: If one of the .cpp files does not contain the word
"GetResp", you will get an error and replacing will stop.  To avoid this, add
the "e" flag to the substitute command: >

	:%s/\<GetResp\>/GetAnswer/ge

The "e" flag tells ":substitute" that not finding a match is not an error.

==============================================================================
*12.2*	Change "Last, First" to "First Last"

You have a list of names in this form:

	Doe, John ~
	Smith, Peter ~

You want to change that to:

	John Doe ~
	Peter Smith ~

This can be done with just one command: >

	:%s/\([^,]*\), \(.*\)/\2 \1/

Let's break this down in parts.  Obviously it starts with a substitute
command.  The "%" is the line range, which stands for the whole file.  Thus
the substitution is done in every line in the file.
   The arguments for the substitute command are "/from/to/".  The slashes
separate the "from" pattern and the "to" string.  This is what the "from"
pattern contains:
							\([^,]*\), \(.*\) ~

	The first part between \( \) matches "Last"	\(     \)
	    match anything but a comma			  [^,]
	    any number of times				      *
	matches ", " literally					 ,
	The second part between \( \) matches "First"		   \(  \)
	    any character					     .
	    any number of times					      *

In the "to" part we have "\2" and "\1".  These are called backreferences.
They refer to the text matched by the "\( \)" parts in the pattern.  "\2"
refers to the text matched by the second "\( \)", which is the "First" name.
"\1" refers to the first "\( \)", which is the "Last" name.
   You can use up to nine backreferences in the "to" part of a substitute
command.  "\0" stands for the whole matched pattern.  There are a few more
special items in a substitute command, see |sub-replace-special|.

==============================================================================
*12.3*	Sort a list

In a Makefile you often have a list of files.  For example:

	OBJS = \ ~
		version.o \ ~
		pch.o \ ~
		getopt.o \ ~
		util.o \ ~
		getopt1.o \ ~
		inp.o \ ~
		patch.o \ ~
		backup.o ~

To sort this list, filter the text through the external sort command: >

	/^OBJS
	j
	:.,/^$/-1!sort

This goes to the first line, where "OBJS" is the first thing in the line.
Then it goes one line down and filters the lines until the next empty line.
You could also select the lines in Visual mode and then use "!sort".  That's
easier to type, but more work when there are many lines.
   The result is this:

	OBJS = \ ~
		backup.o ~
		getopt.o \ ~
		getopt1.o \ ~
		inp.o \ ~
		patch.o \ ~
		pch.o \ ~
		util.o \ ~
		version.o \ ~


Notice that a backslash at the end of each line is used to indicate the line
continues.  After sorting, this is wrong!  The "backup.o" line that was at
the end didn't have a backslash.  Now that it sorts to another place, it
must have a backslash.
   The simplest solution is to add the backslash with "A \<Esc>".  You can
keep the backslash in the last line, if you make sure an empty line comes
after it.  That way you don't have this problem again.

==============================================================================
*12.4*	Reverse line order

The |:global| command can be combined with the |:move| command to move all the
lines before the first line, resulting in a reversed file.  The command is: >

	:global/^/move 0

Abbreviated: >

	:g/^/m 0

The "^" regular expression matches the beginning of the line (even if the line
is blank).  The |:move| command moves the matching line to after the imaginary
zeroth line, so the current matching line becomes the first line of the file.
As the |:global| command is not confused by the changing line numbering,
|:global| proceeds to match all remaining lines of the file and puts each as
the first.

This also works on a range of lines.  First move to above the first line and
mark it with "mt".  Then move the cursor to the last line in the range and
type: >

	:'t+1,.g/^/m 't

==============================================================================
*12.5*	Count words

Sometimes you have to write a text with a maximum number of words.  Vim can
count the words for you.
   When the whole file is what you want to count the words in, use this
command: >

	g CTRL-G

Do not type a space after the g, this is just used here to make the command
easy to read.
   The output looks like this:

	Col 1 of 0; Line 141 of 157; Word 748 of 774; Byte 4489 of 4976 ~

You can see on which word you are (748), and the total number of words in the
file (774).

When the text is only part of a file, you could move to the start of the text,
type "g CTRL-G", move to the end of the text, type "g CTRL-G" again, and then
use your brain to compute the difference in the word position.  That's a good
exercise, but there is an easier way.  With Visual mode, select the text you
want to count words in.  Then type g CTRL-G.  The result:

	Selected 5 of 293 Lines; 70 of 1884 Words; 359 of 10928 Bytes ~

For other ways to count words, lines and other items, see |count-items|.

==============================================================================
*12.6*	Find a man page					*find-manpage*

While editing a shell script or C program, you are using a command or function
that you want to find the man page for (this is on Unix).  Let's first use a
simple way: Move the cursor to the word you want to find help on and press >

	K

Vim will run the external "man" program on the word.  If the man page is
found, it is displayed.  This uses the normal pager to scroll through the text
(mostly the "more" program).  When you get to the end pressing <Enter> will
get you back into Vim.

A disadvantage is that you can't see the man page and the text you are working
on at the same time.  There is a trick to make the man page appear in a Vim
window.  First, load the man filetype plugin: >

	:runtime! ftplugin/man.vim

Put this command in your vimrc file if you intend to do this often.  Now you
can use the ":Man" command to open a window on a man page: >

	:Man csh

You can scroll around and the text is highlighted.  This allows you to find
the help you were looking for.  Use CTRL-W w to jump to the window with the
text you were working on.
   To find a man page in a specific section, put the section number first.
For example, to look in section 3 for "echo": >

	:Man 3 echo

To jump to another man page, which is in the text with the typical form
"word(1)", press CTRL-] on it.  Further ":Man" commands will use the same
window.

To display a man page for the word under the cursor, use this: >

	\K

(If you redefined the <Leader>, use it instead of the backslash).
For example, you want to know the return value of "strstr()" while editing
this line:

	if ( strstr (input, "aap") == ) ~

Move the cursor to somewhere on "strstr" and type "\K".  A window will open
to display the man page for strstr().

==============================================================================
*12.7*	Trim blanks

Some people find spaces and tabs at the end of a line useless, wasteful, and
ugly.  To remove whitespace at the end of every line, execute the following
command: >

	:%s/\s\+$//

The line range "%" is used, thus this works on the whole file.  The pattern
that the ":substitute" command matches with is "\s\+$".  This finds white
space characters (\s), 1 or more of them (\+), before the end-of-line ($).
Later will be explained how you write patterns like this, see |usr_27.txt|.
   The "to" part of the substitute command is empty: "//".  Thus it replaces
with nothing, effectively deleting the matched white space.

Another wasteful use of spaces is placing them before a tab.  Often these can
be deleted without changing the amount of white space.  But not always!
Therefore, you can best do this manually.  Use this search command: >

	/ 	

You cannot see it, but there is a space before a tab in this command.  Thus
it's "/<Space><Tab>".   Now use "x" to delete the space and check that the
amount of white space doesn't change.  You might have to insert a tab if it
does change.  Type "n" to find the next match.  Repeat this until no more
matches can be found.

==============================================================================
*12.8*	Find where a word is used

If you are a UNIX user, you can use a combination of Vim and the grep command
to edit all the files that contain a given word.  This is extremely useful if
you are working on a program and want to view or edit all the files that
contain a specific variable.
   For example, suppose you want to edit all the C program files that contain
the word "frame_counter".  To do this you use the command: >

	vim `grep -l frame_counter *.c`

Let's look at this command in detail.  The grep command searches through a set
of files for a given word.  Because the -l argument is specified, the command
will only list the files containing the word and not print the matching lines.
The word it is searching for is "frame_counter".  Actually, this can be any
regular expression.  (Note: What grep uses for regular expressions is not
exactly the same as what Vim uses.)
   The entire command is enclosed in backticks (`).  This tells the UNIX shell
to run this command and pretend that the results were typed on the command
line.  So what happens is that the grep command is run and produces a list of
files, these files are put on the Vim command line.  This results in Vim
editing the file list that is the output of grep.  You can then use commands
like ":next" and ":first" to browse through the files.


FINDING EACH LINE

The above command only finds the files in which the word is found.  You still
have to find the word within the files.
   Vim has a built-in command that you can use to search a set of files for a
given string.  If you want to find all occurrences of "error_string" in all C
program files, for example, enter the following command: >

	:grep error_string *.c

This causes Vim to search for the string "error_string" in all the specified
files (*.c).  The editor will now open the first file where a match is found
and position the cursor on the first matching line.  To go to the next
matching line (no matter in what file it is), use the ":cnext" command.  To go
to the previous match, use the ":cprev" command.  Use ":clist" to see all the
matches and where they are.
   The ":grep" command uses the external commands grep (on Unix) or findstr
(on Windows).  You can change this by setting the option 'grepprg'.

==============================================================================

Next chapter: |usr_20.txt|  Typing command-line commands quickly

Copyright: see |manual-copyright|  vim:tw=78:ts=8:noet:ft=help:norl:
                                                                                                                                                                                                                                                                                                                                                                                                       usr/share/vim/vim90/doc/usr_20.txt                                                                  0000644 0000000 0000000 00000032645 14424703754 015362  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        *usr_20.txt*	For Vim version 9.0.  Last change: 2021 Nov 18

		     VIM USER MANUAL - by Bram Moolenaar

		     Typing command-line commands quickly


Vim has a few generic features that makes it easier to enter commands.  Colon
commands can be abbreviated, edited and repeated.  Completion is available for
nearly everything.

|20.1|	Command line editing
|20.2|	Command line abbreviations
|20.3|	Command line completion
|20.4|	Command line history
|20.5|	Command line window

     Next chapter: |usr_21.txt|  Go away and come back
 Previous chapter: |usr_12.txt|  Clever tricks
Table of contents: |usr_toc.txt|

==============================================================================
*20.1*	Command line editing

When you use a colon (:) command or search for a string with / or ?, Vim puts
the cursor on the bottom of the screen.  There you type the command or search
pattern.  This is called the Command line.  Also when it's used for entering a
search command.

The most obvious way to edit the command you type is by pressing the <BS> key.
This erases the character before the cursor.  To erase another character,
typed earlier, first move the cursor with the cursor keys.
   For example, you have typed this: >

	:s/col/pig/

Before you hit <Enter>, you notice that "col" should be "cow".  To correct
this, you type <Left> five times.  The cursor is now just after "col".  Type
<BS> and "w" to correct: >

	:s/cow/pig/

Now you can press <Enter> directly.  You don't have to move the cursor to the
end of the line before executing the command.

The most often used keys to move around in the command line:

	<Left>			one character left
	<Right>			one character right
	<S-Left> or <C-Left>	one word left
	<S-Right> or <C-Right>	one word right
	CTRL-B or <Home>	to begin of command line
	CTRL-E or <End>		to end of command line

	Note:
	<S-Left> (cursor left key with Shift key pressed) and <C-Left> (cursor
	left key with Control pressed) will not work on all keyboards.  Same
	for the other Shift and Control combinations.

You can also use the mouse to move the cursor.


DELETING

As mentioned, <BS> deletes the character before the cursor.  To delete a whole
word use CTRL-W.

	/the fine pig ~

		     CTRL-W

	/the fine ~

CTRL-U removes all text, thus allows you to start all over again.


OVERSTRIKE

The <Insert> key toggles between inserting characters and replacing the
existing ones.  Start with this text:

	/the fine pig ~

Move the cursor to the start of "fine" with <S-Left> twice (or <Left> eight
times, if <S-Left> doesn't work).  Now press <Insert> to switch to overstrike
and type "great":

	/the greatpig ~

Oops, we lost the space.  Now, don't use <BS>, because it would delete the
"t" (this is different from Replace mode).  Instead, press <Insert> to switch
from overstrike to inserting, and type the space:

	/the great pig ~


CANCELLING

