            "    gpointer                user_data)\n"
            "{\n"
            '  g_async_initable_new_async (%sTYPE_OBJECT_MANAGER_CLIENT, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "flags", flags, "name", name, "connection", connection, "object-path", object_path, "get-proxy-type-func", %sobject_manager_client_get_proxy_type, NULL);\n'
            "}\n"
            "\n" % (self.ns_lower, self.ns_upper, self.ns_lower)
        )
        self.outfile.write(
            "/**\n"
            " * %sobject_manager_client_new_finish:\n"
            " * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to %sobject_manager_client_new().\n"
            " * @error: Return location for error or %%NULL\n"
            " *\n"
            " * Finishes an operation started with %sobject_manager_client_new().\n"
            " *\n"
            " * Returns: (transfer full) (type %sObjectManagerClient): The constructed object manager client or %%NULL if @error is set.\n"
            % (self.ns_lower, self.ns_lower, self.ns_lower, self.namespace)
        )
        self.outfile.write(" */\n")
        self.outfile.write(
            "GDBusObjectManager *\n"
            "%sobject_manager_client_new_finish (\n"
            "    GAsyncResult        *res,\n"
            "    GError             **error)\n"
            "{\n"
            "  GObject *ret;\n"
            "  GObject *source_object;\n"
            "  source_object = g_async_result_get_source_object (res);\n"
            "  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);\n"
            "  g_object_unref (source_object);\n"
            "  if (ret != NULL)\n"
            "    return G_DBUS_OBJECT_MANAGER (ret);\n"
            "  else\n"
            "    return NULL;\n"
            "}\n"
            "\n" % (self.ns_lower)
        )
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sobject_manager_client_new_sync:\n"
                " * @connection: A #GDBusConnection.\n"
                " * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.\n"
                " * @name: (nullable): A bus name (well-known or unique) or %%NULL if @connection is not a message bus connection.\n"
                " * @object_path: An object path.\n"
                " * @cancellable: (nullable): A #GCancellable or %%NULL.\n"
                " * @error: Return location for error or %%NULL\n"
                " *\n"
                " * Synchronously creates #GDBusObjectManagerClient using %sobject_manager_client_get_proxy_type() as the #GDBusProxyTypeFunc. See g_dbus_object_manager_client_new_sync() for more details.\n"
                " *\n"
                " * The calling thread is blocked until a reply is received.\n"
                " *\n"
                " * See %sobject_manager_client_new() for the asynchronous version of this constructor.\n"
                " *\n"
                " * Returns: (transfer full) (type %sObjectManagerClient): The constructed object manager client or %%NULL if @error is set.\n"
                % (self.ns_lower, self.ns_lower, self.ns_lower, self.namespace),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write(
            "GDBusObjectManager *\n"
            "%sobject_manager_client_new_sync (\n"
            "    GDBusConnection        *connection,\n"
            "    GDBusObjectManagerClientFlags  flags,\n"
            "    const gchar            *name,\n"
            "    const gchar            *object_path,\n"
            "    GCancellable           *cancellable,\n"
            "    GError                **error)\n"
            "{\n"
            "  GInitable *ret;\n"
            '  ret = g_initable_new (%sTYPE_OBJECT_MANAGER_CLIENT, cancellable, error, "flags", flags, "name", name, "connection", connection, "object-path", object_path, "get-proxy-type-func", %sobject_manager_client_get_proxy_type, NULL);\n'
            "  if (ret != NULL)\n"
            "    return G_DBUS_OBJECT_MANAGER (ret);\n"
            "  else\n"
            "    return NULL;\n"
            "}\n"
            "\n" % (self.ns_lower, self.ns_upper, self.ns_lower)
        )
        self.outfile.write("\n")
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sobject_manager_client_new_for_bus:\n"
                " * @bus_type: A #GBusType.\n"
                " * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.\n"
                " * @name: A bus name (well-known or unique).\n"
                " * @object_path: An object path.\n"
                " * @cancellable: (nullable): A #GCancellable or %%NULL.\n"
                " * @callback: A #GAsyncReadyCallback to call when the request is satisfied.\n"
                " * @user_data: User data to pass to @callback.\n"
                " *\n"
                " * Like %sobject_manager_client_new() but takes a #GBusType instead of a #GDBusConnection.\n"
                " *\n"
                " * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).\n"
                " * You can then call %sobject_manager_client_new_for_bus_finish() to get the result of the operation.\n"
                " *\n"
                " * See %sobject_manager_client_new_for_bus_sync() for the synchronous, blocking version of this constructor.\n"
                % (self.ns_lower, self.ns_lower, self.ns_lower, self.ns_lower),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write(
            "void\n"
            "%sobject_manager_client_new_for_bus (\n"
            "    GBusType                bus_type,\n"
            "    GDBusObjectManagerClientFlags  flags,\n"
            "    const gchar            *name,\n"
            "    const gchar            *object_path,\n"
            "    GCancellable           *cancellable,\n"
            "    GAsyncReadyCallback     callback,\n"
            "    gpointer                user_data)\n"
            "{\n"
            '  g_async_initable_new_async (%sTYPE_OBJECT_MANAGER_CLIENT, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "flags", flags, "name", name, "bus-type", bus_type, "object-path", object_path, "get-proxy-type-func", %sobject_manager_client_get_proxy_type, NULL);\n'
            "}\n"
            "\n" % (self.ns_lower, self.ns_upper, self.ns_lower)
        )
        self.outfile.write(
            "/**\n"
            " * %sobject_manager_client_new_for_bus_finish:\n"
            " * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to %sobject_manager_client_new_for_bus().\n"
            " * @error: Return location for error or %%NULL\n"
            " *\n"
            " * Finishes an operation started with %sobject_manager_client_new_for_bus().\n"
            " *\n"
            " * Returns: (transfer full) (type %sObjectManagerClient): The constructed object manager client or %%NULL if @error is set.\n"
            % (self.ns_lower, self.ns_lower, self.ns_lower, self.namespace)
        )
        self.outfile.write(" */\n")
        self.outfile.write(
            "GDBusObjectManager *\n"
            "%sobject_manager_client_new_for_bus_finish (\n"
            "    GAsyncResult        *res,\n"
            "    GError             **error)\n"
            "{\n"
            "  GObject *ret;\n"
            "  GObject *source_object;\n"
            "  source_object = g_async_result_get_source_object (res);\n"
            "  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);\n"
            "  g_object_unref (source_object);\n"
            "  if (ret != NULL)\n"
            "    return G_DBUS_OBJECT_MANAGER (ret);\n"
            "  else\n"
            "    return NULL;\n"
            "}\n"
            "\n" % (self.ns_lower)
        )
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sobject_manager_client_new_for_bus_sync:\n"
                " * @bus_type: A #GBusType.\n"
                " * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.\n"
                " * @name: A bus name (well-known or unique).\n"
                " * @object_path: An object path.\n"
                " * @cancellable: (nullable): A #GCancellable or %%NULL.\n"
                " * @error: Return location for error or %%NULL\n"
                " *\n"
                " * Like %sobject_manager_client_new_sync() but takes a #GBusType instead of a #GDBusConnection.\n"
                " *\n"
                " * The calling thread is blocked until a reply is received.\n"
                " *\n"
                " * See %sobject_manager_client_new_for_bus() for the asynchronous version of this constructor.\n"
                " *\n"
                " * Returns: (transfer full) (type %sObjectManagerClient): The constructed object manager client or %%NULL if @error is set.\n"
                % (self.ns_lower, self.ns_lower, self.ns_lower, self.namespace),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write(
            "GDBusObjectManager *\n"
            "%sobject_manager_client_new_for_bus_sync (\n"
            "    GBusType                bus_type,\n"
            "    GDBusObjectManagerClientFlags  flags,\n"
            "    const gchar            *name,\n"
            "    const gchar            *object_path,\n"
            "    GCancellable           *cancellable,\n"
            "    GError                **error)\n"
            "{\n"
            "  GInitable *ret;\n"
            '  ret = g_initable_new (%sTYPE_OBJECT_MANAGER_CLIENT, cancellable, error, "flags", flags, "name", name, "bus-type", bus_type, "object-path", object_path, "get-proxy-type-func", %sobject_manager_client_get_proxy_type, NULL);\n'
            "  if (ret != NULL)\n"
            "    return G_DBUS_OBJECT_MANAGER (ret);\n"
            "  else\n"
            "    return NULL;\n"
            "}\n"
            "\n" % (self.ns_lower, self.ns_upper, self.ns_lower)
        )
        self.outfile.write("\n")

    # ---------------------------------------------------------------------------------------------------

    def write_gtkdoc_deprecated_and_since_and_close(self, obj, f, indent):
        if len(obj.since) > 0:
            f.write("%*s *\n" "%*s * Since: %s\n" % (indent, "", indent, "", obj.since))
        if obj.deprecated:
            if isinstance(obj, dbustypes.Interface):
                thing = "The D-Bus interface"
            elif isinstance(obj, dbustypes.Method):
                thing = "The D-Bus method"
            elif isinstance(obj, dbustypes.Signal):
                thing = "The D-Bus signal"
            elif isinstance(obj, dbustypes.Property):
                thing = "The D-Bus property"
            else:
                print_error('Cannot handle object "{}"'.format(obj))
            f.write(
                self.docbook_gen.expand(
                    "%*s *\n"
                    "%*s * Deprecated: %s has been deprecated.\n"
                    % (indent, "", indent, "", thing),
                    False,
                )
            )
        f.write("%*s */\n" % (indent, ""))

    # ---------------------------------------------------------------------------------------------------

    def generate_interface_intro(self, i):
        self.outfile.write(
            "/* ------------------------------------------------------------------------\n"
            " * Code for interface %s\n"
            " * ------------------------------------------------------------------------\n"
            " */\n"
            "\n" % (i.name)
        )

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * SECTION:%s\n"
                " * @title: %s\n"
                " * @short_description: Generated C code for the %s D-Bus interface\n"
                " *\n"
                " * This section contains code for working with the #%s D-Bus interface in C.\n"
                " */\n" % (i.camel_name, i.camel_name, i.name, i.name),
                False,
            )
        )
        self.outfile.write("\n")

    def generate(self):
        self.generate_body_preamble()
        for i in self.ifaces:
            self.generate_interface_intro(i)
            self.generate_introspection_for_interface(i)
            self.generate_interface(i)
            self.generate_property_accessors(i)
            self.generate_signal_emitters(i)
            self.generate_method_calls(i)
            self.generate_method_completers(i)
            self.generate_proxy(i)
            self.generate_skeleton(i)
        if self.generate_objmanager:
            self.generate_object()
            self.generate_object_manager_client()
                                                                                                            usr/share/glib-2.0/codegen/codegen_docbook.py                                                       0000644 0000000 0000000 00000044534 14375670023 017474  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # -*- Mode: Python -*-

# GDBus - GLib D-Bus Library
#
# Copyright (C) 2008-2011 Red Hat, Inc.
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General
# Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
#
# Author: David Zeuthen <davidz@redhat.com>

import re
from os import path

from . import utils


# ----------------------------------------------------------------------------------------------------


class DocbookCodeGenerator:
    def __init__(self, ifaces):
        self.ifaces = ifaces
        self.generate_expand_dicts()

    def print_method_prototype(self, i, m, in_synopsis):
        max_method_len = 0
        if in_synopsis:
            for _m in i.methods:
                max_method_len = max(len(_m.name), max_method_len)
        else:
            max_method_len = max(len(m.name), max_method_len)

        max_signature_len = 0
        if in_synopsis:
            for _m in i.methods:
                for a in _m.in_args:
                    max_signature_len = max(len(a.signature), max_signature_len)
                for a in _m.out_args:
                    max_signature_len = max(len(a.signature), max_signature_len)
        else:
            for a in m.in_args:
                max_signature_len = max(len(a.signature), max_signature_len)
            for a in m.out_args:
                max_signature_len = max(len(a.signature), max_signature_len)

        if in_synopsis:
            self.out.write(
                '<link linkend="gdbus-method-%s.%s">%s</link>%*s ('
                % (
                    utils.dots_to_hyphens(i.name),
                    m.name,
                    m.name,
                    max_method_len - len(m.name),
                    "",
                )
            )
        else:
            self.out.write("%s%*s (" % (m.name, max_method_len - len(m.name), ""))
        count = 0
        for a in m.in_args:
            if count > 0:
                self.out.write(",\n%*s" % (max_method_len + 2, ""))
            self.out.write(
                "IN  %s%*s %s"
                % (a.signature, max_signature_len - len(a.signature), "", a.name)
            )
            count = count + 1
        for a in m.out_args:
            if count > 0:
                self.out.write(",\n%*s" % (max_method_len + 2, ""))
            self.out.write(
                "OUT %s%*s %s"
                % (a.signature, max_signature_len - len(a.signature), "", a.name)
            )
            count = count + 1
        self.out.write(");\n")

    def print_signal_prototype(self, i, s, in_synopsis):
        max_signal_len = 0
        if in_synopsis:
            for _s in i.signals:
                max_signal_len = max(len(_s.name), max_signal_len)
        else:
            max_signal_len = max(len(s.name), max_signal_len)

        max_signature_len = 0
        if in_synopsis:
            for _s in i.signals:
                for a in _s.args:
                    max_signature_len = max(len(a.signature), max_signature_len)
        else:
            for a in s.args:
                max_signature_len = max(len(a.signature), max_signature_len)

        if in_synopsis:
            self.out.write(
                '<link linkend="gdbus-signal-%s.%s">%s</link>%*s ('
                % (
                    utils.dots_to_hyphens(i.name),
                    s.name,
                    s.name,
                    max_signal_len - len(s.name),
                    "",
                )
            )
        else:
            self.out.write("%s%*s (" % (s.name, max_signal_len - len(s.name), ""))
        count = 0
        for a in s.args:
            if count > 0:
                self.out.write(",\n%*s" % (max_signal_len + 2, ""))
            self.out.write(
                "%s%*s %s"
                % (a.signature, max_signature_len - len(a.signature), "", a.name)
            )
            count = count + 1
        self.out.write(");\n")

    def print_property_prototype(self, i, p, in_synopsis):
        max_property_len = 0
        if in_synopsis:
            for _p in i.properties:
                max_property_len = max(len(_p.name), max_property_len)
        else:
            max_property_len = max(len(p.name), max_property_len)

        max_signature_len = 0
        if in_synopsis:
            for _p in i.properties:
                max_signature_len = max(len(_p.signature), max_signature_len)
        else:
            max_signature_len = max(len(p.signature), max_signature_len)

        if in_synopsis:
            self.out.write(
                '<link linkend="gdbus-property-%s.%s">%s</link>%*s'
                % (
                    utils.dots_to_hyphens(i.name),
                    p.name,
                    p.name,
                    max_property_len - len(p.name),
                    "",
                )
            )
        else:
            self.out.write("%s%*s" % (p.name, max_property_len - len(p.name), ""))
        if p.readable and p.writable:
            access = "readwrite"
        elif p.readable:
            access = "readable "
        else:
            access = "writable "
        self.out.write("  %s  %s\n" % (access, p.signature))

    def print_synopsis_methods(self, i):
        self.out.write('  <refsynopsisdiv role="synopsis">\n')
        self.out.write('    <title role="synopsis.title">Methods</title>\n')
        self.out.write("    <synopsis>\n")
        for m in i.methods:
            self.print_method_prototype(i, m, in_synopsis=True)
        self.out.write("</synopsis>\n")
        self.out.write("  </refsynopsisdiv>\n")

    def print_synopsis_signals(self, i):
        self.out.write('  <refsect1 role="signal_proto">\n')
        self.out.write('    <title role="signal_proto.title">Signals</title>\n')
        self.out.write("    <synopsis>\n")
        for s in i.signals:
            self.print_signal_prototype(i, s, in_synopsis=True)
        self.out.write("</synopsis>\n")
        self.out.write("  </refsect1>\n")

    def print_synopsis_properties(self, i):
        self.out.write('  <refsect1 role="properties">\n')
        self.out.write('    <title role="properties.title">Properties</title>\n')
        self.out.write("    <synopsis>\n")
        for p in i.properties:
            self.print_property_prototype(i, p, in_synopsis=True)
        self.out.write("</synopsis>\n")
        self.out.write("  </refsect1>\n")

    def print_method(self, i, m):
        self.out.write(
            '<refsect2 role="method" id="gdbus-method-%s.%s">\n'
            % (utils.dots_to_hyphens(i.name), m.name)
        )
        self.out.write("  <title>The %s() method</title>\n" % (m.name))
        self.out.write(
            '  <indexterm zone="gdbus-method-%s.%s"><primary sortas="%s.%s">%s.%s()</primary></indexterm>\n'
            % (
                utils.dots_to_hyphens(i.name),
                m.name,
                i.name_without_prefix,
                m.name,
                i.name,
                m.name,
            )
        )
        self.out.write("<programlisting>\n")
        self.print_method_prototype(i, m, in_synopsis=False)
        self.out.write("</programlisting>\n")
        self.out.write("%s\n" % (self.expand_paras(m.doc_string, True)))
        if m.in_args or m.out_args:
            self.out.write('<variablelist role="params">\n')
            for a in m.in_args:
                self.out.write("<varlistentry>\n")
                self.out.write(
                    "  <term><literal>IN %s <parameter>%s</parameter></literal>:</term>\n"
                    % (a.signature, a.name)
                )
                self.out.write(
                    "  <listitem>%s</listitem>\n"
                    % (self.expand_paras(a.doc_string, True))
                )
                self.out.write("</varlistentry>\n")
            for a in m.out_args:
                self.out.write("<varlistentry>\n")
                self.out.write(
                    "  <term><literal>OUT %s <parameter>%s</parameter></literal>:</term>\n"
                    % (a.signature, a.name)
                )
                self.out.write(
                    "  <listitem>%s</listitem>\n"
                    % (self.expand_paras(a.doc_string, True))
                )
                self.out.write("</varlistentry>\n")
            self.out.write("</variablelist>\n")
        if len(m.since) > 0:
            self.out.write('<para role="since">Since %s</para>\n' % (m.since))
        if m.deprecated:
            self.out.write(
                "<warning><para>The %s() method is deprecated.</para></warning>"
                % (m.name)
            )
        self.out.write("</refsect2>\n")

    def print_signal(self, i, s):
        self.out.write(
            '<refsect2 role="signal" id="gdbus-signal-%s.%s">\n'
            % (utils.dots_to_hyphens(i.name), s.name)
        )
        self.out.write('  <title>The "%s" signal</title>\n' % (s.name))
        self.out.write(
            '  <indexterm zone="gdbus-signal-%s.%s"><primary sortas="%s::%s">%s::%s</primary></indexterm>\n'
            % (
                utils.dots_to_hyphens(i.name),
                s.name,
                i.name_without_prefix,
                s.name,
                i.name,
                s.name,
            )
        )
        self.out.write("<programlisting>\n")
        self.print_signal_prototype(i, s, in_synopsis=False)
        self.out.write("</programlisting>\n")
        self.out.write("%s\n" % (self.expand_paras(s.doc_string, True)))
        if s.args:
            self.out.write('<variablelist role="params">\n')
            for a in s.args:
                self.out.write("<varlistentry>\n")
                self.out.write(
                    "  <term><literal>%s <parameter>%s</parameter></literal>:</term>\n"
                    % (a.signature, a.name)
                )
                self.out.write(
                    "  <listitem>%s</listitem>\n"
                    % (self.expand_paras(a.doc_string, True))
                )
                self.out.write("</varlistentry>\n")
            self.out.write("</variablelist>\n")
        if len(s.since) > 0:
            self.out.write('<para role="since">Since %s</para>\n' % (s.since))
        if s.deprecated:
            self.out.write(
                '<warning><para>The "%s" signal is deprecated.</para></warning>'
                % (s.name)
            )
        self.out.write("</refsect2>\n")

    def print_property(self, i, p):
        self.out.write(
            '<refsect2 role="property" id="gdbus-property-%s.%s">\n'
            % (utils.dots_to_hyphens(i.name), p.name)
        )
        self.out.write('  <title>The "%s" property</title>\n' % (p.name))
        self.out.write(
            '  <indexterm zone="gdbus-property-%s.%s"><primary sortas="%s:%s">%s:%s</primary></indexterm>\n'
            % (
                utils.dots_to_hyphens(i.name),
                p.name,
                i.name_without_prefix,
                p.name,
                i.name,
                p.name,
            )
        )
        self.out.write("<programlisting>\n")
        self.print_property_prototype(i, p, in_synopsis=False)
        self.out.write("</programlisting>\n")
        self.out.write("%s\n" % (self.expand_paras(p.doc_string, True)))
        if len(p.since) > 0:
            self.out.write('<para role="since">Since %s</para>\n' % (p.since))
        if p.deprecated:
            self.out.write(
                '<warning><para>The "%s" property is deprecated.</para></warning>'
                % (p.name)
            )
        self.out.write("</refsect2>\n")

    def expand(self, s, expandParamsAndConstants):
        for key in self.expand_member_dict_keys:
            s = s.replace(key, self.expand_member_dict[key])
        for key in self.expand_iface_dict_keys:
            s = s.replace(key, self.expand_iface_dict[key])
        if expandParamsAndConstants:
            # replace @foo with <parameter>foo</parameter>
            s = re.sub(
                "@[a-zA-Z0-9_]*",
                lambda m: "<parameter>" + m.group(0)[1:] + "</parameter>",
                s,
            )
            # replace e.g. %TRUE with <constant>TRUE</constant>
            s = re.sub(
                "%[a-zA-Z0-9_]*",
                lambda m: "<constant>" + m.group(0)[1:] + "</constant>",
                s,
            )
        return s

    def expand_paras(self, s, expandParamsAndConstants):
        s = self.expand(s, expandParamsAndConstants).strip()
        res = []
        if not s.startswith("<para>"):
            res.append("<para>")
        for line in s.split("\n"):
            line = line.strip()
            if not line:
                line = "</para><para>"
            res.append(line)
        if not s.endswith("</para>"):
            res.append("</para>")
        return "\n".join(res)

    def generate_expand_dicts(self):
        self.expand_member_dict = {}
        self.expand_iface_dict = {}
        for i in self.ifaces:
            key = "#%s" % (i.name)
            value = '<link linkend="gdbus-interface-%s.top_of_page">%s</link>' % (
                utils.dots_to_hyphens(i.name),
                i.name,
            )
            self.expand_iface_dict[key] = value
            for m in i.methods:
                key = "%s.%s()" % (i.name, m.name)
                value = '<link linkend="gdbus-method-%s.%s">%s()</link>' % (
                    utils.dots_to_hyphens(i.name),
                    m.name,
                    m.name,
                )
                self.expand_member_dict[key] = value
            for s in i.signals:
                key = "#%s::%s" % (i.name, s.name)
                value = '<link linkend="gdbus-signal-%s.%s">"%s"</link>' % (
                    utils.dots_to_hyphens(i.name),
                    s.name,
                    s.name,
                )
                self.expand_member_dict[key] = value
            for p in i.properties:
                key = "#%s:%s" % (i.name, p.name)
                value = '<link linkend="gdbus-property-%s.%s">"%s"</link>' % (
                    utils.dots_to_hyphens(i.name),
                    p.name,
                    p.name,
                )
                self.expand_member_dict[key] = value
        # Make sure to expand the keys in reverse order so e.g. #org.foo.Iface:MediaCompat
        # is evaluated before #org.foo.Iface:Media ...
        self.expand_member_dict_keys = sorted(
            self.expand_member_dict.keys(), reverse=True
        )
        self.expand_iface_dict_keys = sorted(
            self.expand_iface_dict.keys(), reverse=True
        )

    def generate(self, docbook, outdir):
        for i in self.ifaces:
            self.out = open(path.join(outdir, "%s-%s.xml" % (docbook, i.name)), "w")
            self.out.write("")
            self.out.write('<?xml version="1.0" encoding="utf-8"?>\n')
            self.out.write(
                '<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"\n'
            )
            self.out.write(
                '               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" [\n'
            )
            self.out.write("]>\n")
            self.out.write('<refentry id="gdbus-%s">\n' % (i.name))
            self.out.write("  <refmeta>")
            self.out.write(
                '    <refentrytitle role="top_of_page" id="gdbus-interface-%s.top_of_page">%s</refentrytitle>\n'
                % (utils.dots_to_hyphens(i.name), i.name)
            )
            self.out.write(
                '  <indexterm zone="gdbus-interface-%s.top_of_page"><primary sortas="%s">%s</primary></indexterm>\n'
                % (utils.dots_to_hyphens(i.name), i.name_without_prefix, i.name)
            )
            self.out.write("  </refmeta>")

            self.out.write("  <refnamediv>")
            self.out.write("    <refname>%s</refname>" % (i.name))
            self.out.write("    <refpurpose>%s</refpurpose>" % (i.doc_string_brief))
            self.out.write("  </refnamediv>")

            if len(i.methods) > 0:
                self.print_synopsis_methods(i)
            if len(i.signals) > 0:
                self.print_synopsis_signals(i)
            if len(i.properties) > 0:
                self.print_synopsis_properties(i)

            self.out.write(
                '<refsect1 role="desc" id="gdbus-interface-%s">\n'
                % (utils.dots_to_hyphens(i.name))
            )
            self.out.write('  <title role="desc.title">Description</title>\n')
            self.out.write("  %s\n" % (self.expand_paras(i.doc_string, True)))
            if len(i.since) > 0:
                self.out.write('  <para role="since">Since %s</para>\n' % (i.since))
            if i.deprecated:
                self.out.write(
                    "<warning><para>The %s interface is deprecated.</para></warning>"
                    % (i.name)
                )
            self.out.write("</refsect1>\n")

            if len(i.methods) > 0:
                self.out.write(
                    '<refsect1 role="details" id="gdbus-methods-%s">\n' % (i.name)
                )
                self.out.write('  <title role="details.title">Method Details</title>\n')
                for m in i.methods:
                    self.print_method(i, m)
                self.out.write("</refsect1>\n")

            if len(i.signals) > 0:
                self.out.write(
                    '<refsect1 role="details" id="gdbus-signals-%s">\n' % (i.name)
                )
                self.out.write('  <title role="details.title">Signal Details</title>\n')
                for s in i.signals:
                    self.print_signal(i, s)
                self.out.write("</refsect1>\n")

            if len(i.properties) > 0:
                self.out.write(
                    '<refsect1 role="details" id="gdbus-properties-%s">\n' % (i.name)
                )
                self.out.write(
                    '  <title role="details.title">Property Details</title>\n'
                )
                for s in i.properties:
                    self.print_property(i, s)
                self.out.write("</refsect1>\n")

            self.out.write("</refentry>\n")
            self.out.write("\n")
                                                                                                                                                                    usr/share/glib-2.0/codegen/codegen_main.py                                                          0000644 0000000 0000000 00000040453 14375670023 016774  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # -*- Mode: Python -*-
# coding=utf-8

# GDBus - GLib D-Bus Library
#
# Copyright (C) 2008-2011 Red Hat, Inc.
# Copyright (C) 2018 Iñigo Martínez <inigomartinez@gmail.com>
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General
# Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
#
# Author: David Zeuthen <davidz@redhat.com>

import argparse
import os
import sys

from . import config
from . import dbustypes
from . import parser
from . import codegen
from . import codegen_docbook
from . import codegen_rst
from .utils import print_error, print_warning


def find_arg(arg_list, arg_name):
    for a in arg_list:
        if a.name == arg_name:
            return a
    return None


def find_method(iface, method):
    for m in iface.methods:
        if m.name == method:
            return m
    return None


def find_signal(iface, signal):
    for m in iface.signals:
        if m.name == signal:
            return m
    return None


def find_prop(iface, prop):
    for m in iface.properties:
        if m.name == prop:
            return m
    return None


def apply_annotation(iface_list, iface, method, signal, prop, arg, key, value):
    iface_obj = None
    for i in iface_list:
        if i.name == iface:
            iface_obj = i
            break

    if iface_obj is None:
        print_error('No interface "{}"'.format(iface))

    target_obj = None

    if method:
        method_obj = find_method(iface_obj, method)
        if method_obj is None:
            print_error('No method "{}" on interface "{}"'.format(method, iface))
        if arg:
            arg_obj = find_arg(method_obj.in_args, arg)
            if arg_obj is None:
                arg_obj = find_arg(method_obj.out_args, arg)
                if arg_obj is None:
                    print_error(
                        'No arg "{}" on method "{}" on interface "{}"'.format(
                            arg, method, iface
                        )
                    )
            target_obj = arg_obj
        else:
            target_obj = method_obj
    elif signal:
        signal_obj = find_signal(iface_obj, signal)
        if signal_obj is None:
            print_error('No signal "{}" on interface "{}"'.format(signal, iface))
        if arg:
            arg_obj = find_arg(signal_obj.args, arg)
            if arg_obj is None:
                print_error(
                    'No arg "{}" on signal "{}" on interface "{}"'.format(
                        arg, signal, iface
                    )
                )
            target_obj = arg_obj
        else:
            target_obj = signal_obj
    elif prop:
        prop_obj = find_prop(iface_obj, prop)
        if prop_obj is None:
            print_error('No property "{}" on interface "{}"'.format(prop, iface))
        target_obj = prop_obj
    else:
        target_obj = iface_obj
    target_obj.annotations.insert(0, dbustypes.Annotation(key, value))


def apply_annotations(iface_list, annotation_list):
    # apply annotations given on the command line
    for (what, key, value) in annotation_list:
        pos = what.find("::")
        if pos != -1:
            # signal
            iface = what[0:pos]
            signal = what[pos + 2 :]
            pos = signal.find("[")
            if pos != -1:
                arg = signal[pos + 1 :]
                signal = signal[0:pos]
                pos = arg.find("]")
                arg = arg[0:pos]
                apply_annotation(iface_list, iface, None, signal, None, arg, key, value)
            else:
                apply_annotation(
                    iface_list, iface, None, signal, None, None, key, value
                )
        else:
            pos = what.find(":")
            if pos != -1:
                # property
                iface = what[0:pos]
                prop = what[pos + 1 :]
                apply_annotation(iface_list, iface, None, None, prop, None, key, value)
            else:
                pos = what.find("()")
                if pos != -1:
                    # method
                    combined = what[0:pos]
                    pos = combined.rfind(".")
                    iface = combined[0:pos]
                    method = combined[pos + 1 :]
                    pos = what.find("[")
                    if pos != -1:
                        arg = what[pos + 1 :]
                        pos = arg.find("]")
                        arg = arg[0:pos]
                        apply_annotation(
                            iface_list, iface, method, None, None, arg, key, value
                        )
                    else:
                        apply_annotation(
                            iface_list, iface, method, None, None, None, key, value
                        )
                else:
                    # must be an interface
                    iface = what
                    apply_annotation(
                        iface_list, iface, None, None, None, None, key, value
                    )


def codegen_main():
    arg_parser = argparse.ArgumentParser(
        description="D-Bus code and documentation generator"
    )
    arg_parser.add_argument(
        "files", metavar="FILE", nargs="+", help="D-Bus introspection XML file"
    )
    arg_parser.add_argument(
        "--xml-files",
        metavar="FILE",
        action="append",
        default=[],
        help=argparse.SUPPRESS,
    )
    arg_parser.add_argument(
        "--interface-prefix",
        metavar="PREFIX",
        default="",
        help="String to strip from D-Bus interface names for code and docs",
    )
    arg_parser.add_argument(
        "--c-namespace",
        metavar="NAMESPACE",
        default="",
        help="The namespace to use for generated C code",
    )
    arg_parser.add_argument(
        "--c-generate-object-manager",
        action="store_true",
        help="Generate a GDBusObjectManagerClient subclass when generating C code",
    )
    arg_parser.add_argument(
        "--c-generate-autocleanup",
        choices=["none", "objects", "all"],
        default="objects",
        help="Generate autocleanup support",
    )
    arg_parser.add_argument(
        "--generate-docbook",
        metavar="OUTFILES",
        help="Generate Docbook in OUTFILES-org.Project.IFace.xml",
    )
    arg_parser.add_argument(
        "--generate-rst",
        metavar="OUTFILES",
        help="Generate reStructuredText in OUTFILES-org.Project.IFace.rst",
    )
    arg_parser.add_argument(
        "--pragma-once",
        action="store_true",
        help='Use "pragma once" as the inclusion guard',
    )
    arg_parser.add_argument(
        "--annotate",
        nargs=3,
        action="append",
        metavar="WHAT KEY VALUE",
        help="Add annotation (may be used several times)",
    )
    arg_parser.add_argument(
        "--glib-min-required",
        metavar="VERSION",
        help="Minimum version of GLib to be supported by the outputted code "
        "(default: 2.30)",
    )
    arg_parser.add_argument(
        "--glib-max-allowed",
        metavar="VERSION",
        help="Maximum version of GLib to be used by the outputted code "
        "(default: current GLib version)",
    )
    arg_parser.add_argument(
        "--symbol-decorator",
        help="Macro used to decorate a symbol in the outputted header, "
        "possibly to export symbols",
    )
    arg_parser.add_argument(
        "--symbol-decorator-header",
        help="Additional header required for decorator specified by "
        "--symbol-decorator",
    )
    arg_parser.add_argument(
        "--symbol-decorator-define",
        help="Additional define required for decorator specified by "
        "--symbol-decorator",
    )

    group = arg_parser.add_mutually_exclusive_group()
    group.add_argument(
        "--generate-c-code", metavar="OUTFILES", help="Generate C code in OUTFILES.[ch]"
    )
