				user.  See |undo-blocks|.
		  "entries"	A list of dictionaries with information about
				undo blocks.

		The first item in the "entries" list is the oldest undo item.
		Each List item is a |Dictionary| with these items:
		  "seq"		Undo sequence number.  Same as what appears in
				|:undolist|.
		  "time"	Timestamp when the change happened.  Use
				|strftime()| to convert to something readable.
		  "newhead"	Only appears in the item that is the last one
				that was added.  This marks the last change
				and where further changes will be added.
		  "curhead"	Only appears in the item that is the last one
				that was undone.  This marks the current
				position in the undo tree, the block that will
				be used by a redo command.  When nothing was
				undone after the last change this item will
				not appear anywhere.
		  "save"	Only appears on the last block before a file
				write.  The number is the write count.  The
				first write has number 1, the last one the
				"save_last" mentioned above.
		  "alt"		Alternate entry.  This is again a List of undo
				blocks.  Each item may again have an "alt"
				item.

uniq({list} [, {func} [, {dict}]])			*uniq()* *E882*
		Remove second and succeeding copies of repeated adjacent
		{list} items in-place.  Returns {list}.  If you want a list
		to remain unmodified make a copy first: >
			:let newlist = uniq(copy(mylist))
<		The default compare function uses the string representation of
		each item.  For the use of {func} and {dict} see |sort()|.

		Returns zero if {list} is not a |List|.

		Can also be used as a |method|: >
			mylist->uniq()

values({dict})						*values()*
		Return a |List| with all the values of {dict}.  The |List| is
		in arbitrary order.  Also see |items()| and |keys()|.
		Returns zero if {dict} is not a |Dict|.

		Can also be used as a |method|: >
			mydict->values()

virtcol({expr} [, {list}])				*virtcol()*
		The result is a Number, which is the screen column of the file
		position given with {expr}.  That is, the last screen position
		occupied by the character at that position, when the screen
		would be of unlimited width.  When there is a <Tab> at the
		position, the returned Number will be the column at the end of
		the <Tab>.  For example, for a <Tab> in column 1, with 'ts'
		set to 8, it returns 8. |conceal| is ignored.
		For the byte position use |col()|.

		For the use of {expr} see |col()|.

		When 'virtualedit' is used {expr} can be [lnum, col, off],
		where "off" is the offset in screen columns from the start of
		the character.  E.g., a position within a <Tab> or after the
		last character.  When "off" is omitted zero is used.  When
		Virtual editing is active in the current mode, a position
		beyond the end of the line can be returned.  Also see
		|'virtualedit'|

		The accepted positions are:
		    .	    the cursor position
		    $	    the end of the cursor line (the result is the
			    number of displayed characters in the cursor line
			    plus one)
		    'x	    position of mark x (if the mark is not set, 0 is
			    returned)
		    v       In Visual mode: the start of the Visual area (the
			    cursor is the end).  When not in Visual mode
			    returns the cursor position.  Differs from |'<| in
			    that it's updated right away.

		If {list} is present and non-zero then virtcol() returns a List
		with the first and last screen position occupied by the
		character.

		Note that only marks in the current file can be used.
		Examples: >
			" With text "foo^Lbar" and cursor on the "^L":

			virtcol(".")	" returns 5
			virtcol(".", 1)	" returns [4, 5]
			virtcol("$")	" returns 9

			" With text "	  there", with 't at 'h':

			virtcol("'t")	" returns 6
<		The first column is 1.  0 is returned for an error.
		A more advanced example that echoes the maximum length of
		all lines: >
		    echo max(map(range(1, line('$')), "virtcol([v:val, '$'])"))

<		Can also be used as a |method|: >
			GetPos()->virtcol()

virtcol2col({winid}, {lnum}, {col})			*virtcol2col()*
		The result is a Number, which is the byte index of the
		character in window {winid} at buffer line {lnum} and virtual
		column {col}.

		If {col} is greater than the last virtual column in line
		{lnum}, then the byte index of the character at the last
		virtual column is returned.

		The {winid} argument can be the window number or the
		|window-ID|. If this is zero, then the current window is used.

		Returns -1 if the window {winid} doesn't exist or the buffer
		line {lnum} or virtual column {col} is invalid.

		See also |screenpos()|, |virtcol()| and |col()|.

		Can also be used as a |method|: >
			GetWinid()->virtcol2col(lnum, col)

visualmode([{expr}])						*visualmode()*
		The result is a String, which describes the last Visual mode
		used in the current buffer.  Initially it returns an empty
		string, but once Visual mode has been used, it returns "v",
		"V", or "<CTRL-V>" (a single CTRL-V character) for
		character-wise, line-wise, or block-wise Visual mode
		respectively.
		Example: >
			:exe "normal " .. visualmode()
<		This enters the same Visual mode as before.  It is also useful
		in scripts if you wish to act differently depending on the
		Visual mode that was used.
		If Visual mode is active, use |mode()| to get the Visual mode
		(e.g., in a |:vmap|).
		If {expr} is supplied and it evaluates to a non-zero Number or
		a non-empty String, then the Visual mode will be cleared and
		the old value is returned.  See |non-zero-arg|.

wildmenumode()					*wildmenumode()*
		Returns |TRUE| when the wildmenu is active and |FALSE|
		otherwise.  See 'wildmenu' and 'wildmode'.
		This can be used in mappings to handle the 'wildcharm' option
		gracefully. (Makes only sense with |mapmode-c| mappings).

		For example to make <c-j> work like <down> in wildmode, use: >
    :cnoremap <expr> <C-j> wildmenumode() ? "\<Down>\<Tab>" : "\<c-j>"
<
		(Note, this needs the 'wildcharm' option set appropriately).

win_execute({id}, {command} [, {silent}])		*win_execute()*
		Like `execute()` but in the context of window {id}.
		The window will temporarily be made the current window,
		without triggering autocommands or changing directory.  When
		executing {command} autocommands will be triggered, this may
		have unexpected side effects.  Use |:noautocmd| if needed.
		Example: >
			call win_execute(winid, 'set syntax=python')
<		Doing the same with `setwinvar()` would not trigger
		autocommands and not actually show syntax highlighting.
							*E994*
		Not all commands are allowed in popup windows.
		When window {id} does not exist then no error is given and
		an empty string is returned.

		Can also be used as a |method|, the base is passed as the
		second argument: >
			GetCommand()->win_execute(winid)

win_findbuf({bufnr})					*win_findbuf()*
		Returns a |List| with |window-ID|s for windows that contain
		buffer {bufnr}.  When there is none the list is empty.

		Can also be used as a |method|: >
			GetBufnr()->win_findbuf()

win_getid([{win} [, {tab}]])				*win_getid()*
		Get the |window-ID| for the specified window.
		When {win} is missing use the current window.
		With {win} this is the window number.  The top window has
		number 1.
		Without {tab} use the current tab, otherwise the tab with
		number {tab}.  The first tab has number one.
		Return zero if the window cannot be found.

		Can also be used as a |method|: >
			GetWinnr()->win_getid()


win_gettype([{nr}])					*win_gettype()*
		Return the type of the window:
			"autocmd"	autocommand window. Temporary window
					used to execute autocommands.
			"command"	command-line window |cmdwin|
			(empty)		normal window
			"loclist"	|location-list-window|
			"popup"		popup window |popup|
			"preview"	preview window |preview-window|
			"quickfix"	|quickfix-window|
			"unknown"	window {nr} not found

		When {nr} is omitted return the type of the current window.
		When {nr} is given return the type of this window by number or
		|window-ID|.

		Also see the 'buftype' option.  When running a terminal in a
		popup window then 'buftype' is "terminal" and win_gettype()
		returns "popup".

		Can also be used as a |method|: >
			GetWinid()->win_gettype()
<
win_gotoid({expr})					*win_gotoid()*
		Go to window with ID {expr}.  This may also change the current
		tabpage.
		Return TRUE if successful, FALSE if the window cannot be found.

		Can also be used as a |method|: >
			GetWinid()->win_gotoid()

win_id2tabwin({expr})					*win_id2tabwin()*
		Return a list with the tab number and window number of window
		with ID {expr}: [tabnr, winnr].
		Return [0, 0] if the window cannot be found.

		Can also be used as a |method|: >
			GetWinid()->win_id2tabwin()

win_id2win({expr})					*win_id2win()*
		Return the window number of window with ID {expr}.
		Return 0 if the window cannot be found in the current tabpage.

		Can also be used as a |method|: >
			GetWinid()->win_id2win()

win_move_separator({nr}, {offset})			*win_move_separator()*
		Move window {nr}'s vertical separator (i.e., the right border)
		by {offset} columns, as if being dragged by the mouse. {nr}
		can be a window number or |window-ID|. A positive {offset}
		moves right and a negative {offset} moves left. Moving a
		window's vertical separator will change the width of the
		window and the width of other windows adjacent to the vertical
		separator. The magnitude of movement may be smaller than
		specified (e.g., as a consequence of maintaining
		'winminwidth'). Returns TRUE if the window can be found and
		FALSE otherwise.
		This will fail for the rightmost window and a full-width
		window, since it has no separator on the right.
		Only works for the current tab page. *E1308*

		Can also be used as a |method|: >
			GetWinnr()->win_move_separator(offset)

win_move_statusline({nr}, {offset})			*win_move_statusline()*
		Move window {nr}'s status line (i.e., the bottom border) by
		{offset} rows, as if being dragged by the mouse. {nr} can be a
		window number or |window-ID|. A positive {offset} moves down
		and a negative {offset} moves up. Moving a window's status
		line will change the height of the window and the height of
		other windows adjacent to the status line. The magnitude of
		movement may be smaller than specified (e.g., as a consequence
		of maintaining 'winminheight'). Returns TRUE if the window can
		be found and FALSE otherwise.
		Only works for the current tab page.

		Can also be used as a |method|: >
			GetWinnr()->win_move_statusline(offset)

win_screenpos({nr})					*win_screenpos()*
		Return the screen position of window {nr} as a list with two
		numbers: [row, col].  The first window always has position
		[1, 1], unless there is a tabline, then it is [2, 1].
		{nr} can be the window number or the |window-ID|.  Use zero
		for the current window.
		Returns [0, 0] if the window cannot be found in the current
		tabpage.

		Can also be used as a |method|: >
			GetWinid()->win_screenpos()
<
win_splitmove({nr}, {target} [, {options}])		*win_splitmove()*
		Move the window {nr} to a new split of the window {target}.
		This is similar to moving to {target}, creating a new window
		using |:split| but having the same contents as window {nr}, and
		then closing {nr}.

		Both {nr} and {target} can be window numbers or |window-ID|s.
		Both must be in the current tab page.

		Returns zero for success, non-zero for failure.

		{options} is a |Dictionary| with the following optional entries:
		  "vertical"	When TRUE, the split is created vertically,
				like with |:vsplit|.
		  "rightbelow"	When TRUE, the split is made below or to the
				right (if vertical).  When FALSE, it is done
				above or to the left (if vertical).  When not
				present, the values of 'splitbelow' and
				'splitright' are used.

		Can also be used as a |method|: >
			GetWinid()->win_splitmove(target)
<

							*winbufnr()*
winbufnr({nr})	The result is a Number, which is the number of the buffer
		associated with window {nr}.  {nr} can be the window number or
		the |window-ID|.
		When {nr} is zero, the number of the buffer in the current
		window is returned.
		When window {nr} doesn't exist, -1 is returned.
		Example: >
  :echo "The file in the current window is " . bufname(winbufnr(0))
<
		Can also be used as a |method|: >
			FindWindow()->winbufnr()->bufname()
<
							*wincol()*
wincol()	The result is a Number, which is the virtual column of the
		cursor in the window.  This is counting screen cells from the
		left side of the window.  The leftmost column is one.

							*windowsversion()*
windowsversion()
		The result is a String.  For MS-Windows it indicates the OS
		version.  E.g, Windows 10 is "10.0", Windows 8 is "6.2",
		Windows XP is "5.1".  For non-MS-Windows systems the result is
		an empty string.

winheight({nr})						*winheight()*
		The result is a Number, which is the height of window {nr}.
		{nr} can be the window number or the |window-ID|.
		When {nr} is zero, the height of the current window is
		returned.  When window {nr} doesn't exist, -1 is returned.
		An existing window always has a height of zero or more.
		This excludes any window toolbar line.
		Examples: >
  :echo "The current window has " .. winheight(0) .. " lines."

<		Can also be used as a |method|: >
			GetWinid()->winheight()
<
winlayout([{tabnr}])					*winlayout()*
		The result is a nested List containing the layout of windows
		in a tabpage.

		Without {tabnr} use the current tabpage, otherwise the tabpage
		with number {tabnr}. If the tabpage {tabnr} is not found,
		returns an empty list.

		For a leaf window, it returns:
			['leaf', {winid}]
		For horizontally split windows, which form a column, it
		returns:
			['col', [{nested list of windows}]]
		For vertically split windows, which form a row, it returns:
			['row', [{nested list of windows}]]

		Example: >
			" Only one window in the tab page
			:echo winlayout()
			['leaf', 1000]
			" Two horizontally split windows
			:echo winlayout()
			['col', [['leaf', 1000], ['leaf', 1001]]]
			" The second tab page, with three horizontally split
			" windows, with two vertically split windows in the
			" middle window
			:echo winlayout(2)
			['col', [['leaf', 1002], ['row', [['leaf', 1003],
					    ['leaf', 1001]]], ['leaf', 1000]]]
<
		Can also be used as a |method|: >
			GetTabnr()->winlayout()
<
							*winline()*
winline()	The result is a Number, which is the screen line of the cursor
		in the window.  This is counting screen lines from the top of
		the window.  The first line is one.
		If the cursor was moved the view on the file will be updated
		first, this may cause a scroll.

							*winnr()*
winnr([{arg}])	The result is a Number, which is the number of the current
		window.  The top window has number 1.
		Returns zero for a popup window.

		The optional argument {arg} supports the following values:
			$	the number of the last window (the window
				count).
			#	the number of the last accessed window (where
				|CTRL-W_p| goes to).  If there is no previous
				window or it is in another tab page 0 is
				returned.
			{N}j	the number of the Nth window below the
				current window (where |CTRL-W_j| goes to).
			{N}k	the number of the Nth window above the current
				window (where |CTRL-W_k| goes to).
			{N}h	the number of the Nth window left of the
				current window (where |CTRL-W_h| goes to).
			{N}l	the number of the Nth window right of the
				current window (where |CTRL-W_l| goes to).
		The number can be used with |CTRL-W_w| and ":wincmd w"
		|:wincmd|.
		When {arg} is invalid an error is given and zero is returned.
		Also see |tabpagewinnr()| and |win_getid()|.
		Examples: >
			let window_count = winnr('$')
			let prev_window = winnr('#')
			let wnum = winnr('3k')

<		Can also be used as a |method|: >
			GetWinval()->winnr()
<
							*winrestcmd()*
winrestcmd()	Returns a sequence of |:resize| commands that should restore
		the current window sizes.  Only works properly when no windows
		are opened or closed and the current window and tab page is
		unchanged.
		Example: >
			:let cmd = winrestcmd()
			:call MessWithWindowSizes()
			:exe cmd
<
							*winrestview()*
winrestview({dict})
		Uses the |Dictionary| returned by |winsaveview()| to restore
		the view of the current window.
		Note: The {dict} does not have to contain all values, that are
		returned by |winsaveview()|. If values are missing, those
		settings won't be restored. So you can use: >
		    :call winrestview({'curswant': 4})
<
		This will only set the curswant value (the column the cursor
		wants to move on vertical movements) of the cursor to column 5
		(yes, that is 5), while all other settings will remain the
		same. This is useful, if you set the cursor position manually.

		If you have changed the values the result is unpredictable.
		If the window size changed the result won't be the same.

		Can also be used as a |method|: >
			GetView()->winrestview()
<
							*winsaveview()*
winsaveview()	Returns a |Dictionary| that contains information to restore
		the view of the current window.  Use |winrestview()| to
		restore the view.
		This is useful if you have a mapping that jumps around in the
		buffer and you want to go back to the original view.
		This does not save fold information.  Use the 'foldenable'
		option to temporarily switch off folding, so that folds are
		not opened when moving around. This may have side effects.
		The return value includes:
			lnum		cursor line number
			col		cursor column (Note: the first column
					zero, as opposed to what |getcurpos()|
					returns)
			coladd		cursor column offset for 'virtualedit'
			curswant	column for vertical movement (Note:
					the first column is zero, as opposed
					to what |getcurpos()| returns).  After
					|$| command it will be a very large
					number equal to |v:maxcol|.
			topline		first line in the window
			topfill		filler lines, only in diff mode
			leftcol		first column displayed; only used when
					'wrap' is off
			skipcol		columns skipped
		Note that no option values are saved.


winwidth({nr})						*winwidth()*
		The result is a Number, which is the width of window {nr}.
		{nr} can be the window number or the |window-ID|.
		When {nr} is zero, the width of the current window is
		returned.  When window {nr} doesn't exist, -1 is returned.
		An existing window always has a width of zero or more.
		Examples: >
  :echo "The current window has " .. winwidth(0) .. " columns."
  :if winwidth(0) <= 50
  :  50 wincmd |
  :endif
<		For getting the terminal or screen size, see the 'columns'
		option.

		Can also be used as a |method|: >
			GetWinid()->winwidth()


wordcount()						*wordcount()*
		The result is a dictionary of byte/chars/word statistics for
		the current buffer.  This is the same info as provided by
		|g_CTRL-G|
		The return value includes:
			bytes		Number of bytes in the buffer
			chars		Number of chars in the buffer
			words		Number of words in the buffer
			cursor_bytes    Number of bytes before cursor position
					(not in Visual mode)
			cursor_chars    Number of chars before cursor position
					(not in Visual mode)
			cursor_words    Number of words before cursor position
					(not in Visual mode)
			visual_bytes    Number of bytes visually selected
					(only in Visual mode)
			visual_chars    Number of chars visually selected
					(only in Visual mode)
			visual_words    Number of words visually selected
					(only in Visual mode)


							*writefile()*
writefile({object}, {fname} [, {flags}])
		When {object} is a |List| write it to file {fname}.  Each list
		item is separated with a NL.  Each list item must be a String
		or Number.
		All NL characters are replaced with a NUL character.
		Inserting CR characters needs to be done before passing {list}
		to writefile().

		When {object} is a |Blob| write the bytes to file {fname}
		unmodified, also when binary mode is not specified.

		{flags} must be a String.  These characters are recognized:

		'b'  Binary mode is used: There will not be a NL after the
		     last list item.  An empty item at the end does cause the
		     last line in the file to end in a NL.

		'a'  Append mode is used, lines are appended to the file: >
			:call writefile(["foo"], "event.log", "a")
			:call writefile(["bar"], "event.log", "a")
<
		'D'  Delete the file when the current function ends.  This
		     works like: >
			:defer delete({fname})
<		     Fails when not in a function.  Also see |:defer|.

		's'  fsync() is called after writing the file.  This flushes
		     the file to disk, if possible.  This takes more time but
		     avoids losing the file if the system crashes.

		'S'  fsync() is not called, even when 'fsync' is set.

		     When {flags} does not contain "S" or "s" then fsync() is
		     called if the 'fsync' option is set.

		An existing file is overwritten, if possible.

		When the write fails -1 is returned, otherwise 0.  There is an
		error message if the file can't be created or when writing
		fails.

		Also see |readfile()|.
		To copy a file byte for byte: >
			:let fl = readfile("foo", "b")
			:call writefile(fl, "foocopy", "b")

<		Can also be used as a |method|: >
			GetText()->writefile("thefile")


xor({expr}, {expr})					*xor()*
		Bitwise XOR on the two arguments.  The arguments are converted
		to a number.  A List, Dict or Float argument causes an error.
		Also see `and()` and `or()`.
		Example: >
			:let bits = xor(bits, 0x80)
<
		Can also be used as a |method|: >
			:let bits = bits->xor(0x80)
<

==============================================================================
3. Feature list						*feature-list*

There are three types of features:
1.  Features that are only supported when they have been enabled when Vim
    was compiled |+feature-list|.  Example: >
	:if has("cindent")
<							*gui_running*
2.  Features that are only supported when certain conditions have been met.
    Example: >
	:if has("gui_running")
<							*has-patch*
3.  Beyond a certain version or at a certain version and including a specific
    patch.  The "patch-7.4.248" feature means that the Vim version is 7.5 or
    later, or it is version 7.4 and patch 248 was included.  Example: >
	:if has("patch-7.4.248")
<    Note that it's possible for patch 248 to be omitted even though 249 is
    included.  Only happens when cherry-picking patches.
    Note that this form only works for patch 7.4.237 and later, before that
    you need to check for the patch and the  v:version.  Example (checking
    version 6.2.148 or later): >
	:if v:version > 602 || (v:version == 602 && has("patch148"))

Hint: To find out if Vim supports backslashes in a file name (MS-Windows),
use: `if exists('+shellslash')`


acl			Compiled with |ACL| support.
all_builtin_terms	Compiled with all builtin terminals enabled. (always
			true)
amiga			Amiga version of Vim.
arabic			Compiled with Arabic support |Arabic|.
arp			Compiled with ARP support (Amiga).
autocmd			Compiled with autocommand support. (always true)
autochdir		Compiled with support for 'autochdir'
autoservername		Automatically enable |clientserver|
balloon_eval		Compiled with |balloon-eval| support.
balloon_multiline	GUI supports multiline balloons.
beos			BeOS version of Vim.
browse			Compiled with |:browse| support, and browse() will
			work.
browsefilter		Compiled with support for |browsefilter|.
bsd			Compiled on an OS in the BSD family (excluding macOS).
builtin_terms		Compiled with some builtin terminals. (always true)
byte_offset		Compiled with support for 'o' in 'statusline'
channel			Compiled with support for |channel| and |job|
cindent			Compiled with 'cindent' support. (always true)
clientserver		Compiled with remote invocation support |clientserver|.
clipboard		Compiled with 'clipboard' support.
clipboard_working	Compiled with 'clipboard' support and it can be used.
cmdline_compl		Compiled with |cmdline-completion| support.
cmdline_hist		Compiled with |cmdline-history| support.
cmdline_info		Compiled with 'showcmd' and 'ruler' support.
comments		Compiled with |'comments'| support.
compatible		Compiled to be very Vi compatible.
conpty			Platform where |ConPTY| can be used.
cryptv			Compiled with encryption support |encryption|.
cscope			Compiled with |cscope| support.
cursorbind		Compiled with |'cursorbind'| (always true)
debug			Compiled with "DEBUG" defined.
dialog_con		Compiled with console dialog support.
dialog_gui		Compiled with GUI dialog support.
diff			Compiled with |vimdiff| and 'diff' support.
digraphs		Compiled with support for digraphs.
directx			Compiled with support for DirectX and 'renderoptions'.
dnd			Compiled with support for the "~ register |quote_~|.
drop_file		Compiled with |drop_file| support.
ebcdic			Compiled on a machine with ebcdic character set.
emacs_tags		Compiled with support for Emacs tags.
eval			Compiled with expression evaluation support.  Always
			true, of course!
ex_extra		|+ex_extra| (always true)
extra_search		Compiled with support for |'incsearch'| and
			|'hlsearch'|
farsi			Support for Farsi was removed |farsi|.
file_in_path		Compiled with support for |gf| and |<cfile>| (always
			true)
filterpipe		When 'shelltemp' is off pipes are used for shell
			read/write/filter commands
find_in_path		Compiled with support for include file searches
			|+find_in_path|.
float			Compiled with support for |Float|.
fname_case		Case in file names matters (for Amiga and MS-Windows
			this is not present).
folding			Compiled with |folding| support.
footer			Compiled with GUI footer support. |gui-footer|
fork			Compiled to use fork()/exec() instead of system().
gettext			Compiled with message translation |multi-lang|
gui			Compiled with GUI enabled.
gui_athena		Compiled with Athena GUI (always false).
gui_gnome		Compiled with Gnome support (gui_gtk is also defined).
gui_gtk			Compiled with GTK+ GUI (any version).
gui_gtk2		Compiled with GTK+ 2 GUI (gui_gtk is also defined).
gui_gtk3		Compiled with GTK+ 3 GUI (gui_gtk is also defined).
gui_haiku		Compiled with Haiku GUI.
gui_mac			Compiled with Macintosh GUI.
gui_motif		Compiled with Motif GUI.
gui_photon		Compiled with Photon GUI.
gui_running		Vim is running in the GUI, or it will start soon.
gui_win32		Compiled with MS-Windows Win32 GUI.
gui_win32s		idem, and Win32s system being used (Windows 3.1)
haiku			Haiku version of Vim.
hangul_input		Compiled with Hangul input support. |hangul|
hpux			HP-UX version of Vim.
iconv			Can use iconv() for conversion.
insert_expand		Compiled with support for CTRL-X expansion commands in
			Insert mode. (always true)
job			Compiled with support for |channel| and |job|
ipv6			Compiled with support for IPv6 networking in |channel|.
jumplist		Compiled with |jumplist| support. (always true)
keymap			Compiled with 'keymap' support.
lambda			Compiled with |lambda| support.
langmap			Compiled with 'langmap' support.
libcall			Compiled with |libcall()| support.
linebreak		Compiled with 'linebreak', 'breakat', 'showbreak' and
			'breakindent' support.
linux			Linux version of Vim.
lispindent		Compiled with support for lisp indenting.
			(always true)
listcmds		Compiled with commands for the buffer list |:files|
			and the argument list |arglist|.
localmap		Compiled with local mappings and abbr. |:map-local|
lua			Compiled with Lua interface |Lua|.
mac			Any Macintosh version of Vim  cf. osx
macunix			Synonym for osxdarwin
menu			Compiled with support for |:menu|.
mksession		Compiled with support for |:mksession|.
modify_fname		Compiled with file name modifiers. |filename-modifiers|
			(always true)
mouse			Compiled with support for mouse.
mouse_dec		Compiled with support for Dec terminal mouse.
mouse_gpm		Compiled with support for gpm (Linux console mouse)
mouse_gpm_enabled	GPM mouse is working
mouse_netterm		Compiled with support for netterm mouse.
mouse_pterm		Compiled with support for qnx pterm mouse.
mouse_sysmouse		Compiled with support for sysmouse (*BSD console mouse)
mouse_sgr		Compiled with support for sgr mouse.
mouse_urxvt		Compiled with support for urxvt mouse.
mouse_xterm		Compiled with support for xterm mouse.
mouseshape		Compiled with support for 'mouseshape'.
multi_byte		Compiled with support for 'encoding' (always true)
multi_byte_encoding	'encoding' is set to a multibyte encoding.
multi_byte_ime		Compiled with support for IME input method.
multi_lang		Compiled with support for multiple languages.
mzscheme		Compiled with MzScheme interface |mzscheme|.
nanotime		Compiled with sub-second time stamp checks.
netbeans_enabled	Compiled with support for |netbeans| and connected.
netbeans_intg		Compiled with support for |netbeans|.
num64			Compiled with 64-bit |Number| support. (always true)
ole			Compiled with OLE automation support for Win32.
osx			Compiled for macOS  cf. mac
osxdarwin		Compiled for macOS, with |mac-darwin-feature|
packages		Compiled with |packages| support.
path_extra		Compiled with up/downwards search in 'path' and 'tags'
perl			Compiled with Perl interface.
persistent_undo		Compiled with support for persistent undo history.
postscript		Compiled with PostScript file printing.
printer			Compiled with |:hardcopy| support.
profile			Compiled with |:profile| support.
python			Python 2.x interface available. |has-python|
python_compiled		Compiled with Python 2.x interface. |has-python|
python_dynamic		Python 2.x interface is dynamically loaded. |has-python|
python3			Python 3.x interface available. |has-python|
python3_compiled	Compiled with Python 3.x interface. |has-python|
python3_dynamic		Python 3.x interface is dynamically loaded. |has-python|
pythonx			Python 2.x and/or 3.x interface available. |python_x|
qnx			QNX version of Vim.
quickfix		Compiled with |quickfix| support.
reltime			Compiled with |reltime()| support.
rightleft		Compiled with 'rightleft' support.
ruby			Compiled with Ruby interface |ruby|.
scrollbind		Compiled with 'scrollbind' support. (always true)
showcmd			Compiled with 'showcmd' support.
signs			Compiled with |:sign| support.
smartindent		Compiled with 'smartindent' support. (always true)
sodium			Compiled with libsodium for better crypt support
sound			Compiled with sound support, e.g. `sound_playevent()`
spell			Compiled with spell checking support |spell|.
startuptime		Compiled with |--startuptime| support.
statusline		Compiled with support for 'statusline', 'rulerformat'
			and special formats of 'titlestring' and 'iconstring'.
sun			SunOS version of Vim.
sun_workshop		Support for Sun |workshop| has been removed.
syntax			Compiled with syntax highlighting support |syntax|.
syntax_items		There are active syntax highlighting items for the
			current buffer.
system			Compiled to use system() instead of fork()/exec().
tag_binary		Compiled with binary searching in tags files
			|tag-binary-search|. (always true)
tag_old_static		Support for old static tags was removed, see
			|tag-old-static|.
tcl			Compiled with Tcl interface.
termguicolors		Compiled with true color in terminal support.
terminal		Compiled with |terminal| support.
terminfo		Compiled with terminfo instead of termcap.
termresponse		Compiled with support for |t_RV| and |v:termresponse|.
textobjects		Compiled with support for |text-objects|.
textprop		Compiled with support for |text-properties|.
tgetent			Compiled with tgetent support, able to use a termcap
			or terminfo file.
timers			Compiled with |timer_start()| support.
title			Compiled with window title support |'title'|.
			(always true)
toolbar			Compiled with support for |gui-toolbar|.
ttyin			input is a terminal (tty)
ttyout			output is a terminal (tty)
unix			Unix version of Vim. *+unix*
unnamedplus		Compiled with support for "unnamedplus" in 'clipboard'
user_commands		User-defined commands. (always true)
vartabs			Compiled with variable tabstop support |'vartabstop'|.
vcon			Win32: Virtual console support is working, can use
			'termguicolors'. Also see |+vtp|.
vertsplit		Compiled with vertically split windows |:vsplit|.
			(always true)
vim_starting		True while initial source'ing takes place. |startup|
			*vim_starting*
vim9script		Compiled with |Vim9| script support
viminfo			Compiled with viminfo support.
vimscript-1		Compiled Vim script version 1 support
vimscript-2		Compiled Vim script version 2 support
vimscript-3		Compiled Vim script version 3 support
vimscript-4		Compiled Vim script version 4 support
virtualedit		Compiled with 'virtualedit' option. (always true)
visual			Compiled with Visual mode. (always true)
visualextra		Compiled with extra Visual mode commands. (always
			true) |blockwise-operators|.
vms			VMS version of Vim.
vreplace		Compiled with |gR| and |gr| commands. (always true)
vtp			Compiled for vcon support |+vtp| (check vcon to find
			out if it works in the current console).
wildignore		Compiled with 'wildignore' option.
wildmenu		Compiled with 'wildmenu' option.
win16			old version for MS-Windows 3.1 (always false)
win32			Win32 version of Vim (MS-Windows 95 and later, 32 or
			64 bits)
win32unix		Win32 version of Vim, using Unix files (Cygwin)
win64			Win64 version of Vim (MS-Windows 64 bit).
win95			Win32 version for MS-Windows 95/98/ME (always false)
winaltkeys		Compiled with 'winaltkeys' option.
windows			Compiled with support for more than one window.
			(always true)
writebackup		Compiled with 'writebackup' default on.
xfontset		Compiled with X fontset support |xfontset|.
xim			Compiled with X input method support |xim|.
xpm			Compiled with pixmap support.
xpm_w32			Compiled with pixmap support for Win32. (Only for
			backward compatibility. Use "xpm" instead.)
xsmp			Compiled with X session management support.
xsmp_interact		Compiled with interactive X session management support.
xterm_clipboard		Compiled with support for xterm clipboard.
xterm_save		Compiled with support for saving and restoring the
			xterm screen.
x11			Compiled with X11 support.


==============================================================================
4. Matching a pattern in a String			*string-match*

This is common between several functions.  A regexp pattern as explained at
|pattern| is normally used to find a match in the buffer lines.  When a
pattern is used to find a match in a String, almost everything works in the
same way.  The difference is that a String is handled like it is one line.
When it contains a "\n" character, this is not seen as a line break for the
pattern.  It can be matched with a "\n" in the pattern, or with ".".  Example:
>
	:let a = "aaaa\nxxxx"
	:echo matchstr(a, "..\n..")
	aa
	xx
	:echo matchstr(a, "a.x")
	a
	x

Don't forget that "^" will only match at the first character of the String and
"$" at the last character of the string.  They don't match after or before a
"\n".

 vim:tw=78:ts=8:noet:ft=help:norl:
                                                                                            usr/share/vim/vim90/doc/change.txt                                                                  0000644 0000000 0000000 00000234361 14424703754 015474  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        *change.txt*    For Vim version 9.0.  Last change: 2023 Feb 27


		  VIM REFERENCE MANUAL    by Bram Moolenaar


This file describes commands that delete or change text.  In this context,
changing text means deleting the text and replacing it with other text using
one command.  You can undo all of these commands.  You can repeat the non-Ex
commands with the "." command.

1. Deleting text		|deleting|
2. Delete and insert		|delete-insert|
3. Simple changes		|simple-change|		*changing*
4. Complex changes		|complex-change|
   4.1 Filter commands		   |filter|
   4.2 Substitute		   |:substitute|
   4.3 Search and replace	   |search-replace|
   4.4 Changing tabs		   |change-tabs|
5. Copying and moving text	|copy-move|
6. Formatting text		|formatting|
7. Sorting text			|sorting|

For inserting text see |insert.txt|.

==============================================================================
1. Deleting text					*deleting* *E470*

["x]<Del>	or					*<Del>* *x* *dl*
["x]x			Delete [count] characters under and after the cursor
			[into register x] (not |linewise|).  Does the same as
			"dl".
			The <Del> key does not take a [count].  Instead, it
			deletes the last character of the count.
			See |:fixdel| if the <Del> key does not do what you
			want.  See |'whichwrap'| for deleting a line break
			(join lines).

							*X* *dh*
["x]X			Delete [count] characters before the cursor [into
			register x] (not |linewise|).  Does the same as "dh".
			Also see |'whichwrap'|.

							*d*
["x]d{motion}		Delete text that {motion} moves over [into register
			x].  See below for exceptions.

							*dd*
["x]dd			Delete [count] lines [into register x] |linewise|.

							*D*
["x]D			Delete the characters under the cursor until the end
			of the line and [count]-1 more lines [into register
			x]; synonym for "d$".
			(not |linewise|)
			When the '#' flag is in 'cpoptions' the count is
			ignored.

{Visual}["x]x	or					*v_x* *v_d* *v_<Del>*
{Visual}["x]d   or
{Visual}["x]<Del>	Delete the highlighted text [into register x] (for
			{Visual} see |Visual-mode|).

{Visual}["x]CTRL-H   or					*v_CTRL-H* *v_<BS>*
{Visual}["x]<BS>	When in Select mode: Delete the highlighted text [into
			register x].

{Visual}["x]X	or					*v_X* *v_D* *v_b_D*
{Visual}["x]D		Delete the highlighted lines [into register x] (for
			{Visual} see |Visual-mode|).  In Visual block mode,
			"D" deletes the highlighted text plus all text until
			the end of the line.

					*:d* *:de* *:del* *:delete* *:dl* *:dp*
:[range]d[elete] [x]	Delete [range] lines (default: current line) [into
			register x].
			Note these weird abbreviations:
			   :dl		delete and list
			   :dell	idem
			   :delel	idem
			   :deletl	idem
			   :deletel	idem
			   :dp		delete and print
			   :dep		idem
			   :delp	idem
			   :delep	idem
			   :deletp	idem
			   :deletep	idem

:[range]d[elete] [x] {count}
			Delete {count} lines, starting with [range]
			(default: current line |cmdline-ranges|) [into
			register x].

These commands delete text.  You can repeat them with the `.` command
(except `:d`) and undo them.  Use Visual mode to delete blocks of text.  See
|registers| for an explanation of registers.

An exception for the d{motion} command: If the motion is not linewise, the
start and end of the motion are not in the same line, and there are only
blanks before the start and there are no non-blanks after the end of the
motion, the delete becomes linewise.  This means that the delete also removes
the line of blanks that you might expect to remain. Use the |o_v| operator to
force the motion to be characterwise.

Trying to delete an empty region of text (e.g., "d0" in the first column)
is an error when 'cpoptions' includes the 'E' flag.

							*J*
J			Join [count] lines, with a minimum of two lines.
			Remove the indent and insert up to two spaces (see
			below).  Fails when on the last line of the buffer.
			If [count] is too big it is reduced to the number of
			lines available.

							*v_J*
{Visual}J		Join the highlighted lines, with a minimum of two
			lines.  Remove the indent and insert up to two spaces
			(see below).

							*gJ*
gJ			Join [count] lines, with a minimum of two lines.
			Don't insert or remove any spaces.

							*v_gJ*
{Visual}gJ		Join the highlighted lines, with a minimum of two
			lines.  Don't insert or remove any spaces.

							*:j* *:join*
:[range]j[oin][!] [flags]
			Join [range] lines.  Same as "J", except with [!]
			the join does not insert or delete any spaces.
			If a [range] has equal start and end values, this
			command does nothing.  The default behavior is to
			join the current line with the line below it.
			See |ex-flags| for [flags].

:[range]j[oin][!] {count} [flags]
			Join {count} lines, starting with [range] (default:
			current line |cmdline-ranges|).  Same as "J", except
			with [!] the join does not insert or delete any
			spaces.
			See |ex-flags| for [flags].

These commands delete the <EOL> between lines.  This has the effect of joining
multiple lines into one line.  You can repeat these commands (except `:j`) and
