=head1 NAME

dh_installdeb - install files into the DEBIAN directory

=cut

use strict;
use warnings;
use Debian::Debhelper::Dh_Lib;

our $VERSION = DH_BUILTIN_VERSION;

=head1 SYNOPSIS

B<dh_installdeb> [S<I<debhelper options>>]

=head1 DESCRIPTION

B<dh_installdeb> is a debhelper program that is responsible for installing
files into the F<DEBIAN> directories in package build directories with the
correct permissions.

=head1 FILES

=over 4

=item I<package>.postinst

=item I<package>.preinst

=item I<package>.postrm

=item I<package>.prerm

These maintainer scripts are installed into the F<DEBIAN> directory.

B<dh_installdeb> will perform substitution of known tokens of
the pattern B<#TOKEN#>.  In generally, scripts will want to
include the B<#DEBHELPER#> to benefit from the shell scripts
generated by debhelper commands (including those from
B<dh_installdeb> when it processes I<package>.maintscript files).

The B<#DEBHELPER#> token should be placed on its own line as it is
often replaced by a multi-line shell script.

=item I<package>.triggers

=item I<package>.shlibs

These control files are installed into the F<DEBIAN> directory.

Note that I<package>.shlibs is only installed in compat level 9 and
earlier.  In compat 10, please use L<dh_makeshlibs(1)>.

=item I<package>.conffiles

This file will be installed into the F<DEBIAN> directory. The
provided file will be enriched by debhelper to include all the
B<conffiles> auto-detected by debhelper (the maintainer should
not list there as debhelper assumes it should handle that part).

This file is primarily useful for using "special" entries such as
the B<< remove-on-upgrade >> feature from dpkg.

=item I<package>.maintscript

Lines in this file correspond to L<dpkg-maintscript-helper(1)>
commands and parameters.  However, the "maint-script-parameters"
should I<not> be included as debhelper will add those automatically.

Example:

    # Correct
    rm_conffile /etc/obsolete.conf 0.2~ foo
    # INCORRECT
    rm_conffile /etc/obsolete.conf 0.2~ foo -- "$@"

In compat 10 or later, any shell metacharacters will be escaped, so
arbitrary shell code cannot be inserted here.  For example, a line
such as C<mv_conffile /etc/oldconffile /etc/newconffile> will insert
maintainer script snippets into all maintainer scripts sufficient to
move that conffile.

It was also the intention to escape shell metacharacters in previous
compat levels.  However, it did not work properly and as such it was
possible to embed arbitrary shell code in earlier compat levels.

The B<dh_installdeb> tool will do some basic validation of some of
the commands listed in this file to catch common mistakes.  The
validation is enabled as a warning since compat 10 and as a hard
error in compat 12.

Where possible, B<dh_installdeb> may choose to rewrite some or all
of the entries into equivalent features supported in dpkg without
relying on maintainer scripts at its sole discretion (examples
include rewriting B<rm_conffile> into dpkg's B<remove-on-upgrade>).
The minimum requirement for activating this feature is that debhelper
runs in compat 10 or later.

Supports substitution variables in compat 13 and later as
documented in L<debhelper(7)>.

=back

=head1 OPTIONS

=over 4

=item B<-D>I<TOKEN=VALUE>, B<--define> I<TOKEN=VALUE>

Define tokens to be replaced inside the maintainer scripts when
it is generated.  Please note that the limitations described in
L</Limitations in token names> also applies to tokens defined
on the command line.  Invalid token names will trigger an error.

In the simple case, this parameter will cause B<< #I<TOKEN># >>
to be replaced by I<VALUE>.  If I<VALUE> starts with a literal
I<@>-sign, then I<VALUE> is expected to point to a file
containing the actual value to insert.

An explicit declared token with this parameter will replace built-in
tokens.

Test examples to aid with the understanding:

	cat >> debian/postinst <<EOF
	#SIMPLE#
	#FILEBASED#
	EOF
	echo -n "Complex value" > some-file
    dh_installdeb --define SIMPLE=direct --define FILEBASED=@some-file

In this example, B<#SIMPLE#> will expand to B<direct> and B<#FILEBASED#>
will expand to B<Complex value>.

It is also possible to set package-specific values for a given
token.  This is useful when B<dh_installdeb> is acting on multiple
packages that need different values for the same token.  This is
done by prefixing the token name with B<< pkg.I<package-name>. >>.

This can be used as in the following example:

	cat >> debian/foo.postinst <<EOF
	# Script for #PACKAGE#
	#TOKEN#
	EOF
	cat >> debian/bar.postinst <<EOF
	# Script for #PACKAGE#
	#TOKEN#
	EOF
	cat >> debian/baz.postinst <<EOF
	# Script for #PACKAGE#
	#TOKEN#
	EOF
    dh_installdeb -pfoo -pbar -pbaz  --define TOKEN=default --define pkg.bar.TOKEN=unique-bar-value \
      --define pkg.baz.TOKEN=unique-baz-value

In this example, B<#TOKEN#> will expand to B<default> in F<debian/foo.postinst>,
to B<unique-bar-value> in F<debian/bar.postinst> and to B<unique-baz-value>
in F<debian/baz.postinst>.

Note that the B<#pkg.*#> tokens will be visible in all scripts acted on.  E.g.
you can refer to B<#pkg.bar.TOKEN#> inside F<debian/foo.postinst> and it will
be replaced by B<unique-bar-value>.

=back

=head1 SUBSTITUTION IN MAINTAINER SCRIPTS

The B<dh_installdeb> will automatically replace the following tokens
inside a provided maintainer script (if not replaced via B<-D>/B<--define>):

=over 4

=item #DEBHELPER#

This token is by default replaced with generated shell snippets debhelper
commands.  This includes the snippets generated by
B<dh_installdeb> from I<package>.maintscript file (if present).

=item #DEB_HOST_I<NAME>#, #DEB_BUILD_I<NAME>#, #DEB_TARGET_I<NAME>#

These tokens are replaced with the respective variable from
L<dpkg-architecture(1)>.  In almost all cases, you will want
use the B<< #DEB_HOST_I<NAME> >> variant in a script to ensure
you get the right value when cross-building.

On a best effort, tokens of this pattern that do not match
a variable in L<dpkg-architecture(1)> will be left as-is.

=item #ENV.I<NAME>#

These tokens of this form will be replaced with value of the
corresponding environment variable.  If the environment
variable is unset, the token is replaced with the empty
string.

Note that there are limits on which names can be used (see
L</Limitations in token names>).

=item #PACKAGE#

This token is by default replaced by the package name, which will contain
the concrete script.

=back

=head2 Limitations in token names

All tokens intended to be substituted must match the regex: #[A-Za-z0-9_.+]+#

Tokens that do not match that regex will be silently ignored if found in the
script template.  Invalid token names passed to B<-D> or B<--define> will
cause B<dh_installdeb> to reject the command with an error in most cases.

=cut

my %PROVIDED_SUBST;

init(options => {
	'define|D=s%' => \%PROVIDED_SUBST,
});

# dpkg-maintscript-helper commands with their associated dpkg pre-dependency
# versions.
my %maintscript_predeps = (
	"rm_conffile" => "",
	"mv_conffile" => "",
	"symlink_to_dir" => "",
	"dir_to_symlink" => "",
);
my %maintscript_validator = (
	"rm_conffile" => \&_validate_conffile_args,
	"mv_conffile" => \&_validate_conffile_args,
);

foreach my $package (@{$dh{DOPACKAGES}}) {
	my $tmp=tmpdir($package);

	install_dir("$tmp/DEBIAN");

	if (is_udeb($package)) {
		# For udebs, only do the postinst, and no #DEBHELPER#.
		# Udebs also support menutest and isinstallable scripts.
		foreach my $script (qw{postinst menutest isinstallable}) {
			my $f=pkgfile($package,$script);
			if ($f) {
				install_prog($f, "$tmp/DEBIAN/$script");
			}
		}

		# stop here for udebs
		next;
	}
	
	my $maintscriptfile=pkgfile($package, "maintscript");
	my @special_conffiles_entries;
	if ($maintscriptfile) {
		if (compat(9)) {
			foreach my $line (filedoublearray($maintscriptfile)) {
				my $cmd=$line->[0];
				error("unknown dpkg-maintscript-helper command: $cmd")
					unless exists $maintscript_predeps{$cmd};
				addsubstvar($package, "misc:Pre-Depends", "dpkg",
					">= $maintscript_predeps{$cmd}")
					if length $maintscript_predeps{$cmd};
				my $params=escape_shell(@$line);
				foreach my $script (qw{postinst preinst prerm postrm}) {
					autoscript($package, $script, "maintscript-helper",
							   "s!#PARAMS#!$params!g");
				}
			}
		} else {
			my @maintscripts = filedoublearray($maintscriptfile);
			my @params;
			foreach my $line (@maintscripts) {
				my $cmd=$line->[0];
				error("unknown dpkg-maintscript-helper command: $cmd")
					unless exists $maintscript_predeps{$cmd};
				addsubstvar($package, "misc:Pre-Depends", "dpkg",
					">= $maintscript_predeps{$cmd}")
					if length $maintscript_predeps{$cmd};
				if (my $validator = $maintscript_validator{$cmd}) {
					$validator->($package, @{$line});
				}
				if (0) {  # Disabled for now: #994919 + #994903
					my $current_conffile = $line->[1];
					push(@special_conffiles_entries, "remove-on-upgrade ${current_conffile}");
					addsubstvar($package, "misc:Pre-Depends", "dpkg (>= 1.20.6~)");
					next;
				}
				push(@params, escape_shell(@{$line}) );
			}
			if (@params) {
				foreach my $script (qw{postinst preinst prerm postrm}) {
					my $subst = sub {
						my @res;
						chomp;
						for my $param (@params) {
							my $line = $_;
							$line =~ s{#PARAMS#}{$param}g;
							push(@res, $line);
						}
						$_ = join("\n", @res) . "\n";
					};
					autoscript($package, $script, "maintscript-helper", $subst);
				}
			}
		}
	}

	# Install debian scripts.
	my $package_subst = debhelper_script_per_package_subst($package, \%PROVIDED_SUBST);
	foreach my $script (qw{postinst preinst prerm postrm}) {
		debhelper_script_subst($package, $script, $package_subst);
	}

	# Install non-executable files
	my @non_exec_files;
	# Removed in compat 12.
	push(@non_exec_files, 'conffiles');
	# In compat 10, we let dh_makeshlibs handle "shlibs".
	push(@non_exec_files, 'shlibs') if compat(9);
	foreach my $file (@non_exec_files) {
		my $f=pkgfile($package,$file);
		if ($f) {
			install_file($f, "$tmp/DEBIAN/$file");
		}
	}

	install_triggers($package, $tmp);
	if (@special_conffiles_entries) {
		open(my $fd, '>>', "$tmp/DEBIAN/conffiles");
		for my $line (@special_conffiles_entries) {
			print {$fd} "${line}\n";
		}
		close($fd);
	}

	# Automatic conffiles registration: If it is in /etc, it is a
	# conffile.
	if ( -d "$tmp/etc") {
		complex_doit("find $tmp/etc -type f -printf '/etc/%P\n' | LC_ALL=C sort >> $tmp/DEBIAN/conffiles");
		# Anything found?
		if (-z "$tmp/DEBIAN/conffiles") {
			rm_files("$tmp/DEBIAN/conffiles");
		}
	}

	if ( -f "$tmp/DEBIAN/conffiles") {
		reset_perm_and_owner(0644, "$tmp/DEBIAN/conffiles");
	}
}

sub install_triggers {
	my ($package, $tmp) = @_;
	my $generated = generated_file($package, 'triggers', 0);
	my @sources = grep { -f $_ } (
		pkgfile($package, 'triggers'),
		$generated,
	);
	my $target = "$tmp/DEBIAN/triggers";
	return if not @sources;
	if (@sources > 1) {
		my $merged = "${generated}.merged";
		open(my $ofd, '>', $merged)
			or error("open ${target} failed: $!");
		for my $src (@sources) {
			open(my $ifd, '<', $src)
				or error("open ${src} failed: $!");
			print {$ofd} $_ while <$ifd>;
			close($ifd);
		}
		close($ofd)	or error("close ${merged} failed: $!");
		@sources = ($merged);
	}
	install_file($sources[0], $target);
}

sub _validate_conffile_args {
	my ($package, $cmd, @args) = @_;
	my ($current_conffile, $new_conffile, $prior_version, $owning_package, $other);
	for my $arg (@args) {
		if ($arg eq '--') {
			_maybe_error("The maintscripts file for $package includes a \"--\" for one of the ${cmd} commands, but it should not");
		}
	}
	if ($cmd eq 'rm_conffile') {
		($current_conffile, $prior_version, $owning_package, $other) = @args;
	} else {
		($current_conffile, $new_conffile, $prior_version, $owning_package, $other) = @args;
	}
	$current_conffile //= '';
	_maybe_error("The current conffile path for ${cmd} must be present and absolute, got ${current_conffile}")
		if not $current_conffile or substr($current_conffile, 0, 1) ne '/';
	_maybe_error("The new conffile path for ${cmd} must be present and absolute, got ${new_conffile}")
		if $cmd eq 'mv_conffile' and (not $new_conffile or substr($new_conffile, 0, 1) ne '/');

	_maybe_error("The version for ${cmd} ${current_conffile} is not valid, got ${prior_version}")
		if $prior_version and $prior_version !~ m{^${Debian::Debhelper::Dh_Lib::PKGVERSION_REGEX}$}o;
	_maybe_error("The owning package for ${cmd} ${current_conffile} is not valid, got ${owning_package}")
		if $owning_package and $owning_package !~ m{^${Debian::Debhelper::Dh_Lib::PKGNAME_REGEX}$}o;
	if (defined($other)) {
		warning("Too many arguments for ${cmd} ${current_conffile}");
	}
}

sub _maybe_error {
	my ($msg) = @_;
	if (compat(11)) {
		warning($msg);
	} else {
		error($msg);
	}
}

=head1 SEE ALSO

L<debhelper(7)>

This program is a part of debhelper.

=head1 AUTHOR

Joey Hess <joeyh@debian.org>

=cut
                                                                                                                                                                                                                                                                                                             usr/bin/dh_installdebconf                                                                           0000755 0000000 0000000 00000015277 14354570042 014235  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/perl

=head1 NAME

dh_installdebconf - install files used by debconf in package build directories

=cut

use strict;
use warnings;
use Debian::Debhelper::Dh_Lib;

our $VERSION = DH_BUILTIN_VERSION;

=head1 SYNOPSIS

B<dh_installdebconf> [S<I<debhelper options>>] [B<-n>] [S<B<--> I<params>>]

=head1 DESCRIPTION

B<dh_installdebconf> is a debhelper program that is responsible for installing
files used by debconf into package build directories.

It also automatically generates the F<postrm> commands needed to interface
with debconf. The commands are added to the maintainer scripts by
B<dh_installdeb>. See L<dh_installdeb(1)> for an explanation of how that
works.

Note that if you use debconf, your package probably needs to depend on it
(it will be added to B<${misc:Depends}> by this program).

Note that for your config script to be called by B<dpkg>, your F<postinst>
needs to source debconf's confmodule. B<dh_installdebconf> does not
install this statement into the F<postinst> automatically as it is too
hard to do it right.

=head1 FILES

=over 4

=item debian/I<package>.config

This is the debconf F<config> script, and is installed into the F<DEBIAN>
directory in the package build directory.

Inside the script, the token B<#DEBHELPER#> is replaced with
shell script snippets generated by other debhelper commands.

=item debian/I<package>.templates

This is the debconf F<templates> file, and is installed into the F<DEBIAN>
directory in the package build directory.

=item F<debian/po/>

If this directory is present, this program will automatically use
L<po2debconf(1)> to generate merged templates
files that include the translations from there.

For this to work, your package should build-depend on F<po-debconf>.

=back

=head1 OPTIONS

=over 4

=item B<-n>, B<--no-scripts>

Do not modify F<postrm> script.

=item B<--> I<params>

Pass the params to B<po2debconf>.

=item B<-D>I<TOKEN=VALUE>, B<--define> I<TOKEN=VALUE>

Define tokens to be replaced inside the maintainer scripts when
it is generated.  Please note that the limitations described in
L</Limitations in token names> also applies to tokens defined
on the command line.  Invalid token names will trigger an error.

In the simple case, this parameter will cause B<< #I<TOKEN># >>
to be replaced by I<VALUE>.  If I<VALUE> starts with a literal
I<@>-sign, then I<VALUE> is expected to point to a file
containing the actual value to insert.

An explicit declared token with this parameter will replace built-in
tokens.

Test examples to aid with the understanding:

	cat >> debian/config <<EOF
	#SIMPLE#
	#FILEBASED#
	EOF
	echo -n "Complex value" > some-file
    dh_installdeb --define SIMPLE=direct --define FILEBASED=@some-file

In this example, B<#SIMPLE#> will expand to B<direct> and B<#FILEBASED#>
will expand to B<Complex value>.

It is also possible to set package-specific values for a given
token.  This is useful when B<dh_installdebconf> is acting on multiple
packages that need different values for the same token.  This is
done by prefixing the token name with B<< pkg.I<package-name>. >>.

This can be used as in the following example:

	cat >> debian/foo.config <<EOF
	# Script for #PACKAGE#
	#TOKEN#
	EOF
	cat >> debian/bar.config <<EOF
	# Script for #PACKAGE#
	#TOKEN#
	EOF
	cat >> debian/baz.config <<EOF
	# Script for #PACKAGE#
	#TOKEN#
	EOF
    dh_installdebconf -pfoo -pbar -pbaz  --define TOKEN=default --define pkg.bar.TOKEN=unique-bar-value \
      --define pkg.baz.TOKEN=unique-baz-value

In this example, B<#TOKEN#> will expand to B<default> in F<debian/foo.config>,
to B<unique-bar-value> in F<debian/bar.config> and to B<unique-baz-value>
in F<debian/baz.config>.

Note that the B<#pkg.*#> tokens will be visible in all scripts acted on.  E.g.
you can refer to B<#pkg.bar.TOKEN#> inside F<debian/foo.config> and it will
be replaced by B<unique-bar-value>.

=back

=head1 SUBSTITUTION IN MAINTAINER SCRIPTS

The B<dh_installdebconf> will automatically replace the following tokens
inside a provided maintainer script (if not replaced via B<-D>/B<--define>):

=over 4

=item #DEB_HOST_I<NAME>#, #DEB_BUILD_I<NAME>#, #DEB_TARGET_I<NAME>#

These tokens are replaced with the respective variable from
L<dpkg-architecture(1)>.  In almost all cases, you will want
use the B<< #DEB_HOST_I<NAME> >> variant in a script to ensure
you get the right value when cross-building.

On a best effort, tokens of this pattern that do not match
a variable in L<dpkg-architecture(1)> will be left as-is.

=item #ENV.I<NAME>#

These tokens of this form will be replaced with value of the
corresponding environment variable.  If the environment
variable is unset, the token is replaced with the empty
string.

Note that there are limits on which names can be used (see
L</Limitations in token names>).

=item #PACKAGE#

This token is by default replaced by the package name, which will contain
the concrete script.

=back

=head2 Limitations in token names

All tokens intended to be substituted must match the regex: #[A-Za-z0-9_.+]+#

Tokens that do not match that regex will be silently ignored if found in the
script template.  Invalid token names passed to B<-D> or B<--define> will
cause B<dh_installdebconf> to reject the command with an error in most cases.

=cut

my %PROVIDED_SUBST;

init(options => {
	'define|D=s%' => \%PROVIDED_SUBST,
});

my @extraparams;
if (defined($dh{U_PARAMS})) {
	@extraparams=@{$dh{U_PARAMS}};
}

# PROMISE: DH NOOP WITHOUT config templates cli-options()

foreach my $package (@{$dh{DOPACKAGES}}) {
	my $tmp=tmpdir($package);
	my $config=pkgfile($package,"config");
	my $templates=pkgfile($package,"templates");

	install_dir("$tmp/DEBIAN");

	if (! is_udeb($package)) {
		# Install debian scripts.
		my $package_subst = debhelper_script_per_package_subst($package, \%PROVIDED_SUBST);
		debhelper_script_subst($package, "config", $package_subst);
	}
	
	if ($templates ne '') {
		# Are there old-style translated templates?
		if (glob("$templates.??"), glob("$templates.??_??")) {
			warning "Ignoring debian/templates.ll files. Switch to po-debconf!";
		}

		umask(0022); # since I do a redirect below

		if (-d "debian/po") {
			complex_doit("po2debconf @extraparams $templates > $tmp/DEBIAN/templates");
		}
		else {
			install_file($templates,"$tmp/DEBIAN/templates");
		}
	}

	# I'm going with debconf 0.5 because it was the first
	# "modern" one. udebs just need cdebconf.
	my $debconfdep=is_udeb($package) ? "cdebconf-udeb" : "debconf (>= 0.5) | debconf-2.0";
	if ($config ne '' || $templates ne '') {
		addsubstvar($package, "misc:Depends", $debconfdep);
	}
	
	if (($config ne '' || $templates ne '') && ! $dh{NOSCRIPTS}) {
		autoscript($package,"postrm","postrm-debconf");
	}
}

=head1 SEE ALSO

L<debhelper(7)>

This program is a part of debhelper.

=head1 AUTHOR

Joey Hess <joeyh@debian.org>

=cut
                                                                                                                                                                                                                                                                                                                                 usr/bin/dh_installdirs                                                                              0000755 0000000 0000000 00000006132 14354570042 013564  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/perl

=head1 NAME

dh_installdirs - create subdirectories in package build directories

=cut

use strict;
use warnings;
use Debian::Debhelper::Dh_Lib;

our $VERSION = DH_BUILTIN_VERSION;

=head1 SYNOPSIS

B<dh_installdirs> [S<I<debhelper options>>] [B<-A>] [B<--sourcedir=>I<dir>] [B<--create-in-sourcedir>] [S<I<dir> ...>]

=head1 DESCRIPTION

B<dh_installdirs> is a debhelper program that is responsible for creating
subdirectories in package build directories.

Many packages can get away with omitting the call to B<dh_installdirs>
completely.  Notably, other B<dh_*> commands are expected to create
directories as needed.

=head1 FILES

=over 4

=item debian/I<package>.dirs

Lists directories to be created in I<package>.

Generally, there is no need to list directories created by the
upstream build system or directories needed by other B<debhelper>
commands.

Supports substitution variables in compat 13 and later as
documented in L<debhelper(7)>.

=back

=head1 OPTIONS

=over 4

=item B<-A>, B<--all>

Create any directories specified by command line parameters in ALL packages
acted on, not just the first.

=item B<--create-in-sourcedir>, B<--no-create-in-sourcedir>

Whether to create the specified directories in the source directory
(usually F<debian/tmp>) I<in addition to> in the package build directory
(usually F<< debian/I<package> >>).

The default is B<--no-create-in-sourcedir>.

=item B<--sourcedir=>I<dir>

Consider I<dir> the source directory for the packages acted on instead
of the default (which is usually F<debian/tmp>).

Please note that this option is dependent on the
B<--create-in-sourcedir> option (when B<--no-create-in-sourcedir> is
in effect, this option does nothing in B<dh_installdirs>).

=item I<dir> ...

Create these directories in the package build directory of the first
package acted on. (Or in all packages if B<-A> is specified.)

=back

=cut

my $create_in_sourcedir = 0;

init(options => {
	'sourcedir=s' => \$dh{SOURCEDIR},
	'create-in-sourcedir!' => \$create_in_sourcedir,
});

# PROMISE: DH NOOP WITHOUT dirs cli-options()

foreach my $package (@{$dh{DOPACKAGES}}) {
	my $tmp=tmpdir($package);
	my $file=pkgfile($package,"dirs");
	my $srcdir = $dh{SOURCEDIR} // default_sourcedir($package);

	install_dir($tmp) if compat(10);

	my @dirs;

	if ($file) {
		@dirs=filearray($file)
	}

	if (($package eq $dh{FIRSTPACKAGE} || $dh{PARAMS_ALL}) && @ARGV) {
		push @dirs, @ARGV;
	}	

	if (@dirs) {
		# Stick the $tmp onto the front of all the dirs.
		# This is necessary, for 2 reasons, one to make them 
		# be in the right directory, but more importantly, it 
		# protects against the danger of absolute dirs being
		# specified.
		my @make_dirs;
		push(@make_dirs, map {
				my $dir = "$tmp/$_";
				$dir =~ tr:/:/:s; # just beautification.
				$dir;
			} @dirs);
		if ($create_in_sourcedir) {
			push(@make_dirs, map {
					my $dir = "${srcdir}/$_";
					$dir =~ tr:/:/:s; # just beautification.
					$dir;
				} @dirs);
		}

		# Create dirs.
		install_dir(@make_dirs);
	}
}

=head1 SEE ALSO

L<debhelper(7)>

This program is a part of debhelper.

=head1 AUTHOR

Joey Hess <joeyh@debian.org>

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/bin/dh_installdocs                                                                              0000755 0000000 0000000 00000035230 14354570042 013554  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/perl

=encoding UTF-8

=head1 NAME

dh_installdocs - install documentation into package build directories

=cut

use strict;
use warnings;
use Debian::Debhelper::Dh_Lib;

our $VERSION = DH_BUILTIN_VERSION;

=head1 SYNOPSIS

B<dh_installdocs> [S<I<debhelper options>>] [B<-A>] [B<-X>I<item>] [S<I<file> ...>]

=head1 DESCRIPTION

B<dh_installdocs> is a debhelper program that is responsible for installing
documentation into F<usr/share/doc/package> in package build directories.

In compat 10 and earlier, L<dh_install(1)> may be a better tool for handling
the upstream documentation, when upstream's own build system installs all the desired documentation
correctly.  In this case, B<dh_installdocs> is still useful for installing
packaging related documentation (e.g. the F<debian/copyright> file).

From debhelper compatibility level 11 on, B<dh_install> will fall back to
looking in F<debian/tmp> for files, if it does not find them in the current
directory (or wherever you've told it to look using B<--sourcedir>).

In compat 11 and later, B<dh_installdocs> offers many of the features that
L<dh_install(1)> also has.  Furthermore, B<dh_installdocs> also supports
the B<nodoc> build profile to exclude documentation (regardless of compat
level).

=head1 FILES

=over 4

=item debian/I<package>.docs

List documentation files to be installed into I<package>.

Supports substitution variables in compat 13 and later as
documented in L<debhelper(7)>.

=item F<debian/copyright>

The copyright file is installed into all packages, unless a more
specific copyright file is available.

=item debian/I<package>.copyright

=item debian/I<package>.README.Debian

=item debian/I<package>.TODO

Each of these files is automatically installed if present for a
I<package>.

=item F<debian/README.Debian>

=item F<debian/TODO>

These files are installed into the first binary package listed in
debian/control.

Note that F<README.debian> files are also installed as F<README.Debian>,
and F<TODO> files will be installed as F<TODO.Debian> in non-native packages.

=item debian/I<package>.doc-base

Installed as doc-base control files. Note that the doc-id will be
determined from the B<Document:> entry in the doc-base control file in
question. In the event that multiple doc-base files in a single source
package share the same doc-id, they will be installed to
usr/share/doc-base/package instead of usr/share/doc-base/doc-id.

=item debian/I<package>.doc-base.*

If your package needs to register more than one document, you need
multiple doc-base files, and can name them like this. In the event
that multiple doc-base files of this style in a single source package
share the same doc-id, they will be installed to
usr/share/doc-base/package-* instead of usr/share/doc-base/doc-id.

Please be aware that this deduplication is currently done in memory
only, so for now it requires B<dh_installdocs> to be called no more
than once during the package build. Calling B<dh_installdocs
-p>I<package> in combination with using
F<debian/>I<package>F<.doc-base.*> files can lead to uninstallable
packages. See L<https://bugs.debian.org/980903> for details.

=back

=head1 OPTIONS

=over 4

=item B<-A>, B<--all>

Install all files specified by command line parameters in ALL packages
acted on.

=item B<-X>I<item>, B<--exclude=>I<item>

Exclude files that contain I<item> anywhere in their filename from
being installed. Note that this includes doc-base files.

=item B<--sourcedir=>I<dir>

Look in the specified directory for files to be installed.  This option
requires compat 11 or later (it is silently ignored in compat 10 or earlier).

Note that this is not the same as the B<--sourcedirectory> option used
by the B<dh_auto_>I<*> commands. You rarely need to use this option, since
B<dh_installman> automatically looks for files in F<debian/tmp> in debhelper
compatibility level 11 and above.

=item B<--doc-main-package=>I<main-package>

Set the main package for a documentation package.  This is used to
install the documentation of the documentation package in F<<
/usr/share/doc/I<main-package> >> as recommended by the Debian policy
manual 3.9.7 in §12.3.

In compat 11 (or later), this option is only useful if debhelper's
auto-detection of the main package is wrong.  The option can also be
used to silence a warning from debhelper when the auto-detection fails
but the default happens to be correct.

This option cannot be used when B<dh_installdocs> is instructed to act
on multiple packages.  If you need this option, you will generally
need to combine it with B<-p> to ensure exactly one package is acted
on.

Please keep in mind that some documentation (the copyright file,
README.Debian, etc.) will be unaffected by this option.

=item B<--link-doc=>I<package>

Make the documentation directory of all packages acted on be a symlink to
the documentation directory of I<package>. This has no effect when acting on
I<package> itself, or if the documentation directory to be created already
exists when B<dh_installdocs> is run. To comply with policy, I<package> must
be a binary package that comes from the same source package.

debhelper will try to avoid installing files into linked documentation
directories that would cause conflicts with the linked package. The B<-A>
option will have no effect on packages with linked documentation
directories, and F<copyright>, F<changelog>, F<README.Debian>, and F<TODO> files will
not be installed.

(An older method to accomplish the same thing, which is still supported,
is to make the documentation directory of a package be a dangling symlink,
before calling B<dh_installdocs>.)

Please note that this option only applies to the documentation
directory for the package itself.  When the package ships
documentation for another package (e.g. see B<--doc-main-package>), it
will not use a symlink for the documentation of the other package.


B<CAVEAT 1>: If a previous version of the package was built without this
option and is now built with it (or vice-versa), it requires a "dir to
symlink" (or "symlink to dir") migration.  Since debhelper has no
knowledge of previous versions, you have to enable this migration
itself.

This can be done by providing a "debian/I<package>.maintscript" file
and using L<dh_installdeb(1)> to provide the relevant maintainer
script snippets.

B<CAVEAT 2>: The use of B<--link-doc> should only be done when the
packages have same "architecture" type.  A link from an architecture
independent package to an architecture dependent package (or vice
versa) will not work.  Since compat 10, debhelper will actively reject
unsupported combinations.

=item I<file> ...

Install these files as documentation into the first package acted on. (Or
in all packages if B<-A> is specified).

=back
