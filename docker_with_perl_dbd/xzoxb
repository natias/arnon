
/* Expand to text that checks if ARG_COMB has type _Float128, and if
   so calls the appropriately suffixed FCT (which may include a cast),
   or FCT and CFCT for complex functions, with arguments ARG_CALL.  */
#  if __HAVE_DISTINCT_FLOAT128 && __GLIBC_USE (IEC_60559_TYPES_EXT)
#   if (!__HAVE_FLOAT64X			\
       || __HAVE_FLOAT64X_LONG_DOUBLE		\
       || !__HAVE_FLOATN_NOT_TYPEDEF)
#    define __TGMATH_F128(arg_comb, fct, arg_call)			\
  __builtin_types_compatible_p (__typeof (+(arg_comb)), _Float128)	\
  ? fct ## f128 arg_call :
#    define __TGMATH_CF128(arg_comb, fct, cfct, arg_call)		\
  __builtin_types_compatible_p (__typeof (+__real__ (arg_comb)), _Float128) \
  ? (__expr_is_real (arg_comb)						\
     ? fct ## f128 arg_call						\
     : cfct ## f128 arg_call) :
#   else
/* _Float64x is a distinct type at the C language level, which must be
   handled like _Float128.  */
#    define __TGMATH_F128(arg_comb, fct, arg_call)			\
  (__builtin_types_compatible_p (__typeof (+(arg_comb)), _Float128)	\
   || __builtin_types_compatible_p (__typeof (+(arg_comb)), _Float64x)) \
  ? fct ## f128 arg_call :
#    define __TGMATH_CF128(arg_comb, fct, cfct, arg_call)		\
  (__builtin_types_compatible_p (__typeof (+__real__ (arg_comb)), _Float128) \
   || __builtin_types_compatible_p (__typeof (+__real__ (arg_comb)),	\
				    _Float64x))				\
  ? (__expr_is_real (arg_comb)						\
     ? fct ## f128 arg_call						\
     : cfct ## f128 arg_call) :
#   endif
#  else
#   define __TGMATH_F128(arg_comb, fct, arg_call) /* Nothing.  */
#   define __TGMATH_CF128(arg_comb, fct, cfct, arg_call) /* Nothing.  */
#  endif

# endif /* !__HAVE_BUILTIN_TGMATH.  */

/* We have two kinds of generic macros: to support functions which are
   only defined on real valued parameters and those which are defined
   for complex functions as well.  */
# if __HAVE_BUILTIN_TGMATH

#  define __TGMATH_UNARY_REAL_ONLY(Val, Fct) __TGMATH_1 (Fct, (Val))
#  define __TGMATH_UNARY_REAL_RET_ONLY(Val, Fct) __TGMATH_1 (Fct, (Val))
#  define __TGMATH_BINARY_FIRST_REAL_ONLY(Val1, Val2, Fct)	\
  __TGMATH_2 (Fct, (Val1), (Val2))
#  define __TGMATH_BINARY_FIRST_REAL_STD_ONLY(Val1, Val2, Fct)	\
  __TGMATH_2STD (Fct, (Val1), (Val2))
#  define __TGMATH_BINARY_REAL_ONLY(Val1, Val2, Fct)	\
  __TGMATH_2 (Fct, (Val1), (Val2))
#  define __TGMATH_BINARY_REAL_STD_ONLY(Val1, Val2, Fct)	\
  __TGMATH_2STD (Fct, (Val1), (Val2))
#  define __TGMATH_TERNARY_FIRST_SECOND_REAL_ONLY(Val1, Val2, Val3, Fct) \
  __TGMATH_3 (Fct, (Val1), (Val2), (Val3))
#  define __TGMATH_TERNARY_REAL_ONLY(Val1, Val2, Val3, Fct)	\
  __TGMATH_3 (Fct, (Val1), (Val2), (Val3))
#  define __TGMATH_TERNARY_FIRST_REAL_RET_ONLY(Val1, Val2, Val3, Fct)	\
  __TGMATH_3 (Fct, (Val1), (Val2), (Val3))
#  define __TGMATH_UNARY_REAL_IMAG(Val, Fct, Cfct)	\
  __TGMATH_1C (Fct, Cfct, (Val))
#  define __TGMATH_UNARY_IMAG(Val, Cfct) __TGMATH_1 (Cfct, (Val))
#  define __TGMATH_UNARY_REAL_IMAG_RET_REAL(Val, Fct, Cfct)	\
  __TGMATH_1C (Fct, Cfct, (Val))
#  define __TGMATH_UNARY_REAL_IMAG_RET_REAL_SAME(Val, Cfct)	\
  __TGMATH_1 (Cfct, (Val))
#  define __TGMATH_BINARY_REAL_IMAG(Val1, Val2, Fct, Cfct)	\
  __TGMATH_2C (Fct, Cfct, (Val1), (Val2))

# else /* !__HAVE_BUILTIN_TGMATH.  */

#  define __TGMATH_UNARY_REAL_ONLY(Val, Fct)				\
  (__extension__ ((sizeof (+(Val)) == sizeof (double)			      \
		      || __builtin_classify_type (Val) != 8)		      \
		     ? (__tgmath_real_type (Val)) Fct (Val)		      \
		     : (sizeof (+(Val)) == sizeof (float))		      \
		     ? (__tgmath_real_type (Val)) Fct##f (Val)		      \
		     : __TGMATH_F128 ((Val), (__tgmath_real_type (Val)) Fct,  \
				      (Val))				      \
		     (__tgmath_real_type (Val)) __tgml(Fct) (Val)))

#  define __TGMATH_UNARY_REAL_RET_ONLY(Val, Fct) \
     (__extension__ ((sizeof (+(Val)) == sizeof (double)		      \
		      || __builtin_classify_type (Val) != 8)		      \
		     ? Fct (Val)					      \
		     : (sizeof (+(Val)) == sizeof (float))		      \
		     ? Fct##f (Val)					      \
		     : __TGMATH_F128 ((Val), Fct, (Val))		      \
		     __tgml(Fct) (Val)))

#  define __TGMATH_BINARY_FIRST_REAL_ONLY(Val1, Val2, Fct) \
     (__extension__ ((sizeof (+(Val1)) == sizeof (double)		      \
		      || __builtin_classify_type (Val1) != 8)		      \
		     ? (__tgmath_real_type (Val1)) Fct (Val1, Val2)	      \
		     : (sizeof (+(Val1)) == sizeof (float))		      \
		     ? (__tgmath_real_type (Val1)) Fct##f (Val1, Val2)	      \
		     : __TGMATH_F128 ((Val1), (__tgmath_real_type (Val1)) Fct, \
				    (Val1, Val2))			      \
		     (__tgmath_real_type (Val1)) __tgml(Fct) (Val1, Val2)))

#  define __TGMATH_BINARY_FIRST_REAL_STD_ONLY(Val1, Val2, Fct) \
     (__extension__ ((sizeof (+(Val1)) == sizeof (double)		      \
		      || __builtin_classify_type (Val1) != 8)		      \
		     ? (__tgmath_real_type (Val1)) Fct (Val1, Val2)	      \
		     : (sizeof (+(Val1)) == sizeof (float))		      \
		     ? (__tgmath_real_type (Val1)) Fct##f (Val1, Val2)	      \
		     : (__tgmath_real_type (Val1)) __tgml(Fct) (Val1, Val2)))

#  define __TGMATH_BINARY_REAL_ONLY(Val1, Val2, Fct) \
     (__extension__ ((sizeof ((Val1) + (Val2)) > sizeof (double)	      \
		      && __builtin_classify_type ((Val1) + (Val2)) == 8)      \
		     ? __TGMATH_F128 ((Val1) + (Val2),			      \
				      (__typeof				      \
				       ((__tgmath_real_type (Val1)) 0	      \
					+ (__tgmath_real_type (Val2)) 0)) Fct, \
				      (Val1, Val2))			      \
		     (__typeof ((__tgmath_real_type (Val1)) 0		      \
				+ (__tgmath_real_type (Val2)) 0))	      \
		     __tgml(Fct) (Val1, Val2)				      \
		     : (sizeof (+(Val1)) == sizeof (double)		      \
			|| sizeof (+(Val2)) == sizeof (double)		      \
			|| __builtin_classify_type (Val1) != 8		      \
			|| __builtin_classify_type (Val2) != 8)		      \
		     ? (__typeof ((__tgmath_real_type (Val1)) 0		      \
				   + (__tgmath_real_type (Val2)) 0))	      \
		       Fct (Val1, Val2)					      \
		     : (__typeof ((__tgmath_real_type (Val1)) 0		      \
				   + (__tgmath_real_type (Val2)) 0))	      \
		       Fct##f (Val1, Val2)))

#  define __TGMATH_BINARY_REAL_STD_ONLY(Val1, Val2, Fct) \
     (__extension__ ((sizeof ((Val1) + (Val2)) > sizeof (double)	      \
		      && __builtin_classify_type ((Val1) + (Val2)) == 8)      \
		     ? (__typeof ((__tgmath_real_type (Val1)) 0		      \
				  + (__tgmath_real_type (Val2)) 0))	      \
		       __tgml(Fct) (Val1, Val2)				      \
		     : (sizeof (+(Val1)) == sizeof (double)		      \
			|| sizeof (+(Val2)) == sizeof (double)		      \
			|| __builtin_classify_type (Val1) != 8		      \
			|| __builtin_classify_type (Val2) != 8)		      \
		     ? (__typeof ((__tgmath_real_type (Val1)) 0		      \
				   + (__tgmath_real_type (Val2)) 0))	      \
		       Fct (Val1, Val2)					      \
		     : (__typeof ((__tgmath_real_type (Val1)) 0		      \
				   + (__tgmath_real_type (Val2)) 0))	      \
		       Fct##f (Val1, Val2)))

#  define __TGMATH_TERNARY_FIRST_SECOND_REAL_ONLY(Val1, Val2, Val3, Fct) \
     (__extension__ ((sizeof ((Val1) + (Val2)) > sizeof (double)	      \
		      && __builtin_classify_type ((Val1) + (Val2)) == 8)      \
		     ? __TGMATH_F128 ((Val1) + (Val2),			      \
				      (__typeof				      \
				       ((__tgmath_real_type (Val1)) 0	      \
					+ (__tgmath_real_type (Val2)) 0)) Fct, \
				      (Val1, Val2, Val3))		      \
		     (__typeof ((__tgmath_real_type (Val1)) 0		      \
				+ (__tgmath_real_type (Val2)) 0))	      \
		     __tgml(Fct) (Val1, Val2, Val3)			      \
		     : (sizeof (+(Val1)) == sizeof (double)		      \
			|| sizeof (+(Val2)) == sizeof (double)		      \
			|| __builtin_classify_type (Val1) != 8		      \
			|| __builtin_classify_type (Val2) != 8)		      \
		     ? (__typeof ((__tgmath_real_type (Val1)) 0		      \
				   + (__tgmath_real_type (Val2)) 0))	      \
		       Fct (Val1, Val2, Val3)				      \
		     : (__typeof ((__tgmath_real_type (Val1)) 0		      \
				   + (__tgmath_real_type (Val2)) 0))	      \
		       Fct##f (Val1, Val2, Val3)))

#  define __TGMATH_TERNARY_REAL_ONLY(Val1, Val2, Val3, Fct) \
     (__extension__ ((sizeof ((Val1) + (Val2) + (Val3)) > sizeof (double)     \
		      && __builtin_classify_type ((Val1) + (Val2) + (Val3))   \
			 == 8)						      \
		     ? __TGMATH_F128 ((Val1) + (Val2) + (Val3),		      \
				      (__typeof				      \
				       ((__tgmath_real_type (Val1)) 0	      \
					+ (__tgmath_real_type (Val2)) 0	      \
					+ (__tgmath_real_type (Val3)) 0)) Fct, \
				      (Val1, Val2, Val3))		      \
		     (__typeof ((__tgmath_real_type (Val1)) 0		      \
				+ (__tgmath_real_type (Val2)) 0		      \
				+ (__tgmath_real_type (Val3)) 0))	      \
		       __tgml(Fct) (Val1, Val2, Val3)			      \
		     : (sizeof (+(Val1)) == sizeof (double)		      \
			|| sizeof (+(Val2)) == sizeof (double)		      \
			|| sizeof (+(Val3)) == sizeof (double)		      \
			|| __builtin_classify_type (Val1) != 8		      \
			|| __builtin_classify_type (Val2) != 8		      \
			|| __builtin_classify_type (Val3) != 8)		      \
		     ? (__typeof ((__tgmath_real_type (Val1)) 0		      \
				   + (__tgmath_real_type (Val2)) 0	      \
				   + (__tgmath_real_type (Val3)) 0))	      \
		       Fct (Val1, Val2, Val3)				      \
		     : (__typeof ((__tgmath_real_type (Val1)) 0		      \
				   + (__tgmath_real_type (Val2)) 0	      \
				   + (__tgmath_real_type (Val3)) 0))	      \
		       Fct##f (Val1, Val2, Val3)))

#  define __TGMATH_TERNARY_FIRST_REAL_RET_ONLY(Val1, Val2, Val3, Fct) \
     (__extension__ ((sizeof (+(Val1)) == sizeof (double)		\
		      || __builtin_classify_type (Val1) != 8)		\
		     ? Fct (Val1, Val2, Val3)				\
		     : (sizeof (+(Val1)) == sizeof (float))		\
		     ? Fct##f (Val1, Val2, Val3)			\
		     : __TGMATH_F128 ((Val1), Fct, (Val1, Val2, Val3))	\
		     __tgml(Fct) (Val1, Val2, Val3)))

/* XXX This definition has to be changed as soon as the compiler understands
   the imaginary keyword.  */
#  define __TGMATH_UNARY_REAL_IMAG(Val, Fct, Cfct) \
     (__extension__ ((sizeof (+__real__ (Val)) == sizeof (double)	      \
		      || __builtin_classify_type (__real__ (Val)) != 8)	      \
		     ? (__expr_is_real (Val)				      \
			? (__tgmath_complex_type (Val)) Fct (Val)	      \
			: (__tgmath_complex_type (Val)) Cfct (Val))	      \
		     : (sizeof (+__real__ (Val)) == sizeof (float))	      \
		     ? (__expr_is_real (Val)				      \
			? (__tgmath_complex_type (Val)) Fct##f (Val)	      \
			: (__tgmath_complex_type (Val)) Cfct##f (Val))	      \
		     : __TGMATH_CF128 ((Val),				      \
				       (__tgmath_complex_type (Val)) Fct,     \
				       (__tgmath_complex_type (Val)) Cfct,    \
				       (Val))				      \
		     (__expr_is_real (Val)				      \
		      ? (__tgmath_complex_type (Val)) __tgml(Fct) (Val)	      \
		      : (__tgmath_complex_type (Val)) __tgml(Cfct) (Val))))

#  define __TGMATH_UNARY_IMAG(Val, Cfct) \
     (__extension__ ((sizeof (+__real__ (Val)) == sizeof (double)	      \
		      || __builtin_classify_type (__real__ (Val)) != 8)	      \
		     ? (__typeof__ ((__tgmath_real_type (Val)) 0	      \
				    + _Complex_I)) Cfct (Val)		      \
		     : (sizeof (+__real__ (Val)) == sizeof (float))	      \
		     ? (__typeof__ ((__tgmath_real_type (Val)) 0	      \
				    + _Complex_I)) Cfct##f (Val)	      \
		     : __TGMATH_F128 (__real__ (Val),			      \
				      (__typeof__			      \
				       ((__tgmath_real_type (Val)) 0	      \
					+ _Complex_I)) Cfct, (Val))	      \
		     (__typeof__ ((__tgmath_real_type (Val)) 0		      \
				  + _Complex_I)) __tgml(Cfct) (Val)))

/* XXX This definition has to be changed as soon as the compiler understands
   the imaginary keyword.  */
#  define __TGMATH_UNARY_REAL_IMAG_RET_REAL(Val, Fct, Cfct) \
     (__extension__ ((sizeof (+__real__ (Val)) == sizeof (double)	      \
		      || __builtin_classify_type (__real__ (Val)) != 8)	      \
		     ? (__expr_is_real (Val)				      \
			? (__typeof__ (__real__ (__tgmath_real_type (Val)) 0))\
			  Fct (Val)					      \
			: (__typeof__ (__real__ (__tgmath_real_type (Val)) 0))\
			  Cfct (Val))					      \
		     : (sizeof (+__real__ (Val)) == sizeof (float))	      \
		     ? (__expr_is_real (Val)				      \
			? (__typeof__ (__real__ (__tgmath_real_type (Val)) 0))\
			  Fct##f (Val)					      \
			: (__typeof__ (__real__ (__tgmath_real_type (Val)) 0))\
			  Cfct##f (Val))				      \
		     : __TGMATH_CF128 ((Val), \
				       (__typeof__			      \
					(__real__			      \
					 (__tgmath_real_type (Val)) 0)) Fct,  \
				       (__typeof__			      \
					(__real__			      \
					 (__tgmath_real_type (Val)) 0)) Cfct, \
				       (Val))				      \
		     (__expr_is_real (Val)				      \
		      ? (__typeof__ (__real__ (__tgmath_real_type (Val)) 0))  \
		      __tgml(Fct) (Val)					      \
		      : (__typeof__ (__real__ (__tgmath_real_type (Val)) 0))  \
		      __tgml(Cfct) (Val))))
#  define __TGMATH_UNARY_REAL_IMAG_RET_REAL_SAME(Val, Cfct)	\
  __TGMATH_UNARY_REAL_IMAG_RET_REAL ((Val), Cfct, Cfct)

/* XXX This definition has to be changed as soon as the compiler understands
   the imaginary keyword.  */
#  define __TGMATH_BINARY_REAL_IMAG(Val1, Val2, Fct, Cfct) \
     (__extension__ ((sizeof (__real__ (Val1)				      \
			      + __real__ (Val2)) > sizeof (double)	      \
		      && __builtin_classify_type (__real__ (Val1)	      \
						  + __real__ (Val2)) == 8)    \
		     ? __TGMATH_CF128 ((Val1) + (Val2),			      \
				       (__typeof			      \
					((__tgmath_complex_type (Val1)) 0     \
					 + (__tgmath_complex_type (Val2)) 0)) \
				       Fct,				      \
				       (__typeof			      \
					((__tgmath_complex_type (Val1)) 0     \
					 + (__tgmath_complex_type (Val2)) 0)) \
				       Cfct,				      \
				       (Val1, Val2))			      \
		     (__expr_is_real ((Val1) + (Val2))			      \
		      ? (__typeof ((__tgmath_complex_type (Val1)) 0	      \
				   + (__tgmath_complex_type (Val2)) 0))	      \
		      __tgml(Fct) (Val1, Val2)				      \
		      : (__typeof ((__tgmath_complex_type (Val1)) 0	      \
				   + (__tgmath_complex_type (Val2)) 0))	      \
		      __tgml(Cfct) (Val1, Val2))			      \
		     : (sizeof (+__real__ (Val1)) == sizeof (double)	      \
			|| sizeof (+__real__ (Val2)) == sizeof (double)	      \
			|| __builtin_classify_type (__real__ (Val1)) != 8     \
			|| __builtin_classify_type (__real__ (Val2)) != 8)    \
		     ? (__expr_is_real ((Val1) + (Val2))		      \
			? (__typeof ((__tgmath_complex_type (Val1)) 0	      \
				   + (__tgmath_complex_type (Val2)) 0))	      \
			  Fct (Val1, Val2)				      \
			: (__typeof ((__tgmath_complex_type (Val1)) 0	      \
				   + (__tgmath_complex_type (Val2)) 0))	      \
			  Cfct (Val1, Val2))				      \
		     : (__expr_is_real ((Val1) + (Val2))		      \
			? (__typeof ((__tgmath_complex_type (Val1)) 0	      \
				   + (__tgmath_complex_type (Val2)) 0))	      \
			  Fct##f (Val1, Val2)				      \
			: (__typeof ((__tgmath_complex_type (Val1)) 0	      \
				   + (__tgmath_complex_type (Val2)) 0))	      \
			  Cfct##f (Val1, Val2))))

#  define __TGMATH_1_NARROW_F(F, X)					\
  (__extension__ (sizeof ((__tgmath_real_type (X)) 0) > sizeof (double) \
		  ? F ## l (X)						\
		  : F (X)))
#  define __TGMATH_2_NARROW_F(F, X, Y)					\
  (__extension__ (sizeof ((__tgmath_real_type (X)) 0			\
			  + (__tgmath_real_type (Y)) 0) > sizeof (double) \
		  ? F ## l (X, Y)					\
		  : F (X, Y)))
#  define __TGMATH_3_NARROW_F(F, X, Y, Z)				\
  (__extension__ (sizeof ((__tgmath_real_type (X)) 0			\
			  + (__tgmath_real_type (Y)) 0			\
			  + (__tgmath_real_type (Z)) 0) > sizeof (double) \
		  ? F ## l (X, Y, Z)					\
		  : F (X, Y, Z)))
/* In most cases, these narrowing macro definitions based on sizeof
   ensure that the function called has the right argument format, as
   for other <tgmath.h> macros for compilers before GCC 8, but may not
   have exactly the argument type (among the types with that format)
   specified in the standard logic.

   In the case of macros for _Float32x return type, when _Float64x
   exists, _Float64 arguments should result in the *f64 function being
   called while _Float32x arguments should result in the *f64x
   function being called.  These cases cannot be distinguished using
   sizeof (or at all if the types are typedefs rather than different
   types).  However, for these functions it is OK (does not affect the
   final result) to call a function with any argument format at least
   as wide as all the floating-point arguments, unless that affects
   rounding of integer arguments.  Integer arguments are considered to
   have type _Float64, so the *f64 functions are preferred for f32x*
   macros when no argument has a wider floating-point type.  */
#  if __HAVE_FLOAT64X_LONG_DOUBLE && __HAVE_DISTINCT_FLOAT128
#   define __TGMATH_1_NARROW_F32(F, X)					\
  (__extension__ (sizeof ((__tgmath_real_type (X)) 0) > sizeof (_Float64) \
		  ? __TGMATH_F128 ((X), F, (X))				\
		  F ## f64x (X)						\
		  : F ## f64 (X)))
#   define __TGMATH_2_NARROW_F32(F, X, Y)				\
  (__extension__ (sizeof ((__tgmath_real_type (X)) 0			\
			  + (__tgmath_real_type (Y)) 0) > sizeof (_Float64) \
		  ? __TGMATH_F128 ((X) + (Y), F, (X, Y))		\
		  F ## f64x (X, Y)					\
		  : F ## f64 (X, Y)))
#   define __TGMATH_3_NARROW_F32(F, X, Y, Z)				\
  (__extension__ (sizeof ((__tgmath_real_type (X)) 0			\
			  + (__tgmath_real_type (Y)) 0			\
			  + (__tgmath_real_type (Z)) 0) > sizeof (_Float64) \
		  ? __TGMATH_F128 ((X) + (Y) + (Z), F, (X, Y, Z))	\
		  F ## f64x (X, Y, Z)					\
		  : F ## f64 (X, Y, Z)))
#   define __TGMATH_1_NARROW_F64(F, X)					\
  (__extension__ (sizeof ((__tgmath_real_type (X)) 0) > sizeof (_Float64) \
		  ? __TGMATH_F128 ((X), F, (X))				\
		  F ## f64x (X)						\
		  : F ## f128 (X)))
#   define __TGMATH_2_NARROW_F64(F, X, Y)				\
  (__extension__ (sizeof ((__tgmath_real_type (X)) 0			\
			  + (__tgmath_real_type (Y)) 0) > sizeof (_Float64) \
		  ? __TGMATH_F128 ((X) + (Y), F, (X, Y))		\
		  F ## f64x (X, Y)					\
		  : F ## f128 (X, Y)))
#   define __TGMATH_3_NARROW_F64(F, X, Y, Z)				\
  (__extension__ (sizeof ((__tgmath_real_type (X)) 0			\
			  + (__tgmath_real_type (Y)) 0			\
			  + (__tgmath_real_type (Z)) 0) > sizeof (_Float64) \
		  ? __TGMATH_F128 ((X) + (Y) + (Z), F, (X, Y, Z))	\
		  F ## f64x (X, Y, Z)					\
		  : F ## f128 (X, Y, Z)))
#   define __TGMATH_1_NARROW_F32X(F, X)					\
  (__extension__ (sizeof ((__tgmath_real_type (X)) 0) > sizeof (_Float64) \
		  ? __TGMATH_F128 ((X), F, (X))				\
		  F ## f64x (X)						\
		  : F ## f64 (X)))
#   define __TGMATH_2_NARROW_F32X(F, X, Y)				\
  (__extension__ (sizeof ((__tgmath_real_type (X)) 0			\
			  + (__tgmath_real_type (Y)) 0) > sizeof (_Float64) \
		  ? __TGMATH_F128 ((X) + (Y), F, (X, Y))		\
		  F ## f64x (X, Y)					\
		  : F ## f64 (X, Y)))
#   define __TGMATH_3_NARROW_F32X(F, X, Y, Z)				\
  (__extension__ (sizeof ((__tgmath_real_type (X)) 0			\
			  + (__tgmath_real_type (Y)) 0			\
			  + (__tgmath_real_type (Z)) 0) > sizeof (_Float64) \
		  ? __TGMATH_F128 ((X) + (Y) + (Z), F, (X, Y, Z))	\
		  F ## f64x (X, Y, Z)					\
		  : F ## f64 (X, Y, Z)))
#  elif __HAVE_FLOAT128
#   define __TGMATH_1_NARROW_F32(F, X)					\
  (__extension__ (sizeof ((__tgmath_real_type (X)) 0) > sizeof (_Float64) \
		  ? F ## f128 (X)					\
		  : F ## f64 (X)))
#   define __TGMATH_2_NARROW_F32(F, X, Y)				\
  (__extension__ (sizeof ((__tgmath_real_type (X)) 0			\
			  + (__tgmath_real_type (Y)) 0) > sizeof (_Float64) \
		  ? F ## f128 (X, Y)					\
		  : F ## f64 (X, Y)))
#   define __TGMATH_3_NARROW_F32(F, X, Y, Z)				\
  (__extension__ (sizeof ((__tgmath_real_type (X)) 0			\
			  + (__tgmath_real_type (Y)) 0			\
			  + (__tgmath_real_type (Z)) 0) > sizeof (_Float64) \
		  ? F ## f128 (X, Y, Z)					\
		  : F ## f64 (X, Y, Z)))
#   define __TGMATH_1_NARROW_F64(F, X)		\
  (F ## f128 (X))
#   define __TGMATH_2_NARROW_F64(F, X, Y)	\
  (F ## f128 (X, Y))
#   define __TGMATH_3_NARROW_F64(F, X, Y, Z)	\
  (F ## f128 (X, Y, Z))
#   define __TGMATH_1_NARROW_F32X(F, X)					\
  (__extension__ (sizeof ((__tgmath_real_type (X)) 0) > sizeof (_Float32x) \
		  ? F ## f64x (X)					\
		  : F ## f64 (X)))
#   define __TGMATH_2_NARROW_F32X(F, X, Y)				\
  (__extension__ (sizeof ((__tgmath_real_type (X)) 0			\
			  + (__tgmath_real_type (Y)) 0) > sizeof (_Float32x) \
		  ? F ## f64x (X, Y)					\
		  : F ## f64 (X, Y)))
#   define __TGMATH_3_NARROW_F32X(F, X, Y, Z)				\
  (__extension__ (sizeof ((__tgmath_real_type (X)) 0			\
			  + (__tgmath_real_type (Y)) 0			\
			  + (__tgmath_real_type (Z)) 0) > sizeof (_Float32x) \
		  ? F ## f64x (X, Y, Z)					\
		  : F ## f64 (X, Y, Z)))
#  else
#   define __TGMATH_1_NARROW_F32(F, X)		\
  (F ## f64 (X))
#   define __TGMATH_2_NARROW_F32(F, X, Y)	\
  (F ## f64 (X, Y))
#   define __TGMATH_3_NARROW_F32(F, X, Y, Z)	\
  (F ## f64 (X, Y, Z))
#  endif
# endif /* !__HAVE_BUILTIN_TGMATH.  */
#else
# error "Unsupported compiler; you cannot use <tgmath.h>"
#endif


/* Unary functions defined for real and complex values.  */


/* Trigonometric functions.  */

/* Arc cosine of X.  */
#define acos(Val) __TGMATH_UNARY_REAL_IMAG (Val, acos, cacos)
/* Arc sine of X.  */
#define asin(Val) __TGMATH_UNARY_REAL_IMAG (Val, asin, casin)
/* Arc tangent of X.  */
#define atan(Val) __TGMATH_UNARY_REAL_IMAG (Val, atan, catan)
/* Arc tangent of Y/X.  */
#define atan2(Val1, Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, atan2)

/* Cosine of X.  */
#define cos(Val) __TGMATH_UNARY_REAL_IMAG (Val, cos, ccos)
/* Sine of X.  */
#define sin(Val) __TGMATH_UNARY_REAL_IMAG (Val, sin, csin)
/* Tangent of X.  */
#define tan(Val) __TGMATH_UNARY_REAL_IMAG (Val, tan, ctan)


/* Hyperbolic functions.  */

/* Hyperbolic arc cosine of X.  */
#define acosh(Val) __TGMATH_UNARY_REAL_IMAG (Val, acosh, cacosh)
/* Hyperbolic arc sine of X.  */
#define asinh(Val) __TGMATH_UNARY_REAL_IMAG (Val, asinh, casinh)
/* Hyperbolic arc tangent of X.  */
#define atanh(Val) __TGMATH_UNARY_REAL_IMAG (Val, atanh, catanh)

/* Hyperbolic cosine of X.  */
#define cosh(Val) __TGMATH_UNARY_REAL_IMAG (Val, cosh, ccosh)
/* Hyperbolic sine of X.  */
#define sinh(Val) __TGMATH_UNARY_REAL_IMAG (Val, sinh, csinh)
/* Hyperbolic tangent of X.  */
#define tanh(Val) __TGMATH_UNARY_REAL_IMAG (Val, tanh, ctanh)


/* Exponential and logarithmic functions.  */

/* Exponential function of X.  */
#define exp(Val) __TGMATH_UNARY_REAL_IMAG (Val, exp, cexp)

/* Break VALUE into a normalized fraction and an integral power of 2.  */
#define frexp(Val1, Val2) __TGMATH_BINARY_FIRST_REAL_ONLY (Val1, Val2, frexp)

/* X times (two to the EXP power).  */
#define ldexp(Val1, Val2) __TGMATH_BINARY_FIRST_REAL_ONLY (Val1, Val2, ldexp)

/* Natural logarithm of X.  */
#define log(Val) __TGMATH_UNARY_REAL_IMAG (Val, log, clog)

/* Base-ten logarithm of X.  */
#ifdef __USE_GNU
# define log10(Val) __TGMATH_UNARY_REAL_IMAG (Val, log10, clog10)
#else
# define log10(Val) __TGMATH_UNARY_REAL_ONLY (Val, log10)
#endif

/* Return exp(X) - 1.  */
#define expm1(Val) __TGMATH_UNARY_REAL_ONLY (Val, expm1)

/* Return log(1 + X).  */
#define log1p(Val) __TGMATH_UNARY_REAL_ONLY (Val, log1p)

/* Return the base 2 signed integral exponent of X.  */
#define logb(Val) __TGMATH_UNARY_REAL_ONLY (Val, logb)

/* Compute base-2 exponential of X.  */
#define exp2(Val) __TGMATH_UNARY_REAL_ONLY (Val, exp2)

/* Compute base-2 logarithm of X.  */
#define log2(Val) __TGMATH_UNARY_REAL_ONLY (Val, log2)

#if __GLIBC_USE (IEC_60559_FUNCS_EXT_C2X)
/* Compute exponent to base ten.  */
#define exp10(Val) __TGMATH_UNARY_REAL_ONLY (Val, exp10)
#endif


/* Power functions.  */

/* Return X to the Y power.  */
#define pow(Val1, Val2) __TGMATH_BINARY_REAL_IMAG (Val1, Val2, pow, cpow)

/* Return the square root of X.  */
#define sqrt(Val) __TGMATH_UNARY_REAL_IMAG (Val, sqrt, csqrt)

/* Return `sqrt(X*X + Y*Y)'.  */
#define hypot(Val1, Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, hypot)

/* Return the cube root of X.  */
#define cbrt(Val) __TGMATH_UNARY_REAL_ONLY (Val, cbrt)


/* Nearest integer, absolute value, and remainder functions.  */

/* Smallest integral value not less than X.  */
#define ceil(Val) __TGMATH_UNARY_REAL_ONLY (Val, ceil)

/* Absolute value of X.  */
#define fabs(Val) __TGMATH_UNARY_REAL_IMAG_RET_REAL (Val, fabs, cabs)

/* Largest integer not greater than X.  */
#define floor(Val) __TGMATH_UNARY_REAL_ONLY (Val, floor)

/* Floating-point modulo remainder of X/Y.  */
#define fmod(Val1, Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, fmod)

/* Round X to integral valuein floating-point format using current
   rounding direction, but do not raise inexact exception.  */
#define nearbyint(Val) __TGMATH_UNARY_REAL_ONLY (Val, nearbyint)

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
#define round(Val) __TGMATH_UNARY_REAL_ONLY (Val, round)

/* Round X to the integral value in floating-point format nearest but
   not larger in magnitude.  */
#define trunc(Val) __TGMATH_UNARY_REAL_ONLY (Val, trunc)

/* Compute remainder of X and Y and put in *QUO a value with sign of x/y
   and magnitude congruent `mod 2^n' to the magnitude of the integral
   quotient x/y, with n >= 3.  */
#define remquo(Val1, Val2, Val3) \
     __TGMATH_TERNARY_FIRST_SECOND_REAL_ONLY (Val1, Val2, Val3, remquo)

/* Round X to nearest integral value according to current rounding
   direction.  */
#define lrint(Val) __TGMATH_UNARY_REAL_RET_ONLY (Val, lrint)
#define llrint(Val) __TGMATH_UNARY_REAL_RET_ONLY (Val, llrint)

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
#define lround(Val) __TGMATH_UNARY_REAL_RET_ONLY (Val, lround)
#define llround(Val) __TGMATH_UNARY_REAL_RET_ONLY (Val, llround)


/* Return X with its signed changed to Y's.  */
#define copysign(Val1, Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, copysign)

/* Error and gamma functions.  */
#define erf(Val) __TGMATH_UNARY_REAL_ONLY (Val, erf)
#define erfc(Val) __TGMATH_UNARY_REAL_ONLY (Val, erfc)
#define tgamma(Val) __TGMATH_UNARY_REAL_ONLY (Val, tgamma)
#define lgamma(Val) __TGMATH_UNARY_REAL_ONLY (Val, lgamma)


/* Return the integer nearest X in the direction of the
   prevailing rounding mode.  */
#define rint(Val) __TGMATH_UNARY_REAL_ONLY (Val, rint)

#if __GLIBC_USE (IEC_60559_BFP_EXT_C2X)
/* Return X - epsilon.  */
# define nextdown(Val) __TGMATH_UNARY_REAL_ONLY (Val, nextdown)
/* Return X + epsilon.  */
# define nextup(Val) __TGMATH_UNARY_REAL_ONLY (Val, nextup)
#endif

/* Return X + epsilon if X < Y, X - epsilon if X > Y.  */
#define nextafter(Val1, Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, nextafter)
#define nexttoward(Val1, Val2) \
     __TGMATH_BINARY_FIRST_REAL_STD_ONLY (Val1, Val2, nexttoward)

/* Return the remainder of integer divison X / Y with infinite precision.  */
#define remainder(Val1, Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, remainder)

/* Return X times (2 to the Nth power).  */
#ifdef __USE_MISC
# define scalb(Val1, Val2) __TGMATH_BINARY_REAL_STD_ONLY (Val1, Val2, scalb)
#endif

/* Return X times (2 to the Nth power).  */
#define scalbn(Val1, Val2) __TGMATH_BINARY_FIRST_REAL_ONLY (Val1, Val2, scalbn)

/* Return X times (2 to the Nth power).  */
#define scalbln(Val1, Val2) \
     __TGMATH_BINARY_FIRST_REAL_ONLY (Val1, Val2, scalbln)

/* Return the binary exponent of X, which must be nonzero.  */
#define ilogb(Val) __TGMATH_UNARY_REAL_RET_ONLY (Val, ilogb)


/* Return positive difference between X and Y.  */
#define fdim(Val1, Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, fdim)

#if __GLIBC_USE (ISOC2X) && !defined __USE_GNU
/* Return maximum numeric value from X and Y.  */
# define fmax(Val1, Val2) __TGMATH_BINARY_REAL_STD_ONLY (Val1, Val2, fmax)

/* Return minimum numeric value from X and Y.  */
# define fmin(Val1, Val2) __TGMATH_BINARY_REAL_STD_ONLY (Val1, Val2, fmin)
#else
/* Return maximum numeric value from X and Y.  */
# define fmax(Val1, Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, fmax)

/* Return minimum numeric value from X and Y.  */
# define fmin(Val1, Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, fmin)
#endif


/* Multiply-add function computed as a ternary operation.  */
#define fma(Val1, Val2, Val3) \
     __TGMATH_TERNARY_REAL_ONLY (Val1, Val2, Val3, fma)

#if __GLIBC_USE (IEC_60559_BFP_EXT_C2X)
/* Round X to nearest integer value, rounding halfway cases to even.  */
# define roundeven(Val) __TGMATH_UNARY_REAL_ONLY (Val, roundeven)

# define fromfp(Val1, Val2, Val3)					\
  __TGMATH_TERNARY_FIRST_REAL_RET_ONLY (Val1, Val2, Val3, fromfp)

# define ufromfp(Val1, Val2, Val3)					\
  __TGMATH_TERNARY_FIRST_REAL_RET_ONLY (Val1, Val2, Val3, ufromfp)

# define fromfpx(Val1, Val2, Val3)					\
  __TGMATH_TERNARY_FIRST_REAL_RET_ONLY (Val1, Val2, Val3, fromfpx)

# define ufromfpx(Val1, Val2, Val3)					\
  __TGMATH_TERNARY_FIRST_REAL_RET_ONLY (Val1, Val2, Val3, ufromfpx)

/* Like ilogb, but returning long int.  */
# define llogb(Val) __TGMATH_UNARY_REAL_RET_ONLY (Val, llogb)
#endif

#if __GLIBC_USE (IEC_60559_BFP_EXT)
/* Return value with maximum magnitude.  */
# define fmaxmag(Val1, Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, fmaxmag)

/* Return value with minimum magnitude.  */
# define fminmag(Val1, Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, fminmag)
#endif

#if __GLIBC_USE (ISOC2X)
/* Return maximum value from X and Y.  */
# define fmaximum(Val1, Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, fmaximum)

/* Return minimum value from X and Y.  */
# define fminimum(Val1, Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, fminimum)

/* Return maximum numeric value from X and Y.  */
# define fmaximum_num(Val1, Val2)			\
  __TGMATH_BINARY_REAL_ONLY (Val1, Val2, fmaximum_num)

/* Return minimum numeric value from X and Y.  */
# define fminimum_num(Val1, Val2)			\
  __TGMATH_BINARY_REAL_ONLY (Val1, Val2, fminimum_num)

/* Return value with maximum magnitude.  */
# define fmaximum_mag(Val1, Val2)			\
  __TGMATH_BINARY_REAL_ONLY (Val1, Val2, fmaximum_mag)

/* Return value with minimum magnitude.  */
# define fminimum_mag(Val1, Val2)			\
  __TGMATH_BINARY_REAL_ONLY (Val1, Val2, fminimum_mag)

/* Return numeric value with maximum magnitude.  */
# define fmaximum_mag_num(Val1, Val2)				\
  __TGMATH_BINARY_REAL_ONLY (Val1, Val2, fmaximum_mag_num)

/* Return numeric value with minimum magnitude.  */
# define fminimum_mag_num(Val1, Val2)				\
  __TGMATH_BINARY_REAL_ONLY (Val1, Val2, fminimum_mag_num)
#endif


/* Absolute value, conjugates, and projection.  */

/* Argument value of Z.  */
#define carg(Val) __TGMATH_UNARY_REAL_IMAG_RET_REAL_SAME (Val, carg)

/* Complex conjugate of Z.  */
#define conj(Val) __TGMATH_UNARY_IMAG (Val, conj)

/* Projection of Z onto the Riemann sphere.  */
#define cproj(Val) __TGMATH_UNARY_IMAG (Val, cproj)


/* Decomposing complex values.  */

/* Imaginary part of Z.  */
#define cimag(Val) __TGMATH_UNARY_REAL_IMAG_RET_REAL_SAME (Val, cimag)

/* Real part of Z.  */
#define creal(Val) __TGMATH_UNARY_REAL_IMAG_RET_REAL_SAME (Val, creal)


/* Narrowing functions.  */

#if __GLIBC_USE (IEC_60559_BFP_EXT_C2X)

/* Add.  */
# define fadd(Val1, Val2) __TGMATH_2_NARROW_F (fadd, Val1, Val2)
# define dadd(Val1, Val2) __TGMATH_2_NARROW_D (dadd, Val1, Val2)

/* Divide.  */
# define fdiv(Val1, Val2) __TGMATH_2_NARROW_F (fdiv, Val1, Val2)
# define ddiv(Val1, Val2) __TGMATH_2_NARROW_D (ddiv, Val1, Val2)

/* Multiply.  */
# define fmul(Val1, Val2) __TGMATH_2_NARROW_F (fmul, Val1, Val2)
# define dmul(Val1, Val2) __TGMATH_2_NARROW_D (dmul, Val1, Val2)

/* Subtract.  */
# define fsub(Val1, Val2) __TGMATH_2_NARROW_F (fsub, Val1, Val2)
# define dsub(Val1, Val2) __TGMATH_2_NARROW_D (dsub, Val1, Val2)

/* Square root.  */
# define fsqrt(Val) __TGMATH_1_NARROW_F (fsqrt, Val)
# define dsqrt(Val) __TGMATH_1_NARROW_D (dsqrt, Val)

/* Fused multiply-add.  */
# define ffma(Val1, Val2, Val3) __TGMATH_3_NARROW_F (ffma, Val1, Val2, Val3)
# define dfma(Val1, Val2, Val3) __TGMATH_3_NARROW_D (dfma, Val1, Val2, Val3)

#endif

#if __GLIBC_USE (IEC_60559_TYPES_EXT)

# if __HAVE_FLOAT16
#  define f16add(Val1, Val2) __TGMATH_2_NARROW_F16 (f16add, Val1, Val2)
#  define f16div(Val1, Val2) __TGMATH_2_NARROW_F16 (f16div, Val1, Val2)
#  define f16mul(Val1, Val2) __TGMATH_2_NARROW_F16 (f16mul, Val1, Val2)
#  define f16sub(Val1, Val2) __TGMATH_2_NARROW_F16 (f16sub, Val1, Val2)
#  define f16sqrt(Val) __TGMATH_1_NARROW_F16 (f16sqrt, Val)
#  define f16fma(Val1, Val2, Val3)			\
  __TGMATH_3_NARROW_F16 (f16fma, Val1, Val2, Val3)
# endif

# if __HAVE_FLOAT32
#  define f32add(Val1, Val2) __TGMATH_2_NARROW_F32 (f32add, Val1, Val2)
#  define f32div(Val1, Val2) __TGMATH_2_NARROW_F32 (f32div, Val1, Val2)
#  define f32mul(Val1, Val2) __TGMATH_2_NARROW_F32 (f32mul, Val1, Val2)
#  define f32sub(Val1, Val2) __TGMATH_2_NARROW_F32 (f32sub, Val1, Val2)
#  define f32sqrt(Val) __TGMATH_1_NARROW_F32 (f32sqrt, Val)
#  define f32fma(Val1, Val2, Val3)			\
  __TGMATH_3_NARROW_F32 (f32fma, Val1, Val2, Val3)
# endif

# if __HAVE_FLOAT64 && (__HAVE_FLOAT64X || __HAVE_FLOAT128)
#  define f64add(Val1, Val2) __TGMATH_2_NARROW_F64 (f64add, Val1, Val2)
#  define f64div(Val1, Val2) __TGMATH_2_NARROW_F64 (f64div, Val1, Val2)
#  define f64mul(Val1, Val2) __TGMATH_2_NARROW_F64 (f64mul, Val1, Val2)
#  define f64sub(Val1, Val2) __TGMATH_2_NARROW_F64 (f64sub, Val1, Val2)
#  define f64sqrt(Val) __TGMATH_1_NARROW_F64 (f64sqrt, Val)
#  define f64fma(Val1, Val2, Val3)			\
  __TGMATH_3_NARROW_F64 (f64fma, Val1, Val2, Val3)
# endif

# if __HAVE_FLOAT32X
#  define f32xadd(Val1, Val2) __TGMATH_2_NARROW_F32X (f32xadd, Val1, Val2)
#  define f32xdiv(Val1, Val2) __TGMATH_2_NARROW_F32X (f32xdiv, Val1, Val2)
#  define f32xmul(Val1, Val2) __TGMATH_2_NARROW_F32X (f32xmul, Val1, Val2)
#  define f32xsub(Val1, Val2) __TGMATH_2_NARROW_F32X (f32xsub, Val1, Val2)
#  define f32xsqrt(Val) __TGMATH_1_NARROW_F32X (f32xsqrt, Val)
#  define f32xfma(Val1, Val2, Val3)			\
  __TGMATH_3_NARROW_F32X (f32xfma, Val1, Val2, Val3)
# endif

# if __HAVE_FLOAT64X && (__HAVE_FLOAT128X || __HAVE_FLOAT128)
#  define f64xadd(Val1, Val2) __TGMATH_2_NARROW_F64X (f64xadd, Val1, Val2)
#  define f64xdiv(Val1, Val2) __TGMATH_2_NARROW_F64X (f64xdiv, Val1, Val2)
#  define f64xmul(Val1, Val2) __TGMATH_2_NARROW_F64X (f64xmul, Val1, Val2)
#  define f64xsub(Val1, Val2) __TGMATH_2_NARROW_F64X (f64xsub, Val1, Val2)
#  define f64xsqrt(Val) __TGMATH_1_NARROW_F64X (f64xsqrt, Val)
#  define f64xfma(Val1, Val2, Val3)			\
  __TGMATH_3_NARROW_F64X (f64xfma, Val1, Val2, Val3)
# endif

#endif

#endif /* tgmath.h */
                                                                                                                                                                                                                                                                                                                                                                                                                 usr/include/thread_db.h                                                                             0000644 0000000 0000000 00000037230 14711146254 013577  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* thread_db.h -- interface to libthread_db.so library for debugging -lpthread
   Copyright (C) 1999-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */

#ifndef _THREAD_DB_H
#define _THREAD_DB_H	1

/* This is the debugger interface for the NPTL library.  It is
   modelled closely after the interface with same names in Solaris
   with the goal to share the same code in the debugger.  */
#include <pthread.h>
#include <stdint.h>
#include <sys/types.h>
#include <sys/procfs.h>


/* Error codes of the library.  */
typedef enum
{
  TD_OK,	  /* No error.  */
  TD_ERR,	  /* No further specified error.  */
  TD_NOTHR,	  /* No matching thread found.  */
  TD_NOSV,	  /* No matching synchronization handle found.  */
  TD_NOLWP,	  /* No matching light-weighted process found.  */
  TD_BADPH,	  /* Invalid process handle.  */
  TD_BADTH,	  /* Invalid thread handle.  */
  TD_BADSH,	  /* Invalid synchronization handle.  */
  TD_BADTA,	  /* Invalid thread agent.  */
  TD_BADKEY,	  /* Invalid key.  */
  TD_NOMSG,	  /* No event available.  */
  TD_NOFPREGS,	  /* No floating-point register content available.  */
  TD_NOLIBTHREAD, /* Application not linked with thread library.  */
  TD_NOEVENT,	  /* Requested event is not supported.  */
  TD_NOCAPAB,	  /* Capability not available.  */
  TD_DBERR,	  /* Internal debug library error.  */
  TD_NOAPLIC,	  /* Operation is not applicable.  */
  TD_NOTSD,	  /* No thread-specific data available.  */
  TD_MALLOC,	  /* Out of memory.  */
  TD_PARTIALREG,  /* Not entire register set was read or written.  */
  TD_NOXREGS,	  /* X register set not available for given thread.  */
  TD_TLSDEFER,	  /* Thread has not yet allocated TLS for given module.  */
  TD_NOTALLOC = TD_TLSDEFER,
  TD_VERSION,	  /* Version if libpthread and libthread_db do not match.  */
  TD_NOTLS	  /* There is no TLS segment in the given module.  */
} td_err_e;


/* Possible thread states.  TD_THR_ANY_STATE is a pseudo-state used to
   select threads regardless of state in td_ta_thr_iter().  */
typedef enum
{
  TD_THR_ANY_STATE,
  TD_THR_UNKNOWN,
  TD_THR_STOPPED,
  TD_THR_RUN,
  TD_THR_ACTIVE,
  TD_THR_ZOMBIE,
  TD_THR_SLEEP,
  TD_THR_STOPPED_ASLEEP
} td_thr_state_e;

/* Thread type: user or system.  TD_THR_ANY_TYPE is a pseudo-type used
   to select threads regardless of type in td_ta_thr_iter().  */
typedef enum
{
  TD_THR_ANY_TYPE,
  TD_THR_USER,
  TD_THR_SYSTEM
} td_thr_type_e;


/* Types of the debugging library.  */

/* Handle for a process.  This type is opaque.  */
typedef struct td_thragent td_thragent_t;

/* The actual thread handle type.  This is also opaque.  */
typedef struct td_thrhandle
{
  td_thragent_t *th_ta_p;
  psaddr_t th_unique;
} td_thrhandle_t;


/* Forward declaration of a type defined by and for the dynamic linker.  */
struct link_map;


/* Flags for `td_ta_thr_iter'.  */
#define TD_THR_ANY_USER_FLAGS	0xffffffff
#define TD_THR_LOWEST_PRIORITY	-20
#define TD_SIGNO_MASK		NULL


#define TD_EVENTSIZE	2
#define BT_UISHIFT	5 /* log base 2 of BT_NBIPUI, to extract word index */
#define BT_NBIPUI	(1 << BT_UISHIFT)       /* n bits per unsigned int */
#define BT_UIMASK	(BT_NBIPUI - 1)         /* to extract bit index */

/* Bitmask of enabled events. */
typedef struct td_thr_events
{
  uint32_t event_bits[TD_EVENTSIZE];
} td_thr_events_t;

/* Event set manipulation macros. */
#define __td_eventmask(n) \
  (UINT32_C (1) << (((n) - 1) & BT_UIMASK))
#define __td_eventword(n) \
  ((UINT32_C ((n) - 1)) >> BT_UISHIFT)

#define td_event_emptyset(setp) \
  do {									      \
    int __i;								      \
    for (__i = TD_EVENTSIZE; __i > 0; --__i)				      \
      (setp)->event_bits[__i - 1] = 0;					      \
  } while (0)

#define td_event_fillset(setp) \
  do {									      \
    int __i;								      \
    for (__i = TD_EVENTSIZE; __i > 0; --__i)				      \
      (setp)->event_bits[__i - 1] = UINT32_C (0xffffffff);		      \
  } while (0)

#define td_event_addset(setp, n) \
  (((setp)->event_bits[__td_eventword (n)]) |= __td_eventmask (n))
#define td_event_delset(setp, n) \
  (((setp)->event_bits[__td_eventword (n)]) &= ~__td_eventmask (n))
#define td_eventismember(setp, n) \
  (__td_eventmask (n) & ((setp)->event_bits[__td_eventword (n)]))
#if TD_EVENTSIZE == 2
# define td_eventisempty(setp) \
  (!((setp)->event_bits[0]) && !((setp)->event_bits[1]))
#else
# error "td_eventisempty must be changed to match TD_EVENTSIZE"
#endif

/* Events reportable by the thread implementation.  */
typedef enum
{
  TD_ALL_EVENTS,		 /* Pseudo-event number.  */
  TD_EVENT_NONE = TD_ALL_EVENTS, /* Depends on context.  */
  TD_READY,			 /* Is executable now. */
  TD_SLEEP,			 /* Blocked in a synchronization obj.  */
  TD_SWITCHTO,			 /* Now assigned to a process.  */
  TD_SWITCHFROM,		 /* Not anymore assigned to a process.  */
  TD_LOCK_TRY,			 /* Trying to get an unavailable lock.  */
  TD_CATCHSIG,			 /* Signal posted to the thread.  */
  TD_IDLE,			 /* Process getting idle.  */
  TD_CREATE,			 /* New thread created.  */
  TD_DEATH,			 /* Thread terminated.  */
  TD_PREEMPT,			 /* Preempted.  */
  TD_PRI_INHERIT,		 /* Inherited elevated priority.  */
  TD_REAP,			 /* Reaped.  */
  TD_CONCURRENCY,		 /* Number of processes changing.  */
  TD_TIMEOUT,			 /* Conditional variable wait timed out.  */
  TD_MIN_EVENT_NUM = TD_READY,
