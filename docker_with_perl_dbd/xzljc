In Mac OS X 10.4 "Tiger", you must export the 'u' variant of the SDK:

    export SDK=/Developer/SDKs/MacOSX10.4u.sdk

Mac OS X 10.5 "Leopard" and above do not require the 'u' variant.

In addition to the compiler flags used to select the SDK, also add the flags
for creating a universal binary:

 ./Configure -Accflags="-arch i686 -arch ppc -nostdinc               \
                         -B$SDK/usr/include/gcc                      \
                        -B$SDK/usr/lib/gcc -isystem$SDK/usr/include  \
                        -F$SDK/System/Library/Frameworks"            \
             -Aldflags="-arch i686 -arch ppc -Wl,-syslibroot,$SDK"   \
             -de

Keep in mind that these compiler and linker settings will also be used when
building CPAN modules. For XS modules to be compiled as a universal binary, any
libraries it links to must also be universal binaries. The system libraries that
Apple includes with the 10.4u SDK are all universal, but user-installed libraries
may need to be re-installed as universal binaries.

=head2 64-bit PPC support

Follow the instructions in F<INSTALL> to build perl with support for 64-bit 
integers (C<use64bitint>) or both 64-bit integers and 64-bit addressing
(C<use64bitall>). In the latter case, the resulting binary will run only
on G5-based hosts.

Support for 64-bit addressing is experimental: some aspects of Perl may be
omitted or buggy. Note the messages output by F<Configure> for further 
information. Please use L<https://github.com/Perl/perl5/issues> to submit a
problem report in the event that you encounter difficulties.

When building 64-bit modules, it is your responsibility to ensure that linked
external libraries and frameworks provide 64-bit support: if they do not,
module building may appear to succeed, but attempts to use the module will
result in run-time dynamic linking errors, and subsequent test failures.
You can use C<file> to discover the architectures supported by a library:

    $ file libgdbm.3.0.0.dylib 
    libgdbm.3.0.0.dylib: Mach-O fat file with 2 architectures
    libgdbm.3.0.0.dylib (for architecture ppc):      Mach-O dynamically linked shared library ppc
    libgdbm.3.0.0.dylib (for architecture ppc64):    Mach-O 64-bit dynamically linked shared library ppc64

Note that this issue precludes the building of many Macintosh-specific CPAN
modules (C<Mac::*>), as the required Apple frameworks do not provide PPC64
support. Similarly, downloads from Fink or Darwinports are unlikely to provide
64-bit support; the libraries must be rebuilt from source with the appropriate
compiler and linker flags. For further information, see Apple's
I<64-Bit Transition Guide> at
L<https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/64bitPorting/transition/transition.html>.

=head2 libperl and Prebinding

Mac OS X ships with a dynamically-loaded libperl, but the default for
this release is to compile a static libperl. The reason for this is
pre-binding. Dynamic libraries can be pre-bound to a specific address in
memory in order to decrease load time. To do this, one needs to be aware
of the location and size of all previously-loaded libraries. Apple
collects this information as part of their overall OS build process, and
thus has easy access to it when building Perl, but ordinary users would
need to go to a great deal of effort to obtain the information needed
for pre-binding.

You can override the default and build a shared libperl if you wish
(S<Configure ... -Duseshrplib>).

With Mac OS X 10.4 "Tiger" and newer, there is almost no performance
penalty for non-prebound libraries. Earlier releases will suffer a greater
load time than either the static library, or Apple's pre-bound dynamic library.

=head2 Updating Apple's Perl

In a word - don't, at least not without a *very* good reason. Your scripts
can just as easily begin with "#!/usr/local/bin/perl" as with
"#!/usr/bin/perl". Scripts supplied by Apple and other third parties as
part of installation packages and such have generally only been tested
with the /usr/bin/perl that's installed by Apple.

If you find that you do need to update the system Perl, one issue worth
keeping in mind is the question of static vs. dynamic libraries. If you
upgrade using the default static libperl, you will find that the dynamic
libperl supplied by Apple will not be deleted. If both libraries are
present when an application that links against libperl is built, ld will
link against the dynamic library by default. So, if you need to replace
Apple's dynamic libperl with a static libperl, you need to be sure to
delete the older dynamic library after you've installed the update.


=head2 Known problems

If you have installed extra libraries such as GDBM through Fink
(in other words, you have libraries under F</sw/lib>), or libdlcompat
to F</usr/local/lib>, you may need to be extra careful when running
Configure to not to confuse Configure and Perl about which libraries
to use.  Being confused will show up for example as "dyld" errors about
symbol problems, for example during "make test". The safest bet is to run
Configure as

    Configure ... -Uloclibpth -Dlibpth=/usr/lib

to make Configure look only into the system libraries.  If you have some
extra library directories that you really want to use (such as newer
Berkeley DB libraries in pre-Panther systems), add those to the libpth:

    Configure ... -Uloclibpth -Dlibpth='/usr/lib /opt/lib'

The default of building Perl statically may cause problems with complex
applications like Tk: in that case consider building shared Perl

    Configure ... -Duseshrplib

but remember that there's a startup cost to pay in that case (see above
"libperl and Prebinding").

Starting with Tiger (Mac OS X 10.4), Apple shipped broken locale files for
the eu_ES locale (Basque-Spain).  In previous releases of Perl, this resulted in
failures in the F<lib/locale> test. These failures have been suppressed
in the current release of Perl by making the test ignore the broken locale.
If you need to use the eu_ES locale, you should contact Apple support.


=head2 Cocoa

There are two ways to use Cocoa from Perl. Apple's PerlObjCBridge
module, included with Mac OS X, can be used by standalone scripts to
access Foundation (i.e. non-GUI) classes and objects.

An alternative is CamelBones, a framework that allows access to both
Foundation and AppKit classes and objects, so that full GUI applications
can be built in Perl. CamelBones can be found on SourceForge, at
L<https://www.sourceforge.net/projects/camelbones/>.


=head1 Starting From Scratch

Unfortunately it is not that difficult somehow manage to break one's
Mac OS X Perl rather severely.  If all else fails and you want to
really, B<REALLY>, start from scratch and remove even your Apple Perl
installation (which has become corrupted somehow), the following
instructions should do it.  B<Please think twice before following
these instructions: they are much like conducting brain surgery to
yourself.  Without anesthesia.>  We will B<not> come to fix your system
if you do this.

First, get rid of the libperl.dylib:

    # cd /System/Library/Perl/darwin/CORE
    # rm libperl.dylib

Then delete every .bundle file found anywhere in the folders:

    /System/Library/Perl
    /Library/Perl

You can find them for example by

    # find /System/Library/Perl /Library/Perl -name '*.bundle' -print

After this you can either copy Perl from your operating system media
(you will need at least the /System/Library/Perl and /usr/bin/perl),
or rebuild Perl from the source code with C<Configure -Dprefix=/usr
-Duseshrplib> NOTE: the C<-Dprefix=/usr> to replace the system Perl
works much better with Perl 5.8.1 and later, in Perl 5.8.0 the
settings were not quite right.

"Pacifist" from CharlesSoft (L<https://www.charlessoft.com/>) is a nice
way to extract the Perl binaries from the OS media, without having to
reinstall the entire OS.


=head1 AUTHOR

This README was written by Sherm Pendley E<lt>sherm@dot-app.orgE<gt>,
and subsequently updated by Dominic Dunlop E<lt>domo@computer.orgE<gt>
and Breno G. de Oliveira E<lt>garu@cpan.orgE<gt>. The "Starting From Scratch"
recipe was contributed by John Montbriand E<lt>montbriand@apple.comE<gt>.

=head1 DATE

Last modified 2013-04-29.
                                                                                                                                                 usr/local/lib/perl5/5.40.0/pod/perlmod.pod                                                          0000644 0000000 0000000 00000063647 14714567415 016456  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =head1 NAME

perlmod - Perl modules (packages and symbol tables)

=head1 DESCRIPTION

=head2 Is this the document you were after?

There are other documents which might contain the information that you're
looking for:

=over 2

=item This doc

Perl's packages, namespaces, and some info on classes.

=item L<perlnewmod>

Tutorial on making a new module.

=item L<perlmodstyle>

Best practices for making a new module.

=back

=head2 Packages
X<package> X<namespace> X<variable, global> X<global variable> X<global>

Unlike Perl 4, in which all the variables were dynamic and shared one
global name space, causing maintainability problems, Perl 5 provides two
mechanisms for protecting code from having its variables stomped on by
other code: lexically scoped variables created with C<my> or C<state> and
namespaced global variables, which are exposed via the C<vars> pragma,
or the C<our> keyword. Any global variable is considered to
be part of a namespace and can be accessed via a "fully qualified form".
Conversely, any lexically scoped variable is considered to be part of
that lexical-scope, and does not have a "fully qualified form".

In perl namespaces are called "packages" and
the C<package> declaration tells the compiler which
namespace to prefix to C<our> variables and unqualified dynamic names.
This both protects
against accidental stomping and provides an interface for deliberately
clobbering global dynamic variables declared and used in other scopes or
packages, when that is what you want to do.

The scope of the C<package> declaration is from the
declaration itself through the end of the enclosing block, C<eval>,
or file, whichever comes first (the same scope as the my(), our(), state(), and
local() operators, and also the effect
of the experimental "reference aliasing," which may change), or until
the next C<package> declaration.  Unqualified dynamic identifiers will be in
this namespace, except for those few identifiers that, if unqualified,
default to the main package instead of the current one as described
below.  A C<package> statement affects only dynamic global
symbols, including subroutine names, and variables you've used local()
on, but I<not> lexical variables created with my(), our() or state().

Typically, a C<package> statement is the first declaration in a file
included in a program by one of the C<do>, C<require>, or C<use> operators.  You can
switch into a package in more than one place: C<package> has no
effect beyond specifying which symbol table the compiler will use for
dynamic symbols for the rest of that block or until the next C<package> statement.
You can refer to variables and filehandles in other packages
by prefixing the identifier with the package name and a double
colon: C<$Package::Variable>.  If the package name is null, the
C<main> package is assumed.  That is, C<$::sail> is equivalent to
C<$main::sail>.

The old package delimiter was a single quote, but double colon is now the
preferred delimiter, in part because it's more readable to humans, and
in part because it's more readable to B<emacs> macros.  It also makes C++
programmers feel like they know what's going on--as opposed to using the
single quote as separator, which was there to make Ada programmers feel
like they knew what was going on.  Because the old-fashioned syntax is still
supported for backwards compatibility, if you try to use a string like
C<"This is $owner's house">, you'll be accessing C<$owner::s>; that is,
the $s variable in package C<owner>, which is probably not what you meant.
Use braces to disambiguate, as in C<"This is ${owner}'s house">.
X<::> X<'>

Using C<'> as a package separator is deprecated and will be removed in
Perl 5.40.

Packages may themselves contain package separators, as in
C<$OUTER::INNER::var>.  This implies nothing about the order of
name lookups, however.  There are no relative packages: all symbols
are either local to the current package, or must be fully qualified
from the outer package name down.  For instance, there is nowhere
within package C<OUTER> that C<$INNER::var> refers to
C<$OUTER::INNER::var>.  C<INNER> refers to a totally
separate global package. The custom of treating package names as a
hierarchy is very strong, but the language in no way enforces it.

Only identifiers starting with letters (or underscore) are stored
in a package's symbol table.  All other symbols are kept in package
C<main>, including all punctuation variables, like $_.  In addition,
when unqualified, the identifiers STDIN, STDOUT, STDERR, ARGV,
ARGVOUT, ENV, INC, and SIG are forced to be in package C<main>,
even when used for other purposes than their built-in ones.  If you
have a package called C<m>, C<s>, or C<y>, then you can't use the
qualified form of an identifier because it would be instead interpreted
as a pattern match, a substitution, or a transliteration.
X<variable, punctuation> 

Variables beginning with underscore used to be forced into package
main, but we decided it was more useful for package writers to be able
to use leading underscore to indicate private variables and method names.
However, variables and functions named with a single C<_>, such as
$_ and C<sub _>, are still forced into the package C<main>.  See also
L<perlvar/"The Syntax of Variable Names">.

C<eval>ed strings are compiled in the package in which the eval() was
compiled.  (Assignments to C<$SIG{}>, however, assume the signal
handler specified is in the C<main> package.  Qualify the signal handler
name if you wish to have a signal handler in a package.)  For an
example, examine F<perldb.pl> in the Perl library.  It initially switches
to the C<DB> package so that the debugger doesn't interfere with variables
in the program you are trying to debug.  At various points, however, it
temporarily switches back to the C<main> package to evaluate various
expressions in the context of the C<main> package (or wherever you came
from).  See L<perldebug>.

The special symbol C<__PACKAGE__> contains the current package, but cannot
(easily) be used to construct variable names. After C<my($foo)> has hidden
package variable C<$foo>, it can still be accessed, without knowing what
package you are in, as C<${__PACKAGE__.'::foo'}>.

See L<perlsub> for other scoping issues related to my() and local(),
and L<perlref> regarding closures.

=head2 Symbol Tables
X<symbol table> X<stash> X<%::> X<%main::> X<typeglob> X<glob> X<alias>

The symbol table for a package happens to be stored in the hash of that
name with two colons appended.  The main symbol table's name is thus
C<%main::>, or C<%::> for short.  Likewise the symbol table for the nested
package mentioned earlier is named C<%OUTER::INNER::>.

The value in each entry of the hash is what you are referring to when you
use the C<*name> typeglob notation.

    local *main::foo    = *main::bar;

You can use this to print out all the variables in a package, for
instance.  The standard but antiquated F<dumpvar.pl> library and
the CPAN module Devel::Symdump make use of this.

The results of creating new symbol table entries directly or modifying any
entries that are not already typeglobs are undefined and subject to change
between releases of perl.

Assignment to a typeglob performs an aliasing operation, i.e.,

    *dick = *richard;

causes variables, subroutines, formats, and file and directory handles
accessible via the identifier C<richard> also to be accessible via the
identifier C<dick>.  If you want to alias only a particular variable or
subroutine, assign a reference instead:

    *dick = \$richard;

Which makes $richard and $dick the same variable, but leaves
@richard and @dick as separate arrays.  Tricky, eh?

There is one subtle difference between the following statements:

    *foo = *bar;
    *foo = \$bar;

C<*foo = *bar> makes the typeglobs themselves synonymous while
C<*foo = \$bar> makes the SCALAR portions of two distinct typeglobs
refer to the same scalar value. This means that the following code:

    $bar = 1;
    *foo = \$bar;       # Make $foo an alias for $bar

    {
        local $bar = 2; # Restrict changes to block
        print $foo;     # Prints '1'!
    }

Would print '1', because C<$foo> holds a reference to the I<original>
C<$bar>. The one that was stuffed away by C<local()> and which will be
restored when the block ends. Because variables are accessed through the
typeglob, you can use C<*foo = *bar> to create an alias which can be
localized. (But be aware that this means you can't have a separate
C<@foo> and C<@bar>, etc.)

What makes all of this important is that the Exporter module uses glob
aliasing as the import/export mechanism. Whether or not you can properly
localize a variable that has been exported from a module depends on how
it was exported:

    @EXPORT = qw($FOO); # Usual form, can't be localized
    @EXPORT = qw(*FOO); # Can be localized

You can work around the first case by using the fully qualified name
(C<$Package::FOO>) where you need a local value, or by overriding it
by saying C<*FOO = *Package::FOO> in your script.

The C<*x = \$y> mechanism may be used to pass and return cheap references
into or from subroutines if you don't want to copy the whole
thing.  It only works when assigning to dynamic variables, not
lexicals.

    %some_hash = ();			# can't be my()
    *some_hash = fn( \%another_hash );
    sub fn {
	local *hashsym = shift;
	# now use %hashsym normally, and you
	# will affect the caller's %another_hash
	my %nhash = (); # do what you want
	return \%nhash;
    }

On return, the reference will overwrite the hash slot in the
symbol table specified by the *some_hash typeglob.  This
is a somewhat tricky way of passing around references cheaply
when you don't want to have to remember to dereference variables
explicitly.

Another use of symbol tables is for making "constant" scalars.
X<constant> X<scalar, constant>

    *PI = \3.14159265358979;

Now you cannot alter C<$PI>, which is probably a good thing all in all.
This isn't the same as a constant subroutine, which is subject to
optimization at compile-time.  A constant subroutine is one prototyped
to take no arguments and to return a constant expression.  See
L<perlsub> for details on these.  The C<use constant> pragma is a
convenient shorthand for these.

You can say C<*foo{PACKAGE}> and C<*foo{NAME}> to find out what name and
package the *foo symbol table entry comes from.  This may be useful
in a subroutine that gets passed typeglobs as arguments:

    sub identify_typeglob {
        my $glob = shift;
        print 'You gave me ', *{$glob}{PACKAGE},
            '::', *{$glob}{NAME}, "\n";
    }
    identify_typeglob *foo;
    identify_typeglob *bar::baz;

This prints

    You gave me main::foo
    You gave me bar::baz

The C<*foo{THING}> notation can also be used to obtain references to the
individual elements of *foo.  See L<perlref>.

Subroutine definitions (and declarations, for that matter) need
not necessarily be situated in the package whose symbol table they
occupy.  You can define a subroutine outside its package by
explicitly qualifying the name of the subroutine:

    package main;
    sub Some_package::foo { ... }   # &foo defined in Some_package

This is just a shorthand for a typeglob assignment at compile time:

    BEGIN { *Some_package::foo = sub { ... } }

and is I<not> the same as writing:

    {
	package Some_package;
	sub foo { ... }
    }

In the first two versions, the body of the subroutine is
lexically in the main package, I<not> in Some_package. So
something like this:

    package main;

    $Some_package::name = "fred";
    $main::name = "barney";

    sub Some_package::foo {
	print "in ", __PACKAGE__, ": \$name is '$name'\n";
    }

    Some_package::foo();

prints:

    in main: $name is 'barney'

rather than:

    in Some_package: $name is 'fred'

This also has implications for the use of the SUPER:: qualifier
(see L<perlobj>).

=head2 BEGIN, UNITCHECK, CHECK, INIT and END
X<BEGIN> X<UNITCHECK> X<CHECK> X<INIT> X<END>

Five specially named code blocks are executed at the beginning and at
the end of a running Perl program.  These are the C<BEGIN>,
C<UNITCHECK>, C<CHECK>, C<INIT>, and C<END> blocks.

These code blocks can be prefixed with C<sub> to give the appearance of a
subroutine (although this is not considered good style).  One should note
that these code blocks don't really exist as named subroutines (despite
their appearance). The thing that gives this away is the fact that you can
have B<more than one> of these code blocks in a program, and they will get
B<all> executed at the appropriate moment.  So you can't execute any of
these code blocks by name.

A C<BEGIN> code block is executed as soon as possible, that is, the moment
it is completely defined, even before the rest of the containing file (or
string) is parsed.  You may have multiple C<BEGIN> blocks within a file (or
eval'ed string); they will execute in order of definition.  Because a C<BEGIN>
code block executes immediately, it can pull in definitions of subroutines
and such from other files in time to be visible to the rest of the compile
and run time.  Once a C<BEGIN> has run, it is immediately undefined and any
code it used is returned to Perl's memory pool.

An C<END> code block is executed as late as possible, that is, after
perl has finished running the program and just before the interpreter
is being exited, even if it is exiting as a result of a die() function.
(But not if it's morphing into another program via C<exec>, or
being blown out of the water by a signal--you have to trap that yourself
(if you can).)  You may have multiple C<END> blocks within a file--they
will execute in reverse order of definition; that is: last in, first
out (LIFO).  C<END> blocks are not executed when you run perl with the
C<-c> switch, or if compilation fails.

Note that C<END> code blocks are B<not> executed at the end of a string
C<eval()>: if any C<END> code blocks are created in a string C<eval()>,
they will be executed just as any other C<END> code block of that package
in LIFO order just before the interpreter is being exited.

Inside an C<END> code block, C<$?> contains the value that the program is
going to pass to C<exit()>.  You can modify C<$?> to change the exit
value of the program.  Beware of changing C<$?> by accident (e.g. by
running something via C<system>).
X<$?>

Inside of a C<END> block, the value of C<${^GLOBAL_PHASE}> will be
C<"END">.

Similar to an C<END> block are C<defer> blocks, though they operate on the
lifetime of individual block scopes, rather than the program as a whole. They
are documented in L<perlsyn/defer>.

C<UNITCHECK>, C<CHECK> and C<INIT> code blocks are useful to catch the
transition between the compilation phase and the execution phase of
the main program.

C<UNITCHECK> blocks are run just after the unit which defined them has
been compiled.  The main program file and each module it loads are
compilation units, as are string C<eval>s, run-time code compiled using the
C<(?{ })> construct in a regex, calls to C<do FILE>, C<require FILE>,
and code after the C<-e> switch on the command line.

C<BEGIN> and C<UNITCHECK> blocks are not directly related to the phase of
the interpreter.  They can be created and executed during any phase.

C<CHECK> code blocks are run just after the B<initial> Perl compile phase ends
and before the run time begins, in LIFO order.  C<CHECK> code blocks are used
in the Perl compiler suite to save the compiled state of the program.

Inside of a C<CHECK> block, the value of C<${^GLOBAL_PHASE}> will be
C<"CHECK">.

C<INIT> blocks are run just before the Perl runtime begins execution, in
"first in, first out" (FIFO) order.

Inside of an C<INIT> block, the value of C<${^GLOBAL_PHASE}> will be C<"INIT">.

The C<CHECK> and C<INIT> blocks in code compiled by C<require>, string C<do>,
or string C<eval> will not be executed if they occur after the end of the
main compilation phase; that can be a problem in mod_perl and other persistent
environments which use those functions to load code at runtime.

When you use the B<-n> and B<-p> switches to Perl, C<BEGIN> and
C<END> work just as they do in B<awk>, as a degenerate case.
Both C<BEGIN> and C<CHECK> blocks are run when you use the B<-c>
switch for a compile-only syntax check, although your main code
is not.

The B<begincheck> program makes it all clear, eventually:

  #!/usr/bin/perl

  # begincheck

  print         "10. Ordinary code runs at runtime.\n";

  END { print   "16.   So this is the end of the tale.\n" }
  INIT { print  " 7. INIT blocks run FIFO just before runtime.\n" }
  UNITCHECK {
    print       " 4.   And therefore before any CHECK blocks.\n"
  }
  CHECK { print " 6.   So this is the sixth line.\n" }

  print         "11.   It runs in order, of course.\n";

  BEGIN { print " 1. BEGIN blocks run FIFO during compilation.\n" }
  END { print   "15.   Read perlmod for the rest of the story.\n" }
  CHECK { print " 5. CHECK blocks run LIFO after all compilation.\n" }
  INIT { print  " 8.   Run this again, using Perl's -c switch.\n" }

  print         "12.   This is anti-obfuscated code.\n";

  END { print   "14. END blocks run LIFO at quitting time.\n" }
  BEGIN { print " 2.   So this line comes out second.\n" }
  UNITCHECK {
   print " 3. UNITCHECK blocks run LIFO after each file is compiled.\n"
  }
  INIT { print  " 9.   You'll see the difference right away.\n" }

  print         "13.   It only _looks_ like it should be confusing.\n";

  __END__

=head2 Perl Classes
X<class> X<@ISA>

There is no stable class syntax in Perl, but a package may act
as a class if it provides subroutines to act as methods.  Such a
package may also derive some of its methods from another class (package)
by listing the other package name(s) in its global @ISA array (which
must be a package global, not a lexical).

For more on packages acting as classes, see L<perlootut> and L<perlobj>.
For more on the not-yet-stable class syntax, see L<perlclass>.

=head2 Perl Modules
X<module>

A module is just a set of related functions in a library file, i.e.,
a Perl package with the same name as the file.  It is specifically
designed to be reusable by other modules or programs.  It may do this
by providing a mechanism for exporting some of its symbols into the
symbol table of any package using it, or it may function as a class
definition and make its semantics available implicitly through
method calls on the class and its objects, without explicitly
exporting anything.  Or it can do a little of both.

For example, to start a traditional, non-OO module called Some::Module,
create a file called F<Some/Module.pm> and start with this template:

    package Some::Module;  # assumes Some/Module.pm

    use v5.36;

    # Get the import method from Exporter to export functions and
    # variables
    use Exporter 5.57 'import';

    # set the version for version checking
    our $VERSION     = '1.00';

    # Functions and variables which are exported by default
    our @EXPORT      = qw(func1 func2);

    # Functions and variables which can be optionally exported
    our @EXPORT_OK   = qw($Var1 %Hashit func3);

    # exported package globals go here
    our $Var1    = '';
    our %Hashit  = ();

    # non-exported package globals go here
    # (they are still accessible as $Some::Module::stuff)
    our @more    = ();
    our $stuff   = '';

    # file-private lexicals go here, before any functions which use them
    my $priv_var    = '';
    my %secret_hash = ();

    # here's a file-private function as a closure,
    # callable as $priv_func->();
    my $priv_func = sub {
        ...
    };

    # make all your functions, whether exported or not;
    # remember to put something interesting in the {} stubs
    sub func1      { ... }
    sub func2      { ... }

    # this one isn't always exported, but could be called directly
    # as Some::Module::func3()
    sub func3      { ... }

    END { ... }       # module clean-up code here (global destructor)

    1;  # don't forget to return a true value from the file

Then go on to declare and use your variables in functions without
any qualifications.  See L<Exporter> and the L<perlmodlib> for
details on mechanics and style issues in module creation.

Perl modules are included into your program by saying

    use Module;

or

    use Module LIST;

This is exactly equivalent to

    BEGIN { require 'Module.pm'; 'Module'->import; }

or

    BEGIN { require 'Module.pm'; 'Module'->import( LIST ); }

As a special case

    use Module ();

is exactly equivalent to

    BEGIN { require 'Module.pm'; }

All Perl module files have the extension F<.pm>.  The C<use> operator
assumes this so you don't have to spell out "F<Module.pm>" in quotes.
This also helps to differentiate new modules from old F<.pl> and
F<.ph> files.  Module names are also capitalized unless they're
functioning as pragmas; pragmas are in effect compiler directives,
and are sometimes called "pragmatic modules" (or even "pragmata"
if you're a classicist).

The two statements:

    require SomeModule;
    require "SomeModule.pm";

differ from each other in two ways.  In the first case, any double
colons in the module name, such as C<Some::Module>, are translated
into your system's directory separator, usually "/".   The second
case does not, and would have to be specified literally.  The other
difference is that seeing the first C<require> clues in the compiler
that uses of indirect object notation involving "SomeModule", as
in C<$ob = purge SomeModule>, are method calls, not function calls.
(Yes, this really can make a difference.)

Because the C<use> statement implies a C<BEGIN> block, the importing
of semantics happens as soon as the C<use> statement is compiled,
before the rest of the file is compiled.  This is how it is able
to function as a pragma mechanism, and also how modules are able to
declare subroutines that are then visible as list or unary operators for
the rest of the current file.  This will not work if you use C<require>
instead of C<use>.  With C<require> you can get into this problem:

    require Cwd;		# make Cwd:: accessible
    $here = Cwd::getcwd();

    use Cwd;			# import names from Cwd::
    $here = getcwd();

    require Cwd;	    	# make Cwd:: accessible
    $here = getcwd(); 		# oops! no main::getcwd()

In general, C<use Module ()> is recommended over C<require Module>,
because it determines module availability at compile time, not in the
middle of your program's execution.  An exception would be if two modules
each tried to C<use> each other, and each also called a function from
that other module.  In that case, it's easy to use C<require> instead.

Perl packages may be nested inside other package names, so we can have
package names containing C<::>.  But if we used that package name
directly as a filename it would make for unwieldy or impossible
filenames on some systems.  Therefore, if a module's name is, say,
C<Text::Soundex>, then its definition is actually found in the library
file F<Text/Soundex.pm>.

Perl modules always have a F<.pm> file, but there may also be
dynamically linked executables (often ending in F<.so>) or autoloaded
subroutine definitions (often ending in F<.al>) associated with the
module.  If so, these will be entirely transparent to the user of
the module.  It is the responsibility of the F<.pm> file to load
(or arrange to autoload) any additional functionality.  For example,
although the POSIX module happens to do both dynamic loading and
autoloading, the user can say just C<use POSIX> to get it all.

=head2 Making your module threadsafe
X<threadsafe> X<thread safe>
X<module, threadsafe> X<module, thread safe>
X<CLONE> X<CLONE_SKIP> X<thread> X<threads> X<ithread>

Perl supports a type of threads called interpreter threads (ithreads).
These threads can be used explicitly and implicitly.

Ithreads work by cloning the data tree so that no data is shared
between different threads. These threads can be used by using the C<threads>
module or by doing fork() on win32 (fake fork() support). When a
thread is cloned all Perl data is cloned, however non-Perl data cannot
be cloned automatically.  Perl after 5.8.0 has support for the C<CLONE>
special subroutine.  In C<CLONE> you can do whatever
you need to do,
like for example handle the cloning of non-Perl data, if necessary.
C<CLONE> will be called once as a class method for every package that has it
defined (or inherits it).  It will be called in the context of the new thread,
so all modifications are made in the new area.  Currently CLONE is called with
no parameters other than the invocant package name, but code should not assume
that this will remain unchanged, as it is likely that in future extra parameters
will be passed in to give more information about the state of cloning.

If you want to CLONE all objects you will need to keep track of them per
package. This is simply done using a hash and Scalar::Util::weaken().

Perl after 5.8.7 has support for the C<CLONE_SKIP> special subroutine.
Like C<CLONE>, C<CLONE_SKIP> is called once per package; however, it is
called just before cloning starts, and in the context of the parent
thread. If it returns a true value, then no objects of that class will
be cloned; or rather, they will be copied as unblessed, undef values.
For example: if in the parent there are two references to a single blessed
hash, then in the child there will be two references to a single undefined
scalar value instead.
This provides a simple mechanism for making a module threadsafe; just add
C<sub CLONE_SKIP { 1 }> at the top of the class, and C<DESTROY()> will
now only be called once per object. Of course, if the child thread needs
to make use of the objects, then a more sophisticated approach is
needed.

Like C<CLONE>, C<CLONE_SKIP> is currently called with no parameters other
than the invocant package name, although that may change. Similarly, to
allow for future expansion, the return value should be a single C<0> or
C<1> value.

=head1 SEE ALSO

See L<perlmodlib> for general style issues related to building Perl
modules and classes, as well as descriptions of the standard library
and CPAN, L<Exporter> for how Perl's standard import/export mechanism
works, L<perlootut> and L<perlobj> for in-depth information on
creating classes, L<perlobj> for a hard-core reference document on
objects, L<perlsub> for an explanation of functions and scoping,
and L<perlxstut> and L<perlguts> for more information on writing
extension modules.
                                                                                         usr/local/lib/perl5/5.40.0/pod/perlmodinstall.pod                                                   0000644 0000000 0000000 00000022564 14714567415 020036  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =head1 NAME

perlmodinstall - Installing CPAN Modules

=head1 DESCRIPTION

You can think of a module as the fundamental unit of reusable Perl
code; see L<perlmod> for details.  Whenever anyone creates a chunk of
Perl code that they think will be useful to the world, they register
as a Perl developer at L<https://www.cpan.org/modules/04pause.html>
so that they can then upload their code to the CPAN.  The CPAN is the
Comprehensive Perl Archive Network and can be accessed at
L<https://www.cpan.org/> , and searched at L<https://metacpan.org/> .

This documentation is for people who want to download CPAN modules
and install them on their own computer.

=head2 PREAMBLE

First, are you sure that the module isn't already on your system?  Try
C<perl -MFoo -e 1>.  (Replace "Foo" with the name of the module; for
instance, C<perl -MCGI::Carp -e 1>.)

If you don't see an error message, you have the module.  (If you do
see an error message, it's still possible you have the module, but
that it's not in your path, which you can display with C<perl -e
"print qq(@INC)">.)  For the remainder of this document, we'll assume
that you really honestly truly lack an installed module, but have
found it on the CPAN.

So now you have a file ending in .tar.gz (or, less often, .zip).  You
know there's a tasty module inside.  There are four steps you must now
take:

=over 5

=item B<DECOMPRESS> the file

=item B<UNPACK> the file into a directory

=item B<BUILD> the module (sometimes unnecessary)

=item B<INSTALL> the module.

=back

Here's how to perform each step for each operating system.  This is
<not> a substitute for reading the README and INSTALL files that
might have come with your module!

Also note that these instructions are tailored for installing the
module into your system's repository of Perl modules, but you can
install modules into any directory you wish.  For instance, where I
say C<perl Makefile.PL>, you can substitute C<perl Makefile.PL
PREFIX=/my/perl_directory> to install the modules into
F</my/perl_directory>.  Then you can use the modules from your Perl
programs with C<use lib "/my/perl_directory/lib/site_perl";> or
sometimes just C<use "/my/perl_directory";>.  If you're on a system
that requires superuser/root access to install modules into the
directories you see when you type C<perl -e "print qq(@INC)">, you'll
want to install them into a local directory (such as your home
directory) and use this approach.

=over 4

=item *

B<If you're on a Unix or Unix-like system,>

You can use Andreas Koenig's CPAN module
( L<https://metacpan.org/release/CPAN> )
to automate the following steps, from DECOMPRESS through INSTALL.

A. DECOMPRESS

Decompress the file with C<gzip -d yourmodule.tar.gz>

You can get gzip from L<ftp://prep.ai.mit.edu/pub/gnu/>

Or, you can combine this step with the next to save disk space:

     gzip -dc yourmodule.tar.gz | tar -xof -

B. UNPACK

Unpack the result with C<tar -xof yourmodule.tar>

C. BUILD

Go into the newly-created directory and type:

      perl Makefile.PL
      make test

or

      perl Makefile.PL PREFIX=/my/perl_directory

to install it locally.  (Remember that if you do this, you'll have to
put C<use lib "/my/perl_directory";> near the top of the program that
is to use this module.

D. INSTALL

While still in that directory, type:

      make install

Make sure you have the appropriate permissions to install the module
in your Perl 5 library directory.  Often, you'll need to be root.

That's all you need to do on Unix systems with dynamic linking.
Most Unix systems have dynamic linking. If yours doesn't, or if for
another reason you have a statically-linked perl, B<and> the
module requires compilation, you'll need to build a new Perl binary
that includes the module.  Again, you'll probably need to be root.

=item *

B<If you're running ActivePerl (Win95/98/2K/NT/XP, Linux, Solaris),>

First, type C<ppm> from a shell and see whether ActiveState's PPM
repository has your module.  If so, you can install it with C<ppm> and
you won't have to bother with any of the other steps here.  You might
be able to use the CPAN instructions from the "Unix or Linux" section
above as well; give it a try.  Otherwise, you'll have to follow the
steps below.

   A. DECOMPRESS

You can use the
open source 7-zip ( L<https://www.7-zip.org/> )
or the shareware Winzip ( L<https://www.winzip.com> ) to
decompress and unpack modules.

   B. UNPACK

If you used WinZip, this was already done for you.

   C. BUILD

You'll need either C<nmake> or C<gmake>.

Does the module require compilation (i.e. does it have files that end
in .xs, .c, .h, .y, .cc, .cxx, or .C)?  If it does, life is now
officially tough for you, because you have to compile the module
yourself (no easy feat on Windows).  You'll need a compiler such as
Visual C++.  Alternatively, you can download a pre-built PPM package
from ActiveState.
L<http://aspn.activestate.com/ASPN/Downloads/ActivePerl/PPM/>

Go into the newly-created directory and type:

      perl Makefile.PL
      nmake test


   D. INSTALL

While still in that directory, type:

      nmake install

=item *

B<If you're on OS/2,>

Get the EMX development suite and gzip/tar from Hobbes (
L<http://hobbes.nmsu.edu/h-browse.php?dir=/pub/os2/dev/emx/v0.9d> ), and then follow
the instructions for Unix.

=item *

