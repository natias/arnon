The selection is removed when the selected text is scrolled or changed.

On the command line CTRL-Y can be used to copy the selection into the
clipboard.  To do this from Insert mode, use CTRL-O : CTRL-Y <CR>.  When
'guioptions' contains a or A (default on X11), the selection is automatically
copied to the "* register.

The middle mouse button can then paste the text.  On non-X11 systems, you can
use CTRL-R +.


3.4 Using Mouse on Status Lines				*gui-mouse-status*

Clicking the left or right mouse button on the status line below a Vim
window makes that window the current window.  This actually happens on button
release (to be able to distinguish a click from a drag action).

With the left mouse button a status line can be dragged up and down, thus
resizing the windows above and below it.  This does not change window focus.

The same can be used on the vertical separator: click to give the window left
of it focus, drag left and right to make windows wider and narrower.


3.5 Various Mouse Clicks				*gui-mouse-various*

    <S-LeftMouse>	Search forward for the word under the mouse click.
			When 'mousemodel' is "popup" this starts or extends a
			selection.
    <S-RightMouse>	Search backward for the word under the mouse click.
    <C-LeftMouse>	Jump to the tag name under the mouse click.
    <C-RightMouse>	Jump back to position before the previous tag jump
			(same as "CTRL-T")


3.6 Mouse Mappings					*gui-mouse-mapping*

The mouse events, complete with modifiers, may be mapped.  Eg: >
   :map <S-LeftMouse>     <RightMouse>
   :map <S-LeftDrag>      <RightDrag>
   :map <S-LeftRelease>   <RightRelease>
   :map <2-S-LeftMouse>   <2-RightMouse>
   :map <2-S-LeftDrag>    <2-RightDrag>
   :map <2-S-LeftRelease> <2-RightRelease>
   :map <3-S-LeftMouse>   <3-RightMouse>
   :map <3-S-LeftDrag>    <3-RightDrag>
   :map <3-S-LeftRelease> <3-RightRelease>
   :map <4-S-LeftMouse>   <4-RightMouse>
   :map <4-S-LeftDrag>    <4-RightDrag>
   :map <4-S-LeftRelease> <4-RightRelease>
These mappings make selection work the way it probably should in a Motif
application, with shift-left mouse allowing for extending the visual area
rather than the right mouse button.

<MouseMove> may be mapped, but 'mousemoveevent' must be enabled to use the
mapping.

Mouse mapping with modifiers does not work for modeless selection.


3.7 Drag and drop						*drag-n-drop*

You can drag and drop one or more files into the Vim window, where they will
be opened as if a |:drop| command was used.  You can check if this is
supported with the *drop_file* feature: `has('drop_file')`.

If you hold down Shift while doing this, Vim changes to the first dropped
file's directory.  If you hold Ctrl Vim will always split a new window for the
file.  Otherwise it's only done if the current buffer has been changed.

You can also drop a directory on Vim.  This starts the explorer plugin for
that directory (assuming it was enabled, otherwise you'll get an error
message).  Keep Shift pressed to change to the directory instead.

If Vim happens to be editing a command line, the names of the dropped files
and directories will be inserted at the cursor.  This allows you to use these
names with any Ex command.  Special characters (space, tab, double quote and
'|'; backslash on non-MS-Windows systems) will be escaped.

==============================================================================
4. Making GUI Selections				*gui-selections*

							*quotestar*
You may make selections with the mouse (see |gui-mouse-select|), or by using
Vim's Visual mode (see |v|).  If 'a' is present in 'guioptions', then
whenever a selection is started (Visual or Select mode), or when the selection
is changed, Vim becomes the owner of the windowing system's primary selection
(on MS-Windows the |gui-clipboard| is used; under X11, the |x11-selection| is
used - you should read whichever of these is appropriate now).

							*clipboard*
There is a special register for storing this selection, it is the "*
register.  Nothing is put in here unless the information about what text is
selected is about to change (e.g. with a left mouse click somewhere), or when
another application wants to paste the selected text.  Then the text is put
in the "* register.  For example, to cut a line and make it the current
selection/put it on the clipboard: >

	"*dd

Similarly, when you want to paste a selection from another application, e.g.,
by clicking the middle mouse button, the selection is put in the "* register
first, and then 'put' like any other register.  For example, to put the
selection (contents of the clipboard): >

	"*p

When using this register under X11, also see |x11-selection|.  This also
explains the related "+ register.

Note that when pasting text from one Vim into another separate Vim, the type
of selection (character, line, or block) will also be copied.  For other
applications the type is always character.  However, if the text gets
transferred via the |x11-cut-buffer|, the selection type is ALWAYS lost.

When the "unnamed" string is included in the 'clipboard' option, the unnamed
register is the same as the "* register.  Thus you can yank to and paste the
selection without prepending "* to commands.

==============================================================================
5. Menus						*menus*

For an introduction see |usr_42.txt| in the user manual.


5.1 Using Menus						*using-menus*

Basically, menus can be used just like mappings.  You can define your own
menus, as many as you like.
Long-time Vim users won't use menus much.  But the power is in adding your own
menus and menu items.  They are most useful for things that you can't remember
what the key sequence was.

For creating menus in a different language, see |:menutrans|.
If you don't want to use menus at all, see |'go-M'|.

							*menu.vim*
The default menus are read from the file "$VIMRUNTIME/menu.vim".  See
|$VIMRUNTIME| for where the path comes from.  You can set up your own menus.
Starting off with the default set is a good idea.  You can add more items, or,
if you don't like the defaults at all, start with removing all menus
|:unmenu-all|.  You can also avoid the default menus being loaded by adding
this line to your .vimrc file (NOT your .gvimrc file!): >
	:let did_install_default_menus = 1
If you also want to avoid the Syntax menu: >
	:let did_install_syntax_menu = 1
The first item in the Syntax menu can be used to show all available filetypes
in the menu (which can take a bit of time to load).  If you want to have all
filetypes already present at startup, add: >
	:let do_syntax_sel_menu = 1

The following menuitems show all available color schemes, keymaps and compiler
settings:
	Edit > Color Scheme ~
	Edit > Keymap ~
	Tools > Set Compiler ~
However, they can also take a bit of time to load, because they search all
related files from the directories in 'runtimepath'.  Therefore they are
loaded lazily (by the |CursorHold| event), or you can also load them manually.
If you want to have all these items already present at startup, add: >
	:let do_no_lazyload_menus = 1

Note that the menu.vim is sourced when `:syntax on` or `:filetype on` is
executed or after your .vimrc file is sourced.  This means that the 'encoding'
option and the language of messages (`:language messages`) must be set before
that (if you want to change them).

							*console-menus*
Although this documentation is in the GUI section, you can actually use menus
in console mode too.  You will have to load |menu.vim| explicitly then, it is
not done by default.  You can use the |:emenu| command and command-line
completion with 'wildmenu' to access the menu entries almost like a real menu
system.  To do this, put these commands in your .vimrc file: >
	:source $VIMRUNTIME/menu.vim
	:set wildmenu
	:set cpo-=<
	:set wcm=<C-Z>
	:map <F4> :emenu <C-Z>
Pressing <F4> will start the menu.  You can now use the cursor keys to select
a menu entry.  Hit <Enter> to execute it.  Hit <Esc> if you want to cancel.
This does require the |+menu| feature enabled at compile time.

							*tear-off-menus*
GTK+ 2 and Motif support Tear-off menus.  These are sort of sticky menus or
pop-up menus that are present all the time.  If the resizing does not work
correctly, this may be caused by using something like "Vim*geometry" in the
defaults.  Use "Vim.geometry" instead.

As to GTK+ 3, tear-off menus have been deprecated since GTK+ 3.4.
Accordingly, they are disabled if gvim is linked against GTK+ 3.4 or later.

The Win32 GUI version emulates Motif's tear-off menus.  Actually, a Motif user
will spot the differences easily, but hopefully they're just as useful.  You
can also use the |:tearoff| command together with |hidden-menus| to create
floating menus that do not appear on the main menu bar.


5.2 Creating New Menus					*creating-menus*

				*:me*  *:menu*   *:noreme*  *:noremenu*
				*E330* *E327* *E331* *E336* *E333*
				*E328* *E329* *E337* *E792*
To create a new menu item, use the ":menu" commands.  They are mostly like
the ":map" set of commands (see |map-modes|), but the first argument is a menu
item name, given as a path of menus and submenus with a '.' between them,
e.g.: >

   :menu File.Save  :w<CR>
   :inoremenu File.Save  <C-O>:w<CR>
   :menu Edit.Big\ Changes.Delete\ All\ Spaces  :%s/[ ^I]//g<CR>

This last one will create a new item in the menu bar called "Edit", holding
the mouse button down on this will pop up a menu containing the item
"Big Changes", which is a sub-menu containing the item "Delete All Spaces",
which when selected, performs the operation.

To create a menu for terminal mode, use |:tlmenu| instead of |:tmenu| unlike
key mapping (|:tmap|). This is because |:tmenu| is already used for defining
tooltips for menus. See |terminal-typing|.

Special characters in a menu name:

							*menu-shortcut*
	&	The next character is the shortcut key.  Make sure each
		shortcut key is only used once in a (sub)menu.  If you want to
		insert a literal "&" in the menu name use "&&".
							*menu-text*
	<Tab>	Separates the menu name from right-aligned text.  This can be
		used to show the equivalent typed command.  The text "<Tab>"
		can be used here for convenience.  If you are using a real
		tab, don't forget to put a backslash before it!
Example: >

   :amenu &File.&Open<Tab>:e  :browse e<CR>

[typed literally]
With the shortcut "F" (while keeping the <Alt> key pressed), and then "O",
this menu can be used.  The second part is shown as "Open     :e".  The ":e"
is right aligned, and the "O" is underlined, to indicate it is the shortcut.

					*:am*  *:amenu*  *:an*      *:anoremenu*
The ":amenu" command can be used to define menu entries for all modes at once,
except for Terminal mode.  To make the command work correctly, a character is
automatically inserted for some modes:
	mode		inserted	appended	~
	Normal		nothing		nothing
	Visual		<C-C>		<C-\><C-G>
	Insert		<C-\><C-O>
	Cmdline		<C-C>		<C-\><C-G>
	Op-pending	<C-C>		<C-\><C-G>

Appending CTRL-\ CTRL-G is for going back to insert mode when 'insertmode' is
set. |CTRL-\_CTRL-G|

Example: >

   :amenu File.Next	:next^M

is equal to: >

   :nmenu File.Next	:next^M
   :vmenu File.Next	^C:next^M^\^G
   :imenu File.Next	^\^O:next^M
   :cmenu File.Next	^C:next^M^\^G
   :omenu File.Next	^C:next^M^\^G

Careful: In Insert mode this only works for a SINGLE Normal mode command,
because of the CTRL-O.  If you have two or more commands, you will need to use
the ":imenu" command.  For inserting text in any mode, you can use the
expression register: >

   :amenu Insert.foobar   "='foobar'<CR>P

The special text <Cmd> begins a "command menu", it executes the command
directly without changing modes.  Where you might use ":...<CR>" you can
instead use "<Cmd>...<CR>".  See |<Cmd>| for more info.  Example: >
	anoremenu File.Next <Cmd>next<CR>

Note that the '<' and 'k' flags in 'cpoptions' also apply here (when
included they make the <> form and raw key codes not being recognized).

Note that <Esc> in Cmdline mode executes the command, like in a mapping.  This
is Vi compatible.  Use CTRL-C to quit Cmdline mode.

		*:nme* *:nmenu*  *:nnoreme* *:nnoremenu* *:nunme* *:nunmenu*
Menu commands starting with "n" work in Normal mode. |mapmode-n|

		*:ome* *:omenu*  *:onoreme* *:onoremenu* *:ounme* *:ounmenu*
Menu commands starting with "o" work in Operator-pending mode. |mapmode-o|

		*:vme* *:vmenu*  *:vnoreme* *:vnoremenu* *:vunme* *:vunmenu*
Menu commands starting with "v" work in Visual mode. |mapmode-v|

		*:xme* *:xmenu*  *:xnoreme* *:xnoremenu* *:xunme* *:xunmenu*
Menu commands starting with "x" work in Visual and Select mode. |mapmode-x|

		*:sme* *:smenu*  *:snoreme* *:snoremenu* *:sunme* *:sunmenu*
Menu commands starting with "s" work in Select mode. |mapmode-s|

		*:ime* *:imenu*  *:inoreme* *:inoremenu* *:iunme* *:iunmenu*
Menu commands starting with "i" work in Insert mode. |mapmode-i|

		*:cme* *:cmenu*  *:cnoreme* *:cnoremenu* *:cunme* *:cunmenu*
Menu commands starting with "c" work in Cmdline mode. |mapmode-c|

		*:tlm* *:tlmenu* *:tln*     *:tlnoremenu* *:tlu*   *:tlunmenu*
Menu commands starting with "tl" work in Terminal mode. |mapmode-t|

						*:menu-<silent>* *:menu-silent*
To define a menu which will not be echoed on the command line, add
"<silent>" as the first argument.  Example: >
	:menu <silent> Settings.Ignore\ case  :set ic<CR>
The ":set ic" will not be echoed when using this menu.  Messages from the
executed command are still given though.  To shut them up too, add a ":silent"
in the executed command: >
	:menu <silent> Search.Header :exe ":silent normal /Header\r"<CR>
"<silent>" may also appear just after "<special>" or "<script>".

					*:menu-<special>* *:menu-special*
Define a menu with <> notation for special keys, even though the "<" flag
may appear in 'cpoptions'.  This is useful if the side effect of setting
'cpoptions' is not desired.  Example: >
	:menu <special> Search.Header /Header<CR>
"<special>" must appear as the very first argument to the ":menu" command or
just after "<silent>" or "<script>".

						*:menu-<script>* *:menu-script*
The "to" part of the menu will be inspected for mappings.  If you don't want
this, use the ":noremenu" command (or the similar one for a specific mode).
If you do want to use script-local mappings, add "<script>" as the very first
argument to the ":menu" command or just after "<silent>" or "<special>".

							*menu-priority*
You can give a priority to a menu.  Menus with a higher priority go more to
the right.  The priority is given as a number before the ":menu" command.
Example: >
	:80menu Buffer.next :bn<CR>

The default menus have these priorities:
	File		10
	Edit		20
	Tools		40
	Syntax		50
	Buffers		60
	Window		70
	Help		9999

When no or zero priority is given, 500 is used.
The priority for the PopUp menu is not used.

The Help menu will be placed on the far right side of the menu bar on systems
which support this (Motif and GTK+).  For GTK+ 2 and 3, this is not done
anymore because right-aligning the Help menu is now discouraged UI design.

You can use a priority higher than 9999, to make it go after the Help menu,
but that is non-standard and is discouraged.  The highest possible priority is
about 32000.  The lowest is 1.

							*sub-menu-priority*
The same mechanism can be used to position a sub-menu.  The priority is then
given as a dot-separated list of priorities, before the menu name: >
	:menu 80.500 Buffer.next :bn<CR>
Giving the sub-menu priority is only needed when the item is not to be put
in a normal position.  For example, to put a sub-menu before the other items: >
	:menu 80.100 Buffer.first :brew<CR>
Or to put a sub-menu after the other items, and further items with default
priority will be put before it: >
	:menu 80.900 Buffer.last :blast<CR>
When a number is missing, the default value 500 will be used: >
	:menu .900 myMenu.test :echo "text"<CR>
The menu priority is only used when creating a new menu.  When it already
existed, e.g., in another mode, the priority will not change.  Thus, the
priority only needs to be given the first time a menu is used.
An exception is the PopUp menu.  There is a separate menu for each mode
(Normal, Op-pending, Visual, Insert, Cmdline).  The order in each of these
menus can be different.  This is different from menu-bar menus, which have
the same order for all modes.
NOTE: sub-menu priorities currently don't work for all versions of the GUI.

							*menu-separator* *E332*
Menu items can be separated by a special item that inserts some space between
items.  Depending on the system this is displayed as a line or a dotted line.
These items must start with a '-' and end in a '-'.  The part in between is
used to give it a unique name.  Priorities can be used as with normal items.
Example: >
	:menu Example.item1	:do something
	:menu Example.-Sep-	:
	:menu Example.item2	:do something different
Note that the separator also requires a rhs.  It doesn't matter what it is,
because the item will never be selected.  Use a single colon to keep it
simple.

							*gui-toolbar*
The toolbar is currently available in the Win32, Motif, GTK+ (X11),
and Photon GUI.  It should turn up in other GUIs in due course.  The
default toolbar is setup in menu.vim.
The display of the toolbar is controlled by the 'guioptions' letter 'T'.  You
can thus have menu & toolbar together, or either on its own, or neither.
The appearance is controlled by the 'toolbar' option.  You can choose between
an image, text or both.

							*toolbar-icon*
The toolbar is defined as a special menu called ToolBar, which only has one
level.  Vim interprets the items in this menu as follows:
1)  If an "icon=" argument was specified, the file with this name is used.
    The file can either be specified with the full path or with the base name.
    In the last case it is searched for in the "bitmaps" directory in
    'runtimepath', like in point 3.  Examples: >
	:amenu icon=/usr/local/pixmaps/foo_icon.xpm ToolBar.Foo :echo "Foo"<CR>
	:amenu icon=FooIcon ToolBar.Foo :echo "Foo"<CR>
<   Note that in the first case the extension is included, while in the second
    case it is omitted.
    If the file cannot be opened the next points are tried.
    A space in the file name must be escaped with a backslash.
    A menu priority must come _after_ the icon argument: >
	:amenu icon=foo 1.42 ToolBar.Foo :echo "42!"<CR>
2)  An item called 'BuiltIn##', where ## is a number, is taken as number ## of
    the built-in bitmaps available in Vim.  Currently there are 31 numbered
    from 0 to 30 which cover most common editing operations |builtin-tools|. >
	:amenu ToolBar.BuiltIn22 :call SearchNext("back")<CR>
3)  An item with another name is first searched for in the directory
    "bitmaps" in 'runtimepath'.  If found, the bitmap file is used as the
    toolbar button image.  Note that the exact filename is OS-specific: For
    example, under Win32 the command >
	:amenu ToolBar.Hello :echo "hello"<CR>
<   would find the file 'hello.bmp'.  Under GTK+/X11 it is 'Hello.xpm'.  With
    GTK+ 2 the files 'Hello.png', 'Hello.xpm' and 'Hello.bmp' are checked for
    existence, and the first one found would be used.
    For MS-Windows and GTK+ 2 the bitmap is scaled to fit the button.  For
    MS-Windows a size of 18 by 18 pixels works best.
    For MS-Windows the bitmap should have 16 colors with the standard palette.
    The light grey pixels will be changed to the Window frame color and the
    dark grey pixels to the window shadow color.  More colors might also work,
    depending on your system.
4)  If the bitmap is still not found, Vim checks for a match against its list
    of built-in names.  Each built-in button image has a name.
    So the command >
	:amenu ToolBar.Open :e
<   will show the built-in "open a file" button image if no open.bmp exists.
    All the built-in names can be seen used in menu.vim.
5)  If all else fails, a blank, but functioning, button is displayed.

							*builtin-tools*
nr  Name		Normal action  ~
00  New			open new window
01  Open		browse for file to open in current window
02  Save		write buffer to file
03  Undo		undo last change
04  Redo		redo last undone change
05  Cut			delete selected text to clipboard
06  Copy		copy selected text to clipboard
07  Paste		paste text from clipboard
08  Print		print current buffer
09  Help		open a buffer on Vim's builtin help
10  Find		start a search command
11  SaveAll		write all modified buffers to file
12  SaveSesn		write session file for current situation
13  NewSesn		write new session file
14  LoadSesn		load session file
15  RunScript		browse for file to run as a Vim script
16  Replace		prompt for substitute command
17  WinClose		close current window
18  WinMax		make current window use many lines
19  WinMin		make current window use few lines
20  WinSplit		split current window
21  Shell		start a shell
22  FindPrev		search again, backward
23  FindNext		search again, forward
24  FindHelp		prompt for word to search help for
25  Make		run make and jump to first error
26  TagJump		jump to tag under the cursor
27  RunCtags		build tags for files in current directory
28  WinVSplit		split current window vertically
29  WinMaxWidth		make current window use many columns
30  WinMinWidth		make current window use few columns

					*hidden-menus* *win32-hidden-menus*
In the Win32 and GTK+ GUI, starting a menu name with ']' excludes that menu
from the main menu bar.  You must then use the |:popup| or |:tearoff| command
to display it.

					*window-toolbar* *WinBar*
Each window can have a local toolbar.  This uses the first line of the window,
thus reduces the space for the text by one line.  The items in the toolbar
must start with "WinBar".

Only text can be used.  When using Unicode, special characters can be used to
make the items look like icons.

If the items do not fit then the last ones cannot be used.  The toolbar does
not wrap.

Note that Vim may be in any mode when executing these commands.  The menu
should be defined for Normal mode and will be executed without changing the
current mode. Thus if the current window is in Visual mode and the menu
command does not intentionally change the mode, Vim will remain in Visual
mode.  Best is to use `:nnoremenu` to avoid side effects.

Example for debugger tools: >
	nnoremenu 1.10 WinBar.Step :Step<CR>
	nnoremenu 1.20 WinBar.Next :Next<CR>
	nnoremenu 1.30 WinBar.Finish :Finish<CR>
	nnoremenu 1.40 WinBar.Cont :Continue<CR>
<					*hl-ToolbarLine* *hl-ToolbarButton*
The window toolbar uses the ToolbarLine and ToolbarButton highlight groups.

When splitting the window the window toolbar is not copied to the new window.

							*popup-menu*
In the Win32, GTK+, Motif and Photon GUI, you can define the
special menu "PopUp".  This is the menu that is displayed when the right mouse
button is pressed, if 'mousemodel' is set to popup or popup_setpos.
Example: >
    nnoremenu 1.40 PopUp.&Paste	"+gP
    menu PopUp


5.3 Showing What Menus Are Mapped To			*showing-menus*

To see what an existing menu is mapped to, use just one argument after the
menu commands (just like you would with the ":map" commands).  If the menu
specified is a submenu, then all menus under that hierarchy will be shown.
If no argument is given after :menu at all, then ALL menu items are shown
for the appropriate mode (e.g., Command-line mode for :cmenu).

Special characters in the list, just before the rhs:
*	The menu was defined with "nore" to disallow remapping.
&	The menu was defined with "<script>" to allow remapping script-local
	mappings only.
s	The menu was defined with "<silent>" to avoid showing what it is
	mapped to when triggered.
-	The menu was disabled.

Note that hitting <Tab> while entering a menu name after a menu command may
be used to complete the name of the menu item.

It is not allowed to change menus while listing them.  *E1310*
This doesn't normally happen, only when, for example, you would have a timer
callback define a menu and the user lists menus in a way it shows
|more-prompt|.


5.4 Executing Menus					*execute-menus*

						*:em*  *:emenu* *E334* *E335*
:[range]em[enu] {menu}		Execute {menu} from the command line.
				The default is to execute the Normal mode
				menu.  If a range is specified, it executes
				the Visual mode menu.
				If used from <c-o>, it executes the
				insert-mode menu Eg: >
	:emenu File.Exit

:[range]em[enu] {mode} {menu}	Like above, but execute the menu for {mode}:
				    'n': |:nmenu|  Normal mode
				    'v': |:vmenu|  Visual mode
				    's': |:smenu|  Select mode
				    'o': |:omenu|  Operator-pending mode
				    't': |:tlmenu| Terminal mode
				    'i': |:imenu|  Insert mode
				    'c': |:cmenu|  Cmdline mode


If the console-mode vim has been compiled with WANT_MENU defined, you can
use :emenu to access useful menu items you may have got used to from GUI
mode.  See 'wildmenu' for an option that works well with this.  See
|console-menus| for an example.

When using a range, if the lines match with '<,'>, then the menu is executed
using the last visual selection.


5.5 Deleting Menus					*delete-menus*

						*:unme*  *:unmenu*
						*:aun*   *:aunmenu*
To delete a menu item or a whole submenu, use the unmenu commands, which are
analogous to the unmap commands.  Eg: >
    :unmenu! Edit.Paste

This will remove the Paste item from the Edit menu for Insert and
Command-line modes.

Note that hitting <Tab> while entering a menu name after an umenu command
may be used to complete the name of the menu item for the appropriate mode.

To remove all menus use:			*:unmenu-all*  >
	:unmenu *	" remove all menus in Normal and visual mode
	:unmenu! *	" remove all menus in Insert and Command-line mode
	:aunmenu *	" remove all menus in all modes, except for Terminal
			" mode
	:tlunmenu *	" remove all menus in Terminal mode

If you want to get rid of the menu bar: >
	:set guioptions-=m


5.6 Disabling Menus					*disable-menus*

						*:menu-disable* *:menu-enable*
If you do not want to remove a menu, but disable it for a moment, this can be
done by adding the "enable" or "disable" keyword to a ":menu" command.
Examples: >
	:menu disable &File.&Open\.\.\.
	:amenu enable *
	:amenu disable &Tools.*

The command applies to the modes as used with all menu commands.  Note that
characters like "&" need to be included for translated names to be found.
When the argument is "*", all menus are affected.  Otherwise the given menu
name and all existing submenus below it are affected.


5.7 Examples for Menus					*menu-examples*

Here is an example on how to add menu items with menu's!  You can add a menu
item for the keyword under the cursor.  The register "z" is used. >

  :nmenu Words.Add\ Var		wb"zye:menu! Words.<C-R>z <C-R>z<CR>
  :nmenu Words.Remove\ Var	wb"zye:unmenu! Words.<C-R>z<CR>
  :vmenu Words.Add\ Var		"zy:menu! Words.<C-R>z <C-R>z <CR>
  :vmenu Words.Remove\ Var	"zy:unmenu! Words.<C-R>z<CR>
  :imenu Words.Add\ Var		<Esc>wb"zye:menu! Words.<C-R>z <C-R>z<CR>a
  :imenu Words.Remove\ Var	<Esc>wb"zye:unmenu! Words.<C-R>z<CR>a

(the rhs is in <> notation, you can copy/paste this text to try out the
mappings, or put these lines in your gvimrc; "<C-R>" is CTRL-R, "<CR>" is
the <CR> key.  |<>|)

							*tooltips* *menu-tips*
5.8 Tooltips & Menu tips

See section |42.4| in the user manual.

							*:tmenu* *:tm*
:tm[enu] {menupath} {rhs}	Define a tip for a menu or tool.  {only in
				X11 and Win32 GUI}

:tm[enu] [menupath]		List menu tips. {only in X11 and Win32 GUI}

							*:tunmenu* *:tu*
:tu[nmenu] {menupath}		Remove a tip for a menu or tool.
				{only in X11 and Win32 GUI}

Note: To create menus for terminal mode, use |:tlmenu| instead.

When a tip is defined for a menu item, it appears in the command-line area
when the mouse is over that item, much like a standard Windows menu hint in
the status bar.  (Except when Vim is in Command-line mode, when of course
nothing is displayed.)
When a tip is defined for a ToolBar item, it appears as a tooltip when the
mouse pauses over that button, in the usual fashion.  Use the |hl-Tooltip|
highlight group to change its colors.

A "tip" can be defined for each menu item.  For example, when defining a menu
item like this: >
	:amenu MyMenu.Hello :echo "Hello"<CR>
The tip is defined like this: >
	:tmenu MyMenu.Hello Displays a greeting.
And delete it with: >
	:tunmenu MyMenu.Hello

Tooltips are currently only supported for the X11 and Win32 GUI.  However, they
should appear for the other gui platforms in the not too distant future.

The ":tmenu" command works just like other menu commands, it uses the same
arguments.  ":tunmenu" deletes an existing menu tip, in the same way as the
other unmenu commands.

If a menu item becomes invalid (i.e. its actions in all modes are deleted) Vim
deletes the menu tip (and the item) for you.  This means that :aunmenu deletes
a menu item - you don't need to do a :tunmenu as well.


5.9 Popup Menus

In the Win32 and GTK+ GUI, you can cause a menu to popup at the cursor.
This behaves similarly to the PopUp menus except that any menu tree can
be popped up.

This command is for backwards compatibility, using it is discouraged, because
it behaves in a strange way.

							*:popup* *:popu*
:popu[p] {name}			Popup the menu {name}.  The menu named must
				have at least one subentry, but need not
				appear on the menu-bar (see |hidden-menus|).
				{only available for Win32 and GTK GUI or in
				the terminal}

:popu[p]! {name}		Like above, but use the position of the mouse
				pointer instead of the cursor.
				In the terminal this is the last known
				position, which is usually at the last click
				or release (mouse movement is irrelevant).

Example: >
	:popup File
will make the "File" menu (if there is one) appear at the text cursor (mouse
pointer if ! was used). >

	:amenu ]Toolbar.Make	:make<CR>
	:popup ]Toolbar
This creates a popup menu that doesn't exist on the main menu-bar.

Note that in the GUI the :popup command will return immediately, before a
selection has been made.  In the terminal the commands waits for the user to
make a selection.

Note that a menu that starts with ']' will not be displayed.

==============================================================================
6. Font

This section describes font related options.

GUIFONT							*gui-font*

'guifont' is the option that tells Vim what font to use.  In its simplest form
the value is just one font name.  It can also be a list of font names
separated with commas.  The first valid font is used.  When no valid font can
be found you will get an error message.

On systems where 'guifontset' is supported (X11) and 'guifontset' is not
empty, then 'guifont' is not used.  See |xfontset|.

Note: As to the GTK GUIs, no error is given against any invalid names, and the
first element of the list is always picked up and made use of.  This is
because, instead of identifying a given name with a font, the GTK GUIs use it
to construct a pattern and try to look up a font which best matches the
pattern among available fonts, and this way, the matching never fails.  An
invalid name doesn't matter because a number of font properties other than
name will do to get the matching done.

Spaces after a comma are ignored.  To include a comma in a font name precede
it with a backslash.  Setting an option requires an extra backslash before a
space and a backslash.  See also |option-backslash|.  For example: >
    :set guifont=Screen15,\ 7x13,font\\,with\\,commas
will make Vim try to use the font "Screen15" first, and if it fails it will
try to use "7x13" and then "font,with,commas" instead.

If none of the fonts can be loaded, Vim will keep the current setting.  If an
empty font list is given, Vim will try using other resource settings (for X,
it will use the Vim.font resource), and finally it will try some builtin
default which should always be there ("7x13" in the case of X).  The font
names given should be "normal" fonts.  Vim will try to find the related bold
and italic fonts.

For Win32, GTK, Motif, Mac OS and Photon: >
    :set guifont=*
will bring up a font requester, where you can pick the font you want.

The font name depends on the GUI used.  See |setting-guifont| for a way to set
'guifont' for various systems.

For the GTK+ 2 and 3 GUIs, the font name looks like this: >
    :set guifont=Andale\ Mono\ 11
That's all.  XLFDs are not used.  For Chinese this is reported to work well: >
    if has("gui_gtk2")
      set guifont=Bitstream\ Vera\ Sans\ Mono\ 12,Fixed\ 12
      set guifontwide=Microsoft\ Yahei\ 12,WenQuanYi\ Zen\ Hei\ 12
    endif
<
(Replace gui_gtk2 with gui_gtk3 for the GTK+ 3 GUI)

For Mac OSX you can use something like this: >
    :set guifont=Monaco:h10

Mono-spaced fonts					*E236*

Note that the fonts must be mono-spaced (all characters have the same width).
An exception is GTK: all fonts are accepted, but mono-spaced fonts look best.

To preview a font on X11, you might be able to use the "xfontsel" program.
The "xlsfonts" program gives a list of all available fonts.

For the Win32 GUI					*E244* *E245*
- Takes these options in the font name (use a ':' to separate the options):
	hXX - height is XX (points, can be floating-point)
	wXX - width is XX (points, can be floating-point)
	WXX - weight is XX (see Note on Weights below)
	b   - bold. This is equivalent to setting the weight to 700.
	i   - italic
	u   - underline
	s   - strikeout
	cXX - character set XX.  Valid charsets are: ANSI, ARABIC, BALTIC,
	      CHINESEBIG5, DEFAULT, EASTEUROPE, GB2312, GREEK, HANGEUL,
	      HEBREW, JOHAB, MAC, OEM, RUSSIAN, SHIFTJIS, SYMBOL, THAI,
	      TURKISH and VIETNAMESE.  Normally you would use "cDEFAULT".
	qXX - quality XX.  Valid quality names are: PROOF, DRAFT, ANTIALIASED,
	      NONANTIALIASED, CLEARTYPE and DEFAULT.  Normally you would use
	      "qDEFAULT".
	      Some quality values are not supported in legacy OSs.
- A '_' can be used in the place of a space, so you don't need to use
  backslashes to escape the spaces.
Examples: >
    :set guifont=courier_new:h12:w5:b:cRUSSIAN
    :set guifont=Andale_Mono:h7.5:w4.5

See also |font-sizes|.

Note on Weights: Fonts often come with a variety of weights. "Normal" weights
in Windows have a value of 400 and, left unspecified, this is the value that
will be used when attempting to find fonts. Windows will often match fonts
based on their weight with higher priority than the font name which means a
Book or Medium variant of a font might be used despite specifying a Light or
ExtraLight variant. If you are experiencing heavier weight substitution, then
explicitly setting a lower weight value may mitigate against this unwanted
substitution.


GUIFONTWIDE						*gui-fontwide*

When not empty, 'guifontwide' specifies a comma-separated list of fonts to be
used for double-width characters.  The first font that can be loaded is used.

Note: The size of these fonts must be exactly twice as wide as the one
specified with 'guifont' and the same height.  If there is a mismatch then the
text will not be drawn correctly.

All GUI versions but GTK+:

'guifontwide' is only used when 'encoding' is set to "utf-8" and 'guifontset'
is empty or invalid.
When 'guifont' is set and a valid font is found in it and 'guifontwide' is
empty Vim will attempt to find a matching double-width font and set
'guifontwide' to it.

GTK+ GUI only:				*guifontwide_gtk*

If set and valid, 'guifontwide' is always used for double width characters,
even if 'encoding' is not set to "utf-8".
Vim does not attempt to find an appropriate value for 'guifontwide'
automatically.  If 'guifontwide' is empty Pango/Xft will choose the font for
characters not available in 'guifont'.  Thus you do not need to set
'guifontwide' at all unless you want to override the choice made by Pango/Xft.

Windows +multibyte only:		*guifontwide_win_mbyte*

If set and valid, 'guifontwide' is used for IME instead of 'guifont'.

==============================================================================
7. Extras						*gui-extras*

This section describes other features which are related to the GUI.

- With the GUI, there is no wait for one second after hitting escape, because
  the key codes don't start with <Esc>.

- Typing ^V followed by a special key in the GUI will insert "<Key>", since
  the internal string used is meaningless.  Modifiers may also be held down to
  get "<Modifiers-Key>".

- In the GUI, the modifiers SHIFT, CTRL, and ALT (or META) may be used within
  mappings of special keys and mouse events.
  E.g.: :map <M-LeftDrag> <LeftDrag>

- In the GUI, several normal keys may have modifiers in mappings etc, these
  are <Space>, <Tab>, <NL>, <CR>, <Esc>.

- To check in a Vim script if the GUI is being used, you can use something
  like this: >

	if has("gui_running")
	   echo "yes, we have a GUI"
	else
	   echo "Boring old console"
	endif
<							*setting-guifont*
- When you use the same vimrc file on various systems, you can use something
  like this to set options specifically for each type of GUI: >

	if has("gui_running")
	    if has("gui_gtk2")
		:set guifont=Luxi\ Mono\ 12
	    elseif has("x11")
		" Also for GTK 1
		:set guifont=*-lucidatypewriter-medium-r-normal-*-*-180-*-*-m-*-*
	    elseif has("gui_win32")
		:set guifont=Luxi_Mono:h12:cANSI
	    endif
	endif

A recommended Japanese font is MS Mincho.  You can find info here:
http://www.lexikan.com/mincho.htm

==============================================================================
8. Shell Commands					*gui-shell*

For the X11 GUI the external commands are executed inside the gvim window.
See |gui-pty|.

WARNING: Executing an external command from the X11 GUI will not always work.
"normal" commands like "ls", "grep" and "make" mostly work fine.
Commands that require an intelligent terminal like "less" and "ispell" won't
work.  Some may even hang and need to be killed from another terminal.  So be
careful!

For the Win32 GUI the external commands are executed in a separate window.
See |gui-shell-win32|.

 vim:tw=78:sw=4:ts=8:noet:ft=help:norl:
                                                                                                                                                                                                                                                      usr/share/vim/vim90/doc/gui_w32.txt                                                                 0000644 0000000 0000000 00000045263 14424703754 015527  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        *gui_w32.txt*   For Vim version 9.0.  Last change: 2022 Mar 09


		  VIM REFERENCE MANUAL    by Bram Moolenaar


Vim's Win32 Graphical User Interface			*gui-w32* *win32-gui*

1. Starting the GUI		|gui-w32-start|
2. Vim as default editor	|vim-default-editor|
3. Using the clipboard		|gui-clipboard|
4. Shell Commands		|gui-shell-win32|
5. Special colors		|win32-colors|
6. Windows dialogs & browsers	|gui-w32-dialogs|
7. Command line arguments	|gui-w32-cmdargs|
8. Various			|gui-w32-various|

Other relevant documentation:
|gui.txt|	For generic items of the GUI.
|os_win32.txt|	For Win32 specific items.


==============================================================================
1. Starting the GUI					*gui-w32-start*

The Win32 GUI version of Vim will always start the GUI, no matter how you
start it or what it's called.

The GUI will always run in the Windows subsystem.  Mostly shells automatically
return with a command prompt after starting gvim.  If not, you should use the
"start" command: >
	start gvim [options] file ..
<							*E988*
The console version with the |-g| option may also start the GUI by executing
gvim.exe: >
	vim -g [options] file ..
To make this work, gvim.exe must exist in the same directory as the vim.exe,
and this feature must be enabled at compile time.

One may also use `:gui` from the console version.  However, this is an
experimental feature and this feature must be enabled at compile time.
It uses a session file to recreate the current state of the console Vim in the
GUI Vim.

Note: All fonts (bold, italic) must be of the same size!!!  If you don't do
this, text will disappear or mess up the display.  Vim does not check the font
sizes.  It's the size in screen pixels that must be the same.  Note that some
fonts that have the same point size don't have the same pixel size!
Additionally, the positioning of the fonts must be the same (ascent and
descent).

The Win32 GUI has an extra menu item:  "Edit/Select Font".  It brings up the
standard Windows font selector.

Setting the menu height doesn't work for the Win32 GUI.

							*gui-win32-maximized*
If you want Vim to start with a maximized window, add this command to your
vimrc or gvimrc file: >
	au GUIEnter * simalt ~x
<

Using Vim as a plugin					*gui-w32-windowid*

When gvim starts up normally, it creates its own top level window.  If you
pass Vim the command-line option |--windowid| with a decimal or hexadecimal
value, Vim will create a window that is a child of the window with the given
ID.  This enables Vim to act as a plugin in another application.  This really
is a programmer's interface, and is of no use without a supporting application
to spawn Vim correctly.

==============================================================================
2. Vim as default editor				*vim-default-editor*

To set Vim as the default editor for a file type:
1. Start a Windows Explorer
2. Choose View/Options -> File Types
3. Select the path to gvim for every file type that you want to use it for.
   (you can also use three spaces in the file type field, for files without an
   extension).
   In the "open" action, use: >
	gvim "%1"
<  The quotes are required for using file names with embedded spaces.
   You can also use this: >
	gvim "%L"
<  This should avoid short (8.3 character) file names in some situations.  But
   I'm not sure if this works everywhere.

When you open a file in Vim by double clicking it, Vim changes to that
file's directory.

If you want Vim to start full-screen, use this for the Open action: >
	gvim -c "simalt ~x" "%1"

Another method, which also works when you put Vim in another directory (e.g.,
when you have got a new version):
1. select a file you want to use Vim with
2. <Shift-F10>
