            if not offset:
                return cls.utc
            name = None
        elif not isinstance(name, str):
            raise TypeError("name must be a string")
        if not cls._minoffset <= offset <= cls._maxoffset:
            raise ValueError("offset must be a timedelta "
                             "strictly between -timedelta(hours=24) and "
                             "timedelta(hours=24).")
        return cls._create(offset, name)

    @classmethod
    def _create(cls, offset, name=None):
        self = tzinfo.__new__(cls)
        self._offset = offset
        self._name = name
        return self

    def __getinitargs__(self):
        """pickle support"""
        if self._name is None:
            return (self._offset,)
        return (self._offset, self._name)

    def __eq__(self, other):
        if isinstance(other, timezone):
            return self._offset == other._offset
        return NotImplemented

    def __hash__(self):
        return hash(self._offset)

    def __repr__(self):
        """Convert to formal string, for repr().

        >>> tz = timezone.utc
        >>> repr(tz)
        'datetime.timezone.utc'
        >>> tz = timezone(timedelta(hours=-5), 'EST')
        >>> repr(tz)
        "datetime.timezone(datetime.timedelta(-1, 68400), 'EST')"
        """
        if self is self.utc:
            return 'datetime.timezone.utc'
        if self._name is None:
            return "%s.%s(%r)" % (self.__class__.__module__,
                                  self.__class__.__qualname__,
                                  self._offset)
        return "%s.%s(%r, %r)" % (self.__class__.__module__,
                                  self.__class__.__qualname__,
                                  self._offset, self._name)

    def __str__(self):
        return self.tzname(None)

    def utcoffset(self, dt):
        if isinstance(dt, datetime) or dt is None:
            return self._offset
        raise TypeError("utcoffset() argument must be a datetime instance"
                        " or None")

    def tzname(self, dt):
        if isinstance(dt, datetime) or dt is None:
            if self._name is None:
                return self._name_from_offset(self._offset)
            return self._name
        raise TypeError("tzname() argument must be a datetime instance"
                        " or None")

    def dst(self, dt):
        if isinstance(dt, datetime) or dt is None:
            return None
        raise TypeError("dst() argument must be a datetime instance"
                        " or None")

    def fromutc(self, dt):
        if isinstance(dt, datetime):
            if dt.tzinfo is not self:
                raise ValueError("fromutc: dt.tzinfo "
                                 "is not self")
            return dt + self._offset
        raise TypeError("fromutc() argument must be a datetime instance"
                        " or None")

    _maxoffset = timedelta(hours=24, microseconds=-1)
    _minoffset = -_maxoffset

    @staticmethod
    def _name_from_offset(delta):
        if not delta:
            return 'UTC'
        if delta < timedelta(0):
            sign = '-'
            delta = -delta
        else:
            sign = '+'
        hours, rest = divmod(delta, timedelta(hours=1))
        minutes, rest = divmod(rest, timedelta(minutes=1))
        seconds = rest.seconds
        microseconds = rest.microseconds
        if microseconds:
            return (f'UTC{sign}{hours:02d}:{minutes:02d}:{seconds:02d}'
                    f'.{microseconds:06d}')
        if seconds:
            return f'UTC{sign}{hours:02d}:{minutes:02d}:{seconds:02d}'
        return f'UTC{sign}{hours:02d}:{minutes:02d}'

UTC = timezone.utc = timezone._create(timedelta(0))

# bpo-37642: These attributes are rounded to the nearest minute for backwards
# compatibility, even though the constructor will accept a wider range of
# values. This may change in the future.
timezone.min = timezone._create(-timedelta(hours=23, minutes=59))
timezone.max = timezone._create(timedelta(hours=23, minutes=59))
_EPOCH = datetime(1970, 1, 1, tzinfo=timezone.utc)

# Some time zone algebra.  For a datetime x, let
#     x.n = x stripped of its timezone -- its naive time.
#     x.o = x.utcoffset(), and assuming that doesn't raise an exception or
#           return None
#     x.d = x.dst(), and assuming that doesn't raise an exception or
#           return None
#     x.s = x's standard offset, x.o - x.d
#
# Now some derived rules, where k is a duration (timedelta).
#
# 1. x.o = x.s + x.d
#    This follows from the definition of x.s.
#
# 2. If x and y have the same tzinfo member, x.s = y.s.
#    This is actually a requirement, an assumption we need to make about
#    sane tzinfo classes.
#
# 3. The naive UTC time corresponding to x is x.n - x.o.
#    This is again a requirement for a sane tzinfo class.
#
# 4. (x+k).s = x.s
#    This follows from #2, and that datetime.timetz+timedelta preserves tzinfo.
#
# 5. (x+k).n = x.n + k
#    Again follows from how arithmetic is defined.
#
# Now we can explain tz.fromutc(x).  Let's assume it's an interesting case
# (meaning that the various tzinfo methods exist, and don't blow up or return
# None when called).
#
# The function wants to return a datetime y with timezone tz, equivalent to x.
# x is already in UTC.
#
# By #3, we want
#
#     y.n - y.o = x.n                             [1]
#
# The algorithm starts by attaching tz to x.n, and calling that y.  So
# x.n = y.n at the start.  Then it wants to add a duration k to y, so that [1]
# becomes true; in effect, we want to solve [2] for k:
#
#    (y+k).n - (y+k).o = x.n                      [2]
#
# By #1, this is the same as
#
#    (y+k).n - ((y+k).s + (y+k).d) = x.n          [3]
#
# By #5, (y+k).n = y.n + k, which equals x.n + k because x.n=y.n at the start.
# Substituting that into [3],
#
#    x.n + k - (y+k).s - (y+k).d = x.n; the x.n terms cancel, leaving
#    k - (y+k).s - (y+k).d = 0; rearranging,
#    k = (y+k).s - (y+k).d; by #4, (y+k).s == y.s, so
#    k = y.s - (y+k).d
#
# On the RHS, (y+k).d can't be computed directly, but y.s can be, and we
# approximate k by ignoring the (y+k).d term at first.  Note that k can't be
# very large, since all offset-returning methods return a duration of magnitude
# less than 24 hours.  For that reason, if y is firmly in std time, (y+k).d must
# be 0, so ignoring it has no consequence then.
#
# In any case, the new value is
#
#     z = y + y.s                                 [4]
#
# It's helpful to step back at look at [4] from a higher level:  it's simply
# mapping from UTC to tz's standard time.
#
# At this point, if
#
#     z.n - z.o = x.n                             [5]
#
# we have an equivalent time, and are almost done.  The insecurity here is
# at the start of daylight time.  Picture US Eastern for concreteness.  The wall
# time jumps from 1:59 to 3:00, and wall hours of the form 2:MM don't make good
# sense then.  The docs ask that an Eastern tzinfo class consider such a time to
# be EDT (because it's "after 2"), which is a redundant spelling of 1:MM EST
# on the day DST starts.  We want to return the 1:MM EST spelling because that's
# the only spelling that makes sense on the local wall clock.
#
# In fact, if [5] holds at this point, we do have the standard-time spelling,
# but that takes a bit of proof.  We first prove a stronger result.  What's the
# difference between the LHS and RHS of [5]?  Let
#
#     diff = x.n - (z.n - z.o)                    [6]
#
# Now
#     z.n =                       by [4]
#     (y + y.s).n =               by #5
#     y.n + y.s =                 since y.n = x.n
#     x.n + y.s =                 since z and y are have the same tzinfo member,
#                                     y.s = z.s by #2
#     x.n + z.s
#
# Plugging that back into [6] gives
#
#     diff =
#     x.n - ((x.n + z.s) - z.o) =     expanding
#     x.n - x.n - z.s + z.o =         cancelling
#     - z.s + z.o =                   by #2
#     z.d
#
# So diff = z.d.
#
# If [5] is true now, diff = 0, so z.d = 0 too, and we have the standard-time
# spelling we wanted in the endcase described above.  We're done.  Contrarily,
# if z.d = 0, then we have a UTC equivalent, and are also done.
#
# If [5] is not true now, diff = z.d != 0, and z.d is the offset we need to
# add to z (in effect, z is in tz's standard time, and we need to shift the
# local clock into tz's daylight time).
#
# Let
#
#     z' = z + z.d = z + diff                     [7]
#
# and we can again ask whether
#
#     z'.n - z'.o = x.n                           [8]
#
# If so, we're done.  If not, the tzinfo class is insane, according to the
# assumptions we've made.  This also requires a bit of proof.  As before, let's
# compute the difference between the LHS and RHS of [8] (and skipping some of
# the justifications for the kinds of substitutions we've done several times
# already):
#
#     diff' = x.n - (z'.n - z'.o) =           replacing z'.n via [7]
#             x.n  - (z.n + diff - z'.o) =    replacing diff via [6]
#             x.n - (z.n + x.n - (z.n - z.o) - z'.o) =
#             x.n - z.n - x.n + z.n - z.o + z'.o =    cancel x.n
#             - z.n + z.n - z.o + z'.o =              cancel z.n
#             - z.o + z'.o =                      #1 twice
#             -z.s - z.d + z'.s + z'.d =          z and z' have same tzinfo
#             z'.d - z.d
#
# So z' is UTC-equivalent to x iff z'.d = z.d at this point.  If they are equal,
# we've found the UTC-equivalent so are done.  In fact, we stop with [7] and
# return z', not bothering to compute z'.d.
#
# How could z.d and z'd differ?  z' = z + z.d [7], so merely moving z' by
# a dst() offset, and starting *from* a time already in DST (we know z.d != 0),
# would have to change the result dst() returns:  we start in DST, and moving
# a little further into it takes us out of DST.
#
# There isn't a sane case where this can happen.  The closest it gets is at
# the end of DST, where there's an hour in UTC with no spelling in a hybrid
# tzinfo class.  In US Eastern, that's 5:MM UTC = 0:MM EST = 1:MM EDT.  During
# that hour, on an Eastern clock 1:MM is taken as being in standard time (6:MM
# UTC) because the docs insist on that, but 0:MM is taken as being in daylight
# time (4:MM UTC).  There is no local time mapping to 5:MM UTC.  The local
# clock jumps from 1:59 back to 1:00 again, and repeats the 1:MM hour in
# standard time.  Since that's what the local clock *does*, we want to map both
# UTC hours 5:MM and 6:MM to 1:MM Eastern.  The result is ambiguous
# in local time, but so it goes -- it's the way the local clock works.
#
# When x = 5:MM UTC is the input to this algorithm, x.o=0, y.o=-5 and y.d=0,
# so z=0:MM.  z.d=60 (minutes) then, so [5] doesn't hold and we keep going.
# z' = z + z.d = 1:MM then, and z'.d=0, and z'.d - z.d = -60 != 0 so [8]
# (correctly) concludes that z' is not UTC-equivalent to x.
#
# Because we know z.d said z was in daylight time (else [5] would have held and
# we would have stopped then), and we know z.d != z'.d (else [8] would have held
# and we have stopped then), and there are only 2 possible values dst() can
# return in Eastern, it follows that z'.d must be 0 (which it is in the example,
# but the reasoning doesn't depend on the example -- it depends on there being
# two possible dst() outcomes, one zero and the other non-zero).  Therefore
# z' must be in standard time, and is the spelling we want in this case.
#
# Note again that z' is not UTC-equivalent as far as the hybrid tzinfo class is
# concerned (because it takes z' as being in standard time rather than the
# daylight time we intend here), but returning it gives the real-life "local
# clock repeats an hour" behavior when mapping the "unspellable" UTC hour into
# tz.
#
# When the input is 6:MM, z=1:MM and z.d=0, and we stop at once, again with
# the 1:MM standard time spelling we want.
#
# So how can this break?  One of the assumptions must be violated.  Two
# possibilities:
#
# 1) [2] effectively says that y.s is invariant across all y belong to a given
#    time zone.  This isn't true if, for political reasons or continental drift,
#    a region decides to change its base offset from UTC.
#
# 2) There may be versions of "double daylight" time where the tail end of
#    the analysis gives up a step too early.  I haven't thought about that
#    enough to say.
#
# In any case, it's clear that the default fromutc() is strong enough to handle
# "almost all" time zones:  so long as the standard offset is invariant, it
# doesn't matter if daylight time transition points change from year to year, or
# if daylight time is skipped in some years; it doesn't matter how large or
# small dst() may get within its bounds; and it doesn't even matter if some
# perverse time zone returns a negative dst()).  So a breaking case must be
# pretty bizarre, and a tzinfo subclass can override fromutc() if it is.

try:
    from _datetime import *
except ImportError:
    pass
else:
    # Clean up unused names
    del (_DAYNAMES, _DAYS_BEFORE_MONTH, _DAYS_IN_MONTH, _DI100Y, _DI400Y,
         _DI4Y, _EPOCH, _MAXORDINAL, _MONTHNAMES, _build_struct_time,
         _check_date_fields, _check_time_fields,
         _check_tzinfo_arg, _check_tzname, _check_utc_offset, _cmp, _cmperror,
         _date_class, _days_before_month, _days_before_year, _days_in_month,
         _format_time, _format_offset, _index, _is_leap, _isoweek1monday, _math,
         _ord2ymd, _time, _time_class, _tzinfo_class, _wrap_strftime, _ymd2ord,
         _divide_and_round, _parse_isoformat_date, _parse_isoformat_time,
         _parse_hh_mm_ss_ff, _IsoCalendarDate, _isoweek_to_gregorian,
         _find_isoformat_datetime_separator, _FRACTION_CORRECTION,
         _is_ascii_digit)
    # XXX Since import * above excludes names that start with _,
    # docstring does not get overwritten. In the future, it may be
    # appropriate to maintain a single module level docstring and
    # remove the following line.
    from _datetime import __doc__
                                                                                                                                                             usr/lib/python3.11/dbm/                                                                             0000755 0000000 0000000 00000000000 14714551121 013212  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python3.11/dbm/__init__.py                                                                  0000644 0000000 0000000 00000013372 14671176116 015342  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Generic interface to all dbm clones.

Use

        import dbm
        d = dbm.open(file, 'w', 0o666)

The returned object is a dbm.gnu, dbm.ndbm or dbm.dumb object, dependent on the
type of database being opened (determined by the whichdb function) in the case
of an existing dbm. If the dbm does not exist and the create or new flag ('c'
or 'n') was specified, the dbm type will be determined by the availability of
the modules (tested in the above order).

It has the following interface (key and data are strings):

        d[key] = data   # store data at key (may override data at
                        # existing key)
        data = d[key]   # retrieve data at key (raise KeyError if no
                        # such key)
        del d[key]      # delete data stored at key (raises KeyError
                        # if no such key)
        flag = key in d # true if the key exists
        list = d.keys() # return a list of all existing keys (slow!)

Future versions may change the order in which implementations are
tested for existence, and add interfaces to other dbm-like
implementations.
"""

__all__ = ['open', 'whichdb', 'error']

import io
import os
import struct
import sys


class error(Exception):
    pass

_names = ['dbm.gnu', 'dbm.ndbm', 'dbm.dumb']
_defaultmod = None
_modules = {}

error = (error, OSError)

try:
    from dbm import ndbm
except ImportError:
    ndbm = None


def open(file, flag='r', mode=0o666):
    """Open or create database at path given by *file*.

    Optional argument *flag* can be 'r' (default) for read-only access, 'w'
    for read-write access of an existing database, 'c' for read-write access
    to a new or existing database, and 'n' for read-write access to a new
    database.

    Note: 'r' and 'w' fail if the database doesn't exist; 'c' creates it
    only if it doesn't exist; and 'n' always creates a new database.
    """
    global _defaultmod
    if _defaultmod is None:
        for name in _names:
            try:
                mod = __import__(name, fromlist=['open'])
            except ImportError:
                continue
            if not _defaultmod:
                _defaultmod = mod
            _modules[name] = mod
        if not _defaultmod:
            raise ImportError("no dbm clone found; tried %s" % _names)

    # guess the type of an existing database, if not creating a new one
    result = whichdb(file) if 'n' not in flag else None
    if result is None:
        # db doesn't exist or 'n' flag was specified to create a new db
        if 'c' in flag or 'n' in flag:
            # file doesn't exist and the new flag was used so use default type
            mod = _defaultmod
        else:
            raise error[0]("db file doesn't exist; "
                           "use 'c' or 'n' flag to create a new db")
    elif result == "":
        # db type cannot be determined
        raise error[0]("db type could not be determined")
    elif result not in _modules:
        raise error[0]("db type is {0}, but the module is not "
                       "available".format(result))
    else:
        mod = _modules[result]
    return mod.open(file, flag, mode)


def whichdb(filename):
    """Guess which db package to use to open a db file.

    Return values:

    - None if the database file can't be read;
    - empty string if the file can be read but can't be recognized
    - the name of the dbm submodule (e.g. "ndbm" or "gnu") if recognized.

    Importing the given module may still fail, and opening the
    database using that module may still fail.
    """

    # Check for ndbm first -- this has a .pag and a .dir file
    filename = os.fsencode(filename)
    try:
        f = io.open(filename + b".pag", "rb")
        f.close()
        f = io.open(filename + b".dir", "rb")
        f.close()
        return "dbm.ndbm"
    except OSError:
        # some dbm emulations based on Berkeley DB generate a .db file
        # some do not, but they should be caught by the bsd checks
        try:
            f = io.open(filename + b".db", "rb")
            f.close()
            # guarantee we can actually open the file using dbm
            # kind of overkill, but since we are dealing with emulations
            # it seems like a prudent step
            if ndbm is not None:
                d = ndbm.open(filename)
                d.close()
                return "dbm.ndbm"
        except OSError:
            pass

    # Check for dumbdbm next -- this has a .dir and a .dat file
    try:
        # First check for presence of files
        os.stat(filename + b".dat")
        size = os.stat(filename + b".dir").st_size
        # dumbdbm files with no keys are empty
        if size == 0:
            return "dbm.dumb"
        f = io.open(filename + b".dir", "rb")
        try:
            if f.read(1) in (b"'", b'"'):
                return "dbm.dumb"
        finally:
            f.close()
    except OSError:
        pass

    # See if the file exists, return None if not
    try:
        f = io.open(filename, "rb")
    except OSError:
        return None

    with f:
        # Read the start of the file -- the magic number
        s16 = f.read(16)
    s = s16[0:4]

    # Return "" if not at least 4 bytes
    if len(s) != 4:
        return ""

    # Convert to 4-byte int in native byte order -- return "" if impossible
    try:
        (magic,) = struct.unpack("=l", s)
    except struct.error:
        return ""

    # Check for GNU dbm
    if magic in (0x13579ace, 0x13579acd, 0x13579acf):
        return "dbm.gnu"

    # Later versions of Berkeley db hash file have a 12-byte pad in
    # front of the file type
    try:
        (magic,) = struct.unpack("=l", s16[-4:])
    except struct.error:
        return ""

    # Unknown
    return ""


if __name__ == "__main__":
    for filename in sys.argv[1:]:
        print(whichdb(filename) or "UNKNOWN", filename)
                                                                                                                                                                                                                                                                      usr/lib/python3.11/dbm/__pycache__/                                                                 0000755 0000000 0000000 00000000000 14714551121 015422  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python3.11/dbm/__pycache__/__init__.cpython-311.pyc                                         0000644 0000000 0000000 00000015464 14714551121 021675  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        §
    Nüäfú  ã                   ó   — d Z g d¢ZddlZddlZddlZddlZ G d„ de¦  «        Zg d¢Zda	i Z
eefZ	 ddlmZ n# e$ r dZY nw xY wdd
„Zd„ Zedk    r)ej        dd…         D ]Z e ee¦  «        pde¦  «         ŒdS dS )aN  Generic interface to all dbm clones.

Use

        import dbm
        d = dbm.open(file, 'w', 0o666)

The returned object is a dbm.gnu, dbm.ndbm or dbm.dumb object, dependent on the
type of database being opened (determined by the whichdb function) in the case
of an existing dbm. If the dbm does not exist and the create or new flag ('c'
or 'n') was specified, the dbm type will be determined by the availability of
the modules (tested in the above order).

It has the following interface (key and data are strings):

        d[key] = data   # store data at key (may override data at
                        # existing key)
        data = d[key]   # retrieve data at key (raise KeyError if no
                        # such key)
        del d[key]      # delete data stored at key (raises KeyError
                        # if no such key)
        flag = key in d # true if the key exists
        list = d.keys() # return a list of all existing keys (slow!)

Future versions may change the order in which implementations are
tested for existence, and add interfaces to other dbm-like
implementations.
)ÚopenÚwhichdbÚerroré    Nc                   ó   — e Zd ZdS )r   N)Ú__name__Ú
__module__Ú__qualname__© ó    ú#/usr/lib/python3.11/dbm/__init__.pyr   r   &   s   € € € € € Ø€Dr   r   )údbm.gnuúdbm.ndbmúdbm.dumb)ÚndbmÚré¶  c                 ó&  — t           €_t          D ]9}	 t          |dg¬¦  «        }n# t          $ r Y Œ"w xY wt           s|a |t          |<   Œ:t           st          dt          z  ¦  «        ‚d|vrt          | ¦  «        nd}|€%d|v sd|v rt           }nnt          d         d¦  «        ‚|d	k    rt          d         d
¦  «        ‚|t          vr(t          d         d                     |¦  «        ¦  «        ‚t          |         }|                     | ||¦  «        S )a¶  Open or create database at path given by *file*.

    Optional argument *flag* can be 'r' (default) for read-only access, 'w'
    for read-write access of an existing database, 'c' for read-write access
    to a new or existing database, and 'n' for read-write access to a new
    database.

    Note: 'r' and 'w' fail if the database doesn't exist; 'c' creates it
    only if it doesn't exist; and 'n' always creates a new database.
    Nr   )Úfromlistzno dbm clone found; tried %sÚnÚcr   z=db file doesn't exist; use 'c' or 'n' flag to create a new dbÚ zdb type could not be determinedz/db type is {0}, but the module is not available)	Ú_defaultmodÚ_namesÚ
__import__ÚImportErrorÚ_modulesr   r   Úformatr   )ÚfileÚflagÚmodeÚnameÚmodÚresults         r   r   r   5   sM  € õ Ğİğ 	!ğ 	!ˆDğİ  °°Ğ9Ñ9Ô9øİğ ğ ğ Øğøøøåğ "Ø!Ø HT‰NˆNİğ 	GİĞ<½vÑEÑFÔFĞFğ "¨˜o˜oWT‰]Œ]ˆ]°4€FØ€~à$ˆ;ˆ;˜# ˜+˜+åˆCˆCå˜”(ğ Dñ Eô Eğ Eà	2ŠˆåAŒhĞ8Ñ9Ô9Ğ9Ø	•xĞ	Ğ	İAŒhğ #ß#)¢6¨&¡>¤>ñ3ô 3ğ 	3õ vÔˆØ8Š8D˜$ Ñ%Ô%Ğ%s   ’%¥
2±2c                 ó.  — t          j        | ¦  «        } 	 t          j        | dz   d¦  «        }|                     ¦   «          t          j        | dz   d¦  «        }|                     ¦   «          dS # t
          $ rs 	 t          j        | dz   d¦  «        }|                     ¦   «          t          +t          j        | ¦  «        }|                     ¦   «          Y dS n# t
          $ r Y nw xY wY nw xY w	 t          j        | dz   ¦  «         t          j        | dz   ¦  «        j        }|dk    rd	S t          j        | dz   d¦  «        }	 | 	                    d
¦  «        dv r	 |                     ¦   «          d	S 	 |                     ¦   «          n# |                     ¦   «          w xY wn# t
          $ r Y nw xY w	 t          j        | d¦  «        }n# t
          $ r Y dS w xY w|5  | 	                    d¦  «        }ddd¦  «         n# 1 swxY w Y   |dd…         }t          |¦  «        dk    rdS 	 t          j        d|¦  «        \  }n# t          j        $ r Y dS w xY w|dv rdS 	 t          j        d|dd…         ¦  «        \  }n# t          j        $ r Y dS w xY wdS )au  Guess which db package to use to open a db file.

    Return values:

    - None if the database file can't be read;
    - empty string if the file can be read but can't be recognized
    - the name of the dbm submodule (e.g. "ndbm" or "gnu") if recognized.

    Importing the given module may still fail, and opening the
    database using that module may still fail.
    s   .pagÚrbs   .dirr   s   .dbNs   .datr   r   é   )ó   'ó   "é   é   r   z=l)iÎšWiÍšWiÏšWr   éüÿÿÿ)ÚosÚfsencodeÚior   ÚcloseÚOSErrorr   ÚstatÚst_sizeÚreadÚlenÚstructÚunpackr   )ÚfilenameÚfÚdÚsizeÚs16ÚsÚmagics          r   r   r   b   s0  € õ Œ{˜8Ñ$Ô$€HğİŒGH˜wÑ&¨Ñ-Ô-ˆØ	Š‰	Œ	ˆ	İŒGH˜wÑ&¨Ñ-Ô-ˆØ	Š‰	Œ	ˆ	Øˆzøİğ ğ ğ ğ	İ”˜ 6Ñ)¨4Ñ0Ô0ˆAØGŠG‰IŒIˆIõ Ğİ”I˜hÑ'Ô'Ø—’‘	”		Ø!zzğ  øõ ğ 	ğ 	ğ 	ØˆDğ	øøøøøğøøøğ"å
Œ˜7Ñ"Ñ#Ô#Ğ#İŒwx 'Ñ)Ñ*Ô*Ô2ˆà1Š9ˆ9Ø:İŒGH˜wÑ&¨Ñ-Ô-ˆğ	ØvŠva‰yŒy˜LĞ(Ğ(Ø!àGŠG‰IŒIˆIˆIˆIğ )ğ GŠG‰IŒIˆIˆIøˆAGŠG‰IŒIˆIˆIøøøˆIøİğ ğ ğ ØˆğøøøğİŒGH˜dÑ#Ô#ˆˆøİğ ğ ğ Øˆtˆtğøøøğ 
ğ ğ àfŠfR‰jŒjˆğğ ğ ñ ô ğ ğ ğ ğ ğ ğ øøøğ ğ ğ ğ ğ 	ˆAˆaˆCŒ€Aõ ˆ1v„v‚{€{Øˆrğİ”=  qÑ)Ô)‰ˆˆøİŒ<ğ ğ ğ Øˆrˆrğøøøğ Ğ4Ğ4Ğ4Øˆyğİ”=  s¨2¨3¨3¤xÑ0Ô0‰ˆˆøİŒ<ğ ğ ğ Øˆrˆrğøøøğ ˆ2sµ   –AA0 Á0
C-Á;ACÃC-Ã
C'Ã$C-Ã&C'Ã'C-Ã,C-Ã19F# Ä,F# ÅF	 ÅF# Å4F# Æ	FÆF# Æ#
F0Æ/F0Æ4G
 Ç

GÇGÇG?Ç?HÈHÈ*I ÉIÉIÉI? É?JÊJÚ__main__r&   ÚUNKNOWN)r   r   )Ú__doc__Ú__all__r.   r,   r5   ÚsysÚ	Exceptionr   r   r   r   r0   Údbmr   r   r   r   r   Úargvr7   Úprintr
   r   r   ú<module>rG      sM  ğğğ ğ: 'Ğ
&Ğ
&€à 	€	€	€	Ø 	€	€	€	Ø €€€Ø 
€
€
€
ğ	ğ 	ğ 	ğ 	ğ 	ˆIñ 	ô 	ğ 	ğ 
-Ğ	,Ğ	,€Ø€Ø€à	Ğ€ğØĞĞĞĞĞĞøØğ ğ ğ Ø€D€D€Dğøøøğ*&ğ *&ğ *&ğ *&ğZWğ Wğ Wğt ˆzÒĞØ”H˜Q˜R˜R”Lğ 8ğ 8ˆØˆˆgˆghÑÔĞ, 9¨hÑ7Ô7Ğ7Ğ7ğ Ğğ8ğ 8s   ²9 ¹AÁA                                                                                                                                                                                                            usr/lib/python3.11/dbm/__pycache__/dumb.cpython-311.pyc                                             0000644 0000000 0000000 00000034726 14714551121 021067  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        §
    NüäfJ-  ã                   ór   — d Z ddlZddlZddlZddlZddgZ	dZ
eZ G d„ dej        j        ¦  «        Zdd
„ZdS )a­  A dumb and slow but simple dbm clone.

For database spam, spam.dir contains the index (a text file),
spam.bak *may* contain a backup of the index (also a text file),
while spam.dat contains the data (a binary file).

XXX TO DO:

- seems to contain a bug when updating...

- reclaim free space (currently, space once occupied by deleted or expanded
items is never reused)

- support concurrent access (currently, if two processes take turns making
updates, they can mess up the index)

- support efficient access to large databases (currently, the whole index
is read when the database is opened, and some updates rewrite the whole index)

- support opening for read-only (flag = 'm')

é    NÚerrorÚopeni   c                   óœ   — e Zd ZeZeZdd„Zd„ Zd„ Zd„ ZeZ	d„ Z
d„ Zd„ Zd	„ Zd
„ Zd„ Zd„ Zd„ Zd„ Zd„ Zd„ ZeZd„ Zd„ ZeZd„ Zd„ Zd„ ZdS )Ú	_DatabaseÚcc                 óü   — | j                              |¦  «        }|| _        |dk    | _        |dz   | _        |dz   | _        |dz   | _        d | _        |                      |¦  «         |  	                    |¦  «         d S )NÚrs   .dirs   .dats   .bak)
Ú_osÚfsencodeÚ_modeÚ	_readonlyÚ_dirfileÚ_datfileÚ_bakfileÚ_indexÚ_createÚ_update)ÚselfÚfilebasenameÚmodeÚflags       ú/usr/lib/python3.11/dbm/dumb.pyÚ__init__z_Database.__init__0   s†   € Ø”x×(Ò(¨Ñ6Ô6ˆØˆŒ
Ø #š+ˆŒğ % wÑ.ˆŒğ % wÑ.ˆŒØ$ wÑ.ˆŒğ ˆŒğ 	ŠTÑÔĞØŠTÑÔĞĞĞó    c                 ó¸  — |dk    r<| j         | j        | j        fD ]'}	 t          j        |¦  «         Œ# t
          $ r Y Œ$w xY w	 t          j        | j         dd¬¦  «        }|                     ¦   «          d S # t
          $ rY |dvr‚ t          j        | j         dd¬¦  «        5 }|  	                    | j         ¦  «         d d d ¦  «         Y d S # 1 swxY w Y   Y d S w xY w)NÚnr	   úLatin-1©Úencoding©r   r   Úw)
r   r   r   r
   ÚremoveÚOSErrorÚ_ior   ÚcloseÚ_chmod)r   r   ÚfilenameÚfs       r   r   z_Database._createJ   sR  € Ø3Š;ˆ;Ø!œ]¨D¬M¸4¼=ĞIğ ğ ğİ”J˜xÑ(Ô(Ğ(Ğ(øİğ ğ ğ ØDğøøøğ	İ”˜œ¨°iĞ@Ñ@Ô@ˆAğ GŠG‰IŒIˆIˆIˆIøõ ğ 	+ğ 	+ğ 	+Ø˜:Ğ%Ğ%Øİ”˜$œ-¨°yĞAÑAÔAğ +ÀQØ—’˜DœMÑ*Ô*Ğ*ğ+ğ +ğ +ñ +ô +ğ +ğ +ğ +ğ +ğ +ğ +ğ +ğ +øøøğ +ğ +ğ +ğ +ğ +ğ +ğ +ğ	+øøøsD   3³
A ¿A ÁA6 Á6+CÂ!C
Â<CÃ
C	ÃCÃC	ÃCÃCc                 ól  — d| _         i | _        	 t          j        | j        dd¬¦  «        }|5  |D ]L}|                     ¦   «         }t          j        |¦  «        \  }}|                     d¦  «        }|| j        |<   ŒM	 d d d ¦  «         d S # 1 swxY w Y   d S # t          $ r |dvr‚ d| _         Y d S w xY w)NFr	   r   r   r    T)
Ú	_modifiedr   r$   r   r   ÚrstripÚ_astÚliteral_evalÚencoder#   )r   r   r(   ÚlineÚkeyÚpos_and_siz_pairs         r   r   z_Database._update]   s(  € ØˆŒØˆŒğ	8İ”˜œ¨°iĞ@Ñ@Ô@ˆAğ ğ 8ğ 8Øğ 8ğ 8DØŸ;š;™=œ=Dİ,0Ô,=¸dÑ,CÔ,CÑ)CĞ)ØŸ*š* YÑ/Ô/CØ'7D”K Ñ$Ğ$ğ	8ğ8ğ 8ğ 8ñ 8ô 8ğ 8ğ 8ğ 8ğ 8ğ 8ğ 8ğ 8øøøğ 8ğ 8ğ 8ğ 8ğ 8ğ 8øõ ğ 	"ğ 	"ğ 	"Ø˜:Ğ%Ğ%ØØ!ˆDŒNˆNˆNˆNğ	"øøøs#   B ®ABÂBÂBÂB3Â2B3c                 ó@  — | j         | j        sd S 	 | j                             | j        ¦  «         n# t
          $ r Y nw xY w	 | j                             | j        | j        ¦  «         n# t
          $ r Y nw xY w| j         	                    | j        dd¬¦  «        5 }|  
                    | j        ¦  «         | j                              ¦   «         D ]5\  }}|                     d¦  «        ›d|›d}|                     |¦  «         Œ6	 d d d ¦  «         d S # 1 swxY w Y   d S )Nr!   r   r   ú, ú
)r   r*   r
   Úunlinkr   r#   Úrenamer   r$   r   r&   ÚitemsÚdecodeÚwrite)r   r(   r0   r1   Úentrys        r   Ú_commitz_Database._commitq   s‰  € ğ Œ;Ğ d¤nĞØˆFğ	ØŒHOŠO˜DœMÑ*Ô*Ğ*Ğ*øİğ 	ğ 	ğ 	ØˆDğ	øøøğ	ØŒHOŠO˜DœM¨4¬=Ñ9Ô9Ğ9Ğ9øİğ 	ğ 	ğ 	ØˆDğ	øøøğ ŒX]Š]˜4œ=¨#¸	ˆ]ÑBÔBğ 	ÀaØKŠK˜œÑ&Ô&Ğ&Ø)-¬×):Ò):Ñ)<Ô)<ğ ğ Ñ%Ğ%ğ '*§j¢j°Ñ&;Ô&;Ğ&;Ğ&;Ğ=MĞ=MĞ=MĞNØ—’˜‘”ğ	ğ	ğ 	ğ 	ñ 	ô 	ğ 	ğ 	ğ 	ğ 	ğ 	ğ 	ğ 	øøøğ 	ğ 	ğ 	ğ 	ğ 	ğ 	s1   ’2 ²
?¾?Á%A) Á)
A6Á5A6ÂA*DÄDÄDc                 ó2   — | j         €t          d¦  «        ‚d S ©Nú"DBM object has already been closed)r   r   ©r   s    r   Ú_verify_openz_Database._verify_openŒ   s!   € ØŒ;ĞİĞ<Ñ=Ô=Ğ=ğ Ğr   c                 óZ  — t          |t          ¦  «        r|                     d¦  «        }|                      ¦   «          | j        |         \  }}t          j        | j        d¦  «        5 }|                     |¦  «         | 	                    |¦  «        }d d d ¦  «         n# 1 swxY w Y   |S )Núutf-8Úrb)
Ú
isinstanceÚstrr.   r@   r   r$   r   r   ÚseekÚread)r   r0   ÚposÚsizr(   Údats         r   Ú__getitem__z_Database.__getitem__   sÒ   € İc3ÑÔğ 	&Ø—*’*˜WÑ%Ô%ˆCØ×ÒÑÔĞØ”;˜sÔ#‰ˆˆSİŒXd”m TÑ*Ô*ğ 	¨aØFŠF3‰KŒKˆKØ—&’&˜‘+”+ˆCğ	ğ 	ğ 	ñ 	ô 	ğ 	ğ 	ğ 	ğ 	ğ 	ğ 	øøøğ 	ğ 	ğ 	ğ 	ğ ˆ
s   Á)+B Â B$Â'B$c                 ó”  — t          j        | j        d¦  «        5 }|                     dd¦  «         t	          |                     ¦   «         ¦  «        }|t          z   dz
  t          z  t          z  }|                     d||z
  z  ¦  «         |}|                     |¦  «         d d d ¦  «         n# 1 swxY w Y   |t          |¦  «        fS )Núrb+r   é   é   ó    )	r$   r   r   rF   ÚintÚtellÚ
_BLOCKSIZEr9   Úlen)r   Úvalr(   rH   Únposs        r   Ú_addvalz_Database._addval   sæ   € İŒXd”m UÑ+Ô+ğ 	¨qØFŠF1a‰LŒLˆLİa—f’f‘h”h‘-”-ˆCØ:Ñ%¨Ñ)­jÑ8½JÑFˆDØGŠGE˜4 ™8Ñ$Ñ%Ô%Ğ%ØˆCØGŠGC‰LŒLˆLğ	ğ 	ğ 	ñ 	ô 	ğ 	ğ 	ğ 	ğ 	ğ 	ğ 	øøøğ 	ğ 	ğ 	ğ 	ğ •S˜‘X”XˆĞs   ›BB.Â.B2Â5B2c                 óÜ   — t          j        | j        d¦  «        5 }|                     |¦  «         |                     |¦  «         d d d ¦  «         n# 1 swxY w Y   |t          |¦  «        fS )NrM   )r$   r   r   rF   r9   rT   )r   rH   rU   r(   s       r   Ú_setvalz_Database._setval¬   s˜   € İŒXd”m UÑ+Ô+ğ 	¨qØFŠF3‰KŒKˆKØGŠGC‰LŒLˆLğ	ğ 	ğ 	ñ 	ô 	ğ 	ğ 	ğ 	ğ 	ğ 	ğ 	øøøğ 	ğ 	ğ 	ğ 	ğ •S˜‘X”XˆĞs   ›+AÁAÁAc                 ó  — || j         |<   t          j        | j        dd¬¦  «        5 }|                      | j        ¦  «         |                     |                     d¦  «        ›d|›d¦  «         d d d ¦  «         d S # 1 swxY w Y   d S )NÚar   r   r3   r4   )r   r$   r   r   r&   r9   r8   )r   r0   r1   r(   s       r   Ú_addkeyz_Database._addkeyµ   sß   € Ø+ˆŒCÑİŒXd”m S°9Ğ=Ñ=Ô=ğ 	LÀØKŠK˜œÑ&Ô&Ğ&ØGŠG #§*¢*¨YÑ"7Ô"7Ğ"7Ğ"7Ğ9IĞ9IĞ9IĞJÑKÔKĞKğ	Lğ 	Lğ 	Lñ 	Lô 	Lğ 	Lğ 	Lğ 	Lğ 	Lğ 	Lğ 	Lğ 	Løøøğ 	Lğ 	Lğ 	Lğ 	Lğ 	Lğ 	Ls   §A	A=Á=BÂBc                 ó<  — | j         rt          d¦  «        ‚t          |t          ¦  «        r|                     d¦  «        }n+t          |t
          t          f¦  «        st          d¦  «        ‚t          |t          ¦  «        r|                     d¦  «        }n+t          |t
          t          f¦  «        st          d¦  «        ‚|                      ¦   «          d| _	        || j
        vr+|                      ||                      |¦  «        ¦  «         d S | j
        |         \  }}|t          z   dz
  t          z  }t          |¦  «        t          z   dz
  t          z  }||k    r |                      ||¦  «        | j
        |<   d S |                      |¦  «        | j
        |<   d S )Nú'The database is opened for reading onlyrB   zkeys must be bytes or stringszvalues must be bytes or stringsTrO   )r   r   rD   rE   r.   ÚbytesÚ	bytearrayÚ	TypeErrorr@   r*   r   r\   rW   rS   rT   rY   )r   r0   rU   rH   rI   Ú	oldblocksÚ	newblockss          r   Ú__setitem__z_Database.__setitem__»   s‰  € ØŒ>ğ 	CİĞAÑBÔBĞBİc3ÑÔğ 	=Ø—*’*˜WÑ%Ô%ˆCˆCİ˜C¥%­Ğ!3Ñ4Ô4ğ 	=İĞ;Ñ<Ô<Ğ<İc3ÑÔğ 	?Ø—*’*˜WÑ%Ô%ˆCˆCİ˜C¥%­Ğ!3Ñ4Ô4ğ 	?İĞ=Ñ>Ô>Ğ>Ø×ÒÑÔĞØˆŒØd”kĞ!Ğ!ØLŠL˜˜dŸlšl¨3Ñ/Ô/Ñ0Ô0Ğ0Ğ0Ğ0ğ ”{ 3Ô'‰HˆCØzÑ)¨AÑ-µ*Ñ<ˆIİ˜S™œ¥JÑ.°Ñ2µzÑAˆIØ˜IÒ%Ğ%Ø#'§<¢<°°SÑ#9Ô#9”˜CÑ Ğ Ğ ğ
 $(§<¢<°Ñ#4Ô#4”˜CÑ Ğ Ğ r   c                 óô   — | j         rt          d¦  «        ‚t          |t          ¦  «        r|                     d¦  «        }|                      ¦   «          d| _        | j        |= |                      ¦   «          d S )Nr^   rB   T)	r   r   rD   rE   r.   r@   r*   r   r;   ©r   r0   s     r   Ú__delitem__z_Database.__delitem__à   su   € ØŒ>ğ 	CİĞAÑBÔBĞBİc3ÑÔğ 	&Ø—*’*˜WÑ%Ô%ˆCØ×ÒÑÔĞØˆŒàŒK˜Ğğ
 	Š‰Œˆˆˆr   c                 óh   — 	 t          | j        ¦  «        S # t          $ r t          d¦  «        d ‚w xY wr=   )Úlistr   ra   r   r?   s    r   Úkeysz_Database.keysï   óH   € ğ	Hİ˜œÑ$Ô$Ğ$øİğ 	Hğ 	Hğ 	HİĞ<Ñ=Ô=À4ĞGğ	Høøøó   ‚ –1c                 óv   ‡ — ‰                       ¦   «          ˆ fd„‰ j                             ¦   «         D ¦   «         S )Nc                 ó$   •— g | ]}|‰|         f‘ŒS © ro   )Ú.0r0   r   s     €r   ú
<listcomp>z#_Database.items.<locals>.<listcomp>÷   s"   ø€ Ğ?Ğ?Ğ? Sd˜3”iĞ Ğ?Ğ?Ğ?r   )r@   r   rj   r?   s   `r   r7   z_Database.itemsõ   s=   ø€ Ø×ÒÑÔĞØ?Ğ?Ğ?Ğ?¨D¬K×,<Ò,<Ñ,>Ô,>Ğ?Ñ?Ô?Ğ?r   c                 ó¶   — t          |t          ¦  «        r|                     d¦  «        }	 || j        v S # t          $ r | j        €t          d¦  «        d ‚‚ w xY w)NrB   r>   )rD   rE   r.   r   ra   r   rf   s     r   Ú__contains__z_Database.__contains__ù   sn   € İc3ÑÔğ 	&Ø—*’*˜WÑ%Ô%ˆCğ	Ø˜$œ+Ğ%Ğ%øİğ 	ğ 	ğ 	ØŒ{Ğ"İĞ@ÑAÔAÀtĞKàğ		øøøs	   ¬5 µ#Ac                 óh   — 	 t          | j        ¦  «        S # t          $ r t          d¦  «        d ‚w xY wr=   )Úiterr   ra   r   r?   s    r   Úiterkeysz_Database.iterkeys  rk   rl   c                 óh   — 	 t          | j        ¦  «        S # t          $ r t          d¦  «        d ‚w xY wr=   )rT   r   ra   r   r?   s    r   Ú__len__z_Database.__len__  sH   € ğ	Hİt”{Ñ#Ô#Ğ#øİğ 	Hğ 	Hğ 	HİĞ<Ñ=Ô=À4ĞGğ	Høøørl   c                 óª   — 	 |                       ¦   «          d x| _        x| _        x| _        | _        d S # d x| _        x| _        x| _        | _        w xY w©N)r;   r   r   r   r   r?   s    r   r%   z_Database.close  s]   € ğ	OØLŠL‰NŒNˆNàJNĞNˆDŒKĞN˜$œ-ĞN¨$¬-¸$¼-¸-¸-øÈ$ĞNˆDŒKĞN˜$œ-ĞN¨$¬-¸$¼-ĞNĞNĞNĞNs	   ‚4 ´Ac                 óF   — | j                              || j        ¦  «         d S rz   )r
   Úchmodr   )r   Úfiles     r   r&   z_Database._chmod  s    € ØŒŠt˜TœZÑ(Ô(Ğ(Ğ(Ğ(r   c                 ó   — | S rz   ro   r?   s    r   Ú	__enter__z_Database.__enter__  s   € Øˆr   c                 ó.   — |                       ¦   «          d S rz   )r%   )r   Úargss     r   Ú__exit__z_Database.__exit__  s   € Ø
Š
‰Œˆˆˆr   N)r   )Ú__name__Ú
__module__Ú__qualname__r
   r$   r   r   r   r;   Úsyncr@   rK   rW   rY   r\   rd   rg   rj   r7   rs   rv   Ú__iter__rx   r%   Ú__del__r&   r   r‚   ro   r   r   r   r   #   sy  € € € € € ğ €CØ
€Cğğ ğ ğ ğ4ğ ğ ğ&8ğ 8ğ 8ğ(ğ ğ ğ2 €Dğ>ğ >ğ >ğğ ğ ğğ ğ ğğ ğ ğLğ Lğ Lğ5ğ 5ğ 5ğJğ ğ ğHğ Hğ Hğ@ğ @ğ @ğ	ğ 	ğ 	ğHğ Hğ Hğ
 €HğHğ Hğ HğOğ Oğ Oğ €Gğ)ğ )ğ )ğğ ğ ğğ ğ ğ ğ r   r   r   é¶  c                 óÌ   — 	 t          j        d¦  «        }t          j        |¦  «         || z  }n# t          $ r Y nw xY w|dvrt          d¦  «        ‚t	          | ||¬¦  «        S )aE  Open the database file, filename, and return corresponding object.

    The flag argument, used to control how the database is opened in the
    other DBM implementations, supports only the semantics of 'c' and 'n'
    values.  Other values will default to the semantics of 'c' value:
    the database will always opened for update and will be created if it
    does not exist.

    The optional mode argument is the UNIX mode of the file, used only when
    the database has to be created.  It defaults to octal code 0o666 (and
    will be modified by the prevailing umask).

    r   )r	   r!   r   r   z)Flag must be one of 'r', 'w', 'c', or 'n')r   )r
   ÚumaskÚAttributeErrorÚ
ValueErrorr   )r}   r   r   Úums       r   r   r   #  s„   € ğ İŒYq‰\Œ\ˆİŒ	"‰Œˆğ
 ˜s‰|ˆˆøõ	 ğ ğ ğ Øˆğøøøğ
 Ğ'Ğ'Ğ'İĞDÑEÔEĞEİT˜4 dĞ+Ñ+Ô+Ğ+s   ‚(1 ±
>½>)r   r‰   )Ú__doc__Úastr,   Úior$   Úosr
   Úcollections.abcÚcollectionsÚ__all__rS   r#   r   ÚabcÚMutableMappingr   r   ro   r   r   ú<module>r˜      s«   ğğğ ğ. Ğ Ğ Ğ Ø Ğ Ğ Ğ Ø Ğ Ğ Ğ Ø Ğ Ğ Ğ àFĞ
€à€
à€ğ}ğ }ğ }ğ }ğ }”Ô.ñ }ô }ğ }ğ@,ğ ,ğ ,ğ ,ğ ,ğ ,r                                             usr/lib/python3.11/dbm/__pycache__/gnu.cpython-311.pyc                                              0000644 0000000 0000000 00000000715 14714551121 020720  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        §
    Nüäfº   ã                   ó\   — d Z 	 ddlT dS # e$ rZ e ee¦  «        dz   ¦  «        ‚dZ[ww xY w)z,Provide the _gdbm module as a dbm submodule.é    )Ú*z), please install the python3-gdbm packageN)Ú__doc__Ú_gdbmÚImportErrorÚmsgÚstr© ó    ú/usr/lib/python3.11/dbm/gnu.pyú<module>r      sd   ğØ 2Ğ 2ğNØĞĞĞĞĞøØğ Nğ Nğ NØ
ˆ+cc˜#‘h”hĞ!LÑLÑ
MÔ
MĞMøøøøğNøøøs   „
 Š+&¦+                                                   usr/lib/python3.11/dbm/__pycache__/ndbm.cpython-311.pyc                                             0000644 0000000 0000000 00000000714 14714551121 021046  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        §
    Nüäf¸   ã                   ó\   — d Z 	 ddlT dS # e$ rZ e ee¦  «        dz   ¦  «        ‚dZ[ww xY w)z+Provide the _dbm module as a dbm submodule.é    )Ú*z), please install the python3-gdbm packageN)Ú__doc__Ú_dbmÚImportErrorÚmsgÚstr© ó    ú/usr/lib/python3.11/dbm/ndbm.pyú<module>r      sd   ğØ 1Ğ 1ğNØĞĞĞĞĞøØğ Nğ Nğ NØ
ˆ+cc˜#‘h”hĞ!LÑLÑ
MÔ
MĞMøøøøğNøøøs   „
 Š+&¦+                                                    usr/lib/python3.11/dbm/dumb.py                                                                      0000644 0000000 0000000 00000026512 14671176116 014532  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """A dumb and slow but simple dbm clone.

For database spam, spam.dir contains the index (a text file),
spam.bak *may* contain a backup of the index (also a text file),
while spam.dat contains the data (a binary file).

XXX TO DO:

- seems to contain a bug when updating...

- reclaim free space (currently, space once occupied by deleted or expanded
items is never reused)

- support concurrent access (currently, if two processes take turns making
updates, they can mess up the index)

- support efficient access to large databases (currently, the whole index
is read when the database is opened, and some updates rewrite the whole index)

- support opening for read-only (flag = 'm')

"""

import ast as _ast
import io as _io
import os as _os
import collections.abc

__all__ = ["error", "open"]

_BLOCKSIZE = 512

error = OSError

class _Database(collections.abc.MutableMapping):

    # The on-disk directory and data files can remain in mutually
    # inconsistent states for an arbitrarily long time (see comments
    # at the end of __setitem__).  This is only repaired when _commit()
    # gets called.  One place _commit() gets called is from __del__(),
    # and if that occurs at program shutdown time, module globals may
    # already have gotten rebound to None.  Since it's crucial that
    # _commit() finish successfully, we can't ignore shutdown races
    # here, and _commit() must not reference any globals.
    _os = _os       # for _commit()
    _io = _io       # for _commit()

    def __init__(self, filebasename, mode, flag='c'):
        filebasename = self._os.fsencode(filebasename)
        self._mode = mode
        self._readonly = (flag == 'r')

        # The directory file is a text file.  Each line looks like
        #    "%r, (%d, %d)\n" % (key, pos, siz)
        # where key is the string key, pos is the offset into the dat
        # file of the associated value's first byte, and siz is the number
        # of bytes in the associated value.
        self._dirfile = filebasename + b'.dir'

        # The data file is a binary file pointed into by the directory
        # file, and holds the values associated with keys.  Each value
        # begins at a _BLOCKSIZE-aligned byte offset, and is a raw
        # binary 8-bit string value.
        self._datfile = filebasename + b'.dat'
        self._bakfile = filebasename + b'.bak'

        # The index is an in-memory dict, mirroring the directory file.
        self._index = None  # maps keys to (pos, siz) pairs

        # Handle the creation
        self._create(flag)
        self._update(flag)

    def _create(self, flag):
        if flag == 'n':
            for filename in (self._datfile, self._bakfile, self._dirfile):
                try:
                    _os.remove(filename)
                except OSError:
                    pass
        # Mod by Jack: create data file if needed
        try:
            f = _io.open(self._datfile, 'r', encoding="Latin-1")
        except OSError:
            if flag not in ('c', 'n'):
                raise
            with _io.open(self._datfile, 'w', encoding="Latin-1") as f:
                self._chmod(self._datfile)
        else:
            f.close()

    # Read directory file into the in-memory index dict.
    def _update(self, flag):
        self._modified = False
        self._index = {}
        try:
            f = _io.open(self._dirfile, 'r', encoding="Latin-1")
        except OSError:
            if flag not in ('c', 'n'):
                raise
            self._modified = True
        else:
            with f:
                for line in f:
                    line = line.rstrip()
                    key, pos_and_siz_pair = _ast.literal_eval(line)
                    key = key.encode('Latin-1')
                    self._index[key] = pos_and_siz_pair

    # Write the index dict to the directory file.  The original directory
    # file (if any) is renamed with a .bak extension first.  If a .bak
    # file currently exists, it's deleted.
    def _commit(self):
        # CAUTION:  It's vital that _commit() succeed, and _commit() can
        # be called from __del__().  Therefore we must never reference a
        # global in this routine.
        if self._index is None or not self._modified:
            return  # nothing to do

        try:
            self._os.unlink(self._bakfile)
        except OSError:
            pass

        try:
            self._os.rename(self._dirfile, self._bakfile)
        except OSError:
            pass

        with self._io.open(self._dirfile, 'w', encoding="Latin-1") as f:
            self._chmod(self._dirfile)
            for key, pos_and_siz_pair in self._index.items():
                # Use Latin-1 since it has no qualms with any value in any
                # position; UTF-8, though, does care sometimes.
                entry = "%r, %r\n" % (key.decode('Latin-1'), pos_and_siz_pair)
                f.write(entry)

    sync = _commit

    def _verify_open(self):
        if self._index is None:
            raise error('DBM object has already been closed')

    def __getitem__(self, key):
        if isinstance(key, str):
            key = key.encode('utf-8')
        self._verify_open()
        pos, siz = self._index[key]     # may raise KeyError
        with _io.open(self._datfile, 'rb') as f:
            f.seek(pos)
            dat = f.read(siz)
        return dat

    # Append val to the data file, starting at a _BLOCKSIZE-aligned
    # offset.  The data file is first padded with NUL bytes (if needed)
    # to get to an aligned offset.  Return pair
    #     (starting offset of val, len(val))
    def _addval(self, val):
        with _io.open(self._datfile, 'rb+') as f:
            f.seek(0, 2)
            pos = int(f.tell())
            npos = ((pos + _BLOCKSIZE - 1) // _BLOCKSIZE) * _BLOCKSIZE
            f.write(b'\0'*(npos-pos))
            pos = npos
            f.write(val)
        return (pos, len(val))

    # Write val to the data file, starting at offset pos.  The caller
    # is responsible for ensuring that there's enough room starting at
    # pos to hold val, without overwriting some other value.  Return
    # pair (pos, len(val)).
    def _setval(self, pos, val):
        with _io.open(self._datfile, 'rb+') as f:
            f.seek(pos)
            f.write(val)
        return (pos, len(val))

    # key is a new key whose associated value starts in the data file
    # at offset pos and with length siz.  Add an index record to
    # the in-memory index dict, and append one to the directory file.
    def _addkey(self, key, pos_and_siz_pair):
        self._index[key] = pos_and_siz_pair
        with _io.open(self._dirfile, 'a', encoding="Latin-1") as f:
            self._chmod(self._dirfile)
            f.write("%r, %r\n" % (key.decode("Latin-1"), pos_and_siz_pair))

    def __setitem__(self, key, val):
        if self._readonly:
            raise error('The database is opened for reading only')
        if isinstance(key, str):
            key = key.encode('utf-8')
        elif not isinstance(key, (bytes, bytearray)):
            raise TypeError("keys must be bytes or strings")
        if isinstance(val, str):
            val = val.encode('utf-8')
        elif not isinstance(val, (bytes, bytearray)):
            raise TypeError("values must be bytes or strings")
        self._verify_open()
        self._modified = True
        if key not in self._index:
            self._addkey(key, self._addval(val))
        else:
            # See whether the new value is small enough to fit in the
            # (padded) space currently occupied by the old value.
            pos, siz = self._index[key]
            oldblocks = (siz + _BLOCKSIZE - 1) // _BLOCKSIZE
            newblocks = (len(val) + _BLOCKSIZE - 1) // _BLOCKSIZE
            if newblocks <= oldblocks:
                self._index[key] = self._setval(pos, val)
            else:
                # The new value doesn't fit in the (padded) space used
                # by the old value.  The blocks used by the old value are
                # forever lost.
                self._index[key] = self._addval(val)

            # Note that _index may be out of synch with the directory
            # file now:  _setval() and _addval() don't update the directory
            # file.  This also means that the on-disk directory and data
            # files are in a mutually inconsistent state, and they'll
            # remain that way until _commit() is called.  Note that this
            # is a disaster (for the database) if the program crashes
            # (so that _commit() never gets called).

    def __delitem__(self, key):
        if self._readonly:
            raise error('The database is opened for reading only')
        if isinstance(key, str):
            key = key.encode('utf-8')
        self._verify_open()
        self._modified = True
        # The blocks used by the associated value are lost.
        del self._index[key]
        # XXX It's unclear why we do a _commit() here (the code always
        # XXX has, so I'm not changing it).  __setitem__ doesn't try to
        # XXX keep the directory file in synch.  Why should we?  Or
        # XXX why shouldn't __setitem__?
        self._commit()

    def keys(self):
        try:
            return list(self._index)
        except TypeError:
            raise error('DBM object has already been closed') from None

    def items(self):
        self._verify_open()
        return [(key, self[key]) for key in self._index.keys()]

    def __contains__(self, key):
        if isinstance(key, str):
            key = key.encode('utf-8')
        try:
            return key in self._index
        except TypeError:
            if self._index is None:
                raise error('DBM object has already been closed') from None
            else:
                raise

    def iterkeys(self):
        try:
            return iter(self._index)
        except TypeError:
            raise error('DBM object has already been closed') from None
    __iter__ = iterkeys

    def __len__(self):
        try:
            return len(self._index)
        except TypeError:
            raise error('DBM object has already been closed') from None

    def close(self):
        try:
            self._commit()
        finally:
            self._index = self._datfile = self._dirfile = self._bakfile = None

    __del__ = close

    def _chmod(self, file):
        self._os.chmod(file, self._mode)

    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.close()


def open(file, flag='c', mode=0o666):
    """Open the database file, filename, and return corresponding object.

    The flag argument, used to control how the database is opened in the
    other DBM implementations, supports only the semantics of 'c' and 'n'
    values.  Other values will default to the semantics of 'c' value:
    the database will always opened for update and will be created if it
    does not exist.

    The optional mode argument is the UNIX mode of the file, used only when
    the database has to be created.  It defaults to octal code 0o666 (and
    will be modified by the prevailing umask).

    """

