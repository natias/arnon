    SV**        xobject_fields;
};

#define ObjectMAXFIELD(inst)  ((XPVOBJ *)SvANY(inst))->xobject_maxfield
#define ObjectITERSVAT(inst)  ((XPVOBJ *)SvANY(inst))->xobject_iter_sv_at
#define ObjectFIELDS(inst)    ((XPVOBJ *)SvANY(inst))->xobject_fields

/* The following macros define implementation-independent predicates on SVs. */

/*
=for apidoc Am|U32|SvNIOK|SV* sv
Returns a U32 value indicating whether the SV contains a number, integer or
double.

=for apidoc Am|U32|SvNIOKp|SV* sv
Returns a U32 value indicating whether the SV contains a number, integer or
double.  Checks the B<private> setting.  Use C<SvNIOK> instead.

=for apidoc Am|void|SvNIOK_off|SV* sv
Unsets the NV/IV status of an SV.

=for apidoc Am|U32|SvOK|SV* sv
Returns a U32 value indicating whether the value is defined.  This is
only meaningful for scalars.

=for apidoc Am|U32|SvIOKp|SV* sv
Returns a U32 value indicating whether the SV contains an integer.  Checks
the B<private> setting.  Use C<SvIOK> instead.

=for apidoc Am|U32|SvNOKp|SV* sv
Returns a U32 value indicating whether the SV contains a double.  Checks the
B<private> setting.  Use C<SvNOK> instead.

=for apidoc Am|U32|SvPOKp|SV* sv
Returns a U32 value indicating whether the SV contains a character string.
Checks the B<private> setting.  Use C<SvPOK> instead.

=for apidoc Am|U32|SvIOK|SV* sv
Returns a U32 value indicating whether the SV contains an integer.

=for apidoc Am|void|SvIOK_on|SV* sv
Tells an SV that it is an integer.

=for apidoc Am|void|SvIOK_off|SV* sv
Unsets the IV status of an SV.

=for apidoc Am|void|SvIOK_only|SV* sv
Tells an SV that it is an integer and disables all other C<OK> bits.

=for apidoc Am|void|SvIOK_only_UV|SV* sv
Tells an SV that it is an unsigned integer and disables all other C<OK> bits.

=for apidoc Am|bool|SvIOK_UV|SV* sv
Returns a boolean indicating whether the SV contains an integer that must be
interpreted as unsigned.  A non-negative integer whose value is within the
range of both an IV and a UV may be flagged as either C<SvUOK> or C<SvIOK>.

=for apidoc Am|bool|SvUOK|SV* sv
Returns a boolean indicating whether the SV contains an integer that must be
interpreted as unsigned.  A non-negative integer whose value is within the
range of both an IV and a UV may be flagged as either C<SvUOK> or C<SvIOK>.

=for apidoc Am|bool|SvIOK_notUV|SV* sv
Returns a boolean indicating whether the SV contains a signed integer.

=for apidoc Am|U32|SvNOK|SV* sv
Returns a U32 value indicating whether the SV contains a double.

=for apidoc Am|void|SvNOK_on|SV* sv
Tells an SV that it is a double.

=for apidoc Am|void|SvNOK_off|SV* sv
Unsets the NV status of an SV.

=for apidoc Am|void|SvNOK_only|SV* sv
Tells an SV that it is a double and disables all other OK bits.

=for apidoc Am|U32|SvPOK|SV* sv
Returns a U32 value indicating whether the SV contains a character
string.

=for apidoc Am|void|SvPOK_on|SV* sv
Tells an SV that it is a string.

=for apidoc Am|void|SvPOK_off|SV* sv
Unsets the PV status of an SV.

=for apidoc Am|void|SvPOK_only|SV* sv
Tells an SV that it is a string and disables all other C<OK> bits.
Will also turn off the UTF-8 status.

=for apidoc Am|U32|SvBoolFlagsOK|SV* sv
Returns a bool indicating whether the SV has the right flags set such
that it is safe to call C<BOOL_INTERNALS_sv_isbool()> or
C<BOOL_INTERNALS_sv_isbool_true()> or
C<BOOL_INTERNALS_sv_isbool_false()>. Currently equivalent to
C<SvIandPOK(sv)> or C<SvIOK(sv) && SvPOK(sv)>. Serialization may want to
unroll this check. If so you are strongly recommended to add code like
C<assert(SvBoolFlagsOK(sv));> B<before> calling using any of the
BOOL_INTERNALS macros.

=for apidoc Am|U32|SvIandPOK|SV* sv
Returns a bool indicating whether the SV is both C<SvPOK()> and
C<SvIOK()> at the same time. Equivalent to C<SvIOK(sv) && SvPOK(sv)> but
more efficient.

=for apidoc Am|void|SvIandPOK_on|SV* sv
Tells an SV that is a string and a number in one operation. Equivalent
to C<SvIOK_on(sv); SvPOK_on(sv);> but more efficient.

=for apidoc Am|void|SvIandPOK_off|SV* sv
Unsets the PV and IV status of an SV in one operation. Equivalent to
C<SvIOK_off(sv); SvPK_off(v);> but more efficient.

=for apidoc Am|bool|BOOL_INTERNALS_sv_isbool|SV* sv
Checks if a C<SvBoolFlagsOK()> sv is a bool. B<Note> that it is the
caller's responsibility to ensure that the sv is C<SvBoolFlagsOK()> before
calling this. This is only useful in specialized logic like
serialization code where performance is critical and the flags have
already been checked to be correct. Almost always you should be using
C<sv_isbool(sv)> instead.

=for apidoc Am|bool|BOOL_INTERNALS_sv_isbool_true|SV* sv
Checks if a C<SvBoolFlagsOK()> sv is a true bool. B<Note> that it is
the caller's responsibility to ensure that the sv is C<SvBoolFlagsOK()>
before calling this. This is only useful in specialized logic like
serialization code where performance is critical and the flags have
already been checked to be correct. This is B<NOT> what you should use
to check if an SV is "true", for that you should be using
C<SvTRUE(sv)> instead.

=for apidoc Am|bool|BOOL_INTERNALS_sv_isbool_false|SV* sv
Checks if a C<SvBoolFlagsOK()> sv is a false bool. B<Note> that it is
the caller's responsibility to ensure that the sv is C<SvBoolFlagsOK()>
before calling this. This is only useful in specialized logic like
serialization code where performance is critical and the flags have
already been checked to be correct. This is B<NOT> what you should use
to check if an SV is "false", for that you should be using
C<!SvTRUE(sv)> instead.

=for apidoc Am|bool|SvVOK|SV* sv
Returns a boolean indicating whether the SV contains a v-string.

=for apidoc Am|U32|SvOOK|SV* sv
Returns a U32 indicating whether the pointer to the string buffer is offset.
This hack is used internally to speed up removal of characters from the
beginning of a C<L</SvPV>>.  When C<SvOOK> is true, then the start of the
allocated string buffer is actually C<SvOOK_offset()> bytes before C<SvPVX>.
This offset used to be stored in C<SvIVX>, but is now stored within the spare
part of the buffer.

=for apidoc Am|U32|SvROK|SV* sv
Tests if the SV is an RV.

=for apidoc Am|void|SvROK_on|SV* sv
Tells an SV that it is an RV.

=for apidoc Am|void|SvROK_off|SV* sv
Unsets the RV status of an SV.

=for apidoc Am|SV*|SvRV|SV* sv
Dereferences an RV to return the SV.

=for apidoc Am|IV|SvIVX|SV* sv
Returns the raw value in the SV's IV slot, without checks or conversions.
Only use when you are sure C<SvIOK> is true.  See also C<L</SvIV>>.

=for apidoc Am|UV|SvUVX|SV* sv
Returns the raw value in the SV's UV slot, without checks or conversions.
Only use when you are sure C<SvIOK> is true.  See also C<L</SvUV>>.

=for apidoc AmD|UV|SvUVXx|SV* sv
This is an unnecessary synonym for L</SvUVX>

=for apidoc Am|NV|SvNVX|SV* sv
Returns the raw value in the SV's NV slot, without checks or conversions.
Only use when you are sure C<SvNOK> is true.  See also C<L</SvNV>>.

=for apidoc Am   |char*      |SvPVX|SV* sv
=for apidoc_item |const char*|SvPVX_const|SV* sv
=for apidoc_item |char*      |SvPVX_mutable|SV* sv
=for apidoc_item |char*      |SvPVXx|SV* sv

These return a pointer to the physical string in the SV.  The SV must contain a
string.  Prior to 5.9.3 it is not safe to execute these unless the SV's
type >= C<SVt_PV>.

These are also used to store the name of an autoloaded subroutine in an XS
AUTOLOAD routine.  See L<perlguts/Autoloading with XSUBs>.

C<SvPVXx> is identical to C<SvPVX>.

C<SvPVX_mutable> is merely a synonym for C<SvPVX>, but its name emphasizes that
the string is modifiable by the caller.

C<SvPVX_const> differs in that the return value has been cast so that the
compiler will complain if you were to try to modify the contents of the string,
(unless you cast away const yourself).

=for apidoc Am|STRLEN|SvCUR|SV* sv
Returns the length, in bytes, of the PV inside the SV.
Note that this may not match Perl's C<length>; for that, use
C<sv_len_utf8(sv)>. See C<L</SvLEN>> also.

=for apidoc Am|STRLEN|SvLEN|SV* sv
Returns the size of the string buffer in the SV, not including any part
attributable to C<SvOOK>.  See C<L</SvCUR>>.

=for apidoc Am|char*|SvEND|SV* sv
Returns a pointer to the spot just after the last character in
the string which is in the SV, where there is usually a trailing
C<NUL> character (even though Perl scalars do not strictly require it).
See C<L</SvCUR>>.  Access the character as C<*(SvEND(sv))>.

Warning: If C<SvCUR> is equal to C<SvLEN>, then C<SvEND> points to
unallocated memory.

=for apidoc Am|HV*|SvSTASH|SV* sv
Returns the stash of the SV.

=for apidoc Am|void|SvIV_set|SV* sv|IV val
Set the value of the IV pointer in sv to val.  It is possible to perform
the same function of this macro with an lvalue assignment to C<SvIVX>.
With future Perls, however, it will be more efficient to use
C<SvIV_set> instead of the lvalue assignment to C<SvIVX>.

=for apidoc Am|void|SvNV_set|SV* sv|NV val
Set the value of the NV pointer in C<sv> to val.  See C<L</SvIV_set>>.

=for apidoc Am|void|SvPV_set|SV* sv|char* val
This is probably not what you want to use, you probably wanted
L</sv_usepvn_flags> or L</sv_setpvn> or L</sv_setpvs>.

Set the value of the PV pointer in C<sv> to the Perl allocated
C<NUL>-terminated string C<val>.  See also C<L</SvIV_set>>.

Remember to free the previous PV buffer. There are many things to check.
Beware that the existing pointer may be involved in copy-on-write or other
mischief, so do C<SvOOK_off(sv)> and use C<sv_force_normal> or
C<SvPV_force> (or check the C<SvIsCOW> flag) first to make sure this
modification is safe. Then finally, if it is not a COW, call
C<L</SvPV_free>> to free the previous PV buffer.

=for apidoc Am|void|SvUV_set|SV* sv|UV val
Set the value of the UV pointer in C<sv> to val.  See C<L</SvIV_set>>.

=for apidoc Am|void|SvRV_set|SV* sv|SV* val
Set the value of the RV pointer in C<sv> to val.  See C<L</SvIV_set>>.

=for apidoc Am|void|SvMAGIC_set|SV* sv|MAGIC* val
Set the value of the MAGIC pointer in C<sv> to val.  See C<L</SvIV_set>>.

=for apidoc Am|void|SvSTASH_set|SV* sv|HV* val
Set the value of the STASH pointer in C<sv> to val.  See C<L</SvIV_set>>.

=for apidoc Am|void|SvCUR_set|SV* sv|STRLEN len
Sets the current length, in bytes, of the C string which is in the SV.
See C<L</SvCUR>> and C<SvIV_set>>.

=for apidoc Am|void|SvLEN_set|SV* sv|STRLEN len
Set the size of the string buffer for the SV. See C<L</SvLEN>>.

=cut
*/

#define SvNIOK(sv)		(SvFLAGS(sv) & (SVf_IOK|SVf_NOK))
#define SvNIOKp(sv)		(SvFLAGS(sv) & (SVp_IOK|SVp_NOK))
#define SvNIOK_off(sv)		(SvFLAGS(sv) &= ~(SVf_IOK|SVf_NOK| \
                                                  SVp_IOK|SVp_NOK|SVf_IVisUV))

#define assert_not_ROK(sv)	assert_(!SvROK(sv) || !SvRV(sv))
#define assert_not_glob(sv)	assert_(!isGV_with_GP(sv))

#define SvOK(sv)		(SvFLAGS(sv) & SVf_OK)
#define SvOK_off(sv)		(assert_not_ROK(sv) assert_not_glob(sv)	\
                                 SvFLAGS(sv) &=	~(SVf_OK|		\
                                                  SVf_IVisUV|SVf_UTF8),	\
                                                        SvOOK_off(sv))
#define SvOK_off_exc_UV(sv)	(assert_not_ROK(sv)			\
                                 SvFLAGS(sv) &=	~(SVf_OK|		\
                                                  SVf_UTF8),		\
                                                        SvOOK_off(sv))

#define SvOKp(sv)		(SvFLAGS(sv) & (SVp_IOK|SVp_NOK|SVp_POK))
#define SvIOKp(sv)		(SvFLAGS(sv) & SVp_IOK)
#define SvIOKp_on(sv)		(assert_not_glob(sv)	\
                                    SvFLAGS(sv) |= SVp_IOK)
#define SvNOKp(sv)		(SvFLAGS(sv) & SVp_NOK)
#define SvNOKp_on(sv)		(assert_not_glob(sv) SvFLAGS(sv) |= SVp_NOK)
#define SvPOKp(sv)		(SvFLAGS(sv) & SVp_POK)
#define SvPOKp_on(sv)		(assert_not_ROK(sv) assert_not_glob(sv)	\
                                 SvFLAGS(sv) |= SVp_POK)

#define SvIOK(sv)		(SvFLAGS(sv) & SVf_IOK)
#define SvIOK_on(sv)		(assert_not_glob(sv)	\
                                    SvFLAGS(sv) |= (SVf_IOK|SVp_IOK))
#define SvIOK_off(sv)		(SvFLAGS(sv) &= ~(SVf_IOK|SVp_IOK|SVf_IVisUV))
#define SvIOK_only(sv)		(SvOK_off(sv), \
                                    SvFLAGS(sv) |= (SVf_IOK|SVp_IOK))
#define SvIOK_only_UV(sv)	(assert_not_glob(sv) SvOK_off_exc_UV(sv), \
                                    SvFLAGS(sv) |= (SVf_IOK|SVp_IOK))

#define SvIOK_UV(sv)		((SvFLAGS(sv) & (SVf_IOK|SVf_IVisUV))	\
                                 == (SVf_IOK|SVf_IVisUV))
#define SvUOK(sv)		SvIOK_UV(sv)
#define SvIOK_notUV(sv)		((SvFLAGS(sv) & (SVf_IOK|SVf_IVisUV))	\
                                 == SVf_IOK)

#define SvIandPOK(sv)              ((SvFLAGS(sv) & (SVf_IOK|SVf_POK)) == (SVf_IOK|SVf_POK))
#define SvIandPOK_on(sv)           (assert_not_glob(sv) \
                                    (SvFLAGS(sv) |= (SVf_IOK|SVp_IOK|SVf_POK|SVp_POK)))
#define SvIandPOK_off(sv)          (SvFLAGS(sv) &= ~(SVf_IOK|SVp_IOK|SVf_IVisUV|SVf_POK|SVp_POK))

#define SvBoolFlagsOK(sv)           SvIandPOK(sv)

#define BOOL_INTERNALS_sv_isbool(sv)      (SvIsCOW_static(sv) && \
        (SvPVX_const(sv) == PL_Yes || SvPVX_const(sv) == PL_No))
#define BOOL_INTERNALS_sv_isbool_true(sv)      (SvIsCOW_static(sv) && \
        (SvPVX_const(sv) == PL_Yes))
#define BOOL_INTERNALS_sv_isbool_false(sv)      (SvIsCOW_static(sv) && \
        (SvPVX_const(sv) == PL_No))

#define SvIsUV(sv)		(SvFLAGS(sv) & SVf_IVisUV)
#define SvIsUV_on(sv)		(SvFLAGS(sv) |= SVf_IVisUV)
#define SvIsUV_off(sv)		(SvFLAGS(sv) &= ~SVf_IVisUV)

#define SvNOK(sv)		(SvFLAGS(sv) & SVf_NOK)
#define SvNOK_on(sv)		(assert_not_glob(sv) \
                                 SvFLAGS(sv) |= (SVf_NOK|SVp_NOK))
#define SvNOK_off(sv)		(SvFLAGS(sv) &= ~(SVf_NOK|SVp_NOK))
#define SvNOK_only(sv)		(SvOK_off(sv), \
                                    SvFLAGS(sv) |= (SVf_NOK|SVp_NOK))

/*
=for apidoc Am|U32|SvUTF8|SV* sv
Returns a U32 value indicating the UTF-8 status of an SV.  If things are set-up
properly, this indicates whether or not the SV contains UTF-8 encoded data.
You should use this I<after> a call to C<L</SvPV>> or one of its variants, in
case any call to string overloading updates the internal flag.

If you want to take into account the L<bytes> pragma, use C<L</DO_UTF8>>
instead.

=for apidoc Am|void|SvUTF8_on|SV *sv
Turn on the UTF-8 status of an SV (the data is not changed, just the flag).
Do not use frivolously.

=for apidoc Am|void|SvUTF8_off|SV *sv
Unsets the UTF-8 status of an SV (the data is not changed, just the flag).
Do not use frivolously.

=for apidoc Am|void|SvPOK_only_UTF8|SV* sv
Tells an SV that it is a string and disables all other C<OK> bits,
and leaves the UTF-8 status as it was.

=cut
 */

/* Ensure the return value of this macro does not clash with the GV_ADD* flags
in gv.h: */
#define SvUTF8(sv)		(SvFLAGS(sv) & SVf_UTF8)
#define SvUTF8_on(sv)		(SvFLAGS(sv) |= (SVf_UTF8))
#define SvUTF8_off(sv)		(SvFLAGS(sv) &= ~(SVf_UTF8))

#define SvPOK(sv)		(SvFLAGS(sv) & SVf_POK)
#define SvPOK_on(sv)		(assert_not_ROK(sv) assert_not_glob(sv)	\
                                 SvFLAGS(sv) |= (SVf_POK|SVp_POK))
#define SvPOK_off(sv)		(SvFLAGS(sv) &= ~(SVf_POK|SVp_POK))
#define SvPOK_only(sv)		(assert_not_ROK(sv) assert_not_glob(sv)	\
                                 SvFLAGS(sv) &= ~(SVf_OK|		\
                                                  SVf_IVisUV|SVf_UTF8),	\
                                    SvFLAGS(sv) |= (SVf_POK|SVp_POK))
#define SvPOK_only_UTF8(sv)	(assert_not_ROK(sv) assert_not_glob(sv)	\
                                 SvFLAGS(sv) &= ~(SVf_OK|		\
                                                  SVf_IVisUV),		\
                                    SvFLAGS(sv) |= (SVf_POK|SVp_POK))

#define SvVOK(sv)		(SvMAGICAL(sv)				\
                                 && mg_find(sv,PERL_MAGIC_vstring))
/*
=for apidoc Am|MAGIC*|SvVSTRING_mg|SV * sv

Returns the vstring magic, or NULL if none

=cut
*/
#define SvVSTRING_mg(sv)	(SvMAGICAL(sv) \
                                 ? mg_find(sv,PERL_MAGIC_vstring) : NULL)

#define SvOOK(sv)		(SvFLAGS(sv) & SVf_OOK)
#define SvOOK_on(sv)		(SvFLAGS(sv) |= SVf_OOK)


/*
=for apidoc Am|void|SvOOK_off|SV * sv

Remove any string offset.

=cut
*/

#define SvOOK_off(sv)		((void)(SvOOK(sv) && (sv_backoff(sv),0)))

#define SvFAKE(sv)		(SvFLAGS(sv) & SVf_FAKE)
#define SvFAKE_on(sv)		(SvFLAGS(sv) |= SVf_FAKE)
#define SvFAKE_off(sv)		(SvFLAGS(sv) &= ~SVf_FAKE)

#define SvROK(sv)		(SvFLAGS(sv) & SVf_ROK)
#define SvROK_on(sv)		(SvFLAGS(sv) |= SVf_ROK)
#define SvROK_off(sv)		(SvFLAGS(sv) &= ~(SVf_ROK))

#define SvMAGICAL(sv)		(SvFLAGS(sv) & (SVs_GMG|SVs_SMG|SVs_RMG))
#define SvMAGICAL_on(sv)	(SvFLAGS(sv) |= (SVs_GMG|SVs_SMG|SVs_RMG))
#define SvMAGICAL_off(sv)	(SvFLAGS(sv) &= ~(SVs_GMG|SVs_SMG|SVs_RMG))

#define SvGMAGICAL(sv)		(SvFLAGS(sv) & SVs_GMG)
#define SvGMAGICAL_on(sv)	(SvFLAGS(sv) |= SVs_GMG)
#define SvGMAGICAL_off(sv)	(SvFLAGS(sv) &= ~SVs_GMG)

#define SvSMAGICAL(sv)		(SvFLAGS(sv) & SVs_SMG)
#define SvSMAGICAL_on(sv)	(SvFLAGS(sv) |= SVs_SMG)
#define SvSMAGICAL_off(sv)	(SvFLAGS(sv) &= ~SVs_SMG)

#define SvRMAGICAL(sv)		(SvFLAGS(sv) & SVs_RMG)
#define SvRMAGICAL_on(sv)	(SvFLAGS(sv) |= SVs_RMG)
#define SvRMAGICAL_off(sv)	(SvFLAGS(sv) &= ~SVs_RMG)

/*
=for apidoc Am|bool|SvAMAGIC|SV * sv

Returns a boolean as to whether C<sv> has overloading (active magic) enabled or
not.

=cut
*/

#define SvAMAGIC(sv)		(SvROK(sv) && SvOBJECT(SvRV(sv)) &&	\
                                 HvAMAGIC(SvSTASH(SvRV(sv))))

/* To be used on the stashes themselves: */
#define HvAMAGIC(hv)		(SvFLAGS(hv) & SVf_AMAGIC)
#define HvAMAGIC_on(hv)		(SvFLAGS(hv) |= SVf_AMAGIC)
#define HvAMAGIC_off(hv)	(SvFLAGS(hv) &=~ SVf_AMAGIC)


/* "nog" means "doesn't have get magic" */
#define SvPOK_nog(sv)		((SvFLAGS(sv) & (SVf_POK|SVs_GMG)) == SVf_POK)
#define SvIOK_nog(sv)		((SvFLAGS(sv) & (SVf_IOK|SVs_GMG)) == SVf_IOK)
#define SvUOK_nog(sv)		((SvFLAGS(sv) & (SVf_IOK|SVf_IVisUV|SVs_GMG)) == (SVf_IOK|SVf_IVisUV))
#define SvNOK_nog(sv)		((SvFLAGS(sv) & (SVf_NOK|SVs_GMG)) == SVf_NOK)
#define SvNIOK_nog(sv)		(SvNIOK(sv) && !(SvFLAGS(sv) & SVs_GMG))

#define SvPOK_nogthink(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_THINKFIRST|SVs_GMG)) == SVf_POK)
#define SvIOK_nogthink(sv)	((SvFLAGS(sv) & (SVf_IOK|SVf_THINKFIRST|SVs_GMG)) == SVf_IOK)
#define SvUOK_nogthink(sv)	((SvFLAGS(sv) & (SVf_IOK|SVf_IVisUV|SVf_THINKFIRST|SVs_GMG)) == (SVf_IOK|SVf_IVisUV))
#define SvNOK_nogthink(sv)	((SvFLAGS(sv) & (SVf_NOK|SVf_THINKFIRST|SVs_GMG)) == SVf_NOK)
#define SvNIOK_nogthink(sv)	(SvNIOK(sv) && !(SvFLAGS(sv) & (SVf_THINKFIRST|SVs_GMG)))

#define SvPOK_utf8_nog(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVs_GMG)) == (SVf_POK|SVf_UTF8))
#define SvPOK_utf8_nogthink(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_THINKFIRST|SVs_GMG)) == (SVf_POK|SVf_UTF8))

#define SvPOK_byte_nog(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVs_GMG)) == SVf_POK)
#define SvPOK_byte_nogthink(sv)	((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_THINKFIRST|SVs_GMG)) == SVf_POK)

#define SvPOK_pure_nogthink(sv) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_IOK|SVf_NOK|SVf_ROK|SVpgv_GP|SVf_THINKFIRST|SVs_GMG)) == SVf_POK)
#define SvPOK_utf8_pure_nogthink(sv) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_IOK|SVf_NOK|SVf_ROK|SVpgv_GP|SVf_THINKFIRST|SVs_GMG)) == (SVf_POK|SVf_UTF8))
#define SvPOK_byte_pure_nogthink(sv) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_IOK|SVf_NOK|SVf_ROK|SVpgv_GP|SVf_THINKFIRST|SVs_GMG)) == SVf_POK)

/*
=for apidoc Am|bool|SvIsBOOL|SV* sv

Returns true if the SV is one of the special boolean constants (PL_sv_yes or
PL_sv_no), or is a regular SV whose last assignment stored a copy of one.

=cut
*/

#define SvIsBOOL(sv)            Perl_sv_isbool(aTHX_ sv)

/*
=for apidoc Am|U32|SvGAMAGIC|SV* sv

Returns true if the SV has get magic or
overloading.  If either is true then
the scalar is active data, and has the potential to return a new value every
time it is accessed.  Hence you must be careful to
only read it once per user logical operation and work
with that returned value.  If neither is true then
the scalar's value cannot change unless written to.

=cut
*/

#define SvGAMAGIC(sv)           (SvGMAGICAL(sv) || SvAMAGIC(sv))

#define Gv_AMG(stash) \
        (HvNAME(stash) && Gv_AMupdate(stash,FALSE) \
            ? 1					    \
            : (HvAMAGIC_off(stash), 0))

#define SvWEAKREF(sv)		((SvFLAGS(sv) & (SVf_ROK|SVprv_WEAKREF)) \
                                  == (SVf_ROK|SVprv_WEAKREF))
#define SvWEAKREF_on(sv)	(SvFLAGS(sv) |=  (SVf_ROK|SVprv_WEAKREF))
#define SvWEAKREF_off(sv)	(SvFLAGS(sv) &= ~(SVf_ROK|SVprv_WEAKREF))

#define SvPCS_IMPORTED(sv)	((SvFLAGS(sv) & (SVf_ROK|SVprv_PCS_IMPORTED)) \
                                 == (SVf_ROK|SVprv_PCS_IMPORTED))
#define SvPCS_IMPORTED_on(sv)	(SvFLAGS(sv) |=  (SVf_ROK|SVprv_PCS_IMPORTED))
#define SvPCS_IMPORTED_off(sv)	(SvFLAGS(sv) &= ~(SVf_ROK|SVprv_PCS_IMPORTED))

/*
=for apidoc m|U32|SvTHINKFIRST|SV *sv

A quick flag check to see whether an C<sv> should be passed to C<sv_force_normal>
to be "downgraded" before C<SvIVX> or C<SvPVX> can be modified directly.

For example, if your scalar is a reference and you want to modify the C<SvIVX>
slot, you can't just do C<SvROK_off>, as that will leak the referent.

This is used internally by various sv-modifying functions, such as
C<sv_setsv>, C<sv_setiv> and C<sv_pvn_force>.

One case that this does not handle is a gv without SvFAKE set.  After

    if (SvTHINKFIRST(gv)) sv_force_normal(gv);

it will still be a gv.

C<SvTHINKFIRST> sometimes produces false positives.  In those cases
C<sv_force_normal> does nothing.

=cut
*/

#define SvTHINKFIRST(sv)	(SvFLAGS(sv) & SVf_THINKFIRST)

#define SVs_PADMY		0
#define SvPADMY(sv)		(!(SvFLAGS(sv) & SVs_PADTMP))
#ifndef PERL_CORE
# define SvPADMY_on(sv)		SvPADTMP_off(sv)
#endif

#define SvPADTMP(sv)		(SvFLAGS(sv) & (SVs_PADTMP))
#define SvPADSTALE(sv)		(SvFLAGS(sv) & (SVs_PADSTALE))

#define SvPADTMP_on(sv)		(SvFLAGS(sv) |= SVs_PADTMP)
#define SvPADTMP_off(sv)	(SvFLAGS(sv) &= ~SVs_PADTMP)
#define SvPADSTALE_on(sv)	Perl_SvPADSTALE_on(MUTABLE_SV(sv))
#define SvPADSTALE_off(sv)	Perl_SvPADSTALE_off(MUTABLE_SV(sv))

#define SvTEMP(sv)		(SvFLAGS(sv) & SVs_TEMP)
#define SvTEMP_on(sv)		(SvFLAGS(sv) |= SVs_TEMP)
#define SvTEMP_off(sv)		(SvFLAGS(sv) &= ~SVs_TEMP)

#define SvOBJECT(sv)		(SvFLAGS(sv) & SVs_OBJECT)
#define SvOBJECT_on(sv)		(SvFLAGS(sv) |= SVs_OBJECT)
#define SvOBJECT_off(sv)	(SvFLAGS(sv) &= ~SVs_OBJECT)

/*
=for apidoc Am|U32|SvREADONLY|SV* sv
Returns true if the argument is readonly, otherwise returns false.
Exposed to perl code via Internals::SvREADONLY().

=for apidoc Am|U32|SvREADONLY_on|SV* sv
Mark an object as readonly. Exactly what this means depends on the object
type. Exposed to perl code via Internals::SvREADONLY().

=for apidoc Am|U32|SvREADONLY_off|SV* sv
Mark an object as not-readonly. Exactly what this mean depends on the
object type. Exposed to perl code via Internals::SvREADONLY().

=cut
*/

#define SvREADONLY(sv)		(SvFLAGS(sv) & (SVf_READONLY|SVf_PROTECT))
#ifdef PERL_CORE
# define SvREADONLY_on(sv)	(SvFLAGS(sv) |= (SVf_READONLY|SVf_PROTECT))
# define SvREADONLY_off(sv)	(SvFLAGS(sv) &=~(SVf_READONLY|SVf_PROTECT))
#else
# define SvREADONLY_on(sv)	(SvFLAGS(sv) |= SVf_READONLY)
# define SvREADONLY_off(sv)	(SvFLAGS(sv) &= ~SVf_READONLY)
#endif

#define SvSCREAM(sv) ((SvFLAGS(sv) & (SVp_SCREAM|SVp_POK)) == (SVp_SCREAM|SVp_POK))
#define SvSCREAM_on(sv)		(SvFLAGS(sv) |= SVp_SCREAM)
#define SvSCREAM_off(sv)	(SvFLAGS(sv) &= ~SVp_SCREAM)

#ifndef PERL_CORE
#  define SvCOMPILED(sv)	0
#  define SvCOMPILED_on(sv)
#  define SvCOMPILED_off(sv)
#endif


#if defined (DEBUGGING) && defined(PERL_USE_GCC_BRACE_GROUPS)
#  define SvTAIL(sv)	({ const SV *const _svtail = (const SV *)(sv);	\
                            assert(SvTYPE(_svtail) != SVt_PVAV);	\
                            assert(SvTYPE(_svtail) != SVt_PVHV);	\
                            assert(!(SvFLAGS(_svtail) & (SVf_NOK|SVp_NOK))); \
                            assert(SvVALID(_svtail));                        \
                            ((XPVNV*)SvANY(_svtail))->xnv_u.xnv_bm_tail;     \
                        })
#else
#  define SvTAIL(_svtail)  (((XPVNV*)SvANY(_svtail))->xnv_u.xnv_bm_tail)
#endif

/* Does the SV have a Boyer-Moore table attached as magic?
 * 'VALID' is a poor name, but is kept for historical reasons.  */
#define SvVALID(_svvalid) (                                  \
               SvPOKp(_svvalid)                              \
            && SvSMAGICAL(_svvalid)                          \
            && SvMAGIC(_svvalid)                             \
            && (SvMAGIC(_svvalid)->mg_type == PERL_MAGIC_bm  \
                || mg_find(_svvalid, PERL_MAGIC_bm))         \
        )

#define SvRVx(sv) SvRV(sv)

#ifdef PERL_DEBUG_COW
/* Need -0.0 for SvNVX to preserve IEEE FP "negative zero" because
   +0.0 + -0.0 => +0.0 but -0.0 + -0.0 => -0.0 */
#  define SvIVX(sv) (0 + ((XPVIV*) SvANY(sv))->xiv_iv)
#  define SvUVX(sv) (0 + ((XPVUV*) SvANY(sv))->xuv_uv)
#  define SvNVX(sv) (-0.0 + ((XPVNV*) SvANY(sv))->xnv_u.xnv_nv)
#  define SvRV(sv) (0 + (sv)->sv_u.svu_rv)
#  define SvRV_const(sv) (0 + (sv)->sv_u.svu_rv)
/* Don't test the core XS code yet.  */
#  if defined (PERL_CORE) && PERL_DEBUG_COW > 1
#    define SvPVX(sv) (0 + (assert_(!SvREADONLY(sv)) (sv)->sv_u.svu_pv))
#  else
#  define SvPVX(sv) SvPVX_mutable(sv)
#  endif
#  define SvCUR(sv) (0 + ((XPV*) SvANY(sv))->xpv_cur)
#  define SvLEN(sv) (0 + ((XPV*) SvANY(sv))->xpv_len)
#  define SvEND(sv) ((sv)->sv_u.svu_pv + ((XPV*)SvANY(sv))->xpv_cur)

#  define SvMAGIC(sv)	(0 + *(assert_(SvTYPE(sv) >= SVt_PVMG) &((XPVMG*)  SvANY(sv))->xmg_u.xmg_magic))
#  define SvSTASH(sv)	(0 + *(assert_(SvTYPE(sv) >= SVt_PVMG) &((XPVMG*)  SvANY(sv))->xmg_stash))
#else   /* Below is not PERL_DEBUG_COW */
# ifdef PERL_CORE
#  define SvLEN(sv) (0 + ((XPV*) SvANY(sv))->xpv_len)
# else
#  define SvLEN(sv) ((XPV*) SvANY(sv))->xpv_len
# endif
#  define SvEND(sv) ((sv)->sv_u.svu_pv + ((XPV*)SvANY(sv))->xpv_cur)

#  if defined (DEBUGGING) && defined(PERL_USE_GCC_BRACE_GROUPS)
/* These get expanded inside other macros that already use a variable _sv  */
#    define SvPVX(sv)							\
        (*({ SV *const _svpvx = MUTABLE_SV(sv);				\
            assert(PL_valid_types_PVX[SvTYPE(_svpvx) & SVt_MASK]);	\
            assert(!isGV_with_GP(_svpvx));				\
            assert(!(SvTYPE(_svpvx) == SVt_PVIO				\
                     && !(IoFLAGS(_svpvx) & IOf_FAKE_DIRP)));		\
            &((_svpvx)->sv_u.svu_pv);					\
         }))
#   ifdef PERL_CORE
#    define SvCUR(sv)							\
        ({ const SV *const _svcur = (const SV *)(sv);			\
            assert(PL_valid_types_PVX[SvTYPE(_svcur) & SVt_MASK]);	\
            assert(!isGV_with_GP(_svcur));				\
            assert(!(SvTYPE(_svcur) == SVt_PVIO				\
                     && !(IoFLAGS(_svcur) & IOf_FAKE_DIRP)));		\
            (((XPV*) MUTABLE_PTR(SvANY(_svcur)))->xpv_cur);		\
         })
#   else
#    define SvCUR(sv)							\
        (*({ const SV *const _svcur = (const SV *)(sv);			\
            assert(PL_valid_types_PVX[SvTYPE(_svcur) & SVt_MASK]);	\
            assert(!isGV_with_GP(_svcur));				\
            assert(!(SvTYPE(_svcur) == SVt_PVIO				\
                     && !(IoFLAGS(_svcur) & IOf_FAKE_DIRP)));		\
            &(((XPV*) MUTABLE_PTR(SvANY(_svcur)))->xpv_cur);		\
         }))
#   endif
#    define SvIVX(sv)							\
        (*({ const SV *const _svivx = (const SV *)(sv);			\
            assert(PL_valid_types_IVX[SvTYPE(_svivx) & SVt_MASK]);	\
            assert(!isGV_with_GP(_svivx));				\
            &(((XPVIV*) MUTABLE_PTR(SvANY(_svivx)))->xiv_iv);		\
         }))
#    define SvUVX(sv)							\
        (*({ const SV *const _svuvx = (const SV *)(sv);			\
            assert(PL_valid_types_IVX[SvTYPE(_svuvx) & SVt_MASK]);	\
            assert(!isGV_with_GP(_svuvx));				\
            &(((XPVUV*) MUTABLE_PTR(SvANY(_svuvx)))->xuv_uv);		\
         }))
#    define SvNVX(sv)							\
        (*({ const SV *const _svnvx = (const SV *)(sv);			\
            assert(PL_valid_types_NVX[SvTYPE(_svnvx) & SVt_MASK]);	\
            assert(!isGV_with_GP(_svnvx));				\
            &(((XPVNV*) MUTABLE_PTR(SvANY(_svnvx)))->xnv_u.xnv_nv);	\
         }))
#    define SvRV(sv)							\
        (*({ SV *const _svrv = MUTABLE_SV(sv);				\
            assert(PL_valid_types_RV[SvTYPE(_svrv) & SVt_MASK]);	\
            assert(!isGV_with_GP(_svrv));				\
            assert(!(SvTYPE(_svrv) == SVt_PVIO				\
                     && !(IoFLAGS(_svrv) & IOf_FAKE_DIRP)));		\
            &((_svrv)->sv_u.svu_rv);					\
         }))
#    define SvRV_const(sv)						\
        ({ const SV *const _svrv = (const SV *)(sv);			\
            assert(PL_valid_types_RV[SvTYPE(_svrv) & SVt_MASK]);	\
            assert(!isGV_with_GP(_svrv));				\
            assert(!(SvTYPE(_svrv) == SVt_PVIO				\
                     && !(IoFLAGS(_svrv) & IOf_FAKE_DIRP)));		\
            (_svrv)->sv_u.svu_rv;					\
         })
#    define SvMAGIC(sv)							\
        (*({ const SV *const _svmagic = (const SV *)(sv);		\
            assert(SvTYPE(_svmagic) >= SVt_PVMG);			\
            &(((XPVMG*) MUTABLE_PTR(SvANY(_svmagic)))->xmg_u.xmg_magic); \
          }))
#    define SvSTASH(sv)							\
        (*({ const SV *const _svstash = (const SV *)(sv);		\
            assert(SvTYPE(_svstash) >= SVt_PVMG);			\
            &(((XPVMG*) MUTABLE_PTR(SvANY(_svstash)))->xmg_stash);	\
          }))
#  else     /* Below is not DEBUGGING or can't use brace groups */
#    define SvPVX(sv) ((sv)->sv_u.svu_pv)
#    define SvCUR(sv) ((XPV*) SvANY(sv))->xpv_cur
#    define SvIVX(sv) ((XPVIV*) SvANY(sv))->xiv_iv
#    define SvUVX(sv) ((XPVUV*) SvANY(sv))->xuv_uv
#    define SvNVX(sv) ((XPVNV*) SvANY(sv))->xnv_u.xnv_nv
#    define SvRV(sv) ((sv)->sv_u.svu_rv)
#    define SvRV_const(sv) (0 + (sv)->sv_u.svu_rv)
#    define SvMAGIC(sv)	((XPVMG*)  SvANY(sv))->xmg_u.xmg_magic
#    define SvSTASH(sv)	((XPVMG*)  SvANY(sv))->xmg_stash
#  endif
#endif

#ifndef PERL_POISON
/* Given that these two are new, there can't be any existing code using them
 *  as LVALUEs, so prevent that from happening  */
#  define SvPVX_mutable(sv)	((char *)((sv)->sv_u.svu_pv))
#  define SvPVX_const(sv)	((const char*)((sv)->sv_u.svu_pv))
#else
/* Except for the poison code, which uses & to scribble over the pointer after
   free() is called.  */
#  define SvPVX_mutable(sv)	((sv)->sv_u.svu_pv)
#  define SvPVX_const(sv)	((const char*)((sv)->sv_u.svu_pv))
#endif

#define SvIVXx(sv) SvIVX(sv)
#define SvUVXx(sv) SvUVX(sv)
#define SvNVXx(sv) SvNVX(sv)
#define SvPVXx(sv) SvPVX(sv)
#define SvLENx(sv) SvLEN(sv)
#define SvENDx(sv) ((PL_Sv = (sv)), SvEND(PL_Sv))


/* Ask a scalar nicely to try to become an IV, if possible.
   Not guaranteed to stay returning void */
/* Macro won't actually call sv_2iv if already IOK */
#define SvIV_please(sv) \
        STMT_START {                                                        \
            SV * sv_ = MUTABLE_SV(sv);                                      \
            if (!SvIOKp(sv_) && (SvFLAGS(sv_) & (SVf_NOK|SVf_POK)))         \
                (void) SvIV(sv_);                                           \
        } STMT_END
#define SvIV_please_nomg(sv) \
        (!(SvFLAGS(sv) & (SVf_IOK|SVp_IOK)) && (SvFLAGS(sv) & (SVf_NOK|SVf_POK)) \
            ? (sv_2iv_flags(sv, 0), SvIOK(sv))	  \
            : SvIOK(sv))

#define SvIV_set(sv, val) \
        STMT_START { \
                SV * sv_ = MUTABLE_SV(sv);                                  \
                assert(PL_valid_types_IV_set[SvTYPE(sv_) & SVt_MASK]);      \
                assert(!isGV_with_GP(sv_));                                 \
                (((XPVIV*)  SvANY(sv_))->xiv_iv = (val));                   \
        } STMT_END

#define SvNV_set(sv, val) \
        STMT_START { \
                SV * sv_ = MUTABLE_SV(sv);                                  \
                assert(PL_valid_types_NV_set[SvTYPE(sv_) & SVt_MASK]);      \
                assert(!isGV_with_GP(sv_));                                 \
                (((XPVNV*)SvANY(sv_))->xnv_u.xnv_nv = (val));               \
        } STMT_END

#define SvPV_set(sv, val) \
        STMT_START { \
                SV * sv_ = MUTABLE_SV(sv);                                  \
                assert(PL_valid_types_PVX[SvTYPE(sv_) & SVt_MASK]);         \
                assert(!isGV_with_GP(sv_));		                    \
                assert(!(SvTYPE(sv_) == SVt_PVIO		            \
                     && !(IoFLAGS(sv_) & IOf_FAKE_DIRP)));                  \
                ((sv_)->sv_u.svu_pv = (val));                               \
        } STMT_END

#define SvUV_set(sv, val) \
        STMT_START { \
                SV * sv_ = MUTABLE_SV(sv);                                  \
                assert(PL_valid_types_IV_set[SvTYPE(sv_) & SVt_MASK]);	    \
                assert(!isGV_with_GP(sv_));		                    \
                (((XPVUV*)SvANY(sv_))->xuv_uv = (val));                     \
        } STMT_END

#define SvRV_set(sv, val) \
        STMT_START { \
                SV * sv_ = MUTABLE_SV(sv);                                  \
                assert(PL_valid_types_RV[SvTYPE(sv_) & SVt_MASK]);	    \
                assert(!isGV_with_GP(sv_));		                    \
                assert(!(SvTYPE(sv_) == SVt_PVIO		            \
                     && !(IoFLAGS(sv_) & IOf_FAKE_DIRP)));                  \
                ((sv_)->sv_u.svu_rv = (val));                               \
        } STMT_END
#define SvMAGIC_set(sv, val) \
        STMT_START { assert(SvTYPE(sv) >= SVt_PVMG); \
                (((XPVMG*)SvANY(sv))->xmg_u.xmg_magic = (val)); } STMT_END
#define SvSTASH_set(sv, val) \
        STMT_START { assert(SvTYPE(sv) >= SVt_PVMG); \
                (((XPVMG*)  SvANY(sv))->xmg_stash = (val)); } STMT_END
#define SvCUR_set(sv, val) \
        STMT_START { \
                assert(PL_valid_types_PVX[SvTYPE(sv) & SVt_MASK]);	\
                assert(!isGV_with_GP(sv));		\
                assert(!(SvTYPE(sv) == SVt_PVIO		\
                     && !(IoFLAGS(sv) & IOf_FAKE_DIRP))); \
                (((XPV*)  SvANY(sv))->xpv_cur = (val)); } STMT_END
#define SvLEN_set(sv, val) \
        STMT_START { \
                assert(PL_valid_types_PVX[SvTYPE(sv) & SVt_MASK]);	\
                assert(!isGV_with_GP(sv));	\
                assert(!(SvTYPE(sv) == SVt_PVIO		\
                     && !(IoFLAGS(sv) & IOf_FAKE_DIRP))); \
                (((XPV*)  SvANY(sv))->xpv_len = (val)); } STMT_END
#define SvEND_set(sv, val) \
        STMT_START { assert(SvTYPE(sv) >= SVt_PV); \
                SvCUR_set(sv, (val) - SvPVX(sv)); } STMT_END

/*
=for apidoc Am|void|SvPV_renew|SV* sv|STRLEN len
Low level micro optimization of C<L</SvGROW>>.  It is generally better to use
C<SvGROW> instead.  This is because C<SvPV_renew> ignores potential issues that
C<SvGROW> handles.  C<sv> needs to have a real C<PV> that is unencumbered by
things like COW.  Using C<SV_CHECK_THINKFIRST> or
C<SV_CHECK_THINKFIRST_COW_DROP> before calling this should clean it up, but
why not just use C<SvGROW> if you're not sure about the provenance?

=cut
*/
#define SvPV_renew(sv,n) \
        STMT_START { SvLEN_set(sv, n); \
                SvPV_set((sv), (MEM_WRAP_CHECK_(n,char)			\
                                (char*)saferealloc((Malloc_t)SvPVX(sv), \
                                                   (MEM_SIZE)((n)))));  \
                 } STMT_END
/*
=for apidoc Am|void|SvPV_shrink_to_cur|SV* sv

Trim any trailing unused memory in the PV of C<sv>, which needs to have a real
C<PV> that is unencumbered by things like COW.  Think first before using this
functionality.  Is the space saving really worth giving up COW?  Will the
needed size of C<sv> stay the same?

If the answers are both yes, then use L</C<SV_CHECK_THINKFIRST>> or
L</C<SV_CHECK_THINKFIRST_COW_DROP>> before calling this.

=cut
*/

#define SvPV_shrink_to_cur(sv) STMT_START { \
                   const STRLEN _lEnGtH = SvCUR(sv) + 1; \
                   SvPV_renew(sv, _lEnGtH); \
                 } STMT_END

/*
=for apidoc Am|void|SvPV_free|SV * sv

Frees the PV buffer in C<sv>, leaving things in a precarious state, so should
only be used as part of a larger operation

=cut
*/
#define SvPV_free(sv)							\
    STMT_START {							\
                     assert(SvTYPE(sv) >= SVt_PV);			\
                     if (SvLEN(sv)) {					\
                         assert(!SvROK(sv));				\
                         if(UNLIKELY(SvOOK(sv))) {			\
                             STRLEN zok; 				\
                             SvOOK_offset(sv, zok);			\
                             SvPV_set(sv, SvPVX_mutable(sv) - zok);	\
                             SvFLAGS(sv) &= ~SVf_OOK;			\
                         }						\
                         Safefree(SvPVX(sv));				\
                     }							\
                 } STMT_END

#ifdef PERL_CORE
/* Code that crops up in three places to take a scalar and ready it to hold
   a reference */
#  define prepare_SV_for_RV(sv)						\
    STMT_START {							\
                    if (SvTYPE(sv) < SVt_PV && SvTYPE(sv) != SVt_IV)	\
                        sv_upgrade(sv, SVt_IV);				\
                    else if (SvTYPE(sv) >= SVt_PV) {			\
                        SvPV_free(sv);					\
                        SvLEN_set(sv, 0);				\
                        SvCUR_set(sv, 0);				\
                    }							\
                 } STMT_END
#endif

#ifndef PERL_CORE
#  define BmFLAGS(sv)		(SvTAIL(sv) ? FBMcf_TAIL : 0)
#endif

#if defined (DEBUGGING) && defined(PERL_USE_GCC_BRACE_GROUPS)
#  define BmUSEFUL(sv)							\
        (*({ SV *const _bmuseful = MUTABLE_SV(sv);			\
            assert(SvTYPE(_bmuseful) >= SVt_PVIV);			\
            assert(SvVALID(_bmuseful));					\
            assert(!SvIOK(_bmuseful));					\
            &(((XPVIV*) SvANY(_bmuseful))->xiv_u.xivu_iv);              \
         }))
#else
#  define BmUSEFUL(sv)          ((XPVIV*) SvANY(sv))->xiv_u.xivu_iv

#endif

#ifndef PERL_CORE
# define BmRARE(sv)	0
# define BmPREVIOUS(sv)	0
#endif

#define FmLINES(sv)	((XPVIV*)  SvANY(sv))->xiv_iv

#define LvTYPE(sv)	((XPVLV*)  SvANY(sv))->xlv_type
#define LvTARG(sv)	((XPVLV*)  SvANY(sv))->xlv_targ
#define LvTARGOFF(sv)	((XPVLV*)  SvANY(sv))->xlv_targoff
#define LvSTARGOFF(sv)	((XPVLV*)  SvANY(sv))->xlv_targoff_u.xlvu_stargoff
#define LvTARGLEN(sv)	((XPVLV*)  SvANY(sv))->xlv_targlen
#define LvFLAGS(sv)	((XPVLV*)  SvANY(sv))->xlv_flags

#define LVf_NEG_OFF      0x1
#define LVf_NEG_LEN      0x2
#define LVf_OUT_OF_RANGE 0x4

#define IoIFP(sv)	(sv)->sv_u.svu_fp
#define IoOFP(sv)	((XPVIO*)  SvANY(sv))->xio_ofp
#define IoDIRP(sv)	((XPVIO*)  SvANY(sv))->xio_dirp
#define IoANY(sv)	((XPVIO*)  SvANY(sv))->xio_any
#define IoLINES(sv)	((XPVIO*)  SvANY(sv))->xiv_u.xivu_iv
#define IoPAGE(sv)	((XPVIO*)  SvANY(sv))->xio_page
#define IoPAGE_LEN(sv)	((XPVIO*)  SvANY(sv))->xio_page_len
#define IoLINES_LEFT(sv)((XPVIO*)  SvANY(sv))->xio_lines_left
#define IoTOP_NAME(sv)	((XPVIO*)  SvANY(sv))->xio_top_name
#define IoTOP_GV(sv)	((XPVIO*)  SvANY(sv))->xio_top_gv
#define IoFMT_NAME(sv)	((XPVIO*)  SvANY(sv))->xio_fmt_name
#define IoFMT_GV(sv)	((XPVIO*)  SvANY(sv))->xio_fmt_gv
#define IoBOTTOM_NAME(sv)((XPVIO*) SvANY(sv))->xio_bottom_name
#define IoBOTTOM_GV(sv)	((XPVIO*)  SvANY(sv))->xio_bottom_gv
#define IoTYPE(sv)	((XPVIO*)  SvANY(sv))->xio_type
#define IoFLAGS(sv)	((XPVIO*)  SvANY(sv))->xio_flags

/* IoTYPE(sv) is a single character telling the type of I/O connection. */
#define IoTYPE_RDONLY		'<'
#define IoTYPE_WRONLY		'>'
#define IoTYPE_RDWR		'+'
#define IoTYPE_APPEND 		'a'
#define IoTYPE_PIPE		'|'
#define IoTYPE_STD		'-'	/* stdin or stdout */
#define IoTYPE_SOCKET		's'
#define IoTYPE_CLOSED		' '
#define IoTYPE_IMPLICIT		'I'	/* stdin or stdout or stderr */
#define IoTYPE_NUMERIC		'#'	/* fdopen */

/*
=for apidoc_section $tainting
=for apidoc Am|bool|SvTAINTED|SV* sv
Checks to see if an SV is tainted.  Returns TRUE if it is, FALSE if
not.

=for apidoc Am|void|SvTAINTED_on|SV* sv
Marks an SV as tainted if tainting is enabled.

=for apidoc Am|void|SvTAINTED_off|SV* sv
Untaints an SV.  Be I<very> careful with this routine, as it short-circuits
some of Perl's fundamental security features.  XS module authors should not
use this function unless they fully understand all the implications of
unconditionally untainting the value.  Untainting should be done in the
standard perl fashion, via a carefully crafted regexp, rather than directly
untainting variables.

=for apidoc Am|void|SvTAINT|SV* sv
Taints an SV if tainting is enabled, and if some input to the current
expression is tainted--usually a variable, but possibly also implicit
inputs such as locale settings.  C<SvTAINT> propagates that taintedness to
the outputs of an expression in a pessimistic fashion; i.e., without paying
attention to precisely which outputs are influenced by which inputs.

=cut
*/
